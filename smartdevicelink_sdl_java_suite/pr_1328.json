{"pr_number": 1328, "pr_title": "Inconsistencies in ScreenManager behavior if displayCapabilities is null & revisions", "pr_author": "bilal-alsharifi", "pr_createdAt": "2020-04-02T15:24:33Z", "pr_url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328", "merge_commit": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "timeline": [{"oid": "116310d0c6887ed19fc2f7c433e3d15a92945c22", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/116310d0c6887ed19fc2f7c433e3d15a92945c22", "message": "Fixed WindowCapability logic in BaseText and graphic manager", "committedDate": "2020-03-19T16:07:54Z", "type": "commit"}, {"oid": "fcf53125f5f2337063b90e0906436f49e3d1bd1b", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/fcf53125f5f2337063b90e0906436f49e3d1bd1b", "message": "Fixed spacing", "committedDate": "2020-03-19T16:13:12Z", "type": "commit"}, {"oid": "53da44d5a6cd6d49ff4ff018f0e509363eb9ef15", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/53da44d5a6cd6d49ff4ff018f0e509363eb9ef15", "message": "Made to look like IOS", "committedDate": "2020-03-19T19:26:08Z", "type": "commit"}, {"oid": "11ed30768b2d5438b47c8dcb249e0f607b5ddb79", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/11ed30768b2d5438b47c8dcb249e0f607b5ddb79", "message": "Merge branch 'develop' into bugfix/issue_1310", "committedDate": "2020-03-20T20:00:11Z", "type": "commit"}, {"oid": "bd7112bc97bbc95bd92dc0b8e529f721c89d7b8c", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/bd7112bc97bbc95bd92dc0b8e529f721c89d7b8c", "message": "Remove unnecessary check", "committedDate": "2020-03-20T20:29:39Z", "type": "commit"}, {"oid": "d23deada8e8b224a20b69b990d6d521f7a09a3a9", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/d23deada8e8b224a20b69b990d6d521f7a09a3a9", "message": "Fixed unit test", "committedDate": "2020-03-20T20:53:05Z", "type": "commit"}, {"oid": "bdf850d41c1bcaeceac672e2645000df78cab78a", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/bdf850d41c1bcaeceac672e2645000df78cab78a", "message": "Added three methods to WindowCapability  to be used in managers of the ScreenManager\n\nhasImageFieldOfName,  hasTextFieldOfName, getMaxNumberOfMainFieldLines", "committedDate": "2020-03-25T20:50:47Z", "type": "commit"}, {"oid": "9ad10826080a790a289ad65dc50ceb94549b23ea", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/9ad10826080a790a289ad65dc50ceb94549b23ea", "message": "Aligned how java uses WindowCapability  in TextAndGraphicManager  with IOS", "committedDate": "2020-03-25T21:12:05Z", "type": "commit"}, {"oid": "765e47d5e6ad8a3f15e9e8b26f36bc496f973567", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/765e47d5e6ad8a3f15e9e8b26f36bc496f973567", "message": "removed redudant checks in BaseTextAndGraphicManager", "committedDate": "2020-03-26T16:43:24Z", "type": "commit"}, {"oid": "09fcf0f743b7dca4075aeefd548e9b3c4b9b76c7", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/09fcf0f743b7dca4075aeefd548e9b3c4b9b76c7", "message": "Updated MenuManager handling of WindowCapability to align with IOS", "committedDate": "2020-03-26T19:18:04Z", "type": "commit"}, {"oid": "59570247015a05d9b50bb40aa1b023ab22636798", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/59570247015a05d9b50bb40aa1b023ab22636798", "message": "Added ManagerUtility to extend capabilities of WindowCapability, Removed added methods from WindowCapability and added them to ManagerUtility.WindowCapabilityUtility", "committedDate": "2020-03-27T14:58:30Z", "type": "commit"}, {"oid": "52961a90dfb932598a09938f280afc9f58dfec0a", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/52961a90dfb932598a09938f280afc9f58dfec0a", "message": "Deprecated hasTextFieldOfName and hasImageFieldOfName, changed where they were used to use ManagerUtility.WindowCapability methods", "committedDate": "2020-03-27T15:22:28Z", "type": "commit"}, {"oid": "153f02cc27178335306bf76f721e8683c41acfb1", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/153f02cc27178335306bf76f721e8683c41acfb1", "message": "Changed logic to use new Class and methods in ManagerUtility.WindowCapabilityUtility", "committedDate": "2020-03-27T15:25:00Z", "type": "commit"}, {"oid": "08dc7ac1e4a295a75c1a0f217e18714b68a81e31", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/08dc7ac1e4a295a75c1a0f217e18714b68a81e31", "message": "Moved ManagerUtility class and created symlink", "committedDate": "2020-03-27T16:54:32Z", "type": "commit"}, {"oid": "3343aa6cf322504a7a27916fdff870bbe3d43571", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3343aa6cf322504a7a27916fdff870bbe3d43571", "message": "Fixing imports for ManagerUtility", "committedDate": "2020-03-27T18:19:35Z", "type": "commit"}, {"oid": "ae388d20cb559419a045208052be47ad149ad8c5", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/ae388d20cb559419a045208052be47ad149ad8c5", "message": "Removed Method that was added by mistake", "committedDate": "2020-03-27T18:33:11Z", "type": "commit"}, {"oid": "97f081340b9441226b76118a76563c896c6ab299", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/97f081340b9441226b76118a76563c896c6ab299", "message": "removed unused import", "committedDate": "2020-03-27T19:13:30Z", "type": "commit"}, {"oid": "165da413a858ebc8bca20d48b4eac8dec9e33c52", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/165da413a858ebc8bca20d48b4eac8dec9e33c52", "message": "Moved this class to base managers", "committedDate": "2020-03-27T19:17:21Z", "type": "commit"}, {"oid": "f1e233d5a2a97f591843d4e6b94b26957370ee42", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/f1e233d5a2a97f591843d4e6b94b26957370ee42", "message": "Fixed logic for unit test", "committedDate": "2020-03-27T20:05:46Z", "type": "commit"}, {"oid": "a094e7ac754bc540316d712863fcacb129394fe3", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/a094e7ac754bc540316d712863fcacb129394fe3", "message": "Fixed preloadChoicOperation logic for WindowCapability", "committedDate": "2020-03-27T20:58:04Z", "type": "commit"}, {"oid": "838a524fa0d3d9bf83b9d540b0f1d3c05fc1ec79", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/838a524fa0d3d9bf83b9d540b0f1d3c05fc1ec79", "message": "Added check back that checks if capability is null", "committedDate": "2020-03-29T23:04:56Z", "type": "commit"}, {"oid": "4f7cab824d6d8a5d87fc9c80ca3d50a4b25c31bc", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/4f7cab824d6d8a5d87fc9c80ca3d50a4b25c31bc", "message": "Fixed Test for MenuManager: testSetMenuConfiguration", "committedDate": "2020-03-29T23:24:19Z", "type": "commit"}, {"oid": "3e62843b558c60cae3046cb76dacb9d5b7358110", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3e62843b558c60cae3046cb76dacb9d5b7358110", "message": "Added test for nonNullCapability", "committedDate": "2020-03-30T13:09:11Z", "type": "commit"}, {"oid": "dff4bc53989d8f2caf2f5eca60c132d7d9602b38", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/dff4bc53989d8f2caf2f5eca60c132d7d9602b38", "message": "Fixed unit Test for TextandGraphicManager", "committedDate": "2020-03-30T14:36:17Z", "type": "commit"}, {"oid": "eb4efc5aaa40e0fa70d1972538f18a45d78fdbb4", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/eb4efc5aaa40e0fa70d1972538f18a45d78fdbb4", "message": "Adding javaDocs", "committedDate": "2020-03-30T15:12:43Z", "type": "commit"}, {"oid": "45c8c3bc4814b69229a17be2f3079aa86f6b44dd", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/45c8c3bc4814b69229a17be2f3079aa86f6b44dd", "message": "Added unit test to PreloadChoicesOperation", "committedDate": "2020-03-30T16:43:24Z", "type": "commit"}, {"oid": "0af803c2a248dcd423d20f05aed055b052df7b34", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/0af803c2a248dcd423d20f05aed055b052df7b34", "message": "Removed old test that get covered in newly added test testShouldSendText", "committedDate": "2020-03-30T16:55:21Z", "type": "commit"}, {"oid": "b7a30c2dcbb7fe62013f1d94a2b1c2863be47842", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/b7a30c2dcbb7fe62013f1d94a2b1c2863be47842", "message": "Removed unused imports", "committedDate": "2020-03-30T17:13:40Z", "type": "commit"}, {"oid": "eae8aa958b27737146d7781c90563a15f4d3d85b", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/eae8aa958b27737146d7781c90563a15f4d3d85b", "message": "Update getMaxNumberOfMainFieldLines to align with iOS", "committedDate": "2020-04-02T14:15:41Z", "type": "commit"}, {"oid": "13844194574ca4c1d8307684523a30cd54a43d36", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/13844194574ca4c1d8307684523a30cd54a43d36", "message": "Update ManagerUtility formatting", "committedDate": "2020-04-02T14:26:15Z", "type": "commit"}, {"oid": "f4e5c312044e3a97daa865a54a9ed628174dba3f", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/f4e5c312044e3a97daa865a54a9ed628174dba3f", "message": "Update T&G manager capability handling to align with iOS", "committedDate": "2020-04-02T15:20:31Z", "type": "commit"}, {"oid": "2f66c5c56d45801a6313d25d14f0939ca228147d", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/2f66c5c56d45801a6313d25d14f0939ca228147d", "message": "Update supportsImages", "committedDate": "2020-04-02T19:18:18Z", "type": "commit"}, {"oid": "c744b2d7d4902ed0ff9a6b8ecc2695be6cd3d901", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/c744b2d7d4902ed0ff9a6b8ecc2695be6cd3d901", "message": "Update setMenuConfiguration", "committedDate": "2020-04-02T19:44:47Z", "type": "commit"}, {"oid": "0d735b1079bed06c6c400991e9b0f758e7b30d5f", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/0d735b1079bed06c6c400991e9b0f758e7b30d5f", "message": "Update ChoiceSetManager capability handling", "committedDate": "2020-04-02T21:00:57Z", "type": "commit"}, {"oid": "3c99b27d2600a3dfa1ce16011d012c9ed45f7b03", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3c99b27d2600a3dfa1ce16011d012c9ed45f7b03", "message": "Fix ChoiceSetManager unit tests", "committedDate": "2020-04-03T13:37:12Z", "type": "commit"}, {"oid": "0cbcceac20dd4bf179f3ac42021e9364849e61c2", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/0cbcceac20dd4bf179f3ac42021e9364849e61c2", "message": "Fixing space issue", "committedDate": "2020-04-03T16:45:26Z", "type": "commit"}, {"oid": "9761aab7668d3546efd0750f9c276efb1925daa2", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/9761aab7668d3546efd0750f9c276efb1925daa2", "message": "Remove some duplicate code from TextAndGraphicManager", "committedDate": "2020-04-08T14:35:27Z", "type": "commit"}, {"oid": "0f045661724a7100fbb6890a3277da46aed3a36d", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/0f045661724a7100fbb6890a3277da46aed3a36d", "message": "Remove duplicate code from PreloadChoicesOperation", "committedDate": "2020-04-08T14:45:56Z", "type": "commit"}, {"oid": "40ed2d11522da4529c645b5df05df0fedd8769e1", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/40ed2d11522da4529c645b5df05df0fedd8769e1", "message": "Simplify some helper methods in screen manager", "committedDate": "2020-04-08T15:14:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI2OTEyMA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406269120", "body": "```suggestion\r\n            if (windowCapability == null || name == null) {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (windowCapability == null) {\n          \n          \n            \n                        if (windowCapability == null || name == null) {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">if</span> (windowCapability <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">if</span> (windowCapability <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span><span class=\"x x-first\"> </span><span class=\"pl-k x\">||</span><span class=\"x\"> name </span><span class=\"pl-k x\">==</span><span class=\"x\"> </span><span class=\"pl-c1 x x-last\">null</span>) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "joeygrover", "createdAt": "2020-04-09T15:00:27Z", "path": "base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.smartdevicelink.managers;\n+\n+import com.smartdevicelink.proxy.rpc.ImageField;\n+import com.smartdevicelink.proxy.rpc.TextField;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ImageFieldName;\n+import com.smartdevicelink.proxy.rpc.enums.TextFieldName;\n+\n+/**\n+ * <strong>ManagerUtility</strong> <br>\n+ * <p>\n+ * Static Methods to be used throughout the Manager classes <br>\n+ */\n+public class ManagerUtility {\n+\n+    public static class WindowCapabilityUtility {\n+\n+        /**\n+         * Check to see if WindowCapability has an ImageFieldName of a given name.\n+         *\n+         * @param windowCapability WindowCapability representing the capabilities of the desired window\n+         * @param name ImageFieldName representing a name of a given Image field that would be stored in WindowCapability\n+         * @return true if name exist in WindowCapability else false\n+         */\n+        public static boolean hasImageFieldOfName(WindowCapability windowCapability, ImageFieldName name) {\n+            if (windowCapability == null) {", "originalCommit": "40ed2d11522da4529c645b5df05df0fedd8769e1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5d271d43ad21b23e3437e4d19c5f1aff75994936", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 4bd26697c..62942918e 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -23,7 +23,7 @@ public class ManagerUtility {\n          * @return true if name exist in WindowCapability else false\n          */\n         public static boolean hasImageFieldOfName(WindowCapability windowCapability, ImageFieldName name) {\n-            if (windowCapability == null) {\n+            if (windowCapability == null || name == null) {\n                 return false;\n             }\n             if (windowCapability.getImageFields() != null) {\n", "next_change": {"commit": "f0e56e34018c6ec4b8fb0cd469456b8c2397b882", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 62942918e..7889af38e 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -28,7 +28,7 @@ public class ManagerUtility {\n             }\n             if (windowCapability.getImageFields() != null) {\n                 for (ImageField field : windowCapability.getImageFields()) {\n-                    if (field != null && field.getName() != null && field.getName().equals(name)) {\n+                    if (field != null && name.equals(field.getName())) {\n                         return true;\n                     }\n                 }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 4bd26697c..6a2da0e39 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -23,12 +23,12 @@ public class ManagerUtility {\n          * @return true if name exist in WindowCapability else false\n          */\n         public static boolean hasImageFieldOfName(WindowCapability windowCapability, ImageFieldName name) {\n-            if (windowCapability == null) {\n+            if (windowCapability == null || name == null) {\n                 return false;\n             }\n             if (windowCapability.getImageFields() != null) {\n                 for (ImageField field : windowCapability.getImageFields()) {\n-                    if (field != null && field.getName() != null && field.getName().equals(name)) {\n+                    if (field != null && name.equals(field.getName())) {\n                         return true;\n                     }\n                 }\n", "next_change": {"commit": "9829fb3228e8bd8a38a67a32a3666fcc45acf066", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 6a2da0e39..f9910032c 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -22,14 +28,17 @@ public class ManagerUtility {\n          * @param name ImageFieldName representing a name of a given Image field that would be stored in WindowCapability\n          * @return true if name exist in WindowCapability else false\n          */\n-        public static boolean hasImageFieldOfName(WindowCapability windowCapability, ImageFieldName name) {\n+        public static boolean hasImageFieldOfName(final WindowCapability windowCapability, final ImageFieldName name) {\n             if (windowCapability == null || name == null) {\n                 return false;\n             }\n             if (windowCapability.getImageFields() != null) {\n-                for (ImageField field : windowCapability.getImageFields()) {\n-                    if (field != null && name.equals(field.getName())) {\n-                        return true;\n+                List<ImageField> imageFields = windowCapability.getImageFields();\n+                if(imageFields != null && imageFields.size() > 0) {\n+                    for (ImageField field : imageFields) {\n+                        if (field != null && name.equals(field.getName())) {\n+                            return true;\n+                        }\n                     }\n                 }\n             }\n", "next_change": {"commit": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex f9910032c..b5ad249bb 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -34,7 +34,7 @@ public class ManagerUtility {\n             }\n             if (windowCapability.getImageFields() != null) {\n                 List<ImageField> imageFields = windowCapability.getImageFields();\n-                if(imageFields != null && imageFields.size() > 0) {\n+                if (imageFields != null && imageFields.size() > 0) {\n                     for (ImageField field : imageFields) {\n                         if (field != null && name.equals(field.getName())) {\n                             return true;\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "message": "Merge commit", "committedDate": null}, {"oid": "4c5fb6bcf05020314ae7585f10eaf9d09a07b3b7", "committedDate": "2020-05-20 17:10:14 -0400", "message": "Add utility to support all Image and Text Types"}, {"oid": "98809c89f50800fe4fb773ecdf45f49463cd8c0f", "committedDate": "2020-05-29 09:36:49 -0400", "message": "Add Javadocs change max row number"}, {"oid": "c1c55c127ac3c46252994c42161031c9da6f56b1", "committedDate": "2020-07-29 15:53:48 -0400", "message": "Update Tests and replace CID2SET references"}, {"oid": "9829fb3228e8bd8a38a67a32a3666fcc45acf066", "committedDate": "2020-09-02 12:08:17 -0400", "message": "Fix potential NPEs in ManagerUtility class"}, {"oid": "316494bc3a149db2016dbfb73b79e7941a53e725", "committedDate": "2020-09-14 16:29:18 -0400", "message": "Add check to prevent NPE"}, {"oid": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "committedDate": "2020-09-17 16:31:17 -0400", "message": "Run the Reformat Code tool on the project"}, {"oid": "af9d766dcee36cca42a3563a149b4623f04ae688", "committedDate": "2021-03-05 11:47:00 -0500", "message": "Screen manager alert manager (#1555)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI3MDE3OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406270179", "body": "```suggestion\r\n                    if (field != null && name.equals(field.getName())) {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (field != null && field.getName() != null && field.getName().equals(name)) {\n          \n          \n            \n                                if (field != null && name.equals(field.getName())) {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    <span class=\"pl-k\">if</span> (field <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span> <span class=\"pl-k\">&amp;&amp;</span> <span class=\"x x-first\">field</span><span class=\"pl-k x\">.</span><span class=\"x\">getName() </span><span class=\"pl-k x\">!=</span><span class=\"x\"> </span><span class=\"pl-c1 x\">null</span><span class=\"x\"> </span><span class=\"pl-k x\">&amp;&amp;</span><span class=\"x x-last\"> </span>field<span class=\"pl-k\">.</span>getName()<span class=\"pl-k x x-first\">.</span><span class=\"x x-last\">equals(name</span>)) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    <span class=\"pl-k\">if</span> (field <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span> <span class=\"pl-k\">&amp;&amp;</span> <span class=\"x x-first\">name</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">equals(</span>field<span class=\"pl-k\">.</span>getName())) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "joeygrover", "createdAt": "2020-04-09T15:02:01Z", "path": "base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.smartdevicelink.managers;\n+\n+import com.smartdevicelink.proxy.rpc.ImageField;\n+import com.smartdevicelink.proxy.rpc.TextField;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ImageFieldName;\n+import com.smartdevicelink.proxy.rpc.enums.TextFieldName;\n+\n+/**\n+ * <strong>ManagerUtility</strong> <br>\n+ * <p>\n+ * Static Methods to be used throughout the Manager classes <br>\n+ */\n+public class ManagerUtility {\n+\n+    public static class WindowCapabilityUtility {\n+\n+        /**\n+         * Check to see if WindowCapability has an ImageFieldName of a given name.\n+         *\n+         * @param windowCapability WindowCapability representing the capabilities of the desired window\n+         * @param name ImageFieldName representing a name of a given Image field that would be stored in WindowCapability\n+         * @return true if name exist in WindowCapability else false\n+         */\n+        public static boolean hasImageFieldOfName(WindowCapability windowCapability, ImageFieldName name) {\n+            if (windowCapability == null) {\n+                return false;\n+            }\n+            if (windowCapability.getImageFields() != null) {\n+                for (ImageField field : windowCapability.getImageFields()) {\n+                    if (field != null && field.getName() != null && field.getName().equals(name)) {", "originalCommit": "40ed2d11522da4529c645b5df05df0fedd8769e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI3MDY0Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406270642", "bodyText": "If we add the null check to name above, we can avoid the null check to field.getName().", "author": "joeygrover", "createdAt": "2020-04-09T15:02:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI3MDE3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "5d271d43ad21b23e3437e4d19c5f1aff75994936", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 4bd26697c..62942918e 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -23,7 +23,7 @@ public class ManagerUtility {\n          * @return true if name exist in WindowCapability else false\n          */\n         public static boolean hasImageFieldOfName(WindowCapability windowCapability, ImageFieldName name) {\n-            if (windowCapability == null) {\n+            if (windowCapability == null || name == null) {\n                 return false;\n             }\n             if (windowCapability.getImageFields() != null) {\n", "next_change": {"commit": "f0e56e34018c6ec4b8fb0cd469456b8c2397b882", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 62942918e..7889af38e 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -28,7 +28,7 @@ public class ManagerUtility {\n             }\n             if (windowCapability.getImageFields() != null) {\n                 for (ImageField field : windowCapability.getImageFields()) {\n-                    if (field != null && field.getName() != null && field.getName().equals(name)) {\n+                    if (field != null && name.equals(field.getName())) {\n                         return true;\n                     }\n                 }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 4bd26697c..6a2da0e39 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -23,12 +23,12 @@ public class ManagerUtility {\n          * @return true if name exist in WindowCapability else false\n          */\n         public static boolean hasImageFieldOfName(WindowCapability windowCapability, ImageFieldName name) {\n-            if (windowCapability == null) {\n+            if (windowCapability == null || name == null) {\n                 return false;\n             }\n             if (windowCapability.getImageFields() != null) {\n                 for (ImageField field : windowCapability.getImageFields()) {\n-                    if (field != null && field.getName() != null && field.getName().equals(name)) {\n+                    if (field != null && name.equals(field.getName())) {\n                         return true;\n                     }\n                 }\n", "next_change": {"commit": "9829fb3228e8bd8a38a67a32a3666fcc45acf066", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 6a2da0e39..f9910032c 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -22,14 +28,17 @@ public class ManagerUtility {\n          * @param name ImageFieldName representing a name of a given Image field that would be stored in WindowCapability\n          * @return true if name exist in WindowCapability else false\n          */\n-        public static boolean hasImageFieldOfName(WindowCapability windowCapability, ImageFieldName name) {\n+        public static boolean hasImageFieldOfName(final WindowCapability windowCapability, final ImageFieldName name) {\n             if (windowCapability == null || name == null) {\n                 return false;\n             }\n             if (windowCapability.getImageFields() != null) {\n-                for (ImageField field : windowCapability.getImageFields()) {\n-                    if (field != null && name.equals(field.getName())) {\n-                        return true;\n+                List<ImageField> imageFields = windowCapability.getImageFields();\n+                if(imageFields != null && imageFields.size() > 0) {\n+                    for (ImageField field : imageFields) {\n+                        if (field != null && name.equals(field.getName())) {\n+                            return true;\n+                        }\n                     }\n                 }\n             }\n", "next_change": {"commit": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex f9910032c..b5ad249bb 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -34,7 +34,7 @@ public class ManagerUtility {\n             }\n             if (windowCapability.getImageFields() != null) {\n                 List<ImageField> imageFields = windowCapability.getImageFields();\n-                if(imageFields != null && imageFields.size() > 0) {\n+                if (imageFields != null && imageFields.size() > 0) {\n                     for (ImageField field : imageFields) {\n                         if (field != null && name.equals(field.getName())) {\n                             return true;\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "message": "Merge commit", "committedDate": null}, {"oid": "4c5fb6bcf05020314ae7585f10eaf9d09a07b3b7", "committedDate": "2020-05-20 17:10:14 -0400", "message": "Add utility to support all Image and Text Types"}, {"oid": "98809c89f50800fe4fb773ecdf45f49463cd8c0f", "committedDate": "2020-05-29 09:36:49 -0400", "message": "Add Javadocs change max row number"}, {"oid": "c1c55c127ac3c46252994c42161031c9da6f56b1", "committedDate": "2020-07-29 15:53:48 -0400", "message": "Update Tests and replace CID2SET references"}, {"oid": "9829fb3228e8bd8a38a67a32a3666fcc45acf066", "committedDate": "2020-09-02 12:08:17 -0400", "message": "Fix potential NPEs in ManagerUtility class"}, {"oid": "316494bc3a149db2016dbfb73b79e7941a53e725", "committedDate": "2020-09-14 16:29:18 -0400", "message": "Add check to prevent NPE"}, {"oid": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "committedDate": "2020-09-17 16:31:17 -0400", "message": "Run the Reformat Code tool on the project"}, {"oid": "af9d766dcee36cca42a3563a149b4623f04ae688", "committedDate": "2021-03-05 11:47:00 -0500", "message": "Screen manager alert manager (#1555)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI3Mjg1Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406272852", "body": "```suggestion\r\n            if (windowCapability == null || name == null) {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (windowCapability == null) {\n          \n          \n            \n                        if (windowCapability == null || name == null) {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">if</span> (windowCapability <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">if</span> (windowCapability <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span><span class=\"x x-first\"> </span><span class=\"pl-k x\">||</span><span class=\"x\"> name </span><span class=\"pl-k x\">==</span><span class=\"x\"> </span><span class=\"pl-c1 x x-last\">null</span>) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "joeygrover", "createdAt": "2020-04-09T15:05:52Z", "path": "base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.smartdevicelink.managers;\n+\n+import com.smartdevicelink.proxy.rpc.ImageField;\n+import com.smartdevicelink.proxy.rpc.TextField;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ImageFieldName;\n+import com.smartdevicelink.proxy.rpc.enums.TextFieldName;\n+\n+/**\n+ * <strong>ManagerUtility</strong> <br>\n+ * <p>\n+ * Static Methods to be used throughout the Manager classes <br>\n+ */\n+public class ManagerUtility {\n+\n+    public static class WindowCapabilityUtility {\n+\n+        /**\n+         * Check to see if WindowCapability has an ImageFieldName of a given name.\n+         *\n+         * @param windowCapability WindowCapability representing the capabilities of the desired window\n+         * @param name ImageFieldName representing a name of a given Image field that would be stored in WindowCapability\n+         * @return true if name exist in WindowCapability else false\n+         */\n+        public static boolean hasImageFieldOfName(WindowCapability windowCapability, ImageFieldName name) {\n+            if (windowCapability == null) {\n+                return false;\n+            }\n+            if (windowCapability.getImageFields() != null) {\n+                for (ImageField field : windowCapability.getImageFields()) {\n+                    if (field != null && field.getName() != null && field.getName().equals(name)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Check to see if WindowCapability has a textField of a given name.\n+         *\n+         * @param windowCapability WindowCapability representing the capabilities of the desired window\n+         * @param name TextFieldName representing a name of a given text field that would be stored in WindowCapability\n+         * @return true if name exist in WindowCapability else false\n+         */\n+        public static boolean hasTextFieldOfName(WindowCapability windowCapability, TextFieldName name) {\n+            if (windowCapability == null) {", "originalCommit": "40ed2d11522da4529c645b5df05df0fedd8769e1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e285d375b2a0ba32798adc84e481bc990a120cc3", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 4bd26697c..ae24e5f54 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -44,7 +44,7 @@ public class ManagerUtility {\n          * @return true if name exist in WindowCapability else false\n          */\n         public static boolean hasTextFieldOfName(WindowCapability windowCapability, TextFieldName name) {\n-            if (windowCapability == null) {\n+            if (windowCapability == null || name == null) {\n                 return false;\n             }\n             if (windowCapability.getTextFields() != null) {\n", "next_change": {"commit": "8fed860092b7e07a891e420a6095b4aeeaa8a9c0", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex ae24e5f54..56f4f0480 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -49,7 +49,7 @@ public class ManagerUtility {\n             }\n             if (windowCapability.getTextFields() != null) {\n                 for (TextField field : windowCapability.getTextFields()) {\n-                    if (field != null && field.getName() != null && field.getName().equals(name)) {\n+                    if (field != null && name.equals(field.getName())) {\n                         return true;\n                     }\n                 }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 4bd26697c..6a2da0e39 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -44,12 +44,12 @@ public class ManagerUtility {\n          * @return true if name exist in WindowCapability else false\n          */\n         public static boolean hasTextFieldOfName(WindowCapability windowCapability, TextFieldName name) {\n-            if (windowCapability == null) {\n+            if (windowCapability == null || name == null) {\n                 return false;\n             }\n             if (windowCapability.getTextFields() != null) {\n                 for (TextField field : windowCapability.getTextFields()) {\n-                    if (field != null && field.getName() != null && field.getName().equals(name)) {\n+                    if (field != null && name.equals(field.getName())) {\n                         return true;\n                     }\n                 }\n", "next_change": {"commit": "9829fb3228e8bd8a38a67a32a3666fcc45acf066", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 6a2da0e39..f9910032c 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -43,14 +52,17 @@ public class ManagerUtility {\n          * @param name TextFieldName representing a name of a given text field that would be stored in WindowCapability\n          * @return true if name exist in WindowCapability else false\n          */\n-        public static boolean hasTextFieldOfName(WindowCapability windowCapability, TextFieldName name) {\n+        public static boolean hasTextFieldOfName(final WindowCapability windowCapability, final TextFieldName name) {\n             if (windowCapability == null || name == null) {\n                 return false;\n             }\n             if (windowCapability.getTextFields() != null) {\n-                for (TextField field : windowCapability.getTextFields()) {\n-                    if (field != null && name.equals(field.getName())) {\n-                        return true;\n+                List<TextField> textFields = windowCapability.getTextFields();\n+                if (textFields != null && textFields.size() > 0) {\n+                    for (TextField field : textFields) {\n+                        if (field != null && name.equals(field.getName())) {\n+                            return true;\n+                        }\n                     }\n                 }\n             }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "message": "Merge commit", "committedDate": null}, {"oid": "4c5fb6bcf05020314ae7585f10eaf9d09a07b3b7", "committedDate": "2020-05-20 17:10:14 -0400", "message": "Add utility to support all Image and Text Types"}, {"oid": "98809c89f50800fe4fb773ecdf45f49463cd8c0f", "committedDate": "2020-05-29 09:36:49 -0400", "message": "Add Javadocs change max row number"}, {"oid": "c1c55c127ac3c46252994c42161031c9da6f56b1", "committedDate": "2020-07-29 15:53:48 -0400", "message": "Update Tests and replace CID2SET references"}, {"oid": "9829fb3228e8bd8a38a67a32a3666fcc45acf066", "committedDate": "2020-09-02 12:08:17 -0400", "message": "Fix potential NPEs in ManagerUtility class"}, {"oid": "316494bc3a149db2016dbfb73b79e7941a53e725", "committedDate": "2020-09-14 16:29:18 -0400", "message": "Add check to prevent NPE"}, {"oid": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "committedDate": "2020-09-17 16:31:17 -0400", "message": "Run the Reformat Code tool on the project"}, {"oid": "af9d766dcee36cca42a3563a149b4623f04ae688", "committedDate": "2021-03-05 11:47:00 -0500", "message": "Screen manager alert manager (#1555)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI3MzIxMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406273211", "body": "```suggestion\r\n                    if (field != null && name.equals(field.getName())) {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (field != null && field.getName() != null && field.getName().equals(name)) {\n          \n          \n            \n                                if (field != null && name.equals(field.getName())) {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    <span class=\"pl-k\">if</span> (field <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span> <span class=\"pl-k\">&amp;&amp;</span> <span class=\"x x-first\">field</span><span class=\"pl-k x\">.</span><span class=\"x\">getName() </span><span class=\"pl-k x\">!=</span><span class=\"x\"> </span><span class=\"pl-c1 x\">null</span><span class=\"x\"> </span><span class=\"pl-k x\">&amp;&amp;</span><span class=\"x x-last\"> </span>field<span class=\"pl-k\">.</span>getName()<span class=\"pl-k x x-first\">.</span><span class=\"x x-last\">equals(name</span>)) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    <span class=\"pl-k\">if</span> (field <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span> <span class=\"pl-k\">&amp;&amp;</span> <span class=\"x x-first\">name</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">equals(</span>field<span class=\"pl-k\">.</span>getName())) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "joeygrover", "createdAt": "2020-04-09T15:06:24Z", "path": "base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.smartdevicelink.managers;\n+\n+import com.smartdevicelink.proxy.rpc.ImageField;\n+import com.smartdevicelink.proxy.rpc.TextField;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ImageFieldName;\n+import com.smartdevicelink.proxy.rpc.enums.TextFieldName;\n+\n+/**\n+ * <strong>ManagerUtility</strong> <br>\n+ * <p>\n+ * Static Methods to be used throughout the Manager classes <br>\n+ */\n+public class ManagerUtility {\n+\n+    public static class WindowCapabilityUtility {\n+\n+        /**\n+         * Check to see if WindowCapability has an ImageFieldName of a given name.\n+         *\n+         * @param windowCapability WindowCapability representing the capabilities of the desired window\n+         * @param name ImageFieldName representing a name of a given Image field that would be stored in WindowCapability\n+         * @return true if name exist in WindowCapability else false\n+         */\n+        public static boolean hasImageFieldOfName(WindowCapability windowCapability, ImageFieldName name) {\n+            if (windowCapability == null) {\n+                return false;\n+            }\n+            if (windowCapability.getImageFields() != null) {\n+                for (ImageField field : windowCapability.getImageFields()) {\n+                    if (field != null && field.getName() != null && field.getName().equals(name)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Check to see if WindowCapability has a textField of a given name.\n+         *\n+         * @param windowCapability WindowCapability representing the capabilities of the desired window\n+         * @param name TextFieldName representing a name of a given text field that would be stored in WindowCapability\n+         * @return true if name exist in WindowCapability else false\n+         */\n+        public static boolean hasTextFieldOfName(WindowCapability windowCapability, TextFieldName name) {\n+            if (windowCapability == null) {\n+                return false;\n+            }\n+            if (windowCapability.getTextFields() != null) {\n+                for (TextField field : windowCapability.getTextFields()) {\n+                    if (field != null && field.getName() != null && field.getName().equals(name)) {", "originalCommit": "40ed2d11522da4529c645b5df05df0fedd8769e1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e285d375b2a0ba32798adc84e481bc990a120cc3", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 4bd26697c..ae24e5f54 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -44,7 +44,7 @@ public class ManagerUtility {\n          * @return true if name exist in WindowCapability else false\n          */\n         public static boolean hasTextFieldOfName(WindowCapability windowCapability, TextFieldName name) {\n-            if (windowCapability == null) {\n+            if (windowCapability == null || name == null) {\n                 return false;\n             }\n             if (windowCapability.getTextFields() != null) {\n", "next_change": {"commit": "8fed860092b7e07a891e420a6095b4aeeaa8a9c0", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex ae24e5f54..56f4f0480 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -49,7 +49,7 @@ public class ManagerUtility {\n             }\n             if (windowCapability.getTextFields() != null) {\n                 for (TextField field : windowCapability.getTextFields()) {\n-                    if (field != null && field.getName() != null && field.getName().equals(name)) {\n+                    if (field != null && name.equals(field.getName())) {\n                         return true;\n                     }\n                 }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 4bd26697c..6a2da0e39 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -44,12 +44,12 @@ public class ManagerUtility {\n          * @return true if name exist in WindowCapability else false\n          */\n         public static boolean hasTextFieldOfName(WindowCapability windowCapability, TextFieldName name) {\n-            if (windowCapability == null) {\n+            if (windowCapability == null || name == null) {\n                 return false;\n             }\n             if (windowCapability.getTextFields() != null) {\n                 for (TextField field : windowCapability.getTextFields()) {\n-                    if (field != null && field.getName() != null && field.getName().equals(name)) {\n+                    if (field != null && name.equals(field.getName())) {\n                         return true;\n                     }\n                 }\n", "next_change": {"commit": "9829fb3228e8bd8a38a67a32a3666fcc45acf066", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 6a2da0e39..f9910032c 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -43,14 +52,17 @@ public class ManagerUtility {\n          * @param name TextFieldName representing a name of a given text field that would be stored in WindowCapability\n          * @return true if name exist in WindowCapability else false\n          */\n-        public static boolean hasTextFieldOfName(WindowCapability windowCapability, TextFieldName name) {\n+        public static boolean hasTextFieldOfName(final WindowCapability windowCapability, final TextFieldName name) {\n             if (windowCapability == null || name == null) {\n                 return false;\n             }\n             if (windowCapability.getTextFields() != null) {\n-                for (TextField field : windowCapability.getTextFields()) {\n-                    if (field != null && name.equals(field.getName())) {\n-                        return true;\n+                List<TextField> textFields = windowCapability.getTextFields();\n+                if (textFields != null && textFields.size() > 0) {\n+                    for (TextField field : textFields) {\n+                        if (field != null && name.equals(field.getName())) {\n+                            return true;\n+                        }\n                     }\n                 }\n             }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "message": "Merge commit", "committedDate": null}, {"oid": "4c5fb6bcf05020314ae7585f10eaf9d09a07b3b7", "committedDate": "2020-05-20 17:10:14 -0400", "message": "Add utility to support all Image and Text Types"}, {"oid": "98809c89f50800fe4fb773ecdf45f49463cd8c0f", "committedDate": "2020-05-29 09:36:49 -0400", "message": "Add Javadocs change max row number"}, {"oid": "c1c55c127ac3c46252994c42161031c9da6f56b1", "committedDate": "2020-07-29 15:53:48 -0400", "message": "Update Tests and replace CID2SET references"}, {"oid": "9829fb3228e8bd8a38a67a32a3666fcc45acf066", "committedDate": "2020-09-02 12:08:17 -0400", "message": "Fix potential NPEs in ManagerUtility class"}, {"oid": "316494bc3a149db2016dbfb73b79e7941a53e725", "committedDate": "2020-09-14 16:29:18 -0400", "message": "Add check to prevent NPE"}, {"oid": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "committedDate": "2020-09-17 16:31:17 -0400", "message": "Run the Reformat Code tool on the project"}, {"oid": "af9d766dcee36cca42a3563a149b4623f04ae688", "committedDate": "2021-03-05 11:47:00 -0500", "message": "Screen manager alert manager (#1555)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4Mjg4MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406282880", "body": "```suggestion\r\n\r\n                        int fieldNumber =0;\r\n                        switch (textField.getName()){\r\n                            case mainField1:\r\n                                fieldNumber = 1;\r\n                                break;\r\n                            case mainField2:\r\n                                fieldNumber = 2;\r\n                                break;\r\n                            case mainField3:\r\n                                fieldNumber = 3;\r\n                                break;\r\n                            case mainField4:\r\n                                fieldNumber = 4;\r\n                                break;\r\n                        }\r\n                        if(fieldNumber > 0){\r\n                            highestFound = Math.max(highestFound, fieldNumber);\r\n                            if (highestFound == 4) {\r\n                                break;\r\n                            }\r\n                        }\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    name = field.getName();\n          \n          \n            \n                                    if (name == TextFieldName.mainField1 || name == TextFieldName.mainField2 || name == TextFieldName.mainField3 || name == TextFieldName.mainField4) {\n          \n          \n            \n                                        int fieldNumber = Integer.parseInt(name.toString().substring(name.toString().length() - 1));\n          \n          \n            \n                                        highestFound = Math.max(highestFound, fieldNumber);\n          \n          \n            \n                                        if (highestFound == 4) {\n          \n          \n            \n                                            break;\n          \n          \n            \n                                        }\n          \n          \n            \n                                    }\n          \n          \n            \n            \n          \n          \n            \n                                    int fieldNumber =0;\n          \n          \n            \n                                    switch (textField.getName()){\n          \n          \n            \n                                        case mainField1:\n          \n          \n            \n                                            fieldNumber = 1;\n          \n          \n            \n                                            break;\n          \n          \n            \n                                        case mainField2:\n          \n          \n            \n                                            fieldNumber = 2;\n          \n          \n            \n                                            break;\n          \n          \n            \n                                        case mainField3:\n          \n          \n            \n                                            fieldNumber = 3;\n          \n          \n            \n                                            break;\n          \n          \n            \n                                        case mainField4:\n          \n          \n            \n                                            fieldNumber = 4;\n          \n          \n            \n                                            break;\n          \n          \n            \n                                    }\n          \n          \n            \n                                    if(fieldNumber > 0){\n          \n          \n            \n                                        highestFound = Math.max(highestFound, fieldNumber);\n          \n          \n            \n                                        if (highestFound == 4) {\n          \n          \n            \n                                            break;\n          \n          \n            \n                                        }\n          \n          \n            \n                                    }", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"89\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                        name <span class=\"pl-k\">=</span> field<span class=\"pl-k\">.</span>getName();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"90\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                        <span class=\"pl-k\">if</span> (name <span class=\"pl-k\">==</span> <span class=\"pl-smi\">TextFieldName</span><span class=\"pl-k\">.</span>mainField1 <span class=\"pl-k\">||</span> name <span class=\"pl-k\">==</span> <span class=\"pl-smi\">TextFieldName</span><span class=\"pl-k\">.</span>mainField2 <span class=\"pl-k\">||</span> name <span class=\"pl-k\">==</span> <span class=\"pl-smi\">TextFieldName</span><span class=\"pl-k\">.</span>mainField3 <span class=\"pl-k\">||</span> name <span class=\"pl-k\">==</span> <span class=\"pl-smi\">TextFieldName</span><span class=\"pl-k\">.</span>mainField4) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"91\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                            <span class=\"pl-k\">int</span> fieldNumber <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Integer</span><span class=\"pl-k\">.</span>parseInt(name<span class=\"pl-k\">.</span>toString()<span class=\"pl-k\">.</span>substring(name<span class=\"pl-k\">.</span>toString()<span class=\"pl-k\">.</span>length() <span class=\"pl-k\">-</span> <span class=\"pl-c1\">1</span>));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"92\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                            highestFound <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Math</span><span class=\"pl-k\">.</span>max(highestFound, fieldNumber);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"93\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                            <span class=\"pl-k\">if</span> (highestFound <span class=\"pl-k\">==</span> <span class=\"pl-c1\">4</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"94\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                                <span class=\"pl-k\">break</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"95\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                            }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"96\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"89\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"90\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        <span class=\"pl-k\">int</span> fieldNumber <span class=\"pl-k\">=</span><span class=\"pl-c1\">0</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"91\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        <span class=\"pl-k\">switch</span> (textField<span class=\"pl-k\">.</span>getName()){</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"92\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                            <span class=\"pl-k\">case</span> mainField1<span class=\"pl-k\">:</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"93\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                                fieldNumber <span class=\"pl-k\">=</span> <span class=\"pl-c1\">1</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"94\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                                <span class=\"pl-k\">break</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"95\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                            <span class=\"pl-k\">case</span> mainField2<span class=\"pl-k\">:</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"96\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                                fieldNumber <span class=\"pl-k\">=</span> <span class=\"pl-c1\">2</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"97\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                                <span class=\"pl-k\">break</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"98\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                            <span class=\"pl-k\">case</span> mainField3<span class=\"pl-k\">:</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"99\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                                fieldNumber <span class=\"pl-k\">=</span> <span class=\"pl-c1\">3</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"100\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                                <span class=\"pl-k\">break</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"101\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                            <span class=\"pl-k\">case</span> mainField4<span class=\"pl-k\">:</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"102\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                                fieldNumber <span class=\"pl-k\">=</span> <span class=\"pl-c1\">4</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"103\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                                <span class=\"pl-k\">break</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"104\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"105\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        <span class=\"pl-k\">if</span>(fieldNumber <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span>){</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"106\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                            highestFound <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Math</span><span class=\"pl-k\">.</span>max(highestFound, fieldNumber);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"107\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                            <span class=\"pl-k\">if</span> (highestFound <span class=\"pl-k\">==</span> <span class=\"pl-c1\">4</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"108\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                                <span class=\"pl-k\">break</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"109\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                            }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"110\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        }</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "joeygrover", "createdAt": "2020-04-09T15:20:44Z", "path": "base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.smartdevicelink.managers;\n+\n+import com.smartdevicelink.proxy.rpc.ImageField;\n+import com.smartdevicelink.proxy.rpc.TextField;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ImageFieldName;\n+import com.smartdevicelink.proxy.rpc.enums.TextFieldName;\n+\n+/**\n+ * <strong>ManagerUtility</strong> <br>\n+ * <p>\n+ * Static Methods to be used throughout the Manager classes <br>\n+ */\n+public class ManagerUtility {\n+\n+    public static class WindowCapabilityUtility {\n+\n+        /**\n+         * Check to see if WindowCapability has an ImageFieldName of a given name.\n+         *\n+         * @param windowCapability WindowCapability representing the capabilities of the desired window\n+         * @param name ImageFieldName representing a name of a given Image field that would be stored in WindowCapability\n+         * @return true if name exist in WindowCapability else false\n+         */\n+        public static boolean hasImageFieldOfName(WindowCapability windowCapability, ImageFieldName name) {\n+            if (windowCapability == null) {\n+                return false;\n+            }\n+            if (windowCapability.getImageFields() != null) {\n+                for (ImageField field : windowCapability.getImageFields()) {\n+                    if (field != null && field.getName() != null && field.getName().equals(name)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Check to see if WindowCapability has a textField of a given name.\n+         *\n+         * @param windowCapability WindowCapability representing the capabilities of the desired window\n+         * @param name TextFieldName representing a name of a given text field that would be stored in WindowCapability\n+         * @return true if name exist in WindowCapability else false\n+         */\n+        public static boolean hasTextFieldOfName(WindowCapability windowCapability, TextFieldName name) {\n+            if (windowCapability == null) {\n+                return false;\n+            }\n+            if (windowCapability.getTextFields() != null) {\n+                for (TextField field : windowCapability.getTextFields()) {\n+                    if (field != null && field.getName() != null && field.getName().equals(name)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Method to get number of textFields allowed to be set according to WindowCapability\n+         *\n+         * @param windowCapability WindowCapability representing the capabilities of the desired window\n+         * @return linesFound Number of textFields found in WindowCapability\n+         */\n+        public static int getMaxNumberOfMainFieldLines(WindowCapability windowCapability) {\n+            int highestFound = 0;\n+            TextFieldName name;\n+            if (windowCapability != null && windowCapability.getTextFields() != null) {\n+                for (TextField field : windowCapability.getTextFields()) {\n+                    if (field.getName() != null) {\n+                        name = field.getName();\n+                        if (name == TextFieldName.mainField1 || name == TextFieldName.mainField2 || name == TextFieldName.mainField3 || name == TextFieldName.mainField4) {\n+                            int fieldNumber = Integer.parseInt(name.toString().substring(name.toString().length() - 1));\n+                            highestFound = Math.max(highestFound, fieldNumber);\n+                            if (highestFound == 4) {\n+                                break;\n+                            }\n+                        }", "originalCommit": "40ed2d11522da4529c645b5df05df0fedd8769e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4Mzk1NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406283955", "bodyText": "While the current solution is more adaptable/clever, the reality is that there are only 4 specific cases that we care about and therefore should avoid string manipulation. I suggest not taking this suggestions from github, but making the changes in Android Studio.", "author": "joeygrover", "createdAt": "2020-04-09T15:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4Mjg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMyMDY1OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406320658", "bodyText": "I agree that the suggested code should be better in performance. I will update the method.", "author": "bilal-alsharifi", "createdAt": "2020-04-09T16:18:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4Mjg4MA=="}], "type": "inlineReview", "revised_code": {"commit": "62a57bdbc2f8794ea020d6bdd293ba92789eb278", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 4bd26697c..6a2da0e39 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -65,17 +65,27 @@ public class ManagerUtility {\n          */\n         public static int getMaxNumberOfMainFieldLines(WindowCapability windowCapability) {\n             int highestFound = 0;\n-            TextFieldName name;\n             if (windowCapability != null && windowCapability.getTextFields() != null) {\n                 for (TextField field : windowCapability.getTextFields()) {\n-                    if (field.getName() != null) {\n-                        name = field.getName();\n-                        if (name == TextFieldName.mainField1 || name == TextFieldName.mainField2 || name == TextFieldName.mainField3 || name == TextFieldName.mainField4) {\n-                            int fieldNumber = Integer.parseInt(name.toString().substring(name.toString().length() - 1));\n-                            highestFound = Math.max(highestFound, fieldNumber);\n-                            if (highestFound == 4) {\n-                                break;\n-                            }\n+                    int fieldNumber = 0;\n+                    switch (field.getName()) {\n+                        case mainField1:\n+                            fieldNumber = 1;\n+                            break;\n+                        case mainField2:\n+                            fieldNumber = 2;\n+                            break;\n+                        case mainField3:\n+                            fieldNumber = 3;\n+                            break;\n+                        case mainField4:\n+                            fieldNumber = 4;\n+                            break;\n+                    }\n+                    if (fieldNumber > 0) {\n+                        highestFound = Math.max(highestFound, fieldNumber);\n+                        if (highestFound == 4) {\n+                            break;\n                         }\n                     }\n                 }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 4bd26697c..6a2da0e39 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -65,17 +65,27 @@ public class ManagerUtility {\n          */\n         public static int getMaxNumberOfMainFieldLines(WindowCapability windowCapability) {\n             int highestFound = 0;\n-            TextFieldName name;\n             if (windowCapability != null && windowCapability.getTextFields() != null) {\n                 for (TextField field : windowCapability.getTextFields()) {\n-                    if (field.getName() != null) {\n-                        name = field.getName();\n-                        if (name == TextFieldName.mainField1 || name == TextFieldName.mainField2 || name == TextFieldName.mainField3 || name == TextFieldName.mainField4) {\n-                            int fieldNumber = Integer.parseInt(name.toString().substring(name.toString().length() - 1));\n-                            highestFound = Math.max(highestFound, fieldNumber);\n-                            if (highestFound == 4) {\n-                                break;\n-                            }\n+                    int fieldNumber = 0;\n+                    switch (field.getName()) {\n+                        case mainField1:\n+                            fieldNumber = 1;\n+                            break;\n+                        case mainField2:\n+                            fieldNumber = 2;\n+                            break;\n+                        case mainField3:\n+                            fieldNumber = 3;\n+                            break;\n+                        case mainField4:\n+                            fieldNumber = 4;\n+                            break;\n+                    }\n+                    if (fieldNumber > 0) {\n+                        highestFound = Math.max(highestFound, fieldNumber);\n+                        if (highestFound == 4) {\n+                            break;\n                         }\n                     }\n                 }\n", "next_change": {"commit": "4c5fb6bcf05020314ae7585f10eaf9d09a07b3b7", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\nindex 6a2da0e39..1f9d17093 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n", "chunk": "@@ -92,5 +98,22 @@ public class ManagerUtility {\n             }\n             return highestFound;\n         }\n+\n+        public static List<TextField> getAllTextFields() {\n+            List<TextField> allTextFields = new ArrayList<>();\n+            for (TextFieldName name : TextFieldName.values()) {\n+                allTextFields.add(new TextField(name, CharacterSet.CID1SET, 500, 500));\n+            }\n+            return allTextFields;\n+        }\n+\n+        public static List<ImageField> getAllImageFields() {\n+            List<ImageField> allImageFields = new ArrayList<>();\n+            List<FileType> allImageFileTypes = Arrays.asList(FileType.GRAPHIC_BMP, FileType.GRAPHIC_JPEG, FileType.GRAPHIC_PNG);\n+            for (ImageFieldName name : ImageFieldName.values()) {\n+                allImageFields.add(new ImageField(name, allImageFileTypes));\n+            }\n+            return allImageFields;\n+        }\n     }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "message": "Merge commit", "committedDate": null}, {"oid": "4c5fb6bcf05020314ae7585f10eaf9d09a07b3b7", "committedDate": "2020-05-20 17:10:14 -0400", "message": "Add utility to support all Image and Text Types"}, {"oid": "98809c89f50800fe4fb773ecdf45f49463cd8c0f", "committedDate": "2020-05-29 09:36:49 -0400", "message": "Add Javadocs change max row number"}, {"oid": "c1c55c127ac3c46252994c42161031c9da6f56b1", "committedDate": "2020-07-29 15:53:48 -0400", "message": "Update Tests and replace CID2SET references"}, {"oid": "9829fb3228e8bd8a38a67a32a3666fcc45acf066", "committedDate": "2020-09-02 12:08:17 -0400", "message": "Fix potential NPEs in ManagerUtility class"}, {"oid": "316494bc3a149db2016dbfb73b79e7941a53e725", "committedDate": "2020-09-14 16:29:18 -0400", "message": "Add check to prevent NPE"}, {"oid": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "committedDate": "2020-09-17 16:31:17 -0400", "message": "Run the Reformat Code tool on the project"}, {"oid": "af9d766dcee36cca42a3563a149b4623f04ae688", "committedDate": "2021-03-05 11:47:00 -0500", "message": "Screen manager alert manager (#1555)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4NTQ4MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406285480", "body": "Does it max sense to just alter the utility method call to return 4 by default instead of this long inline if statement? This is not a hard requirement and would be interested to know how iOS handles it.", "bodyText": "Does it max sense to just alter the utility method call to return 4 by default instead of this long inline if statement? This is not a hard requirement and would be interested to know how iOS handles it.", "bodyHTML": "<p dir=\"auto\">Does it max sense to just alter the utility method call to return 4 by default instead of this long inline if statement? This is not a hard requirement and would be interested to know how iOS handles it.</p>", "author": "joeygrover", "createdAt": "2020-04-09T15:24:35Z", "path": "base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java", "diffHunk": "@@ -409,7 +410,7 @@ Show assembleShowText(Show show){\n \t\t\treturn show;\n \t\t}\n \n-\t\tint numberOfLines = getNumberOfLines();\n+\t\tint numberOfLines = (defaultMainWindowCapability != null && defaultMainWindowCapability.getTextFields() != null) ? ManagerUtility.WindowCapabilityUtility.getMaxNumberOfMainFieldLines(defaultMainWindowCapability) : 4;", "originalCommit": "40ed2d11522da4529c645b5df05df0fedd8769e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM2OTY2Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406369666", "bodyText": "We kind of abstracted the logic in the helper methods in ManagerUtility to just return the actually supported things. And we kept the implementation for the rule \"if null, then all enabled\" directly in the manager's implementation. Of course, that is not a hard rule. We can apply the suggestion if you think that makes more sense. I just did it this way for alignment purposes as iOS implementation also does it similarly:\nhttps://github.com/smartdevicelink/sdl_ios/blob/d4bd0eed98cb1e872da5bcd4a62b04d81a87f815/SmartDeviceLink/SDLTextAndGraphicManager.m#L315:", "author": "bilal-alsharifi", "createdAt": "2020-04-09T17:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4NTQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3OTM3Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406379377", "bodyText": "If that's how iOS does it then staying aligned is more important right now. We can always address a better method for both in the future.", "author": "joeygrover", "createdAt": "2020-04-09T17:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4NTQ4MA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "52ef200d1c60e85373c2a5484d03c11ad87f5ec3", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex 2deb11f09..491111b2b 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -410,7 +410,7 @@ abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \t\t\treturn show;\n \t\t}\n \n-\t\tint numberOfLines = (defaultMainWindowCapability != null && defaultMainWindowCapability.getTextFields() != null) ? ManagerUtility.WindowCapabilityUtility.getMaxNumberOfMainFieldLines(defaultMainWindowCapability) : 4;\n+\t\tint numberOfLines = defaultMainWindowCapability != null ? ManagerUtility.WindowCapabilityUtility.getMaxNumberOfMainFieldLines(defaultMainWindowCapability) : 4;\n \n \t\tswitch (numberOfLines) {\n \t\t\tcase 1: show = assembleOneLineShowText(show, nonNullFields);\n", "next_change": {"commit": "d1ade9d639958a5a9eca69488d62a0ef7d196f40", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex 491111b2b..b5ee13f11 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -235,420 +198,56 @@ abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \t\t\treturn;\n \t\t}\n \n-\t\t//Updating Text and Graphics\n-\t\tif (inProgressUpdate != null){\n-\n-\t\t\t//In progress update exists, queueing update\n-\t\t\tif (queuedUpdateListener != null){\n-\n-\t\t\t\t//Queued update already exists, superseding previous queued update\n-\t\t\t\tqueuedUpdateListener.onComplete(false);\n-\t\t\t\tqueuedUpdateListener = null;\n-\t\t\t}\n-\n-\t\t\tif (listener != null){\n-\t\t\t\tqueuedUpdateListener = listener;\n-\t\t\t}\n-\n-\t\t\thasQueuedUpdate = true;\n-\n+\t\t// check if is batch update\n+\t\tif (batchingUpdates) {\n \t\t\treturn;\n \t\t}\n \n-\t\tShow fullShow = new Show();\n-\t\tfullShow.setAlignment(textAlignment);\n-\t\tfullShow = assembleShowText(fullShow);\n-\t\tfullShow = assembleShowImages(fullShow);\n-\n-\t\tinProgressListener = listener;\n-\n-\t\tif (!shouldUpdatePrimaryImage() && !shouldUpdateSecondaryImage()){\n-\n-\t\t\t//No Images to send, only sending text\n-\t\t\tinProgressUpdate = extractTextFromShow(fullShow);\n-\t\t\tsendShow();\n-\n-\t\t}else if (!sdlArtworkNeedsUpload(primaryGraphic) && (secondaryGraphic == blankArtwork || !sdlArtworkNeedsUpload(secondaryGraphic))){\n-\n-\t\t\t//Images already uploaded, sending full update\n-\t\t\t// The files to be updated are already uploaded, send the full show immediately\n-\t\t\tinProgressUpdate = fullShow;\n-\t\t\tsendShow();\n-\t\t} else{\n-\n-\t\t\t// Images need to be uploaded, sending text and uploading images\n-\t\t\tinProgressUpdate = fullShow;\n-\t\t\tfinal Show thisUpdate = fullShow;\n-\n-\t\t\tuploadImages(new CompletionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\tif (!success){\n-\t\t\t\t\t\tLog.e(TAG, \"Error uploading image\");\n-\t\t\t\t\t\tinProgressUpdate = extractTextFromShow(inProgressUpdate);\n-\t\t\t\t\t\tsendShow();\n-\t\t\t\t\t}\n-\t\t\t\t\t// Check if queued image update still matches our images (there could have been a new Show in the meantime)\n-\t\t\t\t\t// and send a new update if it does. Since the images will already be on the head unit, the whole show will be sent\n-\t\t\t\t\tif (thisUpdate.getGraphic() != null && thisUpdate.getGraphic().equals(queuedImageUpdate.getGraphic()) ||\n-\t\t\t\t\t\t\t(thisUpdate.getSecondaryGraphic() != null && queuedImageUpdate.getSecondaryGraphic() != null) && thisUpdate.getSecondaryGraphic().equals(queuedImageUpdate.getSecondaryGraphic())){\n-\t\t\t\t\t\t// Queued image update matches the images we need, sending update\n-\t\t\t\t\t\tsendShow();\n-\t\t\t\t\t}\n-\t\t\t\t\t// Else, Queued image update does not match the images we need, skipping update\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tqueuedImageUpdate = fullShow;\n-\t\t}\n-\t}\n-\n-\tprivate void sendShow(){\n-\t\tinProgressUpdate.setOnRPCResponseListener(new OnRPCResponseListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\thandleResponse(response.getSuccess());\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\thandleResponse(false);\n-\t\t\t}\n-\n-\t\t\tprivate void handleResponse(boolean success){\n-\t\t\t\tif (success){\n-\t\t\t\t\tupdateCurrentScreenDataState(inProgressUpdate);\n-\t\t\t\t}\n-\n-\t\t\t\tinProgressUpdate = null;\n-\t\t\t\tif (inProgressListener != null){\n-\t\t\t\t\tinProgressListener.onComplete(success);\n-\t\t\t\t\tinProgressListener = null;\n-\t\t\t\t}\n-\n-\t\t\t\tif (hasQueuedUpdate){\n-\t\t\t\t\t//Queued update exists, sending another update\n-\t\t\t\t\thasQueuedUpdate = false;\n-\t\t\t\t\tCompletionListener temp = queuedUpdateListener;\n-\t\t\t\t\tqueuedUpdateListener = null;\n-\t\t\t\t\tsdlUpdate(temp);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tif (this.softButtonManager.get() != null) {\n-\t\t\tthis.softButtonManager.get().setCurrentMainField1(inProgressUpdate.getMainField1());\n-\t\t}\n-\t\tinternalInterface.sendRPC(inProgressUpdate);\n-\t}\n-\n-\t// Images\n-\n-\tprivate void uploadImages(final CompletionListener listener) {\n-\n-\t\tList<SdlArtwork> artworksToUpload = new ArrayList<>();\n-\n-\t\t// add primary image\n-\t\tif (shouldUpdatePrimaryImage() && !primaryGraphic.isStaticIcon()){\n-\t\t\tartworksToUpload.add(primaryGraphic);\n-\t\t}\n-\n-\t\t// add secondary image\n-\t\tif (shouldUpdateSecondaryImage() && !secondaryGraphic.isStaticIcon()){\n-\t\t\tartworksToUpload.add(secondaryGraphic);\n-\t\t}\n-\n-\t\tif (artworksToUpload.size() == 0 && (primaryGraphic.isStaticIcon() || secondaryGraphic.isStaticIcon())){\n-\t\t\tDebugTool.logInfo(\"Upload attempted on static icons, sending them without upload instead\");\n+\t\tif (isDirty){\n+\t\t\tisDirty = false;\n+\t\t\tsdlUpdate(listener);\n+\t\t} else if (listener != null) {\n \t\t\tlistener.onComplete(true);\n \t\t}\n-\n-\t\t// use file manager to upload art\n-\t\tif (fileManager.get() != null) {\n-\t\t\tfileManager.get().uploadArtworks(artworksToUpload, new MultipleFileCompletionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onComplete(Map<String, String> errors) {\n-\t\t\t\t\tif (errors != null) {\n-\t\t\t\t\t\tLog.e(TAG, \"Error Uploading Artworks. Error: \" + errors.toString());\n-\t\t\t\t\t\tlistener.onComplete(false);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tlistener.onComplete(true);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate Show assembleShowImages(Show show){\n-\n-\t\tif (shouldUpdatePrimaryImage()){\n-\t\t\tshow.setGraphic(primaryGraphic.getImageRPC());\n-\t\t}\n-\n-\t\tif (shouldUpdateSecondaryImage()){\n-\t\t\tshow.setSecondaryGraphic(secondaryGraphic.getImageRPC());\n-\t\t}\n-\n-\t\treturn show;\n-\t}\n-\n-\t// Text\n-\n-\tShow assembleShowText(Show show){\n-\n-\t\tshow = setBlankTextFields(show);\n-\n-\t\tif (mediaTrackTextField != null && shouldUpdateMediaTrackField()) {\n-\t\t\tshow.setMediaTrack(mediaTrackTextField);\n-\t\t}\n-\n-\t\tif (title != null && shouldUpdateTitleField()) {\n-\t\t\tshow.setTemplateTitle(title);\n-\t\t}\n-\n-\t\tList<String> nonNullFields = findValidMainTextFields();\n-\t\tif (nonNullFields.isEmpty()){\n-\t\t\treturn show;\n-\t\t}\n-\n-\t\tint numberOfLines = defaultMainWindowCapability != null ? ManagerUtility.WindowCapabilityUtility.getMaxNumberOfMainFieldLines(defaultMainWindowCapability) : 4;\n-\n-\t\tswitch (numberOfLines) {\n-\t\t\tcase 1: show = assembleOneLineShowText(show, nonNullFields);\n-\t\t\t\tbreak;\n-\t\t\tcase 2: show = assembleTwoLineShowText(show);\n-\t\t\t\tbreak;\n-\t\t\tcase 3: show = assembleThreeLineShowText(show);\n-\t\t\t\tbreak;\n-\t\t\tcase 4: show = assembleFourLineShowText(show);\n-\t\t\t\tbreak;\n-\t\t}\n-\n-\t\treturn show;\n-\t}\n-\n-\tprivate Show assembleOneLineShowText(Show show, List<String> showFields){\n-\n-\t\tStringBuilder showString1 = new StringBuilder();\n-\t\tfor (int i = 0; i < showFields.size(); i++) {\n-\t\t\tif (i > 0) {\n-\t\t\t\tshowString1.append(\" - \").append(showFields.get(i));\n-\t\t\t}else{\n-\t\t\t\tshowString1.append(showFields.get(i));\n-\t\t\t}\n-\t\t}\n-\t\tshow.setMainField1(showString1.toString());\n-\n-\t\tMetadataTags tags = new MetadataTags();\n-\t\ttags.setMainField1(findNonNullMetadataFields());\n-\n-\t\tshow.setMetadataTags(tags);\n-\n-\t\treturn show;\n-\t}\n-\n-\tprivate Show assembleTwoLineShowText(Show show){\n-\n-\t\tStringBuilder tempString = new StringBuilder();\n-\t\tMetadataTags tags = new MetadataTags();\n-\n-\t\tif (textField1 != null && textField1.length() > 0) {\n-\t\t\ttempString.append(textField1);\n-\t\t\tif (textField1Type != null){\n-\t\t\t\ttags.setMainField1(textField1Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField2 != null && textField2.length() > 0) {\n-\t\t\tif (( textField3 == null || !(textField3.length() > 0)) && (textField4 == null || !(textField4.length() > 0))){\n-\t\t\t\t// text does not exist in slots 3 or 4, put text2 in slot 2\n-\t\t\t\tshow.setMainField2(textField2);\n-\t\t\t\tif (textField2Type != null){\n-\t\t\t\t\ttags.setMainField2(textField2Type);\n-\t\t\t\t}\n-\t\t\t} else if (textField1 != null && textField1.length() > 0) {\n-\t\t\t\t// If text 1 exists, put it in slot 1 formatted\n-\t\t\t\ttempString.append(\" - \").append(textField2);\n-\t\t\t\tif (textField2Type != null){\n-\t\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n-\t\t\t\t\ttypeList.add(textField2Type);\n-\t\t\t\t\tif (textField1Type != null){\n-\t\t\t\t\t\ttypeList.add(textField1Type);\n-\t\t\t\t\t}\n-\t\t\t\t\ttags.setMainField1(typeList);\n-\t\t\t\t}\n-\t\t\t}else {\n-\t\t\t\t// If text 1 does not exist, put it in slot 1 unformatted\n-\t\t\t\ttempString.append(textField2);\n-\t\t\t\tif (textField2Type != null){\n-\t\t\t\t\ttags.setMainField1(textField2Type);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// set mainfield 1\n-\t\tshow.setMainField1(tempString.toString());\n-\n-\t\t// new stringbuilder object\n-\t\ttempString = new StringBuilder();\n-\n-\t\tif (textField3 != null && textField3.length() > 0){\n-\t\t\t// If text 3 exists, put it in slot 2\n-\t\t\ttempString.append(textField3);\n-\t\t\tif (textField3Type != null){\n-\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n-\t\t\t\ttypeList.add(textField3Type);\n-\t\t\t\ttags.setMainField2(typeList);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField4 != null && textField4.length() > 0){\n-\t\t\tif (textField3 != null && textField3.length() > 0){\n-\t\t\t\t// If text 3 exists, put it in slot 2 formatted\n-\t\t\t\ttempString.append(\" - \").append(textField4);\n-\t\t\t\tif (textField4Type != null){\n-\t\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n-\t\t\t\t\ttypeList.add(textField4Type);\n-\t\t\t\t\tif (textField3Type != null){\n-\t\t\t\t\t\ttypeList.add(textField3Type);\n-\t\t\t\t\t}\n-\t\t\t\t\ttags.setMainField2(typeList);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// If text 3 does not exist, put it in slot 3 unformatted\n-\t\t\t\ttempString.append(textField4);\n-\t\t\t\tif (textField4Type != null){\n-\t\t\t\t\ttags.setMainField2(textField4Type);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (tempString.toString().length() > 0){\n-\t\t\tshow.setMainField2(tempString.toString());\n-\t\t}\n-\n-\t\tshow.setMetadataTags(tags);\n-\t\treturn show;\n \t}\n \n-\tprivate Show assembleThreeLineShowText(Show show){\n+\tprivate synchronized void sdlUpdate(final CompletionListener listener){\n \n-\t\tMetadataTags tags = new MetadataTags();\n-\n-\t\tif (textField1 != null && textField1.length() > 0) {\n-\t\t\tshow.setMainField1(textField1);\n-\t\t\tif (textField1Type != null){\n-\t\t\t\ttags.setMainField1(textField1Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField2 != null && textField2.length() > 0) {\n-\t\t\tshow.setMainField2(textField2);\n-\t\t\tif (textField2Type != null){\n-\t\t\t\ttags.setMainField2(textField2Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tStringBuilder tempString = new StringBuilder();\n-\n-\t\tif (textField3 != null && textField3.length() > 0){\n-\t\t\ttempString.append(textField3);\n-\t\t\tif (textField3Type != null){\n-\t\t\t\ttags.setMainField3(textField3Type);\n-\t\t\t}\n+\t\tif(transactionQueue.getTasksAsList().size() > 0) {\n+\t\t\t//Transactions already exist, cancelling them\n+\t\t\ttransactionQueue.clear();\n \t\t}\n+\t\tupdateOperation = new TextAndGraphicUpdateOperation(internalInterface, fileManager.get(), defaultMainWindowCapability, currentScreenData, currentState(), new CompletionListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onComplete(boolean success) {\n \n-\t\tif (textField4 != null && textField4.length() > 0) {\n-\t\t\tif (textField3 != null && textField3.length() > 0) {\n-\t\t\t\t// If text 3 exists, put it in slot 3 formatted\n-\t\t\t\ttempString.append(\" - \").append(textField4);\n-\t\t\t\tif (textField4Type != null){\n-\t\t\t\t\tList<MetadataType> tags4 = new ArrayList<>();\n-\t\t\t\t\tif (textField3Type != null){\n-\t\t\t\t\t\ttags4.add(textField3Type);\n-\t\t\t\t\t}\n-\t\t\t\t\ttags4.add(textField4Type);\n-\t\t\t\t\ttags.setMainField3(tags4);\n+\t\t\t\tif (updateOperation.getSentShow() != null) {\n+\t\t\t\t\tcurrentScreenData = updateOperation.getSentShow();\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// If text 3 does not exist, put it in slot 3 formatted\n-\t\t\t\ttempString.append(textField4);\n-\t\t\t\tif (textField4Type != null){\n-\t\t\t\t\ttags.setMainField3(textField4Type);\n+\t\t\t\tif (listener != null) { //IOS diff here\n+\t\t\t\t\tlistener.onComplete(success);\n \t\t\t\t}\n \t\t\t}\n-\t\t}\n-\n-\t\tshow.setMainField3(tempString.toString());\n-\t\tshow.setMetadataTags(tags);\n-\t\treturn show;\n+\t\t});\n+\t\ttransactionQueue.add(updateOperation, false);\n \t}\n \n-\tprivate Show assembleFourLineShowText(Show show){\n-\n-\t\tMetadataTags tags = new MetadataTags();\n-\n-\t\tif (textField1 != null && textField1.length() > 0) {\n-\t\t\tshow.setMainField1(textField1);\n-\t\t\tif (textField1Type != null){\n-\t\t\t\ttags.setMainField1(textField1Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField2 != null && textField2.length() > 0) {\n-\t\t\tshow.setMainField2(textField2);\n-\t\t\tif (textField2Type != null){\n-\t\t\t\ttags.setMainField2(textField2Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField3 != null && textField3.length() > 0) {\n-\t\t\tshow.setMainField3(textField3);\n-\t\t\tif (textField3Type != null){\n-\t\t\t\ttags.setMainField3(textField3Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField4 != null && textField4.length() > 0) {\n-\t\t\tshow.setMainField4(textField4);\n-\t\t\tif (textField4Type != null){\n-\t\t\t\ttags.setMainField4(textField4Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tshow.setMetadataTags(tags);\n-\t\treturn show;\n+\t// Convert to State\n+\tprivate TextsAndGraphicsState currentState() {\n+\t\treturn new TextsAndGraphicsState(textField1, textField2, textField3, textField4, mediaTrackTextField,\n+\t\t\t\ttitle, primaryGraphic, secondaryGraphic, blankArtwork, textAlignment, textField1Type, textField2Type, textField3Type, textField4Type);\n \t}\n \n \t// Extraction\n \n-\tShow extractTextFromShow(Show show){\n-\n-\t\tShow newShow = new Show();\n-\t\tnewShow.setMainField1(show.getMainField1());\n-\t\tnewShow.setMainField2(show.getMainField2());\n-\t\tnewShow.setMainField3(show.getMainField3());\n-\t\tnewShow.setMainField4(show.getMainField4());\n-\t\tnewShow.setTemplateTitle(show.getTemplateTitle());\n-\n-\t\treturn newShow;\n-\t}\n-\n-\tprivate Show setBlankTextFields(Show newShow){\n+\t//IOS has sdl_extractImageFromShow\n \n-\t\tnewShow.setMainField1(\"\");\n-\t\tnewShow.setMainField2(\"\");\n-\t\tnewShow.setMainField3(\"\");\n-\t\tnewShow.setMainField4(\"\");\n-\t\tnewShow.setMediaTrack(\"\");\n-\t\tnewShow.setTemplateTitle(\"\");\n-\n-\t\treturn newShow;\n-\t}\n+\t//IOS has sdl_createImageOnlyShowWithPrimaryArtwork\n \n \tprivate void updateCurrentScreenDataState(Show show){\n \n \t\tif (show == null){\n-\t\t\tLog.e(TAG, \"can not updateCurrentScreenDataFromShow from null show\");\n+\t\t\tDebugTool.logError(TAG, \"can not updateCurrentScreenDataFromShow from null show\");\n \t\t\treturn;\n \t\t}\n \n", "next_change": {"commit": "afd900229c8e4bea0c1062a858acc8c8e2ffaea2", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex b5ee13f11..371c49a98 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -244,42 +245,42 @@ abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \n \t//IOS has sdl_createImageOnlyShowWithPrimaryArtwork\n \n-\tprivate void updateCurrentScreenDataState(Show show){\n+\tprivate void updateCurrentScreenDataState(Show show) {\n \n-\t\tif (show == null){\n+\t\tif (show == null) {\n \t\t\tDebugTool.logError(TAG, \"can not updateCurrentScreenDataFromShow from null show\");\n \t\t\treturn;\n \t\t}\n \n \t\t// If the items are null, they were not updated, so we can't just set it directly\n-\t\tif (show.getMainField1() != null){\n+\t\tif (show.getMainField1() != null) {\n \t\t\tcurrentScreenData.setMainField1(show.getMainField1());\n \t\t}\n-\t\tif (show.getMainField2() != null){\n+\t\tif (show.getMainField2() != null) {\n \t\t\tcurrentScreenData.setMainField2(show.getMainField2());\n \t\t}\n-\t\tif (show.getMainField3() != null){\n+\t\tif (show.getMainField3() != null) {\n \t\t\tcurrentScreenData.setMainField3(show.getMainField3());\n \t\t}\n-\t\tif (show.getMainField4() != null){\n+\t\tif (show.getMainField4() != null) {\n \t\t\tcurrentScreenData.setMainField4(show.getMainField4());\n \t\t}\n-\t\tif (show.getTemplateTitle() != null){\n+\t\tif (show.getTemplateTitle() != null) {\n \t\t\tcurrentScreenData.setTemplateTitle(show.getTemplateTitle());\n \t\t}\n-\t\tif (show.getMediaTrack() != null){\n+\t\tif (show.getMediaTrack() != null) {\n \t\t\tcurrentScreenData.setMediaTrack(show.getMediaTrack());\n \t\t}\n-\t\tif (show.getMetadataTags() != null){\n+\t\tif (show.getMetadataTags() != null) {\n \t\t\tcurrentScreenData.setMetadataTags(show.getMetadataTags());\n \t\t}\n-\t\tif (show.getAlignment() != null){\n+\t\tif (show.getAlignment() != null) {\n \t\t\tcurrentScreenData.setAlignment(show.getAlignment());\n \t\t}\n-\t\tif (show.getGraphic() != null){\n+\t\tif (show.getGraphic() != null) {\n \t\t\tcurrentScreenData.setGraphic(show.getGraphic());\n \t\t}\n-\t\tif (show.getSecondaryGraphic() != null){\n+\t\tif (show.getSecondaryGraphic() != null) {\n \t\t\tcurrentScreenData.setSecondaryGraphic(show.getSecondaryGraphic());\n \t\t}\n \t}\n", "next_change": {"commit": "d10a5525520ba077ac2f1f841e6bb9653880263f", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex 371c49a98..9a298e87b 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -234,66 +217,12 @@ abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \t}\n \n \t// Convert to State\n+\n \tprivate TextsAndGraphicsState currentState() {\n \t\treturn new TextsAndGraphicsState(textField1, textField2, textField3, textField4, mediaTrackTextField,\n-\t\t\t\ttitle, primaryGraphic, secondaryGraphic, blankArtwork, textAlignment, textField1Type, textField2Type, textField3Type, textField4Type);\n-\t}\n-\n-\t// Extraction\n-\n-\t//IOS has sdl_extractImageFromShow\n-\n-\t//IOS has sdl_createImageOnlyShowWithPrimaryArtwork\n-\n-\tprivate void updateCurrentScreenDataState(Show show) {\n-\n-\t\tif (show == null) {\n-\t\t\tDebugTool.logError(TAG, \"can not updateCurrentScreenDataFromShow from null show\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// If the items are null, they were not updated, so we can't just set it directly\n-\t\tif (show.getMainField1() != null) {\n-\t\t\tcurrentScreenData.setMainField1(show.getMainField1());\n-\t\t}\n-\t\tif (show.getMainField2() != null) {\n-\t\t\tcurrentScreenData.setMainField2(show.getMainField2());\n-\t\t}\n-\t\tif (show.getMainField3() != null) {\n-\t\t\tcurrentScreenData.setMainField3(show.getMainField3());\n-\t\t}\n-\t\tif (show.getMainField4() != null) {\n-\t\t\tcurrentScreenData.setMainField4(show.getMainField4());\n-\t\t}\n-\t\tif (show.getTemplateTitle() != null) {\n-\t\t\tcurrentScreenData.setTemplateTitle(show.getTemplateTitle());\n-\t\t}\n-\t\tif (show.getMediaTrack() != null) {\n-\t\t\tcurrentScreenData.setMediaTrack(show.getMediaTrack());\n-\t\t}\n-\t\tif (show.getMetadataTags() != null) {\n-\t\t\tcurrentScreenData.setMetadataTags(show.getMetadataTags());\n-\t\t}\n-\t\tif (show.getAlignment() != null) {\n-\t\t\tcurrentScreenData.setAlignment(show.getAlignment());\n-\t\t}\n-\t\tif (show.getGraphic() != null) {\n-\t\t\tcurrentScreenData.setGraphic(show.getGraphic());\n-\t\t}\n-\t\tif (show.getSecondaryGraphic() != null) {\n-\t\t\tcurrentScreenData.setSecondaryGraphic(show.getSecondaryGraphic());\n-\t\t}\n+\t\t\t\ttitle, primaryGraphic, secondaryGraphic, textAlignment, textField1Type, textField2Type, textField3Type, textField4Type);\n \t}\n \n-\t// Helpers\n-\n-\t// IOS has sdl_hasData\n-\n-\t//Equality IOS has this section with:\n-\t// sdl_showImages\n-\n-\tabstract SdlArtwork getBlankArtwork();\n-\n \t// Getters / Setters\n \n \tvoid setTextAlignment(TextAlignment textAlignment) {\n", "next_change": {"commit": "0f6a3f5c7f286686a78e7ecc9ee397bcbba675b0", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex 9a298e87b..a07e60f20 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -175,279 +214,767 @@ abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \t\t\treturn;\n \t\t}\n \n+\t\tif (isDirty){\n+\t\t\tisDirty = false;\n+\t\t\tsdlUpdate(listener);\n+\t\t} else if (listener != null) {\n+\t\t\tlistener.onComplete(true);\n+\t\t}\n+\t}\n+\n+\tprivate synchronized void sdlUpdate(CompletionListener listener){\n+\n \t\t// make sure hmi is not none\n-\t\tif (currentHMILevel == null || currentHMILevel == HMILevel.HMI_NONE) {\n+\t\tif (currentHMILevel == null || currentHMILevel == HMILevel.HMI_NONE){\n \t\t\t//Trying to send show on HMI_NONE, waiting for full\n \t\t\tpendingHMIFull = true;\n-\t\t\tif (listener != null) {\n+\t\t\tif (listener != null){\n \t\t\t\tpendingHMIListener = listener;\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n-\t\tif (isDirty) {\n-\t\t\tisDirty = false;\n-\t\t\tsdlUpdate(listener);\n-\t\t} else if (listener != null) {\n-\t\t\tlistener.onComplete(true);\n-\t\t}\n-\t}\n+\t\t//Updating Text and Graphics\n+\t\tif (inProgressUpdate != null){\n \n-\tprivate synchronized void sdlUpdate(final CompletionListener listener) {\n+\t\t\t//In progress update exists, queueing update\n+\t\t\tif (queuedUpdateListener != null){\n+\n+\t\t\t\t//Queued update already exists, superseding previous queued update\n+\t\t\t\tqueuedUpdateListener.onComplete(false);\n+\t\t\t\tqueuedUpdateListener = null;\n+\t\t\t}\n+\n+\t\t\tif (listener != null){\n+\t\t\t\tqueuedUpdateListener = listener;\n+\t\t\t}\n+\n+\t\t\thasQueuedUpdate = true;\n \n-\t\tif (transactionQueue.getTasksAsList().size() > 0) {\n-\t\t\t//Transactions already exist, cancelling them\n-\t\t\ttransactionQueue.clear();\n-\t\t\tlistener.onComplete(false);\n \t\t\treturn;\n \t\t}\n-\t\tupdateOperation = new TextAndGraphicUpdateOperation(internalInterface, fileManager.get(), defaultMainWindowCapability, currentScreenData, currentState(), new CompletionListener() {\n+\n+\t\tShow fullShow = new Show();\n+\t\tfullShow.setAlignment(textAlignment);\n+\t\tfullShow = assembleShowText(fullShow);\n+\t\tfullShow = assembleShowImages(fullShow);\n+\n+\t\tinProgressListener = listener;\n+\n+\t\tif (!shouldUpdatePrimaryImage() && !shouldUpdateSecondaryImage()){\n+\n+\t\t\t//No Images to send, only sending text\n+\t\t\tinProgressUpdate = extractTextFromShow(fullShow);\n+\t\t\tsendShow();\n+\n+\t\t}else if (!sdlArtworkNeedsUpload(primaryGraphic) && (secondaryGraphic == blankArtwork || !sdlArtworkNeedsUpload(secondaryGraphic))){\n+\n+\t\t\t//Images already uploaded, sending full update\n+\t\t\t// The files to be updated are already uploaded, send the full show immediately\n+\t\t\tinProgressUpdate = fullShow;\n+\t\t\tsendShow();\n+\t\t} else{\n+\n+\t\t\t// Images need to be uploaded, sending text and uploading images\n+\t\t\tinProgressUpdate = fullShow;\n+\t\t\tfinal Show thisUpdate = fullShow;\n+\n+\t\t\tuploadImages(new CompletionListener() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void onComplete(boolean success) {\n+\t\t\t\t\tif (!success){\n+\t\t\t\t\t\tDebugTool.logError(TAG, \"Error uploading image\");\n+\t\t\t\t\t\tinProgressUpdate = extractTextFromShow(inProgressUpdate);\n+\t\t\t\t\t\tsendShow();\n+\t\t\t\t\t}\n+\t\t\t\t\t// Check if queued image update still matches our images (there could have been a new Show in the meantime)\n+\t\t\t\t\t// and send a new update if it does. Since the images will already be on the head unit, the whole show will be sent\n+\t\t\t\t\tif (thisUpdate.getGraphic() != null && thisUpdate.getGraphic().equals(queuedImageUpdate.getGraphic()) ||\n+\t\t\t\t\t\t\t(thisUpdate.getSecondaryGraphic() != null && queuedImageUpdate.getSecondaryGraphic() != null) && thisUpdate.getSecondaryGraphic().equals(queuedImageUpdate.getSecondaryGraphic())){\n+\t\t\t\t\t\t// Queued image update matches the images we need, sending update\n+\t\t\t\t\t\tsendShow();\n+\t\t\t\t\t}\n+\t\t\t\t\t// Else, Queued image update does not match the images we need, skipping update\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tqueuedImageUpdate = fullShow;\n+\t\t}\n+\t}\n+\n+\tprivate void sendShow(){\n+\t\tinProgressUpdate.setOnRPCResponseListener(new OnRPCResponseListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n+\t\t\t\thandleResponse(response.getSuccess());\n+\t\t\t}\n+\n \t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n+\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n+\t\t\t\thandleResponse(false);\n+\t\t\t}\n \n-\t\t\t\tif (updateOperation.getSentShow() != null) {\n-\t\t\t\t\tcurrentScreenData = updateOperation.getSentShow();\n+\t\t\tprivate void handleResponse(boolean success){\n+\t\t\t\tif (success){\n+\t\t\t\t\tupdateCurrentScreenDataState(inProgressUpdate);\n \t\t\t\t}\n-\t\t\t\tif (listener != null) {\n-\t\t\t\t\tlistener.onComplete(success);\n+\n+\t\t\t\tinProgressUpdate = null;\n+\t\t\t\tif (inProgressListener != null){\n+\t\t\t\t\tinProgressListener.onComplete(success);\n+\t\t\t\t\tinProgressListener = null;\n+\t\t\t\t}\n+\n+\t\t\t\tif (hasQueuedUpdate){\n+\t\t\t\t\t//Queued update exists, sending another update\n+\t\t\t\t\thasQueuedUpdate = false;\n+\t\t\t\t\tCompletionListener temp = queuedUpdateListener;\n+\t\t\t\t\tqueuedUpdateListener = null;\n+\t\t\t\t\tsdlUpdate(temp);\n \t\t\t\t}\n \t\t\t}\n \t\t});\n-\t\ttransactionQueue.add(updateOperation, false);\n+\n+\t\tif (this.softButtonManager.get() != null) {\n+\t\t\tthis.softButtonManager.get().setCurrentMainField1(inProgressUpdate.getMainField1());\n+\t\t}\n+\t\tinternalInterface.sendRPC(inProgressUpdate);\n+\t}\n+\n+\t// Images\n+\n+\tprivate void uploadImages(final CompletionListener listener) {\n+\n+\t\tList<SdlArtwork> artworksToUpload = new ArrayList<>();\n+\n+\t\t// add primary image\n+\t\tif (shouldUpdatePrimaryImage() && !primaryGraphic.isStaticIcon()){\n+\t\t\tartworksToUpload.add(primaryGraphic);\n+\t\t}\n+\n+\t\t// add secondary image\n+\t\tif (shouldUpdateSecondaryImage() && !secondaryGraphic.isStaticIcon()){\n+\t\t\tartworksToUpload.add(secondaryGraphic);\n+\t\t}\n+\n+\t\tif (artworksToUpload.size() == 0 && (primaryGraphic.isStaticIcon() || secondaryGraphic.isStaticIcon())){\n+\t\t\tDebugTool.logInfo(TAG, \"Upload attempted on static icons, sending them without upload instead\");\n+\t\t\tlistener.onComplete(true);\n+\t\t}\n+\n+\t\t// use file manager to upload art\n+\t\tif (fileManager.get() != null) {\n+\t\t\tfileManager.get().uploadArtworks(artworksToUpload, new MultipleFileCompletionListener() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void onComplete(Map<String, String> errors) {\n+\t\t\t\t\tif (errors != null) {\n+\t\t\t\t\t\tDebugTool.logError(TAG, \"Error Uploading Artworks. Error: \" + errors.toString());\n+\t\t\t\t\t\tlistener.onComplete(false);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tlistener.onComplete(true);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t}\n+\n+\tprivate Show assembleShowImages(Show show){\n+\n+\t\tif (shouldUpdatePrimaryImage()){\n+\t\t\tshow.setGraphic(primaryGraphic.getImageRPC());\n+\t\t}\n+\n+\t\tif (shouldUpdateSecondaryImage()){\n+\t\t\tshow.setSecondaryGraphic(secondaryGraphic.getImageRPC());\n+\t\t}\n+\n+\t\treturn show;\n \t}\n \n-\t// Convert to State\n+\t// Text\n \n-\tprivate TextsAndGraphicsState currentState() {\n-\t\treturn new TextsAndGraphicsState(textField1, textField2, textField3, textField4, mediaTrackTextField,\n-\t\t\t\ttitle, primaryGraphic, secondaryGraphic, textAlignment, textField1Type, textField2Type, textField3Type, textField4Type);\n+\tShow assembleShowText(Show show){\n+\n+\t\tshow = setBlankTextFields(show);\n+\n+\t\tif (mediaTrackTextField != null && shouldUpdateMediaTrackField()) {\n+\t\t\tshow.setMediaTrack(mediaTrackTextField);\n+\t\t}\n+\n+\t\tif (title != null && shouldUpdateTitleField()) {\n+\t\t\tshow.setTemplateTitle(title);\n+\t\t}\n+\n+\t\tList<String> nonNullFields = findValidMainTextFields();\n+\t\tif (nonNullFields.isEmpty()){\n+\t\t\treturn show;\n+\t\t}\n+\n+\t\tint numberOfLines = defaultMainWindowCapability != null ? ManagerUtility.WindowCapabilityUtility.getMaxNumberOfMainFieldLines(defaultMainWindowCapability) : 4;\n+\n+\t\tswitch (numberOfLines) {\n+\t\t\tcase 1: show = assembleOneLineShowText(show, nonNullFields);\n+\t\t\t\tbreak;\n+\t\t\tcase 2: show = assembleTwoLineShowText(show);\n+\t\t\t\tbreak;\n+\t\t\tcase 3: show = assembleThreeLineShowText(show);\n+\t\t\t\tbreak;\n+\t\t\tcase 4: show = assembleFourLineShowText(show);\n+\t\t\t\tbreak;\n+\t\t}\n+\n+\t\treturn show;\n \t}\n \n-\t// Getters / Setters\n+\tprivate Show assembleOneLineShowText(Show show, List<String> showFields){\n \n-\tvoid setTextAlignment(TextAlignment textAlignment) {\n+\t\tStringBuilder showString1 = new StringBuilder();\n+\t\tfor (int i = 0; i < showFields.size(); i++) {\n+\t\t\tif (i > 0) {\n+\t\t\t\tshowString1.append(\" - \").append(showFields.get(i));\n+\t\t\t}else{\n+\t\t\t\tshowString1.append(showFields.get(i));\n+\t\t\t}\n+\t\t}\n+\t\tshow.setMainField1(showString1.toString());\n+\n+\t\tMetadataTags tags = new MetadataTags();\n+\t\ttags.setMainField1(findNonNullMetadataFields());\n+\n+\t\tshow.setMetadataTags(tags);\n+\n+\t\treturn show;\n+\t}\n+\n+\tprivate Show assembleTwoLineShowText(Show show){\n+\n+\t\tStringBuilder tempString = new StringBuilder();\n+\t\tMetadataTags tags = new MetadataTags();\n+\n+\t\tif (textField1 != null && textField1.length() > 0) {\n+\t\t\ttempString.append(textField1);\n+\t\t\tif (textField1Type != null){\n+\t\t\t\ttags.setMainField1(textField1Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (textField2 != null && textField2.length() > 0) {\n+\t\t\tif (( textField3 == null || !(textField3.length() > 0)) && (textField4 == null || !(textField4.length() > 0))){\n+\t\t\t\t// text does not exist in slots 3 or 4, put text2 in slot 2\n+\t\t\t\tshow.setMainField2(textField2);\n+\t\t\t\tif (textField2Type != null){\n+\t\t\t\t\ttags.setMainField2(textField2Type);\n+\t\t\t\t}\n+\t\t\t} else if (textField1 != null && textField1.length() > 0) {\n+\t\t\t\t// If text 1 exists, put it in slot 1 formatted\n+\t\t\t\ttempString.append(\" - \").append(textField2);\n+\t\t\t\tif (textField2Type != null){\n+\t\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n+\t\t\t\t\ttypeList.add(textField2Type);\n+\t\t\t\t\tif (textField1Type != null){\n+\t\t\t\t\t\ttypeList.add(textField1Type);\n+\t\t\t\t\t}\n+\t\t\t\t\ttags.setMainField1(typeList);\n+\t\t\t\t}\n+\t\t\t}else {\n+\t\t\t\t// If text 1 does not exist, put it in slot 1 unformatted\n+\t\t\t\ttempString.append(textField2);\n+\t\t\t\tif (textField2Type != null){\n+\t\t\t\t\ttags.setMainField1(textField2Type);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// set mainfield 1\n+\t\tshow.setMainField1(tempString.toString());\n+\n+\t\t// new stringbuilder object\n+\t\ttempString = new StringBuilder();\n+\n+\t\tif (textField3 != null && textField3.length() > 0){\n+\t\t\t// If text 3 exists, put it in slot 2\n+\t\t\ttempString.append(textField3);\n+\t\t\tif (textField3Type != null){\n+\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n+\t\t\t\ttypeList.add(textField3Type);\n+\t\t\t\ttags.setMainField2(typeList);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (textField4 != null && textField4.length() > 0){\n+\t\t\tif (textField3 != null && textField3.length() > 0){\n+\t\t\t\t// If text 3 exists, put it in slot 2 formatted\n+\t\t\t\ttempString.append(\" - \").append(textField4);\n+\t\t\t\tif (textField4Type != null){\n+\t\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n+\t\t\t\t\ttypeList.add(textField4Type);\n+\t\t\t\t\tif (textField3Type != null){\n+\t\t\t\t\t\ttypeList.add(textField3Type);\n+\t\t\t\t\t}\n+\t\t\t\t\ttags.setMainField2(typeList);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// If text 3 does not exist, put it in slot 3 unformatted\n+\t\t\t\ttempString.append(textField4);\n+\t\t\t\tif (textField4Type != null){\n+\t\t\t\t\ttags.setMainField2(textField4Type);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (tempString.toString().length() > 0){\n+\t\t\tshow.setMainField2(tempString.toString());\n+\t\t}\n+\n+\t\tshow.setMetadataTags(tags);\n+\t\treturn show;\n+\t}\n+\n+\tprivate Show assembleThreeLineShowText(Show show){\n+\n+\t\tMetadataTags tags = new MetadataTags();\n+\n+\t\tif (textField1 != null && textField1.length() > 0) {\n+\t\t\tshow.setMainField1(textField1);\n+\t\t\tif (textField1Type != null){\n+\t\t\t\ttags.setMainField1(textField1Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (textField2 != null && textField2.length() > 0) {\n+\t\t\tshow.setMainField2(textField2);\n+\t\t\tif (textField2Type != null){\n+\t\t\t\ttags.setMainField2(textField2Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tStringBuilder tempString = new StringBuilder();\n+\n+\t\tif (textField3 != null && textField3.length() > 0){\n+\t\t\ttempString.append(textField3);\n+\t\t\tif (textField3Type != null){\n+\t\t\t\ttags.setMainField3(textField3Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (textField4 != null && textField4.length() > 0) {\n+\t\t\tif (textField3 != null && textField3.length() > 0) {\n+\t\t\t\t// If text 3 exists, put it in slot 3 formatted\n+\t\t\t\ttempString.append(\" - \").append(textField4);\n+\t\t\t\tif (textField4Type != null){\n+\t\t\t\t\tList<MetadataType> tags4 = new ArrayList<>();\n+\t\t\t\t\tif (textField3Type != null){\n+\t\t\t\t\t\ttags4.add(textField3Type);\n+\t\t\t\t\t}\n+\t\t\t\t\ttags4.add(textField4Type);\n+\t\t\t\t\ttags.setMainField3(tags4);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// If text 3 does not exist, put it in slot 3 formatted\n+\t\t\t\ttempString.append(textField4);\n+\t\t\t\tif (textField4Type != null){\n+\t\t\t\t\ttags.setMainField3(textField4Type);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tshow.setMainField3(tempString.toString());\n+\t\tshow.setMetadataTags(tags);\n+\t\treturn show;\n+\t}\n+\n+\tprivate Show assembleFourLineShowText(Show show){\n+\n+\t\tMetadataTags tags = new MetadataTags();\n+\n+\t\tif (textField1 != null && textField1.length() > 0) {\n+\t\t\tshow.setMainField1(textField1);\n+\t\t\tif (textField1Type != null){\n+\t\t\t\ttags.setMainField1(textField1Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (textField2 != null && textField2.length() > 0) {\n+\t\t\tshow.setMainField2(textField2);\n+\t\t\tif (textField2Type != null){\n+\t\t\t\ttags.setMainField2(textField2Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (textField3 != null && textField3.length() > 0) {\n+\t\t\tshow.setMainField3(textField3);\n+\t\t\tif (textField3Type != null){\n+\t\t\t\ttags.setMainField3(textField3Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (textField4 != null && textField4.length() > 0) {\n+\t\t\tshow.setMainField4(textField4);\n+\t\t\tif (textField4Type != null){\n+\t\t\t\ttags.setMainField4(textField4Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tshow.setMetadataTags(tags);\n+\t\treturn show;\n+\t}\n+\n+\t// Extraction\n+\n+\tShow extractTextFromShow(Show show){\n+\n+\t\tShow newShow = new Show();\n+\t\tnewShow.setMainField1(show.getMainField1());\n+\t\tnewShow.setMainField2(show.getMainField2());\n+\t\tnewShow.setMainField3(show.getMainField3());\n+\t\tnewShow.setMainField4(show.getMainField4());\n+\t\tnewShow.setTemplateTitle(show.getTemplateTitle());\n+\n+\t\treturn newShow;\n+\t}\n+\n+\tprivate Show setBlankTextFields(Show newShow){\n+\n+\t\tnewShow.setMainField1(\"\");\n+\t\tnewShow.setMainField2(\"\");\n+\t\tnewShow.setMainField3(\"\");\n+\t\tnewShow.setMainField4(\"\");\n+\t\tnewShow.setMediaTrack(\"\");\n+\t\tnewShow.setTemplateTitle(\"\");\n+\n+\t\treturn newShow;\n+\t}\n+\n+\tprivate void updateCurrentScreenDataState(Show show){\n+\n+\t\tif (show == null){\n+\t\t\tDebugTool.logError(TAG, \"can not updateCurrentScreenDataFromShow from null show\");\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// If the items are null, they were not updated, so we can't just set it directly\n+\t\tif (show.getMainField1() != null){\n+\t\t\tcurrentScreenData.setMainField1(show.getMainField1());\n+\t\t}\n+\t\tif (show.getMainField2() != null){\n+\t\t\tcurrentScreenData.setMainField2(show.getMainField2());\n+\t\t}\n+\t\tif (show.getMainField3() != null){\n+\t\t\tcurrentScreenData.setMainField3(show.getMainField3());\n+\t\t}\n+\t\tif (show.getMainField4() != null){\n+\t\t\tcurrentScreenData.setMainField4(show.getMainField4());\n+\t\t}\n+\t\tif (show.getTemplateTitle() != null){\n+\t\t\tcurrentScreenData.setTemplateTitle(show.getTemplateTitle());\n+\t\t}\n+\t\tif (show.getMediaTrack() != null){\n+\t\t\tcurrentScreenData.setMediaTrack(show.getMediaTrack());\n+\t\t}\n+\t\tif (show.getMetadataTags() != null){\n+\t\t\tcurrentScreenData.setMetadataTags(show.getMetadataTags());\n+\t\t}\n+\t\tif (show.getAlignment() != null){\n+\t\t\tcurrentScreenData.setAlignment(show.getAlignment());\n+\t\t}\n+\t\tif (show.getGraphic() != null){\n+\t\t\tcurrentScreenData.setGraphic(show.getGraphic());\n+\t\t}\n+\t\tif (show.getSecondaryGraphic() != null){\n+\t\t\tcurrentScreenData.setSecondaryGraphic(show.getSecondaryGraphic());\n+\t\t}\n+\t}\n+\n+\t// Helpers\n+\n+\tprivate List<String> findValidMainTextFields(){\n+\t\tList<String> array = new ArrayList<>();\n+\n+\t\tif (textField1 != null && textField1.length() > 0) {\n+\t\t\tarray.add(textField1);\n+\t\t}\n+\n+\t\tif (textField2 != null && textField2.length() > 0) {\n+\t\t\tarray.add(textField2);\n+\t\t}\n+\n+\t\tif (textField3 != null && textField3.length() > 0) {\n+\t\t\tarray.add(textField3);\n+\t\t}\n+\n+\t\tif (textField4 != null && textField4.length() > 0) {\n+\t\t\tarray.add(textField4);\n+\t\t}\n+\n+\t\treturn array;\n+\t}\n+\n+\n+\tprivate List<MetadataType> findNonNullMetadataFields(){\n+\t\tList<MetadataType> array = new ArrayList<>();\n+\n+\t\tif (textField1Type != null) {\n+\t\t\tarray.add(textField1Type);\n+\t\t}\n+\n+\t\tif (textField2Type != null) {\n+\t\t\tarray.add(textField2Type);\n+\t\t}\n+\n+\t\tif (textField3Type != null) {\n+\t\t\tarray.add(textField3Type);\n+\t\t}\n+\n+\t\tif (textField4Type != null) {\n+\t\t\tarray.add(textField4Type);\n+\t\t}\n+\n+\t\treturn array;\n+\t}\n+\n+\tabstract SdlArtwork getBlankArtwork();\n+\n+\t@SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n+\tprivate boolean sdlArtworkNeedsUpload(SdlArtwork artwork){\n+\t\tif (fileManager.get() != null) {\n+\t\t\treturn artwork != null && !fileManager.get().hasUploadedFile(artwork) && !artwork.isStaticIcon();\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Check to see if primaryGraphic should be updated\n+\t * @return true if primaryGraphic should be updated, false if not\n+\t */\n+\tprivate boolean shouldUpdatePrimaryImage() {\n+\t\tboolean templateSupportsPrimaryArtwork = templateSupportsImageField(ImageFieldName.graphic);\n+\n+\t\tString currentScreenDataPrimaryGraphicName = (currentScreenData != null && currentScreenData.getGraphic() != null) ? currentScreenData.getGraphic().getValue() : null;\n+\t\tString primaryGraphicName = primaryGraphic != null ? primaryGraphic.getName() : null;\n+\t\treturn templateSupportsPrimaryArtwork\n+\t\t\t\t&& !CompareUtils.areStringsEqual(currentScreenDataPrimaryGraphicName, primaryGraphicName, true, true)\n+\t\t\t\t&& primaryGraphic != null;\n+\t}\n+\n+\t/**\n+\t * Check to see if secondaryGraphic should be updated\n+\t * @return true if secondaryGraphic should be updated, false if not\n+\t */\n+\tprivate boolean shouldUpdateSecondaryImage() {\n+\t\tboolean templateSupportsSecondaryArtwork = (templateSupportsImageField(ImageFieldName.graphic) || templateSupportsImageField(ImageFieldName.secondaryGraphic));\n+\n+\t\tString currentScreenDataSecondaryGraphicName = (currentScreenData != null && currentScreenData.getSecondaryGraphic() != null) ? currentScreenData.getSecondaryGraphic().getValue() : null;\n+\t\tString secondaryGraphicName = secondaryGraphic != null ? secondaryGraphic.getName() : null;\n+\t\treturn templateSupportsSecondaryArtwork\n+\t\t\t\t&& !CompareUtils.areStringsEqual(currentScreenDataSecondaryGraphicName, secondaryGraphicName, true, true)\n+\t\t\t\t&& secondaryGraphic != null;\n+\t}\n+\n+\t/**\n+\t * Check to see if template supports the specified image field\n+\t * @return true if image field is supported, false if not\n+\t */\n+\tprivate boolean templateSupportsImageField(ImageFieldName name) {\n+\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, name);\n+\t}\n+\n+\t/**\n+\t * Check to see if mediaTrackTextField should be updated\n+\t * @return true if mediaTrackTextField should be updated, false if not\n+\t */\n+\tprivate boolean shouldUpdateMediaTrackField() {\n+\t\treturn templateSupportsTextField(TextFieldName.mediaTrack);\n+\t}\n+\n+\t/**\n+\t * Check to see if title should be updated\n+\t * @return true if title should be updated, false if not\n+\t */\n+\tprivate boolean shouldUpdateTitleField() {\n+\t\treturn templateSupportsTextField(TextFieldName.templateTitle);\n+\t}\n+\n+\t/**\n+\t * Check to see if field should be updated\n+\t * @return true if field should be updated, false if not\n+\t */\n+\tprivate boolean templateSupportsTextField(TextFieldName name) {\n+\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasTextFieldOfName(defaultMainWindowCapability, name);\n+\t}\n+\n+\t// SCREEN ITEM SETTERS AND GETTERS\n+\n+\tvoid setTextAlignment(TextAlignment textAlignment){\n \t\tthis.textAlignment = textAlignment;\n \t\t// If we aren't batching, send the update immediately, if we are, set ourselves as dirty (so we know we should send an update after the batch ends)\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tTextAlignment getTextAlignment() {\n+\tTextAlignment getTextAlignment(){\n \t\treturn textAlignment;\n \t}\n \n-\tvoid setMediaTrackTextField(String mediaTrackTextField) {\n+\tvoid setMediaTrackTextField(String mediaTrackTextField){\n \t\tthis.mediaTrackTextField = mediaTrackTextField;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getMediaTrackTextField() {\n+\tString getMediaTrackTextField(){\n \t\treturn mediaTrackTextField;\n \t}\n \n-\tvoid setTextField1(String textField1) {\n+\tvoid setTextField1(String textField1){\n \t\tthis.textField1 = textField1;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField1() {\n+\tString getTextField1(){\n \t\treturn textField1;\n \t}\n \n-\tvoid setTextField2(String textField2) {\n+\tvoid setTextField2(String textField2){\n \t\tthis.textField2 = textField2;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField2() {\n+\tString getTextField2(){\n \t\treturn textField2;\n \t}\n \n-\tvoid setTextField3(String textField3) {\n+\tvoid setTextField3(String textField3){\n \t\tthis.textField3 = textField3;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField3() {\n+\tString getTextField3(){\n \t\treturn textField3;\n \t}\n \n-\tvoid setTextField4(String textField4) {\n+\tvoid setTextField4(String textField4){\n \t\tthis.textField4 = textField4;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField4() {\n+\tString getTextField4(){\n \t\treturn textField4;\n \t}\n \n-\tvoid setTextField1Type(MetadataType textField1Type) {\n+\tvoid setTextField1Type(MetadataType textField1Type){\n \t\tthis.textField1Type = textField1Type;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField1Type() {\n+\tMetadataType getTextField1Type(){\n \t\treturn textField1Type;\n \t}\n \n-\tvoid setTextField2Type(MetadataType textField2Type) {\n+\tvoid setTextField2Type(MetadataType textField2Type){\n \t\tthis.textField2Type = textField2Type;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField2Type() {\n+\tMetadataType getTextField2Type(){\n \t\treturn textField2Type;\n \t}\n \n-\tvoid setTextField3Type(MetadataType textField3Type) {\n+\tvoid setTextField3Type(MetadataType textField3Type){\n \t\tthis.textField3Type = textField3Type;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField3Type() {\n+\tMetadataType getTextField3Type(){\n \t\treturn textField3Type;\n \t}\n \n-\tvoid setTextField4Type(MetadataType textField4Type) {\n+\tvoid setTextField4Type(MetadataType textField4Type){\n \t\tthis.textField4Type = textField4Type;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField4Type() {\n+\tMetadataType getTextField4Type(){\n \t\treturn textField4Type;\n \t}\n \n-\tvoid setTitle(String title) {\n+\tvoid setTitle(String title){\n \t\tthis.title = title;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTitle() {\n+\tString getTitle(){\n \t\treturn title;\n \t}\n \n-\tvoid setPrimaryGraphic(SdlArtwork primaryGraphic) {\n+\tvoid setPrimaryGraphic(SdlArtwork primaryGraphic){\n \t\tthis.primaryGraphic = primaryGraphic;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tSdlArtwork getPrimaryGraphic() {\n+\tSdlArtwork getPrimaryGraphic(){\n \t\treturn primaryGraphic;\n \t}\n \n-\tvoid setSecondaryGraphic(SdlArtwork secondaryGraphic) {\n+\tvoid setSecondaryGraphic(SdlArtwork secondaryGraphic){\n \t\tthis.secondaryGraphic = secondaryGraphic;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tSdlArtwork getSecondaryGraphic() {\n+\tSdlArtwork getSecondaryGraphic(){\n \t\treturn secondaryGraphic;\n \t}\n \n-\tvoid setBatchUpdates(boolean batching) {\n+\tvoid setBatchUpdates(boolean batching){\n \t\tthis.batchingUpdates = batching;\n \t}\n \n-\tprivate void addListeners() {\n-\t\t// add listener\n-\t\thmiListener = new OnRPCNotificationListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n-\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\tcurrentHMILevel = onHMIStatus.getHmiLevel();\n-\t\t\t\tupdateTransactionQueueSuspended();\n-\t\t\t\tif (currentHMILevel == HMILevel.HMI_FULL) {\n-\t\t\t\t\tif (pendingHMIFull) {\n-\t\t\t\t\t\tDebugTool.logInfo(TAG, \"Acquired HMI_FULL with pending update. Sending now\");\n-\t\t\t\t\t\tpendingHMIFull = false;\n-\t\t\t\t\t\tsdlUpdate(pendingHMIListener);\n-\t\t\t\t\t\tpendingHMIListener = null;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t};\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\n-\n-\t\tonDisplaysCapabilityListener = new OnSystemCapabilityListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t// instead of using the parameter it's more safe to use the convenience method\n-\t\t\t\tList<DisplayCapability> capabilities = SystemCapabilityManager.convertToList(capability, DisplayCapability.class);\n-\t\t\t\tif (capabilities == null || capabilities.size() == 0) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"TextAndGraphic Manager - Capabilities sent here are null or empty\");\n-\t\t\t\t} else {\n-\t\t\t\t\tDisplayCapability display = capabilities.get(0);\n-\t\t\t\t\tfor (WindowCapability windowCapability : display.getWindowCapabilities()) {\n-\t\t\t\t\t\tint currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\t\t\t\tif (currentWindowID == PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\t\t\tdefaultMainWindowCapability = windowCapability;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(String info) {\n-\t\t\t\tDebugTool.logError(TAG, \"Display Capability cannot be retrieved\");\n-\t\t\t\tdefaultMainWindowCapability = null;\n-\t\t\t}\n-\t\t};\n-\t\tthis.internalInterface.addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n-\t}\n }\n", "next_change": {"commit": "be7157d524736b19fb9277c5cad3dc0e9bec3935", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex a07e60f20..b8190edaa 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -222,759 +175,314 @@ abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \t\t}\n \t}\n \n-\tprivate synchronized void sdlUpdate(CompletionListener listener){\n-\n-\t\t// make sure hmi is not none\n-\t\tif (currentHMILevel == null || currentHMILevel == HMILevel.HMI_NONE){\n-\t\t\t//Trying to send show on HMI_NONE, waiting for full\n-\t\t\tpendingHMIFull = true;\n-\t\t\tif (listener != null){\n-\t\t\t\tpendingHMIListener = listener;\n+\tprivate synchronized void sdlUpdate(final CompletionListener listener) {\n+\t\tif (transactionQueue.getTasksAsList().size() > 0) {\n+\t\t\t//Transactions already exist, cancelling them\n+\t\t\ttransactionQueue.clear();\n+\t\t\tif (listener != null) {\n+\t\t\t\tlistener.onComplete(false);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n-\n-\t\t//Updating Text and Graphics\n-\t\tif (inProgressUpdate != null){\n-\n-\t\t\t//In progress update exists, queueing update\n-\t\t\tif (queuedUpdateListener != null){\n-\n-\t\t\t\t//Queued update already exists, superseding previous queued update\n-\t\t\t\tqueuedUpdateListener.onComplete(false);\n-\t\t\t\tqueuedUpdateListener = null;\n-\t\t\t}\n-\n-\t\t\tif (listener != null){\n-\t\t\t\tqueuedUpdateListener = listener;\n-\t\t\t}\n-\n-\t\t\thasQueuedUpdate = true;\n-\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tShow fullShow = new Show();\n-\t\tfullShow.setAlignment(textAlignment);\n-\t\tfullShow = assembleShowText(fullShow);\n-\t\tfullShow = assembleShowImages(fullShow);\n-\n-\t\tinProgressListener = listener;\n-\n-\t\tif (!shouldUpdatePrimaryImage() && !shouldUpdateSecondaryImage()){\n-\n-\t\t\t//No Images to send, only sending text\n-\t\t\tinProgressUpdate = extractTextFromShow(fullShow);\n-\t\t\tsendShow();\n-\n-\t\t}else if (!sdlArtworkNeedsUpload(primaryGraphic) && (secondaryGraphic == blankArtwork || !sdlArtworkNeedsUpload(secondaryGraphic))){\n-\n-\t\t\t//Images already uploaded, sending full update\n-\t\t\t// The files to be updated are already uploaded, send the full show immediately\n-\t\t\tinProgressUpdate = fullShow;\n-\t\t\tsendShow();\n-\t\t} else{\n-\n-\t\t\t// Images need to be uploaded, sending text and uploading images\n-\t\t\tinProgressUpdate = fullShow;\n-\t\t\tfinal Show thisUpdate = fullShow;\n-\n-\t\t\tuploadImages(new CompletionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\tif (!success){\n-\t\t\t\t\t\tDebugTool.logError(TAG, \"Error uploading image\");\n-\t\t\t\t\t\tinProgressUpdate = extractTextFromShow(inProgressUpdate);\n-\t\t\t\t\t\tsendShow();\n-\t\t\t\t\t}\n-\t\t\t\t\t// Check if queued image update still matches our images (there could have been a new Show in the meantime)\n-\t\t\t\t\t// and send a new update if it does. Since the images will already be on the head unit, the whole show will be sent\n-\t\t\t\t\tif (thisUpdate.getGraphic() != null && thisUpdate.getGraphic().equals(queuedImageUpdate.getGraphic()) ||\n-\t\t\t\t\t\t\t(thisUpdate.getSecondaryGraphic() != null && queuedImageUpdate.getSecondaryGraphic() != null) && thisUpdate.getSecondaryGraphic().equals(queuedImageUpdate.getSecondaryGraphic())){\n-\t\t\t\t\t\t// Queued image update matches the images we need, sending update\n-\t\t\t\t\t\tsendShow();\n-\t\t\t\t\t}\n-\t\t\t\t\t// Else, Queued image update does not match the images we need, skipping update\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tqueuedImageUpdate = fullShow;\n-\t\t}\n-\t}\n-\n-\tprivate void sendShow(){\n-\t\tinProgressUpdate.setOnRPCResponseListener(new OnRPCResponseListener() {\n+\t\tCurrentScreenDataUpdatedListener currentScreenDataUpdateListener = new CurrentScreenDataUpdatedListener() {\n \t\t\t@Override\n-\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\thandleResponse(response.getSuccess());\n+\t\t\tpublic void onUpdate(Show show) {\n+\t\t\t\tupdatePendingOperationsWithNewScreenData(show);\n \t\t\t}\n-\n+\t\t};\n+\t\tCompletionListener updateOperationListener = new CompletionListener() {\n \t\t\t@Override\n-\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\thandleResponse(false);\n-\t\t\t}\n-\n-\t\t\tprivate void handleResponse(boolean success){\n-\t\t\t\tif (success){\n-\t\t\t\t\tupdateCurrentScreenDataState(inProgressUpdate);\n-\t\t\t\t}\n-\n-\t\t\t\tinProgressUpdate = null;\n-\t\t\t\tif (inProgressListener != null){\n-\t\t\t\t\tinProgressListener.onComplete(success);\n-\t\t\t\t\tinProgressListener = null;\n-\t\t\t\t}\n-\n-\t\t\t\tif (hasQueuedUpdate){\n-\t\t\t\t\t//Queued update exists, sending another update\n-\t\t\t\t\thasQueuedUpdate = false;\n-\t\t\t\t\tCompletionListener temp = queuedUpdateListener;\n-\t\t\t\t\tqueuedUpdateListener = null;\n-\t\t\t\t\tsdlUpdate(temp);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tif (this.softButtonManager.get() != null) {\n-\t\t\tthis.softButtonManager.get().setCurrentMainField1(inProgressUpdate.getMainField1());\n-\t\t}\n-\t\tinternalInterface.sendRPC(inProgressUpdate);\n-\t}\n-\n-\t// Images\n-\n-\tprivate void uploadImages(final CompletionListener listener) {\n-\n-\t\tList<SdlArtwork> artworksToUpload = new ArrayList<>();\n-\n-\t\t// add primary image\n-\t\tif (shouldUpdatePrimaryImage() && !primaryGraphic.isStaticIcon()){\n-\t\t\tartworksToUpload.add(primaryGraphic);\n-\t\t}\n-\n-\t\t// add secondary image\n-\t\tif (shouldUpdateSecondaryImage() && !secondaryGraphic.isStaticIcon()){\n-\t\t\tartworksToUpload.add(secondaryGraphic);\n-\t\t}\n-\n-\t\tif (artworksToUpload.size() == 0 && (primaryGraphic.isStaticIcon() || secondaryGraphic.isStaticIcon())){\n-\t\t\tDebugTool.logInfo(TAG, \"Upload attempted on static icons, sending them without upload instead\");\n-\t\t\tlistener.onComplete(true);\n-\t\t}\n-\n-\t\t// use file manager to upload art\n-\t\tif (fileManager.get() != null) {\n-\t\t\tfileManager.get().uploadArtworks(artworksToUpload, new MultipleFileCompletionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onComplete(Map<String, String> errors) {\n-\t\t\t\t\tif (errors != null) {\n-\t\t\t\t\t\tDebugTool.logError(TAG, \"Error Uploading Artworks. Error: \" + errors.toString());\n-\t\t\t\t\t\tlistener.onComplete(false);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tlistener.onComplete(true);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate Show assembleShowImages(Show show){\n-\n-\t\tif (shouldUpdatePrimaryImage()){\n-\t\t\tshow.setGraphic(primaryGraphic.getImageRPC());\n-\t\t}\n-\n-\t\tif (shouldUpdateSecondaryImage()){\n-\t\t\tshow.setSecondaryGraphic(secondaryGraphic.getImageRPC());\n-\t\t}\n-\n-\t\treturn show;\n-\t}\n-\n-\t// Text\n-\n-\tShow assembleShowText(Show show){\n-\n-\t\tshow = setBlankTextFields(show);\n-\n-\t\tif (mediaTrackTextField != null && shouldUpdateMediaTrackField()) {\n-\t\t\tshow.setMediaTrack(mediaTrackTextField);\n-\t\t}\n-\n-\t\tif (title != null && shouldUpdateTitleField()) {\n-\t\t\tshow.setTemplateTitle(title);\n-\t\t}\n-\n-\t\tList<String> nonNullFields = findValidMainTextFields();\n-\t\tif (nonNullFields.isEmpty()){\n-\t\t\treturn show;\n-\t\t}\n-\n-\t\tint numberOfLines = defaultMainWindowCapability != null ? ManagerUtility.WindowCapabilityUtility.getMaxNumberOfMainFieldLines(defaultMainWindowCapability) : 4;\n-\n-\t\tswitch (numberOfLines) {\n-\t\t\tcase 1: show = assembleOneLineShowText(show, nonNullFields);\n-\t\t\t\tbreak;\n-\t\t\tcase 2: show = assembleTwoLineShowText(show);\n-\t\t\t\tbreak;\n-\t\t\tcase 3: show = assembleThreeLineShowText(show);\n-\t\t\t\tbreak;\n-\t\t\tcase 4: show = assembleFourLineShowText(show);\n-\t\t\t\tbreak;\n-\t\t}\n-\n-\t\treturn show;\n-\t}\n-\n-\tprivate Show assembleOneLineShowText(Show show, List<String> showFields){\n-\n-\t\tStringBuilder showString1 = new StringBuilder();\n-\t\tfor (int i = 0; i < showFields.size(); i++) {\n-\t\t\tif (i > 0) {\n-\t\t\t\tshowString1.append(\" - \").append(showFields.get(i));\n-\t\t\t}else{\n-\t\t\t\tshowString1.append(showFields.get(i));\n-\t\t\t}\n-\t\t}\n-\t\tshow.setMainField1(showString1.toString());\n-\n-\t\tMetadataTags tags = new MetadataTags();\n-\t\ttags.setMainField1(findNonNullMetadataFields());\n-\n-\t\tshow.setMetadataTags(tags);\n-\n-\t\treturn show;\n-\t}\n-\n-\tprivate Show assembleTwoLineShowText(Show show){\n-\n-\t\tStringBuilder tempString = new StringBuilder();\n-\t\tMetadataTags tags = new MetadataTags();\n-\n-\t\tif (textField1 != null && textField1.length() > 0) {\n-\t\t\ttempString.append(textField1);\n-\t\t\tif (textField1Type != null){\n-\t\t\t\ttags.setMainField1(textField1Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField2 != null && textField2.length() > 0) {\n-\t\t\tif (( textField3 == null || !(textField3.length() > 0)) && (textField4 == null || !(textField4.length() > 0))){\n-\t\t\t\t// text does not exist in slots 3 or 4, put text2 in slot 2\n-\t\t\t\tshow.setMainField2(textField2);\n-\t\t\t\tif (textField2Type != null){\n-\t\t\t\t\ttags.setMainField2(textField2Type);\n-\t\t\t\t}\n-\t\t\t} else if (textField1 != null && textField1.length() > 0) {\n-\t\t\t\t// If text 1 exists, put it in slot 1 formatted\n-\t\t\t\ttempString.append(\" - \").append(textField2);\n-\t\t\t\tif (textField2Type != null){\n-\t\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n-\t\t\t\t\ttypeList.add(textField2Type);\n-\t\t\t\t\tif (textField1Type != null){\n-\t\t\t\t\t\ttypeList.add(textField1Type);\n-\t\t\t\t\t}\n-\t\t\t\t\ttags.setMainField1(typeList);\n+\t\t\tpublic void onComplete(boolean success) {\n+\t\t\t\tif (listener != null) {\n+\t\t\t\t\tlistener.onComplete(success);\n \t\t\t\t}\n-\t\t\t}else {\n-\t\t\t\t// If text 1 does not exist, put it in slot 1 unformatted\n-\t\t\t\ttempString.append(textField2);\n-\t\t\t\tif (textField2Type != null){\n-\t\t\t\t\ttags.setMainField1(textField2Type);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// set mainfield 1\n-\t\tshow.setMainField1(tempString.toString());\n-\n-\t\t// new stringbuilder object\n-\t\ttempString = new StringBuilder();\n-\n-\t\tif (textField3 != null && textField3.length() > 0){\n-\t\t\t// If text 3 exists, put it in slot 2\n-\t\t\ttempString.append(textField3);\n-\t\t\tif (textField3Type != null){\n-\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n-\t\t\t\ttypeList.add(textField3Type);\n-\t\t\t\ttags.setMainField2(typeList);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField4 != null && textField4.length() > 0){\n-\t\t\tif (textField3 != null && textField3.length() > 0){\n-\t\t\t\t// If text 3 exists, put it in slot 2 formatted\n-\t\t\t\ttempString.append(\" - \").append(textField4);\n-\t\t\t\tif (textField4Type != null){\n-\t\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n-\t\t\t\t\ttypeList.add(textField4Type);\n-\t\t\t\t\tif (textField3Type != null){\n-\t\t\t\t\t\ttypeList.add(textField3Type);\n-\t\t\t\t\t}\n-\t\t\t\t\ttags.setMainField2(typeList);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// If text 3 does not exist, put it in slot 3 unformatted\n-\t\t\t\ttempString.append(textField4);\n-\t\t\t\tif (textField4Type != null){\n-\t\t\t\t\ttags.setMainField2(textField4Type);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (tempString.toString().length() > 0){\n-\t\t\tshow.setMainField2(tempString.toString());\n-\t\t}\n-\n-\t\tshow.setMetadataTags(tags);\n-\t\treturn show;\n-\t}\n-\n-\tprivate Show assembleThreeLineShowText(Show show){\n-\n-\t\tMetadataTags tags = new MetadataTags();\n-\n-\t\tif (textField1 != null && textField1.length() > 0) {\n-\t\t\tshow.setMainField1(textField1);\n-\t\t\tif (textField1Type != null){\n-\t\t\t\ttags.setMainField1(textField1Type);\n \t\t\t}\n-\t\t}\n-\n-\t\tif (textField2 != null && textField2.length() > 0) {\n-\t\t\tshow.setMainField2(textField2);\n-\t\t\tif (textField2Type != null){\n-\t\t\t\ttags.setMainField2(textField2Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tStringBuilder tempString = new StringBuilder();\n-\n-\t\tif (textField3 != null && textField3.length() > 0){\n-\t\t\ttempString.append(textField3);\n-\t\t\tif (textField3Type != null){\n-\t\t\t\ttags.setMainField3(textField3Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField4 != null && textField4.length() > 0) {\n-\t\t\tif (textField3 != null && textField3.length() > 0) {\n-\t\t\t\t// If text 3 exists, put it in slot 3 formatted\n-\t\t\t\ttempString.append(\" - \").append(textField4);\n-\t\t\t\tif (textField4Type != null){\n-\t\t\t\t\tList<MetadataType> tags4 = new ArrayList<>();\n-\t\t\t\t\tif (textField3Type != null){\n-\t\t\t\t\t\ttags4.add(textField3Type);\n-\t\t\t\t\t}\n-\t\t\t\t\ttags4.add(textField4Type);\n-\t\t\t\t\ttags.setMainField3(tags4);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// If text 3 does not exist, put it in slot 3 formatted\n-\t\t\t\ttempString.append(textField4);\n-\t\t\t\tif (textField4Type != null){\n-\t\t\t\t\ttags.setMainField3(textField4Type);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+\t\t};\n \n-\t\tshow.setMainField3(tempString.toString());\n-\t\tshow.setMetadataTags(tags);\n-\t\treturn show;\n+\t\tupdateOperation = new TextAndGraphicUpdateOperation(internalInterface, fileManager.get(), defaultMainWindowCapability, currentScreenData, currentState(), updateOperationListener, currentScreenDataUpdateListener);\n+\t\ttransactionQueue.add(updateOperation, false);\n \t}\n-\n-\tprivate Show assembleFourLineShowText(Show show){\n-\n-\t\tMetadataTags tags = new MetadataTags();\n-\n-\t\tif (textField1 != null && textField1.length() > 0) {\n-\t\t\tshow.setMainField1(textField1);\n-\t\t\tif (textField1Type != null){\n-\t\t\t\ttags.setMainField1(textField1Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField2 != null && textField2.length() > 0) {\n-\t\t\tshow.setMainField2(textField2);\n-\t\t\tif (textField2Type != null){\n-\t\t\t\ttags.setMainField2(textField2Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField3 != null && textField3.length() > 0) {\n-\t\t\tshow.setMainField3(textField3);\n-\t\t\tif (textField3Type != null){\n-\t\t\t\ttags.setMainField3(textField3Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField4 != null && textField4.length() > 0) {\n-\t\t\tshow.setMainField4(textField4);\n-\t\t\tif (textField4Type != null){\n-\t\t\t\ttags.setMainField4(textField4Type);\n+\t//Updates pending task with current screen data\n+\tvoid updatePendingOperationsWithNewScreenData(Show newScreenData){\n+\t\tfor(Task task: transactionQueue.getTasksAsList()){\n+\t\t\tif(!(task instanceof TextAndGraphicUpdateOperation) || task.getState() == Task.IN_PROGRESS){\n+\t\t\t\tcontinue;\n \t\t\t}\n+\t\t\t((TextAndGraphicUpdateOperation) task).setCurrentScreenData(newScreenData);\n \t\t}\n-\n-\t\tshow.setMetadataTags(tags);\n-\t\treturn show;\n-\t}\n-\n-\t// Extraction\n-\n-\tShow extractTextFromShow(Show show){\n-\n-\t\tShow newShow = new Show();\n-\t\tnewShow.setMainField1(show.getMainField1());\n-\t\tnewShow.setMainField2(show.getMainField2());\n-\t\tnewShow.setMainField3(show.getMainField3());\n-\t\tnewShow.setMainField4(show.getMainField4());\n-\t\tnewShow.setTemplateTitle(show.getTemplateTitle());\n-\n-\t\treturn newShow;\n-\t}\n-\n-\tprivate Show setBlankTextFields(Show newShow){\n-\n-\t\tnewShow.setMainField1(\"\");\n-\t\tnewShow.setMainField2(\"\");\n-\t\tnewShow.setMainField3(\"\");\n-\t\tnewShow.setMainField4(\"\");\n-\t\tnewShow.setMediaTrack(\"\");\n-\t\tnewShow.setTemplateTitle(\"\");\n-\n-\t\treturn newShow;\n \t}\n \n-\tprivate void updateCurrentScreenDataState(Show show){\n-\n-\t\tif (show == null){\n-\t\t\tDebugTool.logError(TAG, \"can not updateCurrentScreenDataFromShow from null show\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// If the items are null, they were not updated, so we can't just set it directly\n-\t\tif (show.getMainField1() != null){\n-\t\t\tcurrentScreenData.setMainField1(show.getMainField1());\n-\t\t}\n-\t\tif (show.getMainField2() != null){\n-\t\t\tcurrentScreenData.setMainField2(show.getMainField2());\n-\t\t}\n-\t\tif (show.getMainField3() != null){\n-\t\t\tcurrentScreenData.setMainField3(show.getMainField3());\n-\t\t}\n-\t\tif (show.getMainField4() != null){\n-\t\t\tcurrentScreenData.setMainField4(show.getMainField4());\n-\t\t}\n-\t\tif (show.getTemplateTitle() != null){\n-\t\t\tcurrentScreenData.setTemplateTitle(show.getTemplateTitle());\n-\t\t}\n-\t\tif (show.getMediaTrack() != null){\n-\t\t\tcurrentScreenData.setMediaTrack(show.getMediaTrack());\n-\t\t}\n-\t\tif (show.getMetadataTags() != null){\n-\t\t\tcurrentScreenData.setMetadataTags(show.getMetadataTags());\n-\t\t}\n-\t\tif (show.getAlignment() != null){\n-\t\t\tcurrentScreenData.setAlignment(show.getAlignment());\n-\t\t}\n-\t\tif (show.getGraphic() != null){\n-\t\t\tcurrentScreenData.setGraphic(show.getGraphic());\n-\t\t}\n-\t\tif (show.getSecondaryGraphic() != null){\n-\t\t\tcurrentScreenData.setSecondaryGraphic(show.getSecondaryGraphic());\n-\t\t}\n+\tinterface CurrentScreenDataUpdatedListener{\n+\t\tvoid onUpdate(Show show);\n \t}\n \n-\t// Helpers\n \n-\tprivate List<String> findValidMainTextFields(){\n+\tprivate List<String> findNonNullTextFields() {\n \t\tList<String> array = new ArrayList<>();\n \n-\t\tif (textField1 != null && textField1.length() > 0) {\n+\t\tif (textField1 != null) {\n \t\t\tarray.add(textField1);\n \t\t}\n \n-\t\tif (textField2 != null && textField2.length() > 0) {\n+\t\tif (textField2 != null) {\n \t\t\tarray.add(textField2);\n \t\t}\n \n-\t\tif (textField3 != null && textField3.length() > 0) {\n+\t\tif (textField3 != null) {\n \t\t\tarray.add(textField3);\n \t\t}\n \n-\t\tif (textField4 != null && textField4.length() > 0) {\n+\t\tif (textField4 != null) {\n \t\t\tarray.add(textField4);\n \t\t}\n \n-\t\treturn array;\n-\t}\n-\n-\n-\tprivate List<MetadataType> findNonNullMetadataFields(){\n-\t\tList<MetadataType> array = new ArrayList<>();\n-\n-\t\tif (textField1Type != null) {\n-\t\t\tarray.add(textField1Type);\n-\t\t}\n-\n-\t\tif (textField2Type != null) {\n-\t\t\tarray.add(textField2Type);\n-\t\t}\n-\n-\t\tif (textField3Type != null) {\n-\t\t\tarray.add(textField3Type);\n+\t\tif(title != null){\n+\t\t\tarray.add(title);\n \t\t}\n \n-\t\tif (textField4Type != null) {\n-\t\t\tarray.add(textField4Type);\n+\t\tif(mediaTrackTextField != null){\n+\t\t\tarray.add(mediaTrackTextField);\n \t\t}\n \n \t\treturn array;\n \t}\n \n-\tabstract SdlArtwork getBlankArtwork();\n+\tBoolean hasData() {\n+\t\tboolean hasTextFields = (findNonNullTextFields().size() > 0);\n+\t\tboolean hasImageFields = (primaryGraphic != null) || (secondaryGraphic != null);\n \n-\t@SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n-\tprivate boolean sdlArtworkNeedsUpload(SdlArtwork artwork){\n-\t\tif (fileManager.get() != null) {\n-\t\t\treturn artwork != null && !fileManager.get().hasUploadedFile(artwork) && !artwork.isStaticIcon();\n-\t\t}\n-\t\treturn false;\n+\t\treturn hasTextFields || hasImageFields;\n \t}\n \n-\t/**\n-\t * Check to see if primaryGraphic should be updated\n-\t * @return true if primaryGraphic should be updated, false if not\n-\t */\n-\tprivate boolean shouldUpdatePrimaryImage() {\n-\t\tboolean templateSupportsPrimaryArtwork = templateSupportsImageField(ImageFieldName.graphic);\n-\n-\t\tString currentScreenDataPrimaryGraphicName = (currentScreenData != null && currentScreenData.getGraphic() != null) ? currentScreenData.getGraphic().getValue() : null;\n-\t\tString primaryGraphicName = primaryGraphic != null ? primaryGraphic.getName() : null;\n-\t\treturn templateSupportsPrimaryArtwork\n-\t\t\t\t&& !CompareUtils.areStringsEqual(currentScreenDataPrimaryGraphicName, primaryGraphicName, true, true)\n-\t\t\t\t&& primaryGraphic != null;\n-\t}\n \n-\t/**\n-\t * Check to see if secondaryGraphic should be updated\n-\t * @return true if secondaryGraphic should be updated, false if not\n-\t */\n-\tprivate boolean shouldUpdateSecondaryImage() {\n-\t\tboolean templateSupportsSecondaryArtwork = (templateSupportsImageField(ImageFieldName.graphic) || templateSupportsImageField(ImageFieldName.secondaryGraphic));\n+\t// Convert to State\n \n-\t\tString currentScreenDataSecondaryGraphicName = (currentScreenData != null && currentScreenData.getSecondaryGraphic() != null) ? currentScreenData.getSecondaryGraphic().getValue() : null;\n-\t\tString secondaryGraphicName = secondaryGraphic != null ? secondaryGraphic.getName() : null;\n-\t\treturn templateSupportsSecondaryArtwork\n-\t\t\t\t&& !CompareUtils.areStringsEqual(currentScreenDataSecondaryGraphicName, secondaryGraphicName, true, true)\n-\t\t\t\t&& secondaryGraphic != null;\n+\tprivate TextsAndGraphicsState currentState() {\n+\t\treturn new TextsAndGraphicsState(textField1, textField2, textField3, textField4, mediaTrackTextField,\n+\t\t\t\ttitle, primaryGraphic, secondaryGraphic, textAlignment, textField1Type, textField2Type, textField3Type, textField4Type);\n \t}\n \n-\t/**\n-\t * Check to see if template supports the specified image field\n-\t * @return true if image field is supported, false if not\n-\t */\n-\tprivate boolean templateSupportsImageField(ImageFieldName name) {\n-\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, name);\n-\t}\n+\t// Getters / Setters\n \n-\t/**\n-\t * Check to see if mediaTrackTextField should be updated\n-\t * @return true if mediaTrackTextField should be updated, false if not\n-\t */\n-\tprivate boolean shouldUpdateMediaTrackField() {\n-\t\treturn templateSupportsTextField(TextFieldName.mediaTrack);\n-\t}\n-\n-\t/**\n-\t * Check to see if title should be updated\n-\t * @return true if title should be updated, false if not\n-\t */\n-\tprivate boolean shouldUpdateTitleField() {\n-\t\treturn templateSupportsTextField(TextFieldName.templateTitle);\n-\t}\n-\n-\t/**\n-\t * Check to see if field should be updated\n-\t * @return true if field should be updated, false if not\n-\t */\n-\tprivate boolean templateSupportsTextField(TextFieldName name) {\n-\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasTextFieldOfName(defaultMainWindowCapability, name);\n-\t}\n-\n-\t// SCREEN ITEM SETTERS AND GETTERS\n-\n-\tvoid setTextAlignment(TextAlignment textAlignment){\n+\tvoid setTextAlignment(TextAlignment textAlignment) {\n \t\tthis.textAlignment = textAlignment;\n \t\t// If we aren't batching, send the update immediately, if we are, set ourselves as dirty (so we know we should send an update after the batch ends)\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tTextAlignment getTextAlignment(){\n+\tTextAlignment getTextAlignment() {\n \t\treturn textAlignment;\n \t}\n \n-\tvoid setMediaTrackTextField(String mediaTrackTextField){\n+\tvoid setMediaTrackTextField(String mediaTrackTextField) {\n \t\tthis.mediaTrackTextField = mediaTrackTextField;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getMediaTrackTextField(){\n+\tString getMediaTrackTextField() {\n \t\treturn mediaTrackTextField;\n \t}\n \n-\tvoid setTextField1(String textField1){\n+\tvoid setTextField1(String textField1) {\n \t\tthis.textField1 = textField1;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField1(){\n+\tString getTextField1() {\n \t\treturn textField1;\n \t}\n \n-\tvoid setTextField2(String textField2){\n+\tvoid setTextField2(String textField2) {\n \t\tthis.textField2 = textField2;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField2(){\n+\tString getTextField2() {\n \t\treturn textField2;\n \t}\n \n-\tvoid setTextField3(String textField3){\n+\tvoid setTextField3(String textField3) {\n \t\tthis.textField3 = textField3;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField3(){\n+\tString getTextField3() {\n \t\treturn textField3;\n \t}\n \n-\tvoid setTextField4(String textField4){\n+\tvoid setTextField4(String textField4) {\n \t\tthis.textField4 = textField4;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField4(){\n+\tString getTextField4() {\n \t\treturn textField4;\n \t}\n \n-\tvoid setTextField1Type(MetadataType textField1Type){\n+\tvoid setTextField1Type(MetadataType textField1Type) {\n \t\tthis.textField1Type = textField1Type;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField1Type(){\n+\tMetadataType getTextField1Type() {\n \t\treturn textField1Type;\n \t}\n \n-\tvoid setTextField2Type(MetadataType textField2Type){\n+\tvoid setTextField2Type(MetadataType textField2Type) {\n \t\tthis.textField2Type = textField2Type;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField2Type(){\n+\tMetadataType getTextField2Type() {\n \t\treturn textField2Type;\n \t}\n \n-\tvoid setTextField3Type(MetadataType textField3Type){\n+\tvoid setTextField3Type(MetadataType textField3Type) {\n \t\tthis.textField3Type = textField3Type;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField3Type(){\n+\tMetadataType getTextField3Type() {\n \t\treturn textField3Type;\n \t}\n \n-\tvoid setTextField4Type(MetadataType textField4Type){\n+\tvoid setTextField4Type(MetadataType textField4Type) {\n \t\tthis.textField4Type = textField4Type;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField4Type(){\n+\tMetadataType getTextField4Type() {\n \t\treturn textField4Type;\n \t}\n \n-\tvoid setTitle(String title){\n+\tvoid setTitle(String title) {\n \t\tthis.title = title;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTitle(){\n+\tString getTitle() {\n \t\treturn title;\n \t}\n \n-\tvoid setPrimaryGraphic(SdlArtwork primaryGraphic){\n+\tvoid setPrimaryGraphic(SdlArtwork primaryGraphic) {\n \t\tthis.primaryGraphic = primaryGraphic;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tSdlArtwork getPrimaryGraphic(){\n+\tSdlArtwork getPrimaryGraphic() {\n \t\treturn primaryGraphic;\n \t}\n \n-\tvoid setSecondaryGraphic(SdlArtwork secondaryGraphic){\n+\tvoid setSecondaryGraphic(SdlArtwork secondaryGraphic) {\n \t\tthis.secondaryGraphic = secondaryGraphic;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tSdlArtwork getSecondaryGraphic(){\n+\tSdlArtwork getSecondaryGraphic() {\n \t\treturn secondaryGraphic;\n \t}\n \n-\tvoid setBatchUpdates(boolean batching){\n+\tvoid setBatchUpdates(boolean batching) {\n \t\tthis.batchingUpdates = batching;\n \t}\n \n+\tprivate void addListeners() {\n+\t\t// add listener\n+\t\thmiListener = new OnRPCNotificationListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onNotified(RPCNotification notification) {\n+\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tcurrentHMILevel = onHMIStatus.getHmiLevel();\n+\t\t\t\tupdateTransactionQueueSuspended();\n+\t\t\t}\n+\t\t};\n+\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+\n+\t\tonDisplaysCapabilityListener = new OnSystemCapabilityListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n+\t\t\t\t// instead of using the parameter it's more safe to use the convenience method\n+\t\t\t\tList<DisplayCapability> capabilities = SystemCapabilityManager.convertToList(capability, DisplayCapability.class);\n+\t\t\t\tif (capabilities == null || capabilities.size() == 0) {\n+\t\t\t\t\tDebugTool.logError(TAG, \"TextAndGraphic Manager - Capabilities sent here are null or empty\");\n+\t\t\t\t} else {\n+\t\t\t\t\tDisplayCapability display = capabilities.get(0);\n+\t\t\t\t\tfor (WindowCapability windowCapability : display.getWindowCapabilities()) {\n+\t\t\t\t\t\tint currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+\t\t\t\t\t\tif (currentWindowID == PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+\t\t\t\t\t\t\tdefaultMainWindowCapability = windowCapability;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t// Update the queue's suspend state\n+\t\t\t\tupdateTransactionQueueSuspended();\n+\t\t\t\tif (hasData()) {\n+\t\t\t\t\tupdate(null);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void onError(String info) {\n+\t\t\t\tDebugTool.logError(TAG, \"Display Capability cannot be retrieved\");\n+\t\t\t\tdefaultMainWindowCapability = null;\n+\t\t\t\tupdateTransactionQueueSuspended();\n+\t\t\t}\n+\t\t};\n+\t\tthis.internalInterface.addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+\t}\n }\n", "next_change": {"commit": "9e77ff43b1450f656e8ae6405a8da6bb435e5127", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex b8190edaa..4bdfcb441 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -483,6 +504,8 @@ abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \t\t\t\tupdateTransactionQueueSuspended();\n \t\t\t}\n \t\t};\n-\t\tthis.internalInterface.addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+\t\tif (internalInterface.getSystemCapabilityManager() != null) {\n+\t\t\tthis.internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+\t\t}\n \t}\n }\n", "next_change": {"commit": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex 4bdfcb441..0a201fc22 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -69,443 +69,504 @@ import static com.smartdevicelink.proxy.rpc.enums.TextAlignment.CENTERED;\n  */\n abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \n-\tprivate static final String TAG = \"TextAndGraphicManager\";\n-\n-\tboolean isDirty;\n-\tShow currentScreenData;\n-\tHMILevel currentHMILevel;\n-\tprivate final WeakReference<SoftButtonManager> softButtonManager;\n-\tWindowCapability defaultMainWindowCapability;\n-\tprivate boolean batchingUpdates;\n-\tprivate final WeakReference<FileManager> fileManager;\n-\tSdlArtwork blankArtwork;\n-\tprivate OnRPCNotificationListener hmiListener;\n-\tprivate OnSystemCapabilityListener onDisplaysCapabilityListener;\n-\tprivate SdlArtwork primaryGraphic, secondaryGraphic;\n-\tprivate TextAlignment textAlignment;\n-\tprivate String textField1, textField2, textField3, textField4, mediaTrackTextField, title;\n-\tprivate MetadataType textField1Type, textField2Type, textField3Type, textField4Type;\n-\tTextAndGraphicUpdateOperation updateOperation;\n-\tprivate CompletionListener currentOperationListener;\n-\tQueue transactionQueue;\n-\n-\t//Constructors\n-\n-\tBaseTextAndGraphicManager(@NonNull ISdl internalInterface, @NonNull FileManager fileManager, @NonNull SoftButtonManager softButtonManager) {\n-\t\t// set class vars\n-\t\tsuper(internalInterface);\n-\t\tthis.fileManager = new WeakReference<>(fileManager);\n-\t\tthis.softButtonManager = new WeakReference<>(softButtonManager);\n-\t\tbatchingUpdates = false;\n-\t\tisDirty = false;\n-\t\ttextAlignment = CENTERED;\n-\t\tcurrentHMILevel = HMILevel.HMI_NONE;\n-\t\tcurrentScreenData = new Show();\n-\t\tthis.transactionQueue = newTransactionQueue();\n-\t\taddListeners();\n-\t}\n-\n-\t@Override\n-\tpublic void start(CompletionListener listener) {\n-\t\ttransitionToState(READY);\n-\t\tsuper.start(listener);\n-\t}\n-\n-\t@Override\n-\tpublic void dispose() {\n-\t\ttextField1 = null;\n-\t\ttextField1Type = null;\n-\t\ttextField2 = null;\n-\t\ttextField2Type = null;\n-\t\ttextField3 = null;\n-\t\ttextField3Type = null;\n-\t\ttextField4 = null;\n-\t\ttextField4Type = null;\n-\t\tmediaTrackTextField = null;\n-\t\ttitle = null;\n-\t\ttextAlignment = null;\n-\t\tprimaryGraphic = null;\n-\t\tsecondaryGraphic = null;\n-\t\tblankArtwork = null;\n-\t\tdefaultMainWindowCapability = null;\n-\t\tcurrentScreenData = null;\n-\t\tisDirty = false;\n-\t\tupdateOperation = null;\n-\n-\t\t// Cancel the operations\n-\t\tif (transactionQueue != null) {\n-\t\t\ttransactionQueue.close();\n-\t\t\ttransactionQueue = null;\n-\t\t}\n-\n-\t\t// remove listeners\n-\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\tif (internalInterface.getSystemCapabilityManager() != null) {\n-\t\t\tinternalInterface.getSystemCapabilityManager().removeOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n-\t\t}\n-\n-\t\tsuper.dispose();\n-\t}\n-\n-\tprivate Queue newTransactionQueue() {\n-\t\tQueue queue = internalInterface.getTaskmaster().createQueue(\"TextAndGraphicManager\", 3, false);\n-\t\tqueue.pause();\n-\t\treturn queue;\n-\t}\n-\n-\t// Suspend the queue if the WindowCapabilities are null\n-\t// OR if the HMI level is NONE since we want to delay sending RPCs until we're in non-NONE\n-\tprivate void updateTransactionQueueSuspended() {\n-\t\tif (defaultMainWindowCapability == null || HMILevel.HMI_NONE.equals(currentHMILevel)) {\n-\t\t\tDebugTool.logInfo(TAG, String.format(\"Suspending the transaction queue. Current HMI level is NONE: %b, window capabilities are null: %b\", HMILevel.HMI_NONE.equals(currentHMILevel), defaultMainWindowCapability == null));\n-\t\t\ttransactionQueue.pause();\n-\t\t} else {\n-\t\t\tDebugTool.logInfo(TAG, \"Starting the transaction queue\");\n-\t\t\ttransactionQueue.resume();\n-\t\t}\n-\t}\n-\n-\t// Upload / Send\n-\n-\tprotected void update(CompletionListener listener) {\n-\t\t// check if is batch update\n-\t\tif (batchingUpdates) {\n-\t\t\treturn;\n-\t\t}\n-\t\tif (isDirty) {\n-\t\t\tisDirty = false;\n-\t\t\tsdlUpdate(listener);\n-\t\t} else if (listener != null) {\n-\t\t\tlistener.onComplete(true);\n-\t\t}\n-\t}\n-\n-\tprivate synchronized void sdlUpdate(final CompletionListener listener) {\n-\t\tif (this.transactionQueue.getTasksAsList().size() > 0) {\n-\t\t\t// Transactions already in queue, we need to clear it out\n-\t\t\ttransactionQueue.clear();\n-\t\t\tupdateOperation = null;\n-\t\t\tif (currentOperationListener != null) {\n-\t\t\t\tcurrentOperationListener.onComplete(false);\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Task can be READY, about to start and popped of the queue, so we have to cancel it, to prevent it from starting\n-\t\tif (updateOperation != null && updateOperation.getState() == Task.READY) {\n-\t\t\tupdateOperation.cancelTask();\n-\t\t\tif (currentOperationListener != null) {\n-\t\t\t\tcurrentOperationListener.onComplete(false);\n-\t\t\t}\n-\t\t}\n-\n-\t\t// If Task is IN_PROGRESS, it\u2019s not on the queue, we need to mark it as cancelled. The task will return at some point when it checks its status and call the listener back\n-\t\tif (updateOperation != null && updateOperation.getState() == Task.IN_PROGRESS) {\n-\t\t\tupdateOperation.cancelTask();\n-\t\t}\n-\n-\t\tcurrentOperationListener = listener;\n-\n-\t\tCurrentScreenDataUpdatedListener currentScreenDataUpdateListener = new CurrentScreenDataUpdatedListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onUpdate(Show show) {\n-\t\t\t\tupdatePendingOperationsWithNewScreenData(show);\n-\t\t\t\tcurrentScreenData = show;\n-\t\t\t}\n-\t\t};\n-\n-\t\tupdateOperation = new TextAndGraphicUpdateOperation(internalInterface, fileManager.get(), defaultMainWindowCapability, currentScreenData, currentState(), currentOperationListener, currentScreenDataUpdateListener);\n-\t\ttransactionQueue.add(updateOperation, false);\n-\t}\n-\n-\t//Updates pending task with current screen data\n-\tvoid updatePendingOperationsWithNewScreenData(Show newScreenData) {\n-\t\tfor (Task task : transactionQueue.getTasksAsList()) {\n-\t\t\tif (!(task instanceof TextAndGraphicUpdateOperation)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\t((TextAndGraphicUpdateOperation) task).setCurrentScreenData(newScreenData);\n-\t\t}\n-\t\tif (this.softButtonManager.get() != null && newScreenData.getMainField1() != null) {\n-\t\t\tthis.softButtonManager.get().setCurrentMainField1(currentScreenData.getMainField1());\n-\t\t}\n-\t}\n-\n-\tinterface CurrentScreenDataUpdatedListener {\n-\t\tvoid onUpdate(Show show);\n-\t}\n-\n-\n-\tprivate List<String> findNonNullTextFields() {\n-\t\tList<String> array = new ArrayList<>();\n-\n-\t\tif (textField1 != null) {\n-\t\t\tarray.add(textField1);\n-\t\t}\n-\n-\t\tif (textField2 != null) {\n-\t\t\tarray.add(textField2);\n-\t\t}\n-\n-\t\tif (textField3 != null) {\n-\t\t\tarray.add(textField3);\n-\t\t}\n-\n-\t\tif (textField4 != null) {\n-\t\t\tarray.add(textField4);\n-\t\t}\n-\n-\t\tif (title != null) {\n-\t\t\tarray.add(title);\n-\t\t}\n-\n-\t\tif (mediaTrackTextField != null) {\n-\t\t\tarray.add(mediaTrackTextField);\n-\t\t}\n-\n-\t\treturn array;\n-\t}\n-\n-\tBoolean hasData() {\n-\t\tboolean hasTextFields = (findNonNullTextFields().size() > 0);\n-\t\tboolean hasImageFields = (primaryGraphic != null) || (secondaryGraphic != null);\n-\n-\t\treturn hasTextFields || hasImageFields;\n-\t}\n-\n-\tabstract SdlArtwork getBlankArtwork();\n-\n-\n-\t// Convert to State\n-\n-\tprivate TextsAndGraphicsState currentState() {\n-\t\treturn new TextsAndGraphicsState(textField1, textField2, textField3, textField4, mediaTrackTextField,\n-\t\t\t\ttitle, primaryGraphic, secondaryGraphic, textAlignment, textField1Type, textField2Type, textField3Type, textField4Type);\n-\t}\n-\n-\t// Getters / Setters\n-\n-\tvoid setTextAlignment(TextAlignment textAlignment) {\n-\t\tthis.textAlignment = textAlignment;\n-\t\t// If we aren't batching, send the update immediately, if we are, set ourselves as dirty (so we know we should send an update after the batch ends)\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tTextAlignment getTextAlignment() {\n-\t\treturn textAlignment;\n-\t}\n-\n-\tvoid setMediaTrackTextField(String mediaTrackTextField) {\n-\t\tthis.mediaTrackTextField = mediaTrackTextField;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tString getMediaTrackTextField() {\n-\t\treturn mediaTrackTextField;\n-\t}\n-\n-\tvoid setTextField1(String textField1) {\n-\t\tthis.textField1 = textField1;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tString getTextField1() {\n-\t\treturn textField1;\n-\t}\n-\n-\tvoid setTextField2(String textField2) {\n-\t\tthis.textField2 = textField2;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tString getTextField2() {\n-\t\treturn textField2;\n-\t}\n-\n-\tvoid setTextField3(String textField3) {\n-\t\tthis.textField3 = textField3;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tString getTextField3() {\n-\t\treturn textField3;\n-\t}\n-\n-\tvoid setTextField4(String textField4) {\n-\t\tthis.textField4 = textField4;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tString getTextField4() {\n-\t\treturn textField4;\n-\t}\n-\n-\tvoid setTextField1Type(MetadataType textField1Type) {\n-\t\tthis.textField1Type = textField1Type;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tMetadataType getTextField1Type() {\n-\t\treturn textField1Type;\n-\t}\n-\n-\tvoid setTextField2Type(MetadataType textField2Type) {\n-\t\tthis.textField2Type = textField2Type;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tMetadataType getTextField2Type() {\n-\t\treturn textField2Type;\n-\t}\n-\n-\tvoid setTextField3Type(MetadataType textField3Type) {\n-\t\tthis.textField3Type = textField3Type;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tMetadataType getTextField3Type() {\n-\t\treturn textField3Type;\n-\t}\n-\n-\tvoid setTextField4Type(MetadataType textField4Type) {\n-\t\tthis.textField4Type = textField4Type;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tMetadataType getTextField4Type() {\n-\t\treturn textField4Type;\n-\t}\n-\n-\tvoid setTitle(String title) {\n-\t\tthis.title = title;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tString getTitle() {\n-\t\treturn title;\n-\t}\n-\n-\tvoid setPrimaryGraphic(SdlArtwork primaryGraphic) {\n-\t\tthis.primaryGraphic = primaryGraphic;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tSdlArtwork getPrimaryGraphic() {\n-\t\treturn primaryGraphic;\n-\t}\n-\n-\tvoid setSecondaryGraphic(SdlArtwork secondaryGraphic) {\n-\t\tthis.secondaryGraphic = secondaryGraphic;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tSdlArtwork getSecondaryGraphic() {\n-\t\treturn secondaryGraphic;\n-\t}\n-\n-\tvoid setBatchUpdates(boolean batching) {\n-\t\tthis.batchingUpdates = batching;\n-\t}\n-\n-\tprivate void addListeners() {\n-\t\t// add listener\n-\t\thmiListener = new OnRPCNotificationListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n-\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tcurrentHMILevel = onHMIStatus.getHmiLevel();\n-\t\t\t\tupdateTransactionQueueSuspended();\n-\t\t\t}\n-\t\t};\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\n-\t\tonDisplaysCapabilityListener = new OnSystemCapabilityListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t// instead of using the parameter it's more safe to use the convenience method\n-\t\t\t\tList<DisplayCapability> capabilities = SystemCapabilityManager.convertToList(capability, DisplayCapability.class);\n-\t\t\t\tif (capabilities == null || capabilities.size() == 0) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"TextAndGraphic Manager - Capabilities sent here are null or empty\");\n-\t\t\t\t\tdefaultMainWindowCapability = null;\n-\t\t\t\t} else {\n-\t\t\t\t\tDisplayCapability display = capabilities.get(0);\n-\t\t\t\t\tfor (WindowCapability windowCapability : display.getWindowCapabilities()) {\n-\t\t\t\t\t\tint currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\t\t\t\tif (currentWindowID == PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\t\t\tdefaultMainWindowCapability = windowCapability;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t// Update the queue's suspend state\n-\t\t\t\tupdateTransactionQueueSuspended();\n-\t\t\t\tif (hasData()) {\n-\t\t\t\t\tsdlUpdate(null);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(String info) {\n-\t\t\t\tDebugTool.logError(TAG, \"Display Capability cannot be retrieved\");\n-\t\t\t\tdefaultMainWindowCapability = null;\n-\t\t\t\tupdateTransactionQueueSuspended();\n-\t\t\t}\n-\t\t};\n-\t\tif (internalInterface.getSystemCapabilityManager() != null) {\n-\t\t\tthis.internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n-\t\t}\n-\t}\n+    private static final String TAG = \"TextAndGraphicManager\";\n+\n+    boolean isDirty;\n+    TextAndGraphicState currentScreenData;\n+    HMILevel currentHMILevel;\n+    private final WeakReference<SoftButtonManager> softButtonManager;\n+    WindowCapability defaultMainWindowCapability;\n+    private boolean batchingUpdates;\n+    private final WeakReference<FileManager> fileManager;\n+    SdlArtwork blankArtwork;\n+    private OnRPCNotificationListener hmiListener;\n+    private OnSystemCapabilityListener onDisplaysCapabilityListener;\n+    private SdlArtwork primaryGraphic, secondaryGraphic;\n+    private TextAlignment textAlignment;\n+    private String textField1, textField2, textField3, textField4, mediaTrackTextField, title;\n+    private MetadataType textField1Type, textField2Type, textField3Type, textField4Type;\n+    private TemplateConfiguration templateConfiguration;\n+    TextAndGraphicUpdateOperation updateOperation;\n+    private CompletionListener currentOperationListener;\n+    Queue transactionQueue;\n+\n+    //Constructors\n+\n+    BaseTextAndGraphicManager(@NonNull ISdl internalInterface, @NonNull FileManager fileManager, @NonNull SoftButtonManager softButtonManager) {\n+        // set class vars\n+        super(internalInterface);\n+        this.fileManager = new WeakReference<>(fileManager);\n+        this.softButtonManager = new WeakReference<>(softButtonManager);\n+        batchingUpdates = false;\n+        isDirty = false;\n+        textAlignment = CENTERED;\n+        currentHMILevel = HMILevel.HMI_NONE;\n+        currentScreenData = new TextAndGraphicState();\n+        this.transactionQueue = newTransactionQueue();\n+        addListeners();\n+    }\n+\n+    @Override\n+    public void start(CompletionListener listener) {\n+        transitionToState(READY);\n+        super.start(listener);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        textField1 = null;\n+        textField1Type = null;\n+        textField2 = null;\n+        textField2Type = null;\n+        textField3 = null;\n+        textField3Type = null;\n+        textField4 = null;\n+        textField4Type = null;\n+        mediaTrackTextField = null;\n+        title = null;\n+        textAlignment = null;\n+        primaryGraphic = null;\n+        secondaryGraphic = null;\n+        blankArtwork = null;\n+        defaultMainWindowCapability = null;\n+        currentScreenData = null;\n+        isDirty = false;\n+        updateOperation = null;\n+\n+        // Cancel the operations\n+        if (transactionQueue != null) {\n+            transactionQueue.close();\n+            transactionQueue = null;\n+        }\n+\n+        // remove listeners\n+        internalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        if (internalInterface.getSystemCapabilityManager() != null) {\n+            internalInterface.getSystemCapabilityManager().removeOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private Queue newTransactionQueue() {\n+        Queue queue = internalInterface.getTaskmaster().createQueue(\"TextAndGraphicManager\", 3, false);\n+        queue.pause();\n+        return queue;\n+    }\n+\n+    // Suspend the queue if the WindowCapabilities are null\n+    // OR if the HMI level is NONE since we want to delay sending RPCs until we're in non-NONE\n+    private void updateTransactionQueueSuspended() {\n+        if (defaultMainWindowCapability == null || HMILevel.HMI_NONE.equals(currentHMILevel)) {\n+            DebugTool.logInfo(TAG, String.format(\"Suspending the transaction queue. Current HMI level is NONE: %b, window capabilities are null: %b\", HMILevel.HMI_NONE.equals(currentHMILevel), defaultMainWindowCapability == null));\n+            transactionQueue.pause();\n+        } else {\n+            DebugTool.logInfo(TAG, \"Starting the transaction queue\");\n+            transactionQueue.resume();\n+        }\n+    }\n+\n+    // Upload / Send\n+\n+    protected void update(CompletionListener listener) {\n+        // check if is batch update\n+        if (batchingUpdates) {\n+            return;\n+        }\n+        if (isDirty) {\n+            isDirty = false;\n+            sdlUpdate(true, listener);\n+        } else if (listener != null) {\n+            listener.onComplete(true);\n+        }\n+    }\n+\n+    private synchronized void sdlUpdate(Boolean supersedePreviousOperations, final CompletionListener listener) {\n+        if (this.transactionQueue.getTasksAsList().size() > 0 && supersedePreviousOperations) {\n+            // Transactions already in queue, we need to clear it out\n+            transactionQueue.clear();\n+            updateOperation = null;\n+            if (currentOperationListener != null) {\n+                currentOperationListener.onComplete(false);\n+            }\n+        }\n+\n+        // Task can be READY, about to start and popped of the queue, so we have to cancel it, to prevent it from starting\n+        if (updateOperation != null && updateOperation.getState() == Task.READY && supersedePreviousOperations) {\n+            updateOperation.cancelTask();\n+            if (currentOperationListener != null) {\n+                currentOperationListener.onComplete(false);\n+            }\n+        }\n+\n+        // If Task is IN_PROGRESS, it\u2019s not on the queue, we need to mark it as cancelled. The task will return at some point when it checks its status and call the listener back\n+        if (updateOperation != null && updateOperation.getState() == Task.IN_PROGRESS && supersedePreviousOperations) {\n+            updateOperation.cancelTask();\n+        }\n+\n+        currentOperationListener = listener;\n+\n+        CurrentScreenDataUpdatedListener currentScreenDataUpdateListener = new CurrentScreenDataUpdatedListener() {\n+            @Override\n+            public void onUpdate(TextAndGraphicState newScreenData) {\n+                if (newScreenData != null) {\n+                    // Update our current screen data\n+                    currentScreenData = newScreenData;\n+                    updatePendingOperationsWithNewScreenData();\n+                }\n+            }\n+\n+            @Override\n+            public void onError() {\n+                // Invalidate data that's different from our current screen data\n+                resetFieldsToCurrentScreenData();\n+            }\n+        };\n+\n+        updateOperation = new TextAndGraphicUpdateOperation(internalInterface, fileManager.get(), defaultMainWindowCapability, currentScreenData, currentState(), currentOperationListener, currentScreenDataUpdateListener);\n+        transactionQueue.add(updateOperation, false);\n+    }\n+\n+    void resetFieldsToCurrentScreenData() {\n+        textField1 = currentScreenData.getTextField1();\n+        textField2 = currentScreenData.getTextField2();\n+        textField3 = currentScreenData.getTextField3();\n+        textField4 = currentScreenData.getTextField4();\n+        mediaTrackTextField = currentScreenData.getMediaTrackTextField();\n+        title = currentScreenData.getTitle();\n+        textAlignment = currentScreenData.getTextAlignment();\n+        textField1Type = currentScreenData.getTextField1Type();\n+        textField2Type = currentScreenData.getTextField2Type();\n+        textField3Type = currentScreenData.getTextField3Type();\n+        textField4Type = currentScreenData.getTextField4Type();\n+        primaryGraphic = currentScreenData.getPrimaryGraphic();\n+        secondaryGraphic = currentScreenData.getSecondaryGraphic();\n+        templateConfiguration = currentScreenData.getTemplateConfiguration();\n+    }\n+\n+    //Updates pending task with current screen data\n+    void updatePendingOperationsWithNewScreenData() {\n+        for (Task task : transactionQueue.getTasksAsList()) {\n+            if (!(task instanceof TextAndGraphicUpdateOperation)) {\n+                continue;\n+            }\n+            ((TextAndGraphicUpdateOperation) task).setCurrentScreenData(currentScreenData);\n+        }\n+        if (this.softButtonManager.get() != null && currentScreenData.getTextField1() != null) {\n+            this.softButtonManager.get().setCurrentMainField1(currentScreenData.getTextField1());\n+        }\n+    }\n+\n+    interface CurrentScreenDataUpdatedListener {\n+        void onUpdate(TextAndGraphicState newState);\n+\n+        void onError();\n+    }\n+\n+\n+    private List<String> findNonNullTextFields() {\n+        List<String> array = new ArrayList<>();\n+\n+        if (textField1 != null) {\n+            array.add(textField1);\n+        }\n+\n+        if (textField2 != null) {\n+            array.add(textField2);\n+        }\n+\n+        if (textField3 != null) {\n+            array.add(textField3);\n+        }\n+\n+        if (textField4 != null) {\n+            array.add(textField4);\n+        }\n+\n+        if (title != null) {\n+            array.add(title);\n+        }\n+\n+        if (mediaTrackTextField != null) {\n+            array.add(mediaTrackTextField);\n+        }\n+\n+        return array;\n+    }\n+\n+    Boolean hasData() {\n+        boolean hasTextFields = (findNonNullTextFields().size() > 0);\n+        boolean hasImageFields = (primaryGraphic != null) || (secondaryGraphic != null);\n+\n+        return hasTextFields || hasImageFields;\n+    }\n+\n+    abstract SdlArtwork getBlankArtwork();\n+\n+\n+    // Convert to State\n+\n+    TextAndGraphicState currentState() {\n+        return new TextAndGraphicState(textField1, textField2, textField3, textField4, mediaTrackTextField,\n+                title, primaryGraphic, secondaryGraphic, textAlignment, textField1Type, textField2Type, textField3Type, textField4Type, templateConfiguration);\n+    }\n+\n+    // Getters / Setters\n+\n+    void setTextAlignment(TextAlignment textAlignment) {\n+        this.textAlignment = textAlignment;\n+        // If we aren't batching, send the update immediately, if we are, set ourselves as dirty (so we know we should send an update after the batch ends)\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    TextAlignment getTextAlignment() {\n+        return textAlignment;\n+    }\n+\n+    void setMediaTrackTextField(String mediaTrackTextField) {\n+        this.mediaTrackTextField = mediaTrackTextField;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    String getMediaTrackTextField() {\n+        return mediaTrackTextField;\n+    }\n+\n+    void setTextField1(String textField1) {\n+        this.textField1 = textField1;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    String getTextField1() {\n+        return textField1;\n+    }\n+\n+    void setTextField2(String textField2) {\n+        this.textField2 = textField2;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    String getTextField2() {\n+        return textField2;\n+    }\n+\n+    void setTextField3(String textField3) {\n+        this.textField3 = textField3;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    String getTextField3() {\n+        return textField3;\n+    }\n+\n+    void setTextField4(String textField4) {\n+        this.textField4 = textField4;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    String getTextField4() {\n+        return textField4;\n+    }\n+\n+    void setTextField1Type(MetadataType textField1Type) {\n+        this.textField1Type = textField1Type;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    MetadataType getTextField1Type() {\n+        return textField1Type;\n+    }\n+\n+    void setTextField2Type(MetadataType textField2Type) {\n+        this.textField2Type = textField2Type;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    MetadataType getTextField2Type() {\n+        return textField2Type;\n+    }\n+\n+    void setTextField3Type(MetadataType textField3Type) {\n+        this.textField3Type = textField3Type;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    MetadataType getTextField3Type() {\n+        return textField3Type;\n+    }\n+\n+    void setTextField4Type(MetadataType textField4Type) {\n+        this.textField4Type = textField4Type;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    MetadataType getTextField4Type() {\n+        return textField4Type;\n+    }\n+\n+    void setTitle(String title) {\n+        this.title = title;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    String getTitle() {\n+        return title;\n+    }\n+\n+    void setPrimaryGraphic(SdlArtwork primaryGraphic) {\n+        this.primaryGraphic = primaryGraphic;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    SdlArtwork getPrimaryGraphic() {\n+        return primaryGraphic;\n+    }\n+\n+    void setSecondaryGraphic(SdlArtwork secondaryGraphic) {\n+        this.secondaryGraphic = secondaryGraphic;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    /**\n+     * Change the current layout to a new layout and optionally update the layout's night and day color schemes.\n+     * The values set for the text, graphics, buttons and template title persist between layout changes.\n+     * To update the text, graphics, buttons and template title at the same time as the template, batch all the updates between beginTransaction and commit.\n+     * If the layout update fails while batching, then the updated text, graphics, buttons or template title will also not be updated.\n+     *\n+     * @param templateConfiguration The new configuration of the template, including the layout and color scheme.\n+     * @param listener              A listener that will be called when the layout change finished.\n+     */\n+    void changeLayout(TemplateConfiguration templateConfiguration, CompletionListener listener) {\n+        setTemplateConfiguration(templateConfiguration);\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, listener);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    TemplateConfiguration getTemplateConfiguration() {\n+        return templateConfiguration;\n+    }\n+\n+    void setTemplateConfiguration(TemplateConfiguration templateConfiguration) {\n+        // Don't do the `isBatchingUpdates` like elsewhere because the call is already handled in `changeLayout(TemplateConfiguration templateConfiguration, CompletionListener listener) `\n+        this.templateConfiguration = templateConfiguration;\n+    }\n+\n+    SdlArtwork getSecondaryGraphic() {\n+        return secondaryGraphic;\n+    }\n+\n+    void setBatchUpdates(boolean batching) {\n+        this.batchingUpdates = batching;\n+    }\n+\n+    private void addListeners() {\n+        // add listener\n+        hmiListener = new OnRPCNotificationListener() {\n+            @Override\n+            public void onNotified(RPCNotification notification) {\n+                OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                    return;\n+                }\n+                currentHMILevel = onHMIStatus.getHmiLevel();\n+                updateTransactionQueueSuspended();\n+            }\n+        };\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+\n+        onDisplaysCapabilityListener = new OnSystemCapabilityListener() {\n+            @Override\n+            public void onCapabilityRetrieved(Object capability) {\n+                // instead of using the parameter it's more safe to use the convenience method\n+                List<DisplayCapability> capabilities = SystemCapabilityManager.convertToList(capability, DisplayCapability.class);\n+                if (capabilities == null || capabilities.size() == 0) {\n+                    DebugTool.logError(TAG, \"TextAndGraphic Manager - Capabilities sent here are null or empty\");\n+                    defaultMainWindowCapability = null;\n+                } else {\n+                    DisplayCapability display = capabilities.get(0);\n+                    for (WindowCapability windowCapability : display.getWindowCapabilities()) {\n+                        int currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+                        if (currentWindowID == PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                            // Check if the window capability is equal to the one we already have. If it is, abort.\n+                            if (defaultMainWindowCapability != null && defaultMainWindowCapability.getStore().equals(windowCapability.getStore())) {\n+                                return;\n+                            }\n+                            defaultMainWindowCapability = windowCapability;\n+                        }\n+                    }\n+                }\n+                // Update the queue's suspend state\n+                updateTransactionQueueSuspended();\n+                if (hasData()) {\n+                    // HAX: Capability updates cannot supersede earlier updates because of the case where a developer batched a `changeLayout` call w/ T&G changes on < 6.0 systems could cause this to come in before the operation completes. That would cause the operation to report a \"failure\" (because it was superseded by this call) when in fact the operation didn't fail at all and is just being adjusted.\n+                    sdlUpdate(false, null);\n+                }\n+            }\n+\n+            @Override\n+            public void onError(String info) {\n+                DebugTool.logError(TAG, \"Display Capability cannot be retrieved\");\n+                defaultMainWindowCapability = null;\n+                updateTransactionQueueSuspended();\n+            }\n+        };\n+        if (internalInterface.getSystemCapabilityManager() != null) {\n+            this.internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "message": "Merge commit", "committedDate": null}, {"oid": "763753da5436d9e296cda95e50a5c7ac3740079c", "committedDate": "2020-05-20 15:56:21 -0400", "message": "Update null checks for the Base Managers"}, {"oid": "52ef200d1c60e85373c2a5484d03c11ad87f5ec3", "committedDate": "2020-05-26 11:01:01 -0400", "message": "Fix max line"}, {"oid": "9762e00fd51397c5e3549c7ef2dd9fe2910c376b", "committedDate": "2020-06-11 11:58:43 -0400", "message": "Create Log Wrapper and Repace Base library logging"}, {"oid": "a13463c85c8969dd1934cfbe35804a8cce00281c", "committedDate": "2020-06-11 16:09:29 -0400", "message": "Wrap Log.java and move base logging to DebugTool"}, {"oid": "df7badc06dfdeb3b9cccb7496d1a27471874e877", "committedDate": "2020-06-26 15:03:18 -0400", "message": "Use new logInfo API instead of Deprecated API"}, {"oid": "05d262701ff3495da7470a925bf67a91b57ad163", "committedDate": "2020-06-26 16:40:13 -0400", "message": "Move logError to new DebugTool APIs in android/base"}, {"oid": "87f443305eef5dcf5d0cd70ecbe9ad5f7c5c5100", "committedDate": "2020-08-04 16:50:18 -0400", "message": "Move SCM to managers.lifecycle package"}, {"oid": "3e9f90212e713f85369e6a11f1d15abf3b966bdf", "committedDate": "2020-08-10 19:35:10 -0400", "message": "Update imports to androidX"}, {"oid": "faeb0e9ee70af8bb81eda226bbac0082f72e6417", "committedDate": "2020-08-18 15:21:22 -0400", "message": "Remove onError from TextAndGraphicManager"}, {"oid": "d1ade9d639958a5a9eca69488d62a0ef7d196f40", "committedDate": "2020-08-18 16:10:19 -0400", "message": "Very rough draft, Added two classes TextAndGraphicUpdateOperation and TextAndGraphicsState. Refactored BaseT&Gmanager"}, {"oid": "afd900229c8e4bea0c1062a858acc8c8e2ffaea2", "committedDate": "2020-08-18 16:32:55 -0400", "message": "Added call to updateTransactionQueueSuspended in hmiListener and fixed some formatting"}, {"oid": "be1956908cf446b7ae84f91fabbf43a6d248af97", "committedDate": "2020-08-19 10:58:47 -0400", "message": "Align blankArtwork logic with IOS"}, {"oid": "d10a5525520ba077ac2f1f841e6bb9653880263f", "committedDate": "2020-08-19 16:26:07 -0400", "message": "Fixed formatting and Aligned logic with IOS"}, {"oid": "09cfdefd37f14f684f34417b19351d10bfb9a389", "committedDate": "2020-08-20 13:25:33 -0400", "message": "Added null check for listener"}, {"oid": "0f6a3f5c7f286686a78e7ecc9ee397bcbba675b0", "committedDate": "2020-08-21 11:16:08 -0400", "message": "Fix OnSystemCapabilityListener package name"}, {"oid": "7d27d47885cc983ba9c9f49df4ff329654dea0de", "committedDate": "2020-08-21 13:08:18 -0400", "message": "Remove unsed imports"}, {"oid": "b667a9b159f6d7443acdcd1b5b230652dbd576b8", "committedDate": "2020-08-21 15:38:41 -0400", "message": "Merge branch 'develop' into feature/fix_scm_package"}, {"oid": "be7157d524736b19fb9277c5cad3dc0e9bec3935", "committedDate": "2020-08-21 16:08:35 -0400", "message": "IOS alignment"}, {"oid": "8750183930d06f53f51353e6839c6ae27a323547", "committedDate": "2020-08-22 16:05:22 -0400", "message": "Merge branch 'develop' into TextAndGraphicsManager-Refactor-Queues"}, {"oid": "788be099f11fb96e3ebb9a2dce9752fb6c9e3735", "committedDate": "2020-08-22 16:14:07 -0400", "message": "Fix OnRPCResponseListener in TextAndGraphicsOperation and remove unused imports"}, {"oid": "381094c7666e36dbe4e66da837ed05a1d9c6f093", "committedDate": "2020-08-22 16:55:33 -0400", "message": "Added unit test to TextAndGraphicsManager"}, {"oid": "f9fa66d9d5f540bbedb98b8377974de4ee2bafad", "committedDate": "2020-08-23 15:27:41 -0400", "message": "Added test for OnRPCNotificationListener in T&G manager"}, {"oid": "ec88eaab3e4d130500185f303dea98ebaa04481f", "committedDate": "2020-08-23 17:50:59 -0400", "message": "Added functionality to cancel task and fix formatting"}, {"oid": "676b3db50a6ef9cb5314dbb89a8b23c4a95f2337", "committedDate": "2020-08-23 17:59:45 -0400", "message": "Updated copyright fixed formatting"}, {"oid": "de3f00e43aa8d61e7cb589c16d4fe57d416abda1", "committedDate": "2020-08-24 15:40:07 -0400", "message": "Fixed task executing canceling"}, {"oid": "54e78d863f1d714f85b1fd03de67842f3199826a", "committedDate": "2020-08-24 15:56:50 -0400", "message": "Fix canceling logic for operations"}, {"oid": "f0ac42ed59bd8b0a45c7a7c3f1a41f8dae5075c0", "committedDate": "2020-08-24 16:00:03 -0400", "message": "Added null check"}, {"oid": "3954d4ea76e35d5fa5bc17ba7eae4e7ae8544a7e", "committedDate": "2020-08-26 11:38:32 -0400", "message": "Fixed softButton mainField1 issue"}, {"oid": "cdaac8e90faf848b22a64aa322af3ca9776af764", "committedDate": "2020-08-26 13:42:58 -0400", "message": "Add Override back for blankArtwork"}, {"oid": "8d445a8cb181722c74172dae9266458563692c0a", "committedDate": "2020-08-26 14:43:21 -0400", "message": "Updated CurrentScreenData with onUpdate while updating pending operations, set defadefaultMainWindowCapability to null if no capabilities received"}, {"oid": "cdadb3bf31051787bf48bcb14a0e7da1d4300706", "committedDate": "2020-08-26 19:01:18 -0400", "message": "Fixed queue management"}, {"oid": "22fd530fe67f1ea15d732b922a403c8d07600125", "committedDate": "2020-08-26 19:26:45 -0400", "message": "Fixed Unit test"}, {"oid": "64543b97b18d07005cb827435ca0161c3dd9291d", "committedDate": "2020-08-27 17:13:31 -0400", "message": "Fixing issues form Review"}, {"oid": "9b2831fa6f6c6a46c285bf1050e1762243e417b6", "committedDate": "2020-08-27 17:15:57 -0400", "message": "Update comments"}, {"oid": "9e77ff43b1450f656e8ae6405a8da6bb435e5127", "committedDate": "2020-09-08 15:25:03 -0400", "message": "Remove Deprecated Isdl methods (#1485)"}, {"oid": "cd4ac27321c641ef4a9c9f6628059735364ef4dd", "committedDate": "2020-09-15 14:02:09 -0400", "message": "Move proxy interfaces to better packages"}, {"oid": "6e93579d490d60deb382e96ee4bc8d7581989929", "committedDate": "2020-09-17 13:40:18 -0400", "message": "[SDL 0278] Screen Manager Template Management (#1492)"}, {"oid": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "committedDate": "2020-09-17 16:31:17 -0400", "message": "Run the Reformat Code tool on the project"}, {"oid": "44b38cb3766f2685aee586db0ede1d00dffd19e4", "committedDate": "2022-09-21 15:22:23 -0400", "message": "Bugfix/issue 1828 Good text failing (#1831)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5NjE4Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406296186", "body": "I don't believe this logic is correct. Based on the RPC spec, the `imageField` array is not mandatory. Therefore if it is not included, we should infer that it is not supported, right? @joeljfischer can you confirm?", "bodyText": "I don't believe this logic is correct. Based on the RPC spec, the imageField array is not mandatory. Therefore if it is not included, we should infer that it is not supported, right? @joeljfischer can you confirm?", "bodyHTML": "<p dir=\"auto\">I don't believe this logic is correct. Based on the RPC spec, the <code>imageField</code> array is not mandatory. Therefore if it is not included, we should infer that it is not supported, right? <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/joeljfischer/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/joeljfischer\">@joeljfischer</a> can you confirm?</p>", "author": "joeygrover", "createdAt": "2020-04-09T15:39:51Z", "path": "base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java", "diffHunk": "@@ -741,53 +742,64 @@ private boolean sdlArtworkNeedsUpload(SdlArtwork artwork){\n \t\treturn false;\n \t}\n \n+\t/**\n+\t * Check to see if primaryGraphic should be updated\n+\t * @return true if primaryGraphic should be updated, false if not\n+\t */\n \tprivate boolean shouldUpdatePrimaryImage() {\n-\t\tif (defaultMainWindowCapability == null || defaultMainWindowCapability.getImageTypeSupported() == null || defaultMainWindowCapability.getImageTypeSupported().size() > 0) {\n-\t\t\tif (currentScreenData.getGraphic() == null) {\n-\t\t\t\treturn primaryGraphic != null;\n-\t\t\t} else {\n-\t\t\t\treturn currentScreenData != null\n-\t\t\t\t\t\t&& (primaryGraphic != null && !CompareUtils.areStringsEqual(currentScreenData.getGraphic().getValue(), primaryGraphic.getName(), true, true));\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n+\t\tboolean templateSupportsPrimaryArtwork = templateSupportsImageField(ImageFieldName.graphic);\n+\n+\t\tString currentScreenDataPrimaryGraphicName = (currentScreenData != null && currentScreenData.getGraphic() != null) ? currentScreenData.getGraphic().getValue() : null;\n+\t\tString primaryGraphicName = primaryGraphic != null ? primaryGraphic.getName() : null;\n+\t\treturn templateSupportsPrimaryArtwork\n+\t\t\t\t&& !CompareUtils.areStringsEqual(currentScreenDataPrimaryGraphicName, primaryGraphicName, true, true)\n+\t\t\t\t&& primaryGraphic != null;\n \t}\n \n+\t/**\n+\t * Check to see if secondaryGraphic should be updated\n+\t * @return true if secondaryGraphic should be updated, false if not\n+\t */\n \tprivate boolean shouldUpdateSecondaryImage() {\n-\t\t// Cannot detect if there is a secondary image, so we'll just try to detect if there's a primary image and allow it if there is.\n-\t\tif (defaultMainWindowCapability == null || defaultMainWindowCapability.getImageTypeSupported() == null || defaultMainWindowCapability.getImageTypeSupported().size() > 0) {\n-\t\t\tif (currentScreenData.getGraphic() == null) {\n-\t\t\t\treturn secondaryGraphic != null;\n-\t\t\t} else {\n-\t\t\t\treturn currentScreenData != null\n-\t\t\t\t\t\t&& (secondaryGraphic != null && !CompareUtils.areStringsEqual(currentScreenData.getGraphic().getValue(), secondaryGraphic.getName(), true, true));\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n+\t\tboolean templateSupportsSecondaryArtwork = (templateSupportsImageField(ImageFieldName.graphic) || templateSupportsImageField(ImageFieldName.secondaryGraphic));\n \n-\tint getNumberOfLines() {\n+\t\tString currentScreenDataSecondaryGraphicName = (currentScreenData != null && currentScreenData.getSecondaryGraphic() != null) ? currentScreenData.getSecondaryGraphic().getValue() : null;\n+\t\tString secondaryGraphicName = secondaryGraphic != null ? secondaryGraphic.getName() : null;\n+\t\treturn templateSupportsSecondaryArtwork\n+\t\t\t\t&& !CompareUtils.areStringsEqual(currentScreenDataSecondaryGraphicName, secondaryGraphicName, true, true)\n+\t\t\t\t&& secondaryGraphic != null;\n+\t}\n \n-\t\tif (defaultMainWindowCapability == null){\n-\t\t\treturn 4;\n-\t\t}\n+\t/**\n+\t * Check to see if template supports the specified image field\n+\t * @return true if image field is supported, false if not\n+\t */\n+\tprivate boolean templateSupportsImageField(ImageFieldName name) {\n+\t\treturn (defaultMainWindowCapability == null || defaultMainWindowCapability.getImageFields() == null) || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, name);", "originalCommit": "40ed2d11522da4529c645b5df05df0fedd8769e1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "763753da5436d9e296cda95e50a5c7ac3740079c", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex 2deb11f09..debccabbe 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -775,7 +775,7 @@ abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \t * @return true if image field is supported, false if not\n \t */\n \tprivate boolean templateSupportsImageField(ImageFieldName name) {\n-\t\treturn (defaultMainWindowCapability == null || defaultMainWindowCapability.getImageFields() == null) || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, name);\n+\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, name);\n \t}\n \n \t/**\n", "next_change": {"commit": "d1ade9d639958a5a9eca69488d62a0ef7d196f40", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex debccabbe..b5ee13f11 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -687,122 +286,14 @@ abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \n \t// Helpers\n \n-\tprivate List<String> findValidMainTextFields(){\n-\t\tList<String> array = new ArrayList<>();\n-\n-\t\tif (textField1 != null && textField1.length() > 0) {\n-\t\t\tarray.add(textField1);\n-\t\t}\n-\n-\t\tif (textField2 != null && textField2.length() > 0) {\n-\t\t\tarray.add(textField2);\n-\t\t}\n-\n-\t\tif (textField3 != null && textField3.length() > 0) {\n-\t\t\tarray.add(textField3);\n-\t\t}\n-\n-\t\tif (textField4 != null && textField4.length() > 0) {\n-\t\t\tarray.add(textField4);\n-\t\t}\n-\n-\t\treturn array;\n-\t}\n-\n+\t// IOS has sdl_hasData\n \n-\tprivate List<MetadataType> findNonNullMetadataFields(){\n-\t\tList<MetadataType> array = new ArrayList<>();\n-\n-\t\tif (textField1Type != null) {\n-\t\t\tarray.add(textField1Type);\n-\t\t}\n-\n-\t\tif (textField2Type != null) {\n-\t\t\tarray.add(textField2Type);\n-\t\t}\n-\n-\t\tif (textField3Type != null) {\n-\t\t\tarray.add(textField3Type);\n-\t\t}\n-\n-\t\tif (textField4Type != null) {\n-\t\t\tarray.add(textField4Type);\n-\t\t}\n-\n-\t\treturn array;\n-\t}\n+\t//Equality IOS has this section with:\n+\t// sdl_showImages\n \n \tabstract SdlArtwork getBlankArtwork();\n \n-\t@SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n-\tprivate boolean sdlArtworkNeedsUpload(SdlArtwork artwork){\n-\t\tif (fileManager.get() != null) {\n-\t\t\treturn artwork != null && !fileManager.get().hasUploadedFile(artwork) && !artwork.isStaticIcon();\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * Check to see if primaryGraphic should be updated\n-\t * @return true if primaryGraphic should be updated, false if not\n-\t */\n-\tprivate boolean shouldUpdatePrimaryImage() {\n-\t\tboolean templateSupportsPrimaryArtwork = templateSupportsImageField(ImageFieldName.graphic);\n-\n-\t\tString currentScreenDataPrimaryGraphicName = (currentScreenData != null && currentScreenData.getGraphic() != null) ? currentScreenData.getGraphic().getValue() : null;\n-\t\tString primaryGraphicName = primaryGraphic != null ? primaryGraphic.getName() : null;\n-\t\treturn templateSupportsPrimaryArtwork\n-\t\t\t\t&& !CompareUtils.areStringsEqual(currentScreenDataPrimaryGraphicName, primaryGraphicName, true, true)\n-\t\t\t\t&& primaryGraphic != null;\n-\t}\n-\n-\t/**\n-\t * Check to see if secondaryGraphic should be updated\n-\t * @return true if secondaryGraphic should be updated, false if not\n-\t */\n-\tprivate boolean shouldUpdateSecondaryImage() {\n-\t\tboolean templateSupportsSecondaryArtwork = (templateSupportsImageField(ImageFieldName.graphic) || templateSupportsImageField(ImageFieldName.secondaryGraphic));\n-\n-\t\tString currentScreenDataSecondaryGraphicName = (currentScreenData != null && currentScreenData.getSecondaryGraphic() != null) ? currentScreenData.getSecondaryGraphic().getValue() : null;\n-\t\tString secondaryGraphicName = secondaryGraphic != null ? secondaryGraphic.getName() : null;\n-\t\treturn templateSupportsSecondaryArtwork\n-\t\t\t\t&& !CompareUtils.areStringsEqual(currentScreenDataSecondaryGraphicName, secondaryGraphicName, true, true)\n-\t\t\t\t&& secondaryGraphic != null;\n-\t}\n-\n-\t/**\n-\t * Check to see if template supports the specified image field\n-\t * @return true if image field is supported, false if not\n-\t */\n-\tprivate boolean templateSupportsImageField(ImageFieldName name) {\n-\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, name);\n-\t}\n-\n-\t/**\n-\t * Check to see if mediaTrackTextField should be updated\n-\t * @return true if mediaTrackTextField should be updated, false if not\n-\t */\n-\tprivate boolean shouldUpdateMediaTrackField() {\n-\t\treturn templateSupportsTextField(TextFieldName.mediaTrack);\n-\t}\n-\n-\t/**\n-\t * Check to see if title should be updated\n-\t * @return true if title should be updated, false if not\n-\t */\n-\tprivate boolean shouldUpdateTitleField() {\n-\t\treturn templateSupportsTextField(TextFieldName.templateTitle);\n-\t}\n-\n-\t/**\n-\t * Check to see if field should be updated\n-\t * @return true if field should be updated, false if not\n-\t */\n-\tprivate boolean templateSupportsTextField(TextFieldName name) {\n-\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasTextFieldOfName(defaultMainWindowCapability, name);\n-\t}\n-\n-\t// SCREEN ITEM SETTERS AND GETTERS\n+\t// Getters / Setters\n \n \tvoid setTextAlignment(TextAlignment textAlignment){\n \t\tthis.textAlignment = textAlignment;\n", "next_change": {"commit": "afd900229c8e4bea0c1062a858acc8c8e2ffaea2", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex b5ee13f11..371c49a98 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -295,177 +296,177 @@ abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \n \t// Getters / Setters\n \n-\tvoid setTextAlignment(TextAlignment textAlignment){\n+\tvoid setTextAlignment(TextAlignment textAlignment) {\n \t\tthis.textAlignment = textAlignment;\n \t\t// If we aren't batching, send the update immediately, if we are, set ourselves as dirty (so we know we should send an update after the batch ends)\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tTextAlignment getTextAlignment(){\n+\tTextAlignment getTextAlignment() {\n \t\treturn textAlignment;\n \t}\n \n-\tvoid setMediaTrackTextField(String mediaTrackTextField){\n+\tvoid setMediaTrackTextField(String mediaTrackTextField) {\n \t\tthis.mediaTrackTextField = mediaTrackTextField;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getMediaTrackTextField(){\n+\tString getMediaTrackTextField() {\n \t\treturn mediaTrackTextField;\n \t}\n \n-\tvoid setTextField1(String textField1){\n+\tvoid setTextField1(String textField1) {\n \t\tthis.textField1 = textField1;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField1(){\n+\tString getTextField1() {\n \t\treturn textField1;\n \t}\n \n-\tvoid setTextField2(String textField2){\n+\tvoid setTextField2(String textField2) {\n \t\tthis.textField2 = textField2;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField2(){\n+\tString getTextField2() {\n \t\treturn textField2;\n \t}\n \n-\tvoid setTextField3(String textField3){\n+\tvoid setTextField3(String textField3) {\n \t\tthis.textField3 = textField3;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField3(){\n+\tString getTextField3() {\n \t\treturn textField3;\n \t}\n \n-\tvoid setTextField4(String textField4){\n+\tvoid setTextField4(String textField4) {\n \t\tthis.textField4 = textField4;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField4(){\n+\tString getTextField4() {\n \t\treturn textField4;\n \t}\n \n-\tvoid setTextField1Type(MetadataType textField1Type){\n+\tvoid setTextField1Type(MetadataType textField1Type) {\n \t\tthis.textField1Type = textField1Type;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField1Type(){\n+\tMetadataType getTextField1Type() {\n \t\treturn textField1Type;\n \t}\n \n-\tvoid setTextField2Type(MetadataType textField2Type){\n+\tvoid setTextField2Type(MetadataType textField2Type) {\n \t\tthis.textField2Type = textField2Type;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField2Type(){\n+\tMetadataType getTextField2Type() {\n \t\treturn textField2Type;\n \t}\n \n-\tvoid setTextField3Type(MetadataType textField3Type){\n+\tvoid setTextField3Type(MetadataType textField3Type) {\n \t\tthis.textField3Type = textField3Type;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField3Type(){\n+\tMetadataType getTextField3Type() {\n \t\treturn textField3Type;\n \t}\n \n-\tvoid setTextField4Type(MetadataType textField4Type){\n+\tvoid setTextField4Type(MetadataType textField4Type) {\n \t\tthis.textField4Type = textField4Type;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField4Type(){\n+\tMetadataType getTextField4Type() {\n \t\treturn textField4Type;\n \t}\n \n-\tvoid setTitle(String title){\n+\tvoid setTitle(String title) {\n \t\tthis.title = title;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTitle(){\n+\tString getTitle() {\n \t\treturn title;\n \t}\n \n-\tvoid setPrimaryGraphic(SdlArtwork primaryGraphic){\n+\tvoid setPrimaryGraphic(SdlArtwork primaryGraphic) {\n \t\tthis.primaryGraphic = primaryGraphic;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tSdlArtwork getPrimaryGraphic(){\n+\tSdlArtwork getPrimaryGraphic() {\n \t\treturn primaryGraphic;\n \t}\n \n-\tvoid setSecondaryGraphic(SdlArtwork secondaryGraphic){\n+\tvoid setSecondaryGraphic(SdlArtwork secondaryGraphic) {\n \t\tthis.secondaryGraphic = secondaryGraphic;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tSdlArtwork getSecondaryGraphic(){\n+\tSdlArtwork getSecondaryGraphic() {\n \t\treturn secondaryGraphic;\n \t}\n \n-\tvoid setBatchUpdates(boolean batching){\n+\tvoid setBatchUpdates(boolean batching) {\n \t\tthis.batchingUpdates = batching;\n \t}\n \n", "next_change": {"commit": "0f6a3f5c7f286686a78e7ecc9ee397bcbba675b0", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex 371c49a98..a07e60f20 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -162,363 +155,826 @@ abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \t\tsuper.dispose();\n \t}\n \n-\t//TODO temp location Also what do I set the ID to?\n-\tprivate Queue newTransactionQueue() {\n-\t\tQueue queue = internalInterface.getTaskmaster().createQueue(\"TextAndGraphicManager\", 9, false);\n-\t\tqueue.pause();\n-\t\treturn queue;\n-\t}\n+\tprivate void addListeners() {\n+\t\t// add listener\n+\t\thmiListener = new OnRPCNotificationListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onNotified(RPCNotification notification) {\n+\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus)notification;\n+\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tcurrentHMILevel = onHMIStatus.getHmiLevel();\n+\t\t\t\tif (currentHMILevel == HMILevel.HMI_FULL){\n+\t\t\t\t\tif (pendingHMIFull){\n+\t\t\t\t\t\tDebugTool.logInfo(TAG, \"Acquired HMI_FULL with pending update. Sending now\");\n+\t\t\t\t\t\tpendingHMIFull = false;\n+\t\t\t\t\t\tsdlUpdate(pendingHMIListener);\n+\t\t\t\t\t\tpendingHMIListener = null;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n \n-\t//TODO fix for T&G Manager\n-\t// Suspend the queue if the soft button capabilities are null (we assume that soft buttons are not supported)\n-\t// OR if the HMI level is NONE since we want to delay sending RPCs until we're in non-NONE\n-\tprivate void updateTransactionQueueSuspended() {\n-\t\tif (defaultMainWindowCapability == null || HMILevel.HMI_NONE.equals(currentHMILevel)) {\n-\t\t\tDebugTool.logInfo(TAG, String.format(\"Suspending the transaction queue. Current HMI level is NONE: %b, window capabilities are null: %b\", HMILevel.HMI_NONE.equals(currentHMILevel), defaultMainWindowCapability == null));\n-\t\t\ttransactionQueue.pause();\n-\t\t} else {\n-\t\t\tDebugTool.logInfo(TAG, \"Starting the transaction queue\");\n-\t\t\ttransactionQueue.resume();\n-\t\t}\n-\t}\n \n-\t//TODO not in IOS\n+\t\tonDisplaysCapabilityListener = new OnSystemCapabilityListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n+\t\t\t\t// instead of using the parameter it's more safe to use the convenience method\n+\t\t\t\tList<DisplayCapability> capabilities = SystemCapabilityManager.convertToList(capability, DisplayCapability.class);\n+\t\t\t\tif (capabilities == null || capabilities.size() == 0) {\n+\t\t\t\t\tDebugTool.logError(TAG, \"TextAndGraphic Manager - Capabilities sent here are null or empty\");\n+\t\t\t\t}else {\n+\t\t\t\t\tDisplayCapability display = capabilities.get(0);\n+\t\t\t\t\tfor (WindowCapability windowCapability : display.getWindowCapabilities()) {\n+\t\t\t\t\t\tint currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+\t\t\t\t\t\tif (currentWindowID == PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+\t\t\t\t\t\t\tdefaultMainWindowCapability = windowCapability;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n \n+\t\t\t@Override\n+\t\t\tpublic void onError(String info) {\n+\t\t\t\tDebugTool.logError(TAG, \"Display Capability cannot be retrieved\");\n+\t\t\t\tdefaultMainWindowCapability = null;\n+\t\t\t}\n+\t\t};\n+\t\tthis.internalInterface.addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+\t}\n \n \t// Upload / Send\n \n \tprotected void update(CompletionListener listener) {\n \n+\t\t// check if is batch update\n+\t\tif (batchingUpdates) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (isDirty){\n+\t\t\tisDirty = false;\n+\t\t\tsdlUpdate(listener);\n+\t\t} else if (listener != null) {\n+\t\t\tlistener.onComplete(true);\n+\t\t}\n+\t}\n+\n+\tprivate synchronized void sdlUpdate(CompletionListener listener){\n+\n \t\t// make sure hmi is not none\n-\t\tif (currentHMILevel == null || currentHMILevel == HMILevel.HMI_NONE) {\n+\t\tif (currentHMILevel == null || currentHMILevel == HMILevel.HMI_NONE){\n \t\t\t//Trying to send show on HMI_NONE, waiting for full\n \t\t\tpendingHMIFull = true;\n-\t\t\tif (listener != null) {\n+\t\t\tif (listener != null){\n \t\t\t\tpendingHMIListener = listener;\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n-\t\t// check if is batch update\n-\t\tif (batchingUpdates) {\n+\t\t//Updating Text and Graphics\n+\t\tif (inProgressUpdate != null){\n+\n+\t\t\t//In progress update exists, queueing update\n+\t\t\tif (queuedUpdateListener != null){\n+\n+\t\t\t\t//Queued update already exists, superseding previous queued update\n+\t\t\t\tqueuedUpdateListener.onComplete(false);\n+\t\t\t\tqueuedUpdateListener = null;\n+\t\t\t}\n+\n+\t\t\tif (listener != null){\n+\t\t\t\tqueuedUpdateListener = listener;\n+\t\t\t}\n+\n+\t\t\thasQueuedUpdate = true;\n+\n \t\t\treturn;\n \t\t}\n \n-\t\tif (isDirty) {\n-\t\t\tisDirty = false;\n-\t\t\tsdlUpdate(listener);\n-\t\t} else if (listener != null) {\n-\t\t\tlistener.onComplete(true);\n+\t\tShow fullShow = new Show();\n+\t\tfullShow.setAlignment(textAlignment);\n+\t\tfullShow = assembleShowText(fullShow);\n+\t\tfullShow = assembleShowImages(fullShow);\n+\n+\t\tinProgressListener = listener;\n+\n+\t\tif (!shouldUpdatePrimaryImage() && !shouldUpdateSecondaryImage()){\n+\n+\t\t\t//No Images to send, only sending text\n+\t\t\tinProgressUpdate = extractTextFromShow(fullShow);\n+\t\t\tsendShow();\n+\n+\t\t}else if (!sdlArtworkNeedsUpload(primaryGraphic) && (secondaryGraphic == blankArtwork || !sdlArtworkNeedsUpload(secondaryGraphic))){\n+\n+\t\t\t//Images already uploaded, sending full update\n+\t\t\t// The files to be updated are already uploaded, send the full show immediately\n+\t\t\tinProgressUpdate = fullShow;\n+\t\t\tsendShow();\n+\t\t} else{\n+\n+\t\t\t// Images need to be uploaded, sending text and uploading images\n+\t\t\tinProgressUpdate = fullShow;\n+\t\t\tfinal Show thisUpdate = fullShow;\n+\n+\t\t\tuploadImages(new CompletionListener() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void onComplete(boolean success) {\n+\t\t\t\t\tif (!success){\n+\t\t\t\t\t\tDebugTool.logError(TAG, \"Error uploading image\");\n+\t\t\t\t\t\tinProgressUpdate = extractTextFromShow(inProgressUpdate);\n+\t\t\t\t\t\tsendShow();\n+\t\t\t\t\t}\n+\t\t\t\t\t// Check if queued image update still matches our images (there could have been a new Show in the meantime)\n+\t\t\t\t\t// and send a new update if it does. Since the images will already be on the head unit, the whole show will be sent\n+\t\t\t\t\tif (thisUpdate.getGraphic() != null && thisUpdate.getGraphic().equals(queuedImageUpdate.getGraphic()) ||\n+\t\t\t\t\t\t\t(thisUpdate.getSecondaryGraphic() != null && queuedImageUpdate.getSecondaryGraphic() != null) && thisUpdate.getSecondaryGraphic().equals(queuedImageUpdate.getSecondaryGraphic())){\n+\t\t\t\t\t\t// Queued image update matches the images we need, sending update\n+\t\t\t\t\t\tsendShow();\n+\t\t\t\t\t}\n+\t\t\t\t\t// Else, Queued image update does not match the images we need, skipping update\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tqueuedImageUpdate = fullShow;\n \t\t}\n \t}\n \n-\tprivate synchronized void sdlUpdate(final CompletionListener listener) {\n+\tprivate void sendShow(){\n+\t\tinProgressUpdate.setOnRPCResponseListener(new OnRPCResponseListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n+\t\t\t\thandleResponse(response.getSuccess());\n+\t\t\t}\n \n-\t\tif (transactionQueue.getTasksAsList().size() > 0) {\n-\t\t\t//Transactions already exist, cancelling them\n-\t\t\ttransactionQueue.clear();\n-\t\t}\n-\t\tupdateOperation = new TextAndGraphicUpdateOperation(internalInterface, fileManager.get(), defaultMainWindowCapability, currentScreenData, currentState(), new CompletionListener() {\n \t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n+\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n+\t\t\t\thandleResponse(false);\n+\t\t\t}\n+\n+\t\t\tprivate void handleResponse(boolean success){\n+\t\t\t\tif (success){\n+\t\t\t\t\tupdateCurrentScreenDataState(inProgressUpdate);\n+\t\t\t\t}\n \n-\t\t\t\tif (updateOperation.getSentShow() != null) {\n-\t\t\t\t\tcurrentScreenData = updateOperation.getSentShow();\n+\t\t\t\tinProgressUpdate = null;\n+\t\t\t\tif (inProgressListener != null){\n+\t\t\t\t\tinProgressListener.onComplete(success);\n+\t\t\t\t\tinProgressListener = null;\n \t\t\t\t}\n-\t\t\t\tif (listener != null) { //IOS diff here\n-\t\t\t\t\tlistener.onComplete(success);\n+\n+\t\t\t\tif (hasQueuedUpdate){\n+\t\t\t\t\t//Queued update exists, sending another update\n+\t\t\t\t\thasQueuedUpdate = false;\n+\t\t\t\t\tCompletionListener temp = queuedUpdateListener;\n+\t\t\t\t\tqueuedUpdateListener = null;\n+\t\t\t\t\tsdlUpdate(temp);\n \t\t\t\t}\n \t\t\t}\n \t\t});\n-\t\ttransactionQueue.add(updateOperation, false);\n+\n+\t\tif (this.softButtonManager.get() != null) {\n+\t\t\tthis.softButtonManager.get().setCurrentMainField1(inProgressUpdate.getMainField1());\n+\t\t}\n+\t\tinternalInterface.sendRPC(inProgressUpdate);\n+\t}\n+\n+\t// Images\n+\n+\tprivate void uploadImages(final CompletionListener listener) {\n+\n+\t\tList<SdlArtwork> artworksToUpload = new ArrayList<>();\n+\n+\t\t// add primary image\n+\t\tif (shouldUpdatePrimaryImage() && !primaryGraphic.isStaticIcon()){\n+\t\t\tartworksToUpload.add(primaryGraphic);\n+\t\t}\n+\n+\t\t// add secondary image\n+\t\tif (shouldUpdateSecondaryImage() && !secondaryGraphic.isStaticIcon()){\n+\t\t\tartworksToUpload.add(secondaryGraphic);\n+\t\t}\n+\n+\t\tif (artworksToUpload.size() == 0 && (primaryGraphic.isStaticIcon() || secondaryGraphic.isStaticIcon())){\n+\t\t\tDebugTool.logInfo(TAG, \"Upload attempted on static icons, sending them without upload instead\");\n+\t\t\tlistener.onComplete(true);\n+\t\t}\n+\n+\t\t// use file manager to upload art\n+\t\tif (fileManager.get() != null) {\n+\t\t\tfileManager.get().uploadArtworks(artworksToUpload, new MultipleFileCompletionListener() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void onComplete(Map<String, String> errors) {\n+\t\t\t\t\tif (errors != null) {\n+\t\t\t\t\t\tDebugTool.logError(TAG, \"Error Uploading Artworks. Error: \" + errors.toString());\n+\t\t\t\t\t\tlistener.onComplete(false);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tlistener.onComplete(true);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n \t}\n \n-\t// Convert to State\n-\tprivate TextsAndGraphicsState currentState() {\n-\t\treturn new TextsAndGraphicsState(textField1, textField2, textField3, textField4, mediaTrackTextField,\n-\t\t\t\ttitle, primaryGraphic, secondaryGraphic, blankArtwork, textAlignment, textField1Type, textField2Type, textField3Type, textField4Type);\n+\tprivate Show assembleShowImages(Show show){\n+\n+\t\tif (shouldUpdatePrimaryImage()){\n+\t\t\tshow.setGraphic(primaryGraphic.getImageRPC());\n+\t\t}\n+\n+\t\tif (shouldUpdateSecondaryImage()){\n+\t\t\tshow.setSecondaryGraphic(secondaryGraphic.getImageRPC());\n+\t\t}\n+\n+\t\treturn show;\n+\t}\n+\n+\t// Text\n+\n+\tShow assembleShowText(Show show){\n+\n+\t\tshow = setBlankTextFields(show);\n+\n+\t\tif (mediaTrackTextField != null && shouldUpdateMediaTrackField()) {\n+\t\t\tshow.setMediaTrack(mediaTrackTextField);\n+\t\t}\n+\n+\t\tif (title != null && shouldUpdateTitleField()) {\n+\t\t\tshow.setTemplateTitle(title);\n+\t\t}\n+\n+\t\tList<String> nonNullFields = findValidMainTextFields();\n+\t\tif (nonNullFields.isEmpty()){\n+\t\t\treturn show;\n+\t\t}\n+\n+\t\tint numberOfLines = defaultMainWindowCapability != null ? ManagerUtility.WindowCapabilityUtility.getMaxNumberOfMainFieldLines(defaultMainWindowCapability) : 4;\n+\n+\t\tswitch (numberOfLines) {\n+\t\t\tcase 1: show = assembleOneLineShowText(show, nonNullFields);\n+\t\t\t\tbreak;\n+\t\t\tcase 2: show = assembleTwoLineShowText(show);\n+\t\t\t\tbreak;\n+\t\t\tcase 3: show = assembleThreeLineShowText(show);\n+\t\t\t\tbreak;\n+\t\t\tcase 4: show = assembleFourLineShowText(show);\n+\t\t\t\tbreak;\n+\t\t}\n+\n+\t\treturn show;\n+\t}\n+\n+\tprivate Show assembleOneLineShowText(Show show, List<String> showFields){\n+\n+\t\tStringBuilder showString1 = new StringBuilder();\n+\t\tfor (int i = 0; i < showFields.size(); i++) {\n+\t\t\tif (i > 0) {\n+\t\t\t\tshowString1.append(\" - \").append(showFields.get(i));\n+\t\t\t}else{\n+\t\t\t\tshowString1.append(showFields.get(i));\n+\t\t\t}\n+\t\t}\n+\t\tshow.setMainField1(showString1.toString());\n+\n+\t\tMetadataTags tags = new MetadataTags();\n+\t\ttags.setMainField1(findNonNullMetadataFields());\n+\n+\t\tshow.setMetadataTags(tags);\n+\n+\t\treturn show;\n+\t}\n+\n+\tprivate Show assembleTwoLineShowText(Show show){\n+\n+\t\tStringBuilder tempString = new StringBuilder();\n+\t\tMetadataTags tags = new MetadataTags();\n+\n+\t\tif (textField1 != null && textField1.length() > 0) {\n+\t\t\ttempString.append(textField1);\n+\t\t\tif (textField1Type != null){\n+\t\t\t\ttags.setMainField1(textField1Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (textField2 != null && textField2.length() > 0) {\n+\t\t\tif (( textField3 == null || !(textField3.length() > 0)) && (textField4 == null || !(textField4.length() > 0))){\n+\t\t\t\t// text does not exist in slots 3 or 4, put text2 in slot 2\n+\t\t\t\tshow.setMainField2(textField2);\n+\t\t\t\tif (textField2Type != null){\n+\t\t\t\t\ttags.setMainField2(textField2Type);\n+\t\t\t\t}\n+\t\t\t} else if (textField1 != null && textField1.length() > 0) {\n+\t\t\t\t// If text 1 exists, put it in slot 1 formatted\n+\t\t\t\ttempString.append(\" - \").append(textField2);\n+\t\t\t\tif (textField2Type != null){\n+\t\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n+\t\t\t\t\ttypeList.add(textField2Type);\n+\t\t\t\t\tif (textField1Type != null){\n+\t\t\t\t\t\ttypeList.add(textField1Type);\n+\t\t\t\t\t}\n+\t\t\t\t\ttags.setMainField1(typeList);\n+\t\t\t\t}\n+\t\t\t}else {\n+\t\t\t\t// If text 1 does not exist, put it in slot 1 unformatted\n+\t\t\t\ttempString.append(textField2);\n+\t\t\t\tif (textField2Type != null){\n+\t\t\t\t\ttags.setMainField1(textField2Type);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// set mainfield 1\n+\t\tshow.setMainField1(tempString.toString());\n+\n+\t\t// new stringbuilder object\n+\t\ttempString = new StringBuilder();\n+\n+\t\tif (textField3 != null && textField3.length() > 0){\n+\t\t\t// If text 3 exists, put it in slot 2\n+\t\t\ttempString.append(textField3);\n+\t\t\tif (textField3Type != null){\n+\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n+\t\t\t\ttypeList.add(textField3Type);\n+\t\t\t\ttags.setMainField2(typeList);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (textField4 != null && textField4.length() > 0){\n+\t\t\tif (textField3 != null && textField3.length() > 0){\n+\t\t\t\t// If text 3 exists, put it in slot 2 formatted\n+\t\t\t\ttempString.append(\" - \").append(textField4);\n+\t\t\t\tif (textField4Type != null){\n+\t\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n+\t\t\t\t\ttypeList.add(textField4Type);\n+\t\t\t\t\tif (textField3Type != null){\n+\t\t\t\t\t\ttypeList.add(textField3Type);\n+\t\t\t\t\t}\n+\t\t\t\t\ttags.setMainField2(typeList);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// If text 3 does not exist, put it in slot 3 unformatted\n+\t\t\t\ttempString.append(textField4);\n+\t\t\t\tif (textField4Type != null){\n+\t\t\t\t\ttags.setMainField2(textField4Type);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (tempString.toString().length() > 0){\n+\t\t\tshow.setMainField2(tempString.toString());\n+\t\t}\n+\n+\t\tshow.setMetadataTags(tags);\n+\t\treturn show;\n+\t}\n+\n+\tprivate Show assembleThreeLineShowText(Show show){\n+\n+\t\tMetadataTags tags = new MetadataTags();\n+\n+\t\tif (textField1 != null && textField1.length() > 0) {\n+\t\t\tshow.setMainField1(textField1);\n+\t\t\tif (textField1Type != null){\n+\t\t\t\ttags.setMainField1(textField1Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (textField2 != null && textField2.length() > 0) {\n+\t\t\tshow.setMainField2(textField2);\n+\t\t\tif (textField2Type != null){\n+\t\t\t\ttags.setMainField2(textField2Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tStringBuilder tempString = new StringBuilder();\n+\n+\t\tif (textField3 != null && textField3.length() > 0){\n+\t\t\ttempString.append(textField3);\n+\t\t\tif (textField3Type != null){\n+\t\t\t\ttags.setMainField3(textField3Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (textField4 != null && textField4.length() > 0) {\n+\t\t\tif (textField3 != null && textField3.length() > 0) {\n+\t\t\t\t// If text 3 exists, put it in slot 3 formatted\n+\t\t\t\ttempString.append(\" - \").append(textField4);\n+\t\t\t\tif (textField4Type != null){\n+\t\t\t\t\tList<MetadataType> tags4 = new ArrayList<>();\n+\t\t\t\t\tif (textField3Type != null){\n+\t\t\t\t\t\ttags4.add(textField3Type);\n+\t\t\t\t\t}\n+\t\t\t\t\ttags4.add(textField4Type);\n+\t\t\t\t\ttags.setMainField3(tags4);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// If text 3 does not exist, put it in slot 3 formatted\n+\t\t\t\ttempString.append(textField4);\n+\t\t\t\tif (textField4Type != null){\n+\t\t\t\t\ttags.setMainField3(textField4Type);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tshow.setMainField3(tempString.toString());\n+\t\tshow.setMetadataTags(tags);\n+\t\treturn show;\n+\t}\n+\n+\tprivate Show assembleFourLineShowText(Show show){\n+\n+\t\tMetadataTags tags = new MetadataTags();\n+\n+\t\tif (textField1 != null && textField1.length() > 0) {\n+\t\t\tshow.setMainField1(textField1);\n+\t\t\tif (textField1Type != null){\n+\t\t\t\ttags.setMainField1(textField1Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (textField2 != null && textField2.length() > 0) {\n+\t\t\tshow.setMainField2(textField2);\n+\t\t\tif (textField2Type != null){\n+\t\t\t\ttags.setMainField2(textField2Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (textField3 != null && textField3.length() > 0) {\n+\t\t\tshow.setMainField3(textField3);\n+\t\t\tif (textField3Type != null){\n+\t\t\t\ttags.setMainField3(textField3Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (textField4 != null && textField4.length() > 0) {\n+\t\t\tshow.setMainField4(textField4);\n+\t\t\tif (textField4Type != null){\n+\t\t\t\ttags.setMainField4(textField4Type);\n+\t\t\t}\n+\t\t}\n+\n+\t\tshow.setMetadataTags(tags);\n+\t\treturn show;\n \t}\n \n \t// Extraction\n \n-\t//IOS has sdl_extractImageFromShow\n+\tShow extractTextFromShow(Show show){\n+\n+\t\tShow newShow = new Show();\n+\t\tnewShow.setMainField1(show.getMainField1());\n+\t\tnewShow.setMainField2(show.getMainField2());\n+\t\tnewShow.setMainField3(show.getMainField3());\n+\t\tnewShow.setMainField4(show.getMainField4());\n+\t\tnewShow.setTemplateTitle(show.getTemplateTitle());\n \n-\t//IOS has sdl_createImageOnlyShowWithPrimaryArtwork\n+\t\treturn newShow;\n+\t}\n+\n+\tprivate Show setBlankTextFields(Show newShow){\n+\n+\t\tnewShow.setMainField1(\"\");\n+\t\tnewShow.setMainField2(\"\");\n+\t\tnewShow.setMainField3(\"\");\n+\t\tnewShow.setMainField4(\"\");\n+\t\tnewShow.setMediaTrack(\"\");\n+\t\tnewShow.setTemplateTitle(\"\");\n+\n+\t\treturn newShow;\n+\t}\n \n-\tprivate void updateCurrentScreenDataState(Show show) {\n+\tprivate void updateCurrentScreenDataState(Show show){\n \n-\t\tif (show == null) {\n+\t\tif (show == null){\n \t\t\tDebugTool.logError(TAG, \"can not updateCurrentScreenDataFromShow from null show\");\n \t\t\treturn;\n \t\t}\n \n \t\t// If the items are null, they were not updated, so we can't just set it directly\n-\t\tif (show.getMainField1() != null) {\n+\t\tif (show.getMainField1() != null){\n \t\t\tcurrentScreenData.setMainField1(show.getMainField1());\n \t\t}\n-\t\tif (show.getMainField2() != null) {\n+\t\tif (show.getMainField2() != null){\n \t\t\tcurrentScreenData.setMainField2(show.getMainField2());\n \t\t}\n-\t\tif (show.getMainField3() != null) {\n+\t\tif (show.getMainField3() != null){\n \t\t\tcurrentScreenData.setMainField3(show.getMainField3());\n \t\t}\n-\t\tif (show.getMainField4() != null) {\n+\t\tif (show.getMainField4() != null){\n \t\t\tcurrentScreenData.setMainField4(show.getMainField4());\n \t\t}\n-\t\tif (show.getTemplateTitle() != null) {\n+\t\tif (show.getTemplateTitle() != null){\n \t\t\tcurrentScreenData.setTemplateTitle(show.getTemplateTitle());\n \t\t}\n-\t\tif (show.getMediaTrack() != null) {\n+\t\tif (show.getMediaTrack() != null){\n \t\t\tcurrentScreenData.setMediaTrack(show.getMediaTrack());\n \t\t}\n-\t\tif (show.getMetadataTags() != null) {\n+\t\tif (show.getMetadataTags() != null){\n \t\t\tcurrentScreenData.setMetadataTags(show.getMetadataTags());\n \t\t}\n-\t\tif (show.getAlignment() != null) {\n+\t\tif (show.getAlignment() != null){\n \t\t\tcurrentScreenData.setAlignment(show.getAlignment());\n \t\t}\n-\t\tif (show.getGraphic() != null) {\n+\t\tif (show.getGraphic() != null){\n \t\t\tcurrentScreenData.setGraphic(show.getGraphic());\n \t\t}\n-\t\tif (show.getSecondaryGraphic() != null) {\n+\t\tif (show.getSecondaryGraphic() != null){\n \t\t\tcurrentScreenData.setSecondaryGraphic(show.getSecondaryGraphic());\n \t\t}\n \t}\n \n \t// Helpers\n \n-\t// IOS has sdl_hasData\n+\tprivate List<String> findValidMainTextFields(){\n+\t\tList<String> array = new ArrayList<>();\n+\n+\t\tif (textField1 != null && textField1.length() > 0) {\n+\t\t\tarray.add(textField1);\n+\t\t}\n+\n+\t\tif (textField2 != null && textField2.length() > 0) {\n+\t\t\tarray.add(textField2);\n+\t\t}\n+\n+\t\tif (textField3 != null && textField3.length() > 0) {\n+\t\t\tarray.add(textField3);\n+\t\t}\n \n-\t//Equality IOS has this section with:\n-\t// sdl_showImages\n+\t\tif (textField4 != null && textField4.length() > 0) {\n+\t\t\tarray.add(textField4);\n+\t\t}\n+\n+\t\treturn array;\n+\t}\n+\n+\n+\tprivate List<MetadataType> findNonNullMetadataFields(){\n+\t\tList<MetadataType> array = new ArrayList<>();\n+\n+\t\tif (textField1Type != null) {\n+\t\t\tarray.add(textField1Type);\n+\t\t}\n+\n+\t\tif (textField2Type != null) {\n+\t\t\tarray.add(textField2Type);\n+\t\t}\n+\n+\t\tif (textField3Type != null) {\n+\t\t\tarray.add(textField3Type);\n+\t\t}\n+\n+\t\tif (textField4Type != null) {\n+\t\t\tarray.add(textField4Type);\n+\t\t}\n+\n+\t\treturn array;\n+\t}\n \n \tabstract SdlArtwork getBlankArtwork();\n \n-\t// Getters / Setters\n+\t@SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n+\tprivate boolean sdlArtworkNeedsUpload(SdlArtwork artwork){\n+\t\tif (fileManager.get() != null) {\n+\t\t\treturn artwork != null && !fileManager.get().hasUploadedFile(artwork) && !artwork.isStaticIcon();\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Check to see if primaryGraphic should be updated\n+\t * @return true if primaryGraphic should be updated, false if not\n+\t */\n+\tprivate boolean shouldUpdatePrimaryImage() {\n+\t\tboolean templateSupportsPrimaryArtwork = templateSupportsImageField(ImageFieldName.graphic);\n+\n+\t\tString currentScreenDataPrimaryGraphicName = (currentScreenData != null && currentScreenData.getGraphic() != null) ? currentScreenData.getGraphic().getValue() : null;\n+\t\tString primaryGraphicName = primaryGraphic != null ? primaryGraphic.getName() : null;\n+\t\treturn templateSupportsPrimaryArtwork\n+\t\t\t\t&& !CompareUtils.areStringsEqual(currentScreenDataPrimaryGraphicName, primaryGraphicName, true, true)\n+\t\t\t\t&& primaryGraphic != null;\n+\t}\n+\n+\t/**\n+\t * Check to see if secondaryGraphic should be updated\n+\t * @return true if secondaryGraphic should be updated, false if not\n+\t */\n+\tprivate boolean shouldUpdateSecondaryImage() {\n+\t\tboolean templateSupportsSecondaryArtwork = (templateSupportsImageField(ImageFieldName.graphic) || templateSupportsImageField(ImageFieldName.secondaryGraphic));\n+\n+\t\tString currentScreenDataSecondaryGraphicName = (currentScreenData != null && currentScreenData.getSecondaryGraphic() != null) ? currentScreenData.getSecondaryGraphic().getValue() : null;\n+\t\tString secondaryGraphicName = secondaryGraphic != null ? secondaryGraphic.getName() : null;\n+\t\treturn templateSupportsSecondaryArtwork\n+\t\t\t\t&& !CompareUtils.areStringsEqual(currentScreenDataSecondaryGraphicName, secondaryGraphicName, true, true)\n+\t\t\t\t&& secondaryGraphic != null;\n+\t}\n+\n+\t/**\n+\t * Check to see if template supports the specified image field\n+\t * @return true if image field is supported, false if not\n+\t */\n+\tprivate boolean templateSupportsImageField(ImageFieldName name) {\n+\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, name);\n+\t}\n+\n+\t/**\n+\t * Check to see if mediaTrackTextField should be updated\n+\t * @return true if mediaTrackTextField should be updated, false if not\n+\t */\n+\tprivate boolean shouldUpdateMediaTrackField() {\n+\t\treturn templateSupportsTextField(TextFieldName.mediaTrack);\n+\t}\n \n-\tvoid setTextAlignment(TextAlignment textAlignment) {\n+\t/**\n+\t * Check to see if title should be updated\n+\t * @return true if title should be updated, false if not\n+\t */\n+\tprivate boolean shouldUpdateTitleField() {\n+\t\treturn templateSupportsTextField(TextFieldName.templateTitle);\n+\t}\n+\n+\t/**\n+\t * Check to see if field should be updated\n+\t * @return true if field should be updated, false if not\n+\t */\n+\tprivate boolean templateSupportsTextField(TextFieldName name) {\n+\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasTextFieldOfName(defaultMainWindowCapability, name);\n+\t}\n+\n+\t// SCREEN ITEM SETTERS AND GETTERS\n+\n+\tvoid setTextAlignment(TextAlignment textAlignment){\n \t\tthis.textAlignment = textAlignment;\n \t\t// If we aren't batching, send the update immediately, if we are, set ourselves as dirty (so we know we should send an update after the batch ends)\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tTextAlignment getTextAlignment() {\n+\tTextAlignment getTextAlignment(){\n \t\treturn textAlignment;\n \t}\n \n-\tvoid setMediaTrackTextField(String mediaTrackTextField) {\n+\tvoid setMediaTrackTextField(String mediaTrackTextField){\n \t\tthis.mediaTrackTextField = mediaTrackTextField;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getMediaTrackTextField() {\n+\tString getMediaTrackTextField(){\n \t\treturn mediaTrackTextField;\n \t}\n \n-\tvoid setTextField1(String textField1) {\n+\tvoid setTextField1(String textField1){\n \t\tthis.textField1 = textField1;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField1() {\n+\tString getTextField1(){\n \t\treturn textField1;\n \t}\n \n-\tvoid setTextField2(String textField2) {\n+\tvoid setTextField2(String textField2){\n \t\tthis.textField2 = textField2;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField2() {\n+\tString getTextField2(){\n \t\treturn textField2;\n \t}\n \n-\tvoid setTextField3(String textField3) {\n+\tvoid setTextField3(String textField3){\n \t\tthis.textField3 = textField3;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField3() {\n+\tString getTextField3(){\n \t\treturn textField3;\n \t}\n \n-\tvoid setTextField4(String textField4) {\n+\tvoid setTextField4(String textField4){\n \t\tthis.textField4 = textField4;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField4() {\n+\tString getTextField4(){\n \t\treturn textField4;\n \t}\n \n-\tvoid setTextField1Type(MetadataType textField1Type) {\n+\tvoid setTextField1Type(MetadataType textField1Type){\n \t\tthis.textField1Type = textField1Type;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField1Type() {\n+\tMetadataType getTextField1Type(){\n \t\treturn textField1Type;\n \t}\n \n-\tvoid setTextField2Type(MetadataType textField2Type) {\n+\tvoid setTextField2Type(MetadataType textField2Type){\n \t\tthis.textField2Type = textField2Type;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField2Type() {\n+\tMetadataType getTextField2Type(){\n \t\treturn textField2Type;\n \t}\n \n-\tvoid setTextField3Type(MetadataType textField3Type) {\n+\tvoid setTextField3Type(MetadataType textField3Type){\n \t\tthis.textField3Type = textField3Type;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField3Type() {\n+\tMetadataType getTextField3Type(){\n \t\treturn textField3Type;\n \t}\n \n-\tvoid setTextField4Type(MetadataType textField4Type) {\n+\tvoid setTextField4Type(MetadataType textField4Type){\n \t\tthis.textField4Type = textField4Type;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField4Type() {\n+\tMetadataType getTextField4Type(){\n \t\treturn textField4Type;\n \t}\n \n-\tvoid setTitle(String title) {\n+\tvoid setTitle(String title){\n \t\tthis.title = title;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTitle() {\n+\tString getTitle(){\n \t\treturn title;\n \t}\n \n-\tvoid setPrimaryGraphic(SdlArtwork primaryGraphic) {\n+\tvoid setPrimaryGraphic(SdlArtwork primaryGraphic){\n \t\tthis.primaryGraphic = primaryGraphic;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tSdlArtwork getPrimaryGraphic() {\n+\tSdlArtwork getPrimaryGraphic(){\n \t\treturn primaryGraphic;\n \t}\n \n-\tvoid setSecondaryGraphic(SdlArtwork secondaryGraphic) {\n+\tvoid setSecondaryGraphic(SdlArtwork secondaryGraphic){\n \t\tthis.secondaryGraphic = secondaryGraphic;\n-\t\tif (!batchingUpdates) {\n+\t\tif (!batchingUpdates){\n \t\t\tsdlUpdate(null);\n-\t\t} else {\n+\t\t}else{\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tSdlArtwork getSecondaryGraphic() {\n+\tSdlArtwork getSecondaryGraphic(){\n \t\treturn secondaryGraphic;\n \t}\n \n-\tvoid setBatchUpdates(boolean batching) {\n+\tvoid setBatchUpdates(boolean batching){\n \t\tthis.batchingUpdates = batching;\n \t}\n \n-\tprivate void addListeners() {\n-\t\t// add listener\n-\t\thmiListener = new OnRPCNotificationListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n-\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\tcurrentHMILevel = onHMIStatus.getHmiLevel();\n-\t\t\t\tupdateTransactionQueueSuspended();\n-\t\t\t\tif (currentHMILevel == HMILevel.HMI_FULL) {\n-\t\t\t\t\tif (pendingHMIFull) {\n-\t\t\t\t\t\tDebugTool.logInfo(TAG, \"Acquired HMI_FULL with pending update. Sending now\");\n-\t\t\t\t\t\tpendingHMIFull = false;\n-\t\t\t\t\t\tsdlUpdate(pendingHMIListener);\n-\t\t\t\t\t\tpendingHMIListener = null;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t};\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\n-\n-\t\tonDisplaysCapabilityListener = new OnSystemCapabilityListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t// instead of using the parameter it's more safe to use the convenience method\n-\t\t\t\tList<DisplayCapability> capabilities = SystemCapabilityManager.convertToList(capability, DisplayCapability.class);\n-\t\t\t\tif (capabilities == null || capabilities.size() == 0) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"TextAndGraphic Manager - Capabilities sent here are null or empty\");\n-\t\t\t\t} else {\n-\t\t\t\t\tDisplayCapability display = capabilities.get(0);\n-\t\t\t\t\tfor (WindowCapability windowCapability : display.getWindowCapabilities()) {\n-\t\t\t\t\t\tint currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\t\t\t\tif (currentWindowID == PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\t\t\tdefaultMainWindowCapability = windowCapability;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(String info) {\n-\t\t\t\tDebugTool.logError(TAG, \"Display Capability cannot be retrieved\");\n-\t\t\t\tdefaultMainWindowCapability = null;\n-\t\t\t}\n-\t\t};\n-\t\tthis.internalInterface.addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n-\t}\n }\n", "next_change": {"commit": "be7157d524736b19fb9277c5cad3dc0e9bec3935", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex a07e60f20..b8190edaa 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -222,759 +175,314 @@ abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \t\t}\n \t}\n \n-\tprivate synchronized void sdlUpdate(CompletionListener listener){\n-\n-\t\t// make sure hmi is not none\n-\t\tif (currentHMILevel == null || currentHMILevel == HMILevel.HMI_NONE){\n-\t\t\t//Trying to send show on HMI_NONE, waiting for full\n-\t\t\tpendingHMIFull = true;\n-\t\t\tif (listener != null){\n-\t\t\t\tpendingHMIListener = listener;\n+\tprivate synchronized void sdlUpdate(final CompletionListener listener) {\n+\t\tif (transactionQueue.getTasksAsList().size() > 0) {\n+\t\t\t//Transactions already exist, cancelling them\n+\t\t\ttransactionQueue.clear();\n+\t\t\tif (listener != null) {\n+\t\t\t\tlistener.onComplete(false);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n-\n-\t\t//Updating Text and Graphics\n-\t\tif (inProgressUpdate != null){\n-\n-\t\t\t//In progress update exists, queueing update\n-\t\t\tif (queuedUpdateListener != null){\n-\n-\t\t\t\t//Queued update already exists, superseding previous queued update\n-\t\t\t\tqueuedUpdateListener.onComplete(false);\n-\t\t\t\tqueuedUpdateListener = null;\n-\t\t\t}\n-\n-\t\t\tif (listener != null){\n-\t\t\t\tqueuedUpdateListener = listener;\n-\t\t\t}\n-\n-\t\t\thasQueuedUpdate = true;\n-\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tShow fullShow = new Show();\n-\t\tfullShow.setAlignment(textAlignment);\n-\t\tfullShow = assembleShowText(fullShow);\n-\t\tfullShow = assembleShowImages(fullShow);\n-\n-\t\tinProgressListener = listener;\n-\n-\t\tif (!shouldUpdatePrimaryImage() && !shouldUpdateSecondaryImage()){\n-\n-\t\t\t//No Images to send, only sending text\n-\t\t\tinProgressUpdate = extractTextFromShow(fullShow);\n-\t\t\tsendShow();\n-\n-\t\t}else if (!sdlArtworkNeedsUpload(primaryGraphic) && (secondaryGraphic == blankArtwork || !sdlArtworkNeedsUpload(secondaryGraphic))){\n-\n-\t\t\t//Images already uploaded, sending full update\n-\t\t\t// The files to be updated are already uploaded, send the full show immediately\n-\t\t\tinProgressUpdate = fullShow;\n-\t\t\tsendShow();\n-\t\t} else{\n-\n-\t\t\t// Images need to be uploaded, sending text and uploading images\n-\t\t\tinProgressUpdate = fullShow;\n-\t\t\tfinal Show thisUpdate = fullShow;\n-\n-\t\t\tuploadImages(new CompletionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\tif (!success){\n-\t\t\t\t\t\tDebugTool.logError(TAG, \"Error uploading image\");\n-\t\t\t\t\t\tinProgressUpdate = extractTextFromShow(inProgressUpdate);\n-\t\t\t\t\t\tsendShow();\n-\t\t\t\t\t}\n-\t\t\t\t\t// Check if queued image update still matches our images (there could have been a new Show in the meantime)\n-\t\t\t\t\t// and send a new update if it does. Since the images will already be on the head unit, the whole show will be sent\n-\t\t\t\t\tif (thisUpdate.getGraphic() != null && thisUpdate.getGraphic().equals(queuedImageUpdate.getGraphic()) ||\n-\t\t\t\t\t\t\t(thisUpdate.getSecondaryGraphic() != null && queuedImageUpdate.getSecondaryGraphic() != null) && thisUpdate.getSecondaryGraphic().equals(queuedImageUpdate.getSecondaryGraphic())){\n-\t\t\t\t\t\t// Queued image update matches the images we need, sending update\n-\t\t\t\t\t\tsendShow();\n-\t\t\t\t\t}\n-\t\t\t\t\t// Else, Queued image update does not match the images we need, skipping update\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tqueuedImageUpdate = fullShow;\n-\t\t}\n-\t}\n-\n-\tprivate void sendShow(){\n-\t\tinProgressUpdate.setOnRPCResponseListener(new OnRPCResponseListener() {\n+\t\tCurrentScreenDataUpdatedListener currentScreenDataUpdateListener = new CurrentScreenDataUpdatedListener() {\n \t\t\t@Override\n-\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\thandleResponse(response.getSuccess());\n+\t\t\tpublic void onUpdate(Show show) {\n+\t\t\t\tupdatePendingOperationsWithNewScreenData(show);\n \t\t\t}\n-\n+\t\t};\n+\t\tCompletionListener updateOperationListener = new CompletionListener() {\n \t\t\t@Override\n-\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\thandleResponse(false);\n-\t\t\t}\n-\n-\t\t\tprivate void handleResponse(boolean success){\n-\t\t\t\tif (success){\n-\t\t\t\t\tupdateCurrentScreenDataState(inProgressUpdate);\n-\t\t\t\t}\n-\n-\t\t\t\tinProgressUpdate = null;\n-\t\t\t\tif (inProgressListener != null){\n-\t\t\t\t\tinProgressListener.onComplete(success);\n-\t\t\t\t\tinProgressListener = null;\n-\t\t\t\t}\n-\n-\t\t\t\tif (hasQueuedUpdate){\n-\t\t\t\t\t//Queued update exists, sending another update\n-\t\t\t\t\thasQueuedUpdate = false;\n-\t\t\t\t\tCompletionListener temp = queuedUpdateListener;\n-\t\t\t\t\tqueuedUpdateListener = null;\n-\t\t\t\t\tsdlUpdate(temp);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tif (this.softButtonManager.get() != null) {\n-\t\t\tthis.softButtonManager.get().setCurrentMainField1(inProgressUpdate.getMainField1());\n-\t\t}\n-\t\tinternalInterface.sendRPC(inProgressUpdate);\n-\t}\n-\n-\t// Images\n-\n-\tprivate void uploadImages(final CompletionListener listener) {\n-\n-\t\tList<SdlArtwork> artworksToUpload = new ArrayList<>();\n-\n-\t\t// add primary image\n-\t\tif (shouldUpdatePrimaryImage() && !primaryGraphic.isStaticIcon()){\n-\t\t\tartworksToUpload.add(primaryGraphic);\n-\t\t}\n-\n-\t\t// add secondary image\n-\t\tif (shouldUpdateSecondaryImage() && !secondaryGraphic.isStaticIcon()){\n-\t\t\tartworksToUpload.add(secondaryGraphic);\n-\t\t}\n-\n-\t\tif (artworksToUpload.size() == 0 && (primaryGraphic.isStaticIcon() || secondaryGraphic.isStaticIcon())){\n-\t\t\tDebugTool.logInfo(TAG, \"Upload attempted on static icons, sending them without upload instead\");\n-\t\t\tlistener.onComplete(true);\n-\t\t}\n-\n-\t\t// use file manager to upload art\n-\t\tif (fileManager.get() != null) {\n-\t\t\tfileManager.get().uploadArtworks(artworksToUpload, new MultipleFileCompletionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onComplete(Map<String, String> errors) {\n-\t\t\t\t\tif (errors != null) {\n-\t\t\t\t\t\tDebugTool.logError(TAG, \"Error Uploading Artworks. Error: \" + errors.toString());\n-\t\t\t\t\t\tlistener.onComplete(false);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tlistener.onComplete(true);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate Show assembleShowImages(Show show){\n-\n-\t\tif (shouldUpdatePrimaryImage()){\n-\t\t\tshow.setGraphic(primaryGraphic.getImageRPC());\n-\t\t}\n-\n-\t\tif (shouldUpdateSecondaryImage()){\n-\t\t\tshow.setSecondaryGraphic(secondaryGraphic.getImageRPC());\n-\t\t}\n-\n-\t\treturn show;\n-\t}\n-\n-\t// Text\n-\n-\tShow assembleShowText(Show show){\n-\n-\t\tshow = setBlankTextFields(show);\n-\n-\t\tif (mediaTrackTextField != null && shouldUpdateMediaTrackField()) {\n-\t\t\tshow.setMediaTrack(mediaTrackTextField);\n-\t\t}\n-\n-\t\tif (title != null && shouldUpdateTitleField()) {\n-\t\t\tshow.setTemplateTitle(title);\n-\t\t}\n-\n-\t\tList<String> nonNullFields = findValidMainTextFields();\n-\t\tif (nonNullFields.isEmpty()){\n-\t\t\treturn show;\n-\t\t}\n-\n-\t\tint numberOfLines = defaultMainWindowCapability != null ? ManagerUtility.WindowCapabilityUtility.getMaxNumberOfMainFieldLines(defaultMainWindowCapability) : 4;\n-\n-\t\tswitch (numberOfLines) {\n-\t\t\tcase 1: show = assembleOneLineShowText(show, nonNullFields);\n-\t\t\t\tbreak;\n-\t\t\tcase 2: show = assembleTwoLineShowText(show);\n-\t\t\t\tbreak;\n-\t\t\tcase 3: show = assembleThreeLineShowText(show);\n-\t\t\t\tbreak;\n-\t\t\tcase 4: show = assembleFourLineShowText(show);\n-\t\t\t\tbreak;\n-\t\t}\n-\n-\t\treturn show;\n-\t}\n-\n-\tprivate Show assembleOneLineShowText(Show show, List<String> showFields){\n-\n-\t\tStringBuilder showString1 = new StringBuilder();\n-\t\tfor (int i = 0; i < showFields.size(); i++) {\n-\t\t\tif (i > 0) {\n-\t\t\t\tshowString1.append(\" - \").append(showFields.get(i));\n-\t\t\t}else{\n-\t\t\t\tshowString1.append(showFields.get(i));\n-\t\t\t}\n-\t\t}\n-\t\tshow.setMainField1(showString1.toString());\n-\n-\t\tMetadataTags tags = new MetadataTags();\n-\t\ttags.setMainField1(findNonNullMetadataFields());\n-\n-\t\tshow.setMetadataTags(tags);\n-\n-\t\treturn show;\n-\t}\n-\n-\tprivate Show assembleTwoLineShowText(Show show){\n-\n-\t\tStringBuilder tempString = new StringBuilder();\n-\t\tMetadataTags tags = new MetadataTags();\n-\n-\t\tif (textField1 != null && textField1.length() > 0) {\n-\t\t\ttempString.append(textField1);\n-\t\t\tif (textField1Type != null){\n-\t\t\t\ttags.setMainField1(textField1Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField2 != null && textField2.length() > 0) {\n-\t\t\tif (( textField3 == null || !(textField3.length() > 0)) && (textField4 == null || !(textField4.length() > 0))){\n-\t\t\t\t// text does not exist in slots 3 or 4, put text2 in slot 2\n-\t\t\t\tshow.setMainField2(textField2);\n-\t\t\t\tif (textField2Type != null){\n-\t\t\t\t\ttags.setMainField2(textField2Type);\n-\t\t\t\t}\n-\t\t\t} else if (textField1 != null && textField1.length() > 0) {\n-\t\t\t\t// If text 1 exists, put it in slot 1 formatted\n-\t\t\t\ttempString.append(\" - \").append(textField2);\n-\t\t\t\tif (textField2Type != null){\n-\t\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n-\t\t\t\t\ttypeList.add(textField2Type);\n-\t\t\t\t\tif (textField1Type != null){\n-\t\t\t\t\t\ttypeList.add(textField1Type);\n-\t\t\t\t\t}\n-\t\t\t\t\ttags.setMainField1(typeList);\n+\t\t\tpublic void onComplete(boolean success) {\n+\t\t\t\tif (listener != null) {\n+\t\t\t\t\tlistener.onComplete(success);\n \t\t\t\t}\n-\t\t\t}else {\n-\t\t\t\t// If text 1 does not exist, put it in slot 1 unformatted\n-\t\t\t\ttempString.append(textField2);\n-\t\t\t\tif (textField2Type != null){\n-\t\t\t\t\ttags.setMainField1(textField2Type);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// set mainfield 1\n-\t\tshow.setMainField1(tempString.toString());\n-\n-\t\t// new stringbuilder object\n-\t\ttempString = new StringBuilder();\n-\n-\t\tif (textField3 != null && textField3.length() > 0){\n-\t\t\t// If text 3 exists, put it in slot 2\n-\t\t\ttempString.append(textField3);\n-\t\t\tif (textField3Type != null){\n-\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n-\t\t\t\ttypeList.add(textField3Type);\n-\t\t\t\ttags.setMainField2(typeList);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField4 != null && textField4.length() > 0){\n-\t\t\tif (textField3 != null && textField3.length() > 0){\n-\t\t\t\t// If text 3 exists, put it in slot 2 formatted\n-\t\t\t\ttempString.append(\" - \").append(textField4);\n-\t\t\t\tif (textField4Type != null){\n-\t\t\t\t\tList<MetadataType> typeList = new ArrayList<>();\n-\t\t\t\t\ttypeList.add(textField4Type);\n-\t\t\t\t\tif (textField3Type != null){\n-\t\t\t\t\t\ttypeList.add(textField3Type);\n-\t\t\t\t\t}\n-\t\t\t\t\ttags.setMainField2(typeList);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// If text 3 does not exist, put it in slot 3 unformatted\n-\t\t\t\ttempString.append(textField4);\n-\t\t\t\tif (textField4Type != null){\n-\t\t\t\t\ttags.setMainField2(textField4Type);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (tempString.toString().length() > 0){\n-\t\t\tshow.setMainField2(tempString.toString());\n-\t\t}\n-\n-\t\tshow.setMetadataTags(tags);\n-\t\treturn show;\n-\t}\n-\n-\tprivate Show assembleThreeLineShowText(Show show){\n-\n-\t\tMetadataTags tags = new MetadataTags();\n-\n-\t\tif (textField1 != null && textField1.length() > 0) {\n-\t\t\tshow.setMainField1(textField1);\n-\t\t\tif (textField1Type != null){\n-\t\t\t\ttags.setMainField1(textField1Type);\n \t\t\t}\n-\t\t}\n-\n-\t\tif (textField2 != null && textField2.length() > 0) {\n-\t\t\tshow.setMainField2(textField2);\n-\t\t\tif (textField2Type != null){\n-\t\t\t\ttags.setMainField2(textField2Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tStringBuilder tempString = new StringBuilder();\n-\n-\t\tif (textField3 != null && textField3.length() > 0){\n-\t\t\ttempString.append(textField3);\n-\t\t\tif (textField3Type != null){\n-\t\t\t\ttags.setMainField3(textField3Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField4 != null && textField4.length() > 0) {\n-\t\t\tif (textField3 != null && textField3.length() > 0) {\n-\t\t\t\t// If text 3 exists, put it in slot 3 formatted\n-\t\t\t\ttempString.append(\" - \").append(textField4);\n-\t\t\t\tif (textField4Type != null){\n-\t\t\t\t\tList<MetadataType> tags4 = new ArrayList<>();\n-\t\t\t\t\tif (textField3Type != null){\n-\t\t\t\t\t\ttags4.add(textField3Type);\n-\t\t\t\t\t}\n-\t\t\t\t\ttags4.add(textField4Type);\n-\t\t\t\t\ttags.setMainField3(tags4);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// If text 3 does not exist, put it in slot 3 formatted\n-\t\t\t\ttempString.append(textField4);\n-\t\t\t\tif (textField4Type != null){\n-\t\t\t\t\ttags.setMainField3(textField4Type);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+\t\t};\n \n-\t\tshow.setMainField3(tempString.toString());\n-\t\tshow.setMetadataTags(tags);\n-\t\treturn show;\n+\t\tupdateOperation = new TextAndGraphicUpdateOperation(internalInterface, fileManager.get(), defaultMainWindowCapability, currentScreenData, currentState(), updateOperationListener, currentScreenDataUpdateListener);\n+\t\ttransactionQueue.add(updateOperation, false);\n \t}\n-\n-\tprivate Show assembleFourLineShowText(Show show){\n-\n-\t\tMetadataTags tags = new MetadataTags();\n-\n-\t\tif (textField1 != null && textField1.length() > 0) {\n-\t\t\tshow.setMainField1(textField1);\n-\t\t\tif (textField1Type != null){\n-\t\t\t\ttags.setMainField1(textField1Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField2 != null && textField2.length() > 0) {\n-\t\t\tshow.setMainField2(textField2);\n-\t\t\tif (textField2Type != null){\n-\t\t\t\ttags.setMainField2(textField2Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField3 != null && textField3.length() > 0) {\n-\t\t\tshow.setMainField3(textField3);\n-\t\t\tif (textField3Type != null){\n-\t\t\t\ttags.setMainField3(textField3Type);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (textField4 != null && textField4.length() > 0) {\n-\t\t\tshow.setMainField4(textField4);\n-\t\t\tif (textField4Type != null){\n-\t\t\t\ttags.setMainField4(textField4Type);\n+\t//Updates pending task with current screen data\n+\tvoid updatePendingOperationsWithNewScreenData(Show newScreenData){\n+\t\tfor(Task task: transactionQueue.getTasksAsList()){\n+\t\t\tif(!(task instanceof TextAndGraphicUpdateOperation) || task.getState() == Task.IN_PROGRESS){\n+\t\t\t\tcontinue;\n \t\t\t}\n+\t\t\t((TextAndGraphicUpdateOperation) task).setCurrentScreenData(newScreenData);\n \t\t}\n-\n-\t\tshow.setMetadataTags(tags);\n-\t\treturn show;\n-\t}\n-\n-\t// Extraction\n-\n-\tShow extractTextFromShow(Show show){\n-\n-\t\tShow newShow = new Show();\n-\t\tnewShow.setMainField1(show.getMainField1());\n-\t\tnewShow.setMainField2(show.getMainField2());\n-\t\tnewShow.setMainField3(show.getMainField3());\n-\t\tnewShow.setMainField4(show.getMainField4());\n-\t\tnewShow.setTemplateTitle(show.getTemplateTitle());\n-\n-\t\treturn newShow;\n-\t}\n-\n-\tprivate Show setBlankTextFields(Show newShow){\n-\n-\t\tnewShow.setMainField1(\"\");\n-\t\tnewShow.setMainField2(\"\");\n-\t\tnewShow.setMainField3(\"\");\n-\t\tnewShow.setMainField4(\"\");\n-\t\tnewShow.setMediaTrack(\"\");\n-\t\tnewShow.setTemplateTitle(\"\");\n-\n-\t\treturn newShow;\n \t}\n \n-\tprivate void updateCurrentScreenDataState(Show show){\n-\n-\t\tif (show == null){\n-\t\t\tDebugTool.logError(TAG, \"can not updateCurrentScreenDataFromShow from null show\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// If the items are null, they were not updated, so we can't just set it directly\n-\t\tif (show.getMainField1() != null){\n-\t\t\tcurrentScreenData.setMainField1(show.getMainField1());\n-\t\t}\n-\t\tif (show.getMainField2() != null){\n-\t\t\tcurrentScreenData.setMainField2(show.getMainField2());\n-\t\t}\n-\t\tif (show.getMainField3() != null){\n-\t\t\tcurrentScreenData.setMainField3(show.getMainField3());\n-\t\t}\n-\t\tif (show.getMainField4() != null){\n-\t\t\tcurrentScreenData.setMainField4(show.getMainField4());\n-\t\t}\n-\t\tif (show.getTemplateTitle() != null){\n-\t\t\tcurrentScreenData.setTemplateTitle(show.getTemplateTitle());\n-\t\t}\n-\t\tif (show.getMediaTrack() != null){\n-\t\t\tcurrentScreenData.setMediaTrack(show.getMediaTrack());\n-\t\t}\n-\t\tif (show.getMetadataTags() != null){\n-\t\t\tcurrentScreenData.setMetadataTags(show.getMetadataTags());\n-\t\t}\n-\t\tif (show.getAlignment() != null){\n-\t\t\tcurrentScreenData.setAlignment(show.getAlignment());\n-\t\t}\n-\t\tif (show.getGraphic() != null){\n-\t\t\tcurrentScreenData.setGraphic(show.getGraphic());\n-\t\t}\n-\t\tif (show.getSecondaryGraphic() != null){\n-\t\t\tcurrentScreenData.setSecondaryGraphic(show.getSecondaryGraphic());\n-\t\t}\n+\tinterface CurrentScreenDataUpdatedListener{\n+\t\tvoid onUpdate(Show show);\n \t}\n \n-\t// Helpers\n \n-\tprivate List<String> findValidMainTextFields(){\n+\tprivate List<String> findNonNullTextFields() {\n \t\tList<String> array = new ArrayList<>();\n \n-\t\tif (textField1 != null && textField1.length() > 0) {\n+\t\tif (textField1 != null) {\n \t\t\tarray.add(textField1);\n \t\t}\n \n-\t\tif (textField2 != null && textField2.length() > 0) {\n+\t\tif (textField2 != null) {\n \t\t\tarray.add(textField2);\n \t\t}\n \n-\t\tif (textField3 != null && textField3.length() > 0) {\n+\t\tif (textField3 != null) {\n \t\t\tarray.add(textField3);\n \t\t}\n \n-\t\tif (textField4 != null && textField4.length() > 0) {\n+\t\tif (textField4 != null) {\n \t\t\tarray.add(textField4);\n \t\t}\n \n-\t\treturn array;\n-\t}\n-\n-\n-\tprivate List<MetadataType> findNonNullMetadataFields(){\n-\t\tList<MetadataType> array = new ArrayList<>();\n-\n-\t\tif (textField1Type != null) {\n-\t\t\tarray.add(textField1Type);\n-\t\t}\n-\n-\t\tif (textField2Type != null) {\n-\t\t\tarray.add(textField2Type);\n-\t\t}\n-\n-\t\tif (textField3Type != null) {\n-\t\t\tarray.add(textField3Type);\n+\t\tif(title != null){\n+\t\t\tarray.add(title);\n \t\t}\n \n-\t\tif (textField4Type != null) {\n-\t\t\tarray.add(textField4Type);\n+\t\tif(mediaTrackTextField != null){\n+\t\t\tarray.add(mediaTrackTextField);\n \t\t}\n \n \t\treturn array;\n \t}\n \n-\tabstract SdlArtwork getBlankArtwork();\n+\tBoolean hasData() {\n+\t\tboolean hasTextFields = (findNonNullTextFields().size() > 0);\n+\t\tboolean hasImageFields = (primaryGraphic != null) || (secondaryGraphic != null);\n \n-\t@SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n-\tprivate boolean sdlArtworkNeedsUpload(SdlArtwork artwork){\n-\t\tif (fileManager.get() != null) {\n-\t\t\treturn artwork != null && !fileManager.get().hasUploadedFile(artwork) && !artwork.isStaticIcon();\n-\t\t}\n-\t\treturn false;\n+\t\treturn hasTextFields || hasImageFields;\n \t}\n \n-\t/**\n-\t * Check to see if primaryGraphic should be updated\n-\t * @return true if primaryGraphic should be updated, false if not\n-\t */\n-\tprivate boolean shouldUpdatePrimaryImage() {\n-\t\tboolean templateSupportsPrimaryArtwork = templateSupportsImageField(ImageFieldName.graphic);\n-\n-\t\tString currentScreenDataPrimaryGraphicName = (currentScreenData != null && currentScreenData.getGraphic() != null) ? currentScreenData.getGraphic().getValue() : null;\n-\t\tString primaryGraphicName = primaryGraphic != null ? primaryGraphic.getName() : null;\n-\t\treturn templateSupportsPrimaryArtwork\n-\t\t\t\t&& !CompareUtils.areStringsEqual(currentScreenDataPrimaryGraphicName, primaryGraphicName, true, true)\n-\t\t\t\t&& primaryGraphic != null;\n-\t}\n \n-\t/**\n-\t * Check to see if secondaryGraphic should be updated\n-\t * @return true if secondaryGraphic should be updated, false if not\n-\t */\n-\tprivate boolean shouldUpdateSecondaryImage() {\n-\t\tboolean templateSupportsSecondaryArtwork = (templateSupportsImageField(ImageFieldName.graphic) || templateSupportsImageField(ImageFieldName.secondaryGraphic));\n+\t// Convert to State\n \n-\t\tString currentScreenDataSecondaryGraphicName = (currentScreenData != null && currentScreenData.getSecondaryGraphic() != null) ? currentScreenData.getSecondaryGraphic().getValue() : null;\n-\t\tString secondaryGraphicName = secondaryGraphic != null ? secondaryGraphic.getName() : null;\n-\t\treturn templateSupportsSecondaryArtwork\n-\t\t\t\t&& !CompareUtils.areStringsEqual(currentScreenDataSecondaryGraphicName, secondaryGraphicName, true, true)\n-\t\t\t\t&& secondaryGraphic != null;\n+\tprivate TextsAndGraphicsState currentState() {\n+\t\treturn new TextsAndGraphicsState(textField1, textField2, textField3, textField4, mediaTrackTextField,\n+\t\t\t\ttitle, primaryGraphic, secondaryGraphic, textAlignment, textField1Type, textField2Type, textField3Type, textField4Type);\n \t}\n \n-\t/**\n-\t * Check to see if template supports the specified image field\n-\t * @return true if image field is supported, false if not\n-\t */\n-\tprivate boolean templateSupportsImageField(ImageFieldName name) {\n-\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, name);\n-\t}\n+\t// Getters / Setters\n \n-\t/**\n-\t * Check to see if mediaTrackTextField should be updated\n-\t * @return true if mediaTrackTextField should be updated, false if not\n-\t */\n-\tprivate boolean shouldUpdateMediaTrackField() {\n-\t\treturn templateSupportsTextField(TextFieldName.mediaTrack);\n-\t}\n-\n-\t/**\n-\t * Check to see if title should be updated\n-\t * @return true if title should be updated, false if not\n-\t */\n-\tprivate boolean shouldUpdateTitleField() {\n-\t\treturn templateSupportsTextField(TextFieldName.templateTitle);\n-\t}\n-\n-\t/**\n-\t * Check to see if field should be updated\n-\t * @return true if field should be updated, false if not\n-\t */\n-\tprivate boolean templateSupportsTextField(TextFieldName name) {\n-\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasTextFieldOfName(defaultMainWindowCapability, name);\n-\t}\n-\n-\t// SCREEN ITEM SETTERS AND GETTERS\n-\n-\tvoid setTextAlignment(TextAlignment textAlignment){\n+\tvoid setTextAlignment(TextAlignment textAlignment) {\n \t\tthis.textAlignment = textAlignment;\n \t\t// If we aren't batching, send the update immediately, if we are, set ourselves as dirty (so we know we should send an update after the batch ends)\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tTextAlignment getTextAlignment(){\n+\tTextAlignment getTextAlignment() {\n \t\treturn textAlignment;\n \t}\n \n-\tvoid setMediaTrackTextField(String mediaTrackTextField){\n+\tvoid setMediaTrackTextField(String mediaTrackTextField) {\n \t\tthis.mediaTrackTextField = mediaTrackTextField;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getMediaTrackTextField(){\n+\tString getMediaTrackTextField() {\n \t\treturn mediaTrackTextField;\n \t}\n \n-\tvoid setTextField1(String textField1){\n+\tvoid setTextField1(String textField1) {\n \t\tthis.textField1 = textField1;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField1(){\n+\tString getTextField1() {\n \t\treturn textField1;\n \t}\n \n-\tvoid setTextField2(String textField2){\n+\tvoid setTextField2(String textField2) {\n \t\tthis.textField2 = textField2;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField2(){\n+\tString getTextField2() {\n \t\treturn textField2;\n \t}\n \n-\tvoid setTextField3(String textField3){\n+\tvoid setTextField3(String textField3) {\n \t\tthis.textField3 = textField3;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField3(){\n+\tString getTextField3() {\n \t\treturn textField3;\n \t}\n \n-\tvoid setTextField4(String textField4){\n+\tvoid setTextField4(String textField4) {\n \t\tthis.textField4 = textField4;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTextField4(){\n+\tString getTextField4() {\n \t\treturn textField4;\n \t}\n \n-\tvoid setTextField1Type(MetadataType textField1Type){\n+\tvoid setTextField1Type(MetadataType textField1Type) {\n \t\tthis.textField1Type = textField1Type;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField1Type(){\n+\tMetadataType getTextField1Type() {\n \t\treturn textField1Type;\n \t}\n \n-\tvoid setTextField2Type(MetadataType textField2Type){\n+\tvoid setTextField2Type(MetadataType textField2Type) {\n \t\tthis.textField2Type = textField2Type;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField2Type(){\n+\tMetadataType getTextField2Type() {\n \t\treturn textField2Type;\n \t}\n \n-\tvoid setTextField3Type(MetadataType textField3Type){\n+\tvoid setTextField3Type(MetadataType textField3Type) {\n \t\tthis.textField3Type = textField3Type;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField3Type(){\n+\tMetadataType getTextField3Type() {\n \t\treturn textField3Type;\n \t}\n \n-\tvoid setTextField4Type(MetadataType textField4Type){\n+\tvoid setTextField4Type(MetadataType textField4Type) {\n \t\tthis.textField4Type = textField4Type;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tMetadataType getTextField4Type(){\n+\tMetadataType getTextField4Type() {\n \t\treturn textField4Type;\n \t}\n \n-\tvoid setTitle(String title){\n+\tvoid setTitle(String title) {\n \t\tthis.title = title;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tString getTitle(){\n+\tString getTitle() {\n \t\treturn title;\n \t}\n \n-\tvoid setPrimaryGraphic(SdlArtwork primaryGraphic){\n+\tvoid setPrimaryGraphic(SdlArtwork primaryGraphic) {\n \t\tthis.primaryGraphic = primaryGraphic;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tSdlArtwork getPrimaryGraphic(){\n+\tSdlArtwork getPrimaryGraphic() {\n \t\treturn primaryGraphic;\n \t}\n \n-\tvoid setSecondaryGraphic(SdlArtwork secondaryGraphic){\n+\tvoid setSecondaryGraphic(SdlArtwork secondaryGraphic) {\n \t\tthis.secondaryGraphic = secondaryGraphic;\n-\t\tif (!batchingUpdates){\n+\t\tif (!batchingUpdates) {\n \t\t\tsdlUpdate(null);\n-\t\t}else{\n+\t\t} else {\n \t\t\tisDirty = true;\n \t\t}\n \t}\n \n-\tSdlArtwork getSecondaryGraphic(){\n+\tSdlArtwork getSecondaryGraphic() {\n \t\treturn secondaryGraphic;\n \t}\n \n-\tvoid setBatchUpdates(boolean batching){\n+\tvoid setBatchUpdates(boolean batching) {\n \t\tthis.batchingUpdates = batching;\n \t}\n \n+\tprivate void addListeners() {\n+\t\t// add listener\n+\t\thmiListener = new OnRPCNotificationListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onNotified(RPCNotification notification) {\n+\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tcurrentHMILevel = onHMIStatus.getHmiLevel();\n+\t\t\t\tupdateTransactionQueueSuspended();\n+\t\t\t}\n+\t\t};\n+\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+\n+\t\tonDisplaysCapabilityListener = new OnSystemCapabilityListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n+\t\t\t\t// instead of using the parameter it's more safe to use the convenience method\n+\t\t\t\tList<DisplayCapability> capabilities = SystemCapabilityManager.convertToList(capability, DisplayCapability.class);\n+\t\t\t\tif (capabilities == null || capabilities.size() == 0) {\n+\t\t\t\t\tDebugTool.logError(TAG, \"TextAndGraphic Manager - Capabilities sent here are null or empty\");\n+\t\t\t\t} else {\n+\t\t\t\t\tDisplayCapability display = capabilities.get(0);\n+\t\t\t\t\tfor (WindowCapability windowCapability : display.getWindowCapabilities()) {\n+\t\t\t\t\t\tint currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+\t\t\t\t\t\tif (currentWindowID == PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+\t\t\t\t\t\t\tdefaultMainWindowCapability = windowCapability;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t// Update the queue's suspend state\n+\t\t\t\tupdateTransactionQueueSuspended();\n+\t\t\t\tif (hasData()) {\n+\t\t\t\t\tupdate(null);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void onError(String info) {\n+\t\t\t\tDebugTool.logError(TAG, \"Display Capability cannot be retrieved\");\n+\t\t\t\tdefaultMainWindowCapability = null;\n+\t\t\t\tupdateTransactionQueueSuspended();\n+\t\t\t}\n+\t\t};\n+\t\tthis.internalInterface.addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+\t}\n }\n", "next_change": {"commit": "9e77ff43b1450f656e8ae6405a8da6bb435e5127", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex b8190edaa..4bdfcb441 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -483,6 +504,8 @@ abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \t\t\t\tupdateTransactionQueueSuspended();\n \t\t\t}\n \t\t};\n-\t\tthis.internalInterface.addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+\t\tif (internalInterface.getSystemCapabilityManager() != null) {\n+\t\t\tthis.internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+\t\t}\n \t}\n }\n", "next_change": {"commit": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\nindex 4bdfcb441..0a201fc22 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/BaseTextAndGraphicManager.java\n", "chunk": "@@ -69,443 +69,504 @@ import static com.smartdevicelink.proxy.rpc.enums.TextAlignment.CENTERED;\n  */\n abstract class BaseTextAndGraphicManager extends BaseSubManager {\n \n-\tprivate static final String TAG = \"TextAndGraphicManager\";\n-\n-\tboolean isDirty;\n-\tShow currentScreenData;\n-\tHMILevel currentHMILevel;\n-\tprivate final WeakReference<SoftButtonManager> softButtonManager;\n-\tWindowCapability defaultMainWindowCapability;\n-\tprivate boolean batchingUpdates;\n-\tprivate final WeakReference<FileManager> fileManager;\n-\tSdlArtwork blankArtwork;\n-\tprivate OnRPCNotificationListener hmiListener;\n-\tprivate OnSystemCapabilityListener onDisplaysCapabilityListener;\n-\tprivate SdlArtwork primaryGraphic, secondaryGraphic;\n-\tprivate TextAlignment textAlignment;\n-\tprivate String textField1, textField2, textField3, textField4, mediaTrackTextField, title;\n-\tprivate MetadataType textField1Type, textField2Type, textField3Type, textField4Type;\n-\tTextAndGraphicUpdateOperation updateOperation;\n-\tprivate CompletionListener currentOperationListener;\n-\tQueue transactionQueue;\n-\n-\t//Constructors\n-\n-\tBaseTextAndGraphicManager(@NonNull ISdl internalInterface, @NonNull FileManager fileManager, @NonNull SoftButtonManager softButtonManager) {\n-\t\t// set class vars\n-\t\tsuper(internalInterface);\n-\t\tthis.fileManager = new WeakReference<>(fileManager);\n-\t\tthis.softButtonManager = new WeakReference<>(softButtonManager);\n-\t\tbatchingUpdates = false;\n-\t\tisDirty = false;\n-\t\ttextAlignment = CENTERED;\n-\t\tcurrentHMILevel = HMILevel.HMI_NONE;\n-\t\tcurrentScreenData = new Show();\n-\t\tthis.transactionQueue = newTransactionQueue();\n-\t\taddListeners();\n-\t}\n-\n-\t@Override\n-\tpublic void start(CompletionListener listener) {\n-\t\ttransitionToState(READY);\n-\t\tsuper.start(listener);\n-\t}\n-\n-\t@Override\n-\tpublic void dispose() {\n-\t\ttextField1 = null;\n-\t\ttextField1Type = null;\n-\t\ttextField2 = null;\n-\t\ttextField2Type = null;\n-\t\ttextField3 = null;\n-\t\ttextField3Type = null;\n-\t\ttextField4 = null;\n-\t\ttextField4Type = null;\n-\t\tmediaTrackTextField = null;\n-\t\ttitle = null;\n-\t\ttextAlignment = null;\n-\t\tprimaryGraphic = null;\n-\t\tsecondaryGraphic = null;\n-\t\tblankArtwork = null;\n-\t\tdefaultMainWindowCapability = null;\n-\t\tcurrentScreenData = null;\n-\t\tisDirty = false;\n-\t\tupdateOperation = null;\n-\n-\t\t// Cancel the operations\n-\t\tif (transactionQueue != null) {\n-\t\t\ttransactionQueue.close();\n-\t\t\ttransactionQueue = null;\n-\t\t}\n-\n-\t\t// remove listeners\n-\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\tif (internalInterface.getSystemCapabilityManager() != null) {\n-\t\t\tinternalInterface.getSystemCapabilityManager().removeOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n-\t\t}\n-\n-\t\tsuper.dispose();\n-\t}\n-\n-\tprivate Queue newTransactionQueue() {\n-\t\tQueue queue = internalInterface.getTaskmaster().createQueue(\"TextAndGraphicManager\", 3, false);\n-\t\tqueue.pause();\n-\t\treturn queue;\n-\t}\n-\n-\t// Suspend the queue if the WindowCapabilities are null\n-\t// OR if the HMI level is NONE since we want to delay sending RPCs until we're in non-NONE\n-\tprivate void updateTransactionQueueSuspended() {\n-\t\tif (defaultMainWindowCapability == null || HMILevel.HMI_NONE.equals(currentHMILevel)) {\n-\t\t\tDebugTool.logInfo(TAG, String.format(\"Suspending the transaction queue. Current HMI level is NONE: %b, window capabilities are null: %b\", HMILevel.HMI_NONE.equals(currentHMILevel), defaultMainWindowCapability == null));\n-\t\t\ttransactionQueue.pause();\n-\t\t} else {\n-\t\t\tDebugTool.logInfo(TAG, \"Starting the transaction queue\");\n-\t\t\ttransactionQueue.resume();\n-\t\t}\n-\t}\n-\n-\t// Upload / Send\n-\n-\tprotected void update(CompletionListener listener) {\n-\t\t// check if is batch update\n-\t\tif (batchingUpdates) {\n-\t\t\treturn;\n-\t\t}\n-\t\tif (isDirty) {\n-\t\t\tisDirty = false;\n-\t\t\tsdlUpdate(listener);\n-\t\t} else if (listener != null) {\n-\t\t\tlistener.onComplete(true);\n-\t\t}\n-\t}\n-\n-\tprivate synchronized void sdlUpdate(final CompletionListener listener) {\n-\t\tif (this.transactionQueue.getTasksAsList().size() > 0) {\n-\t\t\t// Transactions already in queue, we need to clear it out\n-\t\t\ttransactionQueue.clear();\n-\t\t\tupdateOperation = null;\n-\t\t\tif (currentOperationListener != null) {\n-\t\t\t\tcurrentOperationListener.onComplete(false);\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Task can be READY, about to start and popped of the queue, so we have to cancel it, to prevent it from starting\n-\t\tif (updateOperation != null && updateOperation.getState() == Task.READY) {\n-\t\t\tupdateOperation.cancelTask();\n-\t\t\tif (currentOperationListener != null) {\n-\t\t\t\tcurrentOperationListener.onComplete(false);\n-\t\t\t}\n-\t\t}\n-\n-\t\t// If Task is IN_PROGRESS, it\u2019s not on the queue, we need to mark it as cancelled. The task will return at some point when it checks its status and call the listener back\n-\t\tif (updateOperation != null && updateOperation.getState() == Task.IN_PROGRESS) {\n-\t\t\tupdateOperation.cancelTask();\n-\t\t}\n-\n-\t\tcurrentOperationListener = listener;\n-\n-\t\tCurrentScreenDataUpdatedListener currentScreenDataUpdateListener = new CurrentScreenDataUpdatedListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onUpdate(Show show) {\n-\t\t\t\tupdatePendingOperationsWithNewScreenData(show);\n-\t\t\t\tcurrentScreenData = show;\n-\t\t\t}\n-\t\t};\n-\n-\t\tupdateOperation = new TextAndGraphicUpdateOperation(internalInterface, fileManager.get(), defaultMainWindowCapability, currentScreenData, currentState(), currentOperationListener, currentScreenDataUpdateListener);\n-\t\ttransactionQueue.add(updateOperation, false);\n-\t}\n-\n-\t//Updates pending task with current screen data\n-\tvoid updatePendingOperationsWithNewScreenData(Show newScreenData) {\n-\t\tfor (Task task : transactionQueue.getTasksAsList()) {\n-\t\t\tif (!(task instanceof TextAndGraphicUpdateOperation)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\t((TextAndGraphicUpdateOperation) task).setCurrentScreenData(newScreenData);\n-\t\t}\n-\t\tif (this.softButtonManager.get() != null && newScreenData.getMainField1() != null) {\n-\t\t\tthis.softButtonManager.get().setCurrentMainField1(currentScreenData.getMainField1());\n-\t\t}\n-\t}\n-\n-\tinterface CurrentScreenDataUpdatedListener {\n-\t\tvoid onUpdate(Show show);\n-\t}\n-\n-\n-\tprivate List<String> findNonNullTextFields() {\n-\t\tList<String> array = new ArrayList<>();\n-\n-\t\tif (textField1 != null) {\n-\t\t\tarray.add(textField1);\n-\t\t}\n-\n-\t\tif (textField2 != null) {\n-\t\t\tarray.add(textField2);\n-\t\t}\n-\n-\t\tif (textField3 != null) {\n-\t\t\tarray.add(textField3);\n-\t\t}\n-\n-\t\tif (textField4 != null) {\n-\t\t\tarray.add(textField4);\n-\t\t}\n-\n-\t\tif (title != null) {\n-\t\t\tarray.add(title);\n-\t\t}\n-\n-\t\tif (mediaTrackTextField != null) {\n-\t\t\tarray.add(mediaTrackTextField);\n-\t\t}\n-\n-\t\treturn array;\n-\t}\n-\n-\tBoolean hasData() {\n-\t\tboolean hasTextFields = (findNonNullTextFields().size() > 0);\n-\t\tboolean hasImageFields = (primaryGraphic != null) || (secondaryGraphic != null);\n-\n-\t\treturn hasTextFields || hasImageFields;\n-\t}\n-\n-\tabstract SdlArtwork getBlankArtwork();\n-\n-\n-\t// Convert to State\n-\n-\tprivate TextsAndGraphicsState currentState() {\n-\t\treturn new TextsAndGraphicsState(textField1, textField2, textField3, textField4, mediaTrackTextField,\n-\t\t\t\ttitle, primaryGraphic, secondaryGraphic, textAlignment, textField1Type, textField2Type, textField3Type, textField4Type);\n-\t}\n-\n-\t// Getters / Setters\n-\n-\tvoid setTextAlignment(TextAlignment textAlignment) {\n-\t\tthis.textAlignment = textAlignment;\n-\t\t// If we aren't batching, send the update immediately, if we are, set ourselves as dirty (so we know we should send an update after the batch ends)\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tTextAlignment getTextAlignment() {\n-\t\treturn textAlignment;\n-\t}\n-\n-\tvoid setMediaTrackTextField(String mediaTrackTextField) {\n-\t\tthis.mediaTrackTextField = mediaTrackTextField;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tString getMediaTrackTextField() {\n-\t\treturn mediaTrackTextField;\n-\t}\n-\n-\tvoid setTextField1(String textField1) {\n-\t\tthis.textField1 = textField1;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tString getTextField1() {\n-\t\treturn textField1;\n-\t}\n-\n-\tvoid setTextField2(String textField2) {\n-\t\tthis.textField2 = textField2;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tString getTextField2() {\n-\t\treturn textField2;\n-\t}\n-\n-\tvoid setTextField3(String textField3) {\n-\t\tthis.textField3 = textField3;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tString getTextField3() {\n-\t\treturn textField3;\n-\t}\n-\n-\tvoid setTextField4(String textField4) {\n-\t\tthis.textField4 = textField4;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tString getTextField4() {\n-\t\treturn textField4;\n-\t}\n-\n-\tvoid setTextField1Type(MetadataType textField1Type) {\n-\t\tthis.textField1Type = textField1Type;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tMetadataType getTextField1Type() {\n-\t\treturn textField1Type;\n-\t}\n-\n-\tvoid setTextField2Type(MetadataType textField2Type) {\n-\t\tthis.textField2Type = textField2Type;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tMetadataType getTextField2Type() {\n-\t\treturn textField2Type;\n-\t}\n-\n-\tvoid setTextField3Type(MetadataType textField3Type) {\n-\t\tthis.textField3Type = textField3Type;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tMetadataType getTextField3Type() {\n-\t\treturn textField3Type;\n-\t}\n-\n-\tvoid setTextField4Type(MetadataType textField4Type) {\n-\t\tthis.textField4Type = textField4Type;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tMetadataType getTextField4Type() {\n-\t\treturn textField4Type;\n-\t}\n-\n-\tvoid setTitle(String title) {\n-\t\tthis.title = title;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tString getTitle() {\n-\t\treturn title;\n-\t}\n-\n-\tvoid setPrimaryGraphic(SdlArtwork primaryGraphic) {\n-\t\tthis.primaryGraphic = primaryGraphic;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tSdlArtwork getPrimaryGraphic() {\n-\t\treturn primaryGraphic;\n-\t}\n-\n-\tvoid setSecondaryGraphic(SdlArtwork secondaryGraphic) {\n-\t\tthis.secondaryGraphic = secondaryGraphic;\n-\t\tif (!batchingUpdates) {\n-\t\t\tsdlUpdate(null);\n-\t\t} else {\n-\t\t\tisDirty = true;\n-\t\t}\n-\t}\n-\n-\tSdlArtwork getSecondaryGraphic() {\n-\t\treturn secondaryGraphic;\n-\t}\n-\n-\tvoid setBatchUpdates(boolean batching) {\n-\t\tthis.batchingUpdates = batching;\n-\t}\n-\n-\tprivate void addListeners() {\n-\t\t// add listener\n-\t\thmiListener = new OnRPCNotificationListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n-\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tcurrentHMILevel = onHMIStatus.getHmiLevel();\n-\t\t\t\tupdateTransactionQueueSuspended();\n-\t\t\t}\n-\t\t};\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\n-\t\tonDisplaysCapabilityListener = new OnSystemCapabilityListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t// instead of using the parameter it's more safe to use the convenience method\n-\t\t\t\tList<DisplayCapability> capabilities = SystemCapabilityManager.convertToList(capability, DisplayCapability.class);\n-\t\t\t\tif (capabilities == null || capabilities.size() == 0) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"TextAndGraphic Manager - Capabilities sent here are null or empty\");\n-\t\t\t\t\tdefaultMainWindowCapability = null;\n-\t\t\t\t} else {\n-\t\t\t\t\tDisplayCapability display = capabilities.get(0);\n-\t\t\t\t\tfor (WindowCapability windowCapability : display.getWindowCapabilities()) {\n-\t\t\t\t\t\tint currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\t\t\t\tif (currentWindowID == PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\t\t\tdefaultMainWindowCapability = windowCapability;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t// Update the queue's suspend state\n-\t\t\t\tupdateTransactionQueueSuspended();\n-\t\t\t\tif (hasData()) {\n-\t\t\t\t\tsdlUpdate(null);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(String info) {\n-\t\t\t\tDebugTool.logError(TAG, \"Display Capability cannot be retrieved\");\n-\t\t\t\tdefaultMainWindowCapability = null;\n-\t\t\t\tupdateTransactionQueueSuspended();\n-\t\t\t}\n-\t\t};\n-\t\tif (internalInterface.getSystemCapabilityManager() != null) {\n-\t\t\tthis.internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n-\t\t}\n-\t}\n+    private static final String TAG = \"TextAndGraphicManager\";\n+\n+    boolean isDirty;\n+    TextAndGraphicState currentScreenData;\n+    HMILevel currentHMILevel;\n+    private final WeakReference<SoftButtonManager> softButtonManager;\n+    WindowCapability defaultMainWindowCapability;\n+    private boolean batchingUpdates;\n+    private final WeakReference<FileManager> fileManager;\n+    SdlArtwork blankArtwork;\n+    private OnRPCNotificationListener hmiListener;\n+    private OnSystemCapabilityListener onDisplaysCapabilityListener;\n+    private SdlArtwork primaryGraphic, secondaryGraphic;\n+    private TextAlignment textAlignment;\n+    private String textField1, textField2, textField3, textField4, mediaTrackTextField, title;\n+    private MetadataType textField1Type, textField2Type, textField3Type, textField4Type;\n+    private TemplateConfiguration templateConfiguration;\n+    TextAndGraphicUpdateOperation updateOperation;\n+    private CompletionListener currentOperationListener;\n+    Queue transactionQueue;\n+\n+    //Constructors\n+\n+    BaseTextAndGraphicManager(@NonNull ISdl internalInterface, @NonNull FileManager fileManager, @NonNull SoftButtonManager softButtonManager) {\n+        // set class vars\n+        super(internalInterface);\n+        this.fileManager = new WeakReference<>(fileManager);\n+        this.softButtonManager = new WeakReference<>(softButtonManager);\n+        batchingUpdates = false;\n+        isDirty = false;\n+        textAlignment = CENTERED;\n+        currentHMILevel = HMILevel.HMI_NONE;\n+        currentScreenData = new TextAndGraphicState();\n+        this.transactionQueue = newTransactionQueue();\n+        addListeners();\n+    }\n+\n+    @Override\n+    public void start(CompletionListener listener) {\n+        transitionToState(READY);\n+        super.start(listener);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        textField1 = null;\n+        textField1Type = null;\n+        textField2 = null;\n+        textField2Type = null;\n+        textField3 = null;\n+        textField3Type = null;\n+        textField4 = null;\n+        textField4Type = null;\n+        mediaTrackTextField = null;\n+        title = null;\n+        textAlignment = null;\n+        primaryGraphic = null;\n+        secondaryGraphic = null;\n+        blankArtwork = null;\n+        defaultMainWindowCapability = null;\n+        currentScreenData = null;\n+        isDirty = false;\n+        updateOperation = null;\n+\n+        // Cancel the operations\n+        if (transactionQueue != null) {\n+            transactionQueue.close();\n+            transactionQueue = null;\n+        }\n+\n+        // remove listeners\n+        internalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        if (internalInterface.getSystemCapabilityManager() != null) {\n+            internalInterface.getSystemCapabilityManager().removeOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private Queue newTransactionQueue() {\n+        Queue queue = internalInterface.getTaskmaster().createQueue(\"TextAndGraphicManager\", 3, false);\n+        queue.pause();\n+        return queue;\n+    }\n+\n+    // Suspend the queue if the WindowCapabilities are null\n+    // OR if the HMI level is NONE since we want to delay sending RPCs until we're in non-NONE\n+    private void updateTransactionQueueSuspended() {\n+        if (defaultMainWindowCapability == null || HMILevel.HMI_NONE.equals(currentHMILevel)) {\n+            DebugTool.logInfo(TAG, String.format(\"Suspending the transaction queue. Current HMI level is NONE: %b, window capabilities are null: %b\", HMILevel.HMI_NONE.equals(currentHMILevel), defaultMainWindowCapability == null));\n+            transactionQueue.pause();\n+        } else {\n+            DebugTool.logInfo(TAG, \"Starting the transaction queue\");\n+            transactionQueue.resume();\n+        }\n+    }\n+\n+    // Upload / Send\n+\n+    protected void update(CompletionListener listener) {\n+        // check if is batch update\n+        if (batchingUpdates) {\n+            return;\n+        }\n+        if (isDirty) {\n+            isDirty = false;\n+            sdlUpdate(true, listener);\n+        } else if (listener != null) {\n+            listener.onComplete(true);\n+        }\n+    }\n+\n+    private synchronized void sdlUpdate(Boolean supersedePreviousOperations, final CompletionListener listener) {\n+        if (this.transactionQueue.getTasksAsList().size() > 0 && supersedePreviousOperations) {\n+            // Transactions already in queue, we need to clear it out\n+            transactionQueue.clear();\n+            updateOperation = null;\n+            if (currentOperationListener != null) {\n+                currentOperationListener.onComplete(false);\n+            }\n+        }\n+\n+        // Task can be READY, about to start and popped of the queue, so we have to cancel it, to prevent it from starting\n+        if (updateOperation != null && updateOperation.getState() == Task.READY && supersedePreviousOperations) {\n+            updateOperation.cancelTask();\n+            if (currentOperationListener != null) {\n+                currentOperationListener.onComplete(false);\n+            }\n+        }\n+\n+        // If Task is IN_PROGRESS, it\u2019s not on the queue, we need to mark it as cancelled. The task will return at some point when it checks its status and call the listener back\n+        if (updateOperation != null && updateOperation.getState() == Task.IN_PROGRESS && supersedePreviousOperations) {\n+            updateOperation.cancelTask();\n+        }\n+\n+        currentOperationListener = listener;\n+\n+        CurrentScreenDataUpdatedListener currentScreenDataUpdateListener = new CurrentScreenDataUpdatedListener() {\n+            @Override\n+            public void onUpdate(TextAndGraphicState newScreenData) {\n+                if (newScreenData != null) {\n+                    // Update our current screen data\n+                    currentScreenData = newScreenData;\n+                    updatePendingOperationsWithNewScreenData();\n+                }\n+            }\n+\n+            @Override\n+            public void onError() {\n+                // Invalidate data that's different from our current screen data\n+                resetFieldsToCurrentScreenData();\n+            }\n+        };\n+\n+        updateOperation = new TextAndGraphicUpdateOperation(internalInterface, fileManager.get(), defaultMainWindowCapability, currentScreenData, currentState(), currentOperationListener, currentScreenDataUpdateListener);\n+        transactionQueue.add(updateOperation, false);\n+    }\n+\n+    void resetFieldsToCurrentScreenData() {\n+        textField1 = currentScreenData.getTextField1();\n+        textField2 = currentScreenData.getTextField2();\n+        textField3 = currentScreenData.getTextField3();\n+        textField4 = currentScreenData.getTextField4();\n+        mediaTrackTextField = currentScreenData.getMediaTrackTextField();\n+        title = currentScreenData.getTitle();\n+        textAlignment = currentScreenData.getTextAlignment();\n+        textField1Type = currentScreenData.getTextField1Type();\n+        textField2Type = currentScreenData.getTextField2Type();\n+        textField3Type = currentScreenData.getTextField3Type();\n+        textField4Type = currentScreenData.getTextField4Type();\n+        primaryGraphic = currentScreenData.getPrimaryGraphic();\n+        secondaryGraphic = currentScreenData.getSecondaryGraphic();\n+        templateConfiguration = currentScreenData.getTemplateConfiguration();\n+    }\n+\n+    //Updates pending task with current screen data\n+    void updatePendingOperationsWithNewScreenData() {\n+        for (Task task : transactionQueue.getTasksAsList()) {\n+            if (!(task instanceof TextAndGraphicUpdateOperation)) {\n+                continue;\n+            }\n+            ((TextAndGraphicUpdateOperation) task).setCurrentScreenData(currentScreenData);\n+        }\n+        if (this.softButtonManager.get() != null && currentScreenData.getTextField1() != null) {\n+            this.softButtonManager.get().setCurrentMainField1(currentScreenData.getTextField1());\n+        }\n+    }\n+\n+    interface CurrentScreenDataUpdatedListener {\n+        void onUpdate(TextAndGraphicState newState);\n+\n+        void onError();\n+    }\n+\n+\n+    private List<String> findNonNullTextFields() {\n+        List<String> array = new ArrayList<>();\n+\n+        if (textField1 != null) {\n+            array.add(textField1);\n+        }\n+\n+        if (textField2 != null) {\n+            array.add(textField2);\n+        }\n+\n+        if (textField3 != null) {\n+            array.add(textField3);\n+        }\n+\n+        if (textField4 != null) {\n+            array.add(textField4);\n+        }\n+\n+        if (title != null) {\n+            array.add(title);\n+        }\n+\n+        if (mediaTrackTextField != null) {\n+            array.add(mediaTrackTextField);\n+        }\n+\n+        return array;\n+    }\n+\n+    Boolean hasData() {\n+        boolean hasTextFields = (findNonNullTextFields().size() > 0);\n+        boolean hasImageFields = (primaryGraphic != null) || (secondaryGraphic != null);\n+\n+        return hasTextFields || hasImageFields;\n+    }\n+\n+    abstract SdlArtwork getBlankArtwork();\n+\n+\n+    // Convert to State\n+\n+    TextAndGraphicState currentState() {\n+        return new TextAndGraphicState(textField1, textField2, textField3, textField4, mediaTrackTextField,\n+                title, primaryGraphic, secondaryGraphic, textAlignment, textField1Type, textField2Type, textField3Type, textField4Type, templateConfiguration);\n+    }\n+\n+    // Getters / Setters\n+\n+    void setTextAlignment(TextAlignment textAlignment) {\n+        this.textAlignment = textAlignment;\n+        // If we aren't batching, send the update immediately, if we are, set ourselves as dirty (so we know we should send an update after the batch ends)\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    TextAlignment getTextAlignment() {\n+        return textAlignment;\n+    }\n+\n+    void setMediaTrackTextField(String mediaTrackTextField) {\n+        this.mediaTrackTextField = mediaTrackTextField;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    String getMediaTrackTextField() {\n+        return mediaTrackTextField;\n+    }\n+\n+    void setTextField1(String textField1) {\n+        this.textField1 = textField1;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    String getTextField1() {\n+        return textField1;\n+    }\n+\n+    void setTextField2(String textField2) {\n+        this.textField2 = textField2;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    String getTextField2() {\n+        return textField2;\n+    }\n+\n+    void setTextField3(String textField3) {\n+        this.textField3 = textField3;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    String getTextField3() {\n+        return textField3;\n+    }\n+\n+    void setTextField4(String textField4) {\n+        this.textField4 = textField4;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    String getTextField4() {\n+        return textField4;\n+    }\n+\n+    void setTextField1Type(MetadataType textField1Type) {\n+        this.textField1Type = textField1Type;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    MetadataType getTextField1Type() {\n+        return textField1Type;\n+    }\n+\n+    void setTextField2Type(MetadataType textField2Type) {\n+        this.textField2Type = textField2Type;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    MetadataType getTextField2Type() {\n+        return textField2Type;\n+    }\n+\n+    void setTextField3Type(MetadataType textField3Type) {\n+        this.textField3Type = textField3Type;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    MetadataType getTextField3Type() {\n+        return textField3Type;\n+    }\n+\n+    void setTextField4Type(MetadataType textField4Type) {\n+        this.textField4Type = textField4Type;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    MetadataType getTextField4Type() {\n+        return textField4Type;\n+    }\n+\n+    void setTitle(String title) {\n+        this.title = title;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    String getTitle() {\n+        return title;\n+    }\n+\n+    void setPrimaryGraphic(SdlArtwork primaryGraphic) {\n+        this.primaryGraphic = primaryGraphic;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    SdlArtwork getPrimaryGraphic() {\n+        return primaryGraphic;\n+    }\n+\n+    void setSecondaryGraphic(SdlArtwork secondaryGraphic) {\n+        this.secondaryGraphic = secondaryGraphic;\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, null);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    /**\n+     * Change the current layout to a new layout and optionally update the layout's night and day color schemes.\n+     * The values set for the text, graphics, buttons and template title persist between layout changes.\n+     * To update the text, graphics, buttons and template title at the same time as the template, batch all the updates between beginTransaction and commit.\n+     * If the layout update fails while batching, then the updated text, graphics, buttons or template title will also not be updated.\n+     *\n+     * @param templateConfiguration The new configuration of the template, including the layout and color scheme.\n+     * @param listener              A listener that will be called when the layout change finished.\n+     */\n+    void changeLayout(TemplateConfiguration templateConfiguration, CompletionListener listener) {\n+        setTemplateConfiguration(templateConfiguration);\n+        if (!batchingUpdates) {\n+            sdlUpdate(true, listener);\n+        } else {\n+            isDirty = true;\n+        }\n+    }\n+\n+    TemplateConfiguration getTemplateConfiguration() {\n+        return templateConfiguration;\n+    }\n+\n+    void setTemplateConfiguration(TemplateConfiguration templateConfiguration) {\n+        // Don't do the `isBatchingUpdates` like elsewhere because the call is already handled in `changeLayout(TemplateConfiguration templateConfiguration, CompletionListener listener) `\n+        this.templateConfiguration = templateConfiguration;\n+    }\n+\n+    SdlArtwork getSecondaryGraphic() {\n+        return secondaryGraphic;\n+    }\n+\n+    void setBatchUpdates(boolean batching) {\n+        this.batchingUpdates = batching;\n+    }\n+\n+    private void addListeners() {\n+        // add listener\n+        hmiListener = new OnRPCNotificationListener() {\n+            @Override\n+            public void onNotified(RPCNotification notification) {\n+                OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                    return;\n+                }\n+                currentHMILevel = onHMIStatus.getHmiLevel();\n+                updateTransactionQueueSuspended();\n+            }\n+        };\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+\n+        onDisplaysCapabilityListener = new OnSystemCapabilityListener() {\n+            @Override\n+            public void onCapabilityRetrieved(Object capability) {\n+                // instead of using the parameter it's more safe to use the convenience method\n+                List<DisplayCapability> capabilities = SystemCapabilityManager.convertToList(capability, DisplayCapability.class);\n+                if (capabilities == null || capabilities.size() == 0) {\n+                    DebugTool.logError(TAG, \"TextAndGraphic Manager - Capabilities sent here are null or empty\");\n+                    defaultMainWindowCapability = null;\n+                } else {\n+                    DisplayCapability display = capabilities.get(0);\n+                    for (WindowCapability windowCapability : display.getWindowCapabilities()) {\n+                        int currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+                        if (currentWindowID == PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                            // Check if the window capability is equal to the one we already have. If it is, abort.\n+                            if (defaultMainWindowCapability != null && defaultMainWindowCapability.getStore().equals(windowCapability.getStore())) {\n+                                return;\n+                            }\n+                            defaultMainWindowCapability = windowCapability;\n+                        }\n+                    }\n+                }\n+                // Update the queue's suspend state\n+                updateTransactionQueueSuspended();\n+                if (hasData()) {\n+                    // HAX: Capability updates cannot supersede earlier updates because of the case where a developer batched a `changeLayout` call w/ T&G changes on < 6.0 systems could cause this to come in before the operation completes. That would cause the operation to report a \"failure\" (because it was superseded by this call) when in fact the operation didn't fail at all and is just being adjusted.\n+                    sdlUpdate(false, null);\n+                }\n+            }\n+\n+            @Override\n+            public void onError(String info) {\n+                DebugTool.logError(TAG, \"Display Capability cannot be retrieved\");\n+                defaultMainWindowCapability = null;\n+                updateTransactionQueueSuspended();\n+            }\n+        };\n+        if (internalInterface.getSystemCapabilityManager() != null) {\n+            this.internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "message": "Merge commit", "committedDate": null}, {"oid": "763753da5436d9e296cda95e50a5c7ac3740079c", "committedDate": "2020-05-20 15:56:21 -0400", "message": "Update null checks for the Base Managers"}, {"oid": "52ef200d1c60e85373c2a5484d03c11ad87f5ec3", "committedDate": "2020-05-26 11:01:01 -0400", "message": "Fix max line"}, {"oid": "9762e00fd51397c5e3549c7ef2dd9fe2910c376b", "committedDate": "2020-06-11 11:58:43 -0400", "message": "Create Log Wrapper and Repace Base library logging"}, {"oid": "a13463c85c8969dd1934cfbe35804a8cce00281c", "committedDate": "2020-06-11 16:09:29 -0400", "message": "Wrap Log.java and move base logging to DebugTool"}, {"oid": "df7badc06dfdeb3b9cccb7496d1a27471874e877", "committedDate": "2020-06-26 15:03:18 -0400", "message": "Use new logInfo API instead of Deprecated API"}, {"oid": "05d262701ff3495da7470a925bf67a91b57ad163", "committedDate": "2020-06-26 16:40:13 -0400", "message": "Move logError to new DebugTool APIs in android/base"}, {"oid": "87f443305eef5dcf5d0cd70ecbe9ad5f7c5c5100", "committedDate": "2020-08-04 16:50:18 -0400", "message": "Move SCM to managers.lifecycle package"}, {"oid": "3e9f90212e713f85369e6a11f1d15abf3b966bdf", "committedDate": "2020-08-10 19:35:10 -0400", "message": "Update imports to androidX"}, {"oid": "faeb0e9ee70af8bb81eda226bbac0082f72e6417", "committedDate": "2020-08-18 15:21:22 -0400", "message": "Remove onError from TextAndGraphicManager"}, {"oid": "d1ade9d639958a5a9eca69488d62a0ef7d196f40", "committedDate": "2020-08-18 16:10:19 -0400", "message": "Very rough draft, Added two classes TextAndGraphicUpdateOperation and TextAndGraphicsState. Refactored BaseT&Gmanager"}, {"oid": "afd900229c8e4bea0c1062a858acc8c8e2ffaea2", "committedDate": "2020-08-18 16:32:55 -0400", "message": "Added call to updateTransactionQueueSuspended in hmiListener and fixed some formatting"}, {"oid": "be1956908cf446b7ae84f91fabbf43a6d248af97", "committedDate": "2020-08-19 10:58:47 -0400", "message": "Align blankArtwork logic with IOS"}, {"oid": "d10a5525520ba077ac2f1f841e6bb9653880263f", "committedDate": "2020-08-19 16:26:07 -0400", "message": "Fixed formatting and Aligned logic with IOS"}, {"oid": "09cfdefd37f14f684f34417b19351d10bfb9a389", "committedDate": "2020-08-20 13:25:33 -0400", "message": "Added null check for listener"}, {"oid": "0f6a3f5c7f286686a78e7ecc9ee397bcbba675b0", "committedDate": "2020-08-21 11:16:08 -0400", "message": "Fix OnSystemCapabilityListener package name"}, {"oid": "7d27d47885cc983ba9c9f49df4ff329654dea0de", "committedDate": "2020-08-21 13:08:18 -0400", "message": "Remove unsed imports"}, {"oid": "b667a9b159f6d7443acdcd1b5b230652dbd576b8", "committedDate": "2020-08-21 15:38:41 -0400", "message": "Merge branch 'develop' into feature/fix_scm_package"}, {"oid": "be7157d524736b19fb9277c5cad3dc0e9bec3935", "committedDate": "2020-08-21 16:08:35 -0400", "message": "IOS alignment"}, {"oid": "8750183930d06f53f51353e6839c6ae27a323547", "committedDate": "2020-08-22 16:05:22 -0400", "message": "Merge branch 'develop' into TextAndGraphicsManager-Refactor-Queues"}, {"oid": "788be099f11fb96e3ebb9a2dce9752fb6c9e3735", "committedDate": "2020-08-22 16:14:07 -0400", "message": "Fix OnRPCResponseListener in TextAndGraphicsOperation and remove unused imports"}, {"oid": "381094c7666e36dbe4e66da837ed05a1d9c6f093", "committedDate": "2020-08-22 16:55:33 -0400", "message": "Added unit test to TextAndGraphicsManager"}, {"oid": "f9fa66d9d5f540bbedb98b8377974de4ee2bafad", "committedDate": "2020-08-23 15:27:41 -0400", "message": "Added test for OnRPCNotificationListener in T&G manager"}, {"oid": "ec88eaab3e4d130500185f303dea98ebaa04481f", "committedDate": "2020-08-23 17:50:59 -0400", "message": "Added functionality to cancel task and fix formatting"}, {"oid": "676b3db50a6ef9cb5314dbb89a8b23c4a95f2337", "committedDate": "2020-08-23 17:59:45 -0400", "message": "Updated copyright fixed formatting"}, {"oid": "de3f00e43aa8d61e7cb589c16d4fe57d416abda1", "committedDate": "2020-08-24 15:40:07 -0400", "message": "Fixed task executing canceling"}, {"oid": "54e78d863f1d714f85b1fd03de67842f3199826a", "committedDate": "2020-08-24 15:56:50 -0400", "message": "Fix canceling logic for operations"}, {"oid": "f0ac42ed59bd8b0a45c7a7c3f1a41f8dae5075c0", "committedDate": "2020-08-24 16:00:03 -0400", "message": "Added null check"}, {"oid": "3954d4ea76e35d5fa5bc17ba7eae4e7ae8544a7e", "committedDate": "2020-08-26 11:38:32 -0400", "message": "Fixed softButton mainField1 issue"}, {"oid": "cdaac8e90faf848b22a64aa322af3ca9776af764", "committedDate": "2020-08-26 13:42:58 -0400", "message": "Add Override back for blankArtwork"}, {"oid": "8d445a8cb181722c74172dae9266458563692c0a", "committedDate": "2020-08-26 14:43:21 -0400", "message": "Updated CurrentScreenData with onUpdate while updating pending operations, set defadefaultMainWindowCapability to null if no capabilities received"}, {"oid": "cdadb3bf31051787bf48bcb14a0e7da1d4300706", "committedDate": "2020-08-26 19:01:18 -0400", "message": "Fixed queue management"}, {"oid": "22fd530fe67f1ea15d732b922a403c8d07600125", "committedDate": "2020-08-26 19:26:45 -0400", "message": "Fixed Unit test"}, {"oid": "64543b97b18d07005cb827435ca0161c3dd9291d", "committedDate": "2020-08-27 17:13:31 -0400", "message": "Fixing issues form Review"}, {"oid": "9b2831fa6f6c6a46c285bf1050e1762243e417b6", "committedDate": "2020-08-27 17:15:57 -0400", "message": "Update comments"}, {"oid": "9e77ff43b1450f656e8ae6405a8da6bb435e5127", "committedDate": "2020-09-08 15:25:03 -0400", "message": "Remove Deprecated Isdl methods (#1485)"}, {"oid": "cd4ac27321c641ef4a9c9f6628059735364ef4dd", "committedDate": "2020-09-15 14:02:09 -0400", "message": "Move proxy interfaces to better packages"}, {"oid": "6e93579d490d60deb382e96ee4bc8d7581989929", "committedDate": "2020-09-17 13:40:18 -0400", "message": "[SDL 0278] Screen Manager Template Management (#1492)"}, {"oid": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "committedDate": "2020-09-17 16:31:17 -0400", "message": "Run the Reformat Code tool on the project"}, {"oid": "44b38cb3766f2685aee586db0ede1d00dffd19e4", "committedDate": "2022-09-21 15:22:23 -0400", "message": "Bugfix/issue 1828 Good text failing (#1831)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5ODA2MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406298061", "body": "Is there a reason why this methods are `shouldSend____Text` instead of something more like `is___TextSupported`?", "bodyText": "Is there a reason why this methods are shouldSend____Text instead of something more like is___TextSupported?", "bodyHTML": "<p dir=\"auto\">Is there a reason why this methods are <code>shouldSend____Text</code> instead of something more like <code>is___TextSupported</code>?</p>", "author": "joeygrover", "createdAt": "2020-04-09T15:42:34Z", "path": "base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java", "diffHunk": "@@ -227,14 +230,44 @@ private CreateInteractionChoiceSet choiceFromCell(ChoiceCell cell){\n \t}\n \n \t// HELPERS\n+\tboolean shouldSendChoiceText() {", "originalCommit": "40ed2d11522da4529c645b5df05df0fedd8769e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NjA3OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406376079", "bodyText": "No reason other than following the iOS naming to make them easier to compare and maintain in the future. If you prefer changing the names, I suggest removing these 5 methods and call templateSupports___Field() directly.", "author": "bilal-alsharifi", "createdAt": "2020-04-09T17:53:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5ODA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3OTg4Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406379886", "bodyText": "If this matches iOS then we can keep these for now. I would like to revisit for both after this release if possible. The naming doesn't make sense in my opinion.", "author": "joeygrover", "createdAt": "2020-04-09T17:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5ODA2MQ=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "fd96983377fad92eefa3818fd24c58aee0b6180c", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\nindex bce9aabb8..8eb72f421 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n", "chunk": "@@ -231,7 +226,7 @@ class PreloadChoicesOperation extends AsynchronousOperation {\n \n \t// HELPERS\n \tboolean shouldSendChoiceText() {\n-\t\tif (this.displayName != null && this.displayName.equals(DisplayType.GEN3_8_INCH)){\n+\t\tif (this.displayName != null && this.displayName.equals(DisplayType.GEN3_8_INCH.toString())){\n \t\t\treturn true;\n \t\t}\n \t\treturn templateSupportsTextField(TextFieldName.menuName);\n", "next_change": {"commit": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\nindex 8eb72f421..6bf0b7d25 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n", "chunk": "@@ -63,216 +63,218 @@ import java.util.List;\n import java.util.Map;\n \n class PreloadChoicesOperation extends Task {\n-\tprivate static final String TAG = \"PreloadChoicesOperation\";\n-\tprivate final WeakReference<ISdl> internalInterface;\n-\tprivate final WeakReference<FileManager> fileManager;\n-\tprivate final WindowCapability defaultMainWindowCapability;\n-\tprivate final String displayName;\n-\tprivate final HashSet<ChoiceCell> cellsToUpload;\n-\tprivate final CompletionListener completionListener;\n-\tprivate boolean isRunning;\n-\tprivate final boolean isVROptional;\n-\tprivate boolean choiceError = false;\n-\n-\tPreloadChoicesOperation(ISdl internalInterface, FileManager fileManager, String displayName, WindowCapability defaultMainWindowCapability,\n-\t\t\t\t\t\t\t\t   Boolean isVROptional, HashSet<ChoiceCell> cellsToPreload, CompletionListener listener){\n-\t\tsuper(\"PreloadChoicesOperation\");\n-\t\tthis.internalInterface = new WeakReference<>(internalInterface);\n-\t\tthis.fileManager = new WeakReference<>(fileManager);\n-\t\tthis.displayName = displayName;\n-\t\tthis.defaultMainWindowCapability = defaultMainWindowCapability;\n-\t\tthis.isVROptional = isVROptional;\n-\t\tthis.cellsToUpload = cellsToPreload;\n-\t\tthis.completionListener = listener;\n-\t}\n-\n-\t@Override\n-\tpublic void onExecute() {\n-\t\tDebugTool.logInfo(TAG, \"Choice Operation: Executing preload choices operation\");\n-\t\tpreloadCellArtworks(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tpreloadCells();\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\tvoid removeChoicesFromUpload(HashSet<ChoiceCell> choices){\n-\t\tif (isRunning){ return; }\n-\t\tcellsToUpload.removeAll(choices);\n-\t}\n-\n-\tprivate void preloadCellArtworks(@NonNull final CompletionListener listener){\n-\t\tisRunning = true;\n-\n-\t\tList<SdlArtwork> artworksToUpload = artworksToUpload();\n-\n-\t\tif (artworksToUpload.size() == 0){\n-\t\t\tDebugTool.logInfo(TAG, \"Choice Preload: No Choice Artworks to upload\");\n-\t\t\tlistener.onComplete(true);\n-\t\t\tisRunning = false;\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (fileManager.get() != null){\n-\t\t\tfileManager.get().uploadArtworks(artworksToUpload, new MultipleFileCompletionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onComplete(Map<String, String> errors) {\n-\t\t\t\t\tif (errors != null && errors.size() > 0){\n-\t\t\t\t\t\tDebugTool.logError(TAG, \"Error uploading choice cell Artworks: \"+ errors.toString());\n-\t\t\t\t\t\tlistener.onComplete(false);\n-\t\t\t\t\t\tisRunning = false;\n-\t\t\t\t\t}else{\n-\t\t\t\t\t\tDebugTool.logInfo(TAG, \"Choice Artworks Uploaded\");\n-\t\t\t\t\t\tlistener.onComplete(true);\n-\t\t\t\t\t\tisRunning = false;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}else{\n-\t\t\tDebugTool.logError(TAG, \"File manager is null in choice preload operation\");\n-\t\t\tlistener.onComplete(false);\n-\t\t\tisRunning = false;\n-\t\t}\n-\t}\n-\n-\tprivate void preloadCells(){\n-\t\tisRunning = true;\n-\t\tList<CreateInteractionChoiceSet> choiceRPCs = new ArrayList<>(cellsToUpload.size());\n-\t\tfor (ChoiceCell cell : cellsToUpload){\n-\t\t\tCreateInteractionChoiceSet csCell = choiceFromCell(cell);\n-\t\t\tif (csCell != null){\n-\t\t\t\tchoiceRPCs.add(csCell);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (choiceRPCs.size() == 0){\n-\t\t\tDebugTool.logError(TAG, \" All Choice cells to send are null, so the choice set will not be shown\");\n-\t\t\tcompletionListener.onComplete(true);\n-\t\t\tisRunning = false;\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (internalInterface.get() != null){\n-\t\t\tinternalInterface.get().sendRPCs(choiceRPCs, new OnMultipleRequestListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onUpdate(int remainingRequests) {\n-\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onFinished() {\n-\t\t\t\t\tisRunning = false;\n-\t\t\t\t\tDebugTool.logInfo(TAG, \"Finished pre loading choice cells\");\n-\t\t\t\t\tcompletionListener.onComplete(!choiceError);\n-\t\t\t\t\tchoiceError = false;\n-\t\t\t\t\tPreloadChoicesOperation.super.onFinished();\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\t\tif (!response.getSuccess()) {\n-\t\t\t\t\t\tDebugTool.logError(TAG, \"There was an error uploading a choice cell: \"+ response.getInfo() + \" resultCode: \" + response.getResultCode());\n-\t\t\t\t\t\tchoiceError = true;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}else{\n-\t\t\tDebugTool.logError(TAG, \"Internal Interface null in preload choice operation\");\n-\t\t\tisRunning = false;\n-\t\t\tcompletionListener.onComplete(false);\n-\t\t}\n-\t}\n-\n-\tprivate CreateInteractionChoiceSet choiceFromCell(ChoiceCell cell){\n-\n-\t\tList<String> vrCommands;\n-\t\tif (cell.getVoiceCommands() == null){\n-\t\t\tvrCommands = isVROptional ? null : Collections.singletonList(String.valueOf(cell.getChoiceId()));\n-\t\t}else{\n-\t\t\tvrCommands = cell.getVoiceCommands();\n-\t\t}\n-\n-\t\tString menuName = shouldSendChoiceText() ? cell.getText() : null;\n-\n-\t\tif (menuName == null){\n-\t\t\tDebugTool.logError(TAG, \"Could not convert Choice Cell to CreateInteractionChoiceSet. It will not be shown. Cell: \"+ cell.toString());\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tString secondaryText = shouldSendChoiceSecondaryText() ? cell.getSecondaryText() : null;\n-\t\tString tertiaryText = shouldSendChoiceTertiaryText() ? cell.getTertiaryText() : null;\n-\n-\t\tImage image = shouldSendChoicePrimaryImage() && cell.getArtwork() != null ? cell.getArtwork().getImageRPC() : null;\n-\t\tImage secondaryImage = shouldSendChoiceSecondaryImage() && cell.getSecondaryArtwork() != null ? cell.getSecondaryArtwork().getImageRPC() : null;\n-\n-\t\tChoice choice = new Choice(cell.getChoiceId(), menuName);\n-\t\tchoice.setVrCommands(vrCommands);\n-\t\tchoice.setSecondaryText(secondaryText);\n-\t\tchoice.setTertiaryText(tertiaryText);\n-\t\tchoice.setIgnoreAddingVRItems(true);\n-\n-\t\tif (fileManager.get() != null){\n-\t\t\tif (image != null && (cell.getArtwork().isStaticIcon() || fileManager.get().hasUploadedFile(cell.getArtwork()))) {\n-\t\t\t\tchoice.setImage(image);\n-\t\t\t}\n-\t\t\tif (secondaryImage != null && (cell.getSecondaryArtwork().isStaticIcon() || fileManager.get().hasUploadedFile(cell.getSecondaryArtwork()))) {\n-\t\t\t\tchoice.setSecondaryImage(secondaryImage);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn new CreateInteractionChoiceSet(choice.getChoiceID(), Collections.singletonList(choice));\n-\t}\n-\n-\t// HELPERS\n-\tboolean shouldSendChoiceText() {\n-\t\tif (this.displayName != null && this.displayName.equals(DisplayType.GEN3_8_INCH.toString())){\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn templateSupportsTextField(TextFieldName.menuName);\n-\t}\n-\n-\tboolean shouldSendChoiceSecondaryText() {\n-\t\treturn templateSupportsTextField(TextFieldName.secondaryText);\n-\t}\n-\n-\tboolean shouldSendChoiceTertiaryText() {\n-\t\treturn templateSupportsTextField(TextFieldName.tertiaryText);\n-\t}\n-\n-\tboolean shouldSendChoicePrimaryImage() {\n-\t\treturn templateSupportsImageField(ImageFieldName.choiceImage);\n-\t}\n-\n-\tboolean shouldSendChoiceSecondaryImage() {\n-\t\treturn templateSupportsImageField(ImageFieldName.choiceSecondaryImage);\n-\t}\n-\n-\tboolean templateSupportsTextField(TextFieldName name) {\n-\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasTextFieldOfName(defaultMainWindowCapability, name);\n-\t}\n-\n-\tboolean templateSupportsImageField(ImageFieldName name) {\n-\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, name);\n-\t}\n-\n-\tList<SdlArtwork> artworksToUpload(){\n-\t\tList<SdlArtwork> artworksToUpload = new ArrayList<>();\n-\t\tfor (ChoiceCell cell : cellsToUpload){\n-\t\t\tif (shouldSendChoicePrimaryImage() && artworkNeedsUpload(cell.getArtwork())){\n-\t\t\t\tartworksToUpload.add(cell.getArtwork());\n-\t\t\t}\n-\t\t\tif (shouldSendChoiceSecondaryImage() && artworkNeedsUpload(cell.getSecondaryArtwork())){\n-\t\t\t\tartworksToUpload.add(cell.getSecondaryArtwork());\n-\t\t\t}\n-\t\t}\n-\t\treturn artworksToUpload;\n-\t}\n-\n-\tboolean artworkNeedsUpload(SdlArtwork artwork){\n-\t\tif (fileManager.get() != null){\n-\t\t\treturn (artwork != null && !fileManager.get().hasUploadedFile(artwork) && !artwork.isStaticIcon());\n-\t\t}\n-\t\treturn false;\n-\t}\n+    private static final String TAG = \"PreloadChoicesOperation\";\n+    private final WeakReference<ISdl> internalInterface;\n+    private final WeakReference<FileManager> fileManager;\n+    private final WindowCapability defaultMainWindowCapability;\n+    private final String displayName;\n+    private final HashSet<ChoiceCell> cellsToUpload;\n+    private final CompletionListener completionListener;\n+    private boolean isRunning;\n+    private final boolean isVROptional;\n+    private boolean choiceError = false;\n+\n+    PreloadChoicesOperation(ISdl internalInterface, FileManager fileManager, String displayName, WindowCapability defaultMainWindowCapability,\n+                            Boolean isVROptional, HashSet<ChoiceCell> cellsToPreload, CompletionListener listener) {\n+        super(\"PreloadChoicesOperation\");\n+        this.internalInterface = new WeakReference<>(internalInterface);\n+        this.fileManager = new WeakReference<>(fileManager);\n+        this.displayName = displayName;\n+        this.defaultMainWindowCapability = defaultMainWindowCapability;\n+        this.isVROptional = isVROptional;\n+        this.cellsToUpload = cellsToPreload;\n+        this.completionListener = listener;\n+    }\n+\n+    @Override\n+    public void onExecute() {\n+        DebugTool.logInfo(TAG, \"Choice Operation: Executing preload choices operation\");\n+        preloadCellArtworks(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                preloadCells();\n+            }\n+        });\n+    }\n+\n+    void removeChoicesFromUpload(HashSet<ChoiceCell> choices) {\n+        if (isRunning) {\n+            return;\n+        }\n+        cellsToUpload.removeAll(choices);\n+    }\n+\n+    private void preloadCellArtworks(@NonNull final CompletionListener listener) {\n+        isRunning = true;\n+\n+        List<SdlArtwork> artworksToUpload = artworksToUpload();\n+\n+        if (artworksToUpload.size() == 0) {\n+            DebugTool.logInfo(TAG, \"Choice Preload: No Choice Artworks to upload\");\n+            listener.onComplete(true);\n+            isRunning = false;\n+            return;\n+        }\n+\n+        if (fileManager.get() != null) {\n+            fileManager.get().uploadArtworks(artworksToUpload, new MultipleFileCompletionListener() {\n+                @Override\n+                public void onComplete(Map<String, String> errors) {\n+                    if (errors != null && errors.size() > 0) {\n+                        DebugTool.logError(TAG, \"Error uploading choice cell Artworks: \" + errors.toString());\n+                        listener.onComplete(false);\n+                        isRunning = false;\n+                    } else {\n+                        DebugTool.logInfo(TAG, \"Choice Artworks Uploaded\");\n+                        listener.onComplete(true);\n+                        isRunning = false;\n+                    }\n+                }\n+            });\n+        } else {\n+            DebugTool.logError(TAG, \"File manager is null in choice preload operation\");\n+            listener.onComplete(false);\n+            isRunning = false;\n+        }\n+    }\n+\n+    private void preloadCells() {\n+        isRunning = true;\n+        List<CreateInteractionChoiceSet> choiceRPCs = new ArrayList<>(cellsToUpload.size());\n+        for (ChoiceCell cell : cellsToUpload) {\n+            CreateInteractionChoiceSet csCell = choiceFromCell(cell);\n+            if (csCell != null) {\n+                choiceRPCs.add(csCell);\n+            }\n+        }\n+\n+        if (choiceRPCs.size() == 0) {\n+            DebugTool.logError(TAG, \" All Choice cells to send are null, so the choice set will not be shown\");\n+            completionListener.onComplete(true);\n+            isRunning = false;\n+            return;\n+        }\n+\n+        if (internalInterface.get() != null) {\n+            internalInterface.get().sendRPCs(choiceRPCs, new OnMultipleRequestListener() {\n+                @Override\n+                public void onUpdate(int remainingRequests) {\n+\n+                }\n+\n+                @Override\n+                public void onFinished() {\n+                    isRunning = false;\n+                    DebugTool.logInfo(TAG, \"Finished pre loading choice cells\");\n+                    completionListener.onComplete(!choiceError);\n+                    choiceError = false;\n+                    PreloadChoicesOperation.super.onFinished();\n+                }\n+\n+                @Override\n+                public void onResponse(int correlationId, RPCResponse response) {\n+                    if (!response.getSuccess()) {\n+                        DebugTool.logError(TAG, \"There was an error uploading a choice cell: \" + response.getInfo() + \" resultCode: \" + response.getResultCode());\n+                        choiceError = true;\n+                    }\n+                }\n+            });\n+        } else {\n+            DebugTool.logError(TAG, \"Internal Interface null in preload choice operation\");\n+            isRunning = false;\n+            completionListener.onComplete(false);\n+        }\n+    }\n+\n+    private CreateInteractionChoiceSet choiceFromCell(ChoiceCell cell) {\n+\n+        List<String> vrCommands;\n+        if (cell.getVoiceCommands() == null) {\n+            vrCommands = isVROptional ? null : Collections.singletonList(String.valueOf(cell.getChoiceId()));\n+        } else {\n+            vrCommands = cell.getVoiceCommands();\n+        }\n+\n+        String menuName = shouldSendChoiceText() ? cell.getText() : null;\n+\n+        if (menuName == null) {\n+            DebugTool.logError(TAG, \"Could not convert Choice Cell to CreateInteractionChoiceSet. It will not be shown. Cell: \" + cell.toString());\n+            return null;\n+        }\n+\n+        String secondaryText = shouldSendChoiceSecondaryText() ? cell.getSecondaryText() : null;\n+        String tertiaryText = shouldSendChoiceTertiaryText() ? cell.getTertiaryText() : null;\n+\n+        Image image = shouldSendChoicePrimaryImage() && cell.getArtwork() != null ? cell.getArtwork().getImageRPC() : null;\n+        Image secondaryImage = shouldSendChoiceSecondaryImage() && cell.getSecondaryArtwork() != null ? cell.getSecondaryArtwork().getImageRPC() : null;\n+\n+        Choice choice = new Choice(cell.getChoiceId(), menuName);\n+        choice.setVrCommands(vrCommands);\n+        choice.setSecondaryText(secondaryText);\n+        choice.setTertiaryText(tertiaryText);\n+        choice.setIgnoreAddingVRItems(true);\n+\n+        if (fileManager.get() != null) {\n+            if (image != null && (cell.getArtwork().isStaticIcon() || fileManager.get().hasUploadedFile(cell.getArtwork()))) {\n+                choice.setImage(image);\n+            }\n+            if (secondaryImage != null && (cell.getSecondaryArtwork().isStaticIcon() || fileManager.get().hasUploadedFile(cell.getSecondaryArtwork()))) {\n+                choice.setSecondaryImage(secondaryImage);\n+            }\n+        }\n+\n+        return new CreateInteractionChoiceSet(choice.getChoiceID(), Collections.singletonList(choice));\n+    }\n+\n+    // HELPERS\n+    boolean shouldSendChoiceText() {\n+        if (this.displayName != null && this.displayName.equals(DisplayType.GEN3_8_INCH.toString())) {\n+            return true;\n+        }\n+        return templateSupportsTextField(TextFieldName.menuName);\n+    }\n+\n+    boolean shouldSendChoiceSecondaryText() {\n+        return templateSupportsTextField(TextFieldName.secondaryText);\n+    }\n+\n+    boolean shouldSendChoiceTertiaryText() {\n+        return templateSupportsTextField(TextFieldName.tertiaryText);\n+    }\n+\n+    boolean shouldSendChoicePrimaryImage() {\n+        return templateSupportsImageField(ImageFieldName.choiceImage);\n+    }\n+\n+    boolean shouldSendChoiceSecondaryImage() {\n+        return templateSupportsImageField(ImageFieldName.choiceSecondaryImage);\n+    }\n+\n+    boolean templateSupportsTextField(TextFieldName name) {\n+        return defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasTextFieldOfName(defaultMainWindowCapability, name);\n+    }\n+\n+    boolean templateSupportsImageField(ImageFieldName name) {\n+        return defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, name);\n+    }\n+\n+    List<SdlArtwork> artworksToUpload() {\n+        List<SdlArtwork> artworksToUpload = new ArrayList<>();\n+        for (ChoiceCell cell : cellsToUpload) {\n+            if (shouldSendChoicePrimaryImage() && artworkNeedsUpload(cell.getArtwork())) {\n+                artworksToUpload.add(cell.getArtwork());\n+            }\n+            if (shouldSendChoiceSecondaryImage() && artworkNeedsUpload(cell.getSecondaryArtwork())) {\n+                artworksToUpload.add(cell.getSecondaryArtwork());\n+            }\n+        }\n+        return artworksToUpload;\n+    }\n+\n+    boolean artworkNeedsUpload(SdlArtwork artwork) {\n+        if (fileManager.get() != null) {\n+            return (artwork != null && !fileManager.get().hasUploadedFile(artwork) && !artwork.isStaticIcon());\n+        }\n+        return false;\n+    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "951b808ae1c8a89a99bfb929536d5b18462e22fa", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\nindex 6bf0b7d25..a18aa4dba 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n", "chunk": "@@ -272,8 +272,12 @@ class PreloadChoicesOperation extends Task {\n     }\n \n     boolean artworkNeedsUpload(SdlArtwork artwork) {\n-        if (fileManager.get() != null) {\n-            return (artwork != null && !fileManager.get().hasUploadedFile(artwork) && !artwork.isStaticIcon());\n+        if (artwork != null) {\n+            if (artwork.isStaticIcon()) {\n+                return false;\n+            } else {\n+                return artwork.getOverwrite() || (fileManager.get() != null && !fileManager.get().hasUploadedFile(artwork));\n+            }\n         }\n         return false;\n     }\n", "next_change": {"commit": "fc57f10bcf888c2c25383d8d29e8b356f65bb2cc", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\nindex a18aa4dba..ea026b4cc 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n", "chunk": "@@ -272,12 +272,8 @@ class PreloadChoicesOperation extends Task {\n     }\n \n     boolean artworkNeedsUpload(SdlArtwork artwork) {\n-        if (artwork != null) {\n-            if (artwork.isStaticIcon()) {\n-                return false;\n-            } else {\n-                return artwork.getOverwrite() || (fileManager.get() != null && !fileManager.get().hasUploadedFile(artwork));\n-            }\n+        if (artwork != null && !artwork.isStaticIcon()) {\n+            return artwork.getOverwrite() || (fileManager.get() != null && !fileManager.get().hasUploadedFile(artwork));\n         }\n         return false;\n     }\n", "next_change": {"commit": "6b4ccaa08fa00900d6b8ce7bf2b0c3bf9df44a29", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\nindex ea026b4cc..d11720aec 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n", "chunk": "@@ -261,20 +261,13 @@ class PreloadChoicesOperation extends Task {\n     List<SdlArtwork> artworksToUpload() {\n         List<SdlArtwork> artworksToUpload = new ArrayList<>();\n         for (ChoiceCell cell : cellsToUpload) {\n-            if (shouldSendChoicePrimaryImage() && artworkNeedsUpload(cell.getArtwork())) {\n+            if (shouldSendChoicePrimaryImage() && fileManager.get() != null && fileManager.get().artworkNeedsUpload(cell.getArtwork())) {\n                 artworksToUpload.add(cell.getArtwork());\n             }\n-            if (shouldSendChoiceSecondaryImage() && artworkNeedsUpload(cell.getSecondaryArtwork())) {\n+            if (shouldSendChoiceSecondaryImage() && fileManager.get() != null && fileManager.get().artworkNeedsUpload(cell.getSecondaryArtwork())) {\n                 artworksToUpload.add(cell.getSecondaryArtwork());\n             }\n         }\n         return artworksToUpload;\n     }\n-\n-    boolean artworkNeedsUpload(SdlArtwork artwork) {\n-        if (artwork != null && !artwork.isStaticIcon()) {\n-            return artwork.getOverwrite() || (fileManager.get() != null && !fileManager.get().hasUploadedFile(artwork));\n-        }\n-        return false;\n-    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "ac7dde9b3378b1e33879738f482a70103c85d58c", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\nindex d11720aec..c857f0878 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n", "chunk": "@@ -261,10 +261,10 @@ class PreloadChoicesOperation extends Task {\n     List<SdlArtwork> artworksToUpload() {\n         List<SdlArtwork> artworksToUpload = new ArrayList<>();\n         for (ChoiceCell cell : cellsToUpload) {\n-            if (shouldSendChoicePrimaryImage() && fileManager.get() != null && fileManager.get().artworkNeedsUpload(cell.getArtwork())) {\n+            if (shouldSendChoicePrimaryImage() && fileManager.get() != null && fileManager.get().fileNeedsUpload(cell.getArtwork())) {\n                 artworksToUpload.add(cell.getArtwork());\n             }\n-            if (shouldSendChoiceSecondaryImage() && fileManager.get() != null && fileManager.get().artworkNeedsUpload(cell.getSecondaryArtwork())) {\n+            if (shouldSendChoiceSecondaryImage() && fileManager.get() != null && fileManager.get().fileNeedsUpload(cell.getSecondaryArtwork())) {\n                 artworksToUpload.add(cell.getSecondaryArtwork());\n             }\n         }\n", "next_change": {"commit": "f851102346739230d49ad1f52fa053f2cf5284a8", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\nindex c857f0878..64397a553 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n", "chunk": "@@ -270,4 +295,102 @@ class PreloadChoicesOperation extends Task {\n         }\n         return artworksToUpload;\n     }\n+\n+    void updateCellsBasedOnLoadedChoices() {\n+        if (internalInterface.get().getProtocolVersion().getMajor() >= 7 && internalInterface.get().getProtocolVersion().getMinor() >= 1) {\n+            addUniqueNamesToCells(cellsToUpload);\n+        } else {\n+            ArrayList<ChoiceCell> strippedCellsCopy = (ArrayList<ChoiceCell>) removeUnusedProperties(cellsToUpload);\n+            addUniqueNamesBasedOnStrippedCells(strippedCellsCopy, cellsToUpload);\n+        }\n+        cellsToUpload.removeAll(loadedCells);\n+    }\n+\n+    List<ChoiceCell> removeUnusedProperties(List<ChoiceCell> choiceCells) {\n+        List<ChoiceCell> strippedCellsClone = cloneChoiceCellList(choiceCells);\n+        //Clone Cells\n+        for (ChoiceCell cell : strippedCellsClone) {\n+            // Strip away fields that cannot be used to determine uniqueness visually including fields not supported by the HMI\n+            cell.setVoiceCommands(null);\n+\n+            if (!hasImageFieldOfName(ImageFieldName.choiceImage)) {\n+                cell.setArtwork(null);\n+            }\n+            if (!hasTextFieldOfName(TextFieldName.secondaryText)) {\n+                cell.setSecondaryText(null);\n+            }\n+            if (!hasTextFieldOfName(TextFieldName.tertiaryText)) {\n+                cell.setTertiaryText(null);\n+            }\n+            if (!hasImageFieldOfName(ImageFieldName.choiceSecondaryImage)) {\n+                cell.setSecondaryArtwork(null);\n+            }\n+        }\n+        return strippedCellsClone;\n+    }\n+\n+    private List<ChoiceCell> cloneChoiceCellList(List<ChoiceCell> originalList) {\n+        if (originalList == null) {\n+            return null;\n+        }\n+        List<ChoiceCell> clone = new ArrayList<>();\n+        for (ChoiceCell choiceCell : originalList) {\n+            clone.add(choiceCell.clone());\n+        }\n+        return clone;\n+    }\n+\n+    private boolean hasImageFieldOfName(ImageFieldName imageFieldName) {\n+        return defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, imageFieldName);\n+    }\n+\n+    private boolean hasTextFieldOfName(TextFieldName textFieldName) {\n+        return defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasTextFieldOfName(defaultMainWindowCapability, textFieldName);\n+    }\n+\n+    /**\n+     * Checks if 2 or more cells have the same text/title. In case this condition is true, this function will handle the presented issue by adding \"(count)\".\n+     * E.g. Choices param contains 2 cells with text/title \"Address\" will be handled by updating the uniqueText/uniqueTitle of the second cell to \"Address (2)\".\n+     * @param choices The list of choiceCells to be uploaded.\n+     */\n+    void addUniqueNamesToCells(List<ChoiceCell> choices) {\n+        HashMap<String, Integer> dictCounter = new HashMap<>();\n+\n+        for (ChoiceCell cell : choices) {\n+            String cellName = cell.getText();\n+            Integer counter = dictCounter.get(cellName);\n+\n+            if (counter != null) {\n+                dictCounter.put(cellName, ++counter);\n+                cell.setUniqueText(cell.getText() + \" (\" + counter + \")\");\n+            } else {\n+                dictCounter.put(cellName, 1);\n+            }\n+        }\n+    }\n+\n+    void addUniqueNamesBasedOnStrippedCells(List<ChoiceCell> strippedCells, List<ChoiceCell> unstrippedCells) {\n+        if (strippedCells == null || unstrippedCells == null || strippedCells.size() != unstrippedCells.size()) {\n+            return;\n+        }\n+        // Tracks how many of each cell primary text there are so that we can append numbers to make each unique as necessary\n+        HashMap<ChoiceCell, Integer> dictCounter = new HashMap<>();\n+        for (int i = 0; i < strippedCells.size(); i++) {\n+            ChoiceCell cell = strippedCells.get(i);\n+            Integer counter = dictCounter.get(cell);\n+            if (counter != null) {\n+                counter++;\n+                dictCounter.put(cell, counter);\n+            } else {\n+                dictCounter.put(cell, 1);\n+            }\n+\n+            counter = dictCounter.get(cell);\n+\n+            if (counter > 1) {\n+                unstrippedCells.get(i).setUniqueText(unstrippedCells.get(i).getText() + \" (\" + counter + \")\");\n+            }\n+        }\n+    }\n+\n }\n\\ No newline at end of file\n", "next_change": {"commit": "a140e49566eace9e247003edbe285c3ddd045eda", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\nindex 64397a553..d98ae3517 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n", "chunk": "@@ -295,102 +283,4 @@ class PreloadChoicesOperation extends Task {\n         }\n         return artworksToUpload;\n     }\n-\n-    void updateCellsBasedOnLoadedChoices() {\n-        if (internalInterface.get().getProtocolVersion().getMajor() >= 7 && internalInterface.get().getProtocolVersion().getMinor() >= 1) {\n-            addUniqueNamesToCells(cellsToUpload);\n-        } else {\n-            ArrayList<ChoiceCell> strippedCellsCopy = (ArrayList<ChoiceCell>) removeUnusedProperties(cellsToUpload);\n-            addUniqueNamesBasedOnStrippedCells(strippedCellsCopy, cellsToUpload);\n-        }\n-        cellsToUpload.removeAll(loadedCells);\n-    }\n-\n-    List<ChoiceCell> removeUnusedProperties(List<ChoiceCell> choiceCells) {\n-        List<ChoiceCell> strippedCellsClone = cloneChoiceCellList(choiceCells);\n-        //Clone Cells\n-        for (ChoiceCell cell : strippedCellsClone) {\n-            // Strip away fields that cannot be used to determine uniqueness visually including fields not supported by the HMI\n-            cell.setVoiceCommands(null);\n-\n-            if (!hasImageFieldOfName(ImageFieldName.choiceImage)) {\n-                cell.setArtwork(null);\n-            }\n-            if (!hasTextFieldOfName(TextFieldName.secondaryText)) {\n-                cell.setSecondaryText(null);\n-            }\n-            if (!hasTextFieldOfName(TextFieldName.tertiaryText)) {\n-                cell.setTertiaryText(null);\n-            }\n-            if (!hasImageFieldOfName(ImageFieldName.choiceSecondaryImage)) {\n-                cell.setSecondaryArtwork(null);\n-            }\n-        }\n-        return strippedCellsClone;\n-    }\n-\n-    private List<ChoiceCell> cloneChoiceCellList(List<ChoiceCell> originalList) {\n-        if (originalList == null) {\n-            return null;\n-        }\n-        List<ChoiceCell> clone = new ArrayList<>();\n-        for (ChoiceCell choiceCell : originalList) {\n-            clone.add(choiceCell.clone());\n-        }\n-        return clone;\n-    }\n-\n-    private boolean hasImageFieldOfName(ImageFieldName imageFieldName) {\n-        return defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, imageFieldName);\n-    }\n-\n-    private boolean hasTextFieldOfName(TextFieldName textFieldName) {\n-        return defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasTextFieldOfName(defaultMainWindowCapability, textFieldName);\n-    }\n-\n-    /**\n-     * Checks if 2 or more cells have the same text/title. In case this condition is true, this function will handle the presented issue by adding \"(count)\".\n-     * E.g. Choices param contains 2 cells with text/title \"Address\" will be handled by updating the uniqueText/uniqueTitle of the second cell to \"Address (2)\".\n-     * @param choices The list of choiceCells to be uploaded.\n-     */\n-    void addUniqueNamesToCells(List<ChoiceCell> choices) {\n-        HashMap<String, Integer> dictCounter = new HashMap<>();\n-\n-        for (ChoiceCell cell : choices) {\n-            String cellName = cell.getText();\n-            Integer counter = dictCounter.get(cellName);\n-\n-            if (counter != null) {\n-                dictCounter.put(cellName, ++counter);\n-                cell.setUniqueText(cell.getText() + \" (\" + counter + \")\");\n-            } else {\n-                dictCounter.put(cellName, 1);\n-            }\n-        }\n-    }\n-\n-    void addUniqueNamesBasedOnStrippedCells(List<ChoiceCell> strippedCells, List<ChoiceCell> unstrippedCells) {\n-        if (strippedCells == null || unstrippedCells == null || strippedCells.size() != unstrippedCells.size()) {\n-            return;\n-        }\n-        // Tracks how many of each cell primary text there are so that we can append numbers to make each unique as necessary\n-        HashMap<ChoiceCell, Integer> dictCounter = new HashMap<>();\n-        for (int i = 0; i < strippedCells.size(); i++) {\n-            ChoiceCell cell = strippedCells.get(i);\n-            Integer counter = dictCounter.get(cell);\n-            if (counter != null) {\n-                counter++;\n-                dictCounter.put(cell, counter);\n-            } else {\n-                dictCounter.put(cell, 1);\n-            }\n-\n-            counter = dictCounter.get(cell);\n-\n-            if (counter > 1) {\n-                unstrippedCells.get(i).setUniqueText(unstrippedCells.get(i).getText() + \" (\" + counter + \")\");\n-            }\n-        }\n-    }\n-\n }\n\\ No newline at end of file\n", "next_change": {"commit": "59979d3e1f8ae5258a8d8307c209131094aea9e9", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\nindex d98ae3517..c7a42c15a 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n", "chunk": "@@ -283,4 +297,102 @@ class PreloadChoicesOperation extends Task {\n         }\n         return artworksToUpload;\n     }\n+\n+    void updateCellsBasedOnLoadedChoices() {\n+        if (internalInterface.get().getProtocolVersion().getMajor() >= 7 && internalInterface.get().getProtocolVersion().getMinor() >= 1) {\n+            addUniqueNamesToCells(cellsToUpload);\n+        } else {\n+            ArrayList<ChoiceCell> strippedCellsCopy = (ArrayList<ChoiceCell>) removeUnusedProperties(cellsToUpload);\n+            addUniqueNamesBasedOnStrippedCells(strippedCellsCopy, cellsToUpload);\n+        }\n+        cellsToUpload.removeAll(loadedCells);\n+    }\n+\n+    List<ChoiceCell> removeUnusedProperties(List<ChoiceCell> choiceCells) {\n+        List<ChoiceCell> strippedCellsClone = cloneChoiceCellList(choiceCells);\n+        //Clone Cells\n+        for (ChoiceCell cell : strippedCellsClone) {\n+            // Strip away fields that cannot be used to determine uniqueness visually including fields not supported by the HMI\n+            cell.setVoiceCommands(null);\n+\n+            if (!hasImageFieldOfName(ImageFieldName.choiceImage)) {\n+                cell.setArtwork(null);\n+            }\n+            if (!hasTextFieldOfName(TextFieldName.secondaryText)) {\n+                cell.setSecondaryText(null);\n+            }\n+            if (!hasTextFieldOfName(TextFieldName.tertiaryText)) {\n+                cell.setTertiaryText(null);\n+            }\n+            if (!hasImageFieldOfName(ImageFieldName.choiceSecondaryImage)) {\n+                cell.setSecondaryArtwork(null);\n+            }\n+        }\n+        return strippedCellsClone;\n+    }\n+\n+    private List<ChoiceCell> cloneChoiceCellList(List<ChoiceCell> originalList) {\n+        if (originalList == null) {\n+            return null;\n+        }\n+        List<ChoiceCell> clone = new ArrayList<>();\n+        for (ChoiceCell choiceCell : originalList) {\n+            clone.add(choiceCell.clone());\n+        }\n+        return clone;\n+    }\n+\n+    private boolean hasImageFieldOfName(ImageFieldName imageFieldName) {\n+        return defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, imageFieldName);\n+    }\n+\n+    private boolean hasTextFieldOfName(TextFieldName textFieldName) {\n+        return defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasTextFieldOfName(defaultMainWindowCapability, textFieldName);\n+    }\n+\n+    /**\n+     * Checks if 2 or more cells have the same text/title. In case this condition is true, this function will handle the presented issue by adding \"(count)\".\n+     * E.g. Choices param contains 2 cells with text/title \"Address\" will be handled by updating the uniqueText/uniqueTitle of the second cell to \"Address (2)\".\n+     * @param choices The list of choiceCells to be uploaded.\n+     */\n+    void addUniqueNamesToCells(List<ChoiceCell> choices) {\n+        HashMap<String, Integer> dictCounter = new HashMap<>();\n+\n+        for (ChoiceCell cell : choices) {\n+            String cellName = cell.getText();\n+            Integer counter = dictCounter.get(cellName);\n+\n+            if (counter != null) {\n+                dictCounter.put(cellName, ++counter);\n+                cell.setUniqueText(cell.getText() + \" (\" + counter + \")\");\n+            } else {\n+                dictCounter.put(cellName, 1);\n+            }\n+        }\n+    }\n+\n+    void addUniqueNamesBasedOnStrippedCells(List<ChoiceCell> strippedCells, List<ChoiceCell> unstrippedCells) {\n+        if (strippedCells == null || unstrippedCells == null || strippedCells.size() != unstrippedCells.size()) {\n+            return;\n+        }\n+        // Tracks how many of each cell primary text there are so that we can append numbers to make each unique as necessary\n+        HashMap<ChoiceCell, Integer> dictCounter = new HashMap<>();\n+        for (int i = 0; i < strippedCells.size(); i++) {\n+            ChoiceCell cell = strippedCells.get(i);\n+            Integer counter = dictCounter.get(cell);\n+            if (counter != null) {\n+                counter++;\n+                dictCounter.put(cell, counter);\n+            } else {\n+                dictCounter.put(cell, 1);\n+            }\n+\n+            counter = dictCounter.get(cell);\n+\n+            if (counter > 1) {\n+                unstrippedCells.get(i).setUniqueText(unstrippedCells.get(i).getText() + \" (\" + counter + \")\");\n+            }\n+        }\n+    }\n+\n }\n\\ No newline at end of file\n", "next_change": {"commit": "08ec2f076ac47c106b5ca0759e74a9244f5f5e6a", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java b/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\ndeleted file mode 100644\nindex c7a42c15a..000000000\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/choiceset/PreloadChoicesOperation.java\n+++ /dev/null\n", "chunk": "@@ -1,398 +0,0 @@\n-/*\n- * Copyright (c)  2019 Livio, Inc.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- * Redistributions of source code must retain the above copyright notice, this\n- * list of conditions and the following disclaimer.\n- *\n- * Redistributions in binary form must reproduce the above copyright notice,\n- * this list of conditions and the following\n- * disclaimer in the documentation and/or other materials provided with the\n- * distribution.\n- *\n- * Neither the name of the Livio Inc. nor the names of its contributors\n- * may be used to endorse or promote products derived from this software\n- * without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- *\n- * Created by brettywhite on 6/12/19 1:52 PM\n- *\n- */\n-\n-package com.smartdevicelink.managers.screen.choiceset;\n-\n-import androidx.annotation.NonNull;\n-\n-import com.livio.taskmaster.Task;\n-import com.smartdevicelink.managers.CompletionListener;\n-import com.smartdevicelink.managers.ISdl;\n-import com.smartdevicelink.managers.ManagerUtility;\n-import com.smartdevicelink.managers.file.FileManager;\n-import com.smartdevicelink.managers.file.MultipleFileCompletionListener;\n-import com.smartdevicelink.managers.file.filetypes.SdlArtwork;\n-import com.smartdevicelink.proxy.RPCResponse;\n-import com.smartdevicelink.proxy.rpc.Choice;\n-import com.smartdevicelink.proxy.rpc.CreateInteractionChoiceSet;\n-import com.smartdevicelink.proxy.rpc.Image;\n-import com.smartdevicelink.proxy.rpc.WindowCapability;\n-import com.smartdevicelink.proxy.rpc.enums.DisplayType;\n-import com.smartdevicelink.proxy.rpc.enums.ImageFieldName;\n-import com.smartdevicelink.proxy.rpc.enums.TextFieldName;\n-import com.smartdevicelink.proxy.rpc.listeners.OnMultipleRequestListener;\n-import com.smartdevicelink.util.DebugTool;\n-import com.smartdevicelink.util.Version;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-\n-class PreloadChoicesOperation extends Task {\n-    private static final String TAG = \"PreloadChoicesOperation\";\n-    private final WeakReference<ISdl> internalInterface;\n-    private final WeakReference<FileManager> fileManager;\n-    private final WindowCapability defaultMainWindowCapability;\n-    private final String displayName;\n-    private final ArrayList<ChoiceCell> cellsToUpload;\n-    private final PreloadChoicesCompletionListener completionListener;\n-    private boolean isRunning;\n-    private final boolean isVROptional;\n-    private boolean choiceError = false;\n-    private HashSet<ChoiceCell> loadedCells;\n-\n-    PreloadChoicesOperation(ISdl internalInterface, FileManager fileManager, String displayName, WindowCapability defaultMainWindowCapability,\n-                            Boolean isVROptional, LinkedHashSet<ChoiceCell> cellsToPreload, PreloadChoicesCompletionListener listener, HashSet<ChoiceCell> loadedCells) {\n-        super(\"PreloadChoicesOperation\");\n-        this.internalInterface = new WeakReference<>(internalInterface);\n-        this.fileManager = new WeakReference<>(fileManager);\n-        this.displayName = displayName;\n-        this.defaultMainWindowCapability = defaultMainWindowCapability;\n-        this.isVROptional = isVROptional;\n-        this.cellsToUpload = new ArrayList<>(cellsToPreload);\n-        this.completionListener = listener;\n-        this.loadedCells = loadedCells;\n-    }\n-\n-    @Override\n-    public void onExecute() {\n-        DebugTool.logInfo(TAG, \"Choice Operation: Executing preload choices operation\");\n-        updateCellsBasedOnLoadedChoices();\n-        preloadCellArtworks(new CompletionListener() {\n-            @Override\n-            public void onComplete(boolean success) {\n-                preloadCells();\n-            }\n-        });\n-    }\n-\n-    void removeChoicesFromUpload(HashSet<ChoiceCell> choices) {\n-        if (isRunning) {\n-            return;\n-        }\n-        cellsToUpload.removeAll(choices);\n-    }\n-\n-    private void preloadCellArtworks(@NonNull final CompletionListener listener) {\n-        isRunning = true;\n-\n-        List<SdlArtwork> artworksToUpload = artworksToUpload();\n-\n-        if (artworksToUpload.size() == 0) {\n-            DebugTool.logInfo(TAG, \"Choice Preload: No Choice Artworks to upload\");\n-            listener.onComplete(true);\n-            isRunning = false;\n-            return;\n-        }\n-\n-        if (fileManager.get() != null) {\n-            fileManager.get().uploadArtworks(artworksToUpload, new MultipleFileCompletionListener() {\n-                @Override\n-                public void onComplete(Map<String, String> errors) {\n-                    if (errors != null && errors.size() > 0) {\n-                        DebugTool.logError(TAG, \"Error uploading choice cell Artworks: \" + errors.toString());\n-                        listener.onComplete(false);\n-                        isRunning = false;\n-                    } else {\n-                        DebugTool.logInfo(TAG, \"Choice Artworks Uploaded\");\n-                        listener.onComplete(true);\n-                        isRunning = false;\n-                    }\n-                }\n-            });\n-        } else {\n-            DebugTool.logError(TAG, \"File manager is null in choice preload operation\");\n-            listener.onComplete(false);\n-            isRunning = false;\n-        }\n-    }\n-\n-    private void preloadCells() {\n-        isRunning = true;\n-        List<CreateInteractionChoiceSet> choiceRPCs = new ArrayList<>(cellsToUpload.size());\n-        for (ChoiceCell cell : cellsToUpload) {\n-            CreateInteractionChoiceSet csCell = choiceFromCell(cell);\n-            if (csCell != null) {\n-                choiceRPCs.add(csCell);\n-            }\n-        }\n-\n-        if (choiceRPCs.size() == 0) {\n-            DebugTool.logError(TAG, \" All Choice cells to send are null, so the choice set will not be shown\");\n-            completionListener.onComplete(true, loadedCells);\n-            isRunning = false;\n-            return;\n-        }\n-\n-        if (internalInterface.get() != null) {\n-            internalInterface.get().sendRPCs(choiceRPCs, new OnMultipleRequestListener() {\n-                final HashSet<ChoiceCell> failedChoiceCells = new HashSet<>();\n-\n-                @Override\n-                public void onUpdate(int remainingRequests) {\n-\n-                }\n-\n-                @Override\n-                public void onFinished() {\n-                    isRunning = false;\n-                    DebugTool.logInfo(TAG, \"Finished pre loading choice cells\");\n-                    completionListener.onComplete(!choiceError, loadedCells);\n-                    choiceError = false;\n-                    PreloadChoicesOperation.super.onFinished();\n-                }\n-\n-                @Override\n-                public void onResponse(int correlationId, RPCResponse response) {\n-                    if (!response.getSuccess()) {\n-                        DebugTool.logError(TAG, \"There was an error uploading a choice cell: \" + response.getInfo() + \" resultCode: \" + response.getResultCode());\n-                        choiceError = true;\n-                    } else {\n-                        loadedCells.add(cellFromChoiceId(correlationId));\n-                    }\n-                }\n-            });\n-        } else {\n-            DebugTool.logError(TAG, \"Internal Interface null in preload choice operation\");\n-            isRunning = false;\n-            completionListener.onComplete(false, loadedCells);\n-        }\n-    }\n-\n-    private ChoiceCell cellFromChoiceId(int choiceId) {\n-        for (ChoiceCell cell : this.cellsToUpload) {\n-            if (cell.getChoiceId() == choiceId) {\n-                return cell;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private CreateInteractionChoiceSet choiceFromCell(ChoiceCell cell) {\n-\n-        List<String> vrCommands;\n-        if (cell.getVoiceCommands() == null) {\n-            vrCommands = isVROptional ? null : Collections.singletonList(String.valueOf(cell.getChoiceId()));\n-        } else {\n-            vrCommands = cell.getVoiceCommands();\n-        }\n-\n-        String menuName = shouldSendChoiceText() ? cell.getUniqueText() : null;\n-\n-        if (menuName == null) {\n-            DebugTool.logError(TAG, \"Could not convert Choice Cell to CreateInteractionChoiceSet. It will not be shown. Cell: \" + cell.toString());\n-            return null;\n-        }\n-\n-        String secondaryText = shouldSendChoiceSecondaryText() ? cell.getSecondaryText() : null;\n-        String tertiaryText = shouldSendChoiceTertiaryText() ? cell.getTertiaryText() : null;\n-\n-        Image image = shouldSendChoicePrimaryImage() && cell.getArtwork() != null ? cell.getArtwork().getImageRPC() : null;\n-        Image secondaryImage = shouldSendChoiceSecondaryImage() && cell.getSecondaryArtwork() != null ? cell.getSecondaryArtwork().getImageRPC() : null;\n-\n-        Choice choice = new Choice(cell.getChoiceId(), menuName);\n-        choice.setVrCommands(vrCommands);\n-        choice.setSecondaryText(secondaryText);\n-        choice.setTertiaryText(tertiaryText);\n-        choice.setIgnoreAddingVRItems(true);\n-\n-        if (fileManager.get() != null) {\n-            if (image != null && (cell.getArtwork().isStaticIcon() || fileManager.get().hasUploadedFile(cell.getArtwork()))) {\n-                choice.setImage(image);\n-            }\n-            if (secondaryImage != null && (cell.getSecondaryArtwork().isStaticIcon() || fileManager.get().hasUploadedFile(cell.getSecondaryArtwork()))) {\n-                choice.setSecondaryImage(secondaryImage);\n-            }\n-        }\n-\n-        return new CreateInteractionChoiceSet(choice.getChoiceID(), Collections.singletonList(choice));\n-    }\n-\n-    // HELPERS\n-    boolean shouldSendChoiceText() {\n-        if (this.displayName != null && this.displayName.equals(DisplayType.GEN3_8_INCH.toString())) {\n-            return true;\n-        }\n-        return templateSupportsTextField(TextFieldName.menuName);\n-    }\n-\n-    boolean shouldSendChoiceSecondaryText() {\n-        return templateSupportsTextField(TextFieldName.secondaryText);\n-    }\n-\n-    boolean shouldSendChoiceTertiaryText() {\n-        return templateSupportsTextField(TextFieldName.tertiaryText);\n-    }\n-\n-    boolean shouldSendChoicePrimaryImage() {\n-        return templateSupportsImageField(ImageFieldName.choiceImage);\n-    }\n-\n-    boolean shouldSendChoiceSecondaryImage() {\n-        return templateSupportsImageField(ImageFieldName.choiceSecondaryImage);\n-    }\n-\n-    boolean templateSupportsTextField(TextFieldName name) {\n-        return defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasTextFieldOfName(defaultMainWindowCapability, name);\n-    }\n-\n-    boolean templateSupportsImageField(ImageFieldName name) {\n-        return defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, name);\n-    }\n-\n-    public void setLoadedCells(HashSet<ChoiceCell> loadedCells) {\n-        this.loadedCells = loadedCells;\n-    }\n-\n-    public HashSet<ChoiceCell> getLoadedCells() {\n-        return this.loadedCells;\n-    }\n-\n-    List<SdlArtwork> artworksToUpload() {\n-        List<SdlArtwork> artworksToUpload = new ArrayList<>();\n-        for (ChoiceCell cell : cellsToUpload) {\n-            if (shouldSendChoicePrimaryImage() && fileManager.get() != null && fileManager.get().fileNeedsUpload(cell.getArtwork())) {\n-                artworksToUpload.add(cell.getArtwork());\n-            }\n-            if (shouldSendChoiceSecondaryImage() && fileManager.get() != null && fileManager.get().fileNeedsUpload(cell.getSecondaryArtwork())) {\n-                artworksToUpload.add(cell.getSecondaryArtwork());\n-            }\n-        }\n-        return artworksToUpload;\n-    }\n-\n-    void updateCellsBasedOnLoadedChoices() {\n-        if (internalInterface.get().getProtocolVersion().getMajor() >= 7 && internalInterface.get().getProtocolVersion().getMinor() >= 1) {\n-            addUniqueNamesToCells(cellsToUpload);\n-        } else {\n-            ArrayList<ChoiceCell> strippedCellsCopy = (ArrayList<ChoiceCell>) removeUnusedProperties(cellsToUpload);\n-            addUniqueNamesBasedOnStrippedCells(strippedCellsCopy, cellsToUpload);\n-        }\n-        cellsToUpload.removeAll(loadedCells);\n-    }\n-\n-    List<ChoiceCell> removeUnusedProperties(List<ChoiceCell> choiceCells) {\n-        List<ChoiceCell> strippedCellsClone = cloneChoiceCellList(choiceCells);\n-        //Clone Cells\n-        for (ChoiceCell cell : strippedCellsClone) {\n-            // Strip away fields that cannot be used to determine uniqueness visually including fields not supported by the HMI\n-            cell.setVoiceCommands(null);\n-\n-            if (!hasImageFieldOfName(ImageFieldName.choiceImage)) {\n-                cell.setArtwork(null);\n-            }\n-            if (!hasTextFieldOfName(TextFieldName.secondaryText)) {\n-                cell.setSecondaryText(null);\n-            }\n-            if (!hasTextFieldOfName(TextFieldName.tertiaryText)) {\n-                cell.setTertiaryText(null);\n-            }\n-            if (!hasImageFieldOfName(ImageFieldName.choiceSecondaryImage)) {\n-                cell.setSecondaryArtwork(null);\n-            }\n-        }\n-        return strippedCellsClone;\n-    }\n-\n-    private List<ChoiceCell> cloneChoiceCellList(List<ChoiceCell> originalList) {\n-        if (originalList == null) {\n-            return null;\n-        }\n-        List<ChoiceCell> clone = new ArrayList<>();\n-        for (ChoiceCell choiceCell : originalList) {\n-            clone.add(choiceCell.clone());\n-        }\n-        return clone;\n-    }\n-\n-    private boolean hasImageFieldOfName(ImageFieldName imageFieldName) {\n-        return defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, imageFieldName);\n-    }\n-\n-    private boolean hasTextFieldOfName(TextFieldName textFieldName) {\n-        return defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasTextFieldOfName(defaultMainWindowCapability, textFieldName);\n-    }\n-\n-    /**\n-     * Checks if 2 or more cells have the same text/title. In case this condition is true, this function will handle the presented issue by adding \"(count)\".\n-     * E.g. Choices param contains 2 cells with text/title \"Address\" will be handled by updating the uniqueText/uniqueTitle of the second cell to \"Address (2)\".\n-     * @param choices The list of choiceCells to be uploaded.\n-     */\n-    void addUniqueNamesToCells(List<ChoiceCell> choices) {\n-        HashMap<String, Integer> dictCounter = new HashMap<>();\n-\n-        for (ChoiceCell cell : choices) {\n-            String cellName = cell.getText();\n-            Integer counter = dictCounter.get(cellName);\n-\n-            if (counter != null) {\n-                dictCounter.put(cellName, ++counter);\n-                cell.setUniqueText(cell.getText() + \" (\" + counter + \")\");\n-            } else {\n-                dictCounter.put(cellName, 1);\n-            }\n-        }\n-    }\n-\n-    void addUniqueNamesBasedOnStrippedCells(List<ChoiceCell> strippedCells, List<ChoiceCell> unstrippedCells) {\n-        if (strippedCells == null || unstrippedCells == null || strippedCells.size() != unstrippedCells.size()) {\n-            return;\n-        }\n-        // Tracks how many of each cell primary text there are so that we can append numbers to make each unique as necessary\n-        HashMap<ChoiceCell, Integer> dictCounter = new HashMap<>();\n-        for (int i = 0; i < strippedCells.size(); i++) {\n-            ChoiceCell cell = strippedCells.get(i);\n-            Integer counter = dictCounter.get(cell);\n-            if (counter != null) {\n-                counter++;\n-                dictCounter.put(cell, counter);\n-            } else {\n-                dictCounter.put(cell, 1);\n-            }\n-\n-            counter = dictCounter.get(cell);\n-\n-            if (counter > 1) {\n-                unstrippedCells.get(i).setUniqueText(unstrippedCells.get(i).getText() + \" (\" + counter + \")\");\n-            }\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "message": "Merge commit", "committedDate": null}, {"oid": "763753da5436d9e296cda95e50a5c7ac3740079c", "committedDate": "2020-05-20 15:56:21 -0400", "message": "Update null checks for the Base Managers"}, {"oid": "1b15fb34eceec0b7715477c23f9073824638719c", "committedDate": "2020-06-12 11:17:21 -0400", "message": "Update ChoiceSetManager to use Taskmaster"}, {"oid": "9d2b2b13cbc4e0d9892fd41b5a25a9e8e49f74e1", "committedDate": "2020-06-15 15:56:55 -0400", "message": "Remove calling run() in onExecute()"}, {"oid": "df7badc06dfdeb3b9cccb7496d1a27471874e877", "committedDate": "2020-06-26 15:03:18 -0400", "message": "Use new logInfo API instead of Deprecated API"}, {"oid": "05d262701ff3495da7470a925bf67a91b57ad163", "committedDate": "2020-06-26 16:40:13 -0400", "message": "Move logError to new DebugTool APIs in android/base"}, {"oid": "59f11f6779fba28befe435ee640f31fa2a2dc7e9", "committedDate": "2020-06-30 08:58:34 -0400", "message": "Add Tags to classes using null for TAG"}, {"oid": "ec008966d86894eab40b43b70d7751d25de46caa", "committedDate": "2020-07-07 09:17:31 -0400", "message": "Fixed logic In PreloadChoicesOperation"}, {"oid": "3e9f90212e713f85369e6a11f1d15abf3b966bdf", "committedDate": "2020-08-10 19:35:10 -0400", "message": "Update imports to androidX"}, {"oid": "db1988f63c0eb01512df34dcdfc641ea6c75f82f", "committedDate": "2020-08-18 15:21:08 -0400", "message": "Remove onError from ChoiceSetManager"}, {"oid": "7d27d47885cc983ba9c9f49df4ff329654dea0de", "committedDate": "2020-08-21 13:08:18 -0400", "message": "Remove unsed imports"}, {"oid": "9e77ff43b1450f656e8ae6405a8da6bb435e5127", "committedDate": "2020-09-08 15:25:03 -0400", "message": "Remove Deprecated Isdl methods (#1485)"}, {"oid": "ad99dd774d1726a2b5f0901cf82b8ed62fb027e4", "committedDate": "2020-09-09 17:14:52 -0400", "message": "Fix warnings in managers part 1"}, {"oid": "fd96983377fad92eefa3818fd24c58aee0b6180c", "committedDate": "2020-09-10 10:28:14 -0400", "message": "Fix warnings in managers part 2"}, {"oid": "cd4ac27321c641ef4a9c9f6628059735364ef4dd", "committedDate": "2020-09-15 14:02:09 -0400", "message": "Move proxy interfaces to better packages"}, {"oid": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "committedDate": "2020-09-17 16:31:17 -0400", "message": "Run the Reformat Code tool on the project"}, {"oid": "951b808ae1c8a89a99bfb929536d5b18462e22fa", "committedDate": "2020-11-10 13:08:55 -0500", "message": "Fix overwrite issue in ChoiceSetManager"}, {"oid": "fc57f10bcf888c2c25383d8d29e8b356f65bb2cc", "committedDate": "2020-11-30 12:01:06 -0500", "message": "Update private method names to align more with iOS"}, {"oid": "6b4ccaa08fa00900d6b8ce7bf2b0c3bf9df44a29", "committedDate": "2020-11-30 14:24:48 -0500", "message": "Add artworkNeedsUpload() to FileManager"}, {"oid": "ac7dde9b3378b1e33879738f482a70103c85d58c", "committedDate": "2020-11-30 14:55:56 -0500", "message": "Update fileNeedsUpload() to accept SdlFile"}, {"oid": "a70d82d4219a80412fb092cbb4989a722083338b", "committedDate": "2021-03-04 10:09:56 -0500", "message": "Feature/issue 811 broaden choiceset uniqueness (#1599)"}, {"oid": "b4365f08f8118ec62f9fd88dd58f3ce3b7b0af6f", "committedDate": "2021-07-16 15:43:29 -0400", "message": "Updates to ChoiceSet Manager and Operations"}, {"oid": "f851102346739230d49ad1f52fa053f2cf5284a8", "committedDate": "2021-07-19 09:21:14 -0400", "message": "Add uniqueness updated to preloadChoicesOp"}, {"oid": "a140e49566eace9e247003edbe285c3ddd045eda", "committedDate": "2021-07-20 13:07:25 -0400", "message": "Notify ChoiceSetManager of failed preloads (#1716)"}, {"oid": "59979d3e1f8ae5258a8d8307c209131094aea9e9", "committedDate": "2021-07-22 09:14:11 -0400", "message": "Merge develop and create combined operation"}, {"oid": "08ec2f076ac47c106b5ca0759e74a9244f5f5e6a", "committedDate": "2021-07-22 16:17:21 -0400", "message": "update tests and remove old operations"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5OTMwOQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1328#discussion_r406299309", "body": "Same question before around if the `imageField` array is null. @joeljfischer for visibility. ", "bodyText": "Same question before around if the imageField array is null. @joeljfischer for visibility.", "bodyHTML": "<p dir=\"auto\">Same question before around if the <code>imageField</code> array is null. <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/joeljfischer/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/joeljfischer\">@joeljfischer</a> for visibility.</p>", "author": "joeygrover", "createdAt": "2020-04-09T15:44:20Z", "path": "base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java", "diffHunk": "@@ -780,17 +780,7 @@ private void setAddStatus(Integer size, List<Integer> newArray){\n \n \t@SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n \tprivate boolean supportsImages(){\n-\t\tif (defaultMainWindowCapability != null && defaultMainWindowCapability.getImageFields() != null) {\n-\t\t\tList<ImageField> imageFields = defaultMainWindowCapability.getImageFields();\n-\t\t\tif (imageFields != null && !imageFields.isEmpty()) {\n-\t\t\t\tfor (ImageField field : imageFields) {\n-\t\t\t\t\tif (field != null && field.getName() != null && field.getName().equals(ImageFieldName.cmdIcon)) {\n-\t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n+\t\treturn (defaultMainWindowCapability == null || defaultMainWindowCapability.getImageFields() == null) || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, ImageFieldName.cmdIcon);", "originalCommit": "40ed2d11522da4529c645b5df05df0fedd8769e1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "763753da5436d9e296cda95e50a5c7ac3740079c", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\nindex 00abba550..48ed19b40 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n", "chunk": "@@ -780,7 +780,7 @@ abstract class BaseMenuManager extends BaseSubManager {\n \n \t@SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n \tprivate boolean supportsImages(){\n-\t\treturn (defaultMainWindowCapability == null || defaultMainWindowCapability.getImageFields() == null) || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, ImageFieldName.cmdIcon);\n+\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, ImageFieldName.cmdIcon);\n \t}\n \n \tprivate boolean artworkNeedsUpload(SdlArtwork artwork){\n", "next_change": {"commit": "ceadd66ca7c49fa8f6303b694a0d9aaef89a7cf9", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\nindex 48ed19b40..053d48dff 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n", "chunk": "@@ -780,7 +780,7 @@ abstract class BaseMenuManager extends BaseSubManager {\n \n \t@SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n \tprivate boolean supportsImages(){\n-\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, ImageFieldName.cmdIcon);\n+\t\treturn (defaultMainWindowCapability == null || defaultMainWindowCapability.getImageFields() == null) || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, ImageFieldName.cmdIcon);\n \t}\n \n \tprivate boolean artworkNeedsUpload(SdlArtwork artwork){\n", "next_change": {"commit": "3699318e85d49e7b61978cbc5c6cfe59d3afd9de", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\nindex 053d48dff..928a1277b 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n", "chunk": "@@ -780,7 +780,7 @@ abstract class BaseMenuManager extends BaseSubManager {\n \n \t@SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n \tprivate boolean supportsImages(){\n-\t\treturn (defaultMainWindowCapability == null || defaultMainWindowCapability.getImageFields() == null) || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, ImageFieldName.cmdIcon);\n+\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, ImageFieldName.cmdIcon);\n \t}\n \n \tprivate boolean artworkNeedsUpload(SdlArtwork artwork){\n", "next_change": {"commit": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\nindex 928a1277b..dbf9c211c 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n", "chunk": "@@ -374,982 +369,974 @@ abstract class BaseMenuManager extends BaseSubManager {\n \n         if (menuConfiguration.getMenuLayout() != null) {\n \n-\t\t\tSetGlobalProperties setGlobalProperties = new SetGlobalProperties();\n-\t\t\tsetGlobalProperties.setMenuLayout(menuConfiguration.getMenuLayout());\n-\t\t\tsetGlobalProperties.setOnRPCResponseListener(new OnRPCResponseListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\t\tif (response.getSuccess()) {\n-\t\t\t\t\t\tDebugTool.logInfo(\"Menu Configuration successfully set: \" + menuConfiguration.toString());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\t\tDebugTool.logError(\"onError: \" + resultCode + \" | Info: \" + info);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tinternalInterface.sendRPC(setGlobalProperties);\n-\t\t} else {\n-\t\t\tDebugTool.logInfo(\"Menu Layout is null, not sending setGlobalProperties\");\n-\t\t}\n+            SetGlobalProperties setGlobalProperties = new SetGlobalProperties();\n+            setGlobalProperties.setMenuLayout(menuConfiguration.getMenuLayout());\n+            setGlobalProperties.setOnRPCResponseListener(new OnRPCResponseListener() {\n+                @Override\n+                public void onResponse(int correlationId, RPCResponse response) {\n+                    if (response.getSuccess()) {\n+                        DebugTool.logInfo(TAG, \"Menu Configuration successfully set: \" + menuConfiguration.toString());\n+                    } else {\n+                        DebugTool.logError(TAG, \"onError: \" + response.getResultCode() + \" | Info: \" + response.getInfo());\n+                    }\n+                }\n+            });\n+            internalInterface.sendRPC(setGlobalProperties);\n+        } else {\n+            DebugTool.logInfo(TAG, \"Menu Layout is null, not sending setGlobalProperties\");\n+        }\n     }\n \n-    public MenuConfiguration getMenuConfiguration(){\n+    public MenuConfiguration getMenuConfiguration() {\n         return this.menuConfiguration;\n     }\n-\t// UPDATING SYSTEM\n-\n-\t// ROOT MENU\n-\n-\tprivate void updateMenuAndDetermineBestUpdateMethod(){\n-\n-\t\tif (currentHMILevel == null || currentHMILevel.equals(HMILevel.HMI_NONE) || currentSystemContext.equals(SystemContext.SYSCTXT_MENU)){\n-\t\t\t// We are in NONE or the menu is in use, bail out of here\n-\t\t\tDebugTool.logInfo(\"HMI in None or System Context Menu, returning\");\n-\t\t\twaitingOnHMIUpdate = true;\n-\t\t\twaitingUpdateMenuCells = menuCells;\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (inProgressUpdate != null && inProgressUpdate.size() > 0){\n-\t\t\t// there's an in-progress update so this needs to wait\n-\t\t\tDebugTool.logInfo(\"There is an in progress Menu Update, returning\");\n-\t\t\thasQueuedUpdate = true;\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Checks against what the developer set for update mode and against the display type\n-\t\t// to determine how the menu will be updated. This has the ability to be changed during\n-\t\t// a session.\n-\t\tif (checkUpdateMode(dynamicMenuUpdatesMode, displayType)) {\n-\t\t\t// run the lists through the new algorithm\n-\t\t\tRunScore rootScore = runMenuCompareAlgorithm(oldMenuCells, menuCells);\n-\t\t\tif (rootScore == null) {\n-\t\t\t\t// send initial menu (score will return null)\n-\t\t\t\t// make a copy of our current cells\n-\t\t\t\tDebugTool.logInfo(\"Creating initial Menu\");\n-\t\t\t\t// Set the IDs if needed\n-\t\t\t\tlastMenuId = menuCellIdMin;\n-\t\t\t\tupdateIdsOnMenuCells(menuCells, parentIdNotFound);\n-\t\t\t\tthis.oldMenuCells = new ArrayList<>(menuCells);\n-\t\t\t\tcreateAndSendEntireMenu();\n-\t\t\t} else {\n-\t\t\t\tDebugTool.logInfo(\"Dynamically Updating Menu\");\n-\t\t\t\tif (menuCells.size() == 0 && (oldMenuCells != null && oldMenuCells.size() > 0)) {\n-\t\t\t\t\t// the dev wants to clear the menu. We have old cells and an empty array of new ones.\n-\t\t\t\t\tdeleteMenuWhenNewCellsEmpty();\n-\t\t\t\t} else {\n-\t\t\t\t\t// lets dynamically update the root menu\n-\t\t\t\t\tdynamicallyUpdateRootMenu(rootScore);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// we are in compatibility mode\n-\t\t\tDebugTool.logInfo(\"Updating menus in compatibility mode\");\n-\t\t\tlastMenuId = menuCellIdMin;\n-\t\t\tupdateIdsOnMenuCells(menuCells, parentIdNotFound);\n-\t\t\t// if the old cell array is not null, we want to delete the entire thing, else copy the new array\n-\t\t\tif (oldMenuCells == null) {\n-\t\t\t\tthis.oldMenuCells = new ArrayList<>(menuCells);\n-\t\t\t}\n-\t\t\tcreateAndSendEntireMenu();\n-\t\t}\n-\t}\n-\n-\tprivate boolean checkUpdateMode(DynamicMenuUpdatesMode updateMode, String displayType){\n-\n-\t\tif (updateMode.equals(DynamicMenuUpdatesMode.ON_WITH_COMPAT_MODE)){\n-\t\t\tif (displayType == null){\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\treturn (!displayType.equals(DisplayType.GEN3_8_INCH.toString()));\n-\n-\t\t} else if (updateMode.equals(DynamicMenuUpdatesMode.FORCE_OFF)){\n-\t\t\treturn false;\n-\t\t} else if (updateMode.equals(DynamicMenuUpdatesMode.FORCE_ON)){\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\treturn true;\n-\t}\n-\n-\tprivate void deleteMenuWhenNewCellsEmpty(){\n-\t\tsendDeleteRPCs(createDeleteRPCsForCells(oldMenuCells), new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tinProgressUpdate = null;\n-\n-\t\t\t\tif (!success){\n-\t\t\t\t\tDebugTool.logError(\"Error Sending Current Menu\");\n-\t\t\t\t}else{\n-\t\t\t\t\tDebugTool.logInfo(\"Successfully Cleared Menu\");\n-\t\t\t\t}\n-\t\t\t\toldMenuCells = null;\n-\t\t\t\tif (hasQueuedUpdate){\n-\t\t\t\t\thasQueuedUpdate = false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\tprivate void dynamicallyUpdateRootMenu(RunScore bestRootScore){\n-\n-\t\t// we need to run through the keeps and see if they have subCells, as they also need to be run\n-\t\t// through the compare function.\n-\t\tList<Integer> newIntArray = bestRootScore.getCurrentMenu();\n-\t\tList<Integer> oldIntArray = bestRootScore.getOldMenu();\n-\t\tList<RPCRequest> deleteCommands;\n-\n-\t\t// Set up deletes\n-\t\tList<MenuCell> deletes = new ArrayList<>();\n-\t\tkeepsOld = new ArrayList<>();\n-\t\tfor (int x = 0; x < oldIntArray.size(); x++) {\n-\t\t\tInteger old = oldIntArray.get(x);\n-\t\t\tif (old.equals(MARKED_FOR_DELETION)){\n-\t\t\t\t// grab cell to send to function to create delete commands\n-\t\t\t\tdeletes.add(oldMenuCells.get(x));\n-\t\t\t} else if (old.equals(KEEP)) {\n-\t\t\t\tkeepsOld.add(oldMenuCells.get(x));\n-\t\t\t}\n-\t\t}\n-\t\t// create the delete commands\n-\t\tdeleteCommands = createDeleteRPCsForCells(deletes);\n-\n-\t\t// Set up the adds\n-\t\tList<MenuCell> adds = new ArrayList<>();\n-\t\tkeepsNew = new ArrayList<>();\n-\t\tfor (int x = 0; x < newIntArray.size(); x++) {\n-\t\t\tInteger newInt = newIntArray.get(x);\n-\t\t\tif (newInt.equals(MARKED_FOR_ADDITION)){\n-\t\t\t\t// grab cell to send to function to create add commands\n-\t\t\t\tadds.add(menuCells.get(x));\n-\t\t\t} else if (newInt.equals(KEEP)){\n-\t\t\t\tkeepsNew.add(menuCells.get(x));\n-\t\t\t}\n-\t\t}\n-\t\tupdateIdsOnDynamicCells(adds);\n-\t\t// this is needed for the onCommands to still work\n-\t\ttransferIdsToKeptCells(keepsNew);\n-\n-\t\tif (adds.size() > 0){\n-\t\t\tDebugTool.logInfo(\"Sending root menu updates\");\n-\t\t\tsendDynamicRootMenuRPCs(deleteCommands, adds);\n-\t\t}else{\n-\t\t\tDebugTool.logInfo(\"All root menu items are kept. Check the sub menus\");\n-\t\t\trunSubMenuCompareAlgorithm();\n-\t\t}\n-\t}\n-\n-\t// OTHER\n-\n-\tprivate void sendDynamicRootMenuRPCs(List<RPCRequest> deleteCommands,final List<MenuCell> updatedCells){\n-\t\tsendDeleteRPCs(deleteCommands,new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tcreateAndSendMenuCellRPCs(updatedCells, new CompletionListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\t\tinProgressUpdate = null;\n-\n-\t\t\t\t\t\tif (!success){\n-\t\t\t\t\t\t\tDebugTool.logError(\"Error Sending Current Menu\");\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tif (hasQueuedUpdate){\n-\t\t\t\t\t\t\t//setMenuCells(waitingUpdateMenuCells);\n-\t\t\t\t\t\t\thasQueuedUpdate = false;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t// SUB MENUS\n-\n-\t// This is called in the listener in the sendMenu and sendSubMenuCommands Methods\n-\tprivate void runSubMenuCompareAlgorithm(){\n-\t\t// any cells that were re-added have their sub-cells added with them\n-\t\t// at this point all we care about are the cells that were deemed equal and kept.\n-\t\tif (keepsNew == null || keepsNew.size() == 0) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tList<SubCellCommandList> commandLists = new ArrayList<>();\n-\n-\t\tfor (int i = 0; i < keepsNew.size(); i++) {\n-\n-\t\t\tMenuCell keptCell = keepsNew.get(i);\n-\t\t\tMenuCell oldKeptCell = keepsOld.get(i);\n-\n-\t\t\tif (oldKeptCell.getSubCells() != null && oldKeptCell.getSubCells().size() > 0 && keptCell.getSubCells() != null && keptCell.getSubCells().size() > 0){\n-\t\t\t\t// ACTUAL LOGIC\n-\t\t\t\tRunScore subScore = compareOldAndNewLists(oldKeptCell.getSubCells(), keptCell.getSubCells());\n-\n-\t\t\t\tif (subScore != null){\n-\t\t\t\t\tDebugTool.logInfo(\"Sub menu Run Score: \"+ oldKeptCell.getTitle()+ \" Score: \"+ subScore.getScore());\n-\t\t\t\t\tSubCellCommandList commandList = new SubCellCommandList(oldKeptCell.getTitle(), oldKeptCell.getCellId(), subScore, oldKeptCell.getSubCells(), keptCell.getSubCells());\n-\t\t\t\t\tcommandLists.add(commandList);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tcreateSubMenuDynamicCommands(commandLists);\n-\t}\n-\n-\tprivate void createSubMenuDynamicCommands(final List<SubCellCommandList> commandLists){\n-\n-\t\t// break out\n-\t\tif (commandLists.size() == 0){\n-\t\t\tif (inProgressUpdate != null){\n-\t\t\t\tinProgressUpdate = null;\n-\t\t\t}\n-\n-\t\t\tif (hasQueuedUpdate) {\n-\t\t\t\tDebugTool.logInfo(\"Menu Manager has waiting updates, sending now\");\n-\t\t\t\tsetMenuCells(waitingUpdateMenuCells);\n-\t\t\t\thasQueuedUpdate = false;\n-\t\t\t}\n-\t\t\tDebugTool.logInfo(\"All menu updates, including sub menus - done.\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tfinal SubCellCommandList commandList = commandLists.remove(0);\n-\n-\t\tDebugTool.logInfo(\"Creating and Sending Dynamic Sub Commands For Root Menu Cell: \"+ commandList.getMenuTitle());\n-\n-\t\t// grab the scores\n-\t\tRunScore score = commandList.getListsScore();\n-\t\tList<Integer> newIntArray = score.getCurrentMenu();\n-\t\tList<Integer> oldIntArray = score.getOldMenu();\n-\n-\t\t// Grab the sub-menus from the parent cell\n-\t\tfinal List<MenuCell> oldCells = commandList.getOldList();\n-\t\tfinal List<MenuCell> newCells = commandList.getNewList();\n-\n-\t\t// Create the list for the adds\n-\t\tList<MenuCell> subCellKeepsNew = new ArrayList<>();\n-\n-\t\tList<RPCRequest> deleteCommands;\n-\n-\t\t// Set up deletes\n-\t\tList<MenuCell> deletes = new ArrayList<>();\n-\t\tfor (int x = 0; x < oldIntArray.size(); x++) {\n-\t\t\tInteger old = oldIntArray.get(x);\n-\t\t\tif (old.equals(MARKED_FOR_DELETION)){\n-\t\t\t\t// grab cell to send to function to create delete commands\n-\t\t\t\tdeletes.add(oldCells.get(x));\n-\t\t\t}\n-\t\t}\n-\t\t// create the delete commands\n-\t\tdeleteCommands = createDeleteRPCsForCells(deletes);\n-\n-\t\t// Set up the adds\n-\t\tList<MenuCell> adds = new ArrayList<>();\n-\t\tfor (int x = 0; x < newIntArray.size(); x++) {\n-\t\t\tInteger newInt = newIntArray.get(x);\n-\t\t\tif (newInt.equals(MARKED_FOR_ADDITION)){\n-\t\t\t\t// grab cell to send to function to create add commands\n-\t\t\t\tadds.add(newCells.get(x));\n-\t\t\t} else if (newInt.equals(KEEP)){\n-\t\t\t\tsubCellKeepsNew.add(newCells.get(x));\n-\t\t\t}\n-\t\t}\n-\t\tfinal List<MenuCell> addsWithNewIds = updateIdsOnDynamicSubCells(oldCells, adds, commandList.getParentId());\n-\t\t// this is needed for the onCommands to still work\n-\t\ttransferIdsToKeptSubCells(oldCells, subCellKeepsNew);\n-\n-\t\tsendDeleteRPCs(deleteCommands,new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tif (addsWithNewIds != null && addsWithNewIds.size() > 0) {\n-\t\t\t\t\tcreateAndSendDynamicSubMenuRPCs(newCells, addsWithNewIds, new CompletionListener() {\n-\t\t\t\t\t\t@Override\n-\t\t\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\t\t\t// recurse through next sub list\n-\t\t\t\t\t\t\tDebugTool.logInfo(\"Finished Sending Dynamic Sub Commands For Root Menu Cell: \"+ commandList.getMenuTitle());\n-\t\t\t\t\t\t\tcreateSubMenuDynamicCommands(commandLists);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t});\n-\t\t\t\t} else{\n-\t\t\t\t\t// no add commands to send, recurse through next sub list\n-\t\t\t\t\tDebugTool.logInfo(\"Finished Sending Dynamic Sub Commands For Root Menu Cell: \"+ commandList.getMenuTitle());\n-\t\t\t\t\tcreateSubMenuDynamicCommands(commandLists);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t// OTHER HELPER METHODS:\n-\n-\t// COMPARISONS\n-\n-\tRunScore runMenuCompareAlgorithm(List<MenuCell> oldCells, List<MenuCell> newCells){\n-\n-\t\tif (oldCells == null || oldCells.size() == 0){\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tRunScore bestScore = compareOldAndNewLists(oldCells, newCells);\n-\t\tDebugTool.logInfo(\"Best menu run score: \"+ bestScore.getScore());\n-\n-\t\treturn bestScore;\n-\t}\n-\n-\tprivate RunScore compareOldAndNewLists(List<MenuCell> oldCells, List<MenuCell> newCells){\n-\n-\t\tRunScore bestRunScore = null;\n-\n-\t\t// This first loop is for each 'run'\n-\t\tfor (int run = 0; run < oldCells.size(); run++) {\n-\n-\t\t\tList<Integer> oldArray = new ArrayList<>(oldCells.size());\n-\t\t\tList<Integer> newArray = new ArrayList<>(newCells.size());\n-\n-\t\t\t// Set the statuses\n-\t\t\tsetDeleteStatus(oldCells.size(), oldArray);\n-\t\t\tsetAddStatus(newCells.size(), newArray);\n-\n-\t\t\tint startIndex = 0;\n-\n-\t\t\t// Keep items that appear in both lists\n-\t\t\tfor (int oldItems = run; oldItems < oldCells.size(); oldItems++) {\n-\n-\t\t\t\tfor (int newItems = startIndex; newItems < newCells.size(); newItems++) {\n-\n-\t\t\t\t\tif (oldCells.get(oldItems).equals(newCells.get(newItems))){\n-\t\t\t\t\t\toldArray.set(oldItems, KEEP);\n-\t\t\t\t\t\tnewArray.set(newItems, KEEP);\n-\t\t\t\t\t\t// set the new start index\n-\t\t\t\t\t\tstartIndex = newItems + 1;\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Calculate number of adds, or the 'score' for this run\n-\t\t\tint numberOfAdds = 0;\n-\n-\t\t\tfor (int x = 0; x < newArray.size(); x++) {\n-\t\t\t\tif (newArray.get(x).equals(MARKED_FOR_ADDITION)){\n-\t\t\t\t\tnumberOfAdds++;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// see if we have a new best score and set it if we do\n-\t\t\tif (bestRunScore == null || numberOfAdds < bestRunScore.getScore()){\n-\t\t\t\tbestRunScore = new RunScore(numberOfAdds, oldArray, newArray);\n-\t\t\t}\n-\n-\t\t}\n-\t\treturn bestRunScore;\n-\t}\n-\n-\tprivate void setDeleteStatus(Integer size, List<Integer> oldArray){\n-\t\tfor (int i = 0; i < size; i++) {\n-\t\t\toldArray.add(MARKED_FOR_DELETION);\n-\t\t}\n-\t}\n-\n-\tprivate void setAddStatus(Integer size, List<Integer> newArray){\n-\t\tfor (int i = 0; i < size; i++) {\n-\t\t\tnewArray.add(MARKED_FOR_ADDITION);\n-\t\t}\n-\t}\n-\n-\t// ARTWORKS\n-\n-\tprivate List<SdlArtwork> findAllArtworksToBeUploadedFromCells(List<MenuCell> cells){\n-\t\t// Make sure we can use images in the menus\n-\t\tif (!supportsImages()){\n-\t\t\treturn new ArrayList<>();\n-\t\t}\n-\n-\t\tList<SdlArtwork> artworks = new ArrayList<>();\n-\t\tfor (MenuCell cell : cells){\n-\t\t\tif (artworkNeedsUpload(cell.getIcon())){\n-\t\t\t\tartworks.add(cell.getIcon());\n-\t\t\t}\n-\t\t\tif (cell.getSubCells() != null && cell.getSubCells().size() > 0){\n-\t\t\t\tartworks.addAll(findAllArtworksToBeUploadedFromCells(cell.getSubCells()));\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn artworks;\n-\t}\n-\n-\t@SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n-\tprivate boolean supportsImages(){\n-\t\treturn defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, ImageFieldName.cmdIcon);\n-\t}\n-\n-\tprivate boolean artworkNeedsUpload(SdlArtwork artwork){\n-\t\tif (fileManager.get() != null){\n-\t\t\treturn (artwork != null && !fileManager.get().hasUploadedFile(artwork) && !artwork.isStaticIcon());\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t// IDs\n-\n-\tprivate void updateIdsOnDynamicCells(List<MenuCell> dynamicCells){\n-\t\tif (menuCells != null && menuCells.size() > 0 && dynamicCells != null && dynamicCells.size() > 0) {\n-\t\t\tfor (int z = 0; z < menuCells.size(); z++) {\n-\t\t\t\tMenuCell mainCell = menuCells.get(z);\n-\t\t\t\tfor (int i = 0; i < dynamicCells.size(); i++) {\n-\t\t\t\t\tMenuCell dynamicCell = dynamicCells.get(i);\n-\t\t\t\t\tif (mainCell.equals(dynamicCell)) {\n-\t\t\t\t\t\tint newId = ++lastMenuId;\n-\t\t\t\t\t\tmenuCells.get(z).setCellId(newId);\n-\t\t\t\t\t\tdynamicCells.get(i).setCellId(newId);\n-\n-\t\t\t\t\t\tif (mainCell.getSubCells() != null && mainCell.getSubCells().size() > 0) {\n-\t\t\t\t\t\t\tupdateIdsOnMenuCells(mainCell.getSubCells(), mainCell.getCellId());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate List<MenuCell> updateIdsOnDynamicSubCells(List<MenuCell> oldList, List<MenuCell> dynamicCells, Integer parentId){\n-\t\tif (oldList != null && oldList.size() > 0 && dynamicCells != null && dynamicCells.size() > 0) {\n-\t\t\tfor (int z = 0; z < oldList.size(); z++) {\n-\t\t\t\tMenuCell mainCell = oldList.get(z);\n-\t\t\t\tfor (int i = 0; i < dynamicCells.size(); i++) {\n-\t\t\t\t\tMenuCell dynamicCell = dynamicCells.get(i);\n-\t\t\t\t\tif (mainCell.equals(dynamicCell)) {\n-\t\t\t\t\t\tint newId = ++lastMenuId;\n-\t\t\t\t\t\toldList.get(z).setCellId(newId);\n-\t\t\t\t\t\tdynamicCells.get(i).setParentCellId(parentId);\n-\t\t\t\t\t\tdynamicCells.get(i).setCellId(newId);\n-\t\t\t\t\t}else{\n-\t\t\t\t\t\tint newId = ++lastMenuId;\n-\t\t\t\t\t\tdynamicCells.get(i).setParentCellId(parentId);\n-\t\t\t\t\t\tdynamicCells.get(i).setCellId(newId);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn dynamicCells;\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate void updateIdsOnMenuCells(List<MenuCell> cells, int parentId) {\n-\t\tfor (MenuCell cell : cells) {\n-\t\t\tint newId = ++lastMenuId;\n-\t\t\tcell.setCellId(newId);\n-\t\t\tcell.setParentCellId(parentId);\n-\t\t\tif (cell.getSubCells() != null && cell.getSubCells().size() > 0) {\n-\t\t\t\tupdateIdsOnMenuCells(cell.getSubCells(), cell.getCellId());\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void transferIdsToKeptCells(List<MenuCell> keeps) {\n-\t\tfor (int z = 0; z < oldMenuCells.size(); z++) {\n-\t\t\tMenuCell oldCell = oldMenuCells.get(z);\n-\t\t\tfor (int i = 0; i < keeps.size(); i++) {\n-\t\t\t\tMenuCell keptCell = keeps.get(i);\n-\t\t\t\tif (oldCell.equals(keptCell)) {\n-\t\t\t\t\tkeptCell.setCellId(oldCell.getCellId());\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void transferIdsToKeptSubCells(List<MenuCell> old, List<MenuCell> keeps) {\n-\t\tfor (int z = 0; z < old.size(); z++) {\n-\t\t\tMenuCell oldCell = old.get(z);\n-\t\t\tfor (int i = 0; i < keeps.size(); i++) {\n-\t\t\t\tMenuCell keptCell = keeps.get(i);\n-\t\t\t\tif (oldCell.equals(keptCell)) {\n-\t\t\t\t\tkeptCell.setCellId(oldCell.getCellId());\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// DELETES\n-\n-\tprivate List<RPCRequest> createDeleteRPCsForCells(List<MenuCell> cells){\n-\t\tList<RPCRequest> deletes = new ArrayList<>();\n-\t\tfor (MenuCell cell : cells){\n-\t\t\tif (cell.getSubCells() == null){\n-\t\t\t\tDeleteCommand delete = new DeleteCommand(cell.getCellId());\n-\t\t\t\tdeletes.add(delete);\n-\t\t\t}else{\n-\t\t\t\tDeleteSubMenu delete = new DeleteSubMenu(cell.getCellId());\n-\t\t\t\tdeletes.add(delete);\n-\t\t\t}\n-\t\t}\n-\t\treturn deletes;\n-\t}\n-\n-\t// COMMANDS / SUBMENU RPCs\n-\n-\tprivate List<RPCRequest> mainMenuCommandsForCells(List<MenuCell> cellsToAdd, boolean shouldHaveArtwork) {\n-\t\tList<RPCRequest> builtCommands = new ArrayList<>();\n-\n-\t\t// We need the index so we will use this type of loop\n-\t\tfor (int z = 0; z < menuCells.size(); z++) {\n-\t\t\tMenuCell mainCell = menuCells.get(z);\n-\t\t\tfor (int i = 0; i < cellsToAdd.size(); i++) {\n-\t\t\t\tMenuCell addCell = cellsToAdd.get(i);\n-\t\t\t\tif (mainCell.equals(addCell)) {\n-\t\t\t\t\tif (addCell.getSubCells() != null && addCell.getSubCells().size() > 0) {\n-\t\t\t\t\t\tbuiltCommands.add(subMenuCommandForMenuCell(addCell, shouldHaveArtwork, z));\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tbuiltCommands.add(commandForMenuCell(addCell, shouldHaveArtwork, z));\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn builtCommands;\n-\t}\n-\n-\tprivate List<RPCRequest> subMenuCommandsForCells(List<MenuCell> cells, boolean shouldHaveArtwork){\n-\t\tList<RPCRequest> builtCommands = new ArrayList<>();\n-\t\tfor (MenuCell cell : cells){\n-\t\t\tif (cell.getSubCells() != null && cell.getSubCells().size() > 0){\n-\t\t\t\tbuiltCommands.addAll(allCommandsForCells(cell.getSubCells(), shouldHaveArtwork));\n-\t\t\t}\n-\t\t}\n-\t\treturn builtCommands;\n-\t}\n-\n-\tList<RPCRequest> allCommandsForCells(List<MenuCell> cells, boolean shouldHaveArtwork){\n-\t\tList<RPCRequest> builtCommands = new ArrayList<>();\n-\n-\t\t// We need the index so we will use this type of loop\n-\t\tfor (int i = 0; i < cells.size(); i++) {\n-\t\t\tMenuCell cell = cells.get(i);\n-\t\t\tif (cell.getSubCells() != null && cell.getSubCells().size() > 0){\n-\t\t\t\tbuiltCommands.add(subMenuCommandForMenuCell(cell, shouldHaveArtwork, i));\n-\t\t\t\t// recursively grab the commands for all the sub cells\n-\t\t\t\tbuiltCommands.addAll(allCommandsForCells(cell.getSubCells(), shouldHaveArtwork));\n-\t\t\t}else{\n-\t\t\t\tbuiltCommands.add(commandForMenuCell(cell, shouldHaveArtwork, i));\n-\t\t\t}\n-\t\t}\n-\t\treturn builtCommands;\n-\t}\n-\n-\tprivate List<RPCRequest> createCommandsForDynamicSubCells(List<MenuCell> oldMenuCells, List<MenuCell> cells, boolean shouldHaveArtwork) {\n-\t\tList<RPCRequest> builtCommands = new ArrayList<>();\n-\t\tfor (int z = 0; z < oldMenuCells.size(); z++) {\n-\t\t\tMenuCell oldCell = oldMenuCells.get(z);\n-\t\t\tfor (int i = 0; i < cells.size(); i++) {\n-\t\t\t\tMenuCell cell = cells.get(i);\n-\t\t\t\tif (cell.equals(oldCell)){\n-\t\t\t\t\tbuiltCommands.add(commandForMenuCell(cell, shouldHaveArtwork, z));\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn builtCommands;\n-\t}\n-\n-\tprivate AddCommand commandForMenuCell(MenuCell cell, boolean shouldHaveArtwork, int position){\n-\n-\t\tMenuParams params = new MenuParams(cell.getTitle());\n-\t\tparams.setParentID(cell.getParentCellId() != MAX_ID ? cell.getParentCellId() : null);\n-\t\tparams.setPosition(position);\n-\n-\t\tAddCommand command = new AddCommand(cell.getCellId());\n-\t\tcommand.setMenuParams(params);\n-\t\tif (cell.getVoiceCommands() != null && !cell.getVoiceCommands().isEmpty()) {\n-\t\t\tcommand.setVrCommands(cell.getVoiceCommands());\n-\t\t} else {\n-\t\t\tcommand.setVrCommands(null);\n-\t\t}\n-\t\tcommand.setCmdIcon((cell.getIcon() != null && shouldHaveArtwork) ? cell.getIcon().getImageRPC() : null);\n-\n-\t\treturn command;\n-\t}\n-\n-\tprivate AddSubMenu subMenuCommandForMenuCell(MenuCell cell, boolean shouldHaveArtwork, int position){\n-\t\tAddSubMenu subMenu = new AddSubMenu(cell.getCellId(), cell.getTitle());\n-\t\tsubMenu.setPosition(position);\n-\t\tif (cell.getSubMenuLayout() != null ) {\n-\t\t\tsubMenu.setMenuLayout(cell.getSubMenuLayout());\n-\t\t} else if (menuConfiguration != null && menuConfiguration.getSubMenuLayout() != null) {\n-\t\t\tsubMenu.setMenuLayout(menuConfiguration.getSubMenuLayout());\n-\t\t}\n-\t\tsubMenu.setMenuIcon((shouldHaveArtwork && (cell.getIcon()!= null && cell.getIcon().getImageRPC() != null)) ? cell.getIcon().getImageRPC() : null);\n-\t\treturn subMenu;\n-\t}\n-\n-\t// CELL COMMAND HANDLING\n-\n-\tprivate boolean callListenerForCells(List<MenuCell> cells, OnCommand command){\n-\t\tif (cells != null && cells.size() > 0 && command != null) {\n-\t\t\tfor (MenuCell cell : cells) {\n-\n-\t\t\t\tif (cell.getCellId() == command.getCmdID() && cell.getMenuSelectionListener() != null) {\n-\t\t\t\t\tcell.getMenuSelectionListener().onTriggered(command.getTriggerSource());\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t\tif (cell.getSubCells() != null && cell.getSubCells().size() > 0) {\n-\t\t\t\t\t// for each cell, if it has sub cells, recursively loop through those as well\n-\t\t\t\t\tif (callListenerForCells(cell.getSubCells(), command)) {\n-\t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t// LISTENERS\n-\n-\tprivate void addListeners(){\n-\t\t// DISPLAY CAPABILITIES - via SCM\n-\t\tonDisplaysCapabilityListener = new OnSystemCapabilityListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t// instead of using the parameter it's more safe to use the convenience method\n-\t\t\t\tList<DisplayCapability> capabilities = SystemCapabilityManager.convertToList(capability, DisplayCapability.class);\n-\t\t\t\tif (capabilities == null || capabilities.size() == 0) {\n-\t\t\t\t\tDebugTool.logError(\"SoftButton Manager - Capabilities sent here are null or empty\");\n-\t\t\t\t}else {\n-\t\t\t\t\tDisplayCapability display = capabilities.get(0);\n-\t\t\t\t\tdisplayType = display.getDisplayName();\n-\t\t\t\t\tfor (WindowCapability windowCapability : display.getWindowCapabilities()) {\n-\t\t\t\t\t\tint currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\t\t\t\tif (currentWindowID == PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\t\t\tdefaultMainWindowCapability = windowCapability;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(String info) {\n-\t\t\t\tDebugTool.logError(\"Display Capability cannot be retrieved\");\n-\t\t\t\tdefaultMainWindowCapability = null;\n-\t\t\t}\n-\t\t};\n-\t\tthis.internalInterface.addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n-\n-\t\t// HMI UPDATES\n-\t\thmiListener = new OnRPCNotificationListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus)notification;\n-\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tHMILevel oldHMILevel = currentHMILevel;\n-\t\t\t\tcurrentHMILevel = onHMIStatus.getHmiLevel();\n-\n-\t\t\t\t// Auto-send an updated menu if we were in NONE and now we are not, and we need an update\n-\t\t\t\tif (oldHMILevel == HMILevel.HMI_NONE && currentHMILevel != HMILevel.HMI_NONE && currentSystemContext != SystemContext.SYSCTXT_MENU){\n-\t\t\t\t\tif (waitingOnHMIUpdate){\n-\t\t\t\t\t\tDebugTool.logInfo(\"We now have proper HMI, sending waiting update\");\n-\t\t\t\t\t\tsetMenuCells(waitingUpdateMenuCells);\n-\t\t\t\t\t\twaitingUpdateMenuCells.clear();\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// If we don't check for this and only update when not in the menu, there can be IN_USE errors, especially with submenus.\n-\t\t\t\t// We also don't want to encourage changing out the menu while the user is using it for usability reasons.\n-\t\t\t\tSystemContext oldContext = currentSystemContext;\n-\t\t\t\tcurrentSystemContext = onHMIStatus.getSystemContext();\n-\n-\t\t\t\tif (oldContext == SystemContext.SYSCTXT_MENU && currentSystemContext != SystemContext.SYSCTXT_MENU && currentHMILevel != HMILevel.HMI_NONE){\n-\t\t\t\t\tif (waitingOnHMIUpdate){\n-\t\t\t\t\t\tDebugTool.logInfo(\"We now have a proper system context, sending waiting update\");\n-\t\t\t\t\t\tsetMenuCells(waitingUpdateMenuCells);\n-\t\t\t\t\t\twaitingUpdateMenuCells.clear();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t};\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\n-\t\t// COMMANDS\n-\t\tcommandListener = new OnRPCNotificationListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\t\tOnCommand onCommand = (OnCommand) notification;\n-\t\t\t\tcallListenerForCells(menuCells, onCommand);\n-\t\t\t}\n-\t\t};\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_COMMAND, commandListener);\n-\t}\n-\n-\t// SEND NEW MENU ITEMS\n-\n-\tprivate void createAndSendEntireMenu(){\n-\n-\t\tif (currentHMILevel == null || currentHMILevel.equals(HMILevel.HMI_NONE) || currentSystemContext.equals(SystemContext.SYSCTXT_MENU)){\n-\t\t\t// We are in NONE or the menu is in use, bail out of here\n-\t\t\tDebugTool.logInfo(\"HMI in None or System Context Menu, returning\");\n-\t\t\twaitingOnHMIUpdate = true;\n-\t\t\twaitingUpdateMenuCells = menuCells;\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (inProgressUpdate != null && inProgressUpdate.size() > 0){\n-\t\t\t// there's an in-progress update so this needs to wait\n-\t\t\tDebugTool.logInfo(\"There is an in progress Menu Update, returning\");\n-\t\t\thasQueuedUpdate = true;\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tdeleteRootMenu(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tcreateAndSendMenuCellRPCs(menuCells, new CompletionListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\t\tinProgressUpdate = null;\n-\n-\t\t\t\t\t\tif (!success) {\n-\t\t\t\t\t\t\tDebugTool.logError(\"Error Sending Current Menu\");\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tif (hasQueuedUpdate) {\n-\t\t\t\t\t\t\tsetMenuCells(waitingUpdateMenuCells);\n-\t\t\t\t\t\t\thasQueuedUpdate = false;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\tprivate void createAndSendMenuCellRPCs(final List<MenuCell> menu, final CompletionListener listener){\n-\n-\t\tif (menu.size() == 0){\n-\t\t\tif (listener != null){\n-\t\t\t\t// This can be considered a success if the user was clearing out their menu\n-\t\t\t\tlistener.onComplete(true);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tList<RPCRequest> mainMenuCommands;\n-\t\tfinal List<RPCRequest> subMenuCommands;\n-\n-\t\tif (findAllArtworksToBeUploadedFromCells(menu).size() > 0 || !supportsImages()){\n-\t\t\t// Send artwork-less menu\n-\t\t\tmainMenuCommands = mainMenuCommandsForCells(menu, false);\n-\t\t\tsubMenuCommands = subMenuCommandsForCells(menu, false);\n-\t\t} else {\n-\t\t\tmainMenuCommands = mainMenuCommandsForCells(menu, true);\n-\t\t\tsubMenuCommands = subMenuCommandsForCells(menu, true);\n-\t\t}\n-\n-\t\t// add all built commands to inProgressUpdate\n-\t\tinProgressUpdate = new ArrayList<>(mainMenuCommands);\n-\t\tinProgressUpdate.addAll(subMenuCommands);\n-\n-\t\tinternalInterface.sendSequentialRPCs(mainMenuCommands, new OnMultipleRequestListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onUpdate(int remainingRequests) {\n-\t\t\t\t// nothing here\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onFinished() {\n-\n-\t\t\t\tif (subMenuCommands.size() > 0) {\n-\t\t\t\t\tsendSubMenuCommandRPCs(subMenuCommands, listener);\n-\t\t\t\t\tDebugTool.logInfo(\"Finished sending main menu commands. Sending sub menu commands.\");\n-\t\t\t\t} else {\n-\n-\t\t\t\t\tif (keepsNew != null && keepsNew.size() > 0){\n-\t\t\t\t\t\trunSubMenuCompareAlgorithm();\n-\t\t\t\t\t}else {\n-\t\t\t\t\t\tinProgressUpdate = null;\n-\t\t\t\t\t\tDebugTool.logInfo(\"Finished sending main menu commands.\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\tDebugTool.logError(\"Result: \" + resultCode.toString() + \" Info: \" + info);\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\ttry {\n-\t\t\t\t\tDebugTool.logInfo(\"Main Menu response: \" + response.serializeJSON().toString());\n-\t\t\t\t} catch (JSONException e) {\n-\t\t\t\t\te.printStackTrace();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\tprivate void sendSubMenuCommandRPCs(List<RPCRequest> commands, final CompletionListener listener){\n-\n-\t\tinternalInterface.sendSequentialRPCs(commands, new OnMultipleRequestListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onUpdate(int remainingRequests) {\n-\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onFinished() {\n-\n-\t\t\t\tif (keepsNew != null && keepsNew.size() > 0){\n-\t\t\t\t\trunSubMenuCompareAlgorithm();\n-\t\t\t\t}else {\n-\t\t\t\t\tDebugTool.logInfo(\"Finished Updating Menu\");\n-\t\t\t\t\tinProgressUpdate = null;\n-\n-\t\t\t\t\tif (listener != null) {\n-\t\t\t\t\t\tlistener.onComplete(true);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\tDebugTool.logError(\"Failed to send sub menu commands: \"+ info);\n-\t\t\t\tif (listener != null){\n-\t\t\t\t\tlistener.onComplete(false);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\ttry {\n-\t\t\t\t\tDebugTool.logInfo(\"Sub Menu response: \"+ response.serializeJSON().toString());\n-\t\t\t\t} catch (JSONException e) {\n-\t\t\t\t\te.printStackTrace();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\tprivate void createAndSendDynamicSubMenuRPCs(List<MenuCell> newMenu, final List<MenuCell> adds, final CompletionListener listener){\n-\n-\t\tif (adds.size() == 0){\n-\t\t\tif (listener != null){\n-\t\t\t\t// This can be considered a success if the user was clearing out their menu\n-\t\t\t\tDebugTool.logError(\"Called createAndSendDynamicSubMenuRPCs with empty menu\");\n-\t\t\t\tlistener.onComplete(true);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tList<RPCRequest> mainMenuCommands;\n-\n-\t\tif (findAllArtworksToBeUploadedFromCells(adds).size() > 0 || !supportsImages()){\n-\t\t\t// Send artwork-less menu\n-\t\t\tmainMenuCommands = createCommandsForDynamicSubCells(newMenu, adds, false);\n-\t\t} else {\n-\t\t\tmainMenuCommands = createCommandsForDynamicSubCells(newMenu, adds, true);\n-\t\t}\n-\n-\t\tinternalInterface.sendSequentialRPCs(mainMenuCommands, new OnMultipleRequestListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onUpdate(int remainingRequests) {\n-\t\t\t\t// nothing here\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onFinished() {\n-\n-\t\t\t\tif (listener != null){\n-\t\t\t\t\tlistener.onComplete(true);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\tDebugTool.logError(\"Result: \" + resultCode.toString() + \" Info: \" + info);\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\ttry {\n-\t\t\t\t\tDebugTool.logInfo(\"Dynamic Sub Menu response: \" + response.serializeJSON().toString());\n-\t\t\t\t} catch (JSONException e) {\n-\t\t\t\t\te.printStackTrace();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t// DELETE OLD MENU ITEMS\n-\n-\tprivate void deleteRootMenu(final CompletionListener listener){\n-\n-\t\tif (oldMenuCells == null || oldMenuCells.size() == 0) {\n-\t\t\tif (listener != null){\n-\t\t\t\t// technically this method is successful if there's nothing to delete\n-\t\t\t\tDebugTool.logInfo(\"No old cells to delete, returning\");\n-\t\t\t\tlistener.onComplete(true);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tsendDeleteRPCs(createDeleteRPCsForCells(oldMenuCells), listener);\n-\t\t}\n-\t}\n-\n-\tprivate void sendDeleteRPCs(List<RPCRequest> deleteCommands, final CompletionListener listener){\n-\t\tif (oldMenuCells != null && oldMenuCells.size() == 0) {\n-\t\t\tif (listener != null){\n-\t\t\t\t// technically this method is successful if there's nothing to delete\n-\t\t\t\tDebugTool.logInfo(\"No old cells to delete, returning\");\n-\t\t\t\tlistener.onComplete(true);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (deleteCommands == null || deleteCommands.size() == 0){\n-\t\t\t// no dynamic deletes required. return\n-\t\t\tif (listener != null){\n-\t\t\t\t// technically this method is successful if there's nothing to delete\n-\t\t\t\tlistener.onComplete(true);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tinternalInterface.sendRequests(deleteCommands, new OnMultipleRequestListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onUpdate(int remainingRequests) {\n-\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onFinished() {\n-\t\t\t\tDebugTool.logInfo(\"Successfully deleted cells\");\n-\t\t\t\tif (listener != null){\n-\t\t\t\t\tlistener.onComplete(true);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\tprivate List<MenuCell> cloneMenuCellsList(List<MenuCell> originalList) {\n-\t\tif (originalList == null) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tList<MenuCell> clone = new ArrayList<>();\n-\t\tfor (MenuCell menuCell : originalList) {\n-\t\t\tclone.add(menuCell.clone());\n-\t\t}\n-\t\treturn clone;\n-\t}\n+    // UPDATING SYSTEM\n+\n+    // ROOT MENU\n+\n+    private void updateMenuAndDetermineBestUpdateMethod() {\n+\n+        if (currentHMILevel == null || currentHMILevel.equals(HMILevel.HMI_NONE) || currentSystemContext.equals(SystemContext.SYSCTXT_MENU)) {\n+            // We are in NONE or the menu is in use, bail out of here\n+            DebugTool.logInfo(TAG, \"HMI in None or System Context Menu, returning\");\n+            waitingOnHMIUpdate = true;\n+            waitingUpdateMenuCells = menuCells;\n+            return;\n+        }\n+\n+        if (inProgressUpdate != null && inProgressUpdate.size() > 0) {\n+            // there's an in-progress update so this needs to wait\n+            DebugTool.logInfo(TAG, \"There is an in progress Menu Update, returning\");\n+            hasQueuedUpdate = true;\n+            return;\n+        }\n+\n+        // Checks against what the developer set for update mode and against the display type\n+        // to determine how the menu will be updated. This has the ability to be changed during\n+        // a session.\n+        if (checkUpdateMode(dynamicMenuUpdatesMode, displayType)) {\n+            // run the lists through the new algorithm\n+            RunScore rootScore = runMenuCompareAlgorithm(oldMenuCells, menuCells);\n+            if (rootScore == null) {\n+                // send initial menu (score will return null)\n+                // make a copy of our current cells\n+                DebugTool.logInfo(TAG, \"Creating initial Menu\");\n+                // Set the IDs if needed\n+                lastMenuId = menuCellIdMin;\n+                updateIdsOnMenuCells(menuCells, parentIdNotFound);\n+                this.oldMenuCells = new ArrayList<>(menuCells);\n+                createAndSendEntireMenu();\n+            } else {\n+                DebugTool.logInfo(TAG, \"Dynamically Updating Menu\");\n+                if (menuCells.size() == 0 && (oldMenuCells != null && oldMenuCells.size() > 0)) {\n+                    // the dev wants to clear the menu. We have old cells and an empty array of new ones.\n+                    deleteMenuWhenNewCellsEmpty();\n+                } else {\n+                    // lets dynamically update the root menu\n+                    dynamicallyUpdateRootMenu(rootScore);\n+                }\n+            }\n+        } else {\n+            // we are in compatibility mode\n+            DebugTool.logInfo(TAG, \"Updating menus in compatibility mode\");\n+            lastMenuId = menuCellIdMin;\n+            updateIdsOnMenuCells(menuCells, parentIdNotFound);\n+            // if the old cell array is not null, we want to delete the entire thing, else copy the new array\n+            if (oldMenuCells == null) {\n+                this.oldMenuCells = new ArrayList<>(menuCells);\n+            }\n+            createAndSendEntireMenu();\n+        }\n+    }\n+\n+    private boolean checkUpdateMode(DynamicMenuUpdatesMode updateMode, String displayType) {\n+\n+        if (updateMode.equals(DynamicMenuUpdatesMode.ON_WITH_COMPAT_MODE)) {\n+            if (displayType == null) {\n+                return true;\n+            }\n+            return (!displayType.equals(DisplayType.GEN3_8_INCH.toString()));\n+\n+        } else if (updateMode.equals(DynamicMenuUpdatesMode.FORCE_OFF)) {\n+            return false;\n+        } else if (updateMode.equals(DynamicMenuUpdatesMode.FORCE_ON)) {\n+            return true;\n+        }\n+\n+        return true;\n+    }\n+\n+    private void deleteMenuWhenNewCellsEmpty() {\n+        sendDeleteRPCs(createDeleteRPCsForCells(oldMenuCells), new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                inProgressUpdate = null;\n+\n+                if (!success) {\n+                    DebugTool.logError(TAG, \"Error Sending Current Menu\");\n+                } else {\n+                    DebugTool.logInfo(TAG, \"Successfully Cleared Menu\");\n+                }\n+                oldMenuCells = null;\n+                if (hasQueuedUpdate) {\n+                    hasQueuedUpdate = false;\n+                }\n+            }\n+        });\n+    }\n+\n+    private void dynamicallyUpdateRootMenu(RunScore bestRootScore) {\n+\n+        // we need to run through the keeps and see if they have subCells, as they also need to be run\n+        // through the compare function.\n+        List<Integer> newIntArray = bestRootScore.getCurrentMenu();\n+        List<Integer> oldIntArray = bestRootScore.getOldMenu();\n+        List<RPCRequest> deleteCommands;\n+\n+        // Set up deletes\n+        List<MenuCell> deletes = new ArrayList<>();\n+        keepsOld = new ArrayList<>();\n+        for (int x = 0; x < oldIntArray.size(); x++) {\n+            Integer old = oldIntArray.get(x);\n+            if (old.equals(MARKED_FOR_DELETION)) {\n+                // grab cell to send to function to create delete commands\n+                deletes.add(oldMenuCells.get(x));\n+            } else if (old.equals(KEEP)) {\n+                keepsOld.add(oldMenuCells.get(x));\n+            }\n+        }\n+        // create the delete commands\n+        deleteCommands = createDeleteRPCsForCells(deletes);\n+\n+        // Set up the adds\n+        List<MenuCell> adds = new ArrayList<>();\n+        keepsNew = new ArrayList<>();\n+        for (int x = 0; x < newIntArray.size(); x++) {\n+            Integer newInt = newIntArray.get(x);\n+            if (newInt.equals(MARKED_FOR_ADDITION)) {\n+                // grab cell to send to function to create add commands\n+                adds.add(menuCells.get(x));\n+            } else if (newInt.equals(KEEP)) {\n+                keepsNew.add(menuCells.get(x));\n+            }\n+        }\n+        updateIdsOnDynamicCells(adds);\n+        // this is needed for the onCommands to still work\n+        transferIdsToKeptCells(keepsNew);\n+\n+        if (adds.size() > 0) {\n+            DebugTool.logInfo(TAG, \"Sending root menu updates\");\n+            sendDynamicRootMenuRPCs(deleteCommands, adds);\n+        } else {\n+            DebugTool.logInfo(TAG, \"All root menu items are kept. Check the sub menus\");\n+            runSubMenuCompareAlgorithm();\n+        }\n+    }\n+\n+    // OTHER\n+\n+    private void sendDynamicRootMenuRPCs(List<RPCRequest> deleteCommands, final List<MenuCell> updatedCells) {\n+        sendDeleteRPCs(deleteCommands, new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                createAndSendMenuCellRPCs(updatedCells, new CompletionListener() {\n+                    @Override\n+                    public void onComplete(boolean success) {\n+                        inProgressUpdate = null;\n+\n+                        if (!success) {\n+                            DebugTool.logError(TAG, \"Error Sending Current Menu\");\n+                        }\n+\n+                        if (hasQueuedUpdate) {\n+                            //setMenuCells(waitingUpdateMenuCells);\n+                            hasQueuedUpdate = false;\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    // SUB MENUS\n+\n+    // This is called in the listener in the sendMenu and sendSubMenuCommands Methods\n+    private void runSubMenuCompareAlgorithm() {\n+        // any cells that were re-added have their sub-cells added with them\n+        // at this point all we care about are the cells that were deemed equal and kept.\n+        if (keepsNew == null || keepsNew.size() == 0) {\n+            return;\n+        }\n+\n+        List<SubCellCommandList> commandLists = new ArrayList<>();\n+\n+        for (int i = 0; i < keepsNew.size(); i++) {\n+\n+            MenuCell keptCell = keepsNew.get(i);\n+            MenuCell oldKeptCell = keepsOld.get(i);\n+\n+            if (oldKeptCell.getSubCells() != null && oldKeptCell.getSubCells().size() > 0 && keptCell.getSubCells() != null && keptCell.getSubCells().size() > 0) {\n+                // ACTUAL LOGIC\n+                RunScore subScore = compareOldAndNewLists(oldKeptCell.getSubCells(), keptCell.getSubCells());\n+\n+                if (subScore != null) {\n+                    DebugTool.logInfo(TAG, \"Sub menu Run Score: \" + oldKeptCell.getTitle() + \" Score: \" + subScore.getScore());\n+                    SubCellCommandList commandList = new SubCellCommandList(oldKeptCell.getTitle(), oldKeptCell.getCellId(), subScore, oldKeptCell.getSubCells(), keptCell.getSubCells());\n+                    commandLists.add(commandList);\n+                }\n+            }\n+        }\n+        createSubMenuDynamicCommands(commandLists);\n+    }\n+\n+    private void createSubMenuDynamicCommands(final List<SubCellCommandList> commandLists) {\n+\n+        // break out\n+        if (commandLists.size() == 0) {\n+            if (inProgressUpdate != null) {\n+                inProgressUpdate = null;\n+            }\n+\n+            if (hasQueuedUpdate) {\n+                DebugTool.logInfo(TAG, \"Menu Manager has waiting updates, sending now\");\n+                setMenuCells(waitingUpdateMenuCells);\n+                hasQueuedUpdate = false;\n+            }\n+            DebugTool.logInfo(TAG, \"All menu updates, including sub menus - done.\");\n+            return;\n+        }\n+\n+        final SubCellCommandList commandList = commandLists.remove(0);\n+\n+        DebugTool.logInfo(TAG, \"Creating and Sending Dynamic Sub Commands For Root Menu Cell: \" + commandList.getMenuTitle());\n+\n+        // grab the scores\n+        RunScore score = commandList.getListsScore();\n+        List<Integer> newIntArray = score.getCurrentMenu();\n+        List<Integer> oldIntArray = score.getOldMenu();\n+\n+        // Grab the sub-menus from the parent cell\n+        final List<MenuCell> oldCells = commandList.getOldList();\n+        final List<MenuCell> newCells = commandList.getNewList();\n+\n+        // Create the list for the adds\n+        List<MenuCell> subCellKeepsNew = new ArrayList<>();\n+\n+        List<RPCRequest> deleteCommands;\n+\n+        // Set up deletes\n+        List<MenuCell> deletes = new ArrayList<>();\n+        for (int x = 0; x < oldIntArray.size(); x++) {\n+            Integer old = oldIntArray.get(x);\n+            if (old.equals(MARKED_FOR_DELETION)) {\n+                // grab cell to send to function to create delete commands\n+                deletes.add(oldCells.get(x));\n+            }\n+        }\n+        // create the delete commands\n+        deleteCommands = createDeleteRPCsForCells(deletes);\n+\n+        // Set up the adds\n+        List<MenuCell> adds = new ArrayList<>();\n+        for (int x = 0; x < newIntArray.size(); x++) {\n+            Integer newInt = newIntArray.get(x);\n+            if (newInt.equals(MARKED_FOR_ADDITION)) {\n+                // grab cell to send to function to create add commands\n+                adds.add(newCells.get(x));\n+            } else if (newInt.equals(KEEP)) {\n+                subCellKeepsNew.add(newCells.get(x));\n+            }\n+        }\n+        final List<MenuCell> addsWithNewIds = updateIdsOnDynamicSubCells(oldCells, adds, commandList.getParentId());\n+        // this is needed for the onCommands to still work\n+        transferIdsToKeptSubCells(oldCells, subCellKeepsNew);\n+\n+        sendDeleteRPCs(deleteCommands, new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                if (addsWithNewIds != null && addsWithNewIds.size() > 0) {\n+                    createAndSendDynamicSubMenuRPCs(newCells, addsWithNewIds, new CompletionListener() {\n+                        @Override\n+                        public void onComplete(boolean success) {\n+                            // recurse through next sub list\n+                            DebugTool.logInfo(TAG, \"Finished Sending Dynamic Sub Commands For Root Menu Cell: \" + commandList.getMenuTitle());\n+                            createSubMenuDynamicCommands(commandLists);\n+                        }\n+                    });\n+                } else {\n+                    // no add commands to send, recurse through next sub list\n+                    DebugTool.logInfo(TAG, \"Finished Sending Dynamic Sub Commands For Root Menu Cell: \" + commandList.getMenuTitle());\n+                    createSubMenuDynamicCommands(commandLists);\n+                }\n+            }\n+        });\n+    }\n+\n+    // OTHER HELPER METHODS:\n+\n+    // COMPARISONS\n+\n+    RunScore runMenuCompareAlgorithm(List<MenuCell> oldCells, List<MenuCell> newCells) {\n+\n+        if (oldCells == null || oldCells.size() == 0) {\n+            return null;\n+        }\n+\n+        RunScore bestScore = compareOldAndNewLists(oldCells, newCells);\n+        DebugTool.logInfo(TAG, \"Best menu run score: \" + bestScore.getScore());\n+\n+        return bestScore;\n+    }\n+\n+    private RunScore compareOldAndNewLists(List<MenuCell> oldCells, List<MenuCell> newCells) {\n+\n+        RunScore bestRunScore = null;\n+\n+        // This first loop is for each 'run'\n+        for (int run = 0; run < oldCells.size(); run++) {\n+\n+            List<Integer> oldArray = new ArrayList<>(oldCells.size());\n+            List<Integer> newArray = new ArrayList<>(newCells.size());\n+\n+            // Set the statuses\n+            setDeleteStatus(oldCells.size(), oldArray);\n+            setAddStatus(newCells.size(), newArray);\n+\n+            int startIndex = 0;\n+\n+            // Keep items that appear in both lists\n+            for (int oldItems = run; oldItems < oldCells.size(); oldItems++) {\n+\n+                for (int newItems = startIndex; newItems < newCells.size(); newItems++) {\n+\n+                    if (oldCells.get(oldItems).equals(newCells.get(newItems))) {\n+                        oldArray.set(oldItems, KEEP);\n+                        newArray.set(newItems, KEEP);\n+                        // set the new start index\n+                        startIndex = newItems + 1;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            // Calculate number of adds, or the 'score' for this run\n+            int numberOfAdds = 0;\n+\n+            for (int x = 0; x < newArray.size(); x++) {\n+                if (newArray.get(x).equals(MARKED_FOR_ADDITION)) {\n+                    numberOfAdds++;\n+                }\n+            }\n+\n+            // see if we have a new best score and set it if we do\n+            if (bestRunScore == null || numberOfAdds < bestRunScore.getScore()) {\n+                bestRunScore = new RunScore(numberOfAdds, oldArray, newArray);\n+            }\n+\n+        }\n+        return bestRunScore;\n+    }\n+\n+    private void setDeleteStatus(Integer size, List<Integer> oldArray) {\n+        for (int i = 0; i < size; i++) {\n+            oldArray.add(MARKED_FOR_DELETION);\n+        }\n+    }\n+\n+    private void setAddStatus(Integer size, List<Integer> newArray) {\n+        for (int i = 0; i < size; i++) {\n+            newArray.add(MARKED_FOR_ADDITION);\n+        }\n+    }\n+\n+    // ARTWORKS\n+\n+    private List<SdlArtwork> findAllArtworksToBeUploadedFromCells(List<MenuCell> cells) {\n+        // Make sure we can use images in the menus\n+        if (!supportsImages()) {\n+            return new ArrayList<>();\n+        }\n+\n+        List<SdlArtwork> artworks = new ArrayList<>();\n+        for (MenuCell cell : cells) {\n+            if (artworkNeedsUpload(cell.getIcon())) {\n+                artworks.add(cell.getIcon());\n+            }\n+            if (cell.getSubCells() != null && cell.getSubCells().size() > 0) {\n+                artworks.addAll(findAllArtworksToBeUploadedFromCells(cell.getSubCells()));\n+            }\n+        }\n+\n+        return artworks;\n+    }\n+\n+    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n+    private boolean supportsImages() {\n+        return defaultMainWindowCapability == null || ManagerUtility.WindowCapabilityUtility.hasImageFieldOfName(defaultMainWindowCapability, ImageFieldName.cmdIcon);\n+    }\n+\n+    private boolean artworkNeedsUpload(SdlArtwork artwork) {\n+        if (fileManager.get() != null) {\n+            return (artwork != null && !fileManager.get().hasUploadedFile(artwork) && !artwork.isStaticIcon());\n+        }\n+        return false;\n+    }\n+\n+    // IDs\n+\n+    private void updateIdsOnDynamicCells(List<MenuCell> dynamicCells) {\n+        if (menuCells != null && menuCells.size() > 0 && dynamicCells != null && dynamicCells.size() > 0) {\n+            for (int z = 0; z < menuCells.size(); z++) {\n+                MenuCell mainCell = menuCells.get(z);\n+                for (int i = 0; i < dynamicCells.size(); i++) {\n+                    MenuCell dynamicCell = dynamicCells.get(i);\n+                    if (mainCell.equals(dynamicCell)) {\n+                        int newId = ++lastMenuId;\n+                        menuCells.get(z).setCellId(newId);\n+                        dynamicCells.get(i).setCellId(newId);\n+\n+                        if (mainCell.getSubCells() != null && mainCell.getSubCells().size() > 0) {\n+                            updateIdsOnMenuCells(mainCell.getSubCells(), mainCell.getCellId());\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private List<MenuCell> updateIdsOnDynamicSubCells(List<MenuCell> oldList, List<MenuCell> dynamicCells, Integer parentId) {\n+        if (oldList != null && oldList.size() > 0 && dynamicCells != null && dynamicCells.size() > 0) {\n+            for (int z = 0; z < oldList.size(); z++) {\n+                MenuCell mainCell = oldList.get(z);\n+                for (int i = 0; i < dynamicCells.size(); i++) {\n+                    MenuCell dynamicCell = dynamicCells.get(i);\n+                    if (mainCell.equals(dynamicCell)) {\n+                        int newId = ++lastMenuId;\n+                        oldList.get(z).setCellId(newId);\n+                        dynamicCells.get(i).setParentCellId(parentId);\n+                        dynamicCells.get(i).setCellId(newId);\n+                    } else {\n+                        int newId = ++lastMenuId;\n+                        dynamicCells.get(i).setParentCellId(parentId);\n+                        dynamicCells.get(i).setCellId(newId);\n+                    }\n+                }\n+            }\n+            return dynamicCells;\n+        }\n+        return null;\n+    }\n+\n+    private void updateIdsOnMenuCells(List<MenuCell> cells, int parentId) {\n+        for (MenuCell cell : cells) {\n+            int newId = ++lastMenuId;\n+            cell.setCellId(newId);\n+            cell.setParentCellId(parentId);\n+            if (cell.getSubCells() != null && cell.getSubCells().size() > 0) {\n+                updateIdsOnMenuCells(cell.getSubCells(), cell.getCellId());\n+            }\n+        }\n+    }\n+\n+    private void transferIdsToKeptCells(List<MenuCell> keeps) {\n+        for (int z = 0; z < oldMenuCells.size(); z++) {\n+            MenuCell oldCell = oldMenuCells.get(z);\n+            for (int i = 0; i < keeps.size(); i++) {\n+                MenuCell keptCell = keeps.get(i);\n+                if (oldCell.equals(keptCell)) {\n+                    keptCell.setCellId(oldCell.getCellId());\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void transferIdsToKeptSubCells(List<MenuCell> old, List<MenuCell> keeps) {\n+        for (int z = 0; z < old.size(); z++) {\n+            MenuCell oldCell = old.get(z);\n+            for (int i = 0; i < keeps.size(); i++) {\n+                MenuCell keptCell = keeps.get(i);\n+                if (oldCell.equals(keptCell)) {\n+                    keptCell.setCellId(oldCell.getCellId());\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    // DELETES\n+\n+    private List<RPCRequest> createDeleteRPCsForCells(List<MenuCell> cells) {\n+        List<RPCRequest> deletes = new ArrayList<>();\n+        for (MenuCell cell : cells) {\n+            if (cell.getSubCells() == null) {\n+                DeleteCommand delete = new DeleteCommand(cell.getCellId());\n+                deletes.add(delete);\n+            } else {\n+                DeleteSubMenu delete = new DeleteSubMenu(cell.getCellId());\n+                deletes.add(delete);\n+            }\n+        }\n+        return deletes;\n+    }\n+\n+    // COMMANDS / SUBMENU RPCs\n+\n+    private List<RPCRequest> mainMenuCommandsForCells(List<MenuCell> cellsToAdd, boolean shouldHaveArtwork) {\n+        List<RPCRequest> builtCommands = new ArrayList<>();\n+\n+        // We need the index so we will use this type of loop\n+        for (int z = 0; z < menuCells.size(); z++) {\n+            MenuCell mainCell = menuCells.get(z);\n+            for (int i = 0; i < cellsToAdd.size(); i++) {\n+                MenuCell addCell = cellsToAdd.get(i);\n+                if (mainCell.equals(addCell)) {\n+                    if (addCell.getSubCells() != null && addCell.getSubCells().size() > 0) {\n+                        builtCommands.add(subMenuCommandForMenuCell(addCell, shouldHaveArtwork, z));\n+                    } else {\n+                        builtCommands.add(commandForMenuCell(addCell, shouldHaveArtwork, z));\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+        return builtCommands;\n+    }\n+\n+    private List<RPCRequest> subMenuCommandsForCells(List<MenuCell> cells, boolean shouldHaveArtwork) {\n+        List<RPCRequest> builtCommands = new ArrayList<>();\n+        for (MenuCell cell : cells) {\n+            if (cell.getSubCells() != null && cell.getSubCells().size() > 0) {\n+                builtCommands.addAll(allCommandsForCells(cell.getSubCells(), shouldHaveArtwork));\n+            }\n+        }\n+        return builtCommands;\n+    }\n+\n+    List<RPCRequest> allCommandsForCells(List<MenuCell> cells, boolean shouldHaveArtwork) {\n+        List<RPCRequest> builtCommands = new ArrayList<>();\n+\n+        // We need the index so we will use this type of loop\n+        for (int i = 0; i < cells.size(); i++) {\n+            MenuCell cell = cells.get(i);\n+            if (cell.getSubCells() != null && cell.getSubCells().size() > 0) {\n+                builtCommands.add(subMenuCommandForMenuCell(cell, shouldHaveArtwork, i));\n+                // recursively grab the commands for all the sub cells\n+                builtCommands.addAll(allCommandsForCells(cell.getSubCells(), shouldHaveArtwork));\n+            } else {\n+                builtCommands.add(commandForMenuCell(cell, shouldHaveArtwork, i));\n+            }\n+        }\n+        return builtCommands;\n+    }\n+\n+    private List<RPCRequest> createCommandsForDynamicSubCells(List<MenuCell> oldMenuCells, List<MenuCell> cells, boolean shouldHaveArtwork) {\n+        List<RPCRequest> builtCommands = new ArrayList<>();\n+        for (int z = 0; z < oldMenuCells.size(); z++) {\n+            MenuCell oldCell = oldMenuCells.get(z);\n+            for (int i = 0; i < cells.size(); i++) {\n+                MenuCell cell = cells.get(i);\n+                if (cell.equals(oldCell)) {\n+                    builtCommands.add(commandForMenuCell(cell, shouldHaveArtwork, z));\n+                    break;\n+                }\n+            }\n+        }\n+        return builtCommands;\n+    }\n+\n+    private AddCommand commandForMenuCell(MenuCell cell, boolean shouldHaveArtwork, int position) {\n+\n+        MenuParams params = new MenuParams(cell.getTitle());\n+        params.setParentID(cell.getParentCellId() != MAX_ID ? cell.getParentCellId() : null);\n+        params.setPosition(position);\n+\n+        AddCommand command = new AddCommand(cell.getCellId());\n+        command.setMenuParams(params);\n+        if (cell.getVoiceCommands() != null && !cell.getVoiceCommands().isEmpty()) {\n+            command.setVrCommands(cell.getVoiceCommands());\n+        } else {\n+            command.setVrCommands(null);\n+        }\n+        command.setCmdIcon((cell.getIcon() != null && shouldHaveArtwork) ? cell.getIcon().getImageRPC() : null);\n+\n+        return command;\n+    }\n+\n+    private AddSubMenu subMenuCommandForMenuCell(MenuCell cell, boolean shouldHaveArtwork, int position) {\n+        AddSubMenu subMenu = new AddSubMenu(cell.getCellId(), cell.getTitle());\n+        subMenu.setPosition(position);\n+        if (cell.getSubMenuLayout() != null) {\n+            subMenu.setMenuLayout(cell.getSubMenuLayout());\n+        } else if (menuConfiguration != null && menuConfiguration.getSubMenuLayout() != null) {\n+            subMenu.setMenuLayout(menuConfiguration.getSubMenuLayout());\n+        }\n+        subMenu.setMenuIcon((shouldHaveArtwork && (cell.getIcon() != null && cell.getIcon().getImageRPC() != null)) ? cell.getIcon().getImageRPC() : null);\n+        return subMenu;\n+    }\n+\n+    // CELL COMMAND HANDLING\n+\n+    private boolean callListenerForCells(List<MenuCell> cells, OnCommand command) {\n+        if (cells != null && cells.size() > 0 && command != null) {\n+            for (MenuCell cell : cells) {\n+\n+                if (cell.getCellId() == command.getCmdID() && cell.getMenuSelectionListener() != null) {\n+                    cell.getMenuSelectionListener().onTriggered(command.getTriggerSource());\n+                    return true;\n+                }\n+                if (cell.getSubCells() != null && cell.getSubCells().size() > 0) {\n+                    // for each cell, if it has sub cells, recursively loop through those as well\n+                    if (callListenerForCells(cell.getSubCells(), command)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    // LISTENERS\n+\n+    private void addListeners() {\n+        // DISPLAY CAPABILITIES - via SCM\n+        onDisplaysCapabilityListener = new OnSystemCapabilityListener() {\n+            @Override\n+            public void onCapabilityRetrieved(Object capability) {\n+                // instead of using the parameter it's more safe to use the convenience method\n+                List<DisplayCapability> capabilities = SystemCapabilityManager.convertToList(capability, DisplayCapability.class);\n+                if (capabilities == null || capabilities.size() == 0) {\n+                    DebugTool.logError(TAG, \"SoftButton Manager - Capabilities sent here are null or empty\");\n+                } else {\n+                    DisplayCapability display = capabilities.get(0);\n+                    displayType = display.getDisplayName();\n+                    for (WindowCapability windowCapability : display.getWindowCapabilities()) {\n+                        int currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+                        if (currentWindowID == PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                            defaultMainWindowCapability = windowCapability;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void onError(String info) {\n+                DebugTool.logError(TAG, \"Display Capability cannot be retrieved\");\n+                defaultMainWindowCapability = null;\n+            }\n+        };\n+        if (internalInterface.getSystemCapabilityManager() != null) {\n+            this.internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+        }\n+\n+        // HMI UPDATES\n+        hmiListener = new OnRPCNotificationListener() {\n+            @Override\n+            public void onNotified(RPCNotification notification) {\n+                OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                    return;\n+                }\n+                HMILevel oldHMILevel = currentHMILevel;\n+                currentHMILevel = onHMIStatus.getHmiLevel();\n+\n+                // Auto-send an updated menu if we were in NONE and now we are not, and we need an update\n+                if (oldHMILevel == HMILevel.HMI_NONE && currentHMILevel != HMILevel.HMI_NONE && currentSystemContext != SystemContext.SYSCTXT_MENU) {\n+                    if (waitingOnHMIUpdate) {\n+                        DebugTool.logInfo(TAG, \"We now have proper HMI, sending waiting update\");\n+                        setMenuCells(waitingUpdateMenuCells);\n+                        waitingUpdateMenuCells.clear();\n+                        return;\n+                    }\n+                }\n+\n+                // If we don't check for this and only update when not in the menu, there can be IN_USE errors, especially with submenus.\n+                // We also don't want to encourage changing out the menu while the user is using it for usability reasons.\n+                SystemContext oldContext = currentSystemContext;\n+                currentSystemContext = onHMIStatus.getSystemContext();\n+\n+                if (oldContext == SystemContext.SYSCTXT_MENU && currentSystemContext != SystemContext.SYSCTXT_MENU && currentHMILevel != HMILevel.HMI_NONE) {\n+                    if (waitingOnHMIUpdate) {\n+                        DebugTool.logInfo(TAG, \"We now have a proper system context, sending waiting update\");\n+                        setMenuCells(waitingUpdateMenuCells);\n+                        waitingUpdateMenuCells.clear();\n+                    }\n+                }\n+            }\n+        };\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+\n+        // COMMANDS\n+        commandListener = new OnRPCNotificationListener() {\n+            @Override\n+            public void onNotified(RPCNotification notification) {\n+                OnCommand onCommand = (OnCommand) notification;\n+                callListenerForCells(menuCells, onCommand);\n+            }\n+        };\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_COMMAND, commandListener);\n+    }\n+\n+    // SEND NEW MENU ITEMS\n+\n+    private void createAndSendEntireMenu() {\n+\n+        if (currentHMILevel == null || currentHMILevel.equals(HMILevel.HMI_NONE) || currentSystemContext.equals(SystemContext.SYSCTXT_MENU)) {\n+            // We are in NONE or the menu is in use, bail out of here\n+            DebugTool.logInfo(TAG, \"HMI in None or System Context Menu, returning\");\n+            waitingOnHMIUpdate = true;\n+            waitingUpdateMenuCells = menuCells;\n+            return;\n+        }\n+\n+        if (inProgressUpdate != null && inProgressUpdate.size() > 0) {\n+            // there's an in-progress update so this needs to wait\n+            DebugTool.logInfo(TAG, \"There is an in progress Menu Update, returning\");\n+            hasQueuedUpdate = true;\n+            return;\n+        }\n+\n+        deleteRootMenu(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                createAndSendMenuCellRPCs(menuCells, new CompletionListener() {\n+                    @Override\n+                    public void onComplete(boolean success) {\n+                        inProgressUpdate = null;\n+\n+                        if (!success) {\n+                            DebugTool.logError(TAG, \"Error Sending Current Menu\");\n+                        }\n+\n+                        if (hasQueuedUpdate) {\n+                            setMenuCells(waitingUpdateMenuCells);\n+                            hasQueuedUpdate = false;\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    private void createAndSendMenuCellRPCs(final List<MenuCell> menu, final CompletionListener listener) {\n+\n+        if (menu.size() == 0) {\n+            if (listener != null) {\n+                // This can be considered a success if the user was clearing out their menu\n+                listener.onComplete(true);\n+            }\n+            return;\n+        }\n+\n+        List<RPCRequest> mainMenuCommands;\n+        final List<RPCRequest> subMenuCommands;\n+\n+        if (findAllArtworksToBeUploadedFromCells(menu).size() > 0 || !supportsImages()) {\n+            // Send artwork-less menu\n+            mainMenuCommands = mainMenuCommandsForCells(menu, false);\n+            subMenuCommands = subMenuCommandsForCells(menu, false);\n+        } else {\n+            mainMenuCommands = mainMenuCommandsForCells(menu, true);\n+            subMenuCommands = subMenuCommandsForCells(menu, true);\n+        }\n+\n+        // add all built commands to inProgressUpdate\n+        inProgressUpdate = new ArrayList<>(mainMenuCommands);\n+        inProgressUpdate.addAll(subMenuCommands);\n+\n+        internalInterface.sendSequentialRPCs(mainMenuCommands, new OnMultipleRequestListener() {\n+            @Override\n+            public void onUpdate(int remainingRequests) {\n+                // nothing here\n+            }\n+\n+            @Override\n+            public void onFinished() {\n+\n+                if (subMenuCommands.size() > 0) {\n+                    sendSubMenuCommandRPCs(subMenuCommands, listener);\n+                    DebugTool.logInfo(TAG, \"Finished sending main menu commands. Sending sub menu commands.\");\n+                } else {\n+\n+                    if (keepsNew != null && keepsNew.size() > 0) {\n+                        runSubMenuCompareAlgorithm();\n+                    } else {\n+                        inProgressUpdate = null;\n+                        DebugTool.logInfo(TAG, \"Finished sending main menu commands.\");\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void onResponse(int correlationId, RPCResponse response) {\n+                if (response.getSuccess()) {\n+                    try {\n+                        DebugTool.logInfo(TAG, \"Main Menu response: \" + response.serializeJSON().toString());\n+                    } catch (JSONException e) {\n+                        e.printStackTrace();\n+                    }\n+                } else {\n+                    DebugTool.logError(TAG, \"Result: \" + response.getResultCode() + \" Info: \" + response.getInfo());\n+                }\n+            }\n+        });\n+    }\n+\n+    private void sendSubMenuCommandRPCs(List<RPCRequest> commands, final CompletionListener listener) {\n+\n+        internalInterface.sendSequentialRPCs(commands, new OnMultipleRequestListener() {\n+            @Override\n+            public void onUpdate(int remainingRequests) {\n+\n+            }\n+\n+            @Override\n+            public void onFinished() {\n+\n+                if (keepsNew != null && keepsNew.size() > 0) {\n+                    runSubMenuCompareAlgorithm();\n+                } else {\n+                    DebugTool.logInfo(TAG, \"Finished Updating Menu\");\n+                    inProgressUpdate = null;\n+\n+                    if (listener != null) {\n+                        listener.onComplete(true);\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void onResponse(int correlationId, RPCResponse response) {\n+                if (response.getSuccess()) {\n+                    try {\n+                        DebugTool.logInfo(TAG, \"Sub Menu response: \" + response.serializeJSON().toString());\n+                    } catch (JSONException e) {\n+                        e.printStackTrace();\n+                    }\n+                } else {\n+                    DebugTool.logError(TAG, \"Failed to send sub menu commands: \" + response.getInfo());\n+                    if (listener != null) {\n+                        listener.onComplete(false);\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    private void createAndSendDynamicSubMenuRPCs(List<MenuCell> newMenu, final List<MenuCell> adds, final CompletionListener listener) {\n+\n+        if (adds.size() == 0) {\n+            if (listener != null) {\n+                // This can be considered a success if the user was clearing out their menu\n+                DebugTool.logError(TAG, \"Called createAndSendDynamicSubMenuRPCs with empty menu\");\n+                listener.onComplete(true);\n+            }\n+            return;\n+        }\n+\n+        List<RPCRequest> mainMenuCommands;\n+\n+        if (findAllArtworksToBeUploadedFromCells(adds).size() > 0 || !supportsImages()) {\n+            // Send artwork-less menu\n+            mainMenuCommands = createCommandsForDynamicSubCells(newMenu, adds, false);\n+        } else {\n+            mainMenuCommands = createCommandsForDynamicSubCells(newMenu, adds, true);\n+        }\n+\n+        internalInterface.sendSequentialRPCs(mainMenuCommands, new OnMultipleRequestListener() {\n+            @Override\n+            public void onUpdate(int remainingRequests) {\n+                // nothing here\n+            }\n+\n+            @Override\n+            public void onFinished() {\n+\n+                if (listener != null) {\n+                    listener.onComplete(true);\n+                }\n+            }\n+\n+            @Override\n+            public void onResponse(int correlationId, RPCResponse response) {\n+                if (response.getSuccess()) {\n+                    try {\n+                        DebugTool.logInfo(TAG, \"Dynamic Sub Menu response: \" + response.serializeJSON().toString());\n+                    } catch (JSONException e) {\n+                        e.printStackTrace();\n+                    }\n+                } else {\n+                    DebugTool.logError(TAG, \"Result: \" + response.getResultCode() + \" Info: \" + response.getInfo());\n+                }\n+            }\n+        });\n+    }\n+\n+    // DELETE OLD MENU ITEMS\n+\n+    private void deleteRootMenu(final CompletionListener listener) {\n+\n+        if (oldMenuCells == null || oldMenuCells.size() == 0) {\n+            if (listener != null) {\n+                // technically this method is successful if there's nothing to delete\n+                DebugTool.logInfo(TAG, \"No old cells to delete, returning\");\n+                listener.onComplete(true);\n+            }\n+        } else {\n+            sendDeleteRPCs(createDeleteRPCsForCells(oldMenuCells), listener);\n+        }\n+    }\n+\n+    private void sendDeleteRPCs(List<RPCRequest> deleteCommands, final CompletionListener listener) {\n+        if (oldMenuCells != null && oldMenuCells.size() == 0) {\n+            if (listener != null) {\n+                // technically this method is successful if there's nothing to delete\n+                DebugTool.logInfo(TAG, \"No old cells to delete, returning\");\n+                listener.onComplete(true);\n+            }\n+            return;\n+        }\n+\n+        if (deleteCommands == null || deleteCommands.size() == 0) {\n+            // no dynamic deletes required. return\n+            if (listener != null) {\n+                // technically this method is successful if there's nothing to delete\n+                listener.onComplete(true);\n+            }\n+            return;\n+        }\n+\n+        internalInterface.sendRPCs(deleteCommands, new OnMultipleRequestListener() {\n+            @Override\n+            public void onUpdate(int remainingRequests) {\n+\n+            }\n+\n+            @Override\n+            public void onFinished() {\n+                DebugTool.logInfo(TAG, \"Successfully deleted cells\");\n+                if (listener != null) {\n+                    listener.onComplete(true);\n+                }\n+            }\n+\n+            @Override\n+            public void onResponse(int correlationId, RPCResponse response) {\n+\n+            }\n+        });\n+    }\n+\n+    private List<MenuCell> cloneMenuCellsList(List<MenuCell> originalList) {\n+        if (originalList == null) {\n+            return null;\n+        }\n+\n+        List<MenuCell> clone = new ArrayList<>();\n+        for (MenuCell menuCell : originalList) {\n+            clone.add(menuCell.clone());\n+        }\n+        return clone;\n+    }\n }\n", "next_change": {"commit": "637672b527ccacc8af9167d8341d7f49fb7be985", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\nindex dbf9c211c..6abb4d3d2 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n", "chunk": "@@ -1078,265 +344,71 @@ abstract class BaseMenuManager extends BaseSubManager {\n         internalInterface.addOnRPCNotificationListener(FunctionID.ON_COMMAND, commandListener);\n     }\n \n-    // SEND NEW MENU ITEMS\n-\n-    private void createAndSendEntireMenu() {\n-\n-        if (currentHMILevel == null || currentHMILevel.equals(HMILevel.HMI_NONE) || currentSystemContext.equals(SystemContext.SYSCTXT_MENU)) {\n-            // We are in NONE or the menu is in use, bail out of here\n-            DebugTool.logInfo(TAG, \"HMI in None or System Context Menu, returning\");\n-            waitingOnHMIUpdate = true;\n-            waitingUpdateMenuCells = menuCells;\n-            return;\n-        }\n+    private Queue newTransactionQueue() {\n+        Queue queue = internalInterface.getTaskmaster().createQueue(\"MenuManager\", 7, false);\n+        queue.pause();\n+        return queue;\n+    }\n \n-        if (inProgressUpdate != null && inProgressUpdate.size() > 0) {\n-            // there's an in-progress update so this needs to wait\n-            DebugTool.logInfo(TAG, \"There is an in progress Menu Update, returning\");\n-            hasQueuedUpdate = true;\n-            return;\n+    private void updateTransactionQueueSuspended() {\n+        if (oldHMILevel == HMILevel.HMI_NONE && currentHMILevel != HMILevel.HMI_NONE && currentSystemContext != SystemContext.SYSCTXT_MENU) {\n+            // Resume queue if we were in NONE and now we are not\n+            DebugTool.logInfo(TAG, \"We now have proper HMI, sending waiting update\");\n+            transactionQueue.resume();\n+        } else if (oldSystemContext == SystemContext.SYSCTXT_MENU && currentSystemContext != SystemContext.SYSCTXT_MENU && currentHMILevel != HMILevel.HMI_NONE) {\n+            // If we don't check for this and only update when not in the menu, there can be IN_USE errors, especially with submenus.\n+            // We also don't want to encourage changing out the menu while the user is using it for usability reasons.\n+            DebugTool.logInfo(TAG, \"We now have a proper system context, sending waiting update\");\n+            transactionQueue.resume();\n         }\n-\n-        deleteRootMenu(new CompletionListener() {\n-            @Override\n-            public void onComplete(boolean success) {\n-                createAndSendMenuCellRPCs(menuCells, new CompletionListener() {\n-                    @Override\n-                    public void onComplete(boolean success) {\n-                        inProgressUpdate = null;\n-\n-                        if (!success) {\n-                            DebugTool.logError(TAG, \"Error Sending Current Menu\");\n-                        }\n-\n-                        if (hasQueuedUpdate) {\n-                            setMenuCells(waitingUpdateMenuCells);\n-                            hasQueuedUpdate = false;\n-                        }\n-                    }\n-                });\n-            }\n-        });\n     }\n \n-    private void createAndSendMenuCellRPCs(final List<MenuCell> menu, final CompletionListener listener) {\n-\n-        if (menu.size() == 0) {\n-            if (listener != null) {\n-                // This can be considered a success if the user was clearing out their menu\n-                listener.onComplete(true);\n-            }\n-            return;\n+    private List<MenuCell> cloneMenuCellsList(List<MenuCell> originalList) {\n+        if (originalList == null) {\n+            return null;\n         }\n \n-        List<RPCRequest> mainMenuCommands;\n-        final List<RPCRequest> subMenuCommands;\n-\n-        if (findAllArtworksToBeUploadedFromCells(menu).size() > 0 || !supportsImages()) {\n-            // Send artwork-less menu\n-            mainMenuCommands = mainMenuCommandsForCells(menu, false);\n-            subMenuCommands = subMenuCommandsForCells(menu, false);\n-        } else {\n-            mainMenuCommands = mainMenuCommandsForCells(menu, true);\n-            subMenuCommands = subMenuCommandsForCells(menu, true);\n+        List<MenuCell> clone = new ArrayList<>();\n+        for (MenuCell menuCell : originalList) {\n+            clone.add(menuCell.clone());\n         }\n-\n-        // add all built commands to inProgressUpdate\n-        inProgressUpdate = new ArrayList<>(mainMenuCommands);\n-        inProgressUpdate.addAll(subMenuCommands);\n-\n-        internalInterface.sendSequentialRPCs(mainMenuCommands, new OnMultipleRequestListener() {\n-            @Override\n-            public void onUpdate(int remainingRequests) {\n-                // nothing here\n-            }\n-\n-            @Override\n-            public void onFinished() {\n-\n-                if (subMenuCommands.size() > 0) {\n-                    sendSubMenuCommandRPCs(subMenuCommands, listener);\n-                    DebugTool.logInfo(TAG, \"Finished sending main menu commands. Sending sub menu commands.\");\n-                } else {\n-\n-                    if (keepsNew != null && keepsNew.size() > 0) {\n-                        runSubMenuCompareAlgorithm();\n-                    } else {\n-                        inProgressUpdate = null;\n-                        DebugTool.logInfo(TAG, \"Finished sending main menu commands.\");\n-                    }\n-                }\n-            }\n-\n-            @Override\n-            public void onResponse(int correlationId, RPCResponse response) {\n-                if (response.getSuccess()) {\n-                    try {\n-                        DebugTool.logInfo(TAG, \"Main Menu response: \" + response.serializeJSON().toString());\n-                    } catch (JSONException e) {\n-                        e.printStackTrace();\n-                    }\n-                } else {\n-                    DebugTool.logError(TAG, \"Result: \" + response.getResultCode() + \" Info: \" + response.getInfo());\n-                }\n-            }\n-        });\n-    }\n-\n-    private void sendSubMenuCommandRPCs(List<RPCRequest> commands, final CompletionListener listener) {\n-\n-        internalInterface.sendSequentialRPCs(commands, new OnMultipleRequestListener() {\n-            @Override\n-            public void onUpdate(int remainingRequests) {\n-\n-            }\n-\n-            @Override\n-            public void onFinished() {\n-\n-                if (keepsNew != null && keepsNew.size() > 0) {\n-                    runSubMenuCompareAlgorithm();\n-                } else {\n-                    DebugTool.logInfo(TAG, \"Finished Updating Menu\");\n-                    inProgressUpdate = null;\n-\n-                    if (listener != null) {\n-                        listener.onComplete(true);\n-                    }\n-                }\n-            }\n-\n-            @Override\n-            public void onResponse(int correlationId, RPCResponse response) {\n-                if (response.getSuccess()) {\n-                    try {\n-                        DebugTool.logInfo(TAG, \"Sub Menu response: \" + response.serializeJSON().toString());\n-                    } catch (JSONException e) {\n-                        e.printStackTrace();\n-                    }\n-                } else {\n-                    DebugTool.logError(TAG, \"Failed to send sub menu commands: \" + response.getInfo());\n-                    if (listener != null) {\n-                        listener.onComplete(false);\n-                    }\n-                }\n-            }\n-        });\n+        return clone;\n     }\n \n-    private void createAndSendDynamicSubMenuRPCs(List<MenuCell> newMenu, final List<MenuCell> adds, final CompletionListener listener) {\n-\n-        if (adds.size() == 0) {\n-            if (listener != null) {\n-                // This can be considered a success if the user was clearing out their menu\n-                DebugTool.logError(TAG, \"Called createAndSendDynamicSubMenuRPCs with empty menu\");\n-                listener.onComplete(true);\n-            }\n-            return;\n-        }\n-\n-        List<RPCRequest> mainMenuCommands;\n-\n-        if (findAllArtworksToBeUploadedFromCells(adds).size() > 0 || !supportsImages()) {\n-            // Send artwork-less menu\n-            mainMenuCommands = createCommandsForDynamicSubCells(newMenu, adds, false);\n-        } else {\n-            mainMenuCommands = createCommandsForDynamicSubCells(newMenu, adds, true);\n+    private boolean callListenerForCells(List<MenuCell> cells, OnCommand command) {\n+        if (cells == null || cells.isEmpty() || command == null) {\n+            return false;\n         }\n \n-        internalInterface.sendSequentialRPCs(mainMenuCommands, new OnMultipleRequestListener() {\n-            @Override\n-            public void onUpdate(int remainingRequests) {\n-                // nothing here\n+        for (MenuCell cell : cells) {\n+            if (cell.getCellId() == command.getCmdID() && cell.getMenuSelectionListener() != null) {\n+                cell.getMenuSelectionListener().onTriggered(command.getTriggerSource());\n+                return true;\n             }\n-\n-            @Override\n-            public void onFinished() {\n-\n-                if (listener != null) {\n-                    listener.onComplete(true);\n-                }\n+            if (cell.getSubCells() != null && !cell.getSubCells().isEmpty()) {\n+                // for each cell, if it has sub cells, recursively loop through those as well\n+                return callListenerForCells(cell.getSubCells(), command);\n             }\n+        }\n \n-            @Override\n-            public void onResponse(int correlationId, RPCResponse response) {\n-                if (response.getSuccess()) {\n-                    try {\n-                        DebugTool.logInfo(TAG, \"Dynamic Sub Menu response: \" + response.serializeJSON().toString());\n-                    } catch (JSONException e) {\n-                        e.printStackTrace();\n-                    }\n-                } else {\n-                    DebugTool.logError(TAG, \"Result: \" + response.getResultCode() + \" Info: \" + response.getInfo());\n-                }\n-            }\n-        });\n+        return false;\n     }\n \n-    // DELETE OLD MENU ITEMS\n-\n-    private void deleteRootMenu(final CompletionListener listener) {\n-\n-        if (oldMenuCells == null || oldMenuCells.size() == 0) {\n-            if (listener != null) {\n-                // technically this method is successful if there's nothing to delete\n-                DebugTool.logInfo(TAG, \"No old cells to delete, returning\");\n-                listener.onComplete(true);\n+    private void updatePendingOperationsWithNewMenuConfiguration() {\n+        for (Task task : transactionQueue.getTasksAsList()) {\n+            if (!(task instanceof MenuReplaceOperation)) {\n+                continue;\n             }\n-        } else {\n-            sendDeleteRPCs(createDeleteRPCsForCells(oldMenuCells), listener);\n+            ((MenuReplaceOperation) task).setMenuConfiguration(menuConfiguration);\n         }\n     }\n \n-    private void sendDeleteRPCs(List<RPCRequest> deleteCommands, final CompletionListener listener) {\n-        if (oldMenuCells != null && oldMenuCells.size() == 0) {\n-            if (listener != null) {\n-                // technically this method is successful if there's nothing to delete\n-                DebugTool.logInfo(TAG, \"No old cells to delete, returning\");\n-                listener.onComplete(true);\n-            }\n-            return;\n-        }\n-\n-        if (deleteCommands == null || deleteCommands.size() == 0) {\n-            // no dynamic deletes required. return\n-            if (listener != null) {\n-                // technically this method is successful if there's nothing to delete\n-                listener.onComplete(true);\n+    private void cancelPendingMenuReplaceOperations(){\n+        for (Task operation : transactionQueue.getTasksAsList()) {\n+            if (!(operation instanceof MenuReplaceOperation)) {\n+                continue;\n             }\n-            return;\n+            operation.cancelTask();\n         }\n-\n-        internalInterface.sendRPCs(deleteCommands, new OnMultipleRequestListener() {\n-            @Override\n-            public void onUpdate(int remainingRequests) {\n-\n-            }\n-\n-            @Override\n-            public void onFinished() {\n-                DebugTool.logInfo(TAG, \"Successfully deleted cells\");\n-                if (listener != null) {\n-                    listener.onComplete(true);\n-                }\n-            }\n-\n-            @Override\n-            public void onResponse(int correlationId, RPCResponse response) {\n-\n-            }\n-        });\n-    }\n-\n-    private List<MenuCell> cloneMenuCellsList(List<MenuCell> originalList) {\n-        if (originalList == null) {\n-            return null;\n-        }\n-\n-        List<MenuCell> clone = new ArrayList<>();\n-        for (MenuCell menuCell : originalList) {\n-            clone.add(menuCell.clone());\n-        }\n-        return clone;\n     }\n }\n", "next_change": {"commit": "2cb9b48338a8f10bbc9ebd4b1776d6fecdfead9e", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\nindex 6abb4d3d2..10d84307e 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n", "chunk": "@@ -396,16 +398,16 @@ abstract class BaseMenuManager extends BaseSubManager {\n \n     private void updatePendingOperationsWithNewMenuConfiguration() {\n         for (Task task : transactionQueue.getTasksAsList()) {\n-            if (!(task instanceof MenuReplaceOperation)) {\n+            if (!(task instanceof MenuReplaceStaticOperation)) {\n                 continue;\n             }\n-            ((MenuReplaceOperation) task).setMenuConfiguration(menuConfiguration);\n+            ((MenuReplaceStaticOperation) task).setMenuConfiguration(menuConfiguration);\n         }\n     }\n \n     private void cancelPendingMenuReplaceOperations(){\n         for (Task operation : transactionQueue.getTasksAsList()) {\n-            if (!(operation instanceof MenuReplaceOperation)) {\n+            if (!(operation instanceof MenuReplaceStaticOperation)) {\n                 continue;\n             }\n             operation.cancelTask();\n", "next_change": {"commit": "18094f8fba627d09c8e30e89d0b03ba5bf80b65b", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\nindex 10d84307e..1d7913709 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n", "chunk": "@@ -395,22 +416,4 @@ abstract class BaseMenuManager extends BaseSubManager {\n \n         return false;\n     }\n-\n-    private void updatePendingOperationsWithNewMenuConfiguration() {\n-        for (Task task : transactionQueue.getTasksAsList()) {\n-            if (!(task instanceof MenuReplaceStaticOperation)) {\n-                continue;\n-            }\n-            ((MenuReplaceStaticOperation) task).setMenuConfiguration(menuConfiguration);\n-        }\n-    }\n-\n-    private void cancelPendingMenuReplaceOperations(){\n-        for (Task operation : transactionQueue.getTasksAsList()) {\n-            if (!(operation instanceof MenuReplaceStaticOperation)) {\n-                continue;\n-            }\n-            operation.cancelTask();\n-        }\n-    }\n }\n", "next_change": {"commit": "f4def8de02ed71616b63831f66c0845560311464", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\nindex 1d7913709..12182eb86 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n", "chunk": "@@ -416,4 +440,21 @@ abstract class BaseMenuManager extends BaseSubManager {\n \n         return false;\n     }\n+\n+    // todo change to private\n+    static boolean isDynamicMenuUpdateActive(DynamicMenuUpdatesMode updateMode, String displayType) {\n+        if (updateMode.equals(DynamicMenuUpdatesMode.ON_WITH_COMPAT_MODE)) {\n+            if (displayType == null) {\n+                return true;\n+            }\n+            return (!displayType.equals(DisplayType.GEN3_8_INCH.toString()));\n+\n+        } else if (updateMode.equals(DynamicMenuUpdatesMode.FORCE_OFF)) {\n+            return false;\n+        } else if (updateMode.equals(DynamicMenuUpdatesMode.FORCE_ON)) {\n+            return true;\n+        }\n+\n+        return true;\n+    }\n }\n", "next_change": {"commit": "032460b5a172be33c7e6298c792107278980cc75", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\nindex 12182eb86..0b8f0345e 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n", "chunk": "@@ -457,4 +467,16 @@ abstract class BaseMenuManager extends BaseSubManager {\n \n         return true;\n     }\n+\n+    private void updateIdsOnMenuCells(List<MenuCell> menuCells, int parentId) {\n+        for (MenuCell cell : menuCells) {\n+            cell.setCellId(lastMenuId++);\n+            if (parentId != parentIdNotFound) {\n+                cell.setParentCellId(parentId);\n+            }\n+            if (cell.getSubCells() != null && !cell.getSubCells().isEmpty()) {\n+                updateIdsOnMenuCells(cell.getSubCells(), cell.getCellId());\n+            }\n+        }\n+    }\n }\n", "next_change": {"commit": "07d6c0672f7e6bb689be34b65ddfed81d0a2770b", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\nindex 0b8f0345e..29a08d91f 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n", "chunk": "@@ -474,7 +455,7 @@ abstract class BaseMenuManager extends BaseSubManager {\n             if (parentId != parentIdNotFound) {\n                 cell.setParentCellId(parentId);\n             }\n-            if (cell.getSubCells() != null && !cell.getSubCells().isEmpty()) {\n+            if (isSubMenuCell(cell) && !cell.getSubCells().isEmpty()) {\n                 updateIdsOnMenuCells(cell.getSubCells(), cell.getCellId());\n             }\n         }\n", "next_change": {"commit": "8f8473efe83ca99cb5f93536b594b878ac53bff4", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\nindex 29a08d91f..2a09498a7 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n", "chunk": "@@ -460,4 +446,69 @@ abstract class BaseMenuManager extends BaseSubManager {\n             }\n         }\n     }\n+\n+    private void addUniqueNamesToCells(List<MenuCell> cells) {\n+        HashMap<String, Integer> titlesMap = new HashMap<>();\n+\n+        for (MenuCell cell : cells) {\n+            String cellTitle = cell.getTitle();\n+            Integer counter = titlesMap.get(cellTitle);\n+\n+            if (counter == null) {\n+                titlesMap.put(cellTitle, 1);\n+                cell.setUniqueTitle(cellTitle);\n+            } else {\n+                titlesMap.put(cellTitle, ++counter);\n+                cell.setUniqueTitle(cellTitle + \" (\" + counter + \")\");\n+            }\n+\n+            if (isSubMenuCell(cell) && !cell.getSubCells().isEmpty()) {\n+                addUniqueNamesToCells(cell.getSubCells());\n+            }\n+        }\n+    }\n+\n+    /**\n+     Check for cell lists with completely duplicate information, or any duplicate voiceCommands\n+     @param cells The cells you will be adding\n+     @return Boolean that indicates whether menuCells are unique or not\n+     */\n+    private boolean menuCellsAreUnique(List<MenuCell> cells, ArrayList<String> allVoiceCommands) {\n+        // Check all voice commands for identical items and check each list of cells for identical cells\n+        HashSet<MenuCell> identicalCellsCheckSet = new HashSet<>();\n+\n+        for (MenuCell cell : cells) {\n+            identicalCellsCheckSet.add(cell);\n+\n+            // Recursively check the sub-cell lists to see if they are all unique as well. If anything is not, this will chain back up the list to return false.\n+            if (isSubMenuCell(cell) && !cell.getSubCells().isEmpty()) {\n+                boolean subCellsAreUnique = menuCellsAreUnique(cell.getSubCells(), allVoiceCommands);\n+\n+                if (!subCellsAreUnique) {\n+                    DebugTool.logError(TAG, \"Not all subCells are unique. The menu will not be set.\");\n+                    return false;\n+                }\n+            }\n+\n+            // Voice commands have to be identical across all lists\n+            if (cell.getVoiceCommands() != null) {\n+                allVoiceCommands.addAll(cell.getVoiceCommands());\n+            }\n+        }\n+\n+        // Check for duplicate cells\n+        if (identicalCellsCheckSet.size() != cells.size()) {\n+            DebugTool.logError(TAG, \"Not all cells are unique. The menu will not be set.\");\n+            return false;\n+        }\n+\n+        // All the VR commands must be unique\n+        HashSet<String> voiceCommandsSet = new HashSet<>(allVoiceCommands);\n+        if (allVoiceCommands.size() != voiceCommandsSet.size()) {\n+            DebugTool.logError(TAG, \"Attempted to create a menu with duplicate voice commands. Voice commands must be unique. The menu will not be set\");\n+            return false;\n+        }\n+\n+        return true;\n+    }\n }\n", "next_change": {"commit": "bb898a0cbe7897e72352148e4f68b69dec9bd2f0", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\nindex 2a09498a7..ccb4dc1cf 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n", "chunk": "@@ -511,4 +509,89 @@ abstract class BaseMenuManager extends BaseSubManager {\n \n         return true;\n     }\n+\n+    private void addUniqueNamesToCellsWithDuplicatePrimaryText(List<MenuCell> cells) {\n+        HashMap<String, Integer> countsMap = new HashMap<>();\n+\n+        for (MenuCell cell : cells) {\n+            String cellTitle = cell.getTitle();\n+            Integer counter = countsMap.get(cellTitle);\n+\n+            if (counter != null) {\n+                countsMap.put(cellTitle, ++counter);\n+                cell.setUniqueTitle(cellTitle + \" (\" + counter + \")\");\n+            } else {\n+                countsMap.put(cellTitle, 1);\n+                cell.setUniqueTitle(cellTitle);\n+            }\n+\n+            if (isSubMenuCell(cell) && !cell.getSubCells().isEmpty()) {\n+                addUniqueNamesToCellsWithDuplicatePrimaryText(cell.getSubCells());\n+            }\n+        }\n+    }\n+\n+    void addUniqueNamesBasedOnStrippedCells(List<MenuCell> strippedCells, List<MenuCell> originalCells) {\n+        if (strippedCells == null || originalCells == null || strippedCells.size() != originalCells.size()) {\n+            return;\n+        }\n+        // Tracks how many of each cell primary text there are so that we can append numbers to make each unique as necessary\n+        HashMap<MenuCell, Integer> countsMap = new HashMap<>();\n+        for (int i = 0; i < strippedCells.size(); i++) {\n+            MenuCell cell = strippedCells.get(i);\n+            Integer counter = countsMap.get(cell);\n+            if (counter != null) {\n+                countsMap.put(cell, ++counter);\n+                originalCells.get(i).setUniqueTitle(originalCells.get(i).getTitle() + \" (\" + counter + \")\");\n+            } else {\n+                countsMap.put(cell, 1);\n+                originalCells.get(i).setUniqueTitle(originalCells.get(i).getTitle());\n+            }\n+\n+            if (isSubMenuCell(cell) && !cell.getSubCells().isEmpty()) {\n+                addUniqueNamesBasedOnStrippedCells(cell.getSubCells(), originalCells.get(i).getSubCells());\n+            }\n+        }\n+    }\n+\n+    List<MenuCell> removeUnusedProperties(List<MenuCell> cells) {\n+        if (cells == null) {\n+            return null;\n+        }\n+        List<MenuCell> removePropertiesClone = cloneMenuCellsList(cells);\n+        for (MenuCell cell : removePropertiesClone) {\n+            // Strip away fields that cannot be used to determine uniqueness visually including fields not supported by the HMI\n+            cell.setVoiceCommands(null);\n+\n+            // Don't check ImageFieldName.subMenuIcon because it was added in 7.0 when the feature was added in 5.0.\n+            // Just assume that if cmdIcon is not available, the submenu icon is not either.\n+            if (!hasImageFieldOfName(windowCapability, ImageFieldName.cmdIcon)) {\n+                cell.setIcon(null);\n+            }\n+            // Check for subMenu fields supported\n+            if (isSubMenuCell(cell)) {\n+                if (!hasTextFieldOfName(windowCapability, TextFieldName.menuSubMenuSecondaryText)) {\n+                    cell.setSecondaryText(null);\n+                }\n+                if (!hasTextFieldOfName(windowCapability, TextFieldName.menuSubMenuTertiaryText)) {\n+                    cell.setTertiaryText(null);\n+                }\n+                if (!hasImageFieldOfName(windowCapability, ImageFieldName.menuSubMenuSecondaryImage)) {\n+                    cell.setSecondaryArtwork(null);\n+                }\n+                cell.setSubCells(removeUnusedProperties(cell.getSubCells()));\n+            } else {\n+                if (!hasTextFieldOfName(windowCapability, TextFieldName.menuCommandSecondaryText)) {\n+                    cell.setSecondaryText(null);\n+                }\n+                if (!hasTextFieldOfName(windowCapability, TextFieldName.menuCommandTertiaryText)) {\n+                    cell.setTertiaryText(null);\n+                }\n+                if (!hasImageFieldOfName(windowCapability, ImageFieldName.menuCommandSecondaryImage)) {\n+                    cell.setSecondaryArtwork(null);\n+                }\n+            }\n+        }\n+        return removePropertiesClone;\n+    }\n }\n", "next_change": {"commit": "abb32c54568efe8f1e6b9d37c4815e796643f139", "changed_code": [{"header": "diff --git a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\nindex ccb4dc1cf..7ad00a8cf 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/screen/menu/BaseMenuManager.java\n", "chunk": "@@ -509,89 +501,4 @@ abstract class BaseMenuManager extends BaseSubManager {\n \n         return true;\n     }\n-\n-    private void addUniqueNamesToCellsWithDuplicatePrimaryText(List<MenuCell> cells) {\n-        HashMap<String, Integer> countsMap = new HashMap<>();\n-\n-        for (MenuCell cell : cells) {\n-            String cellTitle = cell.getTitle();\n-            Integer counter = countsMap.get(cellTitle);\n-\n-            if (counter != null) {\n-                countsMap.put(cellTitle, ++counter);\n-                cell.setUniqueTitle(cellTitle + \" (\" + counter + \")\");\n-            } else {\n-                countsMap.put(cellTitle, 1);\n-                cell.setUniqueTitle(cellTitle);\n-            }\n-\n-            if (isSubMenuCell(cell) && !cell.getSubCells().isEmpty()) {\n-                addUniqueNamesToCellsWithDuplicatePrimaryText(cell.getSubCells());\n-            }\n-        }\n-    }\n-\n-    void addUniqueNamesBasedOnStrippedCells(List<MenuCell> strippedCells, List<MenuCell> originalCells) {\n-        if (strippedCells == null || originalCells == null || strippedCells.size() != originalCells.size()) {\n-            return;\n-        }\n-        // Tracks how many of each cell primary text there are so that we can append numbers to make each unique as necessary\n-        HashMap<MenuCell, Integer> countsMap = new HashMap<>();\n-        for (int i = 0; i < strippedCells.size(); i++) {\n-            MenuCell cell = strippedCells.get(i);\n-            Integer counter = countsMap.get(cell);\n-            if (counter != null) {\n-                countsMap.put(cell, ++counter);\n-                originalCells.get(i).setUniqueTitle(originalCells.get(i).getTitle() + \" (\" + counter + \")\");\n-            } else {\n-                countsMap.put(cell, 1);\n-                originalCells.get(i).setUniqueTitle(originalCells.get(i).getTitle());\n-            }\n-\n-            if (isSubMenuCell(cell) && !cell.getSubCells().isEmpty()) {\n-                addUniqueNamesBasedOnStrippedCells(cell.getSubCells(), originalCells.get(i).getSubCells());\n-            }\n-        }\n-    }\n-\n-    List<MenuCell> removeUnusedProperties(List<MenuCell> cells) {\n-        if (cells == null) {\n-            return null;\n-        }\n-        List<MenuCell> removePropertiesClone = cloneMenuCellsList(cells);\n-        for (MenuCell cell : removePropertiesClone) {\n-            // Strip away fields that cannot be used to determine uniqueness visually including fields not supported by the HMI\n-            cell.setVoiceCommands(null);\n-\n-            // Don't check ImageFieldName.subMenuIcon because it was added in 7.0 when the feature was added in 5.0.\n-            // Just assume that if cmdIcon is not available, the submenu icon is not either.\n-            if (!hasImageFieldOfName(windowCapability, ImageFieldName.cmdIcon)) {\n-                cell.setIcon(null);\n-            }\n-            // Check for subMenu fields supported\n-            if (isSubMenuCell(cell)) {\n-                if (!hasTextFieldOfName(windowCapability, TextFieldName.menuSubMenuSecondaryText)) {\n-                    cell.setSecondaryText(null);\n-                }\n-                if (!hasTextFieldOfName(windowCapability, TextFieldName.menuSubMenuTertiaryText)) {\n-                    cell.setTertiaryText(null);\n-                }\n-                if (!hasImageFieldOfName(windowCapability, ImageFieldName.menuSubMenuSecondaryImage)) {\n-                    cell.setSecondaryArtwork(null);\n-                }\n-                cell.setSubCells(removeUnusedProperties(cell.getSubCells()));\n-            } else {\n-                if (!hasTextFieldOfName(windowCapability, TextFieldName.menuCommandSecondaryText)) {\n-                    cell.setSecondaryText(null);\n-                }\n-                if (!hasTextFieldOfName(windowCapability, TextFieldName.menuCommandTertiaryText)) {\n-                    cell.setTertiaryText(null);\n-                }\n-                if (!hasImageFieldOfName(windowCapability, ImageFieldName.menuCommandSecondaryImage)) {\n-                    cell.setSecondaryArtwork(null);\n-                }\n-            }\n-        }\n-        return removePropertiesClone;\n-    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "18b5f861209ec0f7aa31bd55ea5f43d1e39cd900", "message": "Merge commit", "committedDate": null}, {"oid": "763753da5436d9e296cda95e50a5c7ac3740079c", "committedDate": "2020-05-20 15:56:21 -0400", "message": "Update null checks for the Base Managers"}, {"oid": "ceadd66ca7c49fa8f6303b694a0d9aaef89a7cf9", "committedDate": "2020-05-28 10:47:11 -0400", "message": "Move logic to BaseMenuManager"}, {"oid": "54fa80622e5fdef602987fd06fc2b17d2e84cacb", "committedDate": "2020-05-28 13:06:48 -0400", "message": "Fix Logic and Add Test"}, {"oid": "3699318e85d49e7b61978cbc5c6cfe59d3afd9de", "committedDate": "2020-06-02 15:39:49 -0400", "message": "Merge pull request #1354 from smartdevicelink/bugfix/issue_1341"}, {"oid": "df7badc06dfdeb3b9cccb7496d1a27471874e877", "committedDate": "2020-06-26 15:03:18 -0400", "message": "Use new logInfo API instead of Deprecated API"}, {"oid": "cb7b6577fe41cb04140fd0726745dd66071a6680", "committedDate": "2020-06-26 16:17:25 -0400", "message": "Move android and base classes to new logWarning"}, {"oid": "05d262701ff3495da7470a925bf67a91b57ad163", "committedDate": "2020-06-26 16:40:13 -0400", "message": "Move logError to new DebugTool APIs in android/base"}, {"oid": "59f11f6779fba28befe435ee640f31fa2a2dc7e9", "committedDate": "2020-06-30 08:58:34 -0400", "message": "Add Tags to classes using null for TAG"}, {"oid": "87f443305eef5dcf5d0cd70ecbe9ad5f7c5c5100", "committedDate": "2020-08-04 16:50:18 -0400", "message": "Move SCM to managers.lifecycle package"}, {"oid": "3e9f90212e713f85369e6a11f1d15abf3b966bdf", "committedDate": "2020-08-10 19:35:10 -0400", "message": "Update imports to androidX"}, {"oid": "dd92e18447571592661fff2e2e3191f403bd4283", "committedDate": "2020-08-18 15:17:12 -0400", "message": "Remove onError from MenuManager"}, {"oid": "0f6a3f5c7f286686a78e7ecc9ee397bcbba675b0", "committedDate": "2020-08-21 11:16:08 -0400", "message": "Fix OnSystemCapabilityListener package name"}, {"oid": "7d27d47885cc983ba9c9f49df4ff329654dea0de", "committedDate": "2020-08-21 13:08:18 -0400", "message": "Remove unsed imports"}, {"oid": "b667a9b159f6d7443acdcd1b5b230652dbd576b8", "committedDate": "2020-08-21 15:38:41 -0400", "message": "Merge branch 'develop' into feature/fix_scm_package"}, {"oid": "9e77ff43b1450f656e8ae6405a8da6bb435e5127", "committedDate": "2020-09-08 15:25:03 -0400", "message": "Remove Deprecated Isdl methods (#1485)"}, {"oid": "cd4ac27321c641ef4a9c9f6628059735364ef4dd", "committedDate": "2020-09-15 14:02:09 -0400", "message": "Move proxy interfaces to better packages"}, {"oid": "e00f2c1f9310e7423be3a094aa77b1e84b1a0a80", "committedDate": "2020-09-17 16:31:17 -0400", "message": "Run the Reformat Code tool on the project"}, {"oid": "49a7f9b167bd325efc59bd5a4eeba39b4edceeaf", "committedDate": "2020-11-10 15:08:40 -0500", "message": "Fix overwrite issue in MenuManager"}, {"oid": "fc57f10bcf888c2c25383d8d29e8b356f65bb2cc", "committedDate": "2020-11-30 12:01:06 -0500", "message": "Update private method names to align more with iOS"}, {"oid": "6b4ccaa08fa00900d6b8ce7bf2b0c3bf9df44a29", "committedDate": "2020-11-30 14:24:48 -0500", "message": "Add artworkNeedsUpload() to FileManager"}, {"oid": "ac7dde9b3378b1e33879738f482a70103c85d58c", "committedDate": "2020-11-30 14:55:56 -0500", "message": "Update fileNeedsUpload() to accept SdlFile"}, {"oid": "606d6b785983ce5eacb0efda24c5ea4db5d6d977", "committedDate": "2020-11-30 15:39:40 -0500", "message": "REfactor isSdlArtworkUploaded() code"}, {"oid": "83560b1c7883eca966dd2651fde33b6a50f3f420", "committedDate": "2020-12-09 10:41:49 -0500", "message": "Update private method name in Menu Manager"}, {"oid": "637672b527ccacc8af9167d8341d7f49fb7be985", "committedDate": "2021-01-21 17:00:44 -0500", "message": "MenuManager refactor initial commit"}, {"oid": "8d3a750203e260d94872d6603845d66268a83104", "committedDate": "2021-01-22 10:36:24 -0500", "message": "Update modifiers"}, {"oid": "1dc2b77e0f08e29d49913f0a70de9701f82c06b5", "committedDate": "2021-01-22 11:46:55 -0500", "message": "Remove lastMenuId from menu manager"}, {"oid": "027092fc04f47947091d63ff6661aaf2a73c49eb", "committedDate": "2021-01-22 14:55:40 -0500", "message": "Update MenuReplaceOperation"}, {"oid": "cc515b2bcf2dfbefc9965cdfb2c7e7803cec800d", "committedDate": "2021-01-25 10:41:56 -0500", "message": "Pause MenuManager queue when needed"}, {"oid": "2cb9b48338a8f10bbc9ebd4b1776d6fecdfead9e", "committedDate": "2021-01-25 11:49:49 -0500", "message": "Align menu manager with iOS"}, {"oid": "18094f8fba627d09c8e30e89d0b03ba5bf80b65b", "committedDate": "2021-01-25 13:21:06 -0500", "message": "Rename menuCells to currnetMenuCells"}, {"oid": "915ed7c64241f7ffb144bfcb285eb76a9d338ec3", "committedDate": "2021-01-25 13:24:51 -0500", "message": "Update var names"}, {"oid": "d774b215478d89f9e39e23bc8c9485023fc5bf62", "committedDate": "2021-01-25 13:43:39 -0500", "message": "Remove unnecessary checks"}, {"oid": "f3e3acd73ecaf2e5241aea1239c5d6363652aabc", "committedDate": "2021-01-25 14:20:32 -0500", "message": "Refactor MenuShowOperation"}, {"oid": "1a6c325dfe0e2cf839faef75912b5c9dfd1de55a", "committedDate": "2021-01-25 15:24:19 -0500", "message": "Move lastMenuId to BaseMenuManager"}, {"oid": "f4def8de02ed71616b63831f66c0845560311464", "committedDate": "2021-01-26 11:58:29 -0500", "message": "Update canceling pending operations"}, {"oid": "de7c2a4189838998a9408f26adf7dee67b78a8cc", "committedDate": "2021-01-26 13:14:21 -0500", "message": "Add initial code to MenuReplaceDynamicOperation"}, {"oid": "8be2de8b3ef974669f83814163a2c0447287fe53", "committedDate": "2021-01-26 13:14:55 -0500", "message": "make isDynamicMenuUpdateActive private"}, {"oid": "b103a629d67422ab8e1bc1cfdd1890ff2ba931d2", "committedDate": "2021-01-26 13:30:01 -0500", "message": "Reformat code"}, {"oid": "1b33b720b32e9dc2a887bbdaacf13bfd7d6475d7", "committedDate": "2021-01-27 11:40:29 -0500", "message": "Update menu replace operations with new currentMenu"}, {"oid": "f8713042c7520b1cc1cf506e69d54f9ceb9346ce", "committedDate": "2021-01-27 13:42:44 -0500", "message": "Rename windowCapability vars"}, {"oid": "467c29b7d119e9dd2dac2f32f42df0ae4a66fb55", "committedDate": "2021-01-28 10:45:09 -0500", "message": "Add some helper methods to MenuReplaceUtilities"}, {"oid": "2158810dab1406991f37f93bee57094b862b1f50", "committedDate": "2021-01-28 14:24:30 -0500", "message": "Fix issue with parentIdNotFound"}, {"oid": "032460b5a172be33c7e6298c792107278980cc75", "committedDate": "2021-01-29 13:53:51 -0500", "message": "Move setting ids logic from operations to manager"}, {"oid": "690ab07aa3e94cc55b6d0312557a8197a8499a2d", "committedDate": "2021-02-02 10:46:15 -0500", "message": "Use MenuReplaceDynamicOperation for both static and dynamic updates"}, {"oid": "d1a53328eef1880c52de3c7aa958346d176896c4", "committedDate": "2021-02-02 10:49:48 -0500", "message": "Remove MenuReplaceStaticOperation"}, {"oid": "7c1cb77466f3a375ec06d4b9aa95b4ec4eb60890", "committedDate": "2021-02-02 14:45:16 -0500", "message": "Simplify updateTransactionQueueSuspended()"}, {"oid": "d90ea3ec5e02629074d17493b38371b66cb20612", "committedDate": "2021-02-02 15:12:37 -0500", "message": "Cleanup BaseMenuManager"}, {"oid": "2d726ca3c2113234a724d991bd607c1c9e15dd7a", "committedDate": "2021-02-02 15:40:27 -0500", "message": "Cleanup MenuConfigurationUpdateOperation.java"}, {"oid": "615e49be5ead6dd7083e8cfc4d650506eced57f4", "committedDate": "2021-02-03 11:18:43 -0500", "message": "Fix DynamicMenuUpdateRunScoreTests"}, {"oid": "0f586bd073cd24403f62a3501898925464eaab0c", "committedDate": "2021-02-03 16:02:38 -0500", "message": "Fix menu manager unit tests - part 1"}, {"oid": "e90489d1c1b422d26ffb38541cfa6f3ba5431b47", "committedDate": "2021-02-04 10:38:02 -0500", "message": "Replace menuCells with currentMenuCells"}, {"oid": "a79dd81352acbde981d63321ecac8ea76d2062b8", "committedDate": "2021-02-08 14:33:27 -0500", "message": "Update WindowCapability for pending replace operations"}, {"oid": "02bf117d3bd28409da23d1241572f328f8b7062c", "committedDate": "2021-02-08 14:54:04 -0500", "message": "Add updateMenuReplaceOperationsWithNewMenuConfiguration()"}, {"oid": "3dd51e0bedae9f17dfa8ad3314e56fde59b0012c", "committedDate": "2021-02-23 14:14:04 -0500", "message": "Remove unused import"}, {"oid": "db382d37bc531dcac5f87d5049f64cb87aca4f75", "committedDate": "2021-02-23 15:13:16 -0500", "message": "Fix issue in getMenuConfiguration()"}, {"oid": "6b5a6e629d1bebc612bc8a699b061b6c914c2200", "committedDate": "2021-02-25 15:37:01 -0500", "message": "Fix potential NPE"}, {"oid": "e958528b1da754aca81099877a3e854ada2ee3f1", "committedDate": "2021-04-29 11:19:12 -0400", "message": "Reformat code"}, {"oid": "85973d84ce9f49e8246f0ff9c28bfaddd4a91a7b", "committedDate": "2021-07-12 15:23:47 -0400", "message": "Update comments"}, {"oid": "7952a520ec36120dd2fae001ad0531c316449331", "committedDate": "2021-07-12 15:43:52 -0400", "message": "Update comments"}, {"oid": "07d6c0672f7e6bb689be34b65ddfed81d0a2770b", "committedDate": "2021-07-21 15:43:14 -0400", "message": "Treat cells with empty sub cells as AddSubMenus part2"}, {"oid": "8f8473efe83ca99cb5f93536b594b878ac53bff4", "committedDate": "2021-07-26 15:15:29 -0400", "message": "Menu cells uniqueness initial implementation"}, {"oid": "bb898a0cbe7897e72352148e4f68b69dec9bd2f0", "committedDate": "2021-07-27 15:33:56 -0400", "message": "Make cells take which properties are available into account for uniqueness"}, {"oid": "b778150fe8f024f86a31143f708cb286fa8cc46c", "committedDate": "2021-07-27 16:11:16 -0400", "message": "Dont take none visual fields into account when chechin uniqueness"}, {"oid": "1a1d2df248481587d416c163c3d167e405c1ca29", "committedDate": "2021-08-09 17:32:39 -0400", "message": "Fix error messages TAG"}, {"oid": "f4d2d117c2d580e36c61fda28887b862d001a0a6", "committedDate": "2021-08-09 17:37:10 -0400", "message": "Remove code added by mistake"}, {"oid": "8ca18b6831048eed7fe04c8a076b3a0276c79015", "committedDate": "2021-08-09 18:03:29 -0400", "message": "Simplify setMenuCells()"}, {"oid": "abb32c54568efe8f1e6b9d37c4815e796643f139", "committedDate": "2021-08-09 18:08:34 -0400", "message": "Move applying unique titles to MenuReplaceOperation"}, {"oid": "6ff352f22d687b8d95a81276966b0507e103582f", "committedDate": "2021-08-09 18:09:13 -0400", "message": "Remove unused imports"}, {"oid": "6ff10a158a7218587f144f5944d1fbc1f089bbd3", "committedDate": "2021-08-10 10:22:57 -0400", "message": "Move cloneMenuCellsList() to MenuReplaceOperation"}, {"oid": "dca0119b642a6706abaaa149b6a6cf3d4faf8110", "committedDate": "2021-08-10 17:25:30 -0400", "message": "Fix issue in menuCellsAreUnique"}, {"oid": "75a07319e608081c3ab2a352dee3d324c137ea67", "committedDate": "2021-08-11 16:51:22 -0400", "message": "Move cell Id handeling to operation"}, {"oid": "89b3a6c45cdd8433b34697c84cb898f752603cf3", "committedDate": "2021-08-12 15:14:07 -0400", "message": "Fix potential NPE"}, {"oid": "372076351ac693712270ccf6e8e1d009714c7b57", "committedDate": "2021-08-13 14:58:53 -0400", "message": "Transfer listeners from new kepts cells to old kep cells"}, {"oid": "c26675575f68b844cd467ae051efb466bb067406", "committedDate": "2021-08-17 09:50:40 -0400", "message": "Move isSubMenuCell() to MenuCell class"}, {"oid": "5a96e3455d545c53bf805359e12bbf7ae21a5b1e", "committedDate": "2021-08-30 11:20:11 -0400", "message": "Move some methods to MenuReplaceUtilities"}, {"oid": "0a29f6816911c71683a5009da9f43021149ae0b7", "committedDate": "2021-08-31 11:45:23 -0400", "message": "Add more menu manager tests"}, {"oid": "8fc8e787affb177d0a5235f9ddf43f1a37c8302a", "committedDate": "2021-09-13 09:13:09 -0400", "message": "Update log messages"}, {"oid": "2dedb1f5066b080c38c04584ceca1bc8bbd71090", "committedDate": "2021-09-13 11:21:10 -0400", "message": "Fix an issue with calling listeners in BaseMenuManager"}, {"oid": "ef086d79b72321f7d9a60e5a08aa9a2e8aae7e94", "committedDate": "2021-09-15 12:15:07 -0400", "message": "Apply suggestions from code review"}, {"oid": "7088a04fadfb2dcc651e7146ad06c2c54f4c99ce", "committedDate": "2021-09-22 10:01:21 -0400", "message": "Fix using wrong menu configuration pass through to menu operation"}]}, {"oid": "5d271d43ad21b23e3437e4d19c5f1aff75994936", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/5d271d43ad21b23e3437e4d19c5f1aff75994936", "message": "Update base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n\nCo-Authored-By: Joey Grover <joeygrover@gmail.com>", "committedDate": "2020-04-09T16:06:55Z", "type": "commit"}, {"oid": "f0e56e34018c6ec4b8fb0cd469456b8c2397b882", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/f0e56e34018c6ec4b8fb0cd469456b8c2397b882", "message": "Update base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n\nCo-Authored-By: Joey Grover <joeygrover@gmail.com>", "committedDate": "2020-04-09T16:07:21Z", "type": "commit"}, {"oid": "e285d375b2a0ba32798adc84e481bc990a120cc3", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/e285d375b2a0ba32798adc84e481bc990a120cc3", "message": "Update base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n\nCo-Authored-By: Joey Grover <joeygrover@gmail.com>", "committedDate": "2020-04-09T16:08:04Z", "type": "commit"}, {"oid": "8fed860092b7e07a891e420a6095b4aeeaa8a9c0", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/8fed860092b7e07a891e420a6095b4aeeaa8a9c0", "message": "Update base/src/main/java/com/smartdevicelink/managers/ManagerUtility.java\n\nCo-Authored-By: Joey Grover <joeygrover@gmail.com>", "committedDate": "2020-04-09T16:08:20Z", "type": "commit"}, {"oid": "62a57bdbc2f8794ea020d6bdd293ba92789eb278", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/62a57bdbc2f8794ea020d6bdd293ba92789eb278", "message": "Simplify getMaxNumberOfMainFieldLines() logic", "committedDate": "2020-04-09T16:22:11Z", "type": "commit"}]}