{"pr_number": 828, "pr_title": "iceberg-spark changes for vectorized reads", "pr_author": "samarthjain", "pr_createdAt": "2020-03-05T19:16:45Z", "pr_url": "https://github.com/apache/iceberg/pull/828", "timeline": [{"oid": "be26a697c78dd47963c03dd3d363a40bb34ff14e", "url": "https://github.com/apache/iceberg/commit/be26a697c78dd47963c03dd3d363a40bb34ff14e", "message": "Cleanup and address code review comments.\n\nSummary of changes:\n1) Below new test cases added:\n   - Test for code path when optional values are mostly null\n   - Test for case when containers are not reused for every batch\n   - Test for case to verify arrow's validity vector is set correctly when setArrowValidityVector = true\n2) Reuse container logic is now similar to row based read path\n3) We now always set the nullability holder. Arrow validity vector is set only for purpose of supplying complete arrow vectors when requested to do so.", "committedDate": "2020-06-12T19:41:32Z", "type": "forcePushed"}, {"oid": "a3dd1ce3818801c051df88e1557af8de3f5e42d0", "url": "https://github.com/apache/iceberg/commit/a3dd1ce3818801c051df88e1557af8de3f5e42d0", "message": "Run gradle build instead of check since build runs assembly + check", "committedDate": "2020-06-12T23:00:40Z", "type": "forcePushed"}, {"oid": "3c9cc0667b97e18a00c7fcb2c0324cb1ec529d56", "url": "https://github.com/apache/iceberg/commit/3c9cc0667b97e18a00c7fcb2c0324cb1ec529d56", "message": "Run gradle build instead of check since build runs assembly + check", "committedDate": "2020-06-12T23:14:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MDgxMg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r439680812", "body": "Why make this a method? So it can be overridden?", "bodyText": "Why make this a method? So it can be overridden?", "bodyHTML": "<p dir=\"auto\">Why make this a method? So it can be overridden?</p>", "author": "rdblue", "createdAt": "2020-06-12T23:39:45Z", "path": "spark/src/test/java/org/apache/iceberg/spark/data/parquet/vectorized/TestParquetVectorizedReads.java", "diffHunk": "@@ -48,11 +48,15 @@\n import static org.apache.iceberg.types.Types.NestedField.required;\n \n public class TestParquetVectorizedReads extends AvroDataTest {\n-  private static final int NUM_ROWS = 1_000_000;\n+  private static final int NUM_ROWS = 200_000;\n \n   @Override\n   protected void writeAndValidate(Schema schema) throws IOException {\n-    writeAndValidate(schema, NUM_ROWS, 0L, RandomData.DEFAULT_NULL_PERCENTAGE, false, true);\n+    writeAndValidate(schema, getNumRows(), 0L, RandomData.DEFAULT_NULL_PERCENTAGE, false, true);\n+  }\n+\n+  protected int getNumRows() {\n+    return NUM_ROWS;", "originalCommit": "8893379821bf6532a2b7001b574e65a98f8a699a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTYyMg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r439681622", "bodyText": "Yes", "author": "samarthjain", "createdAt": "2020-06-12T23:44:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MDgxMg=="}], "type": "inlineReview"}, {"oid": "066c1ed7c1512225a05548a6152cf81df35f1dc6", "url": "https://github.com/apache/iceberg/commit/066c1ed7c1512225a05548a6152cf81df35f1dc6", "message": "Adjust tests, increase memory and increase travis build timeout", "committedDate": "2020-06-12T23:56:08Z", "type": "forcePushed"}, {"oid": "39a8550e4d041c18c538af6e9245ea7e0218f823", "url": "https://github.com/apache/iceberg/commit/39a8550e4d041c18c538af6e9245ea7e0218f823", "message": "Revert travis_wait since tests are not taking a long time now", "committedDate": "2020-06-13T00:25:00Z", "type": "forcePushed"}, {"oid": "951812f364f6f0c8b3b9aacf57994b7b58f896d6", "url": "https://github.com/apache/iceberg/commit/951812f364f6f0c8b3b9aacf57994b7b58f896d6", "message": "Adjust tests, increase memory and increase travis build timeout", "committedDate": "2020-06-13T01:05:24Z", "type": "forcePushed"}, {"oid": "2fed8256caaa08fbf25b985f9a7b15678968e59a", "url": "https://github.com/apache/iceberg/commit/2fed8256caaa08fbf25b985f9a7b15678968e59a", "message": "Cleanup and address code review comments.\n\nSummary of changes:\n1) Below new test cases added:\n   - Test for code path when optional values are mostly null\n   - Test for case when containers are not reused for every batch\n   - Test for case to verify arrow's validity vector is set correctly when setArrowValidityVector = true\n2) Reuse container logic is now similar to row based read path\n3) We now always set the nullability holder. Arrow validity vector is set only for purpose of supplying complete arrow vectors when requested to do so.", "committedDate": "2020-06-13T07:51:20Z", "type": "forcePushed"}, {"oid": "24161c76e6aa54394c00739dbf31084ccdbf550f", "url": "https://github.com/apache/iceberg/commit/24161c76e6aa54394c00739dbf31084ccdbf550f", "message": "Cleanup and address code review comments.\n\nSummary of changes:\n1) Below new test cases added:\n   - Test for code path when optional values are mostly null\n   - Test for case when containers are not reused for every batch\n   - Test for case to verify arrow's validity vector is set correctly when setArrowValidityVector = true\n2) Reuse container logic is now similar to row based read path\n3) We now always set the nullability holder. Arrow validity vector is set only for purpose of supplying complete arrow vectors when requested to do so.", "committedDate": "2020-06-15T07:29:43Z", "type": "commit"}, {"oid": "24161c76e6aa54394c00739dbf31084ccdbf550f", "url": "https://github.com/apache/iceberg/commit/24161c76e6aa54394c00739dbf31084ccdbf550f", "message": "Cleanup and address code review comments.\n\nSummary of changes:\n1) Below new test cases added:\n   - Test for code path when optional values are mostly null\n   - Test for case when containers are not reused for every batch\n   - Test for case to verify arrow's validity vector is set correctly when setArrowValidityVector = true\n2) Reuse container logic is now similar to row based read path\n3) We now always set the nullability holder. Arrow validity vector is set only for purpose of supplying complete arrow vectors when requested to do so.", "committedDate": "2020-06-15T07:29:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExMzM2Mw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389113363", "body": "Why convert directly from Arrow to Spark? Shouldn't this make guarantees about Arrow storage fields that are used for a given Iceberg type instead?", "bodyText": "Why convert directly from Arrow to Spark? Shouldn't this make guarantees about Arrow storage fields that are used for a given Iceberg type instead?", "bodyHTML": "<p dir=\"auto\">Why convert directly from Arrow to Spark? Shouldn't this make guarantees about Arrow storage fields that are used for a given Iceberg type instead?</p>", "author": "rdblue", "createdAt": "2020-03-06T19:54:47Z", "path": "spark/src/main/java/org/apache/iceberg/spark/arrow/ArrowUtils.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.arrow;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.FloatingPointPrecision;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.spark.sql.types.ArrayType;\n+import org.apache.spark.sql.types.DataType;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.DecimalType;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+\n+public class ArrowUtils {\n+\n+  private static ArrowUtils instance;\n+  private RootAllocator rootAllocator;\n+\n+  private ArrowUtils() {\n+    rootAllocator = new RootAllocator(Long.MAX_VALUE);\n+  }\n+\n+  public static ArrowUtils instance() {\n+    if (instance == null) {\n+      instance = new ArrowUtils();\n+    }\n+    return instance;\n+  }\n+\n+  public RootAllocator rootAllocator() {\n+    return rootAllocator;\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+  public DataType fromArrowType(ArrowType data) {", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExMzc4Nw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389113787", "body": "`bSize` is batch size? If so, `batchSize` is more clear.", "bodyText": "bSize is batch size? If so, batchSize is more clear.", "bodyHTML": "<p dir=\"auto\"><code>bSize</code> is batch size? If so, <code>batchSize</code> is more clear.</p>", "author": "rdblue", "createdAt": "2020-03-06T19:55:47Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ColumnarBatchReaders.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import java.lang.reflect.Array;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.parquet.column.page.PageReadStore;\n+import org.apache.parquet.hadoop.metadata.ColumnChunkMetaData;\n+import org.apache.parquet.hadoop.metadata.ColumnPath;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n+\n+/**\n+ * {@link VectorizedReader} that returns Spark's {@link ColumnarBatch} to support Spark's vectorized read path. The\n+ * {@link ColumnarBatch} returned is created by passing in the Arrow vectors populated via delegated read calls to\n+ * {@linkplain VectorizedArrowReader VectorReader(s)}.\n+ */\n+public class ColumnarBatchReaders implements VectorizedReader<ColumnarBatch> {\n+  private final VectorizedArrowReader[] readers;\n+  private final int batchSize;\n+\n+  public ColumnarBatchReaders(List<VectorizedReader> readers, int bSize) {", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExNjA5MQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389116091", "body": "Should there be more checking that `numRows` is valid? It should be the same for all vectors, right?\r\n\r\nWhat happens when all of the result vectors are null? Looks like this will set the batch length to 0, but I think we want to set it to something valid.", "bodyText": "Should there be more checking that numRows is valid? It should be the same for all vectors, right?\nWhat happens when all of the result vectors are null? Looks like this will set the batch length to 0, but I think we want to set it to something valid.", "bodyHTML": "<p dir=\"auto\">Should there be more checking that <code>numRows</code> is valid? It should be the same for all vectors, right?</p>\n<p dir=\"auto\">What happens when all of the result vectors are null? Looks like this will set the batch length to 0, but I think we want to set it to something valid.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:00:55Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ColumnarBatchReaders.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import java.lang.reflect.Array;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.parquet.column.page.PageReadStore;\n+import org.apache.parquet.hadoop.metadata.ColumnChunkMetaData;\n+import org.apache.parquet.hadoop.metadata.ColumnPath;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n+\n+/**\n+ * {@link VectorizedReader} that returns Spark's {@link ColumnarBatch} to support Spark's vectorized read path. The\n+ * {@link ColumnarBatch} returned is created by passing in the Arrow vectors populated via delegated read calls to\n+ * {@linkplain VectorizedArrowReader VectorReader(s)}.\n+ */\n+public class ColumnarBatchReaders implements VectorizedReader<ColumnarBatch> {\n+  private final VectorizedArrowReader[] readers;\n+  private final int batchSize;\n+\n+  public ColumnarBatchReaders(List<VectorizedReader> readers, int bSize) {\n+    this.readers = (VectorizedArrowReader[]) Array.newInstance(\n+        VectorizedArrowReader.class, readers.size());\n+    int idx = 0;\n+    for (VectorizedReader reader : readers) {\n+      this.readers[idx] = (VectorizedArrowReader) reader;\n+      idx++;\n+    }\n+    this.batchSize = bSize;\n+  }\n+\n+  @Override\n+  public final void setRowGroupInfo(PageReadStore pageStore, Map<ColumnPath, ColumnChunkMetaData> metaData) {\n+    for (int i = 0; i < readers.length; i += 1) {\n+      if (readers[i] != null) {\n+        readers[i].setRowGroupInfo(pageStore, metaData);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void reuseContainers(boolean reuse) {\n+    for (VectorizedReader reader : readers) {\n+      reader.reuseContainers(reuse);\n+    }\n+  }\n+\n+  @Override\n+  public final ColumnarBatch read(int numValsToRead) {\n+    ColumnVector[] arrowColumnVectors = new ColumnVector[readers.length];\n+    int numRows = 0;", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExNjg4Mw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389116883", "body": "You might want to move this into a factory method for `IcebergArrowColumnVector` instead of embedding it here. This logic looks more related to how column vectors work than to the batch. Here, you could just call `IcebergArrowColumnVector.forHolder(holder)` and that would return either the null vector or a real one.", "bodyText": "You might want to move this into a factory method for IcebergArrowColumnVector instead of embedding it here. This logic looks more related to how column vectors work than to the batch. Here, you could just call IcebergArrowColumnVector.forHolder(holder) and that would return either the null vector or a real one.", "bodyHTML": "<p dir=\"auto\">You might want to move this into a factory method for <code>IcebergArrowColumnVector</code> instead of embedding it here. This logic looks more related to how column vectors work than to the batch. Here, you could just call <code>IcebergArrowColumnVector.forHolder(holder)</code> and that would return either the null vector or a real one.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:02:46Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ColumnarBatchReaders.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import java.lang.reflect.Array;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.parquet.column.page.PageReadStore;\n+import org.apache.parquet.hadoop.metadata.ColumnChunkMetaData;\n+import org.apache.parquet.hadoop.metadata.ColumnPath;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n+\n+/**\n+ * {@link VectorizedReader} that returns Spark's {@link ColumnarBatch} to support Spark's vectorized read path. The\n+ * {@link ColumnarBatch} returned is created by passing in the Arrow vectors populated via delegated read calls to\n+ * {@linkplain VectorizedArrowReader VectorReader(s)}.\n+ */\n+public class ColumnarBatchReaders implements VectorizedReader<ColumnarBatch> {\n+  private final VectorizedArrowReader[] readers;\n+  private final int batchSize;\n+\n+  public ColumnarBatchReaders(List<VectorizedReader> readers, int bSize) {\n+    this.readers = (VectorizedArrowReader[]) Array.newInstance(\n+        VectorizedArrowReader.class, readers.size());\n+    int idx = 0;\n+    for (VectorizedReader reader : readers) {\n+      this.readers[idx] = (VectorizedArrowReader) reader;\n+      idx++;\n+    }\n+    this.batchSize = bSize;\n+  }\n+\n+  @Override\n+  public final void setRowGroupInfo(PageReadStore pageStore, Map<ColumnPath, ColumnChunkMetaData> metaData) {\n+    for (int i = 0; i < readers.length; i += 1) {\n+      if (readers[i] != null) {\n+        readers[i].setRowGroupInfo(pageStore, metaData);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void reuseContainers(boolean reuse) {\n+    for (VectorizedReader reader : readers) {\n+      reader.reuseContainers(reuse);\n+    }\n+  }\n+\n+  @Override\n+  public final ColumnarBatch read(int numValsToRead) {\n+    ColumnVector[] arrowColumnVectors = new ColumnVector[readers.length];\n+    int numRows = 0;\n+    for (int i = 0; i < readers.length; i += 1) {\n+      VectorHolder holder = readers[i].read(numValsToRead);", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExNzAwMw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389117003", "body": "Nit: no need for this empty line.", "bodyText": "Nit: no need for this empty line.", "bodyHTML": "<p dir=\"auto\">Nit: no need for this empty line.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:03:02Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.arrow.ArrowUtils;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.DecimalMetadata;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExNzk0NA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389117944", "body": "The convention for singletons used elsewhere is to create a static field named `INSTANCE` and name this method `get`:\r\n\r\n```java\r\npublic class SomeSingleton {\r\n  private static final SomeSingleton INSTANCE = new SomeSingleton();\r\n  public static SomeSingleton get() {\r\n    return INSTANCE;\r\n  }\r\n}\r\n```", "bodyText": "The convention for singletons used elsewhere is to create a static field named INSTANCE and name this method get:\npublic class SomeSingleton {\n  private static final SomeSingleton INSTANCE = new SomeSingleton();\n  public static SomeSingleton get() {\n    return INSTANCE;\n  }\n}", "bodyHTML": "<p dir=\"auto\">The convention for singletons used elsewhere is to create a static field named <code>INSTANCE</code> and name this method <code>get</code>:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public class SomeSingleton {\n  private static final SomeSingleton INSTANCE = new SomeSingleton();\n  public static SomeSingleton get() {\n    return INSTANCE;\n  }\n}\n\"><pre><span class=\"pl-k\">public</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">SomeSingleton</span> {\n  <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">SomeSingleton</span> <span class=\"pl-c1\">INSTANCE</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">SomeSingleton</span>();\n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-smi\">SomeSingleton</span> <span class=\"pl-en\">get</span>() {\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">INSTANCE</span>;\n  }\n}</pre></div>", "author": "rdblue", "createdAt": "2020-03-06T20:05:14Z", "path": "spark/src/main/java/org/apache/iceberg/spark/arrow/ArrowUtils.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.arrow;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.FloatingPointPrecision;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.spark.sql.types.ArrayType;\n+import org.apache.spark.sql.types.DataType;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.DecimalType;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+\n+public class ArrowUtils {\n+\n+  private static ArrowUtils instance;\n+  private RootAllocator rootAllocator;\n+\n+  private ArrowUtils() {\n+    rootAllocator = new RootAllocator(Long.MAX_VALUE);\n+  }\n+\n+  public static ArrowUtils instance() {", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExOTA5NQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389119095", "body": "The data type methods could be static instead. Could you break this class into `SparkArrowTypeUtil` and something like `ArrowAllocation`?", "bodyText": "The data type methods could be static instead. Could you break this class into SparkArrowTypeUtil and something like ArrowAllocation?", "bodyHTML": "<p dir=\"auto\">The data type methods could be static instead. Could you break this class into <code>SparkArrowTypeUtil</code> and something like <code>ArrowAllocation</code>?</p>", "author": "rdblue", "createdAt": "2020-03-06T20:07:50Z", "path": "spark/src/main/java/org/apache/iceberg/spark/arrow/ArrowUtils.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.arrow;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.FloatingPointPrecision;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.spark.sql.types.ArrayType;\n+import org.apache.spark.sql.types.DataType;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.DecimalType;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+\n+public class ArrowUtils {\n+\n+  private static ArrowUtils instance;\n+  private RootAllocator rootAllocator;\n+\n+  private ArrowUtils() {\n+    rootAllocator = new RootAllocator(Long.MAX_VALUE);\n+  }\n+\n+  public static ArrowUtils instance() {\n+    if (instance == null) {\n+      instance = new ArrowUtils();\n+    }\n+    return instance;\n+  }\n+\n+  public RootAllocator rootAllocator() {\n+    return rootAllocator;\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+  public DataType fromArrowType(ArrowType data) {\n+\n+    if (data instanceof ArrowType.Bool) {\n+      return DataTypes.BooleanType;\n+    } else if (data instanceof ArrowType.Int) {\n+      ArrowType.Int intData = (ArrowType.Int) data;\n+      if (intData.getIsSigned() && intData.getBitWidth() == 8) {\n+        return DataTypes.ByteType;\n+      } else if (intData.getIsSigned() && intData.getBitWidth() == 8 * 2) {\n+        return DataTypes.ShortType;\n+      } else if (intData.getIsSigned() && intData.getBitWidth() == 8 * 4) {\n+        return DataTypes.IntegerType;\n+      } else if (intData.getIsSigned() && intData.getBitWidth() == 8 * 8) {\n+        return DataTypes.LongType;\n+      }\n+    } else if (data instanceof ArrowType.FloatingPoint) {\n+      ArrowType.FloatingPoint floatData = (ArrowType.FloatingPoint) data;\n+      if (floatData.getPrecision() == FloatingPointPrecision.SINGLE) {\n+        return DataTypes.FloatType;\n+      } else if (floatData.getPrecision() == FloatingPointPrecision.DOUBLE) {\n+        return DataTypes.DoubleType;\n+      }\n+    } else if (data instanceof ArrowType.Utf8) {\n+      return DataTypes.StringType;\n+    } else if (data instanceof ArrowType.Binary) {\n+      return DataTypes.BinaryType;\n+    } else if (data instanceof ArrowType.Decimal) {\n+      ArrowType.Decimal decimalData = (ArrowType.Decimal) data;\n+      return new DecimalType(decimalData.getPrecision(), decimalData.getScale());\n+    } else if (data instanceof ArrowType.Date && ((ArrowType.Date) data).getUnit() == DateUnit.DAY) {\n+      return DataTypes.DateType;\n+    } else if (data instanceof ArrowType.Timestamp && ((ArrowType.Timestamp) data).getUnit() == TimeUnit.MICROSECOND) {\n+      return DataTypes.TimestampType;\n+    }\n+\n+    throw new UnsupportedOperationException(\"Unsupported data type: \" + data);\n+  }\n+\n+  public DataType fromArrowField(Field field) {", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMDI0NA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389120244", "body": "I thought we supported maps?", "bodyText": "I thought we supported maps?", "bodyHTML": "<p dir=\"auto\">I thought we supported maps?</p>", "author": "rdblue", "createdAt": "2020-03-06T20:10:29Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.arrow.ArrowUtils;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.DecimalMetadata;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+  private final Dictionary dictionary;\n+  private final boolean isVectorDictEncoded;\n+  private ArrowColumnVector[] childColumns;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(ArrowUtils.instance().fromArrowField(holder.vector().getField()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.dictionary = holder.dictionary();\n+    this.isVectorDictEncoded = holder.isDictionaryEncoded();\n+    this.accessor = getVectorAccessor(holder.descriptor(), holder.vector());\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+        childColumns[i] = null;\n+      }\n+      childColumns = null;\n+    }\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException();", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2NTk5Mg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r390665992", "bodyText": "Not currently, no.", "author": "samarthjain", "createdAt": "2020-03-10T23:19:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMDI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMDg0Ng==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389120846", "body": "Doesn't Spark check nullability and only call these methods if `isNullAt` is false? I thought that was why it isn't necessary to check this in the primitive methods, like `getLong`.", "bodyText": "Doesn't Spark check nullability and only call these methods if isNullAt is false? I thought that was why it isn't necessary to check this in the primitive methods, like getLong.", "bodyHTML": "<p dir=\"auto\">Doesn't Spark check nullability and only call these methods if <code>isNullAt</code> is false? I thought that was why it isn't necessary to check this in the primitive methods, like <code>getLong</code>.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:11:42Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.arrow.ArrowUtils;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.DecimalMetadata;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+  private final Dictionary dictionary;\n+  private final boolean isVectorDictEncoded;\n+  private ArrowColumnVector[] childColumns;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(ArrowUtils.instance().fromArrowField(holder.vector().getField()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.dictionary = holder.dictionary();\n+    this.isVectorDictEncoded = holder.isDictionaryEncoded();\n+    this.accessor = getVectorAccessor(holder.descriptor(), holder.vector());\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+        childColumns[i] = null;\n+      }\n+      childColumns = null;\n+    }\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (isNullAt(rowId)) {", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMjg1OA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389122858", "body": "I think this should be moved out of this method. There's no need for this method to have side-effects, and this makes it hard to understand how this class works because `childColumns` appears to be uninitialized when reading the constructor. I'd much rather add `childColumns()` to the `ArrowVectorAccessor` interface and initialize like this:\r\n\r\n```\r\n  this.accessor = VectorAccessors.get(vector);\r\n  this.childColumns = accessor.childColumns();\r\n```\r\n\r\nYou could also remove the `childColumns` field and always call `accessor.childColumns()`.", "bodyText": "I think this should be moved out of this method. There's no need for this method to have side-effects, and this makes it hard to understand how this class works because childColumns appears to be uninitialized when reading the constructor. I'd much rather add childColumns() to the ArrowVectorAccessor interface and initialize like this:\n  this.accessor = VectorAccessors.get(vector);\n  this.childColumns = accessor.childColumns();\n\nYou could also remove the childColumns field and always call accessor.childColumns().", "bodyHTML": "<p dir=\"auto\">I think this should be moved out of this method. There's no need for this method to have side-effects, and this makes it hard to understand how this class works because <code>childColumns</code> appears to be uninitialized when reading the constructor. I'd much rather add <code>childColumns()</code> to the <code>ArrowVectorAccessor</code> interface and initialize like this:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"  this.accessor = VectorAccessors.get(vector);\n  this.childColumns = accessor.childColumns();\n\"><pre><code>  this.accessor = VectorAccessors.get(vector);\n  this.childColumns = accessor.childColumns();\n</code></pre></div>\n<p dir=\"auto\">You could also remove the <code>childColumns</code> field and always call <code>accessor.childColumns()</code>.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:16:31Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.arrow.ArrowUtils;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.DecimalMetadata;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+  private final Dictionary dictionary;\n+  private final boolean isVectorDictEncoded;\n+  private ArrowColumnVector[] childColumns;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(ArrowUtils.instance().fromArrowField(holder.vector().getField()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.dictionary = holder.dictionary();\n+    this.isVectorDictEncoded = holder.isDictionaryEncoded();\n+    this.accessor = getVectorAccessor(holder.descriptor(), holder.vector());\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+        childColumns[i] = null;\n+      }\n+      childColumns = null;\n+    }\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  @Override\n+  public ArrowColumnVector getChild(int ordinal) {\n+    return childColumns[ordinal];\n+  }\n+\n+  private abstract class ArrowVectorAccessor {\n+\n+    private final ValueVector vector;\n+\n+    ArrowVectorAccessor(ValueVector vector) {\n+      this.vector = vector;\n+    }\n+\n+    final boolean isNullAt(int rowId) {\n+      return nullabilityHolder.isNullAt(rowId) == 1;\n+    }\n+\n+    final void close() {\n+      vector.close();\n+    }\n+\n+    boolean getBoolean(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte getByte(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    short getShort(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    int getInt(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    long getLong(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    float getFloat(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    double getDouble(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    Decimal getDecimal(int rowId, int precision, int scale) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    UTF8String getUTF8String(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte[] getBinary(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    ColumnarArray getArray(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+  private ArrowVectorAccessor getVectorAccessor(ColumnDescriptor desc, ValueVector vector) {\n+    PrimitiveType primitive = desc.getPrimitiveType();\n+    if (isVectorDictEncoded) {\n+      Preconditions.checkState(vector instanceof IntVector, \"Dictionary ids should be stored in IntVectors only\");\n+      if (primitive.getOriginalType() != null) {\n+        switch (desc.getPrimitiveType().getOriginalType()) {\n+          case ENUM:\n+          case JSON:\n+          case UTF8:\n+          case BSON:\n+            return new DictionaryStringAccessor((IntVector) vector);\n+          case INT_8:\n+          case INT_16:\n+          case INT_32:\n+          case DATE:\n+            return new DictionaryIntAccessor((IntVector) vector);\n+          case INT_64:\n+          case TIMESTAMP_MILLIS:\n+          case TIMESTAMP_MICROS:\n+            return new DictionaryLongAccessor((IntVector) vector);\n+          case DECIMAL:\n+            DecimalMetadata decimal = primitive.getDecimalMetadata();\n+            switch (primitive.getPrimitiveTypeName()) {\n+              case BINARY:\n+              case FIXED_LEN_BYTE_ARRAY:\n+                return new DictionaryDecimalBinaryAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              case INT64:\n+                return new DictionaryDecimalLongAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              case INT32:\n+                return new DictionaryDecimalIntAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              default:\n+                throw new UnsupportedOperationException(\n+                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n+            }\n+          default:\n+            throw new UnsupportedOperationException(\n+                \"Unsupported logical type: \" + primitive.getOriginalType());\n+        }\n+      } else {\n+        switch (primitive.getPrimitiveTypeName()) {\n+          case FIXED_LEN_BYTE_ARRAY:\n+          case BINARY:\n+            return new DictionaryBinaryAccessor((IntVector) vector);\n+          case INT32:\n+            return new DictionaryIntAccessor((IntVector) vector);\n+          case FLOAT:\n+            return new DictionaryFloatAccessor((IntVector) vector);\n+          case INT64:\n+            return new DictionaryLongAccessor((IntVector) vector);\n+          case DOUBLE:\n+            return new DictionaryDoubleAccessor((IntVector) vector);\n+          default:\n+            throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n+        }\n+      }\n+    } else {\n+      if (vector instanceof BitVector) {\n+        return new BooleanAccessor((BitVector) vector);\n+      } else if (vector instanceof TinyIntVector) {\n+        return new ByteAccessor((TinyIntVector) vector);\n+      } else if (vector instanceof SmallIntVector) {\n+        return new ShortAccessor((SmallIntVector) vector);\n+      } else if (vector instanceof IntVector) {\n+        return new IntAccessor((IntVector) vector);\n+      } else if (vector instanceof BigIntVector) {\n+        return new LongAccessor((BigIntVector) vector);\n+      } else if (vector instanceof Float4Vector) {\n+        return new FloatAccessor((Float4Vector) vector);\n+      } else if (vector instanceof Float8Vector) {\n+        return new DoubleAccessor((Float8Vector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.DecimalArrowVector) {\n+        return new DecimalAccessor((IcebergArrowVectors.DecimalArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarcharArrowVector) {\n+        return new StringAccessor((IcebergArrowVectors.VarcharArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarBinaryArrowVector) {\n+        return new BinaryAccessor((IcebergArrowVectors.VarBinaryArrowVector) vector);\n+      } else if (vector instanceof DateDayVector) {\n+        return new DateAccessor((DateDayVector) vector);\n+      } else if (vector instanceof TimeStampMicroTZVector) {\n+        return new TimestampAccessor((TimeStampMicroTZVector) vector);\n+      } else if (vector instanceof ListVector) {\n+        ListVector listVector = (ListVector) vector;\n+        return new ArrayAccessor(listVector);\n+      } else if (vector instanceof StructVector) {\n+        StructVector structVector = (StructVector) vector;\n+        ArrowVectorAccessor structAccessor = new StructAccessor(structVector);\n+        childColumns = new ArrowColumnVector[structVector.size()];", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyNDQ0Nw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389124447", "body": "It would be nice to have an error message with the type that was accessed.", "bodyText": "It would be nice to have an error message with the type that was accessed.", "bodyHTML": "<p dir=\"auto\">It would be nice to have an error message with the type that was accessed.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:20:26Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.arrow.ArrowUtils;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.DecimalMetadata;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+  private final Dictionary dictionary;\n+  private final boolean isVectorDictEncoded;\n+  private ArrowColumnVector[] childColumns;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(ArrowUtils.instance().fromArrowField(holder.vector().getField()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.dictionary = holder.dictionary();\n+    this.isVectorDictEncoded = holder.isDictionaryEncoded();\n+    this.accessor = getVectorAccessor(holder.descriptor(), holder.vector());\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+        childColumns[i] = null;\n+      }\n+      childColumns = null;\n+    }\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  @Override\n+  public ArrowColumnVector getChild(int ordinal) {\n+    return childColumns[ordinal];\n+  }\n+\n+  private abstract class ArrowVectorAccessor {\n+\n+    private final ValueVector vector;\n+\n+    ArrowVectorAccessor(ValueVector vector) {\n+      this.vector = vector;\n+    }\n+\n+    final boolean isNullAt(int rowId) {\n+      return nullabilityHolder.isNullAt(rowId) == 1;\n+    }\n+\n+    final void close() {\n+      vector.close();\n+    }\n+\n+    boolean getBoolean(int rowId) {\n+      throw new UnsupportedOperationException();", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyNjI3NQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389126275", "body": "Can we move these to a separate file? The convention used elsewhere is to put `ArrowVectorAccessor` in a file and the implementations in a `ArrowVectorAccessors` class with a private constructor.", "bodyText": "Can we move these to a separate file? The convention used elsewhere is to put ArrowVectorAccessor in a file and the implementations in a ArrowVectorAccessors class with a private constructor.", "bodyHTML": "<p dir=\"auto\">Can we move these to a separate file? The convention used elsewhere is to put <code>ArrowVectorAccessor</code> in a file and the implementations in a <code>ArrowVectorAccessors</code> class with a private constructor.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:24:36Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.arrow.ArrowUtils;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.DecimalMetadata;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+  private final Dictionary dictionary;\n+  private final boolean isVectorDictEncoded;\n+  private ArrowColumnVector[] childColumns;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(ArrowUtils.instance().fromArrowField(holder.vector().getField()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.dictionary = holder.dictionary();\n+    this.isVectorDictEncoded = holder.isDictionaryEncoded();\n+    this.accessor = getVectorAccessor(holder.descriptor(), holder.vector());\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+        childColumns[i] = null;\n+      }\n+      childColumns = null;\n+    }\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  @Override\n+  public ArrowColumnVector getChild(int ordinal) {\n+    return childColumns[ordinal];\n+  }\n+\n+  private abstract class ArrowVectorAccessor {", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyNjYzMQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389126631", "body": "Isn't the use of `final` in Arrow causing us trouble? Why use `final` here? Does it have a performance benefit?", "bodyText": "Isn't the use of final in Arrow causing us trouble? Why use final here? Does it have a performance benefit?", "bodyHTML": "<p dir=\"auto\">Isn't the use of <code>final</code> in Arrow causing us trouble? Why use <code>final</code> here? Does it have a performance benefit?</p>", "author": "rdblue", "createdAt": "2020-03-06T20:25:27Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.arrow.ArrowUtils;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.DecimalMetadata;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+  private final Dictionary dictionary;\n+  private final boolean isVectorDictEncoded;\n+  private ArrowColumnVector[] childColumns;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(ArrowUtils.instance().fromArrowField(holder.vector().getField()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.dictionary = holder.dictionary();\n+    this.isVectorDictEncoded = holder.isDictionaryEncoded();\n+    this.accessor = getVectorAccessor(holder.descriptor(), holder.vector());\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+        childColumns[i] = null;\n+      }\n+      childColumns = null;\n+    }\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  @Override\n+  public ArrowColumnVector getChild(int ordinal) {\n+    return childColumns[ordinal];\n+  }\n+\n+  private abstract class ArrowVectorAccessor {\n+\n+    private final ValueVector vector;\n+\n+    ArrowVectorAccessor(ValueVector vector) {\n+      this.vector = vector;\n+    }\n+\n+    final boolean isNullAt(int rowId) {", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyNzEzMQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389127131", "body": "`ArrowVectorAccessor` doesn't define `getStruct`. Do you mean `getChild`?", "bodyText": "ArrowVectorAccessor doesn't define getStruct. Do you mean getChild?", "bodyHTML": "<p dir=\"auto\"><code>ArrowVectorAccessor</code> doesn't define <code>getStruct</code>. Do you mean <code>getChild</code>?</p>", "author": "rdblue", "createdAt": "2020-03-06T20:26:33Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.arrow.ArrowUtils;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.DecimalMetadata;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+  private final Dictionary dictionary;\n+  private final boolean isVectorDictEncoded;\n+  private ArrowColumnVector[] childColumns;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(ArrowUtils.instance().fromArrowField(holder.vector().getField()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.dictionary = holder.dictionary();\n+    this.isVectorDictEncoded = holder.isDictionaryEncoded();\n+    this.accessor = getVectorAccessor(holder.descriptor(), holder.vector());\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+        childColumns[i] = null;\n+      }\n+      childColumns = null;\n+    }\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  @Override\n+  public ArrowColumnVector getChild(int ordinal) {\n+    return childColumns[ordinal];\n+  }\n+\n+  private abstract class ArrowVectorAccessor {\n+\n+    private final ValueVector vector;\n+\n+    ArrowVectorAccessor(ValueVector vector) {\n+      this.vector = vector;\n+    }\n+\n+    final boolean isNullAt(int rowId) {\n+      return nullabilityHolder.isNullAt(rowId) == 1;\n+    }\n+\n+    final void close() {\n+      vector.close();\n+    }\n+\n+    boolean getBoolean(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte getByte(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    short getShort(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    int getInt(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    long getLong(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    float getFloat(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    double getDouble(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    Decimal getDecimal(int rowId, int precision, int scale) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    UTF8String getUTF8String(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte[] getBinary(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    ColumnarArray getArray(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+  private ArrowVectorAccessor getVectorAccessor(ColumnDescriptor desc, ValueVector vector) {\n+    PrimitiveType primitive = desc.getPrimitiveType();\n+    if (isVectorDictEncoded) {\n+      Preconditions.checkState(vector instanceof IntVector, \"Dictionary ids should be stored in IntVectors only\");\n+      if (primitive.getOriginalType() != null) {\n+        switch (desc.getPrimitiveType().getOriginalType()) {\n+          case ENUM:\n+          case JSON:\n+          case UTF8:\n+          case BSON:\n+            return new DictionaryStringAccessor((IntVector) vector);\n+          case INT_8:\n+          case INT_16:\n+          case INT_32:\n+          case DATE:\n+            return new DictionaryIntAccessor((IntVector) vector);\n+          case INT_64:\n+          case TIMESTAMP_MILLIS:\n+          case TIMESTAMP_MICROS:\n+            return new DictionaryLongAccessor((IntVector) vector);\n+          case DECIMAL:\n+            DecimalMetadata decimal = primitive.getDecimalMetadata();\n+            switch (primitive.getPrimitiveTypeName()) {\n+              case BINARY:\n+              case FIXED_LEN_BYTE_ARRAY:\n+                return new DictionaryDecimalBinaryAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              case INT64:\n+                return new DictionaryDecimalLongAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              case INT32:\n+                return new DictionaryDecimalIntAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              default:\n+                throw new UnsupportedOperationException(\n+                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n+            }\n+          default:\n+            throw new UnsupportedOperationException(\n+                \"Unsupported logical type: \" + primitive.getOriginalType());\n+        }\n+      } else {\n+        switch (primitive.getPrimitiveTypeName()) {\n+          case FIXED_LEN_BYTE_ARRAY:\n+          case BINARY:\n+            return new DictionaryBinaryAccessor((IntVector) vector);\n+          case INT32:\n+            return new DictionaryIntAccessor((IntVector) vector);\n+          case FLOAT:\n+            return new DictionaryFloatAccessor((IntVector) vector);\n+          case INT64:\n+            return new DictionaryLongAccessor((IntVector) vector);\n+          case DOUBLE:\n+            return new DictionaryDoubleAccessor((IntVector) vector);\n+          default:\n+            throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n+        }\n+      }\n+    } else {\n+      if (vector instanceof BitVector) {\n+        return new BooleanAccessor((BitVector) vector);\n+      } else if (vector instanceof TinyIntVector) {\n+        return new ByteAccessor((TinyIntVector) vector);\n+      } else if (vector instanceof SmallIntVector) {\n+        return new ShortAccessor((SmallIntVector) vector);\n+      } else if (vector instanceof IntVector) {\n+        return new IntAccessor((IntVector) vector);\n+      } else if (vector instanceof BigIntVector) {\n+        return new LongAccessor((BigIntVector) vector);\n+      } else if (vector instanceof Float4Vector) {\n+        return new FloatAccessor((Float4Vector) vector);\n+      } else if (vector instanceof Float8Vector) {\n+        return new DoubleAccessor((Float8Vector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.DecimalArrowVector) {\n+        return new DecimalAccessor((IcebergArrowVectors.DecimalArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarcharArrowVector) {\n+        return new StringAccessor((IcebergArrowVectors.VarcharArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarBinaryArrowVector) {\n+        return new BinaryAccessor((IcebergArrowVectors.VarBinaryArrowVector) vector);\n+      } else if (vector instanceof DateDayVector) {\n+        return new DateAccessor((DateDayVector) vector);\n+      } else if (vector instanceof TimeStampMicroTZVector) {\n+        return new TimestampAccessor((TimeStampMicroTZVector) vector);\n+      } else if (vector instanceof ListVector) {\n+        ListVector listVector = (ListVector) vector;\n+        return new ArrayAccessor(listVector);\n+      } else if (vector instanceof StructVector) {\n+        StructVector structVector = (StructVector) vector;\n+        ArrowVectorAccessor structAccessor = new StructAccessor(structVector);\n+        childColumns = new ArrowColumnVector[structVector.size()];\n+        for (int i = 0; i < childColumns.length; ++i) {\n+          childColumns[i] = new ArrowColumnVector(structVector.getVectorById(i));\n+        }\n+        return structAccessor;\n+      }\n+    }\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  private class BooleanAccessor extends ArrowVectorAccessor {\n+\n+    private final BitVector vector;\n+\n+    BooleanAccessor(BitVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final boolean getBoolean(int rowId) {\n+      return vector.get(rowId) == 1;\n+    }\n+  }\n+\n+  private class ByteAccessor extends ArrowVectorAccessor {\n+\n+    private final TinyIntVector vector;\n+\n+    ByteAccessor(TinyIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte getByte(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class ShortAccessor extends ArrowVectorAccessor {\n+\n+    private final SmallIntVector vector;\n+\n+    ShortAccessor(SmallIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final short getShort(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class IntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    IntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryIntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryIntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return dictionary.decodeToInt(vector.get(rowId));\n+    }\n+  }\n+\n+  private class LongAccessor extends ArrowVectorAccessor {\n+\n+    private final BigIntVector vector;\n+\n+    LongAccessor(BigIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryLongAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryLongAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return dictionary.decodeToLong(vector.get(rowId));\n+    }\n+  }\n+\n+  private class FloatAccessor extends ArrowVectorAccessor {\n+\n+    private final Float4Vector vector;\n+\n+    FloatAccessor(Float4Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryFloatAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryFloatAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return dictionary.decodeToFloat(vector.get(rowId));\n+    }\n+  }\n+\n+  private class DoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final Float8Vector vector;\n+\n+    DoubleAccessor(Float8Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryDoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryDoubleAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return dictionary.decodeToDouble(vector.get(rowId));\n+    }\n+  }\n+\n+  private class DecimalAccessor extends ArrowVectorAccessor {\n+\n+    private final IcebergArrowVectors.DecimalArrowVector vector;\n+\n+    DecimalAccessor(IcebergArrowVectors.DecimalArrowVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final Decimal getDecimal(int rowId, int precision, int scale) {\n+      if (isNullAt(rowId)) {\n+        return null;\n+      }\n+      return Decimal.apply(vector.getObject(rowId), precision, scale);\n+    }\n+  }\n+\n+  private class StringAccessor extends ArrowVectorAccessor {\n+\n+    private final IcebergArrowVectors.VarcharArrowVector vector;\n+    private final NullableVarCharHolder stringResult = new NullableVarCharHolder();\n+\n+    StringAccessor(IcebergArrowVectors.VarcharArrowVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final UTF8String getUTF8String(int rowId) {\n+      vector.get(rowId, stringResult);\n+      if (stringResult.isSet == 0) {\n+        return null;\n+      } else {\n+        return UTF8String.fromAddress(\n+            null,\n+            stringResult.buffer.memoryAddress() + stringResult.start,\n+            stringResult.end - stringResult.start);\n+      }\n+    }\n+  }\n+\n+  private class DictionaryStringAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryStringAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final UTF8String getUTF8String(int rowId) {\n+      if (isNullAt(rowId)) {\n+        return null;\n+      }\n+      Binary binary = dictionary.decodeToBinary(vector.get(rowId));\n+      return UTF8String.fromBytes(binary.getBytesUnsafe());\n+    }\n+  }\n+\n+  private class FixedSizeBinaryAccessor extends ArrowVectorAccessor {\n+\n+    private final FixedSizeBinaryVector vector;\n+\n+    FixedSizeBinaryAccessor(FixedSizeBinaryVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte[] getBinary(int rowId) {\n+      return vector.getObject(rowId);\n+    }\n+  }\n+\n+  private class BinaryAccessor extends ArrowVectorAccessor {\n+\n+    private final VarBinaryVector vector;\n+\n+    BinaryAccessor(VarBinaryVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte[] getBinary(int rowId) {\n+      return vector.getObject(rowId);\n+    }\n+  }\n+\n+  private class DictionaryBinaryAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryBinaryAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte[] getBinary(int rowId) {\n+      Binary binary = dictionary.decodeToBinary(vector.get(rowId));\n+      return binary.getBytesUnsafe();\n+    }\n+  }\n+\n+  private class DateAccessor extends ArrowVectorAccessor {\n+\n+    private final DateDayVector vector;\n+\n+    DateAccessor(DateDayVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryDateAccessor extends DictionaryIntAccessor {\n+    DictionaryDateAccessor(IntVector vector) {\n+      super(vector);\n+    }\n+  }\n+\n+  private class TimestampAccessor extends ArrowVectorAccessor {\n+\n+    private final TimeStampMicroTZVector vector;\n+\n+    TimestampAccessor(TimeStampMicroTZVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryTimestampAccessor extends DictionaryLongAccessor {\n+    DictionaryTimestampAccessor(IntVector vector) {\n+      super(vector);\n+    }\n+  }\n+\n+  private class ArrayAccessor extends ArrowVectorAccessor {\n+\n+    private final ListVector vector;\n+    private final ArrowColumnVector arrayData;\n+\n+    ArrayAccessor(ListVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+      this.arrayData = new ArrowColumnVector(vector.getDataVector());\n+    }\n+\n+    @Override\n+    final ColumnarArray getArray(int rowId) {\n+      ArrowBuf offsets = vector.getOffsetBuffer();\n+      int index = rowId * ListVector.OFFSET_WIDTH;\n+      int start = offsets.getInt(index);\n+      int end = offsets.getInt(index + ListVector.OFFSET_WIDTH);\n+      return new ColumnarArray(arrayData, start, end - start);\n+    }\n+  }\n+\n+  /**\n+   * Any call to \"get\" method will throw UnsupportedOperationException.\n+   * <p>\n+   * Access struct values in a ArrowColumnVector doesn't use this vector. Instead, it uses getStruct() method defined in\n+   * the parent class. Any call to \"get\" method in this class is a bug in the code.", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyNzY2NA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389127664", "body": "I think these should process the dictionary first to transform each value to a `Decimal` and then use that table instead of the dictionary at read time.", "bodyText": "I think these should process the dictionary first to transform each value to a Decimal and then use that table instead of the dictionary at read time.", "bodyHTML": "<p dir=\"auto\">I think these should process the dictionary first to transform each value to a <code>Decimal</code> and then use that table instead of the dictionary at read time.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:27:46Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.arrow.ArrowUtils;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.DecimalMetadata;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+  private final Dictionary dictionary;\n+  private final boolean isVectorDictEncoded;\n+  private ArrowColumnVector[] childColumns;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(ArrowUtils.instance().fromArrowField(holder.vector().getField()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.dictionary = holder.dictionary();\n+    this.isVectorDictEncoded = holder.isDictionaryEncoded();\n+    this.accessor = getVectorAccessor(holder.descriptor(), holder.vector());\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+        childColumns[i] = null;\n+      }\n+      childColumns = null;\n+    }\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  @Override\n+  public ArrowColumnVector getChild(int ordinal) {\n+    return childColumns[ordinal];\n+  }\n+\n+  private abstract class ArrowVectorAccessor {\n+\n+    private final ValueVector vector;\n+\n+    ArrowVectorAccessor(ValueVector vector) {\n+      this.vector = vector;\n+    }\n+\n+    final boolean isNullAt(int rowId) {\n+      return nullabilityHolder.isNullAt(rowId) == 1;\n+    }\n+\n+    final void close() {\n+      vector.close();\n+    }\n+\n+    boolean getBoolean(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte getByte(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    short getShort(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    int getInt(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    long getLong(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    float getFloat(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    double getDouble(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    Decimal getDecimal(int rowId, int precision, int scale) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    UTF8String getUTF8String(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte[] getBinary(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    ColumnarArray getArray(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+  private ArrowVectorAccessor getVectorAccessor(ColumnDescriptor desc, ValueVector vector) {\n+    PrimitiveType primitive = desc.getPrimitiveType();\n+    if (isVectorDictEncoded) {\n+      Preconditions.checkState(vector instanceof IntVector, \"Dictionary ids should be stored in IntVectors only\");\n+      if (primitive.getOriginalType() != null) {\n+        switch (desc.getPrimitiveType().getOriginalType()) {\n+          case ENUM:\n+          case JSON:\n+          case UTF8:\n+          case BSON:\n+            return new DictionaryStringAccessor((IntVector) vector);\n+          case INT_8:\n+          case INT_16:\n+          case INT_32:\n+          case DATE:\n+            return new DictionaryIntAccessor((IntVector) vector);\n+          case INT_64:\n+          case TIMESTAMP_MILLIS:\n+          case TIMESTAMP_MICROS:\n+            return new DictionaryLongAccessor((IntVector) vector);\n+          case DECIMAL:\n+            DecimalMetadata decimal = primitive.getDecimalMetadata();\n+            switch (primitive.getPrimitiveTypeName()) {\n+              case BINARY:\n+              case FIXED_LEN_BYTE_ARRAY:\n+                return new DictionaryDecimalBinaryAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              case INT64:\n+                return new DictionaryDecimalLongAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              case INT32:\n+                return new DictionaryDecimalIntAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              default:\n+                throw new UnsupportedOperationException(\n+                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n+            }\n+          default:\n+            throw new UnsupportedOperationException(\n+                \"Unsupported logical type: \" + primitive.getOriginalType());\n+        }\n+      } else {\n+        switch (primitive.getPrimitiveTypeName()) {\n+          case FIXED_LEN_BYTE_ARRAY:\n+          case BINARY:\n+            return new DictionaryBinaryAccessor((IntVector) vector);\n+          case INT32:\n+            return new DictionaryIntAccessor((IntVector) vector);\n+          case FLOAT:\n+            return new DictionaryFloatAccessor((IntVector) vector);\n+          case INT64:\n+            return new DictionaryLongAccessor((IntVector) vector);\n+          case DOUBLE:\n+            return new DictionaryDoubleAccessor((IntVector) vector);\n+          default:\n+            throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n+        }\n+      }\n+    } else {\n+      if (vector instanceof BitVector) {\n+        return new BooleanAccessor((BitVector) vector);\n+      } else if (vector instanceof TinyIntVector) {\n+        return new ByteAccessor((TinyIntVector) vector);\n+      } else if (vector instanceof SmallIntVector) {\n+        return new ShortAccessor((SmallIntVector) vector);\n+      } else if (vector instanceof IntVector) {\n+        return new IntAccessor((IntVector) vector);\n+      } else if (vector instanceof BigIntVector) {\n+        return new LongAccessor((BigIntVector) vector);\n+      } else if (vector instanceof Float4Vector) {\n+        return new FloatAccessor((Float4Vector) vector);\n+      } else if (vector instanceof Float8Vector) {\n+        return new DoubleAccessor((Float8Vector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.DecimalArrowVector) {\n+        return new DecimalAccessor((IcebergArrowVectors.DecimalArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarcharArrowVector) {\n+        return new StringAccessor((IcebergArrowVectors.VarcharArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarBinaryArrowVector) {\n+        return new BinaryAccessor((IcebergArrowVectors.VarBinaryArrowVector) vector);\n+      } else if (vector instanceof DateDayVector) {\n+        return new DateAccessor((DateDayVector) vector);\n+      } else if (vector instanceof TimeStampMicroTZVector) {\n+        return new TimestampAccessor((TimeStampMicroTZVector) vector);\n+      } else if (vector instanceof ListVector) {\n+        ListVector listVector = (ListVector) vector;\n+        return new ArrayAccessor(listVector);\n+      } else if (vector instanceof StructVector) {\n+        StructVector structVector = (StructVector) vector;\n+        ArrowVectorAccessor structAccessor = new StructAccessor(structVector);\n+        childColumns = new ArrowColumnVector[structVector.size()];\n+        for (int i = 0; i < childColumns.length; ++i) {\n+          childColumns[i] = new ArrowColumnVector(structVector.getVectorById(i));\n+        }\n+        return structAccessor;\n+      }\n+    }\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  private class BooleanAccessor extends ArrowVectorAccessor {\n+\n+    private final BitVector vector;\n+\n+    BooleanAccessor(BitVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final boolean getBoolean(int rowId) {\n+      return vector.get(rowId) == 1;\n+    }\n+  }\n+\n+  private class ByteAccessor extends ArrowVectorAccessor {\n+\n+    private final TinyIntVector vector;\n+\n+    ByteAccessor(TinyIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte getByte(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class ShortAccessor extends ArrowVectorAccessor {\n+\n+    private final SmallIntVector vector;\n+\n+    ShortAccessor(SmallIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final short getShort(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class IntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    IntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryIntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryIntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return dictionary.decodeToInt(vector.get(rowId));\n+    }\n+  }\n+\n+  private class LongAccessor extends ArrowVectorAccessor {\n+\n+    private final BigIntVector vector;\n+\n+    LongAccessor(BigIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryLongAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryLongAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return dictionary.decodeToLong(vector.get(rowId));\n+    }\n+  }\n+\n+  private class FloatAccessor extends ArrowVectorAccessor {\n+\n+    private final Float4Vector vector;\n+\n+    FloatAccessor(Float4Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryFloatAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryFloatAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return dictionary.decodeToFloat(vector.get(rowId));\n+    }\n+  }\n+\n+  private class DoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final Float8Vector vector;\n+\n+    DoubleAccessor(Float8Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryDoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryDoubleAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return dictionary.decodeToDouble(vector.get(rowId));\n+    }\n+  }\n+\n+  private class DecimalAccessor extends ArrowVectorAccessor {\n+\n+    private final IcebergArrowVectors.DecimalArrowVector vector;\n+\n+    DecimalAccessor(IcebergArrowVectors.DecimalArrowVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final Decimal getDecimal(int rowId, int precision, int scale) {\n+      if (isNullAt(rowId)) {\n+        return null;\n+      }\n+      return Decimal.apply(vector.getObject(rowId), precision, scale);\n+    }\n+  }\n+\n+  private class StringAccessor extends ArrowVectorAccessor {\n+\n+    private final IcebergArrowVectors.VarcharArrowVector vector;\n+    private final NullableVarCharHolder stringResult = new NullableVarCharHolder();\n+\n+    StringAccessor(IcebergArrowVectors.VarcharArrowVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final UTF8String getUTF8String(int rowId) {\n+      vector.get(rowId, stringResult);\n+      if (stringResult.isSet == 0) {\n+        return null;\n+      } else {\n+        return UTF8String.fromAddress(\n+            null,\n+            stringResult.buffer.memoryAddress() + stringResult.start,\n+            stringResult.end - stringResult.start);\n+      }\n+    }\n+  }\n+\n+  private class DictionaryStringAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryStringAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final UTF8String getUTF8String(int rowId) {\n+      if (isNullAt(rowId)) {\n+        return null;\n+      }\n+      Binary binary = dictionary.decodeToBinary(vector.get(rowId));\n+      return UTF8String.fromBytes(binary.getBytesUnsafe());\n+    }\n+  }\n+\n+  private class FixedSizeBinaryAccessor extends ArrowVectorAccessor {\n+\n+    private final FixedSizeBinaryVector vector;\n+\n+    FixedSizeBinaryAccessor(FixedSizeBinaryVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte[] getBinary(int rowId) {\n+      return vector.getObject(rowId);\n+    }\n+  }\n+\n+  private class BinaryAccessor extends ArrowVectorAccessor {\n+\n+    private final VarBinaryVector vector;\n+\n+    BinaryAccessor(VarBinaryVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte[] getBinary(int rowId) {\n+      return vector.getObject(rowId);\n+    }\n+  }\n+\n+  private class DictionaryBinaryAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryBinaryAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte[] getBinary(int rowId) {\n+      Binary binary = dictionary.decodeToBinary(vector.get(rowId));\n+      return binary.getBytesUnsafe();\n+    }\n+  }\n+\n+  private class DateAccessor extends ArrowVectorAccessor {\n+\n+    private final DateDayVector vector;\n+\n+    DateAccessor(DateDayVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryDateAccessor extends DictionaryIntAccessor {\n+    DictionaryDateAccessor(IntVector vector) {\n+      super(vector);\n+    }\n+  }\n+\n+  private class TimestampAccessor extends ArrowVectorAccessor {\n+\n+    private final TimeStampMicroTZVector vector;\n+\n+    TimestampAccessor(TimeStampMicroTZVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryTimestampAccessor extends DictionaryLongAccessor {\n+    DictionaryTimestampAccessor(IntVector vector) {\n+      super(vector);\n+    }\n+  }\n+\n+  private class ArrayAccessor extends ArrowVectorAccessor {\n+\n+    private final ListVector vector;\n+    private final ArrowColumnVector arrayData;\n+\n+    ArrayAccessor(ListVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+      this.arrayData = new ArrowColumnVector(vector.getDataVector());\n+    }\n+\n+    @Override\n+    final ColumnarArray getArray(int rowId) {\n+      ArrowBuf offsets = vector.getOffsetBuffer();\n+      int index = rowId * ListVector.OFFSET_WIDTH;\n+      int start = offsets.getInt(index);\n+      int end = offsets.getInt(index + ListVector.OFFSET_WIDTH);\n+      return new ColumnarArray(arrayData, start, end - start);\n+    }\n+  }\n+\n+  /**\n+   * Any call to \"get\" method will throw UnsupportedOperationException.\n+   * <p>\n+   * Access struct values in a ArrowColumnVector doesn't use this vector. Instead, it uses getStruct() method defined in\n+   * the parent class. Any call to \"get\" method in this class is a bug in the code.\n+   */\n+  private class StructAccessor extends ArrowVectorAccessor {\n+\n+    StructAccessor(StructVector vector) {\n+      super(vector);\n+    }\n+  }\n+\n+  private class DictionaryDecimalBinaryAccessor extends ArrowVectorAccessor {\n+    private final IntVector vector;\n+\n+    DictionaryDecimalBinaryAccessor(IntVector vector, int precision, int scale) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    //TODO: still need to evaluate if this is the most efficient way\n+    @Override\n+    final Decimal getDecimal(int rowId, int precision, int scale) {\n+      if (isNullAt(rowId)) {\n+        return null;\n+      }\n+      Binary value = dictionary.decodeToBinary(vector.get(rowId));\n+      BigInteger unscaledValue = new BigInteger(value.getBytesUnsafe());\n+      return Decimal.apply(unscaledValue.longValue(), precision, scale);\n+    }\n+  }\n+\n+  private class DictionaryDecimalLongAccessor extends ArrowVectorAccessor {\n+    private final IntVector vector;\n+\n+    DictionaryDecimalLongAccessor(IntVector vector, int precision, int scale) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    //TODO: still need to evaluate if this is the most efficient way\n+    @Override\n+    final Decimal getDecimal(int rowId, int precision, int scale) {\n+      if (isNullAt(rowId)) {\n+        return null;\n+      }\n+      long unscaledValue = dictionary.decodeToLong(vector.get(rowId));\n+      return Decimal.apply(unscaledValue, precision, scale);", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyODQwMA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389128400", "body": "Nit: the indentation here was correct before.", "bodyText": "Nit: the indentation here was correct before.", "bodyHTML": "<p dir=\"auto\">Nit: the indentation here was correct before.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:29:26Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -91,20 +64,16 @@\n import org.apache.spark.sql.sources.v2.reader.SupportsPushDownFilters;\n import org.apache.spark.sql.sources.v2.reader.SupportsPushDownRequiredColumns;\n import org.apache.spark.sql.sources.v2.reader.SupportsReportStatistics;\n-import org.apache.spark.sql.types.BinaryType;\n+import org.apache.spark.sql.sources.v2.reader.SupportsScanColumnarBatch;\n import org.apache.spark.sql.types.DataType;\n-import org.apache.spark.sql.types.Decimal;\n-import org.apache.spark.sql.types.DecimalType;\n-import org.apache.spark.sql.types.StringType;\n import org.apache.spark.sql.types.StructField;\n import org.apache.spark.sql.types.StructType;\n-import org.apache.spark.unsafe.types.UTF8String;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.collection.JavaConverters;\n \n-class Reader implements DataSourceReader, SupportsPushDownFilters, SupportsPushDownRequiredColumns,\n-    SupportsReportStatistics {\n+class Reader implements DataSourceReader, SupportsScanColumnarBatch, SupportsPushDownFilters,\n+        SupportsPushDownRequiredColumns, SupportsReportStatistics {", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyODQ1OQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389128459", "body": "Nit: no need to remove this line.", "bodyText": "Nit: no need to remove this line.", "bodyHTML": "<p dir=\"auto\">Nit: no need to remove this line.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:29:35Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -158,11 +129,19 @@\n     } else {\n       this.localityPreferred = false;\n     }\n-", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyOTEwMQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389129101", "body": "Options that enable/disable should use \"enabled\". That avoids users needing to think about whether options enable or disable - true always enables and false always disables.\r\n\r\nI recommend using `iceberg.read.parquet-vectorization.enabled`.", "bodyText": "Options that enable/disable should use \"enabled\". That avoids users needing to think about whether options enable or disable - true always enables and false always disables.\nI recommend using iceberg.read.parquet-vectorization.enabled.", "bodyHTML": "<p dir=\"auto\">Options that enable/disable should use \"enabled\". That avoids users needing to think about whether options enable or disable - true always enables and false always disables.</p>\n<p dir=\"auto\">I recommend using <code>iceberg.read.parquet-vectorization.enabled</code>.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:31:20Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -158,11 +129,19 @@\n     } else {\n       this.localityPreferred = false;\n     }\n-\n     this.schema = table.schema();\n     this.io = io;\n     this.encryptionManager = encryptionManager;\n     this.caseSensitive = caseSensitive;\n+    // override logic to check when batched reads is enabled by turning off batched reads\n+    boolean disableBatchedReads =\n+            options.get(\"iceberg.read.disablevectorizedreads\").map(Boolean::parseBoolean).orElse(false);", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyOTQ0Mg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389129442", "body": "How about `iceberg.read.parquet-vectorization.batch-size`?", "bodyText": "How about iceberg.read.parquet-vectorization.batch-size?", "bodyHTML": "<p dir=\"auto\">How about <code>iceberg.read.parquet-vectorization.batch-size</code>?</p>", "author": "rdblue", "createdAt": "2020-03-06T20:32:17Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -158,11 +129,19 @@\n     } else {\n       this.localityPreferred = false;\n     }\n-\n     this.schema = table.schema();\n     this.io = io;\n     this.encryptionManager = encryptionManager;\n     this.caseSensitive = caseSensitive;\n+    // override logic to check when batched reads is enabled by turning off batched reads\n+    boolean disableBatchedReads =\n+            options.get(\"iceberg.read.disablevectorizedreads\").map(Boolean::parseBoolean).orElse(false);\n+    if (disableBatchedReads) {\n+      enableBatchRead = Boolean.FALSE;\n+    }\n+    Optional<String> numRecordsPerBatchOpt = options.get(\"iceberg.read.numrecordsperbatch\");", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMDI2OQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389130269", "body": "Javadoc: Instead of `[...]`, did you mean to use either `{@link ...}` to link to the class, or `{@code ...}` to use fixed-width font?", "bodyText": "Javadoc: Instead of [...], did you mean to use either {@link ...} to link to the class, or {@code ...} to use fixed-width font?", "bodyHTML": "<p dir=\"auto\">Javadoc: Instead of <code>[...]</code>, did you mean to use either <code>{@link ...}</code> to link to the class, or <code>{@code ...}</code> to use fixed-width font?</p>", "author": "rdblue", "createdAt": "2020-03-06T20:34:17Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -188,6 +167,27 @@ public StructType readSchema() {\n     return lazyType();\n   }\n \n+  /**\n+   * This is called in the Spark Driver when data is to be materialized into [ColumnarBatch]s", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMDY5Mg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389130692", "body": "Can we move this refactor into a separate PR?", "bodyText": "Can we move this refactor into a separate PR?", "bodyHTML": "<p dir=\"auto\">Can we move this refactor into a separate PR?</p>", "author": "rdblue", "createdAt": "2020-03-06T20:35:26Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/InternalRowTaskDataReader.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import java.nio.ByteBuffer;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import org.apache.iceberg.CombinedScanTask;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DataTask;\n+import org.apache.iceberg.FileScanTask;\n+import org.apache.iceberg.PartitionField;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.StructLike;\n+import org.apache.iceberg.avro.Avro;\n+import org.apache.iceberg.encryption.EncryptionManager;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.io.InputFile;\n+import org.apache.iceberg.orc.ORC;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.spark.SparkSchemaUtil;\n+import org.apache.iceberg.spark.data.SparkAvroReader;\n+import org.apache.iceberg.spark.data.SparkOrcReader;\n+import org.apache.iceberg.spark.data.SparkParquetReaders;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+import org.apache.iceberg.util.ByteBuffers;\n+import org.apache.spark.rdd.InputFileBlockHolder;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference;\n+import org.apache.spark.sql.catalyst.expressions.GenericInternalRow;\n+import org.apache.spark.sql.catalyst.expressions.JoinedRow;\n+import org.apache.spark.sql.catalyst.expressions.UnsafeProjection;\n+import org.apache.spark.sql.sources.v2.reader.InputPartitionReader;\n+import org.apache.spark.sql.types.BinaryType;\n+import org.apache.spark.sql.types.DataType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.types.DecimalType;\n+import org.apache.spark.sql.types.StringType;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import org.apache.spark.unsafe.types.UTF8String;\n+import scala.collection.JavaConverters;\n+\n+class InternalRowTaskDataReader extends BaseTaskDataReader<InternalRow> implements InputPartitionReader<InternalRow> {", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU3NjExMg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r394576112", "bodyText": "I am going to leave these changes in this PR and start a new PR for the refactor. Once the refactor PR is approved, I will merge those changes into this PR.", "author": "samarthjain", "createdAt": "2020-03-18T19:03:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMDY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY2MTkzOQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r394661939", "bodyText": "Opened #853", "author": "samarthjain", "createdAt": "2020-03-18T21:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMDY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMTE0Nw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389131147", "body": "It would be nice to make the names shorter. What about `BaseTaskReader`, `BatchTaskReader`, and `RowTaskReader`?", "bodyText": "It would be nice to make the names shorter. What about BaseTaskReader, BatchTaskReader, and RowTaskReader?", "bodyHTML": "<p dir=\"auto\">It would be nice to make the names shorter. What about <code>BaseTaskReader</code>, <code>BatchTaskReader</code>, and <code>RowTaskReader</code>?</p>", "author": "rdblue", "createdAt": "2020-03-06T20:36:26Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/ColumnarBatchTaskDataReader.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.Iterator;\n+import org.apache.iceberg.CombinedScanTask;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.FileScanTask;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.encryption.EncryptionManager;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.io.InputFile;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.spark.SparkSchemaUtil;\n+import org.apache.iceberg.spark.data.vectorized.VectorizedSparkParquetReaders;\n+import org.apache.spark.sql.sources.v2.reader.InputPartitionReader;\n+import org.apache.spark.sql.types.StructType;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n+\n+class ColumnarBatchTaskDataReader extends BaseTaskDataReader<ColumnarBatch>", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMTQ3MQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389131471", "body": "Nit: Can you remove `=>`?", "bodyText": "Nit: Can you remove =>?", "bodyHTML": "<p dir=\"auto\">Nit: Can you remove <code>=&gt;</code>?</p>", "author": "rdblue", "createdAt": "2020-03-06T20:37:08Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -188,6 +167,27 @@ public StructType readSchema() {\n     return lazyType();\n   }\n \n+  /**\n+   * This is called in the Spark Driver when data is to be materialized into [ColumnarBatch]s\n+   */\n+  @Override\n+  public List<InputPartition<ColumnarBatch>> planBatchInputPartitions() {\n+    Preconditions.checkState(enableBatchRead != null && enableBatchRead, \"Batched reads not enabled\");\n+    Preconditions.checkState(batchSize > 0, \"Invalid batch size\");\n+    String tableSchemaString = SchemaParser.toJson(table.schema());\n+    String expectedSchemaString = SchemaParser.toJson(lazySchema());\n+\n+    List<InputPartition<ColumnarBatch>> readTasks = Lists.newArrayList();\n+    for (CombinedScanTask task : tasks()) {\n+      readTasks.add(\n+              new ColumnarBatchReadTask(task, tableSchemaString, expectedSchemaString,\n+                      io, encryptionManager, caseSensitive, batchSize));\n+    }\n+    LOG.info(\"=> Batching input partitions with {} tasks.\", readTasks.size());", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMTgxNQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389131815", "body": "Why would `enableBatchRead` be null? Why not use a `boolean` instead?", "bodyText": "Why would enableBatchRead be null? Why not use a boolean instead?", "bodyHTML": "<p dir=\"auto\">Why would <code>enableBatchRead</code> be null? Why not use a <code>boolean</code> instead?</p>", "author": "rdblue", "createdAt": "2020-03-06T20:37:53Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -188,6 +167,27 @@ public StructType readSchema() {\n     return lazyType();\n   }\n \n+  /**\n+   * This is called in the Spark Driver when data is to be materialized into [ColumnarBatch]s\n+   */\n+  @Override\n+  public List<InputPartition<ColumnarBatch>> planBatchInputPartitions() {\n+    Preconditions.checkState(enableBatchRead != null && enableBatchRead, \"Batched reads not enabled\");", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYzODE2OQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r390638169", "bodyText": "enableBatchRead is of type Boolean. It is lazily initialized in enableBatchRead().", "author": "samarthjain", "createdAt": "2020-03-10T22:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMTgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNzc4Nw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410527787", "bodyText": "Accessing the enableBatchRead that is lazily computed creates an order dependency between this and enableBatchRead(). I'd rather simplify this and use the method call directly.", "author": "rdblue", "createdAt": "2020-04-18T00:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMTgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMjEzNQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389132135", "body": "Style: control flow statements should be followed by empty lines.", "bodyText": "Style: control flow statements should be followed by empty lines.", "bodyHTML": "<p dir=\"auto\">Style: control flow statements should be followed by empty lines.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:38:35Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -259,6 +259,43 @@ public Statistics estimateStatistics() {\n     return new Stats(sizeInBytes, numRows);\n   }\n \n+  @Override\n+  public boolean enableBatchRead() {\n+    return lazyCheckEnableBatchRead();\n+  }\n+\n+  private boolean lazyCheckEnableBatchRead() {\n+    boolean allParquetFiles =\n+            tasks().stream()\n+                    .allMatch(combinedScanTask -> combinedScanTask.files()\n+                            .stream()\n+                            .allMatch(fileScanTask -> fileScanTask.file().format().equals(\n+                                    FileFormat.PARQUET)));\n+    if (!allParquetFiles) {\n+      this.enableBatchRead = false;\n+      return false;\n+    }", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMjkzNw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389132937", "body": "Style: We typically indent method args from the same location. That would be either like it was before, or moving all of the method args to use the 4-space continuation indent.", "bodyText": "Style: We typically indent method args from the same location. That would be either like it was before, or moving all of the method args to use the 4-space continuation indent.", "bodyHTML": "<p dir=\"auto\">Style: We typically indent method args from the same location. That would be either like it was before, or moving all of the method args to use the 4-space continuation indent.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:40:32Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -305,61 +342,74 @@ public Statistics estimateStatistics() {\n   @Override\n   public String toString() {\n     return String.format(\n-        \"IcebergScan(table=%s, type=%s, filters=%s, caseSensitive=%s)\",\n-        table, lazySchema().asStruct(), filterExpressions, caseSensitive);\n+        \"IcebergScan(table=%s, type=%s, filters=%s, caseSensitive=%s, batchedReads=%s)\",\n+        table, lazySchema().asStruct(), filterExpressions, caseSensitive, enableBatchRead);\n   }\n \n-  private static class ReadTask implements InputPartition<InternalRow>, Serializable {\n-    private final CombinedScanTask task;\n+  @SuppressWarnings(\"checkstyle:VisibilityModifier\")\n+  private static class BaseReadTask implements Serializable {\n+    final CombinedScanTask task;\n     private final String tableSchemaString;\n     private final String expectedSchemaString;\n-    private final Broadcast<FileIO> io;\n-    private final Broadcast<EncryptionManager> encryptionManager;\n-    private final boolean caseSensitive;\n-    private final boolean localityPreferred;\n+    final Broadcast<FileIO> io;\n+    final Broadcast<EncryptionManager> encryptionManager;\n+    final boolean caseSensitive;\n \n     private transient Schema tableSchema = null;\n     private transient Schema expectedSchema = null;\n-    private transient String[] preferredLocations;\n \n-    private ReadTask(CombinedScanTask task, String tableSchemaString, String expectedSchemaString,\n-                     Broadcast<FileIO> io, Broadcast<EncryptionManager> encryptionManager,\n-                     boolean caseSensitive, boolean localityPreferred) {\n+    BaseReadTask(CombinedScanTask task, String tableSchemaString, String expectedSchemaString,\n+        Broadcast<FileIO> io, Broadcast<EncryptionManager> encryptionManager,", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMzIzNA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389133234", "body": "Nit: unnecessary newline.", "bodyText": "Nit: unnecessary newline.", "bodyHTML": "<p dir=\"auto\">Nit: unnecessary newline.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:41:16Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -305,61 +342,74 @@ public Statistics estimateStatistics() {\n   @Override\n   public String toString() {\n     return String.format(\n-        \"IcebergScan(table=%s, type=%s, filters=%s, caseSensitive=%s)\",\n-        table, lazySchema().asStruct(), filterExpressions, caseSensitive);\n+        \"IcebergScan(table=%s, type=%s, filters=%s, caseSensitive=%s, batchedReads=%s)\",\n+        table, lazySchema().asStruct(), filterExpressions, caseSensitive, enableBatchRead);\n   }\n \n-  private static class ReadTask implements InputPartition<InternalRow>, Serializable {\n-    private final CombinedScanTask task;\n+  @SuppressWarnings(\"checkstyle:VisibilityModifier\")\n+  private static class BaseReadTask implements Serializable {\n+    final CombinedScanTask task;\n     private final String tableSchemaString;\n     private final String expectedSchemaString;\n-    private final Broadcast<FileIO> io;\n-    private final Broadcast<EncryptionManager> encryptionManager;\n-    private final boolean caseSensitive;\n-    private final boolean localityPreferred;\n+    final Broadcast<FileIO> io;\n+    final Broadcast<EncryptionManager> encryptionManager;\n+    final boolean caseSensitive;\n \n     private transient Schema tableSchema = null;\n     private transient Schema expectedSchema = null;\n-    private transient String[] preferredLocations;\n \n-    private ReadTask(CombinedScanTask task, String tableSchemaString, String expectedSchemaString,\n-                     Broadcast<FileIO> io, Broadcast<EncryptionManager> encryptionManager,\n-                     boolean caseSensitive, boolean localityPreferred) {\n+    BaseReadTask(CombinedScanTask task, String tableSchemaString, String expectedSchemaString,\n+        Broadcast<FileIO> io, Broadcast<EncryptionManager> encryptionManager,\n+        boolean caseSensitive) {\n       this.task = task;\n       this.tableSchemaString = tableSchemaString;\n       this.expectedSchemaString = expectedSchemaString;\n       this.io = io;\n       this.encryptionManager = encryptionManager;\n       this.caseSensitive = caseSensitive;\n-      this.localityPreferred = localityPreferred;\n-      this.preferredLocations = getPreferredLocations();\n     }\n \n-    @Override\n-    public InputPartitionReader<InternalRow> createPartitionReader() {\n-      return new TaskDataReader(task, lazyTableSchema(), lazyExpectedSchema(), io.value(),\n-        encryptionManager.value(), caseSensitive);\n-    }\n-\n-    @Override\n-    public String[] preferredLocations() {\n-      return preferredLocations;\n-    }\n-\n-    private Schema lazyTableSchema() {\n+    Schema lazyTableSchema() {\n       if (tableSchema == null) {\n         this.tableSchema = SchemaParser.fromJson(tableSchemaString);\n       }\n       return tableSchema;\n     }\n \n-    private Schema lazyExpectedSchema() {\n+    Schema lazyExpectedSchema() {\n       if (expectedSchema == null) {\n         this.expectedSchema = SchemaParser.fromJson(expectedSchemaString);\n       }\n       return expectedSchema;\n     }\n \n+", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMzgwNA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389133804", "body": "Nit: extra newline.", "bodyText": "Nit: extra newline.", "bodyHTML": "<p dir=\"auto\">Nit: extra newline.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:42:33Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -699,4 +486,5 @@ public int size() {\n       throw new UnsupportedOperationException(\"Not implemented: set\");\n     }\n   }\n+", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzNDA1MQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389134051", "body": "Why doesn't this support preferred locations?", "bodyText": "Why doesn't this support preferred locations?", "bodyHTML": "<p dir=\"auto\">Why doesn't this support preferred locations?</p>", "author": "rdblue", "createdAt": "2020-03-06T20:43:09Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -383,286 +433,23 @@ private Schema lazyExpectedSchema() {\n     }\n   }\n \n-  private static class TaskDataReader implements InputPartitionReader<InternalRow> {\n-    // for some reason, the apply method can't be called from Java without reflection\n-    private static final DynMethods.UnboundMethod APPLY_PROJECTION = DynMethods.builder(\"apply\")\n-        .impl(UnsafeProjection.class, InternalRow.class)\n-        .build();\n-\n-    private final Iterator<FileScanTask> tasks;\n-    private final Schema tableSchema;\n-    private final Schema expectedSchema;\n-    private final FileIO fileIo;\n-    private final Map<String, InputFile> inputFiles;\n-    private final boolean caseSensitive;\n-\n-    private Iterator<InternalRow> currentIterator = null;\n-    private Closeable currentCloseable = null;\n-    private InternalRow current = null;\n-\n-    TaskDataReader(CombinedScanTask task, Schema tableSchema, Schema expectedSchema, FileIO fileIo,\n-                   EncryptionManager encryptionManager, boolean caseSensitive) {\n-      this.fileIo = fileIo;\n-      this.tasks = task.files().iterator();\n-      this.tableSchema = tableSchema;\n-      this.expectedSchema = expectedSchema;\n-      Iterable<InputFile> decryptedFiles = encryptionManager.decrypt(Iterables.transform(task.files(),\n-          fileScanTask ->\n-              EncryptedFiles.encryptedInput(\n-                  this.fileIo.newInputFile(fileScanTask.file().path().toString()),\n-                  fileScanTask.file().keyMetadata())));\n-      ImmutableMap.Builder<String, InputFile> inputFileBuilder = ImmutableMap.builder();\n-      decryptedFiles.forEach(decrypted -> inputFileBuilder.put(decrypted.location(), decrypted));\n-      this.inputFiles = inputFileBuilder.build();\n-      // open last because the schemas and fileIo must be set\n-      this.currentIterator = open(tasks.next());\n-      this.caseSensitive = caseSensitive;\n-    }\n+  /**\n+   * Organizes input data into [InputPartition]s for Vectorized [ColumnarBatch] reads\n+   */\n+  private static class ColumnarBatchReadTask extends BaseReadTask implements InputPartition<ColumnarBatch> {", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzNDYwMA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389134600", "body": "This should be `enableBatchRead()`.", "bodyText": "This should be enableBatchRead().", "bodyHTML": "<p dir=\"auto\">This should be <code>enableBatchRead()</code>.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:44:20Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -305,61 +342,74 @@ public Statistics estimateStatistics() {\n   @Override\n   public String toString() {\n     return String.format(\n-        \"IcebergScan(table=%s, type=%s, filters=%s, caseSensitive=%s)\",\n-        table, lazySchema().asStruct(), filterExpressions, caseSensitive);\n+        \"IcebergScan(table=%s, type=%s, filters=%s, caseSensitive=%s, batchedReads=%s)\",\n+        table, lazySchema().asStruct(), filterExpressions, caseSensitive, enableBatchRead);", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzNzQ0NA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389137444", "body": "Looks like the only differences between the batch and row tasks is the locality and batch size. Locality should probably be supported by both. If that's done, then do we need 3 classes? What about using one and using `batchSize=1` for row-based tasks? Then we'd be able to have just one class for both cases.", "bodyText": "Looks like the only differences between the batch and row tasks is the locality and batch size. Locality should probably be supported by both. If that's done, then do we need 3 classes? What about using one and using batchSize=1 for row-based tasks? Then we'd be able to have just one class for both cases.", "bodyHTML": "<p dir=\"auto\">Looks like the only differences between the batch and row tasks is the locality and batch size. Locality should probably be supported by both. If that's done, then do we need 3 classes? What about using one and using <code>batchSize=1</code> for row-based tasks? Then we'd be able to have just one class for both cases.</p>", "author": "rdblue", "createdAt": "2020-03-06T20:51:01Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -305,61 +342,74 @@ public Statistics estimateStatistics() {\n   @Override\n   public String toString() {\n     return String.format(\n-        \"IcebergScan(table=%s, type=%s, filters=%s, caseSensitive=%s)\",\n-        table, lazySchema().asStruct(), filterExpressions, caseSensitive);\n+        \"IcebergScan(table=%s, type=%s, filters=%s, caseSensitive=%s, batchedReads=%s)\",\n+        table, lazySchema().asStruct(), filterExpressions, caseSensitive, enableBatchRead);\n   }\n \n-  private static class ReadTask implements InputPartition<InternalRow>, Serializable {\n-    private final CombinedScanTask task;\n+  @SuppressWarnings(\"checkstyle:VisibilityModifier\")\n+  private static class BaseReadTask implements Serializable {\n+    final CombinedScanTask task;\n     private final String tableSchemaString;\n     private final String expectedSchemaString;\n-    private final Broadcast<FileIO> io;\n-    private final Broadcast<EncryptionManager> encryptionManager;\n-    private final boolean caseSensitive;\n-    private final boolean localityPreferred;\n+    final Broadcast<FileIO> io;\n+    final Broadcast<EncryptionManager> encryptionManager;\n+    final boolean caseSensitive;\n \n     private transient Schema tableSchema = null;\n     private transient Schema expectedSchema = null;\n-    private transient String[] preferredLocations;\n \n-    private ReadTask(CombinedScanTask task, String tableSchemaString, String expectedSchemaString,\n-                     Broadcast<FileIO> io, Broadcast<EncryptionManager> encryptionManager,\n-                     boolean caseSensitive, boolean localityPreferred) {\n+    BaseReadTask(CombinedScanTask task, String tableSchemaString, String expectedSchemaString,", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYzNTAyNA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r390635024", "bodyText": "I think 3 classes are still needed since we create different InputPartitionReader for each version.", "author": "samarthjain", "createdAt": "2020-03-10T21:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzNzQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2ODM1OA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r390668358", "bodyText": "You're right. That was changed in a later version of the API. What about using anonymous classes and an abstract BaseReadTask? That might be clean, but up to you.", "author": "rdblue", "createdAt": "2020-03-10T23:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzNzQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NjE0NA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389176144", "body": "Could this implement `VectorHolder` and get passed into the read method, rather than allocating a `VectorHolder` and copying its contents?", "bodyText": "Could this implement VectorHolder and get passed into the read method, rather than allocating a VectorHolder and copying its contents?", "bodyHTML": "<p dir=\"auto\">Could this implement <code>VectorHolder</code> and get passed into the read method, rather than allocating a <code>VectorHolder</code> and copying its contents?</p>", "author": "rdblue", "createdAt": "2020-03-06T22:32:44Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.arrow.ArrowUtils;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.DecimalMetadata;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+\n+public class IcebergArrowColumnVector extends ColumnVector {", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNzgxNQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r395337815", "bodyText": "Not sure I follow, @rdblue.", "author": "samarthjain", "createdAt": "2020-03-19T21:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NjE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NjU1Mw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389176553", "body": "Is this necessary if we always eagerly decode ints?", "bodyText": "Is this necessary if we always eagerly decode ints?", "bodyHTML": "<p dir=\"auto\">Is this necessary if we always eagerly decode ints?</p>", "author": "rdblue", "createdAt": "2020-03-06T22:33:51Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.arrow.ArrowUtils;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.DecimalMetadata;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+  private final Dictionary dictionary;\n+  private final boolean isVectorDictEncoded;\n+  private ArrowColumnVector[] childColumns;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(ArrowUtils.instance().fromArrowField(holder.vector().getField()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.dictionary = holder.dictionary();\n+    this.isVectorDictEncoded = holder.isDictionaryEncoded();\n+    this.accessor = getVectorAccessor(holder.descriptor(), holder.vector());\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+        childColumns[i] = null;\n+      }\n+      childColumns = null;\n+    }\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  @Override\n+  public ArrowColumnVector getChild(int ordinal) {\n+    return childColumns[ordinal];\n+  }\n+\n+  private abstract class ArrowVectorAccessor {\n+\n+    private final ValueVector vector;\n+\n+    ArrowVectorAccessor(ValueVector vector) {\n+      this.vector = vector;\n+    }\n+\n+    final boolean isNullAt(int rowId) {\n+      return nullabilityHolder.isNullAt(rowId) == 1;\n+    }\n+\n+    final void close() {\n+      vector.close();\n+    }\n+\n+    boolean getBoolean(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte getByte(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    short getShort(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    int getInt(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    long getLong(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    float getFloat(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    double getDouble(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    Decimal getDecimal(int rowId, int precision, int scale) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    UTF8String getUTF8String(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte[] getBinary(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    ColumnarArray getArray(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+  private ArrowVectorAccessor getVectorAccessor(ColumnDescriptor desc, ValueVector vector) {\n+    PrimitiveType primitive = desc.getPrimitiveType();\n+    if (isVectorDictEncoded) {\n+      Preconditions.checkState(vector instanceof IntVector, \"Dictionary ids should be stored in IntVectors only\");\n+      if (primitive.getOriginalType() != null) {\n+        switch (desc.getPrimitiveType().getOriginalType()) {\n+          case ENUM:\n+          case JSON:\n+          case UTF8:\n+          case BSON:\n+            return new DictionaryStringAccessor((IntVector) vector);\n+          case INT_8:\n+          case INT_16:\n+          case INT_32:\n+          case DATE:\n+            return new DictionaryIntAccessor((IntVector) vector);\n+          case INT_64:\n+          case TIMESTAMP_MILLIS:\n+          case TIMESTAMP_MICROS:\n+            return new DictionaryLongAccessor((IntVector) vector);\n+          case DECIMAL:\n+            DecimalMetadata decimal = primitive.getDecimalMetadata();\n+            switch (primitive.getPrimitiveTypeName()) {\n+              case BINARY:\n+              case FIXED_LEN_BYTE_ARRAY:\n+                return new DictionaryDecimalBinaryAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              case INT64:\n+                return new DictionaryDecimalLongAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              case INT32:\n+                return new DictionaryDecimalIntAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              default:\n+                throw new UnsupportedOperationException(\n+                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n+            }\n+          default:\n+            throw new UnsupportedOperationException(\n+                \"Unsupported logical type: \" + primitive.getOriginalType());\n+        }\n+      } else {\n+        switch (primitive.getPrimitiveTypeName()) {\n+          case FIXED_LEN_BYTE_ARRAY:\n+          case BINARY:\n+            return new DictionaryBinaryAccessor((IntVector) vector);\n+          case INT32:\n+            return new DictionaryIntAccessor((IntVector) vector);\n+          case FLOAT:\n+            return new DictionaryFloatAccessor((IntVector) vector);\n+          case INT64:\n+            return new DictionaryLongAccessor((IntVector) vector);\n+          case DOUBLE:\n+            return new DictionaryDoubleAccessor((IntVector) vector);\n+          default:\n+            throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n+        }\n+      }\n+    } else {\n+      if (vector instanceof BitVector) {\n+        return new BooleanAccessor((BitVector) vector);\n+      } else if (vector instanceof TinyIntVector) {\n+        return new ByteAccessor((TinyIntVector) vector);\n+      } else if (vector instanceof SmallIntVector) {\n+        return new ShortAccessor((SmallIntVector) vector);\n+      } else if (vector instanceof IntVector) {\n+        return new IntAccessor((IntVector) vector);\n+      } else if (vector instanceof BigIntVector) {\n+        return new LongAccessor((BigIntVector) vector);\n+      } else if (vector instanceof Float4Vector) {\n+        return new FloatAccessor((Float4Vector) vector);\n+      } else if (vector instanceof Float8Vector) {\n+        return new DoubleAccessor((Float8Vector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.DecimalArrowVector) {\n+        return new DecimalAccessor((IcebergArrowVectors.DecimalArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarcharArrowVector) {\n+        return new StringAccessor((IcebergArrowVectors.VarcharArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarBinaryArrowVector) {\n+        return new BinaryAccessor((IcebergArrowVectors.VarBinaryArrowVector) vector);\n+      } else if (vector instanceof DateDayVector) {\n+        return new DateAccessor((DateDayVector) vector);\n+      } else if (vector instanceof TimeStampMicroTZVector) {\n+        return new TimestampAccessor((TimeStampMicroTZVector) vector);\n+      } else if (vector instanceof ListVector) {\n+        ListVector listVector = (ListVector) vector;\n+        return new ArrayAccessor(listVector);\n+      } else if (vector instanceof StructVector) {\n+        StructVector structVector = (StructVector) vector;\n+        ArrowVectorAccessor structAccessor = new StructAccessor(structVector);\n+        childColumns = new ArrowColumnVector[structVector.size()];\n+        for (int i = 0; i < childColumns.length; ++i) {\n+          childColumns[i] = new ArrowColumnVector(structVector.getVectorById(i));\n+        }\n+        return structAccessor;\n+      }\n+    }\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  private class BooleanAccessor extends ArrowVectorAccessor {\n+\n+    private final BitVector vector;\n+\n+    BooleanAccessor(BitVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final boolean getBoolean(int rowId) {\n+      return vector.get(rowId) == 1;\n+    }\n+  }\n+\n+  private class ByteAccessor extends ArrowVectorAccessor {\n+\n+    private final TinyIntVector vector;\n+\n+    ByteAccessor(TinyIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte getByte(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class ShortAccessor extends ArrowVectorAccessor {\n+\n+    private final SmallIntVector vector;\n+\n+    ShortAccessor(SmallIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final short getShort(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class IntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    IntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryIntAccessor extends ArrowVectorAccessor {", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3ODEzMg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389178132", "body": "Have we tested using `IntVector` instead of `DateDayVector`?\r\n\r\nIt would simplify the decoding logic to always use an `IntVector`, and I'm not sure what the benefit of using a `DateDayVector` is. Isn't the underlying buffer identical?\r\n\r\nSame logic applies for `TimeStampMicroTZVector` and `LongVector`.", "bodyText": "Have we tested using IntVector instead of DateDayVector?\nIt would simplify the decoding logic to always use an IntVector, and I'm not sure what the benefit of using a DateDayVector is. Isn't the underlying buffer identical?\nSame logic applies for TimeStampMicroTZVector and LongVector.", "bodyHTML": "<p dir=\"auto\">Have we tested using <code>IntVector</code> instead of <code>DateDayVector</code>?</p>\n<p dir=\"auto\">It would simplify the decoding logic to always use an <code>IntVector</code>, and I'm not sure what the benefit of using a <code>DateDayVector</code> is. Isn't the underlying buffer identical?</p>\n<p dir=\"auto\">Same logic applies for <code>TimeStampMicroTZVector</code> and <code>LongVector</code>.</p>", "author": "rdblue", "createdAt": "2020-03-06T22:38:44Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.arrow.ArrowUtils;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.DecimalMetadata;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+  private final Dictionary dictionary;\n+  private final boolean isVectorDictEncoded;\n+  private ArrowColumnVector[] childColumns;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(ArrowUtils.instance().fromArrowField(holder.vector().getField()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.dictionary = holder.dictionary();\n+    this.isVectorDictEncoded = holder.isDictionaryEncoded();\n+    this.accessor = getVectorAccessor(holder.descriptor(), holder.vector());\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+        childColumns[i] = null;\n+      }\n+      childColumns = null;\n+    }\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  @Override\n+  public ArrowColumnVector getChild(int ordinal) {\n+    return childColumns[ordinal];\n+  }\n+\n+  private abstract class ArrowVectorAccessor {\n+\n+    private final ValueVector vector;\n+\n+    ArrowVectorAccessor(ValueVector vector) {\n+      this.vector = vector;\n+    }\n+\n+    final boolean isNullAt(int rowId) {\n+      return nullabilityHolder.isNullAt(rowId) == 1;\n+    }\n+\n+    final void close() {\n+      vector.close();\n+    }\n+\n+    boolean getBoolean(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte getByte(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    short getShort(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    int getInt(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    long getLong(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    float getFloat(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    double getDouble(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    Decimal getDecimal(int rowId, int precision, int scale) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    UTF8String getUTF8String(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte[] getBinary(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    ColumnarArray getArray(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+  private ArrowVectorAccessor getVectorAccessor(ColumnDescriptor desc, ValueVector vector) {\n+    PrimitiveType primitive = desc.getPrimitiveType();\n+    if (isVectorDictEncoded) {\n+      Preconditions.checkState(vector instanceof IntVector, \"Dictionary ids should be stored in IntVectors only\");\n+      if (primitive.getOriginalType() != null) {\n+        switch (desc.getPrimitiveType().getOriginalType()) {\n+          case ENUM:\n+          case JSON:\n+          case UTF8:\n+          case BSON:\n+            return new DictionaryStringAccessor((IntVector) vector);\n+          case INT_8:\n+          case INT_16:\n+          case INT_32:\n+          case DATE:\n+            return new DictionaryIntAccessor((IntVector) vector);\n+          case INT_64:\n+          case TIMESTAMP_MILLIS:\n+          case TIMESTAMP_MICROS:\n+            return new DictionaryLongAccessor((IntVector) vector);\n+          case DECIMAL:\n+            DecimalMetadata decimal = primitive.getDecimalMetadata();\n+            switch (primitive.getPrimitiveTypeName()) {\n+              case BINARY:\n+              case FIXED_LEN_BYTE_ARRAY:\n+                return new DictionaryDecimalBinaryAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              case INT64:\n+                return new DictionaryDecimalLongAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              case INT32:\n+                return new DictionaryDecimalIntAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              default:\n+                throw new UnsupportedOperationException(\n+                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n+            }\n+          default:\n+            throw new UnsupportedOperationException(\n+                \"Unsupported logical type: \" + primitive.getOriginalType());\n+        }\n+      } else {\n+        switch (primitive.getPrimitiveTypeName()) {\n+          case FIXED_LEN_BYTE_ARRAY:\n+          case BINARY:\n+            return new DictionaryBinaryAccessor((IntVector) vector);\n+          case INT32:\n+            return new DictionaryIntAccessor((IntVector) vector);\n+          case FLOAT:\n+            return new DictionaryFloatAccessor((IntVector) vector);\n+          case INT64:\n+            return new DictionaryLongAccessor((IntVector) vector);\n+          case DOUBLE:\n+            return new DictionaryDoubleAccessor((IntVector) vector);\n+          default:\n+            throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n+        }\n+      }\n+    } else {\n+      if (vector instanceof BitVector) {\n+        return new BooleanAccessor((BitVector) vector);\n+      } else if (vector instanceof TinyIntVector) {\n+        return new ByteAccessor((TinyIntVector) vector);\n+      } else if (vector instanceof SmallIntVector) {\n+        return new ShortAccessor((SmallIntVector) vector);\n+      } else if (vector instanceof IntVector) {\n+        return new IntAccessor((IntVector) vector);\n+      } else if (vector instanceof BigIntVector) {\n+        return new LongAccessor((BigIntVector) vector);\n+      } else if (vector instanceof Float4Vector) {\n+        return new FloatAccessor((Float4Vector) vector);\n+      } else if (vector instanceof Float8Vector) {\n+        return new DoubleAccessor((Float8Vector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.DecimalArrowVector) {\n+        return new DecimalAccessor((IcebergArrowVectors.DecimalArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarcharArrowVector) {\n+        return new StringAccessor((IcebergArrowVectors.VarcharArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarBinaryArrowVector) {\n+        return new BinaryAccessor((IcebergArrowVectors.VarBinaryArrowVector) vector);\n+      } else if (vector instanceof DateDayVector) {\n+        return new DateAccessor((DateDayVector) vector);\n+      } else if (vector instanceof TimeStampMicroTZVector) {\n+        return new TimestampAccessor((TimeStampMicroTZVector) vector);\n+      } else if (vector instanceof ListVector) {\n+        ListVector listVector = (ListVector) vector;\n+        return new ArrayAccessor(listVector);\n+      } else if (vector instanceof StructVector) {\n+        StructVector structVector = (StructVector) vector;\n+        ArrowVectorAccessor structAccessor = new StructAccessor(structVector);\n+        childColumns = new ArrowColumnVector[structVector.size()];\n+        for (int i = 0; i < childColumns.length; ++i) {\n+          childColumns[i] = new ArrowColumnVector(structVector.getVectorById(i));\n+        }\n+        return structAccessor;\n+      }\n+    }\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  private class BooleanAccessor extends ArrowVectorAccessor {\n+\n+    private final BitVector vector;\n+\n+    BooleanAccessor(BitVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final boolean getBoolean(int rowId) {\n+      return vector.get(rowId) == 1;\n+    }\n+  }\n+\n+  private class ByteAccessor extends ArrowVectorAccessor {\n+\n+    private final TinyIntVector vector;\n+\n+    ByteAccessor(TinyIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte getByte(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class ShortAccessor extends ArrowVectorAccessor {\n+\n+    private final SmallIntVector vector;\n+\n+    ShortAccessor(SmallIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final short getShort(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class IntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    IntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryIntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryIntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return dictionary.decodeToInt(vector.get(rowId));\n+    }\n+  }\n+\n+  private class LongAccessor extends ArrowVectorAccessor {\n+\n+    private final BigIntVector vector;\n+\n+    LongAccessor(BigIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryLongAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryLongAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return dictionary.decodeToLong(vector.get(rowId));\n+    }\n+  }\n+\n+  private class FloatAccessor extends ArrowVectorAccessor {\n+\n+    private final Float4Vector vector;\n+\n+    FloatAccessor(Float4Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryFloatAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryFloatAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return dictionary.decodeToFloat(vector.get(rowId));\n+    }\n+  }\n+\n+  private class DoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final Float8Vector vector;\n+\n+    DoubleAccessor(Float8Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryDoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryDoubleAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return dictionary.decodeToDouble(vector.get(rowId));\n+    }\n+  }\n+\n+  private class DecimalAccessor extends ArrowVectorAccessor {\n+\n+    private final IcebergArrowVectors.DecimalArrowVector vector;\n+\n+    DecimalAccessor(IcebergArrowVectors.DecimalArrowVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final Decimal getDecimal(int rowId, int precision, int scale) {\n+      if (isNullAt(rowId)) {\n+        return null;\n+      }\n+      return Decimal.apply(vector.getObject(rowId), precision, scale);\n+    }\n+  }\n+\n+  private class StringAccessor extends ArrowVectorAccessor {\n+\n+    private final IcebergArrowVectors.VarcharArrowVector vector;\n+    private final NullableVarCharHolder stringResult = new NullableVarCharHolder();\n+\n+    StringAccessor(IcebergArrowVectors.VarcharArrowVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final UTF8String getUTF8String(int rowId) {\n+      vector.get(rowId, stringResult);\n+      if (stringResult.isSet == 0) {\n+        return null;\n+      } else {\n+        return UTF8String.fromAddress(\n+            null,\n+            stringResult.buffer.memoryAddress() + stringResult.start,\n+            stringResult.end - stringResult.start);\n+      }\n+    }\n+  }\n+\n+  private class DictionaryStringAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryStringAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final UTF8String getUTF8String(int rowId) {\n+      if (isNullAt(rowId)) {\n+        return null;\n+      }\n+      Binary binary = dictionary.decodeToBinary(vector.get(rowId));\n+      return UTF8String.fromBytes(binary.getBytesUnsafe());\n+    }\n+  }\n+\n+  private class FixedSizeBinaryAccessor extends ArrowVectorAccessor {\n+\n+    private final FixedSizeBinaryVector vector;\n+\n+    FixedSizeBinaryAccessor(FixedSizeBinaryVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte[] getBinary(int rowId) {\n+      return vector.getObject(rowId);\n+    }\n+  }\n+\n+  private class BinaryAccessor extends ArrowVectorAccessor {\n+\n+    private final VarBinaryVector vector;\n+\n+    BinaryAccessor(VarBinaryVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte[] getBinary(int rowId) {\n+      return vector.getObject(rowId);\n+    }\n+  }\n+\n+  private class DictionaryBinaryAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryBinaryAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte[] getBinary(int rowId) {\n+      Binary binary = dictionary.decodeToBinary(vector.get(rowId));\n+      return binary.getBytesUnsafe();\n+    }\n+  }\n+\n+  private class DateAccessor extends ArrowVectorAccessor {", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY3MDQ3OA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r390670478", "bodyText": "Filed #834 to follow up on this.", "author": "samarthjain", "createdAt": "2020-03-10T23:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3ODEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4MDA2MA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389180060", "body": "Does `NullableVarCharHolder` make a copy?", "bodyText": "Does NullableVarCharHolder make a copy?", "bodyHTML": "<p dir=\"auto\">Does <code>NullableVarCharHolder</code> make a copy?</p>", "author": "rdblue", "createdAt": "2020-03-06T22:44:54Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.arrow.ArrowUtils;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.DecimalMetadata;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+  private final Dictionary dictionary;\n+  private final boolean isVectorDictEncoded;\n+  private ArrowColumnVector[] childColumns;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(ArrowUtils.instance().fromArrowField(holder.vector().getField()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.dictionary = holder.dictionary();\n+    this.isVectorDictEncoded = holder.isDictionaryEncoded();\n+    this.accessor = getVectorAccessor(holder.descriptor(), holder.vector());\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+        childColumns[i] = null;\n+      }\n+      childColumns = null;\n+    }\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  @Override\n+  public ArrowColumnVector getChild(int ordinal) {\n+    return childColumns[ordinal];\n+  }\n+\n+  private abstract class ArrowVectorAccessor {\n+\n+    private final ValueVector vector;\n+\n+    ArrowVectorAccessor(ValueVector vector) {\n+      this.vector = vector;\n+    }\n+\n+    final boolean isNullAt(int rowId) {\n+      return nullabilityHolder.isNullAt(rowId) == 1;\n+    }\n+\n+    final void close() {\n+      vector.close();\n+    }\n+\n+    boolean getBoolean(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte getByte(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    short getShort(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    int getInt(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    long getLong(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    float getFloat(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    double getDouble(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    Decimal getDecimal(int rowId, int precision, int scale) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    UTF8String getUTF8String(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte[] getBinary(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    ColumnarArray getArray(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+  private ArrowVectorAccessor getVectorAccessor(ColumnDescriptor desc, ValueVector vector) {\n+    PrimitiveType primitive = desc.getPrimitiveType();\n+    if (isVectorDictEncoded) {\n+      Preconditions.checkState(vector instanceof IntVector, \"Dictionary ids should be stored in IntVectors only\");\n+      if (primitive.getOriginalType() != null) {\n+        switch (desc.getPrimitiveType().getOriginalType()) {\n+          case ENUM:\n+          case JSON:\n+          case UTF8:\n+          case BSON:\n+            return new DictionaryStringAccessor((IntVector) vector);\n+          case INT_8:\n+          case INT_16:\n+          case INT_32:\n+          case DATE:\n+            return new DictionaryIntAccessor((IntVector) vector);\n+          case INT_64:\n+          case TIMESTAMP_MILLIS:\n+          case TIMESTAMP_MICROS:\n+            return new DictionaryLongAccessor((IntVector) vector);\n+          case DECIMAL:\n+            DecimalMetadata decimal = primitive.getDecimalMetadata();\n+            switch (primitive.getPrimitiveTypeName()) {\n+              case BINARY:\n+              case FIXED_LEN_BYTE_ARRAY:\n+                return new DictionaryDecimalBinaryAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              case INT64:\n+                return new DictionaryDecimalLongAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              case INT32:\n+                return new DictionaryDecimalIntAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              default:\n+                throw new UnsupportedOperationException(\n+                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n+            }\n+          default:\n+            throw new UnsupportedOperationException(\n+                \"Unsupported logical type: \" + primitive.getOriginalType());\n+        }\n+      } else {\n+        switch (primitive.getPrimitiveTypeName()) {\n+          case FIXED_LEN_BYTE_ARRAY:\n+          case BINARY:\n+            return new DictionaryBinaryAccessor((IntVector) vector);\n+          case INT32:\n+            return new DictionaryIntAccessor((IntVector) vector);\n+          case FLOAT:\n+            return new DictionaryFloatAccessor((IntVector) vector);\n+          case INT64:\n+            return new DictionaryLongAccessor((IntVector) vector);\n+          case DOUBLE:\n+            return new DictionaryDoubleAccessor((IntVector) vector);\n+          default:\n+            throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n+        }\n+      }\n+    } else {\n+      if (vector instanceof BitVector) {\n+        return new BooleanAccessor((BitVector) vector);\n+      } else if (vector instanceof TinyIntVector) {\n+        return new ByteAccessor((TinyIntVector) vector);\n+      } else if (vector instanceof SmallIntVector) {\n+        return new ShortAccessor((SmallIntVector) vector);\n+      } else if (vector instanceof IntVector) {\n+        return new IntAccessor((IntVector) vector);\n+      } else if (vector instanceof BigIntVector) {\n+        return new LongAccessor((BigIntVector) vector);\n+      } else if (vector instanceof Float4Vector) {\n+        return new FloatAccessor((Float4Vector) vector);\n+      } else if (vector instanceof Float8Vector) {\n+        return new DoubleAccessor((Float8Vector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.DecimalArrowVector) {\n+        return new DecimalAccessor((IcebergArrowVectors.DecimalArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarcharArrowVector) {\n+        return new StringAccessor((IcebergArrowVectors.VarcharArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarBinaryArrowVector) {\n+        return new BinaryAccessor((IcebergArrowVectors.VarBinaryArrowVector) vector);\n+      } else if (vector instanceof DateDayVector) {\n+        return new DateAccessor((DateDayVector) vector);\n+      } else if (vector instanceof TimeStampMicroTZVector) {\n+        return new TimestampAccessor((TimeStampMicroTZVector) vector);\n+      } else if (vector instanceof ListVector) {\n+        ListVector listVector = (ListVector) vector;\n+        return new ArrayAccessor(listVector);\n+      } else if (vector instanceof StructVector) {\n+        StructVector structVector = (StructVector) vector;\n+        ArrowVectorAccessor structAccessor = new StructAccessor(structVector);\n+        childColumns = new ArrowColumnVector[structVector.size()];\n+        for (int i = 0; i < childColumns.length; ++i) {\n+          childColumns[i] = new ArrowColumnVector(structVector.getVectorById(i));\n+        }\n+        return structAccessor;\n+      }\n+    }\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  private class BooleanAccessor extends ArrowVectorAccessor {\n+\n+    private final BitVector vector;\n+\n+    BooleanAccessor(BitVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final boolean getBoolean(int rowId) {\n+      return vector.get(rowId) == 1;\n+    }\n+  }\n+\n+  private class ByteAccessor extends ArrowVectorAccessor {\n+\n+    private final TinyIntVector vector;\n+\n+    ByteAccessor(TinyIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte getByte(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class ShortAccessor extends ArrowVectorAccessor {\n+\n+    private final SmallIntVector vector;\n+\n+    ShortAccessor(SmallIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final short getShort(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class IntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    IntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryIntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryIntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return dictionary.decodeToInt(vector.get(rowId));\n+    }\n+  }\n+\n+  private class LongAccessor extends ArrowVectorAccessor {\n+\n+    private final BigIntVector vector;\n+\n+    LongAccessor(BigIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryLongAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryLongAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return dictionary.decodeToLong(vector.get(rowId));\n+    }\n+  }\n+\n+  private class FloatAccessor extends ArrowVectorAccessor {\n+\n+    private final Float4Vector vector;\n+\n+    FloatAccessor(Float4Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryFloatAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryFloatAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return dictionary.decodeToFloat(vector.get(rowId));\n+    }\n+  }\n+\n+  private class DoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final Float8Vector vector;\n+\n+    DoubleAccessor(Float8Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryDoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryDoubleAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return dictionary.decodeToDouble(vector.get(rowId));\n+    }\n+  }\n+\n+  private class DecimalAccessor extends ArrowVectorAccessor {\n+\n+    private final IcebergArrowVectors.DecimalArrowVector vector;\n+\n+    DecimalAccessor(IcebergArrowVectors.DecimalArrowVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final Decimal getDecimal(int rowId, int precision, int scale) {\n+      if (isNullAt(rowId)) {\n+        return null;\n+      }\n+      return Decimal.apply(vector.getObject(rowId), precision, scale);\n+    }\n+  }\n+\n+  private class StringAccessor extends ArrowVectorAccessor {\n+\n+    private final IcebergArrowVectors.VarcharArrowVector vector;\n+    private final NullableVarCharHolder stringResult = new NullableVarCharHolder();\n+\n+    StringAccessor(IcebergArrowVectors.VarcharArrowVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final UTF8String getUTF8String(int rowId) {\n+      vector.get(rowId, stringResult);", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY3MTk5NA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r390671994", "bodyText": "No, it uses the underlying buffer and sets the start and end positions to get the variable width data out of it.\nhttps://github.com/apache/arrow/blob/maint-0.14.x/java/vector/src/main/java/org/apache/arrow/vector/VarCharVector.java#L134", "author": "samarthjain", "createdAt": "2020-03-10T23:38:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4MDA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4MTM0NA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r389181344", "body": "This looks concerning to me. This variant of `UTF8String` uses Java's `Unsafe` to work with bytes underneath an object. By setting this to null, this is using an absolute address, which I assume should be off-heap. Does our allocator use off-heap memory?", "bodyText": "This looks concerning to me. This variant of UTF8String uses Java's Unsafe to work with bytes underneath an object. By setting this to null, this is using an absolute address, which I assume should be off-heap. Does our allocator use off-heap memory?", "bodyHTML": "<p dir=\"auto\">This looks concerning to me. This variant of <code>UTF8String</code> uses Java's <code>Unsafe</code> to work with bytes underneath an object. By setting this to null, this is using an absolute address, which I assume should be off-heap. Does our allocator use off-heap memory?</p>", "author": "rdblue", "createdAt": "2020-03-06T22:48:47Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,753 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.arrow.ArrowUtils;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.DecimalMetadata;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+  private final Dictionary dictionary;\n+  private final boolean isVectorDictEncoded;\n+  private ArrowColumnVector[] childColumns;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(ArrowUtils.instance().fromArrowField(holder.vector().getField()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.dictionary = holder.dictionary();\n+    this.isVectorDictEncoded = holder.isDictionaryEncoded();\n+    this.accessor = getVectorAccessor(holder.descriptor(), holder.vector());\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+        childColumns[i] = null;\n+      }\n+      childColumns = null;\n+    }\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  @Override\n+  public ArrowColumnVector getChild(int ordinal) {\n+    return childColumns[ordinal];\n+  }\n+\n+  private abstract class ArrowVectorAccessor {\n+\n+    private final ValueVector vector;\n+\n+    ArrowVectorAccessor(ValueVector vector) {\n+      this.vector = vector;\n+    }\n+\n+    final boolean isNullAt(int rowId) {\n+      return nullabilityHolder.isNullAt(rowId) == 1;\n+    }\n+\n+    final void close() {\n+      vector.close();\n+    }\n+\n+    boolean getBoolean(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte getByte(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    short getShort(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    int getInt(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    long getLong(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    float getFloat(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    double getDouble(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    Decimal getDecimal(int rowId, int precision, int scale) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    UTF8String getUTF8String(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte[] getBinary(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    ColumnarArray getArray(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+  private ArrowVectorAccessor getVectorAccessor(ColumnDescriptor desc, ValueVector vector) {\n+    PrimitiveType primitive = desc.getPrimitiveType();\n+    if (isVectorDictEncoded) {\n+      Preconditions.checkState(vector instanceof IntVector, \"Dictionary ids should be stored in IntVectors only\");\n+      if (primitive.getOriginalType() != null) {\n+        switch (desc.getPrimitiveType().getOriginalType()) {\n+          case ENUM:\n+          case JSON:\n+          case UTF8:\n+          case BSON:\n+            return new DictionaryStringAccessor((IntVector) vector);\n+          case INT_8:\n+          case INT_16:\n+          case INT_32:\n+          case DATE:\n+            return new DictionaryIntAccessor((IntVector) vector);\n+          case INT_64:\n+          case TIMESTAMP_MILLIS:\n+          case TIMESTAMP_MICROS:\n+            return new DictionaryLongAccessor((IntVector) vector);\n+          case DECIMAL:\n+            DecimalMetadata decimal = primitive.getDecimalMetadata();\n+            switch (primitive.getPrimitiveTypeName()) {\n+              case BINARY:\n+              case FIXED_LEN_BYTE_ARRAY:\n+                return new DictionaryDecimalBinaryAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              case INT64:\n+                return new DictionaryDecimalLongAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              case INT32:\n+                return new DictionaryDecimalIntAccessor(\n+                    (IntVector) vector,\n+                    decimal.getPrecision(),\n+                    decimal.getScale());\n+              default:\n+                throw new UnsupportedOperationException(\n+                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n+            }\n+          default:\n+            throw new UnsupportedOperationException(\n+                \"Unsupported logical type: \" + primitive.getOriginalType());\n+        }\n+      } else {\n+        switch (primitive.getPrimitiveTypeName()) {\n+          case FIXED_LEN_BYTE_ARRAY:\n+          case BINARY:\n+            return new DictionaryBinaryAccessor((IntVector) vector);\n+          case INT32:\n+            return new DictionaryIntAccessor((IntVector) vector);\n+          case FLOAT:\n+            return new DictionaryFloatAccessor((IntVector) vector);\n+          case INT64:\n+            return new DictionaryLongAccessor((IntVector) vector);\n+          case DOUBLE:\n+            return new DictionaryDoubleAccessor((IntVector) vector);\n+          default:\n+            throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n+        }\n+      }\n+    } else {\n+      if (vector instanceof BitVector) {\n+        return new BooleanAccessor((BitVector) vector);\n+      } else if (vector instanceof TinyIntVector) {\n+        return new ByteAccessor((TinyIntVector) vector);\n+      } else if (vector instanceof SmallIntVector) {\n+        return new ShortAccessor((SmallIntVector) vector);\n+      } else if (vector instanceof IntVector) {\n+        return new IntAccessor((IntVector) vector);\n+      } else if (vector instanceof BigIntVector) {\n+        return new LongAccessor((BigIntVector) vector);\n+      } else if (vector instanceof Float4Vector) {\n+        return new FloatAccessor((Float4Vector) vector);\n+      } else if (vector instanceof Float8Vector) {\n+        return new DoubleAccessor((Float8Vector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.DecimalArrowVector) {\n+        return new DecimalAccessor((IcebergArrowVectors.DecimalArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarcharArrowVector) {\n+        return new StringAccessor((IcebergArrowVectors.VarcharArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarBinaryArrowVector) {\n+        return new BinaryAccessor((IcebergArrowVectors.VarBinaryArrowVector) vector);\n+      } else if (vector instanceof DateDayVector) {\n+        return new DateAccessor((DateDayVector) vector);\n+      } else if (vector instanceof TimeStampMicroTZVector) {\n+        return new TimestampAccessor((TimeStampMicroTZVector) vector);\n+      } else if (vector instanceof ListVector) {\n+        ListVector listVector = (ListVector) vector;\n+        return new ArrayAccessor(listVector);\n+      } else if (vector instanceof StructVector) {\n+        StructVector structVector = (StructVector) vector;\n+        ArrowVectorAccessor structAccessor = new StructAccessor(structVector);\n+        childColumns = new ArrowColumnVector[structVector.size()];\n+        for (int i = 0; i < childColumns.length; ++i) {\n+          childColumns[i] = new ArrowColumnVector(structVector.getVectorById(i));\n+        }\n+        return structAccessor;\n+      }\n+    }\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  private class BooleanAccessor extends ArrowVectorAccessor {\n+\n+    private final BitVector vector;\n+\n+    BooleanAccessor(BitVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final boolean getBoolean(int rowId) {\n+      return vector.get(rowId) == 1;\n+    }\n+  }\n+\n+  private class ByteAccessor extends ArrowVectorAccessor {\n+\n+    private final TinyIntVector vector;\n+\n+    ByteAccessor(TinyIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte getByte(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class ShortAccessor extends ArrowVectorAccessor {\n+\n+    private final SmallIntVector vector;\n+\n+    ShortAccessor(SmallIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final short getShort(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class IntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    IntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryIntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryIntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return dictionary.decodeToInt(vector.get(rowId));\n+    }\n+  }\n+\n+  private class LongAccessor extends ArrowVectorAccessor {\n+\n+    private final BigIntVector vector;\n+\n+    LongAccessor(BigIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryLongAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryLongAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return dictionary.decodeToLong(vector.get(rowId));\n+    }\n+  }\n+\n+  private class FloatAccessor extends ArrowVectorAccessor {\n+\n+    private final Float4Vector vector;\n+\n+    FloatAccessor(Float4Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryFloatAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryFloatAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return dictionary.decodeToFloat(vector.get(rowId));\n+    }\n+  }\n+\n+  private class DoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final Float8Vector vector;\n+\n+    DoubleAccessor(Float8Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private class DictionaryDoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryDoubleAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return dictionary.decodeToDouble(vector.get(rowId));\n+    }\n+  }\n+\n+  private class DecimalAccessor extends ArrowVectorAccessor {\n+\n+    private final IcebergArrowVectors.DecimalArrowVector vector;\n+\n+    DecimalAccessor(IcebergArrowVectors.DecimalArrowVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final Decimal getDecimal(int rowId, int precision, int scale) {\n+      if (isNullAt(rowId)) {\n+        return null;\n+      }\n+      return Decimal.apply(vector.getObject(rowId), precision, scale);\n+    }\n+  }\n+\n+  private class StringAccessor extends ArrowVectorAccessor {\n+\n+    private final IcebergArrowVectors.VarcharArrowVector vector;\n+    private final NullableVarCharHolder stringResult = new NullableVarCharHolder();\n+\n+    StringAccessor(IcebergArrowVectors.VarcharArrowVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final UTF8String getUTF8String(int rowId) {\n+      vector.get(rowId, stringResult);\n+      if (stringResult.isSet == 0) {\n+        return null;\n+      } else {\n+        return UTF8String.fromAddress(\n+            null,\n+            stringResult.buffer.memoryAddress() + stringResult.start,\n+            stringResult.end - stringResult.start);", "originalCommit": "07dd61a5ff849116b8f7234cad9a90fc5fbc2743", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "714c943b3812c8c65309e8161e2801cecafb4dbb", "url": "https://github.com/apache/iceberg/commit/714c943b3812c8c65309e8161e2801cecafb4dbb", "message": "Merge reader changes from master. Rebase branch to master", "committedDate": "2020-03-23T19:21:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNzU5Nw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410507597", "body": "Nit: indentation is off.", "bodyText": "Nit: indentation is off.", "bodyHTML": "<p dir=\"auto\">Nit: indentation is off.</p>", "author": "rdblue", "createdAt": "2020-04-17T23:01:34Z", "path": "arrow/src/main/java/org/apache/iceberg/arrow/vectorized/parquet/VectorizedDictionaryEncodedParquetValuesReader.java", "diffHunk": "@@ -111,7 +111,8 @@ void readBatchOfDictionaryEncodedLongs(FieldVector vector, int startOffset, int\n   }\n \n   void readBatchOfDictionaryEncodedTimestampMillis(FieldVector vector, int startOffset, int numValuesToRead,\n-                                                   Dictionary dict, NullabilityHolder nullabilityHolder) {\n+                                                   Dictionary dict, NullabilityHolder nullabilityHolder,\n+      int typeWidth) {", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMDAxNw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410510017", "body": "Does this make Spark start faster? Should we use it in other tests?", "bodyText": "Does this make Spark start faster? Should we use it in other tests?", "bodyHTML": "<p dir=\"auto\">Does this make Spark start faster? Should we use it in other tests?</p>", "author": "rdblue", "createdAt": "2020-04-17T23:12:16Z", "path": "spark/src/jmh/java/org/apache/iceberg/spark/source/IcebergSourceBenchmark.java", "diffHunk": "@@ -92,15 +93,24 @@ protected void cleanupFiles() throws IOException {\n     }\n   }\n \n-  protected void setupSpark() {\n-    spark = SparkSession.builder()\n-        .config(\"spark.ui.enabled\", false)\n-        .master(\"local\")\n-        .getOrCreate();\n+  protected void setupSpark(boolean enableDictionaryEncoding) {\n+    SparkSession.Builder builder = SparkSession.builder()\n+            .config(\"spark.ui.enabled\", false);", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0MTExNg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r420641116", "bodyText": "I am actually not sure. But it does look like a lot of tests within Spark turn off the UI.\nFor ex- https://github.com/apache/spark/blob/a222644e1df907d0aba19634a166e146dfb4f551/core/src/test/scala/org/apache/spark/deploy/SparkSubmitSuite.scala#L268", "author": "samarthjain", "createdAt": "2020-05-06T08:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMDAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMDQyMg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410510422", "body": "What about the call in `case PACKED` just below? Does that also need to use the `typeWidth`?", "bodyText": "What about the call in case PACKED just below? Does that also need to use the typeWidth?", "bodyHTML": "<p dir=\"auto\">What about the call in <code>case PACKED</code> just below? Does that also need to use the <code>typeWidth</code>?</p>", "author": "rdblue", "createdAt": "2020-04-17T23:13:57Z", "path": "arrow/src/main/java/org/apache/iceberg/arrow/vectorized/parquet/VectorizedParquetDefinitionLevelReader.java", "diffHunk": "@@ -193,7 +193,7 @@ public void readBatchOfDictionaryEncodedLongs(\n         case RLE:\n           if (currentValue == maxDefLevel) {\n             dictionaryEncodedValuesReader.readBatchOfDictionaryEncodedLongs(vector,\n-                idx, numValues, dict, nullabilityHolder);\n+                idx, numValues, dict, nullabilityHolder, typeWidth);", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY3ODY4OQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r417678689", "bodyText": "Good catch, looks like I missed it. Will fix here and other places.", "author": "samarthjain", "createdAt": "2020-04-29T23:54:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMDQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMDkzOA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410510938", "body": "These changes look concerning. It looks like the old offset (only index) must not have been correct. If so, there are places where `getDataBuffer().setLong(...)` and similar methods are called but aren't updated like these. Are those cases bugs as well?", "bodyText": "These changes look concerning. It looks like the old offset (only index) must not have been correct. If so, there are places where getDataBuffer().setLong(...) and similar methods are called but aren't updated like these. Are those cases bugs as well?", "bodyHTML": "<p dir=\"auto\">These changes look concerning. It looks like the old offset (only index) must not have been correct. If so, there are places where <code>getDataBuffer().setLong(...)</code> and similar methods are called but aren't updated like these. Are those cases bugs as well?</p>", "author": "rdblue", "createdAt": "2020-04-17T23:16:33Z", "path": "arrow/src/main/java/org/apache/iceberg/arrow/vectorized/parquet/VectorizedDictionaryEncodedParquetValuesReader.java", "diffHunk": "@@ -72,7 +72,7 @@ void readBatchOfDictionaryIds(IntVector intVector, int startOffset, int numValue\n   }\n \n   void readBatchOfDictionaryEncodedLongs(FieldVector vector, int startOffset, int numValuesToRead, Dictionary dict,\n-                                         NullabilityHolder nullabilityHolder) {\n+                                         NullabilityHolder nullabilityHolder, int typeWidth) {", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY3ODg3Mw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r417678873", "bodyText": "Good catch, looks like I missed it. Will fix here and other places.", "author": "samarthjain", "createdAt": "2020-04-29T23:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMDkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzNzU5Nw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r420637597", "bodyText": "Looks like the test TestSparkParquetFallbackToDictionaryEncodingForVectorizedReader wasn't adequately testing the fallback to plain encoding behavior for all the datatypes. Will tweak it.", "author": "samarthjain", "createdAt": "2020-05-06T08:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMDkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMTA1NQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410511055", "body": "Why is this in the Spark package? Is it specific to Spark?", "bodyText": "Why is this in the Spark package? Is it specific to Spark?", "bodyHTML": "<p dir=\"auto\">Why is this in the Spark package? Is it specific to Spark?</p>", "author": "rdblue", "createdAt": "2020-04-17T23:17:11Z", "path": "spark/src/main/java/org/apache/iceberg/spark/arrow/ArrowAllocation.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.arrow;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+\n+public class ArrowAllocation {", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY3OTQxNg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r417679416", "bodyText": "This can be moved to iceberg-arrow.", "author": "samarthjain", "createdAt": "2020-04-29T23:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMTA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMTUyMA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410511520", "body": "It looks like this could easily be refactored into separate methods: `getDictionaryVectorAccessor(VectorHolder)` and `getPlainVectorAccessor(VectorHolder)`.", "bodyText": "It looks like this could easily be refactored into separate methods: getDictionaryVectorAccessor(VectorHolder) and getPlainVectorAccessor(VectorHolder).", "bodyHTML": "<p dir=\"auto\">It looks like this could easily be refactored into separate methods: <code>getDictionaryVectorAccessor(VectorHolder)</code> and <code>getPlainVectorAccessor(VectorHolder)</code>.</p>", "author": "rdblue", "createdAt": "2020-04-17T23:19:11Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ArrowVectorAccessors.java", "diffHunk": "@@ -0,0 +1,495 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+public class ArrowVectorAccessors {\n+\n+  private ArrowVectorAccessors() {}\n+\n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+  static ArrowVectorAccessor getVectorAccessor(VectorHolder holder) {\n+    Dictionary dictionary = holder.dictionary();\n+    boolean isVectorDictEncoded = holder.isDictionaryEncoded();\n+    ColumnDescriptor desc = holder.descriptor();\n+    FieldVector vector = holder.vector();\n+    PrimitiveType primitive = desc.getPrimitiveType();\n+    if (isVectorDictEncoded) {", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNDU2Ng==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410514566", "bodyText": "This would probably address the complexity problem above without suppressing it.", "author": "rdblue", "createdAt": "2020-04-17T23:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMTUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNzIyMA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410517220", "body": "I think that the dictionary should be eagerly decoded, for a few reasons:\r\n1. `getBytesUnsafe` will make a copy of the bytes when the binary is backed by a `ByteBuffer` or an array slice. It may also cache values and perform checks.\r\n2. `getBytesUnsafe` should only be used when the bytes are immediately consumed, but `UTF8String` keeps a reference, so even if there isn't a copy this could result in a correctness problem\r\n3. `decodeToBinary` should incur a dynamic dispatch cost (this also applies to the other dictionary readers)\r\n\r\nIt's fairly easy to eagerly decode:\r\n```java\r\n  private static class DictionaryStringAccessor extends ArrowVectorAccessor {\r\n    private IntVector offsetVector;\r\n    private UTF8String[] decodedDictionary;\r\n\r\n    DictionaryStringAccessor(IntVector vector, Dictionary dictionary) {\r\n      super(vector);\r\n      this.offsetVector = vector;\r\n      this.decodedDictionary = IntStream.rangeClosed(0, dictionary.getMaxId())\r\n          .mapToObj(dictionary::decodeToBinary)\r\n          .map(binary -> UTF8String.fromBytes(binary.getBytes()))\r\n          .toArray(UTF8String[]::new);\r\n    }\r\n\r\n    @Override\r\n    final UTF8String getUTF8String(int rowId) {\r\n      int offset = offsetVector.get(rowId);\r\n      return decodedDictionary[offset];\r\n    }\r\n  }\r\n```\r\n\r\nAlso, there's no need for the `DictionaryArrowVectorAccessor`, since it only tracks one column that is also tracked by its parent.", "bodyText": "I think that the dictionary should be eagerly decoded, for a few reasons:\n\ngetBytesUnsafe will make a copy of the bytes when the binary is backed by a ByteBuffer or an array slice. It may also cache values and perform checks.\ngetBytesUnsafe should only be used when the bytes are immediately consumed, but UTF8String keeps a reference, so even if there isn't a copy this could result in a correctness problem\ndecodeToBinary should incur a dynamic dispatch cost (this also applies to the other dictionary readers)\n\nIt's fairly easy to eagerly decode:\n  private static class DictionaryStringAccessor extends ArrowVectorAccessor {\n    private IntVector offsetVector;\n    private UTF8String[] decodedDictionary;\n\n    DictionaryStringAccessor(IntVector vector, Dictionary dictionary) {\n      super(vector);\n      this.offsetVector = vector;\n      this.decodedDictionary = IntStream.rangeClosed(0, dictionary.getMaxId())\n          .mapToObj(dictionary::decodeToBinary)\n          .map(binary -> UTF8String.fromBytes(binary.getBytes()))\n          .toArray(UTF8String[]::new);\n    }\n\n    @Override\n    final UTF8String getUTF8String(int rowId) {\n      int offset = offsetVector.get(rowId);\n      return decodedDictionary[offset];\n    }\n  }\nAlso, there's no need for the DictionaryArrowVectorAccessor, since it only tracks one column that is also tracked by its parent.", "bodyHTML": "<p dir=\"auto\">I think that the dictionary should be eagerly decoded, for a few reasons:</p>\n<ol dir=\"auto\">\n<li><code>getBytesUnsafe</code> will make a copy of the bytes when the binary is backed by a <code>ByteBuffer</code> or an array slice. It may also cache values and perform checks.</li>\n<li><code>getBytesUnsafe</code> should only be used when the bytes are immediately consumed, but <code>UTF8String</code> keeps a reference, so even if there isn't a copy this could result in a correctness problem</li>\n<li><code>decodeToBinary</code> should incur a dynamic dispatch cost (this also applies to the other dictionary readers)</li>\n</ol>\n<p dir=\"auto\">It's fairly easy to eagerly decode:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"  private static class DictionaryStringAccessor extends ArrowVectorAccessor {\n    private IntVector offsetVector;\n    private UTF8String[] decodedDictionary;\n\n    DictionaryStringAccessor(IntVector vector, Dictionary dictionary) {\n      super(vector);\n      this.offsetVector = vector;\n      this.decodedDictionary = IntStream.rangeClosed(0, dictionary.getMaxId())\n          .mapToObj(dictionary::decodeToBinary)\n          .map(binary -&gt; UTF8String.fromBytes(binary.getBytes()))\n          .toArray(UTF8String[]::new);\n    }\n\n    @Override\n    final UTF8String getUTF8String(int rowId) {\n      int offset = offsetVector.get(rowId);\n      return decodedDictionary[offset];\n    }\n  }\n\"><pre>  <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">DictionaryStringAccessor</span> <span class=\"pl-k\">extends</span> <span class=\"pl-e\">ArrowVectorAccessor</span> {\n    <span class=\"pl-k\">private</span> <span class=\"pl-smi\">IntVector</span> offsetVector;\n    <span class=\"pl-k\">private</span> <span class=\"pl-k\">UTF8String</span>[] decodedDictionary;\n\n    <span class=\"pl-en\">DictionaryStringAccessor</span>(<span class=\"pl-smi\">IntVector</span> <span class=\"pl-v\">vector</span>, <span class=\"pl-smi\">Dictionary</span> <span class=\"pl-v\">dictionary</span>) {\n      <span class=\"pl-c1\">super</span>(vector);\n      <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>offsetVector <span class=\"pl-k\">=</span> vector;\n      <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>decodedDictionary <span class=\"pl-k\">=</span> <span class=\"pl-smi\">IntStream</span><span class=\"pl-k\">.</span>rangeClosed(<span class=\"pl-c1\">0</span>, dictionary<span class=\"pl-k\">.</span>getMaxId())\n          .mapToObj(dictionary<span class=\"pl-k\">::</span>decodeToBinary)\n          .map(binary <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-smi\">UTF8String</span><span class=\"pl-k\">.</span>fromBytes(binary<span class=\"pl-k\">.</span>getBytes()))\n          .toArray(<span class=\"pl-k\">UTF8String</span>[]<span class=\"pl-k\">::</span><span class=\"pl-k\">new</span>);\n    }\n\n    <span class=\"pl-k\">@Override</span>\n    <span class=\"pl-k\">final</span> <span class=\"pl-smi\">UTF8String</span> getUTF8String(<span class=\"pl-k\">int</span> rowId) {\n      <span class=\"pl-k\">int</span> offset <span class=\"pl-k\">=</span> offsetVector<span class=\"pl-k\">.</span>get(rowId);\n      <span class=\"pl-k\">return</span> decodedDictionary[offset];\n    }\n  }</pre></div>\n<p dir=\"auto\">Also, there's no need for the <code>DictionaryArrowVectorAccessor</code>, since it only tracks one column that is also tracked by its parent.</p>", "author": "rdblue", "createdAt": "2020-04-17T23:46:13Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ArrowVectorAccessors.java", "diffHunk": "@@ -0,0 +1,495 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+public class ArrowVectorAccessors {\n+\n+  private ArrowVectorAccessors() {}\n+\n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+  static ArrowVectorAccessor getVectorAccessor(VectorHolder holder) {\n+    Dictionary dictionary = holder.dictionary();\n+    boolean isVectorDictEncoded = holder.isDictionaryEncoded();\n+    ColumnDescriptor desc = holder.descriptor();\n+    FieldVector vector = holder.vector();\n+    PrimitiveType primitive = desc.getPrimitiveType();\n+    if (isVectorDictEncoded) {\n+      Preconditions.checkState(vector instanceof IntVector, \"Dictionary ids should be stored in IntVectors only\");\n+      if (primitive.getOriginalType() != null) {\n+        switch (desc.getPrimitiveType().getOriginalType()) {\n+          case ENUM:\n+          case JSON:\n+          case UTF8:\n+          case BSON:\n+            return new DictionaryStringAccessor((IntVector) vector, dictionary);\n+          case INT_64:\n+          case TIMESTAMP_MILLIS:\n+          case TIMESTAMP_MICROS:\n+            return new DictionaryLongAccessor((IntVector) vector, dictionary);\n+          case DECIMAL:\n+            switch (primitive.getPrimitiveTypeName()) {\n+              case BINARY:\n+              case FIXED_LEN_BYTE_ARRAY:\n+                return new DictionaryDecimalBinaryAccessor(\n+                    (IntVector) vector,\n+                    dictionary);\n+              case INT64:\n+                return new DictionaryDecimalLongAccessor(\n+                    (IntVector) vector,\n+                    dictionary);\n+              case INT32:\n+                return new DictionaryDecimalIntAccessor(\n+                    (IntVector) vector,\n+                    dictionary);\n+              default:\n+                throw new UnsupportedOperationException(\n+                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n+            }\n+          default:\n+            throw new UnsupportedOperationException(\n+                \"Unsupported logical type: \" + primitive.getOriginalType());\n+        }\n+      } else {\n+        switch (primitive.getPrimitiveTypeName()) {\n+          case FIXED_LEN_BYTE_ARRAY:\n+          case BINARY:\n+            return new DictionaryBinaryAccessor((IntVector) vector, dictionary);\n+          case FLOAT:\n+            return new DictionaryFloatAccessor((IntVector) vector, dictionary);\n+          case INT64:\n+            return new DictionaryLongAccessor((IntVector) vector, dictionary);\n+          case DOUBLE:\n+            return new DictionaryDoubleAccessor((IntVector) vector, dictionary);\n+          default:\n+            throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n+        }\n+      }\n+    } else {\n+      if (vector instanceof BitVector) {\n+        return new BooleanAccessor((BitVector) vector);\n+      } else if (vector instanceof IntVector) {\n+        return new IntAccessor((IntVector) vector);\n+      } else if (vector instanceof BigIntVector) {\n+        return new LongAccessor((BigIntVector) vector);\n+      } else if (vector instanceof Float4Vector) {\n+        return new FloatAccessor((Float4Vector) vector);\n+      } else if (vector instanceof Float8Vector) {\n+        return new DoubleAccessor((Float8Vector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.DecimalArrowVector) {\n+        return new DecimalAccessor((IcebergArrowVectors.DecimalArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarcharArrowVector) {\n+        return new StringAccessor((IcebergArrowVectors.VarcharArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarBinaryArrowVector) {\n+        return new BinaryAccessor((IcebergArrowVectors.VarBinaryArrowVector) vector);\n+      } else if (vector instanceof DateDayVector) {\n+        return new DateAccessor((DateDayVector) vector);\n+      } else if (vector instanceof TimeStampMicroTZVector) {\n+        return new TimestampAccessor((TimeStampMicroTZVector) vector);\n+      } else if (vector instanceof ListVector) {\n+        ListVector listVector = (ListVector) vector;\n+        return new ArrayAccessor(listVector);\n+      } else if (vector instanceof StructVector) {\n+        StructVector structVector = (StructVector) vector;\n+        return new StructAccessor(structVector);\n+      }\n+    }\n+    throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n+  }\n+\n+  private static class BooleanAccessor extends ArrowVectorAccessor {\n+\n+    private final BitVector vector;\n+\n+    BooleanAccessor(BitVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final boolean getBoolean(int rowId) {\n+      return vector.get(rowId) == 1;\n+    }\n+  }\n+\n+  private static class IntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    IntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class LongAccessor extends ArrowVectorAccessor {\n+\n+    private final BigIntVector vector;\n+\n+    LongAccessor(BigIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class DictionaryLongAccessor extends DictionaryArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryLongAccessor(IntVector vector, Dictionary dictionary) {\n+      super(vector, dictionary);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return parquetDictionary.decodeToLong(vector.get(rowId));\n+    }\n+  }\n+\n+  private static class FloatAccessor extends ArrowVectorAccessor {\n+\n+    private final Float4Vector vector;\n+\n+    FloatAccessor(Float4Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class DictionaryFloatAccessor extends DictionaryArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryFloatAccessor(IntVector vector, Dictionary dictionary) {\n+      super(vector, dictionary);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return parquetDictionary.decodeToFloat(vector.get(rowId));\n+    }\n+  }\n+\n+  private static class DoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final Float8Vector vector;\n+\n+    DoubleAccessor(Float8Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class DictionaryDoubleAccessor extends DictionaryArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryDoubleAccessor(IntVector vector, Dictionary dictionary) {\n+      super(vector, dictionary);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return parquetDictionary.decodeToDouble(vector.get(rowId));\n+    }\n+  }\n+\n+  private static class DecimalAccessor extends ArrowVectorAccessor {\n+\n+    private final IcebergArrowVectors.DecimalArrowVector vector;\n+\n+    DecimalAccessor(IcebergArrowVectors.DecimalArrowVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final Decimal getDecimal(int rowId, int precision, int scale) {\n+      return Decimal.apply(vector.getObject(rowId), precision, scale);\n+    }\n+  }\n+\n+  private static class StringAccessor extends ArrowVectorAccessor {\n+\n+    private final IcebergArrowVectors.VarcharArrowVector vector;\n+    private final NullableVarCharHolder stringResult = new NullableVarCharHolder();\n+\n+    StringAccessor(IcebergArrowVectors.VarcharArrowVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final UTF8String getUTF8String(int rowId) {\n+      vector.get(rowId, stringResult);\n+      if (stringResult.isSet == 0) {\n+        return null;\n+      } else {\n+        return UTF8String.fromAddress(\n+            null,\n+            stringResult.buffer.memoryAddress() + stringResult.start,\n+            stringResult.end - stringResult.start);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:VisibilityModifier\")\n+  private abstract static class DictionaryArrowVectorAccessor extends ArrowVectorAccessor {\n+    final Dictionary parquetDictionary;\n+    final IntVector dictionaryVector;\n+\n+    private DictionaryArrowVectorAccessor(IntVector vector, Dictionary dictionary) {\n+      super(vector);\n+      this.dictionaryVector = vector;\n+      this.parquetDictionary = dictionary;\n+    }\n+  }\n+\n+  private static class DictionaryStringAccessor extends DictionaryArrowVectorAccessor {\n+\n+    DictionaryStringAccessor(IntVector vector, Dictionary dictionary) {\n+      super(vector, dictionary);", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxODI0OA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410518248", "body": "Similar to the string dictionary accessor, I think we can avoid extra work and make this simpler by eagerly decoding here:\r\n\r\n```java\r\n  private static class DictionaryDoubleAccessor extends ArrowVectorAccessor {\r\n    private final IntVector vector;\r\n    private final double[] decodedDictionary;\r\n\r\n    DictionaryDoubleAccessor(IntVector vector, Dictionary dictionary) {\r\n      super(vector);\r\n      this.vector = vector;\r\n      this.decodedDictionary = IntStream.rangeClosed(0, dictionary.getMaxId())\r\n          .mapToDouble(dictionary::decodeToDouble)\r\n          .toArray();\r\n    }\r\n\r\n    @Override\r\n    final double getDouble(int rowId) {\r\n      return decodedDictionary[vector.get(rowId)];\r\n    }\r\n  }\r\n```\r\n\r\nParquet decodes into a `double[]` as well, but this avoids dynamic dispatch costs for `decodeToDouble` and is easier to see what's happening.", "bodyText": "Similar to the string dictionary accessor, I think we can avoid extra work and make this simpler by eagerly decoding here:\n  private static class DictionaryDoubleAccessor extends ArrowVectorAccessor {\n    private final IntVector vector;\n    private final double[] decodedDictionary;\n\n    DictionaryDoubleAccessor(IntVector vector, Dictionary dictionary) {\n      super(vector);\n      this.vector = vector;\n      this.decodedDictionary = IntStream.rangeClosed(0, dictionary.getMaxId())\n          .mapToDouble(dictionary::decodeToDouble)\n          .toArray();\n    }\n\n    @Override\n    final double getDouble(int rowId) {\n      return decodedDictionary[vector.get(rowId)];\n    }\n  }\nParquet decodes into a double[] as well, but this avoids dynamic dispatch costs for decodeToDouble and is easier to see what's happening.", "bodyHTML": "<p dir=\"auto\">Similar to the string dictionary accessor, I think we can avoid extra work and make this simpler by eagerly decoding here:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"  private static class DictionaryDoubleAccessor extends ArrowVectorAccessor {\n    private final IntVector vector;\n    private final double[] decodedDictionary;\n\n    DictionaryDoubleAccessor(IntVector vector, Dictionary dictionary) {\n      super(vector);\n      this.vector = vector;\n      this.decodedDictionary = IntStream.rangeClosed(0, dictionary.getMaxId())\n          .mapToDouble(dictionary::decodeToDouble)\n          .toArray();\n    }\n\n    @Override\n    final double getDouble(int rowId) {\n      return decodedDictionary[vector.get(rowId)];\n    }\n  }\n\"><pre>  <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">DictionaryDoubleAccessor</span> <span class=\"pl-k\">extends</span> <span class=\"pl-e\">ArrowVectorAccessor</span> {\n    <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">IntVector</span> vector;\n    <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k\">double</span>[] decodedDictionary;\n\n    <span class=\"pl-en\">DictionaryDoubleAccessor</span>(<span class=\"pl-smi\">IntVector</span> <span class=\"pl-v\">vector</span>, <span class=\"pl-smi\">Dictionary</span> <span class=\"pl-v\">dictionary</span>) {\n      <span class=\"pl-c1\">super</span>(vector);\n      <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>vector <span class=\"pl-k\">=</span> vector;\n      <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>decodedDictionary <span class=\"pl-k\">=</span> <span class=\"pl-smi\">IntStream</span><span class=\"pl-k\">.</span>rangeClosed(<span class=\"pl-c1\">0</span>, dictionary<span class=\"pl-k\">.</span>getMaxId())\n          .mapToDouble(dictionary<span class=\"pl-k\">::</span>decodeToDouble)\n          .toArray();\n    }\n\n    <span class=\"pl-k\">@Override</span>\n    <span class=\"pl-k\">final</span> <span class=\"pl-k\">double</span> <span class=\"pl-en\">getDouble</span>(<span class=\"pl-k\">int</span> <span class=\"pl-v\">rowId</span>) {\n      <span class=\"pl-k\">return</span> decodedDictionary[vector<span class=\"pl-k\">.</span>get(rowId)];\n    }\n  }</pre></div>\n<p dir=\"auto\">Parquet decodes into a <code>double[]</code> as well, but this avoids dynamic dispatch costs for <code>decodeToDouble</code> and is easier to see what's happening.</p>", "author": "rdblue", "createdAt": "2020-04-17T23:52:23Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ArrowVectorAccessors.java", "diffHunk": "@@ -0,0 +1,495 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+public class ArrowVectorAccessors {\n+\n+  private ArrowVectorAccessors() {}\n+\n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+  static ArrowVectorAccessor getVectorAccessor(VectorHolder holder) {\n+    Dictionary dictionary = holder.dictionary();\n+    boolean isVectorDictEncoded = holder.isDictionaryEncoded();\n+    ColumnDescriptor desc = holder.descriptor();\n+    FieldVector vector = holder.vector();\n+    PrimitiveType primitive = desc.getPrimitiveType();\n+    if (isVectorDictEncoded) {\n+      Preconditions.checkState(vector instanceof IntVector, \"Dictionary ids should be stored in IntVectors only\");\n+      if (primitive.getOriginalType() != null) {\n+        switch (desc.getPrimitiveType().getOriginalType()) {\n+          case ENUM:\n+          case JSON:\n+          case UTF8:\n+          case BSON:\n+            return new DictionaryStringAccessor((IntVector) vector, dictionary);\n+          case INT_64:\n+          case TIMESTAMP_MILLIS:\n+          case TIMESTAMP_MICROS:\n+            return new DictionaryLongAccessor((IntVector) vector, dictionary);\n+          case DECIMAL:\n+            switch (primitive.getPrimitiveTypeName()) {\n+              case BINARY:\n+              case FIXED_LEN_BYTE_ARRAY:\n+                return new DictionaryDecimalBinaryAccessor(\n+                    (IntVector) vector,\n+                    dictionary);\n+              case INT64:\n+                return new DictionaryDecimalLongAccessor(\n+                    (IntVector) vector,\n+                    dictionary);\n+              case INT32:\n+                return new DictionaryDecimalIntAccessor(\n+                    (IntVector) vector,\n+                    dictionary);\n+              default:\n+                throw new UnsupportedOperationException(\n+                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n+            }\n+          default:\n+            throw new UnsupportedOperationException(\n+                \"Unsupported logical type: \" + primitive.getOriginalType());\n+        }\n+      } else {\n+        switch (primitive.getPrimitiveTypeName()) {\n+          case FIXED_LEN_BYTE_ARRAY:\n+          case BINARY:\n+            return new DictionaryBinaryAccessor((IntVector) vector, dictionary);\n+          case FLOAT:\n+            return new DictionaryFloatAccessor((IntVector) vector, dictionary);\n+          case INT64:\n+            return new DictionaryLongAccessor((IntVector) vector, dictionary);\n+          case DOUBLE:\n+            return new DictionaryDoubleAccessor((IntVector) vector, dictionary);\n+          default:\n+            throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n+        }\n+      }\n+    } else {\n+      if (vector instanceof BitVector) {\n+        return new BooleanAccessor((BitVector) vector);\n+      } else if (vector instanceof IntVector) {\n+        return new IntAccessor((IntVector) vector);\n+      } else if (vector instanceof BigIntVector) {\n+        return new LongAccessor((BigIntVector) vector);\n+      } else if (vector instanceof Float4Vector) {\n+        return new FloatAccessor((Float4Vector) vector);\n+      } else if (vector instanceof Float8Vector) {\n+        return new DoubleAccessor((Float8Vector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.DecimalArrowVector) {\n+        return new DecimalAccessor((IcebergArrowVectors.DecimalArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarcharArrowVector) {\n+        return new StringAccessor((IcebergArrowVectors.VarcharArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarBinaryArrowVector) {\n+        return new BinaryAccessor((IcebergArrowVectors.VarBinaryArrowVector) vector);\n+      } else if (vector instanceof DateDayVector) {\n+        return new DateAccessor((DateDayVector) vector);\n+      } else if (vector instanceof TimeStampMicroTZVector) {\n+        return new TimestampAccessor((TimeStampMicroTZVector) vector);\n+      } else if (vector instanceof ListVector) {\n+        ListVector listVector = (ListVector) vector;\n+        return new ArrayAccessor(listVector);\n+      } else if (vector instanceof StructVector) {\n+        StructVector structVector = (StructVector) vector;\n+        return new StructAccessor(structVector);\n+      }\n+    }\n+    throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n+  }\n+\n+  private static class BooleanAccessor extends ArrowVectorAccessor {\n+\n+    private final BitVector vector;\n+\n+    BooleanAccessor(BitVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final boolean getBoolean(int rowId) {\n+      return vector.get(rowId) == 1;\n+    }\n+  }\n+\n+  private static class IntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    IntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class LongAccessor extends ArrowVectorAccessor {\n+\n+    private final BigIntVector vector;\n+\n+    LongAccessor(BigIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class DictionaryLongAccessor extends DictionaryArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryLongAccessor(IntVector vector, Dictionary dictionary) {\n+      super(vector, dictionary);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return parquetDictionary.decodeToLong(vector.get(rowId));\n+    }\n+  }\n+\n+  private static class FloatAccessor extends ArrowVectorAccessor {\n+\n+    private final Float4Vector vector;\n+\n+    FloatAccessor(Float4Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class DictionaryFloatAccessor extends DictionaryArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryFloatAccessor(IntVector vector, Dictionary dictionary) {\n+      super(vector, dictionary);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return parquetDictionary.decodeToFloat(vector.get(rowId));\n+    }\n+  }\n+\n+  private static class DoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final Float8Vector vector;\n+\n+    DoubleAccessor(Float8Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class DictionaryDoubleAccessor extends DictionaryArrowVectorAccessor {", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxOTA1Mw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410519053", "body": "Nit: why is the class name plural? Shouldn't it be `ColumnarBatchReader`?", "bodyText": "Nit: why is the class name plural? Shouldn't it be ColumnarBatchReader?", "bodyHTML": "<p dir=\"auto\">Nit: why is the class name plural? Shouldn't it be <code>ColumnarBatchReader</code>?</p>", "author": "rdblue", "createdAt": "2020-04-17T23:56:51Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ColumnarBatchReaders.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import java.lang.reflect.Array;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.page.PageReadStore;\n+import org.apache.parquet.hadoop.metadata.ColumnChunkMetaData;\n+import org.apache.parquet.hadoop.metadata.ColumnPath;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n+\n+/**\n+ * {@link VectorizedReader} that returns Spark's {@link ColumnarBatch} to support Spark's vectorized read path. The\n+ * {@link ColumnarBatch} returned is created by passing in the Arrow vectors populated via delegated read calls to\n+ * {@linkplain VectorizedArrowReader VectorReader(s)}.\n+ */\n+public class ColumnarBatchReaders implements VectorizedReader<ColumnarBatch> {", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxOTE2NA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410519164", "body": "Why not `new VectorizedArrowReader[readers.size()]`?", "bodyText": "Why not new VectorizedArrowReader[readers.size()]?", "bodyHTML": "<p dir=\"auto\">Why not <code>new VectorizedArrowReader[readers.size()]</code>?</p>", "author": "rdblue", "createdAt": "2020-04-17T23:57:32Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ColumnarBatchReaders.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import java.lang.reflect.Array;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.page.PageReadStore;\n+import org.apache.parquet.hadoop.metadata.ColumnChunkMetaData;\n+import org.apache.parquet.hadoop.metadata.ColumnPath;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n+\n+/**\n+ * {@link VectorizedReader} that returns Spark's {@link ColumnarBatch} to support Spark's vectorized read path. The\n+ * {@link ColumnarBatch} returned is created by passing in the Arrow vectors populated via delegated read calls to\n+ * {@linkplain VectorizedArrowReader VectorReader(s)}.\n+ */\n+public class ColumnarBatchReaders implements VectorizedReader<ColumnarBatch> {\n+  private final VectorizedArrowReader[] readers;\n+\n+  public ColumnarBatchReaders(List<VectorizedReader> readers) {\n+    this.readers = (VectorizedArrowReader[]) Array.newInstance(\n+        VectorizedArrowReader.class, readers.size());", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxOTU3Nw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410519577", "bodyText": "Or better, this is where streams are really useful:\n    this.readers = readers.stream()\n        .map(VectorizedArrowReader.class::cast)\n        .toArray(VectorizedArrowReader[]::new);", "author": "rdblue", "createdAt": "2020-04-17T23:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxOTE2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ0Mzg5Nw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r418443897", "bodyText": "Good tip on using streams. Makes it so much more concise.", "author": "samarthjain", "createdAt": "2020-05-01T07:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxOTE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjk0Mw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410522943", "body": "This doesn't use `projectedIcebergSchema`. Can you remove it?\r\n\r\nAlso, I think it would be possible to use just the expected schema instead of the table schema. In `primitive`, the table schema is used to find the Iceberg type. But if the Iceberg type is missing from the projection, then it can't be projected and will be skipped later. So it should be safe to do this:\r\n\r\n```java\r\n      ...\r\n      ColumnDescriptor desc = parquetSchema.getColumnDescription(currentPath());\r\n      // Nested types not yet supported for vectorized reads\r\n      if (desc.getMaxRepetitionLevel() > 0) {\r\n        return null;\r\n      }\r\n\r\n      Types.NestedField icebergField = icebergSchema.findField(parquetFieldId);\r\n      if (icebergField == null) {\r\n        return null;\r\n      }\r\n\r\n      return new VectorizedArrowReader(\r\n          desc, icebergField, rootAllocator, batchSize, false /* setArrowValidityVector */);\r\n```\r\n\r\nIf that works, then you wouldn't need to pass the file schema all the way in.", "bodyText": "This doesn't use projectedIcebergSchema. Can you remove it?\nAlso, I think it would be possible to use just the expected schema instead of the table schema. In primitive, the table schema is used to find the Iceberg type. But if the Iceberg type is missing from the projection, then it can't be projected and will be skipped later. So it should be safe to do this:\n      ...\n      ColumnDescriptor desc = parquetSchema.getColumnDescription(currentPath());\n      // Nested types not yet supported for vectorized reads\n      if (desc.getMaxRepetitionLevel() > 0) {\n        return null;\n      }\n\n      Types.NestedField icebergField = icebergSchema.findField(parquetFieldId);\n      if (icebergField == null) {\n        return null;\n      }\n\n      return new VectorizedArrowReader(\n          desc, icebergField, rootAllocator, batchSize, false /* setArrowValidityVector */);\nIf that works, then you wouldn't need to pass the file schema all the way in.", "bodyHTML": "<p dir=\"auto\">This doesn't use <code>projectedIcebergSchema</code>. Can you remove it?</p>\n<p dir=\"auto\">Also, I think it would be possible to use just the expected schema instead of the table schema. In <code>primitive</code>, the table schema is used to find the Iceberg type. But if the Iceberg type is missing from the projection, then it can't be projected and will be skipped later. So it should be safe to do this:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"      ...\n      ColumnDescriptor desc = parquetSchema.getColumnDescription(currentPath());\n      // Nested types not yet supported for vectorized reads\n      if (desc.getMaxRepetitionLevel() &gt; 0) {\n        return null;\n      }\n\n      Types.NestedField icebergField = icebergSchema.findField(parquetFieldId);\n      if (icebergField == null) {\n        return null;\n      }\n\n      return new VectorizedArrowReader(\n          desc, icebergField, rootAllocator, batchSize, false /* setArrowValidityVector */);\n\"><pre>      <span class=\"pl-c1\">...</span>\n      <span class=\"pl-smi\">ColumnDescriptor</span> desc <span class=\"pl-k\">=</span> parquetSchema<span class=\"pl-k\">.</span>getColumnDescription(currentPath());\n      <span class=\"pl-c\"><span class=\"pl-c\">//</span> Nested types not yet supported for vectorized reads</span>\n      <span class=\"pl-k\">if</span> (desc<span class=\"pl-k\">.</span>getMaxRepetitionLevel() <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span>) {\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">null</span>;\n      }\n\n      <span class=\"pl-smi\">Types</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">NestedField</span> icebergField <span class=\"pl-k\">=</span> icebergSchema<span class=\"pl-k\">.</span>findField(parquetFieldId);\n      <span class=\"pl-k\">if</span> (icebergField <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) {\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">null</span>;\n      }\n\n      <span class=\"pl-k\">return</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">VectorizedArrowReader</span>(\n          desc, icebergField, rootAllocator, batchSize, <span class=\"pl-c1\">false</span> <span class=\"pl-c\"><span class=\"pl-c\">/*</span> setArrowValidityVector <span class=\"pl-c\">*/</span></span>);</pre></div>\n<p dir=\"auto\">If that works, then you wouldn't need to pass the file schema all the way in.</p>", "author": "rdblue", "createdAt": "2020-04-18T00:19:55Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/VectorizedSparkParquetReaders.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.TypeWithSchemaVisitor;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.iceberg.spark.arrow.ArrowAllocation;\n+import org.apache.iceberg.types.Types;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.schema.GroupType;\n+import org.apache.parquet.schema.MessageType;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.parquet.schema.Type;\n+\n+public class VectorizedSparkParquetReaders {\n+\n+  private VectorizedSparkParquetReaders() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static ColumnarBatchReaders buildReader(\n+      Schema tableSchema,\n+      Schema expectedSchema,\n+      MessageType fileSchema,\n+      Integer recordsPerBatch) {\n+    return (ColumnarBatchReaders)\n+        TypeWithSchemaVisitor.visit(expectedSchema.asStruct(), fileSchema,\n+            new VectorizedReaderBuilder(tableSchema, expectedSchema, fileSchema, recordsPerBatch));\n+  }\n+\n+  private static class VectorizedReaderBuilder extends TypeWithSchemaVisitor<VectorizedReader> {\n+    private final MessageType parquetSchema;\n+    private final Schema tableIcebergSchema;\n+    private final BufferAllocator rootAllocator;\n+    private final int batchSize;\n+\n+    VectorizedReaderBuilder(\n+        Schema tableSchema,\n+        Schema projectedIcebergSchema,", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc2NzU2OQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r419767569", "bodyText": "Will change. However, we still need the file schema(parquetSchema) as it is used to get hold of the column descriptor.", "author": "samarthjain", "createdAt": "2020-05-04T22:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MjYwNg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r420292606", "bodyText": "I think I meant table schema, not file schema.", "author": "rdblue", "createdAt": "2020-05-05T17:44:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMzA0Nw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410523047", "body": "This is another case where `IntStream` can make this a bit simpler:\r\n```java\r\n      IntStream.range(0, fields.size())\r\n          .forEach(pos -> readersById.put(fields.get(pos).getId().intValue(), fieldReaders.get(pos)));\r\n```", "bodyText": "This is another case where IntStream can make this a bit simpler:\n      IntStream.range(0, fields.size())\n          .forEach(pos -> readersById.put(fields.get(pos).getId().intValue(), fieldReaders.get(pos)));", "bodyHTML": "<p dir=\"auto\">This is another case where <code>IntStream</code> can make this a bit simpler:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"      IntStream.range(0, fields.size())\n          .forEach(pos -&gt; readersById.put(fields.get(pos).getId().intValue(), fieldReaders.get(pos)));\n\"><pre>      <span class=\"pl-smi\">IntStream</span><span class=\"pl-k\">.</span>range(<span class=\"pl-c1\">0</span>, fields<span class=\"pl-k\">.</span>size())\n          .forEach(pos <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> readersById<span class=\"pl-k\">.</span>put(fields<span class=\"pl-k\">.</span>get(pos)<span class=\"pl-k\">.</span>getId()<span class=\"pl-k\">.</span>intValue(), fieldReaders<span class=\"pl-k\">.</span>get(pos)));</pre></div>", "author": "rdblue", "createdAt": "2020-04-18T00:20:28Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/VectorizedSparkParquetReaders.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.TypeWithSchemaVisitor;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.iceberg.spark.arrow.ArrowAllocation;\n+import org.apache.iceberg.types.Types;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.schema.GroupType;\n+import org.apache.parquet.schema.MessageType;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.parquet.schema.Type;\n+\n+public class VectorizedSparkParquetReaders {\n+\n+  private VectorizedSparkParquetReaders() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static ColumnarBatchReaders buildReader(\n+      Schema tableSchema,\n+      Schema expectedSchema,\n+      MessageType fileSchema,\n+      Integer recordsPerBatch) {\n+    return (ColumnarBatchReaders)\n+        TypeWithSchemaVisitor.visit(expectedSchema.asStruct(), fileSchema,\n+            new VectorizedReaderBuilder(tableSchema, expectedSchema, fileSchema, recordsPerBatch));\n+  }\n+\n+  private static class VectorizedReaderBuilder extends TypeWithSchemaVisitor<VectorizedReader> {\n+    private final MessageType parquetSchema;\n+    private final Schema tableIcebergSchema;\n+    private final BufferAllocator rootAllocator;\n+    private final int batchSize;\n+\n+    VectorizedReaderBuilder(\n+        Schema tableSchema,\n+        Schema projectedIcebergSchema,\n+        MessageType parquetSchema,\n+        int bSize) {\n+      this.parquetSchema = parquetSchema;\n+      this.tableIcebergSchema = tableSchema;\n+      this.batchSize = bSize;\n+      this.rootAllocator = ArrowAllocation.rootAllocator()\n+          .newChildAllocator(\"VectorizedReadBuilder\", 0, Long.MAX_VALUE);\n+    }\n+\n+    @Override\n+    public VectorizedReader message(\n+            Types.StructType expected, MessageType message,\n+            List<VectorizedReader> fieldReaders) {\n+      return struct(expected, message.asGroupType(), fieldReaders);\n+    }\n+\n+    @Override\n+    public VectorizedReader struct(\n+            Types.StructType expected, GroupType struct,\n+            List<VectorizedReader> fieldReaders) {\n+\n+      Map<Integer, VectorizedReader> readersById = Maps.newHashMap();\n+      List<Type> fields = struct.getFields();\n+\n+      for (int i = 0; i < fields.size(); i += 1) {", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDExNw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410524117", "body": "Preconditions accept a format string and arguments to avoid string creation every time the method is called, which is what happens when you use concatenation like this. Can you update the check like this?\r\n\r\n```java\r\nPreconditions.checkArgument(numRowsToRead > 0, \"Invalid number of rows to read: %s\", numRowsToRead);\r\n```", "bodyText": "Preconditions accept a format string and arguments to avoid string creation every time the method is called, which is what happens when you use concatenation like this. Can you update the check like this?\nPreconditions.checkArgument(numRowsToRead > 0, \"Invalid number of rows to read: %s\", numRowsToRead);", "bodyHTML": "<p dir=\"auto\">Preconditions accept a format string and arguments to avoid string creation every time the method is called, which is what happens when you use concatenation like this. Can you update the check like this?</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Preconditions.checkArgument(numRowsToRead &gt; 0, &quot;Invalid number of rows to read: %s&quot;, numRowsToRead);\n\"><pre><span class=\"pl-smi\">Preconditions</span><span class=\"pl-k\">.</span>checkArgument(numRowsToRead <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Invalid number of rows to read: %s<span class=\"pl-pds\">\"</span></span>, numRowsToRead);</pre></div>", "author": "rdblue", "createdAt": "2020-04-18T00:27:22Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ColumnarBatchReaders.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import java.lang.reflect.Array;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.page.PageReadStore;\n+import org.apache.parquet.hadoop.metadata.ColumnChunkMetaData;\n+import org.apache.parquet.hadoop.metadata.ColumnPath;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n+\n+/**\n+ * {@link VectorizedReader} that returns Spark's {@link ColumnarBatch} to support Spark's vectorized read path. The\n+ * {@link ColumnarBatch} returned is created by passing in the Arrow vectors populated via delegated read calls to\n+ * {@linkplain VectorizedArrowReader VectorReader(s)}.\n+ */\n+public class ColumnarBatchReaders implements VectorizedReader<ColumnarBatch> {\n+  private final VectorizedArrowReader[] readers;\n+\n+  public ColumnarBatchReaders(List<VectorizedReader> readers) {\n+    this.readers = (VectorizedArrowReader[]) Array.newInstance(\n+        VectorizedArrowReader.class, readers.size());\n+    int idx = 0;\n+    for (VectorizedReader reader : readers) {\n+      this.readers[idx] = (VectorizedArrowReader) reader;\n+      idx++;\n+    }\n+  }\n+\n+  @Override\n+  public final void setRowGroupInfo(PageReadStore pageStore, Map<ColumnPath, ColumnChunkMetaData> metaData) {\n+    for (int i = 0; i < readers.length; i += 1) {\n+      if (readers[i] != null) {\n+        readers[i].setRowGroupInfo(pageStore, metaData);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void reuseContainers(boolean reuse) {\n+    for (VectorizedReader reader : readers) {\n+      reader.reuseContainers(reuse);\n+    }\n+  }\n+\n+  @Override\n+  public final ColumnarBatch read(int numRowsToRead) {\n+    Preconditions.checkArgument(numRowsToRead > 0, \"Invalid value: \" + numRowsToRead);", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDI2Mg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410524262", "body": "I'm seeing a lot of parameterized types without parameters. Can you make sure you add `<?>` here and check for that in other places?", "bodyText": "I'm seeing a lot of parameterized types without parameters. Can you make sure you add <?> here and check for that in other places?", "bodyHTML": "<p dir=\"auto\">I'm seeing a lot of parameterized types without parameters. Can you make sure you add <code>&lt;?&gt;</code> here and check for that in other places?</p>", "author": "rdblue", "createdAt": "2020-04-18T00:28:24Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ColumnarBatchReaders.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import java.lang.reflect.Array;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.page.PageReadStore;\n+import org.apache.parquet.hadoop.metadata.ColumnChunkMetaData;\n+import org.apache.parquet.hadoop.metadata.ColumnPath;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n+\n+/**\n+ * {@link VectorizedReader} that returns Spark's {@link ColumnarBatch} to support Spark's vectorized read path. The\n+ * {@link ColumnarBatch} returned is created by passing in the Arrow vectors populated via delegated read calls to\n+ * {@linkplain VectorizedArrowReader VectorReader(s)}.\n+ */\n+public class ColumnarBatchReaders implements VectorizedReader<ColumnarBatch> {\n+  private final VectorizedArrowReader[] readers;\n+\n+  public ColumnarBatchReaders(List<VectorizedReader> readers) {\n+    this.readers = (VectorizedArrowReader[]) Array.newInstance(\n+        VectorizedArrowReader.class, readers.size());\n+    int idx = 0;\n+    for (VectorizedReader reader : readers) {\n+      this.readers[idx] = (VectorizedArrowReader) reader;\n+      idx++;\n+    }\n+  }\n+\n+  @Override\n+  public final void setRowGroupInfo(PageReadStore pageStore, Map<ColumnPath, ColumnChunkMetaData> metaData) {\n+    for (int i = 0; i < readers.length; i += 1) {\n+      if (readers[i] != null) {\n+        readers[i].setRowGroupInfo(pageStore, metaData);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void reuseContainers(boolean reuse) {\n+    for (VectorizedReader reader : readers) {", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDM1Mw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410524353", "body": "This can be a for-each loop:\r\n\r\n```java\r\n    for (VectorizedArrowReader reader : readers) {\r\n      if (reader != null) {\r\n        reader.setRowGroupInfo(pageStore, metaData);\r\n      }\r\n    }\r\n```", "bodyText": "This can be a for-each loop:\n    for (VectorizedArrowReader reader : readers) {\n      if (reader != null) {\n        reader.setRowGroupInfo(pageStore, metaData);\n      }\n    }", "bodyHTML": "<p dir=\"auto\">This can be a for-each loop:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"    for (VectorizedArrowReader reader : readers) {\n      if (reader != null) {\n        reader.setRowGroupInfo(pageStore, metaData);\n      }\n    }\n\"><pre>    <span class=\"pl-k\">for</span> (<span class=\"pl-smi\">VectorizedArrowReader</span> reader <span class=\"pl-k\">:</span> readers) {\n      <span class=\"pl-k\">if</span> (reader <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span>) {\n        reader<span class=\"pl-k\">.</span>setRowGroupInfo(pageStore, metaData);\n      }\n    }</pre></div>", "author": "rdblue", "createdAt": "2020-04-18T00:28:52Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ColumnarBatchReaders.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import java.lang.reflect.Array;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.page.PageReadStore;\n+import org.apache.parquet.hadoop.metadata.ColumnChunkMetaData;\n+import org.apache.parquet.hadoop.metadata.ColumnPath;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n+\n+/**\n+ * {@link VectorizedReader} that returns Spark's {@link ColumnarBatch} to support Spark's vectorized read path. The\n+ * {@link ColumnarBatch} returned is created by passing in the Arrow vectors populated via delegated read calls to\n+ * {@linkplain VectorizedArrowReader VectorReader(s)}.\n+ */\n+public class ColumnarBatchReaders implements VectorizedReader<ColumnarBatch> {\n+  private final VectorizedArrowReader[] readers;\n+\n+  public ColumnarBatchReaders(List<VectorizedReader> readers) {\n+    this.readers = (VectorizedArrowReader[]) Array.newInstance(\n+        VectorizedArrowReader.class, readers.size());\n+    int idx = 0;\n+    for (VectorizedReader reader : readers) {\n+      this.readers[idx] = (VectorizedArrowReader) reader;\n+      idx++;\n+    }\n+  }\n+\n+  @Override\n+  public final void setRowGroupInfo(PageReadStore pageStore, Map<ColumnPath, ColumnChunkMetaData> metaData) {\n+    for (int i = 0; i < readers.length; i += 1) {", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDY5MA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410524690", "body": "This should also use a format string.", "bodyText": "This should also use a format string.", "bodyHTML": "<p dir=\"auto\">This should also use a format string.</p>", "author": "rdblue", "createdAt": "2020-04-18T00:31:18Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ColumnarBatchReaders.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import java.lang.reflect.Array;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.page.PageReadStore;\n+import org.apache.parquet.hadoop.metadata.ColumnChunkMetaData;\n+import org.apache.parquet.hadoop.metadata.ColumnPath;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n+\n+/**\n+ * {@link VectorizedReader} that returns Spark's {@link ColumnarBatch} to support Spark's vectorized read path. The\n+ * {@link ColumnarBatch} returned is created by passing in the Arrow vectors populated via delegated read calls to\n+ * {@linkplain VectorizedArrowReader VectorReader(s)}.\n+ */\n+public class ColumnarBatchReaders implements VectorizedReader<ColumnarBatch> {\n+  private final VectorizedArrowReader[] readers;\n+\n+  public ColumnarBatchReaders(List<VectorizedReader> readers) {\n+    this.readers = (VectorizedArrowReader[]) Array.newInstance(\n+        VectorizedArrowReader.class, readers.size());\n+    int idx = 0;\n+    for (VectorizedReader reader : readers) {\n+      this.readers[idx] = (VectorizedArrowReader) reader;\n+      idx++;\n+    }\n+  }\n+\n+  @Override\n+  public final void setRowGroupInfo(PageReadStore pageStore, Map<ColumnPath, ColumnChunkMetaData> metaData) {\n+    for (int i = 0; i < readers.length; i += 1) {\n+      if (readers[i] != null) {\n+        readers[i].setRowGroupInfo(pageStore, metaData);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void reuseContainers(boolean reuse) {\n+    for (VectorizedReader reader : readers) {\n+      reader.reuseContainers(reuse);\n+    }\n+  }\n+\n+  @Override\n+  public final ColumnarBatch read(int numRowsToRead) {\n+    Preconditions.checkArgument(numRowsToRead > 0, \"Invalid value: \" + numRowsToRead);\n+    ColumnVector[] arrowColumnVectors = new ColumnVector[readers.length];\n+    int prevNum = 0;\n+    for (int i = 0; i < readers.length; i += 1) {\n+      VectorHolder holder = readers[i].read(numRowsToRead);\n+      int numRowsInVector = holder.numValues();\n+      Preconditions.checkState(\n+          numRowsInVector == numRowsToRead,\n+          \"Number of rows in the vector \" + numRowsInVector + \" didn't match expected \" +\n+              numRowsToRead);", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDc2Nw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410524767", "body": "If this is always expected to return the requested number of rows, then there is no need for the `prevNum` check because this would fail before that check would.", "bodyText": "If this is always expected to return the requested number of rows, then there is no need for the prevNum check because this would fail before that check would.", "bodyHTML": "<p dir=\"auto\">If this is always expected to return the requested number of rows, then there is no need for the <code>prevNum</code> check because this would fail before that check would.</p>", "author": "rdblue", "createdAt": "2020-04-18T00:31:54Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ColumnarBatchReaders.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import java.lang.reflect.Array;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.page.PageReadStore;\n+import org.apache.parquet.hadoop.metadata.ColumnChunkMetaData;\n+import org.apache.parquet.hadoop.metadata.ColumnPath;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n+\n+/**\n+ * {@link VectorizedReader} that returns Spark's {@link ColumnarBatch} to support Spark's vectorized read path. The\n+ * {@link ColumnarBatch} returned is created by passing in the Arrow vectors populated via delegated read calls to\n+ * {@linkplain VectorizedArrowReader VectorReader(s)}.\n+ */\n+public class ColumnarBatchReaders implements VectorizedReader<ColumnarBatch> {\n+  private final VectorizedArrowReader[] readers;\n+\n+  public ColumnarBatchReaders(List<VectorizedReader> readers) {\n+    this.readers = (VectorizedArrowReader[]) Array.newInstance(\n+        VectorizedArrowReader.class, readers.size());\n+    int idx = 0;\n+    for (VectorizedReader reader : readers) {\n+      this.readers[idx] = (VectorizedArrowReader) reader;\n+      idx++;\n+    }\n+  }\n+\n+  @Override\n+  public final void setRowGroupInfo(PageReadStore pageStore, Map<ColumnPath, ColumnChunkMetaData> metaData) {\n+    for (int i = 0; i < readers.length; i += 1) {\n+      if (readers[i] != null) {\n+        readers[i].setRowGroupInfo(pageStore, metaData);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void reuseContainers(boolean reuse) {\n+    for (VectorizedReader reader : readers) {\n+      reader.reuseContainers(reuse);\n+    }\n+  }\n+\n+  @Override\n+  public final ColumnarBatch read(int numRowsToRead) {\n+    Preconditions.checkArgument(numRowsToRead > 0, \"Invalid value: \" + numRowsToRead);\n+    ColumnVector[] arrowColumnVectors = new ColumnVector[readers.length];\n+    int prevNum = 0;\n+    for (int i = 0; i < readers.length; i += 1) {\n+      VectorHolder holder = readers[i].read(numRowsToRead);\n+      int numRowsInVector = holder.numValues();\n+      Preconditions.checkState(\n+          numRowsInVector == numRowsToRead,", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc2Mzc2OA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r418763768", "bodyText": "Good point. Will remove the check.", "author": "samarthjain", "createdAt": "2020-05-01T22:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNTI0Mg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410525242", "body": "Are these types rejected when we create Iceberg tables?", "bodyText": "Are these types rejected when we create Iceberg tables?", "bodyHTML": "<p dir=\"auto\">Are these types rejected when we create Iceberg tables?</p>", "author": "rdblue", "createdAt": "2020-04-18T00:34:46Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.SparkSchemaUtil;\n+import org.apache.parquet.Preconditions;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(SparkSchemaUtil.convert(holder.icebergType()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.accessor = ArrowVectorAccessors.getVectorAccessor(holder);\n+  }\n+\n+  @Override\n+  public void close() {\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type - byte\");", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc2NDY2Mg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r418764662", "bodyText": "I don't see BYTE and SHORT type in https://github.com/apache/incubator-iceberg/blob/master/api/src/main/java/org/apache/iceberg/types/Type.java\nSo I would assume so?", "author": "samarthjain", "createdAt": "2020-05-01T22:31:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNTI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MjE3MQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r420292171", "bodyText": "Looks good to me.", "author": "rdblue", "createdAt": "2020-05-05T17:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNTI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNjAxNg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410526016", "body": "This is the only place that uses `childColumns` and it seems really strange to only set them in a sub-class, even though they are available in the constructor.\r\n\r\nCould you make the superclass `childColumns` a `private final` field instead, and pass the child columns through a second constructor? Like this:\r\n\r\n```java\r\n    StructAccessor(StructVector structVector) {\r\n      super(structVector,\r\n          IntStream.range(0, structVector.size())\r\n              .mapToObj(structVector::getVectorById)\r\n              .map(ArrowColumnVector::new)\r\n              .toArray(ArrowColumnVector[]::new));\r\n    }\r\n```", "bodyText": "This is the only place that uses childColumns and it seems really strange to only set them in a sub-class, even though they are available in the constructor.\nCould you make the superclass childColumns a private final field instead, and pass the child columns through a second constructor? Like this:\n    StructAccessor(StructVector structVector) {\n      super(structVector,\n          IntStream.range(0, structVector.size())\n              .mapToObj(structVector::getVectorById)\n              .map(ArrowColumnVector::new)\n              .toArray(ArrowColumnVector[]::new));\n    }", "bodyHTML": "<p dir=\"auto\">This is the only place that uses <code>childColumns</code> and it seems really strange to only set them in a sub-class, even though they are available in the constructor.</p>\n<p dir=\"auto\">Could you make the superclass <code>childColumns</code> a <code>private final</code> field instead, and pass the child columns through a second constructor? Like this:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"    StructAccessor(StructVector structVector) {\n      super(structVector,\n          IntStream.range(0, structVector.size())\n              .mapToObj(structVector::getVectorById)\n              .map(ArrowColumnVector::new)\n              .toArray(ArrowColumnVector[]::new));\n    }\n\"><pre>    StructAccessor(<span class=\"pl-smi\">StructVector</span> structVector) {\n      <span class=\"pl-c1\">super</span>(structVector,\n          <span class=\"pl-smi\">IntStream</span><span class=\"pl-k\">.</span>range(<span class=\"pl-c1\">0</span>, structVector<span class=\"pl-k\">.</span>size())\n              .mapToObj(structVector<span class=\"pl-k\">::</span>getVectorById)\n              .map(<span class=\"pl-smi\">ArrowColumnVector</span><span class=\"pl-k\">::</span><span class=\"pl-k\">new</span>)\n              .toArray(<span class=\"pl-k\">ArrowColumnVector</span>[]<span class=\"pl-k\">::</span><span class=\"pl-k\">new</span>));\n    }</pre></div>", "author": "rdblue", "createdAt": "2020-04-18T00:40:20Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ArrowVectorAccessors.java", "diffHunk": "@@ -0,0 +1,495 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.FixedSizeBinaryVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.io.api.Binary;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+public class ArrowVectorAccessors {\n+\n+  private ArrowVectorAccessors() {}\n+\n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+  static ArrowVectorAccessor getVectorAccessor(VectorHolder holder) {\n+    Dictionary dictionary = holder.dictionary();\n+    boolean isVectorDictEncoded = holder.isDictionaryEncoded();\n+    ColumnDescriptor desc = holder.descriptor();\n+    FieldVector vector = holder.vector();\n+    PrimitiveType primitive = desc.getPrimitiveType();\n+    if (isVectorDictEncoded) {\n+      Preconditions.checkState(vector instanceof IntVector, \"Dictionary ids should be stored in IntVectors only\");\n+      if (primitive.getOriginalType() != null) {\n+        switch (desc.getPrimitiveType().getOriginalType()) {\n+          case ENUM:\n+          case JSON:\n+          case UTF8:\n+          case BSON:\n+            return new DictionaryStringAccessor((IntVector) vector, dictionary);\n+          case INT_64:\n+          case TIMESTAMP_MILLIS:\n+          case TIMESTAMP_MICROS:\n+            return new DictionaryLongAccessor((IntVector) vector, dictionary);\n+          case DECIMAL:\n+            switch (primitive.getPrimitiveTypeName()) {\n+              case BINARY:\n+              case FIXED_LEN_BYTE_ARRAY:\n+                return new DictionaryDecimalBinaryAccessor(\n+                    (IntVector) vector,\n+                    dictionary);\n+              case INT64:\n+                return new DictionaryDecimalLongAccessor(\n+                    (IntVector) vector,\n+                    dictionary);\n+              case INT32:\n+                return new DictionaryDecimalIntAccessor(\n+                    (IntVector) vector,\n+                    dictionary);\n+              default:\n+                throw new UnsupportedOperationException(\n+                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n+            }\n+          default:\n+            throw new UnsupportedOperationException(\n+                \"Unsupported logical type: \" + primitive.getOriginalType());\n+        }\n+      } else {\n+        switch (primitive.getPrimitiveTypeName()) {\n+          case FIXED_LEN_BYTE_ARRAY:\n+          case BINARY:\n+            return new DictionaryBinaryAccessor((IntVector) vector, dictionary);\n+          case FLOAT:\n+            return new DictionaryFloatAccessor((IntVector) vector, dictionary);\n+          case INT64:\n+            return new DictionaryLongAccessor((IntVector) vector, dictionary);\n+          case DOUBLE:\n+            return new DictionaryDoubleAccessor((IntVector) vector, dictionary);\n+          default:\n+            throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n+        }\n+      }\n+    } else {\n+      if (vector instanceof BitVector) {\n+        return new BooleanAccessor((BitVector) vector);\n+      } else if (vector instanceof IntVector) {\n+        return new IntAccessor((IntVector) vector);\n+      } else if (vector instanceof BigIntVector) {\n+        return new LongAccessor((BigIntVector) vector);\n+      } else if (vector instanceof Float4Vector) {\n+        return new FloatAccessor((Float4Vector) vector);\n+      } else if (vector instanceof Float8Vector) {\n+        return new DoubleAccessor((Float8Vector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.DecimalArrowVector) {\n+        return new DecimalAccessor((IcebergArrowVectors.DecimalArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarcharArrowVector) {\n+        return new StringAccessor((IcebergArrowVectors.VarcharArrowVector) vector);\n+      } else if (vector instanceof IcebergArrowVectors.VarBinaryArrowVector) {\n+        return new BinaryAccessor((IcebergArrowVectors.VarBinaryArrowVector) vector);\n+      } else if (vector instanceof DateDayVector) {\n+        return new DateAccessor((DateDayVector) vector);\n+      } else if (vector instanceof TimeStampMicroTZVector) {\n+        return new TimestampAccessor((TimeStampMicroTZVector) vector);\n+      } else if (vector instanceof ListVector) {\n+        ListVector listVector = (ListVector) vector;\n+        return new ArrayAccessor(listVector);\n+      } else if (vector instanceof StructVector) {\n+        StructVector structVector = (StructVector) vector;\n+        return new StructAccessor(structVector);\n+      }\n+    }\n+    throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n+  }\n+\n+  private static class BooleanAccessor extends ArrowVectorAccessor {\n+\n+    private final BitVector vector;\n+\n+    BooleanAccessor(BitVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final boolean getBoolean(int rowId) {\n+      return vector.get(rowId) == 1;\n+    }\n+  }\n+\n+  private static class IntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    IntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class LongAccessor extends ArrowVectorAccessor {\n+\n+    private final BigIntVector vector;\n+\n+    LongAccessor(BigIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class DictionaryLongAccessor extends DictionaryArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryLongAccessor(IntVector vector, Dictionary dictionary) {\n+      super(vector, dictionary);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return parquetDictionary.decodeToLong(vector.get(rowId));\n+    }\n+  }\n+\n+  private static class FloatAccessor extends ArrowVectorAccessor {\n+\n+    private final Float4Vector vector;\n+\n+    FloatAccessor(Float4Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class DictionaryFloatAccessor extends DictionaryArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryFloatAccessor(IntVector vector, Dictionary dictionary) {\n+      super(vector, dictionary);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return parquetDictionary.decodeToFloat(vector.get(rowId));\n+    }\n+  }\n+\n+  private static class DoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final Float8Vector vector;\n+\n+    DoubleAccessor(Float8Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class DictionaryDoubleAccessor extends DictionaryArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    DictionaryDoubleAccessor(IntVector vector, Dictionary dictionary) {\n+      super(vector, dictionary);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return parquetDictionary.decodeToDouble(vector.get(rowId));\n+    }\n+  }\n+\n+  private static class DecimalAccessor extends ArrowVectorAccessor {\n+\n+    private final IcebergArrowVectors.DecimalArrowVector vector;\n+\n+    DecimalAccessor(IcebergArrowVectors.DecimalArrowVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final Decimal getDecimal(int rowId, int precision, int scale) {\n+      return Decimal.apply(vector.getObject(rowId), precision, scale);\n+    }\n+  }\n+\n+  private static class StringAccessor extends ArrowVectorAccessor {\n+\n+    private final IcebergArrowVectors.VarcharArrowVector vector;\n+    private final NullableVarCharHolder stringResult = new NullableVarCharHolder();\n+\n+    StringAccessor(IcebergArrowVectors.VarcharArrowVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final UTF8String getUTF8String(int rowId) {\n+      vector.get(rowId, stringResult);\n+      if (stringResult.isSet == 0) {\n+        return null;\n+      } else {\n+        return UTF8String.fromAddress(\n+            null,\n+            stringResult.buffer.memoryAddress() + stringResult.start,\n+            stringResult.end - stringResult.start);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"checkstyle:VisibilityModifier\")\n+  private abstract static class DictionaryArrowVectorAccessor extends ArrowVectorAccessor {\n+    final Dictionary parquetDictionary;\n+    final IntVector dictionaryVector;\n+\n+    private DictionaryArrowVectorAccessor(IntVector vector, Dictionary dictionary) {\n+      super(vector);\n+      this.dictionaryVector = vector;\n+      this.parquetDictionary = dictionary;\n+    }\n+  }\n+\n+  private static class DictionaryStringAccessor extends DictionaryArrowVectorAccessor {\n+\n+    DictionaryStringAccessor(IntVector vector, Dictionary dictionary) {\n+      super(vector, dictionary);\n+    }\n+\n+    @Override\n+    final UTF8String getUTF8String(int rowId) {\n+      Binary binary = parquetDictionary.decodeToBinary(dictionaryVector.get(rowId));\n+      return UTF8String.fromBytes(binary.getBytesUnsafe());\n+    }\n+  }\n+\n+  private static class FixedSizeBinaryAccessor extends ArrowVectorAccessor {\n+\n+    private final FixedSizeBinaryVector vector;\n+\n+    FixedSizeBinaryAccessor(FixedSizeBinaryVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte[] getBinary(int rowId) {\n+      return vector.getObject(rowId);\n+    }\n+  }\n+\n+  private static class BinaryAccessor extends ArrowVectorAccessor {\n+\n+    private final VarBinaryVector vector;\n+\n+    BinaryAccessor(VarBinaryVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final byte[] getBinary(int rowId) {\n+      return vector.getObject(rowId);\n+    }\n+  }\n+\n+  private static class DictionaryBinaryAccessor extends DictionaryArrowVectorAccessor {\n+\n+    DictionaryBinaryAccessor(IntVector vector, Dictionary dictionary) {\n+      super(vector, dictionary);\n+    }\n+\n+    @Override\n+    final byte[] getBinary(int rowId) {\n+      Binary binary = parquetDictionary.decodeToBinary(dictionaryVector.get(rowId));\n+      return binary.getBytesUnsafe();\n+    }\n+  }\n+\n+  private static class DateAccessor extends ArrowVectorAccessor {\n+\n+    private final DateDayVector vector;\n+\n+    DateAccessor(DateDayVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class TimestampAccessor extends ArrowVectorAccessor {\n+\n+    private final TimeStampMicroTZVector vector;\n+\n+    TimestampAccessor(TimeStampMicroTZVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class ArrayAccessor extends ArrowVectorAccessor {\n+\n+    private final ListVector vector;\n+    private final ArrowColumnVector arrayData;\n+\n+    ArrayAccessor(ListVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+      this.arrayData = new ArrowColumnVector(vector.getDataVector());\n+    }\n+\n+    @Override\n+    final ColumnarArray getArray(int rowId) {\n+      ArrowBuf offsets = vector.getOffsetBuffer();\n+      int index = rowId * ListVector.OFFSET_WIDTH;\n+      int start = offsets.getInt(index);\n+      int end = offsets.getInt(index + ListVector.OFFSET_WIDTH);\n+      return new ColumnarArray(arrayData, start, end - start);\n+    }\n+  }\n+\n+  /**\n+   * Use {@link IcebergArrowColumnVector#getChild(int)} to get hold of the {@link ArrowColumnVector} vectors holding the\n+   * struct values.\n+   */\n+  private static class StructAccessor extends ArrowVectorAccessor {\n+    StructAccessor(StructVector structVector) {\n+      super(structVector);\n+      childColumns = new ArrowColumnVector[structVector.size()];", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNjE4MA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410526180", "body": "Did I already ask why this is necessary?", "bodyText": "Did I already ask why this is necessary?", "bodyHTML": "<p dir=\"auto\">Did I already ask why this is necessary?</p>", "author": "rdblue", "createdAt": "2020-04-18T00:41:40Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.SparkSchemaUtil;\n+import org.apache.parquet.Preconditions;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(SparkSchemaUtil.convert(holder.icebergType()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.accessor = ArrowVectorAccessors.getVectorAccessor(holder);\n+  }\n+\n+  @Override\n+  public void close() {\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type - byte\");\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type - short\");\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type - map\");\n+  }\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    if (isNullAt(rowId)) {", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1MTMxNA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r418751314", "bodyText": "This was copied over from Spark's ArrowColumnVector\nhttps://github.com/apache/spark/blob/master/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ArrowColumnVector.java#L108\nThe difference from Spark's implementation is that our isNullAt(rowId) goes to the NullabilityHolder where as Spark's uses vector.isNull(rowId);\nFor spark, we don't set the validity bits in the validity vector since we track that piece of information in NullabilityHolder.", "author": "samarthjain", "createdAt": "2020-05-01T21:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNjE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTg4MA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r420291880", "bodyText": "But doesn't Spark already check nullability before calling this method?", "author": "rdblue", "createdAt": "2020-05-05T17:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNjE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyMDA0Mg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r420620042", "bodyText": "No, spark doesn't. See - https://github.com/apache/spark/blob/branch-2.4/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/MutableColumnarRow.java#L135", "author": "samarthjain", "createdAt": "2020-05-06T08:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNjE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzNTczNA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r420635734", "bodyText": "Also, depending on the accessor, it may or may not have the nullability information. For ex- for DictionaryStringAccessor,\n    final UTF8String getUTF8String(int rowId) {\n      int offset = offsetVector.get(rowId);\n      return decodedDictionary[offset];\n    }\n\nwithout the null check, the offsetVector could return a wrong value when the value at the rowId was actually null.", "author": "samarthjain", "createdAt": "2020-05-06T08:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNjE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNjMxNA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410526314", "body": "Instead of `childColumns()` and then accessing an ordinal, why not change the method to `accessor.childColumn(int pos)`?", "bodyText": "Instead of childColumns() and then accessing an ordinal, why not change the method to accessor.childColumn(int pos)?", "bodyHTML": "<p dir=\"auto\">Instead of <code>childColumns()</code> and then accessing an ordinal, why not change the method to <code>accessor.childColumn(int pos)</code>?</p>", "author": "rdblue", "createdAt": "2020-04-18T00:42:35Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.SparkSchemaUtil;\n+import org.apache.parquet.Preconditions;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(SparkSchemaUtil.convert(holder.icebergType()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.accessor = ArrowVectorAccessors.getVectorAccessor(holder);\n+  }\n+\n+  @Override\n+  public void close() {\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type - byte\");\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type - short\");\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type - map\");\n+  }\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  @Override\n+  public ArrowColumnVector getChild(int ordinal) {\n+    ArrowColumnVector[] childColumns = accessor.childColumns();", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNjQ2MA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410526460", "body": "Let's remove this `Precondition`. An invalid ordinal will cause an automatic exception and there is no need to check twice.", "bodyText": "Let's remove this Precondition. An invalid ordinal will cause an automatic exception and there is no need to check twice.", "bodyHTML": "<p dir=\"auto\">Let's remove this <code>Precondition</code>. An invalid ordinal will cause an automatic exception and there is no need to check twice.</p>", "author": "rdblue", "createdAt": "2020-04-18T00:43:33Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/IcebergArrowColumnVector.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import org.apache.iceberg.arrow.vectorized.NullabilityHolder;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.iceberg.spark.SparkSchemaUtil;\n+import org.apache.parquet.Preconditions;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.sql.vectorized.ColumnarMap;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * Implementation of Spark's {@link ColumnVector} interface. The code for this class is heavily inspired from Spark's\n+ * {@link ArrowColumnVector} The main difference is in how nullability checks are made in this class by relying on\n+ * {@link NullabilityHolder} instead of the validity vector in the Arrow vector.\n+ */\n+public class IcebergArrowColumnVector extends ColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+  private final NullabilityHolder nullabilityHolder;\n+\n+  public IcebergArrowColumnVector(VectorHolder holder) {\n+    super(SparkSchemaUtil.convert(holder.icebergType()));\n+    this.nullabilityHolder = holder.nullabilityHolder();\n+    this.accessor = ArrowVectorAccessors.getVectorAccessor(holder);\n+  }\n+\n+  @Override\n+  public void close() {\n+    accessor.close();\n+  }\n+\n+  @Override\n+  public boolean hasNull() {\n+    return nullabilityHolder.hasNulls();\n+  }\n+\n+  @Override\n+  public int numNulls() {\n+    return nullabilityHolder.numNulls();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nullabilityHolder.isNullAt(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type - byte\");\n+  }\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type - short\");\n+  }\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarArray getArray(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getArray(rowId);\n+  }\n+\n+  @Override\n+  public ColumnarMap getMap(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type - map\");\n+  }\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    if (isNullAt(rowId)) {\n+      return null;\n+    }\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  @Override\n+  public ArrowColumnVector getChild(int ordinal) {\n+    ArrowColumnVector[] childColumns = accessor.childColumns();\n+    Preconditions.checkArgument(childColumns != null && ordinal < childColumns.length, \"Invalid call for getChild() \" +\n+        \"with ordinal \" + ordinal);", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNzI1Mw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410527253", "body": "We need to make sure the extra filter columns are added in the reader and returned to Spark (so Spark expects the projection). This can't return a different set of columns than expected because columns are accessed by ordinal.\r\n\r\nAnother option is to do the `ColumnarBatch` projection here (remove filter columns that have been used), but I would prefer to just return everything to Spark. That simplifies both row and batch read paths.", "bodyText": "We need to make sure the extra filter columns are added in the reader and returned to Spark (so Spark expects the projection). This can't return a different set of columns than expected because columns are accessed by ordinal.\nAnother option is to do the ColumnarBatch projection here (remove filter columns that have been used), but I would prefer to just return everything to Spark. That simplifies both row and batch read paths.", "bodyHTML": "<p dir=\"auto\">We need to make sure the extra filter columns are added in the reader and returned to Spark (so Spark expects the projection). This can't return a different set of columns than expected because columns are accessed by ordinal.</p>\n<p dir=\"auto\">Another option is to do the <code>ColumnarBatch</code> projection here (remove filter columns that have been used), but I would prefer to just return everything to Spark. That simplifies both row and batch read paths.</p>", "author": "rdblue", "createdAt": "2020-04-18T00:48:49Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/BatchDataReader.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.Iterator;\n+import org.apache.iceberg.CombinedScanTask;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.FileScanTask;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.encryption.EncryptionManager;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.io.InputFile;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.spark.SparkSchemaUtil;\n+import org.apache.iceberg.spark.data.vectorized.VectorizedSparkParquetReaders;\n+import org.apache.spark.sql.types.StructType;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n+\n+class BatchDataReader extends BaseDataReader<ColumnarBatch> {\n+  private final Schema tableSchema;\n+  private final Schema expectedSchema;\n+  private final boolean caseSensitive;\n+  private final int batchSize;\n+\n+  BatchDataReader(\n+      CombinedScanTask task, Schema tableSchema, Schema expectedSchema, FileIO fileIo,\n+      EncryptionManager encryptionManager, boolean caseSensitive, int size) {\n+    super(task, fileIo, encryptionManager);\n+    this.tableSchema = tableSchema;\n+    this.expectedSchema = expectedSchema;\n+    this.caseSensitive = caseSensitive;\n+    this.batchSize = size;\n+  }\n+\n+  @Override\n+  Iterator<ColumnarBatch> open(FileScanTask task) {\n+    // schema or rows returned by readers\n+    Schema finalSchema = expectedSchema;\n+    // schema needed for the projection and filtering\n+    StructType sparkType = SparkSchemaUtil.convert(finalSchema);\n+    Schema requiredSchema = SparkSchemaUtil.prune(tableSchema, sparkType, task.residual(), caseSensitive);\n+    boolean hasExtraFilterColumns = requiredSchema.columns().size() != finalSchema.columns().size();\n+    Iterator<ColumnarBatch> iter;\n+    if (hasExtraFilterColumns) {", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4MjU2Nw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r418782567", "bodyText": "Upon looking closer, I think BaseDataReader and RowDataReader classes can be merged. The only difference between BatchDataReader and RowDataReader is how in the former case we don't currently handle identity partition columns. I will spin up a PR for getting that refactoring into master. Once that is in, the only method that we would need to override in BatchDataReader would be Iterator<ColumnarBatch> open(FileScanTask task, Schema readSchema)", "author": "samarthjain", "createdAt": "2020-05-01T23:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNzI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxNzU3Mw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r419717573", "bodyText": "Turns out, I think it makes sense to not merge the two classes. However, a lot of the functionality can be moved to the BaseDataReader class with override for specialized handling of identity partition columns. PR for refactoring - #1000", "author": "samarthjain", "createdAt": "2020-05-04T20:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNzI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MDY3Ng==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r420290676", "bodyText": "I opened #1004 to remove the special handling for extra filter columns. When that's merged, we won't need to handle it. That's what I was talking about with this comment. Can you see how that changes the need for #1000?", "author": "rdblue", "createdAt": "2020-05-05T17:41:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNzI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMyODgzNA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r420328834", "bodyText": "So the idea behind the need for #1000 was to provide only those methods that need to be customized for the two readers. In turn, it would have taken care of the special handling for extra filter columns and other common functionality that would have been introduced in the future.\nI think #1000 is still relevant. It will need to change though if your PR goes in first :)", "author": "samarthjain", "createdAt": "2020-05-05T18:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNzI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyODU3OQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r410528579", "body": "I think this method would be simpler by not exiting early. Something like this:\r\n\r\n```java\r\n  if (enableBatchRead == null) {\r\n    boolean batchReadEnabled = ...;\r\n    boolean allParquetFileScanTasks = ...;\r\n    boolean atLeastOneColumn = lazySchema().columsn().size() > 0;\r\n    boolean hasNoIdentityProjections = ...;\r\n    enableBatchRead = batchReadEnabled && allParquetFileScanTasks && atLeastOneColumn && hasNoIdentityProjections;\r\n  }\r\n  return enableBatchRead;", "bodyText": "I think this method would be simpler by not exiting early. Something like this:\n  if (enableBatchRead == null) {\n    boolean batchReadEnabled = ...;\n    boolean allParquetFileScanTasks = ...;\n    boolean atLeastOneColumn = lazySchema().columsn().size() > 0;\n    boolean hasNoIdentityProjections = ...;\n    enableBatchRead = batchReadEnabled && allParquetFileScanTasks && atLeastOneColumn && hasNoIdentityProjections;\n  }\n  return enableBatchRead;", "bodyHTML": "<p dir=\"auto\">I think this method would be simpler by not exiting early. Something like this:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"  if (enableBatchRead == null) {\n    boolean batchReadEnabled = ...;\n    boolean allParquetFileScanTasks = ...;\n    boolean atLeastOneColumn = lazySchema().columsn().size() &gt; 0;\n    boolean hasNoIdentityProjections = ...;\n    enableBatchRead = batchReadEnabled &amp;&amp; allParquetFileScanTasks &amp;&amp; atLeastOneColumn &amp;&amp; hasNoIdentityProjections;\n  }\n  return enableBatchRead;\n\"><pre>  <span class=\"pl-k\">if</span> (enableBatchRead <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) {\n    <span class=\"pl-k\">boolean</span> batchReadEnabled <span class=\"pl-k\">=</span> <span class=\"pl-c1\">...</span>;\n    <span class=\"pl-k\">boolean</span> allParquetFileScanTasks <span class=\"pl-k\">=</span> <span class=\"pl-c1\">...</span>;\n    <span class=\"pl-k\">boolean</span> atLeastOneColumn <span class=\"pl-k\">=</span> lazySchema()<span class=\"pl-k\">.</span>columsn()<span class=\"pl-k\">.</span>size() <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span>;\n    <span class=\"pl-k\">boolean</span> hasNoIdentityProjections <span class=\"pl-k\">=</span> <span class=\"pl-c1\">...</span>;\n    enableBatchRead <span class=\"pl-k\">=</span> batchReadEnabled <span class=\"pl-k\">&amp;&amp;</span> allParquetFileScanTasks <span class=\"pl-k\">&amp;&amp;</span> atLeastOneColumn <span class=\"pl-k\">&amp;&amp;</span> hasNoIdentityProjections;\n  }\n  <span class=\"pl-k\">return</span> enableBatchRead;</pre></div>", "author": "rdblue", "createdAt": "2020-04-18T00:57:34Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -238,6 +279,46 @@ public Statistics estimateStatistics() {\n     return new Stats(sizeInBytes, numRows);\n   }\n \n+  @Override\n+  public boolean enableBatchRead() {\n+    return lazyCheckEnableBatchRead();\n+  }\n+\n+  private boolean lazyCheckEnableBatchRead() {\n+    if (enableBatchRead == null) {\n+      boolean allParquetFileScanTasks =\n+          tasks().stream()\n+              .allMatch(combinedScanTask -> !combinedScanTask.isDataTask() && combinedScanTask.files()\n+                  .stream()\n+                  .allMatch(fileScanTask -> fileScanTask.file().format().equals(\n+                      FileFormat.PARQUET)));\n+      if (!allParquetFileScanTasks) {\n+        this.enableBatchRead = false;\n+        return false;", "originalCommit": "714c943b3812c8c65309e8161e2801cecafb4dbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1ODA5Ng==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r418758096", "bodyText": "While it makes it cleaner, it is less efficient than exiting early. For ex-\nboolean allParquetFileScanTasks =\n          tasks().stream()\n              .allMatch(combinedScanTask -> !combinedScanTask.isDataTask() && combinedScanTask.files()\n                  .stream()\n                  .allMatch(fileScanTask -> fileScanTask.file().format().equals(\n                      FileFormat.PARQUET)));\n\nThe above is probably a somewhat expensive operation since it is iterating through all the files. We don't want to execute this is batch read has been disabled by config.", "author": "samarthjain", "createdAt": "2020-05-01T22:06:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyODU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTUxOQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r420291519", "bodyText": "Why does this need to be efficient? I think that the primary concern should be readability here because this is executed at planning time and the result is cached.", "author": "rdblue", "createdAt": "2020-05-05T17:42:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyODU3OQ=="}], "type": "inlineReview"}, {"oid": "98da629a6c7b010817c2939c19ac3f715e55d3fe", "url": "https://github.com/apache/iceberg/commit/98da629a6c7b010817c2939c19ac3f715e55d3fe", "message": "Code review comments", "committedDate": "2020-05-07T05:51:13Z", "type": "forcePushed"}, {"oid": "53c920b24e2599ee70a5e9ce96a5a839dcb4753a", "url": "https://github.com/apache/iceberg/commit/53c920b24e2599ee70a5e9ce96a5a839dcb4753a", "message": "Code review comments", "committedDate": "2020-05-07T06:41:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5NTAwNA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r429495004", "body": "This has a warning that it may produce `NullPointerException`. It would be better to initialize `childColumns` to `new ArrowColumnVector[0]` so that this throws an `IndexOutOfBoundsException` instead. That would also avoid needing to check if it is null in close.", "bodyText": "This has a warning that it may produce NullPointerException. It would be better to initialize childColumns to new ArrowColumnVector[0] so that this throws an IndexOutOfBoundsException instead. That would also avoid needing to check if it is null in close.", "bodyHTML": "<p dir=\"auto\">This has a warning that it may produce <code>NullPointerException</code>. It would be better to initialize <code>childColumns</code> to <code>new ArrowColumnVector[0]</code> so that this throws an <code>IndexOutOfBoundsException</code> instead. That would also avoid needing to check if it is null in close.</p>", "author": "rdblue", "createdAt": "2020-05-23T00:15:13Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ArrowVectorAccessor.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+@SuppressWarnings(\"checkstyle:VisibilityModifier\")\n+abstract class ArrowVectorAccessor {\n+\n+  private final ValueVector vector;\n+  private final ArrowColumnVector[] childColumns;\n+\n+  ArrowVectorAccessor(ValueVector vector) {\n+    this.vector = vector;\n+    this.childColumns = null;\n+  }\n+\n+  ArrowVectorAccessor(ValueVector vector, ArrowColumnVector[] children) {\n+    this.vector = vector;\n+    this.childColumns = children;\n+  }\n+\n+  final void close() {\n+    if (childColumns != null) {\n+      for (ArrowColumnVector column : childColumns) {\n+        // Closing an ArrowColumnVector is expected to not throw any exception\n+        column.close();\n+      }\n+    }\n+    vector.close();\n+  }\n+\n+  boolean getBoolean(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type: boolean\");\n+  }\n+\n+  int getInt(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type: int\");\n+  }\n+\n+  long getLong(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type: long\");\n+  }\n+\n+  float getFloat(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type: float\");\n+  }\n+\n+  double getDouble(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type: double\");\n+  }\n+\n+  Decimal getDecimal(int rowId, int precision, int scale) {\n+    throw new UnsupportedOperationException(\"Unsupported type: decimal\");\n+  }\n+\n+  UTF8String getUTF8String(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type: UTF8String\");\n+  }\n+\n+  byte[] getBinary(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type: binary\");\n+  }\n+\n+  ColumnarArray getArray(int rowId) {\n+    throw new UnsupportedOperationException(\"Unsupported type: array\");\n+  }\n+\n+  ArrowColumnVector childColumn(int pos) {\n+    return childColumns[pos];", "originalCommit": "53c920b24e2599ee70a5e9ce96a5a839dcb4753a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5NTQ4MA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r429495480", "body": "This updated `DictionaryDoubleAccessor` to decode into an array, but the other types weren't similarly updated. I think they should be for consistency and so it is clear what's happening.", "bodyText": "This updated DictionaryDoubleAccessor to decode into an array, but the other types weren't similarly updated. I think they should be for consistency and so it is clear what's happening.", "bodyHTML": "<p dir=\"auto\">This updated <code>DictionaryDoubleAccessor</code> to decode into an array, but the other types weren't similarly updated. I think they should be for consistency and so it is clear what's happening.</p>", "author": "rdblue", "createdAt": "2020-05-23T00:19:52Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/ArrowVectorAccessors.java", "diffHunk": "@@ -0,0 +1,505 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import io.netty.buffer.ArrowBuf;\n+import java.math.BigInteger;\n+import java.util.stream.IntStream;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.iceberg.arrow.vectorized.IcebergArrowVectors;\n+import org.apache.iceberg.arrow.vectorized.VectorHolder;\n+import org.apache.parquet.Preconditions;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.column.Dictionary;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.sql.vectorized.ArrowColumnVector;\n+import org.apache.spark.sql.vectorized.ColumnarArray;\n+import org.apache.spark.unsafe.types.UTF8String;\n+import org.jetbrains.annotations.NotNull;\n+\n+public class ArrowVectorAccessors {\n+\n+  private ArrowVectorAccessors() {}\n+\n+  static ArrowVectorAccessor getVectorAccessor(VectorHolder holder) {\n+    Dictionary dictionary = holder.dictionary();\n+    boolean isVectorDictEncoded = holder.isDictionaryEncoded();\n+    ColumnDescriptor desc = holder.descriptor();\n+    FieldVector vector = holder.vector();\n+    PrimitiveType primitive = desc.getPrimitiveType();\n+    if (isVectorDictEncoded) {\n+      return getDictionaryVectorAccessor(dictionary, desc, vector, primitive);\n+    } else {\n+      return getPlainVectorAccessor(vector);\n+    }\n+  }\n+\n+  @NotNull\n+  private static ArrowVectorAccessor getDictionaryVectorAccessor(\n+      Dictionary dictionary,\n+      ColumnDescriptor desc,\n+      FieldVector vector, PrimitiveType primitive) {\n+    Preconditions.checkState(vector instanceof IntVector, \"Dictionary ids should be stored in IntVectors only\");\n+    if (primitive.getOriginalType() != null) {\n+      switch (desc.getPrimitiveType().getOriginalType()) {\n+        case ENUM:\n+        case JSON:\n+        case UTF8:\n+        case BSON:\n+          return new DictionaryStringAccessor((IntVector) vector, dictionary);\n+        case INT_64:\n+        case TIMESTAMP_MILLIS:\n+        case TIMESTAMP_MICROS:\n+          return new DictionaryLongAccessor((IntVector) vector, dictionary);\n+        case DECIMAL:\n+          switch (primitive.getPrimitiveTypeName()) {\n+            case BINARY:\n+            case FIXED_LEN_BYTE_ARRAY:\n+              return new DictionaryDecimalBinaryAccessor(\n+                  (IntVector) vector,\n+                  dictionary);\n+            case INT64:\n+              return new DictionaryDecimalLongAccessor(\n+                  (IntVector) vector,\n+                  dictionary);\n+            case INT32:\n+              return new DictionaryDecimalIntAccessor(\n+                  (IntVector) vector,\n+                  dictionary);\n+            default:\n+              throw new UnsupportedOperationException(\n+                  \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n+          }\n+        default:\n+          throw new UnsupportedOperationException(\n+              \"Unsupported logical type: \" + primitive.getOriginalType());\n+      }\n+    } else {\n+      switch (primitive.getPrimitiveTypeName()) {\n+        case FIXED_LEN_BYTE_ARRAY:\n+        case BINARY:\n+          return new DictionaryBinaryAccessor((IntVector) vector, dictionary);\n+        case FLOAT:\n+          return new DictionaryFloatAccessor((IntVector) vector, dictionary);\n+        case INT64:\n+          return new DictionaryLongAccessor((IntVector) vector, dictionary);\n+        case DOUBLE:\n+          return new DictionaryDoubleAccessor((IntVector) vector, dictionary);\n+        default:\n+          throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n+      }\n+    }\n+  }\n+\n+  @NotNull\n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+  private static ArrowVectorAccessor getPlainVectorAccessor(FieldVector vector) {\n+    if (vector instanceof BitVector) {\n+      return new BooleanAccessor((BitVector) vector);\n+    } else if (vector instanceof IntVector) {\n+      return new IntAccessor((IntVector) vector);\n+    } else if (vector instanceof BigIntVector) {\n+      return new LongAccessor((BigIntVector) vector);\n+    } else if (vector instanceof Float4Vector) {\n+      return new FloatAccessor((Float4Vector) vector);\n+    } else if (vector instanceof Float8Vector) {\n+      return new DoubleAccessor((Float8Vector) vector);\n+    } else if (vector instanceof IcebergArrowVectors.DecimalArrowVector) {\n+      return new DecimalAccessor((IcebergArrowVectors.DecimalArrowVector) vector);\n+    } else if (vector instanceof IcebergArrowVectors.VarcharArrowVector) {\n+      return new StringAccessor((IcebergArrowVectors.VarcharArrowVector) vector);\n+    } else if (vector instanceof IcebergArrowVectors.VarBinaryArrowVector) {\n+      return new BinaryAccessor((IcebergArrowVectors.VarBinaryArrowVector) vector);\n+    } else if (vector instanceof DateDayVector) {\n+      return new DateAccessor((DateDayVector) vector);\n+    } else if (vector instanceof TimeStampMicroTZVector) {\n+      return new TimestampAccessor((TimeStampMicroTZVector) vector);\n+    } else if (vector instanceof ListVector) {\n+      ListVector listVector = (ListVector) vector;\n+      return new ArrayAccessor(listVector);\n+    } else if (vector instanceof StructVector) {\n+      StructVector structVector = (StructVector) vector;\n+      return new StructAccessor(structVector);\n+    }\n+    throw new UnsupportedOperationException(\"Unsupported vector: \" + vector.getClass());\n+  }\n+\n+  private static class BooleanAccessor extends ArrowVectorAccessor {\n+\n+    private final BitVector vector;\n+\n+    BooleanAccessor(BitVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final boolean getBoolean(int rowId) {\n+      return vector.get(rowId) == 1;\n+    }\n+  }\n+\n+  private static class IntAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector vector;\n+\n+    IntAccessor(IntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class LongAccessor extends ArrowVectorAccessor {\n+\n+    private final BigIntVector vector;\n+\n+    LongAccessor(BigIntVector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class DictionaryLongAccessor extends ArrowVectorAccessor {\n+\n+    private final Dictionary parquetDictionary;\n+    private final IntVector offsetVector;\n+\n+    DictionaryLongAccessor(IntVector vector, Dictionary dictionary) {\n+      super(vector);\n+      this.offsetVector = vector;\n+      this.parquetDictionary = dictionary;\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return parquetDictionary.decodeToLong(offsetVector.get(rowId));\n+    }\n+  }\n+\n+  private static class FloatAccessor extends ArrowVectorAccessor {\n+\n+    private final Float4Vector vector;\n+\n+    FloatAccessor(Float4Vector vector) {\n+      super(vector);\n+      this.vector = vector;\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return vector.get(rowId);\n+    }\n+  }\n+\n+  private static class DictionaryFloatAccessor extends ArrowVectorAccessor {\n+\n+    private final IntVector offsetVector;\n+    private final Dictionary parquetDictionary;", "originalCommit": "53c920b24e2599ee70a5e9ce96a5a839dcb4753a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5Njc1Mw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r429496753", "body": "Is this needed since you've updated build.gradle?", "bodyText": "Is this needed since you've updated build.gradle?", "bodyHTML": "<p dir=\"auto\">Is this needed since you've updated build.gradle?</p>", "author": "rdblue", "createdAt": "2020-05-23T00:31:13Z", "path": "spark/src/test/java/org/apache/iceberg/spark/source/TestReadProjection.java", "diffHunk": "@@ -54,6 +56,11 @@ protected abstract Record writeAndRead(String desc,\n   @Rule\n   public TemporaryFolder temp = new TemporaryFolder();\n \n+  @BeforeClass\n+  public static void beforeClass() {", "originalCommit": "53c920b24e2599ee70a5e9ce96a5a839dcb4753a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5NzgxOQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r429497819", "body": "This is missing the type parameter for `VectorizedReader`.", "bodyText": "This is missing the type parameter for VectorizedReader.", "bodyHTML": "<p dir=\"auto\">This is missing the type parameter for <code>VectorizedReader</code>.</p>", "author": "rdblue", "createdAt": "2020-05-23T00:41:53Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/VectorizedSparkParquetReaders.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.IntStream;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.NullCheckingForGet;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.arrow.ArrowAllocation;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.TypeWithSchemaVisitor;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.iceberg.types.Types;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.schema.GroupType;\n+import org.apache.parquet.schema.MessageType;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.parquet.schema.Type;\n+\n+public class VectorizedSparkParquetReaders {\n+\n+  private VectorizedSparkParquetReaders() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static ColumnarBatchReader buildReader(\n+      Schema expectedSchema,\n+      MessageType fileSchema,\n+      Integer recordsPerBatch) {\n+    return (ColumnarBatchReader)\n+        TypeWithSchemaVisitor.visit(expectedSchema.asStruct(), fileSchema,\n+            new VectorizedReaderBuilder(expectedSchema, fileSchema, recordsPerBatch));\n+  }\n+\n+  private static class VectorizedReaderBuilder extends TypeWithSchemaVisitor<VectorizedReader<?>> {\n+    private final MessageType parquetSchema;\n+    private final Schema icebergSchema;\n+    private final BufferAllocator rootAllocator;\n+    private final int batchSize;\n+\n+    VectorizedReaderBuilder(\n+        Schema expectedSchema,\n+        MessageType parquetSchema,\n+        int bSize) {\n+      this.parquetSchema = parquetSchema;\n+      this.icebergSchema = expectedSchema;\n+      this.batchSize = bSize;\n+      this.rootAllocator = ArrowAllocation.rootAllocator()\n+          .newChildAllocator(\"VectorizedReadBuilder\", 0, Long.MAX_VALUE);\n+    }\n+\n+    @Override\n+    public VectorizedReader message(", "originalCommit": "53c920b24e2599ee70a5e9ce96a5a839dcb4753a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5Nzg4Mg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r429497882", "body": "IntelliJ is telling me that this isn't needed?", "bodyText": "IntelliJ is telling me that this isn't needed?", "bodyHTML": "<p dir=\"auto\">IntelliJ is telling me that this isn't needed?</p>", "author": "rdblue", "createdAt": "2020-05-23T00:42:31Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/VectorizedSparkParquetReaders.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.IntStream;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.NullCheckingForGet;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.arrow.ArrowAllocation;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.TypeWithSchemaVisitor;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.iceberg.types.Types;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.schema.GroupType;\n+import org.apache.parquet.schema.MessageType;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.parquet.schema.Type;\n+\n+public class VectorizedSparkParquetReaders {\n+\n+  private VectorizedSparkParquetReaders() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")", "originalCommit": "53c920b24e2599ee70a5e9ce96a5a839dcb4753a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5ODA2Mg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r429498062", "body": "Now that #1004 is in, this can be removed. Now, we guarantee that the expected schema has all of the necessary columns. No need to create `requiredSchema` and handle it differently.", "bodyText": "Now that #1004 is in, this can be removed. Now, we guarantee that the expected schema has all of the necessary columns. No need to create requiredSchema and handle it differently.", "bodyHTML": "<p dir=\"auto\">Now that <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"612761270\" data-permission-text=\"Title is private\" data-url=\"https://github.com/apache/iceberg/issues/1004\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/apache/iceberg/pull/1004/hovercard\" href=\"https://github.com/apache/iceberg/pull/1004\">#1004</a> is in, this can be removed. Now, we guarantee that the expected schema has all of the necessary columns. No need to create <code>requiredSchema</code> and handle it differently.</p>", "author": "rdblue", "createdAt": "2020-05-23T00:44:32Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/BatchDataReader.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.Iterator;\n+import org.apache.iceberg.CombinedScanTask;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.FileScanTask;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.encryption.EncryptionManager;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.io.InputFile;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.spark.SparkSchemaUtil;\n+import org.apache.iceberg.spark.data.vectorized.VectorizedSparkParquetReaders;\n+import org.apache.spark.sql.types.StructType;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n+\n+class BatchDataReader extends BaseDataReader<ColumnarBatch> {\n+  private final Schema tableSchema;\n+  private final Schema expectedSchema;\n+  private final boolean caseSensitive;\n+  private final int batchSize;\n+\n+  BatchDataReader(\n+      CombinedScanTask task, Schema tableSchema, Schema expectedSchema, FileIO fileIo,\n+      EncryptionManager encryptionManager, boolean caseSensitive, int size) {\n+    super(task, fileIo, encryptionManager);\n+    this.tableSchema = tableSchema;\n+    this.expectedSchema = expectedSchema;\n+    this.caseSensitive = caseSensitive;\n+    this.batchSize = size;\n+  }\n+\n+  @Override\n+  Iterator<ColumnarBatch> open(FileScanTask task) {\n+    // schema or rows returned by readers\n+    Schema finalSchema = expectedSchema;\n+    // schema needed for the projection and filtering\n+    StructType sparkType = SparkSchemaUtil.convert(finalSchema);\n+    Schema requiredSchema = SparkSchemaUtil.prune(tableSchema, sparkType, task.residual(), caseSensitive);\n+    boolean hasExtraFilterColumns = requiredSchema.columns().size() != finalSchema.columns().size();", "originalCommit": "53c920b24e2599ee70a5e9ce96a5a839dcb4753a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "65700df38f4763edfb8e7bdd30013aec413a65c5", "url": "https://github.com/apache/iceberg/commit/65700df38f4763edfb8e7bdd30013aec413a65c5", "message": "Code review comments", "committedDate": "2020-05-26T23:44:12Z", "type": "forcePushed"}, {"oid": "032c8c12c972614ee5514b7c586021331c8bf002", "url": "https://github.com/apache/iceberg/commit/032c8c12c972614ee5514b7c586021331c8bf002", "message": "Code review comments", "committedDate": "2020-05-27T00:12:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg0MDkwMQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434840901", "body": "This method isn't used, and the main difference between it and `assertArrowVectors` is that the other one asserts that each vector is an `IcebergArrowColumnVector`, which I don't think is actually necessary. Is there a reason to require a specific type instead of just validating the data in each row?\r\n\r\nAlso, since the `ColumnarBatch` provides access to an `InternalRow` that is already supported, I was able to use the existing `assertEqualsUnsafe(StructType, Record, InternalRow)` in a loop, like this:\r\n\r\n```java\r\n  public static void assertEqualsBatch(Types.StructType struct, List<Record> expected, ColumnarBatch batch) {\r\n    for (int r = 0; r < batch.numRows(); r++) {\r\n      assertEqualsUnsafe(struct, expected.get(r), batch.getRow(r));\r\n    }\r\n  }\r\n```\r\n\r\nThat required fixing null handling in `assertEqualsUnsafe`, which wasn't calling `isNullAt`, but once that was updated everything works without these two fairly large methods. I'd prefer to move to using `assertEqualsBatch` instead unless you think that introduces a problem.", "bodyText": "This method isn't used, and the main difference between it and assertArrowVectors is that the other one asserts that each vector is an IcebergArrowColumnVector, which I don't think is actually necessary. Is there a reason to require a specific type instead of just validating the data in each row?\nAlso, since the ColumnarBatch provides access to an InternalRow that is already supported, I was able to use the existing assertEqualsUnsafe(StructType, Record, InternalRow) in a loop, like this:\n  public static void assertEqualsBatch(Types.StructType struct, List<Record> expected, ColumnarBatch batch) {\n    for (int r = 0; r < batch.numRows(); r++) {\n      assertEqualsUnsafe(struct, expected.get(r), batch.getRow(r));\n    }\n  }\nThat required fixing null handling in assertEqualsUnsafe, which wasn't calling isNullAt, but once that was updated everything works without these two fairly large methods. I'd prefer to move to using assertEqualsBatch instead unless you think that introduces a problem.", "bodyHTML": "<p dir=\"auto\">This method isn't used, and the main difference between it and <code>assertArrowVectors</code> is that the other one asserts that each vector is an <code>IcebergArrowColumnVector</code>, which I don't think is actually necessary. Is there a reason to require a specific type instead of just validating the data in each row?</p>\n<p dir=\"auto\">Also, since the <code>ColumnarBatch</code> provides access to an <code>InternalRow</code> that is already supported, I was able to use the existing <code>assertEqualsUnsafe(StructType, Record, InternalRow)</code> in a loop, like this:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"  public static void assertEqualsBatch(Types.StructType struct, List&lt;Record&gt; expected, ColumnarBatch batch) {\n    for (int r = 0; r &lt; batch.numRows(); r++) {\n      assertEqualsUnsafe(struct, expected.get(r), batch.getRow(r));\n    }\n  }\n\"><pre>  <span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">void</span> assertEqualsBatch(<span class=\"pl-smi\">Types</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">StructType</span> struct, <span class=\"pl-k\">List&lt;<span class=\"pl-smi\">Record</span>&gt;</span> expected, <span class=\"pl-smi\">ColumnarBatch</span> batch) {\n    <span class=\"pl-k\">for</span> (<span class=\"pl-k\">int</span> r <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>; r <span class=\"pl-k\">&lt;</span> batch<span class=\"pl-k\">.</span>numRows(); r<span class=\"pl-k\">++</span>) {\n      assertEqualsUnsafe(struct, expected<span class=\"pl-k\">.</span>get(r), batch<span class=\"pl-k\">.</span>getRow(r));\n    }\n  }</pre></div>\n<p dir=\"auto\">That required fixing null handling in <code>assertEqualsUnsafe</code>, which wasn't calling <code>isNullAt</code>, but once that was updated everything works without these two fairly large methods. I'd prefer to move to using <code>assertEqualsBatch</code> instead unless you think that introduces a problem.</p>", "author": "rdblue", "createdAt": "2020-06-03T20:41:40Z", "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestHelpers.java", "diffHunk": "@@ -78,6 +81,48 @@ public static void assertEqualsSafe(Types.StructType struct, Record rec, Row row\n     }\n   }\n \n+  public static void assertEqualsUnsafe(Types.StructType struct, List<Record> expected, ColumnarBatch batch) {", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxODE1MQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434918151", "bodyText": "Fixed in my PR.", "author": "rdblue", "createdAt": "2020-06-03T23:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg0MDkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg0MjIwOQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434842209", "body": "Can we use `Arrays.fill` instead of leaving some bytes uninitialized?", "bodyText": "Can we use Arrays.fill instead of leaving some bytes uninitialized?", "bodyHTML": "<p dir=\"auto\">Can we use <code>Arrays.fill</code> instead of leaving some bytes uninitialized?</p>", "author": "rdblue", "createdAt": "2020-06-03T20:44:22Z", "path": "spark/src/test/java/org/apache/iceberg/spark/data/RandomData.java", "diffHunk": "@@ -442,4 +474,226 @@ private static BigInteger randomUnscaled(int precision, Random random) {\n \n     return new BigInteger(sb.toString());\n   }\n+\n+  private static class DictionaryEncodedDataGenerator extends RandomDataGenerator {\n+\n+    private DictionaryEncodedDataGenerator(Schema schema, long seed) {\n+      super(schema, seed);\n+    }\n+\n+    @Override\n+    public Object primitive(Type.PrimitiveType primitive) {\n+      Object result = generateDictionaryEncodablePrimitive(primitive, random);\n+      return super.getPrimitive(primitive, result);\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    private static Object generateDictionaryEncodablePrimitive(Type.PrimitiveType primitive, Random random) {\n+      // 3 choices\n+      int choice = random.nextInt(3);\n+      switch (primitive.typeId()) {\n+        case BOOLEAN:\n+          return true; // doesn't really matter for booleans since they are not dictionary encoded\n+\n+        case INTEGER:\n+          switch (choice) {\n+            case 0:\n+              return 0;\n+            case 1:\n+              return 1;\n+            case 2:\n+              return 2;\n+          }\n+\n+        case LONG:\n+          switch (choice) {\n+            case 0:\n+              return 0L;\n+            case 1:\n+              return 1L;\n+            case 2:\n+              return 2L;\n+          }\n+\n+        case FLOAT:\n+          switch (choice) {\n+            case 0:\n+              return 0.0f;\n+            case 1:\n+              return 1.0f;\n+            case 2:\n+              return 2.0f;\n+          }\n+\n+        case DOUBLE:\n+          switch (choice) {\n+            case 0:\n+              return 0.0d;\n+            case 1:\n+              return 1.0d;\n+            case 2:\n+              return 2.0d;\n+          }\n+\n+        case DATE:\n+          switch (choice) {\n+            case 0:\n+              return 0;\n+            case 1:\n+              return 1;\n+            case 2:\n+              return 2;\n+          }\n+\n+        case TIME:\n+          switch (choice) {\n+            case 0:\n+              return 0L;\n+            case 1:\n+              return 1L;\n+            case 2:\n+              return 2L;\n+          }\n+\n+        case TIMESTAMP:\n+          switch (choice) {\n+            case 0:\n+              return 0L;\n+            case 1:\n+              return 1L;\n+            case 2:\n+              return 2L;\n+          }\n+\n+        case STRING:\n+          switch (choice) {\n+            case 0:\n+              return UTF8String.fromString(\"0\");\n+            case 1:\n+              return UTF8String.fromString(\"1\");\n+            case 2:\n+              return UTF8String.fromString(\"2\");\n+          }\n+\n+        case FIXED:\n+          byte[] fixed = new byte[((Types.FixedType) primitive).length()];\n+          switch (choice) {\n+            case 0:\n+              fixed[0] = 0;", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg1MTY1MQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434851651", "body": "I think the way that this extends the base class is awkward. It overrides primitive, but then needs to call `getPrimitive`. What `getPrimitive` is doing is not obvious in the child class, and the `Random` variable needs to be directly accessible causing the need to override checkstyle.\r\n\r\nInstead, the base class should add a method to generate a value for a primitive, like `randomValue` and pass a `Random` into it. Then `random` can stay `private` and we don't need to override checkstyle. Also, the conversion only needs to happen in one place, the implementation of `primitive`.\r\n\r\n```java\r\n\r\n    @Override\r\n    public Object primitive(Type.PrimitiveType primitive) {\r\n      Object result = randomValue(primitive, random);\r\n      // For the primitives that Avro needs a different type than Spark, fix\r\n      // them here.\r\n      switch (primitive.typeId()) {\r\n        ...\r\n      }\r\n    }\r\n\r\n    protected Object randomValue(Type.PrimitiveType primitive, Random rand) {\r\n      return generatePrimitive(primitive, rand);\r\n    }\r\n```", "bodyText": "I think the way that this extends the base class is awkward. It overrides primitive, but then needs to call getPrimitive. What getPrimitive is doing is not obvious in the child class, and the Random variable needs to be directly accessible causing the need to override checkstyle.\nInstead, the base class should add a method to generate a value for a primitive, like randomValue and pass a Random into it. Then random can stay private and we don't need to override checkstyle. Also, the conversion only needs to happen in one place, the implementation of primitive.\n    @Override\n    public Object primitive(Type.PrimitiveType primitive) {\n      Object result = randomValue(primitive, random);\n      // For the primitives that Avro needs a different type than Spark, fix\n      // them here.\n      switch (primitive.typeId()) {\n        ...\n      }\n    }\n\n    protected Object randomValue(Type.PrimitiveType primitive, Random rand) {\n      return generatePrimitive(primitive, rand);\n    }", "bodyHTML": "<p dir=\"auto\">I think the way that this extends the base class is awkward. It overrides primitive, but then needs to call <code>getPrimitive</code>. What <code>getPrimitive</code> is doing is not obvious in the child class, and the <code>Random</code> variable needs to be directly accessible causing the need to override checkstyle.</p>\n<p dir=\"auto\">Instead, the base class should add a method to generate a value for a primitive, like <code>randomValue</code> and pass a <code>Random</code> into it. Then <code>random</code> can stay <code>private</code> and we don't need to override checkstyle. Also, the conversion only needs to happen in one place, the implementation of <code>primitive</code>.</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n    @Override\n    public Object primitive(Type.PrimitiveType primitive) {\n      Object result = randomValue(primitive, random);\n      // For the primitives that Avro needs a different type than Spark, fix\n      // them here.\n      switch (primitive.typeId()) {\n        ...\n      }\n    }\n\n    protected Object randomValue(Type.PrimitiveType primitive, Random rand) {\n      return generatePrimitive(primitive, rand);\n    }\n\"><pre>    <span class=\"pl-k\">@Override</span>\n    <span class=\"pl-k\">public</span> <span class=\"pl-smi\">Object</span> primitive(<span class=\"pl-smi\">Type</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">PrimitiveType</span> primitive) {\n      <span class=\"pl-smi\">Object</span> result <span class=\"pl-k\">=</span> randomValue(primitive, random);\n      <span class=\"pl-c\"><span class=\"pl-c\">//</span> For the primitives that Avro needs a different type than Spark, fix</span>\n      <span class=\"pl-c\"><span class=\"pl-c\">//</span> them here.</span>\n      <span class=\"pl-k\">switch</span> (primitive<span class=\"pl-k\">.</span>typeId()) {\n        <span class=\"pl-c1\">...</span>\n      }\n    }\n\n    <span class=\"pl-k\">protected</span> <span class=\"pl-smi\">Object</span> randomValue(<span class=\"pl-smi\">Type</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">PrimitiveType</span> primitive, <span class=\"pl-smi\">Random</span> rand) {\n      <span class=\"pl-k\">return</span> generatePrimitive(primitive, rand);\n    }</pre></div>", "author": "rdblue", "createdAt": "2020-06-03T21:01:05Z", "path": "spark/src/test/java/org/apache/iceberg/spark/data/RandomData.java", "diffHunk": "@@ -442,4 +474,226 @@ private static BigInteger randomUnscaled(int precision, Random random) {\n \n     return new BigInteger(sb.toString());\n   }\n+\n+  private static class DictionaryEncodedDataGenerator extends RandomDataGenerator {", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxODA4OQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434918089", "bodyText": "Included in my PR.", "author": "rdblue", "createdAt": "2020-06-03T23:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg1MTY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg1NDAwOA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434854008", "body": "This implementation seems over-complicated with a lot of unnecessary `switch` statements. I think checkstyle was right.\r\n\r\nI think you can simplify most of the implementations for types by just converting the choice variable (maybe name it better?)\r\n\r\n```java\r\n    @Override\r\n    protected Object randomValue(Type.PrimitiveType primitive, Random random) {\r\n      // 3 choices\r\n      int choice = random.nextInt(3);\r\n      switch (primitive.typeId()) {\r\n        case BOOLEAN:\r\n          return true; // doesn't really matter for booleans since they are not dictionary encoded\r\n        case INTEGER:\r\n        case DATE:\r\n          return choice;\r\n        case FLOAT:\r\n          return (float) choice;\r\n        case DOUBLE:\r\n          return (double) choice;\r\n        case LONG:\r\n        case TIME:\r\n        case TIMESTAMP:\r\n          return (long) choice;\r\n        case STRING:\r\n          return UTF8String.fromString(String.valueOf(choice));\r\n        case FIXED:\r\n          byte[] fixed = new byte[((Types.FixedType) primitive).length()];\r\n          Arrays.fill(fixed, (byte) choice);\r\n          return fixed;\r\n        case BINARY:\r\n          byte[] binary = new byte[choice + 1];\r\n          Arrays.fill(binary, (byte) choice);\r\n          return binary;\r\n        case DECIMAL:\r\n          Types.DecimalType type = (Types.DecimalType) primitive;\r\n          BigInteger unscaled = new BigInteger(String.valueOf(choice + 1));\r\n          return Decimal.apply(new BigDecimal(unscaled, type.scale()));\r\n        default:\r\n          throw new IllegalArgumentException(\r\n              \"Cannot generate random value for unknown type: \" + primitive);\r\n      }\r\n    }\r\n```\r\n\r\nThis also uses `Arrays.fill` like I suggested below and updates binary to test different lengths.", "bodyText": "This implementation seems over-complicated with a lot of unnecessary switch statements. I think checkstyle was right.\nI think you can simplify most of the implementations for types by just converting the choice variable (maybe name it better?)\n    @Override\n    protected Object randomValue(Type.PrimitiveType primitive, Random random) {\n      // 3 choices\n      int choice = random.nextInt(3);\n      switch (primitive.typeId()) {\n        case BOOLEAN:\n          return true; // doesn't really matter for booleans since they are not dictionary encoded\n        case INTEGER:\n        case DATE:\n          return choice;\n        case FLOAT:\n          return (float) choice;\n        case DOUBLE:\n          return (double) choice;\n        case LONG:\n        case TIME:\n        case TIMESTAMP:\n          return (long) choice;\n        case STRING:\n          return UTF8String.fromString(String.valueOf(choice));\n        case FIXED:\n          byte[] fixed = new byte[((Types.FixedType) primitive).length()];\n          Arrays.fill(fixed, (byte) choice);\n          return fixed;\n        case BINARY:\n          byte[] binary = new byte[choice + 1];\n          Arrays.fill(binary, (byte) choice);\n          return binary;\n        case DECIMAL:\n          Types.DecimalType type = (Types.DecimalType) primitive;\n          BigInteger unscaled = new BigInteger(String.valueOf(choice + 1));\n          return Decimal.apply(new BigDecimal(unscaled, type.scale()));\n        default:\n          throw new IllegalArgumentException(\n              \"Cannot generate random value for unknown type: \" + primitive);\n      }\n    }\nThis also uses Arrays.fill like I suggested below and updates binary to test different lengths.", "bodyHTML": "<p dir=\"auto\">This implementation seems over-complicated with a lot of unnecessary <code>switch</code> statements. I think checkstyle was right.</p>\n<p dir=\"auto\">I think you can simplify most of the implementations for types by just converting the choice variable (maybe name it better?)</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"    @Override\n    protected Object randomValue(Type.PrimitiveType primitive, Random random) {\n      // 3 choices\n      int choice = random.nextInt(3);\n      switch (primitive.typeId()) {\n        case BOOLEAN:\n          return true; // doesn't really matter for booleans since they are not dictionary encoded\n        case INTEGER:\n        case DATE:\n          return choice;\n        case FLOAT:\n          return (float) choice;\n        case DOUBLE:\n          return (double) choice;\n        case LONG:\n        case TIME:\n        case TIMESTAMP:\n          return (long) choice;\n        case STRING:\n          return UTF8String.fromString(String.valueOf(choice));\n        case FIXED:\n          byte[] fixed = new byte[((Types.FixedType) primitive).length()];\n          Arrays.fill(fixed, (byte) choice);\n          return fixed;\n        case BINARY:\n          byte[] binary = new byte[choice + 1];\n          Arrays.fill(binary, (byte) choice);\n          return binary;\n        case DECIMAL:\n          Types.DecimalType type = (Types.DecimalType) primitive;\n          BigInteger unscaled = new BigInteger(String.valueOf(choice + 1));\n          return Decimal.apply(new BigDecimal(unscaled, type.scale()));\n        default:\n          throw new IllegalArgumentException(\n              &quot;Cannot generate random value for unknown type: &quot; + primitive);\n      }\n    }\n\"><pre>    <span class=\"pl-k\">@Override</span>\n    <span class=\"pl-k\">protected</span> <span class=\"pl-smi\">Object</span> randomValue(<span class=\"pl-smi\">Type</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">PrimitiveType</span> primitive, <span class=\"pl-smi\">Random</span> random) {\n      <span class=\"pl-c\"><span class=\"pl-c\">//</span> 3 choices</span>\n      <span class=\"pl-k\">int</span> choice <span class=\"pl-k\">=</span> random<span class=\"pl-k\">.</span>nextInt(<span class=\"pl-c1\">3</span>);\n      <span class=\"pl-k\">switch</span> (primitive<span class=\"pl-k\">.</span>typeId()) {\n        <span class=\"pl-k\">case</span> <span class=\"pl-c1\">BOOLEAN</span><span class=\"pl-k\">:</span>\n          <span class=\"pl-k\">return</span> <span class=\"pl-c1\">true</span>; <span class=\"pl-c\"><span class=\"pl-c\">//</span> doesn't really matter for booleans since they are not dictionary encoded</span>\n        <span class=\"pl-k\">case</span> <span class=\"pl-c1\">INTEGER</span><span class=\"pl-k\">:</span>\n        <span class=\"pl-k\">case</span> <span class=\"pl-c1\">DATE</span><span class=\"pl-k\">:</span>\n          <span class=\"pl-k\">return</span> choice;\n        <span class=\"pl-k\">case</span> <span class=\"pl-c1\">FLOAT</span><span class=\"pl-k\">:</span>\n          <span class=\"pl-k\">return</span> (<span class=\"pl-k\">float</span>) choice;\n        <span class=\"pl-k\">case</span> <span class=\"pl-c1\">DOUBLE</span><span class=\"pl-k\">:</span>\n          <span class=\"pl-k\">return</span> (<span class=\"pl-k\">double</span>) choice;\n        <span class=\"pl-k\">case</span> <span class=\"pl-c1\">LONG</span><span class=\"pl-k\">:</span>\n        <span class=\"pl-k\">case</span> <span class=\"pl-c1\">TIME</span><span class=\"pl-k\">:</span>\n        <span class=\"pl-k\">case</span> <span class=\"pl-c1\">TIMESTAMP</span><span class=\"pl-k\">:</span>\n          <span class=\"pl-k\">return</span> (<span class=\"pl-k\">long</span>) choice;\n        <span class=\"pl-k\">case</span> <span class=\"pl-c1\">STRING</span><span class=\"pl-k\">:</span>\n          <span class=\"pl-k\">return</span> <span class=\"pl-smi\">UTF8String</span><span class=\"pl-k\">.</span>fromString(<span class=\"pl-smi\">String</span><span class=\"pl-k\">.</span>valueOf(choice));\n        <span class=\"pl-k\">case</span> <span class=\"pl-c1\">FIXED</span><span class=\"pl-k\">:</span>\n          <span class=\"pl-k\">byte</span>[] fixed <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">byte</span>[((<span class=\"pl-smi\">Types</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">FixedType</span>) primitive)<span class=\"pl-k\">.</span>length()];\n          <span class=\"pl-smi\">Arrays</span><span class=\"pl-k\">.</span>fill(fixed, (<span class=\"pl-k\">byte</span>) choice);\n          <span class=\"pl-k\">return</span> fixed;\n        <span class=\"pl-k\">case</span> <span class=\"pl-c1\">BINARY</span><span class=\"pl-k\">:</span>\n          <span class=\"pl-k\">byte</span>[] binary <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">byte</span>[choice <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>];\n          <span class=\"pl-smi\">Arrays</span><span class=\"pl-k\">.</span>fill(binary, (<span class=\"pl-k\">byte</span>) choice);\n          <span class=\"pl-k\">return</span> binary;\n        <span class=\"pl-k\">case</span> <span class=\"pl-c1\">DECIMAL</span><span class=\"pl-k\">:</span>\n          <span class=\"pl-smi\">Types</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">DecimalType</span> type <span class=\"pl-k\">=</span> (<span class=\"pl-smi\">Types</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">DecimalType</span>) primitive;\n          <span class=\"pl-smi\">BigInteger</span> unscaled <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">BigInteger</span>(<span class=\"pl-smi\">String</span><span class=\"pl-k\">.</span>valueOf(choice <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>));\n          <span class=\"pl-k\">return</span> <span class=\"pl-smi\">Decimal</span><span class=\"pl-k\">.</span>apply(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">BigDecimal</span>(unscaled, type<span class=\"pl-k\">.</span>scale()));\n        <span class=\"pl-k\">default</span><span class=\"pl-k\">:</span>\n          <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">IllegalArgumentException</span>(\n              <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Cannot generate random value for unknown type: <span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> primitive);\n      }\n    }</pre></div>\n<p dir=\"auto\">This also uses <code>Arrays.fill</code> like I suggested below and updates binary to test different lengths.</p>", "author": "rdblue", "createdAt": "2020-06-03T21:04:02Z", "path": "spark/src/test/java/org/apache/iceberg/spark/data/RandomData.java", "diffHunk": "@@ -442,4 +474,226 @@ private static BigInteger randomUnscaled(int precision, Random random) {\n \n     return new BigInteger(sb.toString());\n   }\n+\n+  private static class DictionaryEncodedDataGenerator extends RandomDataGenerator {\n+\n+    private DictionaryEncodedDataGenerator(Schema schema, long seed) {\n+      super(schema, seed);\n+    }\n+\n+    @Override\n+    public Object primitive(Type.PrimitiveType primitive) {\n+      Object result = generateDictionaryEncodablePrimitive(primitive, random);\n+      return super.getPrimitive(primitive, result);\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxODA0NA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434918044", "bodyText": "Included in my PR.", "author": "rdblue", "createdAt": "2020-06-03T23:52:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg1NDAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg2MDY5Mg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434860692", "body": "I think it would be easier to understand if this were a combination of the normal generator and the dictionary-encoded generator and used just some number of records before falling back. Then you would only need the two existing ways to generate primitives. Something like this, where `generateDictionaryEncodablePrimitive()` is what I pasted for `DictionaryEncodedDataGenerator` above:\r\n\r\n```java\r\n  private static class DictionaryEncodedDataGenerator extends RandomDataGenerator {\r\n    private DictionaryEncodedDataGenerator(Schema schema, long seed) {\r\n      super(schema, seed);\r\n    }\r\n\r\n    @Override\r\n    protected Object randomValue(Type.PrimitiveType primitive, Random random) {\r\n      return generateDictionaryEncodablePrimitive(primitive, random);\r\n    }\r\n  }\r\n\r\n  private static class FallbackDataGenerator extends RandomDataGenerator {\r\n    private final long dictionaryEncodedRows;\r\n    private long rowCount = 0;\r\n\r\n    private FallbackDataGenerator(Schema schema, long seed, long numDictionaryEncoded) {\r\n      super(schema, seed);\r\n      this.dictionaryEncodedRows = numDictionaryEncoded;\r\n    }\r\n\r\n    @Override\r\n    protected Object randomValue(Type.PrimitiveType primitive, Random rand) {\r\n      this.rowCount += 1;\r\n      if (rowCount > dictionaryEncodedRows) {\r\n        return generatePrimitive(primitive, rand);\r\n      } else {\r\n        return generateDictionaryEncodablePrimitive(primitive, rand);\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\n", "bodyText": "I think it would be easier to understand if this were a combination of the normal generator and the dictionary-encoded generator and used just some number of records before falling back. Then you would only need the two existing ways to generate primitives. Something like this, where generateDictionaryEncodablePrimitive() is what I pasted for DictionaryEncodedDataGenerator above:\n  private static class DictionaryEncodedDataGenerator extends RandomDataGenerator {\n    private DictionaryEncodedDataGenerator(Schema schema, long seed) {\n      super(schema, seed);\n    }\n\n    @Override\n    protected Object randomValue(Type.PrimitiveType primitive, Random random) {\n      return generateDictionaryEncodablePrimitive(primitive, random);\n    }\n  }\n\n  private static class FallbackDataGenerator extends RandomDataGenerator {\n    private final long dictionaryEncodedRows;\n    private long rowCount = 0;\n\n    private FallbackDataGenerator(Schema schema, long seed, long numDictionaryEncoded) {\n      super(schema, seed);\n      this.dictionaryEncodedRows = numDictionaryEncoded;\n    }\n\n    @Override\n    protected Object randomValue(Type.PrimitiveType primitive, Random rand) {\n      this.rowCount += 1;\n      if (rowCount > dictionaryEncodedRows) {\n        return generatePrimitive(primitive, rand);\n      } else {\n        return generateDictionaryEncodablePrimitive(primitive, rand);\n      }\n    }\n  }", "bodyHTML": "<p dir=\"auto\">I think it would be easier to understand if this were a combination of the normal generator and the dictionary-encoded generator and used just some number of records before falling back. Then you would only need the two existing ways to generate primitives. Something like this, where <code>generateDictionaryEncodablePrimitive()</code> is what I pasted for <code>DictionaryEncodedDataGenerator</code> above:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"  private static class DictionaryEncodedDataGenerator extends RandomDataGenerator {\n    private DictionaryEncodedDataGenerator(Schema schema, long seed) {\n      super(schema, seed);\n    }\n\n    @Override\n    protected Object randomValue(Type.PrimitiveType primitive, Random random) {\n      return generateDictionaryEncodablePrimitive(primitive, random);\n    }\n  }\n\n  private static class FallbackDataGenerator extends RandomDataGenerator {\n    private final long dictionaryEncodedRows;\n    private long rowCount = 0;\n\n    private FallbackDataGenerator(Schema schema, long seed, long numDictionaryEncoded) {\n      super(schema, seed);\n      this.dictionaryEncodedRows = numDictionaryEncoded;\n    }\n\n    @Override\n    protected Object randomValue(Type.PrimitiveType primitive, Random rand) {\n      this.rowCount += 1;\n      if (rowCount &gt; dictionaryEncodedRows) {\n        return generatePrimitive(primitive, rand);\n      } else {\n        return generateDictionaryEncodablePrimitive(primitive, rand);\n      }\n    }\n  }\n\"><pre>  <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">DictionaryEncodedDataGenerator</span> <span class=\"pl-k\">extends</span> <span class=\"pl-e\">RandomDataGenerator</span> {\n    <span class=\"pl-k\">private</span> <span class=\"pl-en\">DictionaryEncodedDataGenerator</span>(<span class=\"pl-smi\">Schema</span> <span class=\"pl-v\">schema</span>, <span class=\"pl-k\">long</span> <span class=\"pl-v\">seed</span>) {\n      <span class=\"pl-c1\">super</span>(schema, seed);\n    }\n\n    <span class=\"pl-k\">@Override</span>\n    <span class=\"pl-k\">protected</span> <span class=\"pl-smi\">Object</span> <span class=\"pl-en\">randomValue</span>(<span class=\"pl-smi\">Type</span>.<span class=\"pl-smi\">PrimitiveType</span> <span class=\"pl-v\">primitive</span>, <span class=\"pl-smi\">Random</span> <span class=\"pl-v\">random</span>) {\n      <span class=\"pl-k\">return</span> generateDictionaryEncodablePrimitive(primitive, random);\n    }\n  }\n\n  <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">FallbackDataGenerator</span> <span class=\"pl-k\">extends</span> <span class=\"pl-e\">RandomDataGenerator</span> {\n    <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k\">long</span> dictionaryEncodedRows;\n    <span class=\"pl-k\">private</span> <span class=\"pl-k\">long</span> rowCount <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>;\n\n    <span class=\"pl-k\">private</span> <span class=\"pl-en\">FallbackDataGenerator</span>(<span class=\"pl-smi\">Schema</span> <span class=\"pl-v\">schema</span>, <span class=\"pl-k\">long</span> <span class=\"pl-v\">seed</span>, <span class=\"pl-k\">long</span> <span class=\"pl-v\">numDictionaryEncoded</span>) {\n      <span class=\"pl-c1\">super</span>(schema, seed);\n      <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>dictionaryEncodedRows <span class=\"pl-k\">=</span> numDictionaryEncoded;\n    }\n\n    <span class=\"pl-k\">@Override</span>\n    <span class=\"pl-k\">protected</span> <span class=\"pl-smi\">Object</span> <span class=\"pl-en\">randomValue</span>(<span class=\"pl-smi\">Type</span>.<span class=\"pl-smi\">PrimitiveType</span> <span class=\"pl-v\">primitive</span>, <span class=\"pl-smi\">Random</span> <span class=\"pl-v\">rand</span>) {\n      <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>rowCount <span class=\"pl-k\">+=</span> <span class=\"pl-c1\">1</span>;\n      <span class=\"pl-k\">if</span> (rowCount <span class=\"pl-k\">&gt;</span> dictionaryEncodedRows) {\n        <span class=\"pl-k\">return</span> generatePrimitive(primitive, rand);\n      } <span class=\"pl-k\">else</span> {\n        <span class=\"pl-k\">return</span> generateDictionaryEncodablePrimitive(primitive, rand);\n      }\n    }\n  }</pre></div>", "author": "rdblue", "createdAt": "2020-06-03T21:12:53Z", "path": "spark/src/test/java/org/apache/iceberg/spark/data/RandomData.java", "diffHunk": "@@ -442,4 +474,226 @@ private static BigInteger randomUnscaled(int precision, Random random) {\n \n     return new BigInteger(sb.toString());\n   }\n+\n+  private static class DictionaryEncodedDataGenerator extends RandomDataGenerator {\n+\n+    private DictionaryEncodedDataGenerator(Schema schema, long seed) {\n+      super(schema, seed);\n+    }\n+\n+    @Override\n+    public Object primitive(Type.PrimitiveType primitive) {\n+      Object result = generateDictionaryEncodablePrimitive(primitive, random);\n+      return super.getPrimitive(primitive, result);\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    private static Object generateDictionaryEncodablePrimitive(Type.PrimitiveType primitive, Random random) {\n+      // 3 choices\n+      int choice = random.nextInt(3);\n+      switch (primitive.typeId()) {\n+        case BOOLEAN:\n+          return true; // doesn't really matter for booleans since they are not dictionary encoded\n+\n+        case INTEGER:\n+          switch (choice) {\n+            case 0:\n+              return 0;\n+            case 1:\n+              return 1;\n+            case 2:\n+              return 2;\n+          }\n+\n+        case LONG:\n+          switch (choice) {\n+            case 0:\n+              return 0L;\n+            case 1:\n+              return 1L;\n+            case 2:\n+              return 2L;\n+          }\n+\n+        case FLOAT:\n+          switch (choice) {\n+            case 0:\n+              return 0.0f;\n+            case 1:\n+              return 1.0f;\n+            case 2:\n+              return 2.0f;\n+          }\n+\n+        case DOUBLE:\n+          switch (choice) {\n+            case 0:\n+              return 0.0d;\n+            case 1:\n+              return 1.0d;\n+            case 2:\n+              return 2.0d;\n+          }\n+\n+        case DATE:\n+          switch (choice) {\n+            case 0:\n+              return 0;\n+            case 1:\n+              return 1;\n+            case 2:\n+              return 2;\n+          }\n+\n+        case TIME:\n+          switch (choice) {\n+            case 0:\n+              return 0L;\n+            case 1:\n+              return 1L;\n+            case 2:\n+              return 2L;\n+          }\n+\n+        case TIMESTAMP:\n+          switch (choice) {\n+            case 0:\n+              return 0L;\n+            case 1:\n+              return 1L;\n+            case 2:\n+              return 2L;\n+          }\n+\n+        case STRING:\n+          switch (choice) {\n+            case 0:\n+              return UTF8String.fromString(\"0\");\n+            case 1:\n+              return UTF8String.fromString(\"1\");\n+            case 2:\n+              return UTF8String.fromString(\"2\");\n+          }\n+\n+        case FIXED:\n+          byte[] fixed = new byte[((Types.FixedType) primitive).length()];\n+          switch (choice) {\n+            case 0:\n+              fixed[0] = 0;\n+              return fixed;\n+            case 1:\n+              fixed[0] = 1;\n+              return fixed;\n+            case 2:\n+              fixed[0] = 2;\n+              return fixed;\n+          }\n+\n+        case BINARY:\n+          byte[] binary = new byte[4];\n+          switch (choice) {\n+            case 0:\n+              binary[0] = 0;\n+              return binary;\n+            case 1:\n+              binary[0] = 1;\n+              return binary;\n+            case 2:\n+              binary[0] = 2;\n+              return binary;\n+          }\n+\n+        case DECIMAL:\n+          Types.DecimalType type = (Types.DecimalType) primitive;\n+          switch (choice) {\n+            case 0:\n+              BigInteger unscaled = new BigInteger(\"1\");\n+              return Decimal.apply(new BigDecimal(unscaled, type.scale()));\n+            case 1:\n+              unscaled = new BigInteger(\"2\");\n+              return Decimal.apply(new BigDecimal(unscaled, type.scale()));\n+            case 2:\n+              unscaled = new BigInteger(\"3\");\n+              return Decimal.apply(new BigDecimal(unscaled, type.scale()));\n+          }\n+\n+        default:\n+          throw new IllegalArgumentException(\n+              \"Cannot generate random value for unknown type: \" + primitive);\n+      }\n+    }\n+  }\n+\n+  private static class DictionaryFallbackToPlainEncodingDataGenerator extends RandomDataGenerator {\n+    private final long numValues;\n+    private final float fraction;\n+    private int current;\n+\n+    private DictionaryFallbackToPlainEncodingDataGenerator(Schema schema, long seed, int numRecords, float fraction) {", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxODAwNw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434918007", "bodyText": "Included in my PR.", "author": "rdblue", "createdAt": "2020-06-03T23:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg2MDY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg2MzM5Mw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434863393", "body": "Why were these converted to optional?", "bodyText": "Why were these converted to optional?", "bodyHTML": "<p dir=\"auto\">Why were these converted to optional?</p>", "author": "rdblue", "createdAt": "2020-06-03T21:18:15Z", "path": "spark/src/test/java/org/apache/iceberg/spark/data/AvroDataTest.java", "diffHunk": "@@ -44,18 +44,18 @@\n       optional(101, \"data\", Types.StringType.get()),\n       required(102, \"b\", Types.BooleanType.get()),\n       optional(103, \"i\", Types.IntegerType.get()),\n-      required(104, \"l\", LongType.get()),\n+      optional(104, \"l\", LongType.get()),\n       optional(105, \"f\", Types.FloatType.get()),\n-      required(106, \"d\", Types.DoubleType.get()),\n+      optional(106, \"d\", Types.DoubleType.get()),\n       optional(107, \"date\", Types.DateType.get()),\n-      required(108, \"ts\", Types.TimestampType.withZone()),\n-      required(110, \"s\", Types.StringType.get()),\n+      optional(108, \"ts\", Types.TimestampType.withZone()),\n+      optional(110, \"s\", Types.StringType.get()),\n       //required(111, \"uuid\", Types.UUIDType.get()),\n-      required(112, \"fixed\", Types.FixedType.ofLength(7)),\n+      optional(112, \"fixed\", Types.FixedType.ofLength(7)),\n       optional(113, \"bytes\", Types.BinaryType.get()),\n-      required(114, \"dec_9_0\", Types.DecimalType.of(9, 0)),\n-      required(115, \"dec_11_2\", Types.DecimalType.of(11, 2)),\n-      required(116, \"dec_38_10\", Types.DecimalType.of(38, 10)) // spark's maximum precision\n+      optional(114, \"dec_9_0\", Types.DecimalType.of(9, 0)),\n+      optional(115, \"dec_11_2\", Types.DecimalType.of(11, 2)),\n+      optional(116, \"dec_38_10\", Types.DecimalType.of(38, 10)) // spark's maximum precision", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxODY0Ng==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434918646", "bodyText": "Reverted this change in my PR.", "author": "rdblue", "createdAt": "2020-06-03T23:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg2MzM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg2NzAwMQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434867001", "body": "I think this should create a different base class instead of using `AvroDataTest`. This removes quite a few methods from `AvroDataTest` and also makes changes to it, like making all of the fields optional. Rather than doing that, I think it would make sense to just copy those test cases into a new `VectorizedDataTest`, since they are just schemas. And you could also add other cases, like these:\r\n\r\n```java\r\n  @Test\r\n  public void testStructWithRequiredFields() throws IOException {\r\n    writeAndValidate(TypeUtil.assignIncreasingFreshIds(new Schema(\r\n        Lists.transform(SUPPORTED_PRIMITIVES.fields(), Types.NestedField::asRequired))));\r\n  }\r\n\r\n  @Test\r\n  public void testStructWithOptionalFields() throws IOException {\r\n    writeAndValidate(TypeUtil.assignIncreasingFreshIds(new Schema(\r\n        Lists.transform(SUPPORTED_PRIMITIVES.fields(), Types.NestedField::asOptional))));\r\n  }\r\n\r\n  @Test\r\n  public void testNestedStruct() throws IOException {\r\n    writeAndValidate(TypeUtil.assignIncreasingFreshIds(new Schema(required(1, \"struct\", SUPPORTED_PRIMITIVES))));\r\n  }\r\n```", "bodyText": "I think this should create a different base class instead of using AvroDataTest. This removes quite a few methods from AvroDataTest and also makes changes to it, like making all of the fields optional. Rather than doing that, I think it would make sense to just copy those test cases into a new VectorizedDataTest, since they are just schemas. And you could also add other cases, like these:\n  @Test\n  public void testStructWithRequiredFields() throws IOException {\n    writeAndValidate(TypeUtil.assignIncreasingFreshIds(new Schema(\n        Lists.transform(SUPPORTED_PRIMITIVES.fields(), Types.NestedField::asRequired))));\n  }\n\n  @Test\n  public void testStructWithOptionalFields() throws IOException {\n    writeAndValidate(TypeUtil.assignIncreasingFreshIds(new Schema(\n        Lists.transform(SUPPORTED_PRIMITIVES.fields(), Types.NestedField::asOptional))));\n  }\n\n  @Test\n  public void testNestedStruct() throws IOException {\n    writeAndValidate(TypeUtil.assignIncreasingFreshIds(new Schema(required(1, \"struct\", SUPPORTED_PRIMITIVES))));\n  }", "bodyHTML": "<p dir=\"auto\">I think this should create a different base class instead of using <code>AvroDataTest</code>. This removes quite a few methods from <code>AvroDataTest</code> and also makes changes to it, like making all of the fields optional. Rather than doing that, I think it would make sense to just copy those test cases into a new <code>VectorizedDataTest</code>, since they are just schemas. And you could also add other cases, like these:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"  @Test\n  public void testStructWithRequiredFields() throws IOException {\n    writeAndValidate(TypeUtil.assignIncreasingFreshIds(new Schema(\n        Lists.transform(SUPPORTED_PRIMITIVES.fields(), Types.NestedField::asRequired))));\n  }\n\n  @Test\n  public void testStructWithOptionalFields() throws IOException {\n    writeAndValidate(TypeUtil.assignIncreasingFreshIds(new Schema(\n        Lists.transform(SUPPORTED_PRIMITIVES.fields(), Types.NestedField::asOptional))));\n  }\n\n  @Test\n  public void testNestedStruct() throws IOException {\n    writeAndValidate(TypeUtil.assignIncreasingFreshIds(new Schema(required(1, &quot;struct&quot;, SUPPORTED_PRIMITIVES))));\n  }\n\"><pre>  <span class=\"pl-k\">@Test</span>\n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> testStructWithRequiredFields() throws <span class=\"pl-smi\">IOException</span> {\n    writeAndValidate(<span class=\"pl-smi\">TypeUtil</span><span class=\"pl-k\">.</span>assignIncreasingFreshIds(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">Schema</span>(\n        <span class=\"pl-smi\">Lists</span><span class=\"pl-k\">.</span>transform(<span class=\"pl-c1\">SUPPORTED_PRIMITIVES</span><span class=\"pl-k\">.</span>fields(), <span class=\"pl-smi\">Types</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">NestedField</span><span class=\"pl-k\">::</span>asRequired))));\n  }\n\n  <span class=\"pl-k\">@Test</span>\n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> testStructWithOptionalFields() throws <span class=\"pl-smi\">IOException</span> {\n    writeAndValidate(<span class=\"pl-smi\">TypeUtil</span><span class=\"pl-k\">.</span>assignIncreasingFreshIds(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">Schema</span>(\n        <span class=\"pl-smi\">Lists</span><span class=\"pl-k\">.</span>transform(<span class=\"pl-c1\">SUPPORTED_PRIMITIVES</span><span class=\"pl-k\">.</span>fields(), <span class=\"pl-smi\">Types</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">NestedField</span><span class=\"pl-k\">::</span>asOptional))));\n  }\n\n  <span class=\"pl-k\">@Test</span>\n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> testNestedStruct() throws <span class=\"pl-smi\">IOException</span> {\n    writeAndValidate(<span class=\"pl-smi\">TypeUtil</span><span class=\"pl-k\">.</span>assignIncreasingFreshIds(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">Schema</span>(required(<span class=\"pl-c1\">1</span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>struct<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">SUPPORTED_PRIMITIVES</span>))));\n  }</pre></div>", "author": "rdblue", "createdAt": "2020-06-03T21:25:53Z", "path": "spark/src/test/java/org/apache/iceberg/spark/data/parquet/vectorized/TestParquetVectorizedReads.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.parquet.vectorized;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.apache.avro.generic.GenericData;\n+import org.apache.iceberg.Files;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileAppender;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.spark.data.AvroDataTest;\n+import org.apache.iceberg.spark.data.RandomData;\n+import org.apache.iceberg.spark.data.TestHelpers;\n+import org.apache.iceberg.spark.data.vectorized.VectorizedSparkParquetReaders;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.vectorized.ColumnarBatch;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+public class TestParquetVectorizedReads extends AvroDataTest {", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxNzkzNQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434917935", "bodyText": "Included in my PR.", "author": "rdblue", "createdAt": "2020-06-03T23:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg2NzAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg2NzQ5NQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434867495", "body": "All this method does is call another method. Do we need both or can we move the body of `lazyCheckEnableBatchRead` here?", "bodyText": "All this method does is call another method. Do we need both or can we move the body of lazyCheckEnableBatchRead here?", "bodyHTML": "<p dir=\"auto\">All this method does is call another method. Do we need both or can we move the body of <code>lazyCheckEnableBatchRead</code> here?</p>", "author": "rdblue", "createdAt": "2020-06-03T21:27:03Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -249,6 +290,34 @@ public Statistics estimateStatistics() {\n     return new Stats(sizeInBytes, numRows);\n   }\n \n+  @Override\n+  public boolean enableBatchRead() {\n+    return lazyCheckEnableBatchRead();", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxNzMzMw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434917333", "bodyText": "Done in my PR.", "author": "rdblue", "createdAt": "2020-06-03T23:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg2NzQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg2ODU5Nw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434868597", "body": "This method isn't used and can be removed.", "bodyText": "This method isn't used and can be removed.", "bodyHTML": "<p dir=\"auto\">This method isn't used and can be removed.</p>", "author": "rdblue", "createdAt": "2020-06-03T21:29:31Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/VectorizedSparkParquetReaders.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.IntStream;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.NullCheckingForGet;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.arrow.ArrowAllocation;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.TypeWithSchemaVisitor;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.iceberg.types.Types;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.schema.GroupType;\n+import org.apache.parquet.schema.MessageType;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.parquet.schema.Type;\n+\n+public class VectorizedSparkParquetReaders {\n+\n+  private VectorizedSparkParquetReaders() {\n+  }\n+\n+  public static ColumnarBatchReader buildReader(\n+      Schema expectedSchema,\n+      MessageType fileSchema,\n+      Integer recordsPerBatch) {\n+    return (ColumnarBatchReader)\n+        TypeWithSchemaVisitor.visit(expectedSchema.asStruct(), fileSchema,\n+            new VectorizedReaderBuilder(expectedSchema, fileSchema, recordsPerBatch));\n+  }\n+\n+  private static class VectorizedReaderBuilder extends TypeWithSchemaVisitor<VectorizedReader<?>> {\n+    private final MessageType parquetSchema;\n+    private final Schema icebergSchema;\n+    private final BufferAllocator rootAllocator;\n+    private final int batchSize;\n+\n+    VectorizedReaderBuilder(\n+        Schema expectedSchema,\n+        MessageType parquetSchema,\n+        int bSize) {\n+      this.parquetSchema = parquetSchema;\n+      this.icebergSchema = expectedSchema;\n+      this.batchSize = bSize;\n+      this.rootAllocator = ArrowAllocation.rootAllocator()\n+          .newChildAllocator(\"VectorizedReadBuilder\", 0, Long.MAX_VALUE);\n+    }\n+\n+    @Override\n+    public VectorizedReader<?> message(\n+            Types.StructType expected, MessageType message,\n+            List<VectorizedReader<?>> fieldReaders) {\n+      return struct(expected, message.asGroupType(), fieldReaders);\n+    }\n+\n+    @Override\n+    public VectorizedReader<?> struct(\n+            Types.StructType expected, GroupType struct,\n+            List<VectorizedReader<?>> fieldReaders) {\n+\n+      Map<Integer, VectorizedReader<?>> readersById = Maps.newHashMap();\n+      List<Type> fields = struct.getFields();\n+\n+      IntStream.range(0, fields.size())\n+          .forEach(pos -> readersById.put(fields.get(pos).getId().intValue(), fieldReaders.get(pos)));\n+\n+      List<Types.NestedField> icebergFields = expected != null ?\n+          expected.fields() : ImmutableList.of();\n+\n+      List<VectorizedReader<?>> reorderedFields = Lists.newArrayListWithExpectedSize(\n+          icebergFields.size());\n+\n+      for (Types.NestedField field : icebergFields) {\n+        int id = field.fieldId();\n+        VectorizedReader<?> reader = readersById.get(id);\n+        if (reader != null) {\n+          reorderedFields.add(reader);\n+        } else {\n+          reorderedFields.add(VectorizedArrowReader.nulls());\n+        }\n+      }\n+      return new ColumnarBatchReader(reorderedFields);\n+    }\n+\n+    @Override\n+    public VectorizedReader<?> primitive(\n+        org.apache.iceberg.types.Type.PrimitiveType expected,\n+        PrimitiveType primitive) {\n+\n+      // Create arrow vector for this field\n+      int parquetFieldId = primitive.getId().intValue();\n+      ColumnDescriptor desc = parquetSchema.getColumnDescription(currentPath());\n+      // Nested types not yet supported for vectorized reads\n+      if (desc.getMaxRepetitionLevel() > 0) {\n+        return null;\n+      }\n+      Types.NestedField icebergField = icebergSchema.findField(parquetFieldId);\n+      if (icebergField == null) {\n+        return null;\n+      }\n+      // Set the validity buffer if null checking is enabled in arrow\n+      return new VectorizedArrowReader(desc, icebergField, rootAllocator,\n+          batchSize, /* setArrowValidityVector */ NullCheckingForGet.NULL_CHECKING_ENABLED);\n+    }\n+\n+    protected MessageType type() {", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxNzQ3OA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434917478", "bodyText": "Done in my PR.", "author": "rdblue", "createdAt": "2020-06-03T23:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg2ODU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg2OTY5NQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434869695", "body": "Coverage shows that this branch is never taken because there are no tests for read projection that use the vectorized path. Can you add tests based on `TestReadProjection` like the tests you added using `AvroDataTest`?", "bodyText": "Coverage shows that this branch is never taken because there are no tests for read projection that use the vectorized path. Can you add tests based on TestReadProjection like the tests you added using AvroDataTest?", "bodyHTML": "<p dir=\"auto\">Coverage shows that this branch is never taken because there are no tests for read projection that use the vectorized path. Can you add tests based on <code>TestReadProjection</code> like the tests you added using <code>AvroDataTest</code>?</p>", "author": "rdblue", "createdAt": "2020-06-03T21:31:45Z", "path": "spark/src/main/java/org/apache/iceberg/spark/data/vectorized/VectorizedSparkParquetReaders.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data.vectorized;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.IntStream;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.NullCheckingForGet;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.arrow.ArrowAllocation;\n+import org.apache.iceberg.arrow.vectorized.VectorizedArrowReader;\n+import org.apache.iceberg.parquet.TypeWithSchemaVisitor;\n+import org.apache.iceberg.parquet.VectorizedReader;\n+import org.apache.iceberg.types.Types;\n+import org.apache.parquet.column.ColumnDescriptor;\n+import org.apache.parquet.schema.GroupType;\n+import org.apache.parquet.schema.MessageType;\n+import org.apache.parquet.schema.PrimitiveType;\n+import org.apache.parquet.schema.Type;\n+\n+public class VectorizedSparkParquetReaders {\n+\n+  private VectorizedSparkParquetReaders() {\n+  }\n+\n+  public static ColumnarBatchReader buildReader(\n+      Schema expectedSchema,\n+      MessageType fileSchema,\n+      Integer recordsPerBatch) {\n+    return (ColumnarBatchReader)\n+        TypeWithSchemaVisitor.visit(expectedSchema.asStruct(), fileSchema,\n+            new VectorizedReaderBuilder(expectedSchema, fileSchema, recordsPerBatch));\n+  }\n+\n+  private static class VectorizedReaderBuilder extends TypeWithSchemaVisitor<VectorizedReader<?>> {\n+    private final MessageType parquetSchema;\n+    private final Schema icebergSchema;\n+    private final BufferAllocator rootAllocator;\n+    private final int batchSize;\n+\n+    VectorizedReaderBuilder(\n+        Schema expectedSchema,\n+        MessageType parquetSchema,\n+        int bSize) {\n+      this.parquetSchema = parquetSchema;\n+      this.icebergSchema = expectedSchema;\n+      this.batchSize = bSize;\n+      this.rootAllocator = ArrowAllocation.rootAllocator()\n+          .newChildAllocator(\"VectorizedReadBuilder\", 0, Long.MAX_VALUE);\n+    }\n+\n+    @Override\n+    public VectorizedReader<?> message(\n+            Types.StructType expected, MessageType message,\n+            List<VectorizedReader<?>> fieldReaders) {\n+      return struct(expected, message.asGroupType(), fieldReaders);\n+    }\n+\n+    @Override\n+    public VectorizedReader<?> struct(\n+            Types.StructType expected, GroupType struct,\n+            List<VectorizedReader<?>> fieldReaders) {\n+\n+      Map<Integer, VectorizedReader<?>> readersById = Maps.newHashMap();\n+      List<Type> fields = struct.getFields();\n+\n+      IntStream.range(0, fields.size())\n+          .forEach(pos -> readersById.put(fields.get(pos).getId().intValue(), fieldReaders.get(pos)));\n+\n+      List<Types.NestedField> icebergFields = expected != null ?\n+          expected.fields() : ImmutableList.of();\n+\n+      List<VectorizedReader<?>> reorderedFields = Lists.newArrayListWithExpectedSize(\n+          icebergFields.size());\n+\n+      for (Types.NestedField field : icebergFields) {\n+        int id = field.fieldId();\n+        VectorizedReader<?> reader = readersById.get(id);\n+        if (reader != null) {\n+          reorderedFields.add(reader);\n+        } else {\n+          reorderedFields.add(VectorizedArrowReader.nulls());", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxNzgwMw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434917803", "bodyText": "Coverage shows that this is now tested with the update in my PR.", "author": "rdblue", "createdAt": "2020-06-03T23:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg2OTY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg3MzE0MQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434873141", "body": "Coverage shows that this branch isn't taken -- line 213 is never used by the existing tests. The equivalent line for doubles is taken, though. Can you find out what's happening?", "bodyText": "Coverage shows that this branch isn't taken -- line 213 is never used by the existing tests. The equivalent line for doubles is taken, though. Can you find out what's happening?", "bodyHTML": "<p dir=\"auto\">Coverage shows that this branch isn't taken -- line 213 is never used by the existing tests. The equivalent line for doubles is taken, though. Can you find out what's happening?</p>", "author": "rdblue", "createdAt": "2020-06-03T21:39:27Z", "path": "arrow/src/main/java/org/apache/iceberg/arrow/vectorized/parquet/VectorizedPageIterator.java", "diffHunk": "@@ -202,7 +209,7 @@ public int nextBatchFloats(\n     if (actualBatchSize <= 0) {\n       return 0;\n     }\n-    if (eagerDecodeDictionary) {\n+    if (dictionaryDecodeMode == DictionaryDecodeMode.EAGER) {", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg3NzA1MA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434877050", "bodyText": "Actually, this was in my local copy. When I reverted the changes I see that the tests are hitting this line. But the decimal line below is not showing up in coverage.", "author": "rdblue", "createdAt": "2020-06-03T21:48:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg3MzE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg3MzQ3Nw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434873477", "body": "Coverage shows that this path isn't taken either.", "bodyText": "Coverage shows that this path isn't taken either.", "bodyHTML": "<p dir=\"auto\">Coverage shows that this path isn't taken either.</p>", "author": "rdblue", "createdAt": "2020-06-03T21:40:12Z", "path": "arrow/src/main/java/org/apache/iceberg/arrow/vectorized/parquet/VectorizedPageIterator.java", "diffHunk": "@@ -312,7 +319,7 @@ public int nextBatchFixedLengthDecimal(\n     if (actualBatchSize <= 0) {\n       return 0;\n     }\n-    if (eagerDecodeDictionary) {\n+    if (dictionaryDecodeMode == DictionaryDecodeMode.EAGER) {", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg3Mzg1NA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434873854", "bodyText": "Looks like DictionaryDecimalBinaryAccessor is also not used by tests. That's probably related. Maybe decimals are not getting dictionary encoded?", "author": "rdblue", "createdAt": "2020-06-03T21:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg3MzQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMzUyMw==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434903523", "body": "I think this is correct. We don't need to have multiple task instances, especially since this will go away in 3.0.\r\n\r\nInstead, it's cleaner if we pass a reader factory into a single read task and call that factory in `createPartitionReader`:\r\n\r\n```java\r\n  private interface ReaderFactory<T> {\r\n    InputPartitionReader<T> create(CombinedScanTask task, Schema tableSchema, Schema expectedSchema, FileIO io,\r\n                                   EncryptionManager encryptionManager, boolean caseSensitive);\r\n  }\r\n\r\n  private static class InternalRowReaderFactory implements ReaderFactory<InternalRow> {\r\n    private static final InternalRowReaderFactory INSTANCE = new InternalRowReaderFactory();\r\n\r\n    private InternalRowReaderFactory() {\r\n    }\r\n\r\n    @Override\r\n    public InputPartitionReader<InternalRow> create(CombinedScanTask task, Schema tableSchema, Schema expectedSchema,\r\n                                                    FileIO io, EncryptionManager encryptionManager,\r\n                                                    boolean caseSensitive) {\r\n      return new RowDataReader(task, tableSchema, expectedSchema, io, encryptionManager, caseSensitive);\r\n    }\r\n  }\r\n\r\n  private static class BatchReaderFactory implements ReaderFactory<ColumnarBatch> {\r\n    private final int batchSize;\r\n\r\n    BatchReaderFactory(int batchSize) {\r\n      this.batchSize = batchSize;\r\n    }\r\n\r\n    @Override\r\n    public InputPartitionReader<ColumnarBatch> create(CombinedScanTask task, Schema tableSchema, Schema expectedSchema,\r\n                                                    FileIO io, EncryptionManager encryptionManager,\r\n                                                    boolean caseSensitive) {\r\n      return new BatchDataReader(task, expectedSchema, io, encryptionManager, caseSensitive, batchSize);\r\n    }\r\n  }\r\n```", "bodyText": "I think this is correct. We don't need to have multiple task instances, especially since this will go away in 3.0.\nInstead, it's cleaner if we pass a reader factory into a single read task and call that factory in createPartitionReader:\n  private interface ReaderFactory<T> {\n    InputPartitionReader<T> create(CombinedScanTask task, Schema tableSchema, Schema expectedSchema, FileIO io,\n                                   EncryptionManager encryptionManager, boolean caseSensitive);\n  }\n\n  private static class InternalRowReaderFactory implements ReaderFactory<InternalRow> {\n    private static final InternalRowReaderFactory INSTANCE = new InternalRowReaderFactory();\n\n    private InternalRowReaderFactory() {\n    }\n\n    @Override\n    public InputPartitionReader<InternalRow> create(CombinedScanTask task, Schema tableSchema, Schema expectedSchema,\n                                                    FileIO io, EncryptionManager encryptionManager,\n                                                    boolean caseSensitive) {\n      return new RowDataReader(task, tableSchema, expectedSchema, io, encryptionManager, caseSensitive);\n    }\n  }\n\n  private static class BatchReaderFactory implements ReaderFactory<ColumnarBatch> {\n    private final int batchSize;\n\n    BatchReaderFactory(int batchSize) {\n      this.batchSize = batchSize;\n    }\n\n    @Override\n    public InputPartitionReader<ColumnarBatch> create(CombinedScanTask task, Schema tableSchema, Schema expectedSchema,\n                                                    FileIO io, EncryptionManager encryptionManager,\n                                                    boolean caseSensitive) {\n      return new BatchDataReader(task, expectedSchema, io, encryptionManager, caseSensitive, batchSize);\n    }\n  }", "bodyHTML": "<p dir=\"auto\">I think this is correct. We don't need to have multiple task instances, especially since this will go away in 3.0.</p>\n<p dir=\"auto\">Instead, it's cleaner if we pass a reader factory into a single read task and call that factory in <code>createPartitionReader</code>:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"  private interface ReaderFactory&lt;T&gt; {\n    InputPartitionReader&lt;T&gt; create(CombinedScanTask task, Schema tableSchema, Schema expectedSchema, FileIO io,\n                                   EncryptionManager encryptionManager, boolean caseSensitive);\n  }\n\n  private static class InternalRowReaderFactory implements ReaderFactory&lt;InternalRow&gt; {\n    private static final InternalRowReaderFactory INSTANCE = new InternalRowReaderFactory();\n\n    private InternalRowReaderFactory() {\n    }\n\n    @Override\n    public InputPartitionReader&lt;InternalRow&gt; create(CombinedScanTask task, Schema tableSchema, Schema expectedSchema,\n                                                    FileIO io, EncryptionManager encryptionManager,\n                                                    boolean caseSensitive) {\n      return new RowDataReader(task, tableSchema, expectedSchema, io, encryptionManager, caseSensitive);\n    }\n  }\n\n  private static class BatchReaderFactory implements ReaderFactory&lt;ColumnarBatch&gt; {\n    private final int batchSize;\n\n    BatchReaderFactory(int batchSize) {\n      this.batchSize = batchSize;\n    }\n\n    @Override\n    public InputPartitionReader&lt;ColumnarBatch&gt; create(CombinedScanTask task, Schema tableSchema, Schema expectedSchema,\n                                                    FileIO io, EncryptionManager encryptionManager,\n                                                    boolean caseSensitive) {\n      return new BatchDataReader(task, expectedSchema, io, encryptionManager, caseSensitive, batchSize);\n    }\n  }\n\"><pre>  <span class=\"pl-k\">private</span> <span class=\"pl-k\">interface</span> <span class=\"pl-en\">ReaderFactory</span>&lt;T&gt; {\n    <span class=\"pl-k\">InputPartitionReader&lt;<span class=\"pl-smi\">T</span>&gt;</span> <span class=\"pl-en\">create</span>(<span class=\"pl-smi\">CombinedScanTask</span> <span class=\"pl-v\">task</span>, <span class=\"pl-smi\">Schema</span> <span class=\"pl-v\">tableSchema</span>, <span class=\"pl-smi\">Schema</span> <span class=\"pl-v\">expectedSchema</span>, <span class=\"pl-smi\">FileIO</span> <span class=\"pl-v\">io</span>,\n                                   <span class=\"pl-smi\">EncryptionManager</span> <span class=\"pl-v\">encryptionManager</span>, <span class=\"pl-k\">boolean</span> <span class=\"pl-v\">caseSensitive</span>);\n  }\n\n  <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">InternalRowReaderFactory</span> <span class=\"pl-k\">implements</span> <span class=\"pl-e\">ReaderFactory&lt;<span class=\"pl-smi\">InternalRow</span>&gt;</span> {\n    <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">InternalRowReaderFactory</span> <span class=\"pl-c1\">INSTANCE</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">InternalRowReaderFactory</span>();\n\n    <span class=\"pl-k\">private</span> <span class=\"pl-en\">InternalRowReaderFactory</span>() {\n    }\n\n    <span class=\"pl-k\">@Override</span>\n    <span class=\"pl-k\">public</span> <span class=\"pl-k\">InputPartitionReader&lt;<span class=\"pl-smi\">InternalRow</span>&gt;</span> <span class=\"pl-en\">create</span>(<span class=\"pl-smi\">CombinedScanTask</span> <span class=\"pl-v\">task</span>, <span class=\"pl-smi\">Schema</span> <span class=\"pl-v\">tableSchema</span>, <span class=\"pl-smi\">Schema</span> <span class=\"pl-v\">expectedSchema</span>,\n                                                    <span class=\"pl-smi\">FileIO</span> <span class=\"pl-v\">io</span>, <span class=\"pl-smi\">EncryptionManager</span> <span class=\"pl-v\">encryptionManager</span>,\n                                                    <span class=\"pl-k\">boolean</span> <span class=\"pl-v\">caseSensitive</span>) {\n      <span class=\"pl-k\">return</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">RowDataReader</span>(task, tableSchema, expectedSchema, io, encryptionManager, caseSensitive);\n    }\n  }\n\n  <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">BatchReaderFactory</span> <span class=\"pl-k\">implements</span> <span class=\"pl-e\">ReaderFactory&lt;<span class=\"pl-smi\">ColumnarBatch</span>&gt;</span> {\n    <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k\">int</span> batchSize;\n\n    <span class=\"pl-en\">BatchReaderFactory</span>(<span class=\"pl-k\">int</span> <span class=\"pl-v\">batchSize</span>) {\n      <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>batchSize <span class=\"pl-k\">=</span> batchSize;\n    }\n\n    <span class=\"pl-k\">@Override</span>\n    <span class=\"pl-k\">public</span> <span class=\"pl-k\">InputPartitionReader&lt;<span class=\"pl-smi\">ColumnarBatch</span>&gt;</span> <span class=\"pl-en\">create</span>(<span class=\"pl-smi\">CombinedScanTask</span> <span class=\"pl-v\">task</span>, <span class=\"pl-smi\">Schema</span> <span class=\"pl-v\">tableSchema</span>, <span class=\"pl-smi\">Schema</span> <span class=\"pl-v\">expectedSchema</span>,\n                                                    <span class=\"pl-smi\">FileIO</span> <span class=\"pl-v\">io</span>, <span class=\"pl-smi\">EncryptionManager</span> <span class=\"pl-v\">encryptionManager</span>,\n                                                    <span class=\"pl-k\">boolean</span> <span class=\"pl-v\">caseSensitive</span>) {\n      <span class=\"pl-k\">return</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">BatchDataReader</span>(task, expectedSchema, io, encryptionManager, caseSensitive, batchSize);\n    }\n  }</pre></div>", "author": "rdblue", "createdAt": "2020-06-03T23:00:59Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -310,26 +379,27 @@ private static void mergeIcebergHadoopConfs(\n   @Override\n   public String toString() {\n     return String.format(\n-        \"IcebergScan(table=%s, type=%s, filters=%s, caseSensitive=%s)\",\n-        table, lazySchema().asStruct(), filterExpressions, caseSensitive);\n+        \"IcebergScan(table=%s, type=%s, filters=%s, caseSensitive=%s, batchedReads=%s)\",\n+        table, lazySchema().asStruct(), filterExpressions, caseSensitive, enableBatchRead());\n   }\n \n-  private static class ReadTask implements InputPartition<InternalRow>, Serializable {\n-    private final CombinedScanTask task;\n+  @SuppressWarnings(\"checkstyle:VisibilityModifier\")", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMzczNA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434903734", "bodyText": "Then the planBatchInputPartitions method is updated like this:\n      readTasks.add(new ReadTask<>(\n          task, tableSchemaString, expectedSchemaString, io, encryptionManager, caseSensitive, localityPreferred,\n          new BatchReaderFactory(batchSize)));", "author": "rdblue", "createdAt": "2020-06-03T23:01:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMzUyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxNjUzNg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434916536", "bodyText": "This is in the PR against your branch.", "author": "rdblue", "createdAt": "2020-06-03T23:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMzUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwNDE0Ng==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434904146", "body": "I don't think this needed to be reformatted. Can you revert this change?", "bodyText": "I don't think this needed to be reformatted. Can you revert this change?", "bodyHTML": "<p dir=\"auto\">I don't think this needed to be reformatted. Can you revert this change?</p>", "author": "rdblue", "createdAt": "2020-06-03T23:03:16Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -87,14 +93,17 @@\n   private List<Expression> filterExpressions = null;\n   private Filter[] pushedFilters = NO_FILTERS;\n   private final boolean localityPreferred;\n+  private final int batchSize;\n \n   // lazy variables\n   private Schema schema = null;\n   private StructType type = null; // cached because Spark accesses it multiple times\n   private List<CombinedScanTask> tasks = null; // lazy cache of tasks\n+  private Boolean enableBatchRead = null; // cache variable for enabling batched reads\n \n-  Reader(Table table, Broadcast<FileIO> io, Broadcast<EncryptionManager> encryptionManager,\n-         boolean caseSensitive, DataSourceOptions options) {\n+  Reader(\n+      Table table, Broadcast<FileIO> io, Broadcast<EncryptionManager> encryptionManager,\n+      boolean caseSensitive, DataSourceOptions options) {", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwNDcyOA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434904728", "body": "I don't see a test for this. Can you update some of the Spark tests to run both vectorized and non-vectorized? We can also do this in a follow-up, but we need to make sure that this code path is being tested as thoroughly as the non-vectorized code path.", "bodyText": "I don't see a test for this. Can you update some of the Spark tests to run both vectorized and non-vectorized? We can also do this in a follow-up, but we need to make sure that this code path is being tested as thoroughly as the non-vectorized code path.", "bodyHTML": "<p dir=\"auto\">I don't see a test for this. Can you update some of the Spark tests to run both vectorized and non-vectorized? We can also do this in a follow-up, but we need to make sure that this code path is being tested as thoroughly as the non-vectorized code path.</p>", "author": "rdblue", "createdAt": "2020-06-03T23:05:12Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -178,6 +195,30 @@ public StructType readSchema() {\n     return lazyType();\n   }\n \n+  /**\n+   * This is called in the Spark Driver when data is to be materialized into {@link ColumnarBatch}\n+   */\n+  @Override\n+  public List<InputPartition<ColumnarBatch>> planBatchInputPartitions() {", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxNjQzMg==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434916432", "bodyText": "I added cases to TestSparkReadProjection that use this path in the PR against your branch.", "author": "rdblue", "createdAt": "2020-06-03T23:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwNDcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwNjc2MA==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434906760", "body": "Options passed into the read here should be short options because they come from the DataFrameReader interface:\r\n\r\n```scala\r\nspark.read.format(\"iceberg\").config(\"snapshot-id\", snapId).load(\"db.table\");\r\n```\r\n\r\nThe long option names like the ones you have here are what we use for table properties, which are tracked in `TableProperties` and documented. These options should default to the table property value, but a DataFrameReader option should override.\r\n\r\nFor short names, how about `vectorization-enabled` and `batch-size`? We should also add constants in `TableProperties` for the properties you have here. Let's turn off vectorization by default.\r\n\r\nAlso, we can drop \"iceberg\" from the start of the properties.", "bodyText": "Options passed into the read here should be short options because they come from the DataFrameReader interface:\nspark.read.format(\"iceberg\").config(\"snapshot-id\", snapId).load(\"db.table\");\nThe long option names like the ones you have here are what we use for table properties, which are tracked in TableProperties and documented. These options should default to the table property value, but a DataFrameReader option should override.\nFor short names, how about vectorization-enabled and batch-size? We should also add constants in TableProperties for the properties you have here. Let's turn off vectorization by default.\nAlso, we can drop \"iceberg\" from the start of the properties.", "bodyHTML": "<p dir=\"auto\">Options passed into the read here should be short options because they come from the DataFrameReader interface:</p>\n<div class=\"highlight highlight-source-scala position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"spark.read.format(&quot;iceberg&quot;).config(&quot;snapshot-id&quot;, snapId).load(&quot;db.table&quot;);\n\"><pre>spark.read.format(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>iceberg<span class=\"pl-pds\">\"</span></span>).config(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>snapshot-id<span class=\"pl-pds\">\"</span></span>, snapId).load(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>db.table<span class=\"pl-pds\">\"</span></span>);</pre></div>\n<p dir=\"auto\">The long option names like the ones you have here are what we use for table properties, which are tracked in <code>TableProperties</code> and documented. These options should default to the table property value, but a DataFrameReader option should override.</p>\n<p dir=\"auto\">For short names, how about <code>vectorization-enabled</code> and <code>batch-size</code>? We should also add constants in <code>TableProperties</code> for the properties you have here. Let's turn off vectorization by default.</p>\n<p dir=\"auto\">Also, we can drop \"iceberg\" from the start of the properties.</p>", "author": "rdblue", "createdAt": "2020-06-03T23:12:23Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/Reader.java", "diffHunk": "@@ -145,6 +154,14 @@\n     this.io = io;\n     this.encryptionManager = encryptionManager;\n     this.caseSensitive = caseSensitive;\n+\n+    boolean enableBatchReadsConfig =\n+        options.get(\"iceberg.read.parquet-vectorization.enabled\").map(Boolean::parseBoolean).orElse(true);\n+    if (!enableBatchReadsConfig) {\n+      enableBatchRead = Boolean.FALSE;\n+    }\n+    Optional<String> numRecordsPerBatchOpt = options.get(\"iceberg.read.parquet-vectorization.batch-size\");", "originalCommit": "032c8c12c972614ee5514b7c586021331c8bf002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxNjMwMQ==", "url": "https://github.com/apache/iceberg/pull/828#discussion_r434916301", "bodyText": "I included this change in the PR against your branch.", "author": "rdblue", "createdAt": "2020-06-03T23:46:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwNjc2MA=="}], "type": "inlineReview"}, {"oid": "e3f72438b503419a1a02c76a98f1d179babaf712", "url": "https://github.com/apache/iceberg/commit/e3f72438b503419a1a02c76a98f1d179babaf712", "message": "iceberg-spark changes for vectorized reads", "committedDate": "2020-06-12T08:35:35Z", "type": "commit"}, {"oid": "b33f6d876a0b4ebdc93e0a74af1b437eea1336bc", "url": "https://github.com/apache/iceberg/commit/b33f6d876a0b4ebdc93e0a74af1b437eea1336bc", "message": "Minor cleanup", "committedDate": "2020-06-12T08:35:35Z", "type": "commit"}, {"oid": "492c0b0845722c3e9aaef9f108880cff1de672ec", "url": "https://github.com/apache/iceberg/commit/492c0b0845722c3e9aaef9f108880cff1de672ec", "message": "Address code review comments", "committedDate": "2020-06-12T08:35:35Z", "type": "commit"}, {"oid": "dc93427018ae3a7256ed20c203466885d61713fb", "url": "https://github.com/apache/iceberg/commit/dc93427018ae3a7256ed20c203466885d61713fb", "message": "Remove benchmarks from the code review", "committedDate": "2020-06-12T08:35:35Z", "type": "commit"}, {"oid": "4760f790b60b456b214dd9db1d8c94a594bb7995", "url": "https://github.com/apache/iceberg/commit/4760f790b60b456b214dd9db1d8c94a594bb7995", "message": "Merge reader changes from master. Rebase branch to master", "committedDate": "2020-06-12T08:35:35Z", "type": "commit"}, {"oid": "41064aa505d80537e358f19029178d85bb22014e", "url": "https://github.com/apache/iceberg/commit/41064aa505d80537e358f19029178d85bb22014e", "message": "Code review comments", "committedDate": "2020-06-12T08:35:35Z", "type": "commit"}, {"oid": "c5347bf7af610c7af3ac418261f4a182cd1441cc", "url": "https://github.com/apache/iceberg/commit/c5347bf7af610c7af3ac418261f4a182cd1441cc", "message": "Code review comments", "committedDate": "2020-06-12T08:35:35Z", "type": "commit"}, {"oid": "b7b68f5153dcdd55b57fadecf010cbcfce084652", "url": "https://github.com/apache/iceberg/commit/b7b68f5153dcdd55b57fadecf010cbcfce084652", "message": "Some changes from the review.", "committedDate": "2020-06-12T08:36:59Z", "type": "commit"}, {"oid": "58f2cf79ea49e89cf217c773a0591c4de6795428", "url": "https://github.com/apache/iceberg/commit/58f2cf79ea49e89cf217c773a0591c4de6795428", "message": "Enable projection tests for vectorized Parquet.", "committedDate": "2020-06-12T08:36:59Z", "type": "commit"}, {"oid": "edecc2a4c3887fc04b5ce54ad4818b971de5850c", "url": "https://github.com/apache/iceberg/commit/edecc2a4c3887fc04b5ce54ad4818b971de5850c", "message": "Revert changes to AvroDataTest.", "committedDate": "2020-06-12T08:36:59Z", "type": "commit"}, {"oid": "f094507acfc77715803606729c38a690407ecf10", "url": "https://github.com/apache/iceberg/commit/f094507acfc77715803606729c38a690407ecf10", "message": "Run TestParquetScan tests with vectorization enabled.", "committedDate": "2020-06-12T08:36:59Z", "type": "commit"}, {"oid": "8dc98ce60d8df6f7de4f229a81516eea7d58583e", "url": "https://github.com/apache/iceberg/commit/8dc98ce60d8df6f7de4f229a81516eea7d58583e", "message": "Summary of changes:\n1) Below new test cases added:\n   - Test for code path when optional values are mostly null\n   - Test for case when containers are not reused for every batch\n   - Test for case to verify arrow's validity vector is set correctly when setArrowValidityVector = true\n2) Reuse container logic is now similar to row based read path\n3) We now always set the nullability holder. Arrow validity vector is set only for purpose of supplying complete arrow vectors when requested to do so.", "committedDate": "2020-06-12T09:39:22Z", "type": "forcePushed"}, {"oid": "6eee8a798219a09ed194a5f0abbbd09959936ef2", "url": "https://github.com/apache/iceberg/commit/6eee8a798219a09ed194a5f0abbbd09959936ef2", "message": "Cleanup and address code review comments.\n\nSummary of changes:\n1) Below new test cases added:\n   - Test for code path when optional values are mostly null\n   - Test for case when containers are not reused for every batch\n   - Test for case to verify arrow's validity vector is set correctly when setArrowValidityVector = true\n2) Reuse container logic is now similar to row based read path\n3) We now always set the nullability holder. Arrow validity vector is set only for purpose of supplying complete arrow vectors when requested to do so.", "committedDate": "2020-06-12T19:02:42Z", "type": "forcePushed"}]}