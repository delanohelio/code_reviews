{"pr_number": 10524, "pr_title": "Dynamic auto scale Kafka-Stream ingest tasks", "pr_author": "zhangyue19921010", "pr_createdAt": "2020-10-21T06:30:01Z", "pr_url": "https://github.com/apache/druid/pull/10524", "merge_commit": "bddacbb1c3abccf6ad035a4756a6960761fd43a2", "timeline": [{"oid": "f3d6422ae289fc3821e07c4ef9ed5810d67c9f64", "url": "https://github.com/apache/druid/commit/f3d6422ae289fc3821e07c4ef9ed5810d67c9f64", "message": "druid task auto scale based on kafka lag", "committedDate": "2020-10-20T06:41:04Z", "type": "commit"}, {"oid": "5c1c21c44c2737fe0e55405f863cfd8c93329213", "url": "https://github.com/apache/druid/commit/5c1c21c44c2737fe0e55405f863cfd8c93329213", "message": "fix kafkaSupervisorIOConfig and KinesisSupervisorIOConfig", "committedDate": "2020-10-21T03:25:00Z", "type": "commit"}, {"oid": "6d7582be1e9c423a50085b57a3a163a5166316f4", "url": "https://github.com/apache/druid/commit/6d7582be1e9c423a50085b57a3a163a5166316f4", "message": "druid task auto scale based on kafka lag", "committedDate": "2020-10-21T03:27:47Z", "type": "commit"}, {"oid": "16b07446ad051fd8277bdba14b9b3bde4bab247b", "url": "https://github.com/apache/druid/commit/16b07446ad051fd8277bdba14b9b3bde4bab247b", "message": "fix kafkaSupervisorIOConfig and KinesisSupervisorIOConfig", "committedDate": "2020-10-21T03:27:47Z", "type": "commit"}, {"oid": "07eb9c089b9ba751dcb4c3b55728c3486406b278", "url": "https://github.com/apache/druid/commit/07eb9c089b9ba751dcb4c3b55728c3486406b278", "message": "test dynamic auto scale done", "committedDate": "2020-10-21T03:28:36Z", "type": "commit"}, {"oid": "a041b44ec5d39aca60bb319b681d9c5edea7a455", "url": "https://github.com/apache/druid/commit/a041b44ec5d39aca60bb319b681d9c5edea7a455", "message": "auto scale tasks tested on prd cluster", "committedDate": "2020-10-21T03:30:26Z", "type": "commit"}, {"oid": "746b033327ef51dd74c811c369444e51bac785ca", "url": "https://github.com/apache/druid/commit/746b033327ef51dd74c811c369444e51bac785ca", "message": "auto scale tasks tested on prd cluster", "committedDate": "2020-10-21T03:32:06Z", "type": "commit"}, {"oid": "d25f94a593a7b47207db44a8df838bbea46d0793", "url": "https://github.com/apache/druid/commit/d25f94a593a7b47207db44a8df838bbea46d0793", "message": "auto scale tasks tested on prd cluster", "committedDate": "2020-10-21T03:33:04Z", "type": "commit"}, {"oid": "e7a1af1e97a8f693b8f43ef6a20cda5a735e7fa4", "url": "https://github.com/apache/druid/commit/e7a1af1e97a8f693b8f43ef6a20cda5a735e7fa4", "message": "modify code style to solve 29055.10 29055.9 29055.17 29055.18 29055.19 29055.20", "committedDate": "2020-10-22T10:56:00Z", "type": "commit"}, {"oid": "d53ea7680fc8137e7197b8d7fa7fd887c633d566", "url": "https://github.com/apache/druid/commit/d53ea7680fc8137e7197b8d7fa7fd887c633d566", "message": "Merge branch 'master' into kafka-dynamic-scale-ingest-tasks", "committedDate": "2020-10-22T11:04:43Z", "type": "commit"}, {"oid": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "url": "https://github.com/apache/druid/commit/78cbd45577dccc3abd39fb03db6d2a9298e6c252", "message": "rename test fiel function", "committedDate": "2020-10-23T04:54:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4Mjk4MQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r529982981", "body": "add comment stating why this is not implemented", "bodyText": "add comment stating why this is not implemented", "bodyHTML": "<p dir=\"auto\">add comment stating why this is not implemented</p>", "author": "capistrant", "createdAt": "2020-11-24T23:07:42Z", "path": "extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java", "diffHunk": "@@ -377,6 +377,11 @@ protected boolean useExclusiveStartSequenceNumberForNonFirstSequence()\n     return true;\n   }\n \n+  @Override\n+  protected void collectLag(ArrayList<Long> lags)\n+  {", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY2NzEzNA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531667134", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:39:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4Mjk4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\nindex a1f17c5da5..28272d41eb 100644\n--- a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\n+++ b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\n", "chunk": "@@ -377,6 +377,7 @@ public class KinesisSupervisor extends SeekableStreamSupervisor<String, String>\n     return true;\n   }\n \n+  // not yet supported, will be implemented in the future maybe? need to find a proper way to measure kinesis lag.\n   @Override\n   protected void collectLag(ArrayList<Long> lags)\n   {\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\nindex 28272d41eb..14fa97ffe4 100644\n--- a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\n+++ b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\n", "chunk": "@@ -379,7 +380,7 @@ public class KinesisSupervisor extends SeekableStreamSupervisor<String, String>\n \n   // not yet supported, will be implemented in the future maybe? need to find a proper way to measure kinesis lag.\n   @Override\n-  protected void collectLag(ArrayList<Long> lags)\n+  public void collectLag(ArrayList<Long> lags)\n   {\n   }\n \n", "next_change": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\nindex 14fa97ffe4..6d6bf99fe8 100644\n--- a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\n+++ b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\n", "chunk": "@@ -380,8 +381,9 @@ public class KinesisSupervisor extends SeekableStreamSupervisor<String, String,\n \n   // not yet supported, will be implemented in the future maybe? need to find a proper way to measure kinesis lag.\n   @Override\n-  public void collectLag(ArrayList<Long> lags)\n+  public LagStats computeLagStats()\n   {\n+    return null;\n   }\n \n   @Override\n", "next_change": {"commit": "1a9a09d05411476a27de69b0e22e8ddebe0d5f90", "changed_code": [{"header": "diff --git a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\nindex 6d6bf99fe8..92defd2315 100644\n--- a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\n+++ b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\n", "chunk": "@@ -383,7 +383,7 @@ public class KinesisSupervisor extends SeekableStreamSupervisor<String, String,\n   @Override\n   public LagStats computeLagStats()\n   {\n-    return null;\n+    throw new UnsupportedOperationException(\"Compute Lag Stats is not supported in KinesisSupervisor yet.\");\n   }\n \n   @Override\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4MzM3OA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r529983378", "body": "nit: remove empty line", "bodyText": "nit: remove empty line", "bodyHTML": "<p dir=\"auto\">nit: remove empty line</p>", "author": "capistrant", "createdAt": "2020-11-24T23:08:10Z", "path": "extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java", "diffHunk": "@@ -85,7 +88,9 @@ public KinesisSupervisorIOConfig(\n         completionTimeout,\n         lateMessageRejectionPeriod,\n         earlyMessageRejectionPeriod,\n+        dynamicAllocationTasksProperties,\n         lateMessageRejectionStartDateTime\n+", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY3MTg5NQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531671895", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4MzM3OA=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\nindex 885fb6e9f7..1316981865 100644\n--- a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n+++ b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n", "chunk": "@@ -90,7 +90,6 @@ public class KinesisSupervisorIOConfig extends SeekableStreamSupervisorIOConfig\n         earlyMessageRejectionPeriod,\n         dynamicAllocationTasksProperties,\n         lateMessageRejectionStartDateTime\n-\n     );\n     this.endpoint = endpoint != null\n                     ? endpoint\n", "next_change": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\nindex 1316981865..d6c2b37749 100644\n--- a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n+++ b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n", "chunk": "@@ -88,9 +88,16 @@ public class KinesisSupervisorIOConfig extends SeekableStreamSupervisorIOConfig\n         completionTimeout,\n         lateMessageRejectionPeriod,\n         earlyMessageRejectionPeriod,\n-        dynamicAllocationTasksProperties,\n+        null,\n         lateMessageRejectionStartDateTime\n     );\n+\n+    // for now dynamic Allocation Tasks is not supported here\n+    // throw UnsupportedOperationException in case someone sets this on a kinesis supervisor spec.\n+    if (autoscalerConfig != null || !autoscalerConfig.isEmpty()) {\n+      throw new UnsupportedOperationException(\"Dynamic Allocation Tasks is not supported here\");\n+    }\n+\n     this.endpoint = endpoint != null\n                     ? endpoint\n                     : (region != null ? region.getEndpoint() : KinesisRegion.US_EAST_1.getEndpoint());\n", "next_change": {"commit": "6bbbf297d1ab84b675d07108f554bd765206ff08", "changed_code": [{"header": "diff --git a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\nindex d6c2b37749..1460dc3d44 100644\n--- a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n+++ b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n", "chunk": "@@ -94,8 +94,8 @@ public class KinesisSupervisorIOConfig extends SeekableStreamSupervisorIOConfig\n \n     // for now dynamic Allocation Tasks is not supported here\n     // throw UnsupportedOperationException in case someone sets this on a kinesis supervisor spec.\n-    if (autoscalerConfig != null || !autoscalerConfig.isEmpty()) {\n-      throw new UnsupportedOperationException(\"Dynamic Allocation Tasks is not supported here\");\n+    if (autoscalerConfig != null) {\n+      throw new UnsupportedOperationException(\"Tasks auto scaler for kinesis is not supported yet.\");\n     }\n \n     this.endpoint = endpoint != null\n", "next_change": {"commit": "34c2785dd4973dc1fd34b6739464e228654f4d9f", "changed_code": [{"header": "diff --git a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\nindex 1460dc3d44..dac32e5197 100644\n--- a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n+++ b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n", "chunk": "@@ -95,7 +94,7 @@ public class KinesisSupervisorIOConfig extends SeekableStreamSupervisorIOConfig\n     // for now dynamic Allocation Tasks is not supported here\n     // throw UnsupportedOperationException in case someone sets this on a kinesis supervisor spec.\n     if (autoscalerConfig != null) {\n-      throw new UnsupportedOperationException(\"Tasks auto scaler for kinesis is not supported yet.\");\n+      throw new UnsupportedOperationException(\"Tasks auto scaler for kinesis is not supported yet. Please remove autoscalerConfig or set it null!\");\n     }\n \n     this.endpoint = endpoint != null\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\nindex dac32e5197..b43cece0e5 100644\n--- a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n+++ b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n", "chunk": "@@ -87,14 +89,14 @@ public class KinesisSupervisorIOConfig extends SeekableStreamSupervisorIOConfig\n         completionTimeout,\n         lateMessageRejectionPeriod,\n         earlyMessageRejectionPeriod,\n-        null,\n+        autoScalerConfig,\n         lateMessageRejectionStartDateTime\n     );\n \n     // for now dynamic Allocation Tasks is not supported here\n     // throw UnsupportedOperationException in case someone sets this on a kinesis supervisor spec.\n-    if (autoscalerConfig != null) {\n-      throw new UnsupportedOperationException(\"Tasks auto scaler for kinesis is not supported yet. Please remove autoscalerConfig or set it null!\");\n+    if (autoScalerConfig != null) {\n+      throw new UnsupportedOperationException(\"Tasks auto scaler for kinesis is not supported yet. Please remove autoScalerConfig or set it to null!\");\n     }\n \n     this.endpoint = endpoint != null\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4NDU1Ng==", "url": "https://github.com/apache/druid/pull/10524#discussion_r529984556", "body": "javadoc would be helpful as this is important/complex method", "bodyText": "javadoc would be helpful as this is important/complex method", "bodyHTML": "<p dir=\"auto\">javadoc would be helpful as this is important/complex method</p>", "author": "capistrant", "createdAt": "2020-11-24T23:09:29Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -317,6 +322,157 @@ public void handle()\n     }\n   }\n \n+  // same as submit supervisor logic\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    @Override\n+    public void handle()\n+    {\n+      lock.lock();\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        long minTriggerDynamicFrequency = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 1200000)));\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        // max(minTriggerDynamicFrequency, metricsCollectionRangeMillis)\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.info(\"PendingCompletionTaskGroups is : \" + pendingCompletionTaskGroups);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [\" + pendingCompletionTaskGroups + \"]\");\n+            return;\n+          }\n+        }\n+        if (nowTime - dynamicTriggerLastRunTime < minTriggerDynamicFrequency) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [\" + (nowTime - dynamicTriggerLastRunTime) + \"]. Defined minTriggerDynamicFrequency is [\" + minTriggerDynamicFrequency + \"] , CLAM DOWN NOW !\");\n+          return;\n+        }\n+        if (!queue.isAtFullCapacity()) {\n+          log.info(\"Metrics collection is not at full capacity, skip to check dynamic allocate task : [\" + queue.size() + \" vs \" + queue.maxSize() + \"]\");\n+          return;\n+        }\n+        List<Long> lags = collectTotalLags();\n+        boolean allocationSuccess = dynamicAllocate(lags);\n+        if (allocationSuccess) {\n+          dynamicTriggerLastRunTime = nowTime;\n+          queue.clear();\n+        }\n+      }\n+      catch (Exception e) {\n+        log.error(e, \"Error, when parse DynamicAllocationTasksNotice\");\n+      }\n+      finally {\n+        lock.unlock();\n+      }\n+    }\n+  }\n+\n+  private boolean dynamicAllocate(List<Long> lags) throws InterruptedException, ExecutionException, TimeoutException", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUwMTk5Mg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530501992", "bodyText": "logs added in this method should provide context about what supervisor they refer to. I also think we should evaluate what logs should be changed to debug too so limit the chattiness of info level", "author": "capistrant", "createdAt": "2020-11-25T16:30:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4NDU1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUwMjI3NA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530502274", "bodyText": "should the config defaults be instantiated as final constants at top of class?", "author": "capistrant", "createdAt": "2020-11-25T16:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4NDU1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY2NzU5MQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531667591", "bodyText": "All done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:40:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4NDU1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -322,46 +322,47 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n   }\n \n-  // same as submit supervisor logic\n+  // change taskCount without resubmitting.\n   private class DynamicAllocationTasksNotice implements Notice\n   {\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n     @Override\n     public void handle()\n     {\n       lock.lock();\n       try {\n         long nowTime = System.currentTimeMillis();\n-        long minTriggerDynamicFrequency = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 1200000)));\n         // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n-        // max(minTriggerDynamicFrequency, metricsCollectionRangeMillis)\n         if (spec.isSuspended()) {\n           log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n           return;\n         }\n-        log.info(\"PendingCompletionTaskGroups is : \" + pendingCompletionTaskGroups);\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n         for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n           if (!list.isEmpty()) {\n-            log.info(\"Still hand off tasks unfinished, skip to do scale action [\" + pendingCompletionTaskGroups + \"]\");\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n             return;\n           }\n         }\n         if (nowTime - dynamicTriggerLastRunTime < minTriggerDynamicFrequency) {\n-          log.info(\"NowTime - dynamicTriggerLastRunTime is [\" + (nowTime - dynamicTriggerLastRunTime) + \"]. Defined minTriggerDynamicFrequency is [\" + minTriggerDynamicFrequency + \"] , CLAM DOWN NOW !\");\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, minTriggerDynamicFrequency, dataSource);\n           return;\n         }\n-        if (!queue.isAtFullCapacity()) {\n-          log.info(\"Metrics collection is not at full capacity, skip to check dynamic allocate task : [\" + queue.size() + \" vs \" + queue.maxSize() + \"]\");\n+        if (!lagMetricsQueue.isAtFullCapacity()) {\n+          log.info(\"Metrics collection is not at full capacity, may cause unnecessary scale. Skip to check dynamic allocate task : [%s] vs [%s]\", lagMetricsQueue.size(), lagMetricsQueue.maxSize());\n           return;\n         }\n         List<Long> lags = collectTotalLags();\n         boolean allocationSuccess = dynamicAllocate(lags);\n         if (allocationSuccess) {\n           dynamicTriggerLastRunTime = nowTime;\n-          queue.clear();\n+          lagMetricsQueue.clear();\n         }\n       }\n       catch (Exception e) {\n-        log.error(e, \"Error, when parse DynamicAllocationTasksNotice\");\n+        log.warn(e, \"Error, when parse DynamicAllocationTasksNotice\");\n       }\n       finally {\n         lock.unlock();\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -350,98 +356,44 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n           log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, minTriggerDynamicFrequency, dataSource);\n           return;\n         }\n-        if (!lagMetricsQueue.isAtFullCapacity()) {\n-          log.info(\"Metrics collection is not at full capacity, may cause unnecessary scale. Skip to check dynamic allocate task : [%s] vs [%s]\", lagMetricsQueue.size(), lagMetricsQueue.maxSize());\n-          return;\n-        }\n-        List<Long> lags = collectTotalLags();\n-        boolean allocationSuccess = dynamicAllocate(lags);\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n         if (allocationSuccess) {\n           dynamicTriggerLastRunTime = nowTime;\n-          lagMetricsQueue.clear();\n         }\n       }\n-      catch (Exception e) {\n-        log.warn(e, \"Error, when parse DynamicAllocationTasksNotice\");\n-      }\n-      finally {\n-        lock.unlock();\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error, when parse DynamicAllocationTasksNotice\");\n       }\n     }\n   }\n \n   /**\n-   * This method determines whether and how to do scale actions based on collected lag points.\n-   * Current algorithm of scale is simple:\n-   *    First of all, compute the proportion of lag points higher/lower than scaleOutThreshold/scaleInThreshold, getting scaleOutThreshold/scaleInThreshold.\n-   *    Secondly, compare scaleOutThreshold/scaleInThreshold with triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency. P.S. Scale out action has higher priority than scale in action.\n-   *    Finaly, if scaleOutThreshold/scaleInThreshold is higher than triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency, scale out/in action would be triggered.\n+   * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n    * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param lags the lag metrics of Stream(Kafka/Kinesis)\n+   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n    * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(List<Long> lags) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n-    // if supervisor is not suspended, ensure required tasks are running\n-    // if suspended, ensure tasks have been requested to gracefully stop\n-    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic. Current collected lags : [%s]\", dataSource, lags);\n-    int beyond = 0;\n-    int within = 0;\n-    int metricsCount = lags.size();\n-    for (Long lag : lags) {\n-      if (lag >= scaleOutThreshold) {\n-        beyond++;\n-      }\n-      if (lag <= scaleInThreshold) {\n-        within++;\n-      }\n-    }\n-    double beyondProportion = beyond * 1.0 / metricsCount;\n-    double withinProportion = within * 1.0 / metricsCount;\n-    log.debug(\"triggerScaleOutThresholdFrequency is [%s] and triggerScaleInThresholdFrequency is [%s] for dataSource [%s].\", triggerScaleOutThresholdFrequency, triggerScaleInThresholdFrequency, dataSource);\n-    log.info(\"beyondProportion is [%s] and withinProportion is [%s] for dataSource [%s].\", beyondProportion, withinProportion, dataSource);\n-\n     int currentActiveTaskCount;\n-    int desireActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (beyondProportion >= triggerScaleOutThresholdFrequency) {\n-      // Do Scale out\n-      int taskCount = currentActiveTaskCount + scaleOutStep;\n-      if (currentActiveTaskCount == taskCountMax) {\n-        log.info(\"CurrentActiveTaskCount reach task count Max limit, skip to scale out tasks for dataSource [%s].\", dataSource);\n-        return false;\n-      } else {\n-        desireActiveTaskCount = Math.min(taskCount, taskCountMax);\n-      }\n-      log.debug(\"Start to scale out tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n-      gracefulShutdownInternal();\n-      // clear everything\n-      clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n-      return true;\n-    }\n-\n-    if (withinProportion >= triggerScaleInThresholdFrequency) {\n-      // Do Scale in\n-      int taskCount = currentActiveTaskCount - scaleInStep;\n-      if (currentActiveTaskCount == taskCountMin) {\n-        log.info(\"CurrentActiveTaskCount reach task count Min limit, skip to scale in tasks for dataSource [%s].\", dataSource);\n-        return false;\n-      } else {\n-        desireActiveTaskCount = Math.max(taskCount, taskCountMin);\n-      }\n-      log.debug(\"Start to scale in tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+    if (desireActiveTaskCount == -1) {\n+      return false;\n+    } else {\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n       // clear everything\n       clearAllocationInfos();\n", "next_change": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -376,36 +378,36 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desireActiveTaskCount == -1) {\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n       return true;\n     }\n   }\n \n-  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n   {\n-    ioConfig.setTaskCount(desireActiveTaskCount);\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n     try {\n       Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n       if (supervisorManager.isPresent()) {\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -414,7 +428,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n+        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -428,15 +426,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n-      log.warn(\"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n     }\n   }\n \n-  private void clearAllocationInfos()\n+  private void clearAllocationInfo()\n   {\n     activelyReadingTaskGroups.clear();\n     partitionGroups.clear();\n", "next_change": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -369,19 +370,29 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n   }\n \n+  /**\n+   * This method determines whether and how to do scale actions based on collected lag points.\n+   * Current algorithm of scale is simple:\n+   *    First of all, compute the proportion of lag points higher/lower than scaleOutThreshold/scaleInThreshold, getting scaleOutThreshold/scaleInThreshold.\n+   *    Secondly, compare scaleOutThreshold/scaleInThreshold with triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency. P.S. Scale out action has higher priority than scale in action.\n+   *    Finaly, if scaleOutThreshold/scaleInThreshold is higher than triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency, scale out/in action would be triggered.\n+   * If scale action is triggered :\n+   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n+   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n+   * @param lags the lag metrics of Stream(Kafka/Kinesis)\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n+   * @throws InterruptedException\n+   * @throws ExecutionException\n+   * @throws TimeoutException\n+   */\n   private boolean dynamicAllocate(List<Long> lags) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     // if supervisor is not suspended, ensure required tasks are running\n     // if suspended, ensure tasks have been requested to gracefully stop\n-    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic\", dataSource);\n-    long scaleOutThreshold = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleOutThreshold\", 5000000)));\n-    long scaleInThreshold = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleInThreshold\", 1000000)));\n-    double triggerSaleOutThresholdFrequency = Double.parseDouble(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"triggerSaleOutThresholdFrequency\", 0.3)));\n-    double triggerSaleInThresholdFrequency = Double.parseDouble(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"triggerSaleInThresholdFrequency\", 0.8)));\n-    int taskCountMax = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"taskCountMax\", 8)));\n-    int taskCountMin = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"taskCountMin\", 1)));\n-    int scaleInStep = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleInStep\", 1)));\n-    int scaleOutStep = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleOutStep\", 2)));\n+    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic. Current collected lags : [%s]\", dataSource, lags);\n     int beyond = 0;\n     int within = 0;\n     int metricsCount = lags.size();\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -350,98 +356,44 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n           log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, minTriggerDynamicFrequency, dataSource);\n           return;\n         }\n-        if (!lagMetricsQueue.isAtFullCapacity()) {\n-          log.info(\"Metrics collection is not at full capacity, may cause unnecessary scale. Skip to check dynamic allocate task : [%s] vs [%s]\", lagMetricsQueue.size(), lagMetricsQueue.maxSize());\n-          return;\n-        }\n-        List<Long> lags = collectTotalLags();\n-        boolean allocationSuccess = dynamicAllocate(lags);\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n         if (allocationSuccess) {\n           dynamicTriggerLastRunTime = nowTime;\n-          lagMetricsQueue.clear();\n         }\n       }\n-      catch (Exception e) {\n-        log.warn(e, \"Error, when parse DynamicAllocationTasksNotice\");\n-      }\n-      finally {\n-        lock.unlock();\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error, when parse DynamicAllocationTasksNotice\");\n       }\n     }\n   }\n \n   /**\n-   * This method determines whether and how to do scale actions based on collected lag points.\n-   * Current algorithm of scale is simple:\n-   *    First of all, compute the proportion of lag points higher/lower than scaleOutThreshold/scaleInThreshold, getting scaleOutThreshold/scaleInThreshold.\n-   *    Secondly, compare scaleOutThreshold/scaleInThreshold with triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency. P.S. Scale out action has higher priority than scale in action.\n-   *    Finaly, if scaleOutThreshold/scaleInThreshold is higher than triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency, scale out/in action would be triggered.\n+   * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n    * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param lags the lag metrics of Stream(Kafka/Kinesis)\n+   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n    * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(List<Long> lags) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n-    // if supervisor is not suspended, ensure required tasks are running\n-    // if suspended, ensure tasks have been requested to gracefully stop\n-    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic. Current collected lags : [%s]\", dataSource, lags);\n-    int beyond = 0;\n-    int within = 0;\n-    int metricsCount = lags.size();\n-    for (Long lag : lags) {\n-      if (lag >= scaleOutThreshold) {\n-        beyond++;\n-      }\n-      if (lag <= scaleInThreshold) {\n-        within++;\n-      }\n-    }\n-    double beyondProportion = beyond * 1.0 / metricsCount;\n-    double withinProportion = within * 1.0 / metricsCount;\n-    log.debug(\"triggerScaleOutThresholdFrequency is [%s] and triggerScaleInThresholdFrequency is [%s] for dataSource [%s].\", triggerScaleOutThresholdFrequency, triggerScaleInThresholdFrequency, dataSource);\n-    log.info(\"beyondProportion is [%s] and withinProportion is [%s] for dataSource [%s].\", beyondProportion, withinProportion, dataSource);\n-\n     int currentActiveTaskCount;\n-    int desireActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (beyondProportion >= triggerScaleOutThresholdFrequency) {\n-      // Do Scale out\n-      int taskCount = currentActiveTaskCount + scaleOutStep;\n-      if (currentActiveTaskCount == taskCountMax) {\n-        log.info(\"CurrentActiveTaskCount reach task count Max limit, skip to scale out tasks for dataSource [%s].\", dataSource);\n-        return false;\n-      } else {\n-        desireActiveTaskCount = Math.min(taskCount, taskCountMax);\n-      }\n-      log.debug(\"Start to scale out tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n-      gracefulShutdownInternal();\n-      // clear everything\n-      clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n-      return true;\n-    }\n-\n-    if (withinProportion >= triggerScaleInThresholdFrequency) {\n-      // Do Scale in\n-      int taskCount = currentActiveTaskCount - scaleInStep;\n-      if (currentActiveTaskCount == taskCountMin) {\n-        log.info(\"CurrentActiveTaskCount reach task count Min limit, skip to scale in tasks for dataSource [%s].\", dataSource);\n-        return false;\n-      } else {\n-        desireActiveTaskCount = Math.max(taskCount, taskCountMin);\n-      }\n-      log.debug(\"Start to scale in tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+    if (desireActiveTaskCount == -1) {\n+      return false;\n+    } else {\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n       // clear everything\n       clearAllocationInfos();\n", "next_change": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -376,36 +378,36 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desireActiveTaskCount == -1) {\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n       return true;\n     }\n   }\n \n-  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n   {\n-    ioConfig.setTaskCount(desireActiveTaskCount);\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n     try {\n       Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n       if (supervisorManager.isPresent()) {\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -414,7 +428,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n+        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -428,15 +426,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n-      log.warn(\"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n     }\n   }\n \n-  private void clearAllocationInfos()\n+  private void clearAllocationInfo()\n   {\n     activelyReadingTaskGroups.clear();\n     partitionGroups.clear();\n", "next_change": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4NDk2Ng==", "url": "https://github.com/apache/druid/pull/10524#discussion_r529984966", "body": "javadoc would be helpful as this is complex/important method override", "bodyText": "javadoc would be helpful as this is complex/important method override", "bodyHTML": "<p dir=\"auto\">javadoc would be helpful as this is complex/important method override</p>", "author": "capistrant", "createdAt": "2020-11-24T23:09:57Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -317,6 +322,157 @@ public void handle()\n     }\n   }\n \n+  // same as submit supervisor logic\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    @Override\n+    public void handle()", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUwMDM1OQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530500359", "bodyText": "also the logs added should add context about what supervisor is being logged. I think we should evaluate what logs should be changed to debug too so limit the chattiness of info level", "author": "capistrant", "createdAt": "2020-11-25T16:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4NDk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY2NzM3MQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531667371", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4NDk2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -322,46 +322,47 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n   }\n \n-  // same as submit supervisor logic\n+  // change taskCount without resubmitting.\n   private class DynamicAllocationTasksNotice implements Notice\n   {\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n     @Override\n     public void handle()\n     {\n       lock.lock();\n       try {\n         long nowTime = System.currentTimeMillis();\n-        long minTriggerDynamicFrequency = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 1200000)));\n         // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n-        // max(minTriggerDynamicFrequency, metricsCollectionRangeMillis)\n         if (spec.isSuspended()) {\n           log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n           return;\n         }\n-        log.info(\"PendingCompletionTaskGroups is : \" + pendingCompletionTaskGroups);\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n         for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n           if (!list.isEmpty()) {\n-            log.info(\"Still hand off tasks unfinished, skip to do scale action [\" + pendingCompletionTaskGroups + \"]\");\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n             return;\n           }\n         }\n         if (nowTime - dynamicTriggerLastRunTime < minTriggerDynamicFrequency) {\n-          log.info(\"NowTime - dynamicTriggerLastRunTime is [\" + (nowTime - dynamicTriggerLastRunTime) + \"]. Defined minTriggerDynamicFrequency is [\" + minTriggerDynamicFrequency + \"] , CLAM DOWN NOW !\");\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, minTriggerDynamicFrequency, dataSource);\n           return;\n         }\n-        if (!queue.isAtFullCapacity()) {\n-          log.info(\"Metrics collection is not at full capacity, skip to check dynamic allocate task : [\" + queue.size() + \" vs \" + queue.maxSize() + \"]\");\n+        if (!lagMetricsQueue.isAtFullCapacity()) {\n+          log.info(\"Metrics collection is not at full capacity, may cause unnecessary scale. Skip to check dynamic allocate task : [%s] vs [%s]\", lagMetricsQueue.size(), lagMetricsQueue.maxSize());\n           return;\n         }\n         List<Long> lags = collectTotalLags();\n         boolean allocationSuccess = dynamicAllocate(lags);\n         if (allocationSuccess) {\n           dynamicTriggerLastRunTime = nowTime;\n-          queue.clear();\n+          lagMetricsQueue.clear();\n         }\n       }\n       catch (Exception e) {\n-        log.error(e, \"Error, when parse DynamicAllocationTasksNotice\");\n+        log.warn(e, \"Error, when parse DynamicAllocationTasksNotice\");\n       }\n       finally {\n         lock.unlock();\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -350,98 +356,44 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n           log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, minTriggerDynamicFrequency, dataSource);\n           return;\n         }\n-        if (!lagMetricsQueue.isAtFullCapacity()) {\n-          log.info(\"Metrics collection is not at full capacity, may cause unnecessary scale. Skip to check dynamic allocate task : [%s] vs [%s]\", lagMetricsQueue.size(), lagMetricsQueue.maxSize());\n-          return;\n-        }\n-        List<Long> lags = collectTotalLags();\n-        boolean allocationSuccess = dynamicAllocate(lags);\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n         if (allocationSuccess) {\n           dynamicTriggerLastRunTime = nowTime;\n-          lagMetricsQueue.clear();\n         }\n       }\n-      catch (Exception e) {\n-        log.warn(e, \"Error, when parse DynamicAllocationTasksNotice\");\n-      }\n-      finally {\n-        lock.unlock();\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error, when parse DynamicAllocationTasksNotice\");\n       }\n     }\n   }\n \n   /**\n-   * This method determines whether and how to do scale actions based on collected lag points.\n-   * Current algorithm of scale is simple:\n-   *    First of all, compute the proportion of lag points higher/lower than scaleOutThreshold/scaleInThreshold, getting scaleOutThreshold/scaleInThreshold.\n-   *    Secondly, compare scaleOutThreshold/scaleInThreshold with triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency. P.S. Scale out action has higher priority than scale in action.\n-   *    Finaly, if scaleOutThreshold/scaleInThreshold is higher than triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency, scale out/in action would be triggered.\n+   * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n    * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param lags the lag metrics of Stream(Kafka/Kinesis)\n+   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n    * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(List<Long> lags) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n-    // if supervisor is not suspended, ensure required tasks are running\n-    // if suspended, ensure tasks have been requested to gracefully stop\n-    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic. Current collected lags : [%s]\", dataSource, lags);\n-    int beyond = 0;\n-    int within = 0;\n-    int metricsCount = lags.size();\n-    for (Long lag : lags) {\n-      if (lag >= scaleOutThreshold) {\n-        beyond++;\n-      }\n-      if (lag <= scaleInThreshold) {\n-        within++;\n-      }\n-    }\n-    double beyondProportion = beyond * 1.0 / metricsCount;\n-    double withinProportion = within * 1.0 / metricsCount;\n-    log.debug(\"triggerScaleOutThresholdFrequency is [%s] and triggerScaleInThresholdFrequency is [%s] for dataSource [%s].\", triggerScaleOutThresholdFrequency, triggerScaleInThresholdFrequency, dataSource);\n-    log.info(\"beyondProportion is [%s] and withinProportion is [%s] for dataSource [%s].\", beyondProportion, withinProportion, dataSource);\n-\n     int currentActiveTaskCount;\n-    int desireActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (beyondProportion >= triggerScaleOutThresholdFrequency) {\n-      // Do Scale out\n-      int taskCount = currentActiveTaskCount + scaleOutStep;\n-      if (currentActiveTaskCount == taskCountMax) {\n-        log.info(\"CurrentActiveTaskCount reach task count Max limit, skip to scale out tasks for dataSource [%s].\", dataSource);\n-        return false;\n-      } else {\n-        desireActiveTaskCount = Math.min(taskCount, taskCountMax);\n-      }\n-      log.debug(\"Start to scale out tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n-      gracefulShutdownInternal();\n-      // clear everything\n-      clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n-      return true;\n-    }\n-\n-    if (withinProportion >= triggerScaleInThresholdFrequency) {\n-      // Do Scale in\n-      int taskCount = currentActiveTaskCount - scaleInStep;\n-      if (currentActiveTaskCount == taskCountMin) {\n-        log.info(\"CurrentActiveTaskCount reach task count Min limit, skip to scale in tasks for dataSource [%s].\", dataSource);\n-        return false;\n-      } else {\n-        desireActiveTaskCount = Math.max(taskCount, taskCountMin);\n-      }\n-      log.debug(\"Start to scale in tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+    if (desireActiveTaskCount == -1) {\n+      return false;\n+    } else {\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n       // clear everything\n       clearAllocationInfos();\n", "next_change": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -376,36 +378,36 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desireActiveTaskCount == -1) {\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n       return true;\n     }\n   }\n \n-  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n   {\n-    ioConfig.setTaskCount(desireActiveTaskCount);\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n     try {\n       Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n       if (supervisorManager.isPresent()) {\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -414,7 +428,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n+        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -428,15 +426,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n-      log.warn(\"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n     }\n   }\n \n-  private void clearAllocationInfos()\n+  private void clearAllocationInfo()\n   {\n     activelyReadingTaskGroups.clear();\n     partitionGroups.clear();\n", "next_change": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4NjE2NQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r529986165", "body": "javadoc please", "bodyText": "javadoc please", "bodyHTML": "<p dir=\"auto\">javadoc please</p>", "author": "capistrant", "createdAt": "2020-11-24T23:11:10Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -3561,4 +3843,6 @@ protected void emitLag()\n    * sequences. In Kafka, start offsets are always inclusive.\n    */\n   protected abstract boolean useExclusiveStartSequenceNumberForNonFirstSequence();\n+\n+  protected abstract void collectLag(ArrayList<Long> lags);", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY3MDkxMg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531670912", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4NjE2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -3844,5 +3875,10 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    */\n   protected abstract boolean useExclusiveStartSequenceNumberForNonFirstSequence();\n \n+  /**\n+   * Collect maxLag, totalLag, avgLag into ArrayList<Long> lags\n+   * Only support Kafka ingestion so far.\n+   * @param lags , Notice : The order of values is maxLag, totalLag and avgLag.\n+   */\n   protected abstract void collectLag(ArrayList<Long> lags);\n }\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -3874,11 +3748,4 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    * sequences. In Kafka, start offsets are always inclusive.\n    */\n   protected abstract boolean useExclusiveStartSequenceNumberForNonFirstSequence();\n-\n-  /**\n-   * Collect maxLag, totalLag, avgLag into ArrayList<Long> lags\n-   * Only support Kafka ingestion so far.\n-   * @param lags , Notice : The order of values is maxLag, totalLag and avgLag.\n-   */\n-  protected abstract void collectLag(ArrayList<Long> lags);\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4Nzk2MA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r529987960", "body": "we need to document all of these new configs in kafka-ingestion.md in the `KafkaSupervisorIOConfig` section", "bodyText": "we need to document all of these new configs in kafka-ingestion.md in the KafkaSupervisorIOConfig section", "bodyHTML": "<p dir=\"auto\">we need to document all of these new configs in kafka-ingestion.md in the <code>KafkaSupervisorIOConfig</code> section</p>", "author": "capistrant", "createdAt": "2020-11-24T23:12:59Z", "path": "indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorStateTest.java", "diffHunk": "@@ -824,12 +827,32 @@ private static SeekableStreamSupervisorIOConfig getIOConfig()\n         false,\n         new Period(\"PT30M\"),\n         null,\n-        null, null\n+        null, getProperties(), null\n     )\n     {\n     };\n   }\n \n+  private static Map<String, Object> getProperties()\n+  {\n+    HashMap<String, Object> dynamicAllocationTasksProperties = new HashMap<>();", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY3MTI5MA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531671290", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:47:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk4Nzk2MA=="}], "type": "inlineReview", "revised_code": {"commit": "b3b75b20992d6a31e6c4012b6408eeaf03192c5b", "changed_code": [{"header": "diff --git a/indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorStateTest.java b/indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorStateTest.java\nindex e3d82c6d94..5d7e75d5b9 100644\n--- a/indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorStateTest.java\n+++ b/indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorStateTest.java\n", "chunk": "@@ -840,9 +840,9 @@ public class SeekableStreamSupervisorStateTest extends EasyMockSupport\n     dynamicAllocationTasksProperties.put(\"metricsCollectionIntervalMillis\", 500);\n     dynamicAllocationTasksProperties.put(\"metricsCollectionRangeMillis\", 500);\n     dynamicAllocationTasksProperties.put(\"scaleOutThreshold\", 5000000);\n-    dynamicAllocationTasksProperties.put(\"triggerSaleOutThresholdFrequency\", 0.3);\n+    dynamicAllocationTasksProperties.put(\"triggerScaleOutThresholdFrequency\", 0.3);\n     dynamicAllocationTasksProperties.put(\"scaleInThreshold\", 1000000);\n-    dynamicAllocationTasksProperties.put(\"triggerSaleInThresholdFrequency\", 0.8);\n+    dynamicAllocationTasksProperties.put(\"triggerScaleInThresholdFrequency\", 0.8);\n     dynamicAllocationTasksProperties.put(\"dynamicCheckStartDelayMillis\", 0);\n     dynamicAllocationTasksProperties.put(\"dynamicCheckPeriod\", 100);\n     dynamicAllocationTasksProperties.put(\"taskCountMax\", 8);\n", "next_change": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorStateTest.java b/indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorStateTest.java\nindex 5d7e75d5b9..2e15f04850 100644\n--- a/indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorStateTest.java\n+++ b/indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorStateTest.java\n", "chunk": "@@ -835,22 +837,22 @@ public class SeekableStreamSupervisorStateTest extends EasyMockSupport\n \n   private static Map<String, Object> getProperties()\n   {\n-    HashMap<String, Object> dynamicAllocationTasksProperties = new HashMap<>();\n-    dynamicAllocationTasksProperties.put(\"enableDynamicAllocationTasks\", true);\n-    dynamicAllocationTasksProperties.put(\"metricsCollectionIntervalMillis\", 500);\n-    dynamicAllocationTasksProperties.put(\"metricsCollectionRangeMillis\", 500);\n-    dynamicAllocationTasksProperties.put(\"scaleOutThreshold\", 5000000);\n-    dynamicAllocationTasksProperties.put(\"triggerScaleOutThresholdFrequency\", 0.3);\n-    dynamicAllocationTasksProperties.put(\"scaleInThreshold\", 1000000);\n-    dynamicAllocationTasksProperties.put(\"triggerScaleInThresholdFrequency\", 0.8);\n-    dynamicAllocationTasksProperties.put(\"dynamicCheckStartDelayMillis\", 0);\n-    dynamicAllocationTasksProperties.put(\"dynamicCheckPeriod\", 100);\n-    dynamicAllocationTasksProperties.put(\"taskCountMax\", 8);\n-    dynamicAllocationTasksProperties.put(\"taskCountMin\", 1);\n-    dynamicAllocationTasksProperties.put(\"scaleInStep\", 1);\n-    dynamicAllocationTasksProperties.put(\"scaleOutStep\", 2);\n-    dynamicAllocationTasksProperties.put(\"minTriggerDynamicFrequencyMillis\", 1200000);\n-    return dynamicAllocationTasksProperties;\n+    HashMap<String, Object> autoscalerConfig = new HashMap<>();\n+    autoscalerConfig.put(\"enableTaskAutoscaler\", true);\n+    autoscalerConfig.put(\"metricsCollectionIntervalMillis\", 500);\n+    autoscalerConfig.put(\"metricsCollectionRangeMillis\", 500);\n+    autoscalerConfig.put(\"scaleOutThreshold\", 5000000);\n+    autoscalerConfig.put(\"triggerScaleOutThresholdFrequency\", 0.3);\n+    autoscalerConfig.put(\"scaleInThreshold\", 1000000);\n+    autoscalerConfig.put(\"triggerScaleInThresholdFrequency\", 0.8);\n+    autoscalerConfig.put(\"dynamicCheckStartDelayMillis\", 0);\n+    autoscalerConfig.put(\"dynamicCheckPeriod\", 100);\n+    autoscalerConfig.put(\"taskCountMax\", 8);\n+    autoscalerConfig.put(\"taskCountMin\", 1);\n+    autoscalerConfig.put(\"scaleInStep\", 1);\n+    autoscalerConfig.put(\"scaleOutStep\", 2);\n+    autoscalerConfig.put(\"minTriggerDynamicFrequencyMillis\", 1200000);\n+    return autoscalerConfig;\n   }\n \n   private static SeekableStreamSupervisorTuningConfig getTuningConfig()\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorStateTest.java b/indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorStateTest.java\nindex 2e15f04850..62b20a0eb9 100644\n--- a/indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorStateTest.java\n+++ b/indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorStateTest.java\n", "chunk": "@@ -837,22 +838,22 @@ public class SeekableStreamSupervisorStateTest extends EasyMockSupport\n \n   private static Map<String, Object> getProperties()\n   {\n-    HashMap<String, Object> autoscalerConfig = new HashMap<>();\n-    autoscalerConfig.put(\"enableTaskAutoscaler\", true);\n-    autoscalerConfig.put(\"metricsCollectionIntervalMillis\", 500);\n-    autoscalerConfig.put(\"metricsCollectionRangeMillis\", 500);\n-    autoscalerConfig.put(\"scaleOutThreshold\", 5000000);\n-    autoscalerConfig.put(\"triggerScaleOutThresholdFrequency\", 0.3);\n-    autoscalerConfig.put(\"scaleInThreshold\", 1000000);\n-    autoscalerConfig.put(\"triggerScaleInThresholdFrequency\", 0.8);\n-    autoscalerConfig.put(\"dynamicCheckStartDelayMillis\", 0);\n-    autoscalerConfig.put(\"dynamicCheckPeriod\", 100);\n-    autoscalerConfig.put(\"taskCountMax\", 8);\n-    autoscalerConfig.put(\"taskCountMin\", 1);\n-    autoscalerConfig.put(\"scaleInStep\", 1);\n-    autoscalerConfig.put(\"scaleOutStep\", 2);\n-    autoscalerConfig.put(\"minTriggerDynamicFrequencyMillis\", 1200000);\n-    return autoscalerConfig;\n+    HashMap<String, Object> autoScalerConfig = new HashMap<>();\n+    autoScalerConfig.put(\"enableTaskAutoScaler\", true);\n+    autoScalerConfig.put(\"lagCollectionIntervalMillis\", 500);\n+    autoScalerConfig.put(\"lagCollectionRangeMillis\", 500);\n+    autoScalerConfig.put(\"scaleOutThreshold\", 5000000);\n+    autoScalerConfig.put(\"triggerScaleOutThresholdFrequency\", 0.3);\n+    autoScalerConfig.put(\"scaleInThreshold\", 1000000);\n+    autoScalerConfig.put(\"triggerScaleInThresholdFrequency\", 0.8);\n+    autoScalerConfig.put(\"scaleActionStartDelayMillis\", 0);\n+    autoScalerConfig.put(\"scaleActionPeriodMillis\", 100);\n+    autoScalerConfig.put(\"taskCountMax\", 8);\n+    autoScalerConfig.put(\"taskCountMin\", 1);\n+    autoScalerConfig.put(\"scaleInStep\", 1);\n+    autoScalerConfig.put(\"scaleOutStep\", 2);\n+    autoScalerConfig.put(\"minTriggerScaleActionFrequencyMillis\", 1200000);\n+    return autoScalerConfig;\n   }\n \n   private static SeekableStreamSupervisorTuningConfig getTuningConfig()\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwNTM0MA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530005340", "body": "what is the reasoning behind this default of 8?", "bodyText": "what is the reasoning behind this default of 8?", "bodyHTML": "<p dir=\"auto\">what is the reasoning behind this default of 8?</p>", "author": "capistrant", "createdAt": "2020-11-24T23:31:01Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -518,20 +684,52 @@ public SeekableStreamSupervisor(\n     this.useExclusiveStartingSequence = useExclusiveStartingSequence;\n     this.dataSource = spec.getDataSchema().getDataSource();\n     this.ioConfig = spec.getIoConfig();\n+    this.dynamicAllocationTasksProperties = ioConfig.getDynamicAllocationTasksProperties();\n+    log.info(\"Get dynamicAllocationTasksProperties from IOConfig : \" + dynamicAllocationTasksProperties);\n+\n+    if (dynamicAllocationTasksProperties != null && !dynamicAllocationTasksProperties.isEmpty() && Boolean.parseBoolean(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"enableDynamicAllocationTasks\", false)))) {\n+      log.info(\"EnableDynamicAllocationTasks for datasource \" + dataSource);\n+      this.enableDynamicAllocationTasks = true;\n+    } else {\n+      log.info(\"Disable Dynamic Allocate Tasks\");\n+      this.enableDynamicAllocationTasks = false;\n+    }\n+    int taskCountMax = 0;\n+    if (enableDynamicAllocationTasks) {\n+      this.metricsCollectionIntervalMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionIntervalMillis\", 10000)));\n+      this.metricsCollectionRangeMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionRangeMillis\", 6 * 10 * 1000)));\n+      int slots = (int) (metricsCollectionRangeMillis / metricsCollectionIntervalMillis) + 1;\n+      log.info(\" The interval of metrics collection is \" + metricsCollectionIntervalMillis + \", \" + metricsCollectionRangeMillis + \" timeRange will collect \" + slots + \" data points at most.\");\n+      this.queue = new CircularFifoQueue<>(slots);\n+      taskCountMax = Integer.parseInt(String.valueOf(this.dynamicAllocationTasksProperties.getOrDefault(\"taskCountMax\", 8)));", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY3NjIzMQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531676231", "bodyText": "We have deployed this auto scale feature on PRD environment for half a year. And it works stably and efficiently. The default values of all parameters are the best practice values continuously adjusted according to the online conditions. And the max number of ingest tasks in our cluster is 8. Just in case, maybe 4 is more reasonable, avoiding using up all resources. And users can set a larger value if 4 is not satisfied.", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwNTM0MA=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -685,26 +706,32 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     this.dataSource = spec.getDataSchema().getDataSource();\n     this.ioConfig = spec.getIoConfig();\n     this.dynamicAllocationTasksProperties = ioConfig.getDynamicAllocationTasksProperties();\n-    log.info(\"Get dynamicAllocationTasksProperties from IOConfig : \" + dynamicAllocationTasksProperties);\n-\n+    log.debug(\"Get dynamicAllocationTasksProperties from IOConfig : [%s] in [%s]\", dynamicAllocationTasksProperties, dataSource);\n     if (dynamicAllocationTasksProperties != null && !dynamicAllocationTasksProperties.isEmpty() && Boolean.parseBoolean(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"enableDynamicAllocationTasks\", false)))) {\n-      log.info(\"EnableDynamicAllocationTasks for datasource \" + dataSource);\n+      log.info(\"EnableDynamicAllocationTasks for datasource [%s]\", dataSource);\n       this.enableDynamicAllocationTasks = true;\n     } else {\n-      log.info(\"Disable Dynamic Allocate Tasks\");\n+      log.info(\"Disable dynamic allocate tasks for [%s]\", dataSource);\n       this.enableDynamicAllocationTasks = false;\n     }\n-    int taskCountMax = 0;\n     if (enableDynamicAllocationTasks) {\n-      this.metricsCollectionIntervalMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionIntervalMillis\", 10000)));\n-      this.metricsCollectionRangeMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionRangeMillis\", 6 * 10 * 1000)));\n+      this.metricsCollectionIntervalMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionIntervalMillis\", 30000)));\n+      this.metricsCollectionRangeMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionRangeMillis\", 600000)));\n       int slots = (int) (metricsCollectionRangeMillis / metricsCollectionIntervalMillis) + 1;\n-      log.info(\" The interval of metrics collection is \" + metricsCollectionIntervalMillis + \", \" + metricsCollectionRangeMillis + \" timeRange will collect \" + slots + \" data points at most.\");\n-      this.queue = new CircularFifoQueue<>(slots);\n-      taskCountMax = Integer.parseInt(String.valueOf(this.dynamicAllocationTasksProperties.getOrDefault(\"taskCountMax\", 8)));\n+      log.debug(\" The interval of metrics collection is [%s], [%s] timeRange will collect [%s] data points for dataSource [%s].\", metricsCollectionIntervalMillis, metricsCollectionRangeMillis, slots, dataSource);\n+      this.lagMetricsQueue = new CircularFifoQueue<>(slots);\n       this.dynamicCheckStartDelayMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"dynamicCheckStartDelayMillis\", 300000)));\n-      this.dynamicCheckPeriod = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"dynamicCheckPeriod\", 600000)));\n+      this.dynamicCheckPeriod = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"dynamicCheckPeriod\", 60000)));\n       this.metricsCollectionRangeMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionRangeMillis\", 600000)));\n+      this.scaleOutThreshold = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleOutThreshold\", 6000000)));\n+      this.scaleInThreshold = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleInThreshold\", 1000000)));\n+      this.triggerScaleOutThresholdFrequency = Double.parseDouble(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"triggerScaleOutThresholdFrequency\", 0.3)));\n+      this.triggerScaleInThresholdFrequency = Double.parseDouble(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"triggerScaleInThresholdFrequency\", 0.9)));\n+      this.taskCountMax = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"taskCountMax\", 4)));\n+      this.taskCountMin = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"taskCountMin\", 1)));\n+      this.scaleInStep = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleInStep\", 1)));\n+      this.scaleOutStep = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleOutStep\", 2)));\n+      this.minTriggerDynamicFrequency = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 600000)));\n     }\n \n     this.tuningConfig = spec.getTuningConfig();\n", "next_change": {"commit": "fb70688fa646c0d4826f1a8e224a76cf6a640427", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..54904e8b4a 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -737,11 +738,12 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     this.tuningConfig = spec.getTuningConfig();\n     this.taskTuningConfig = this.tuningConfig.convertToTaskTuningConfig();\n     this.supervisorId = supervisorId;\n-    this.exec = Execs.singleThreaded(supervisorId);\n-    this.scheduledExec = Execs.scheduledSingleThreaded(supervisorId + \"-Scheduler-%d\");\n-    this.reportingExec = Execs.scheduledSingleThreaded(supervisorId + \"-Reporting-%d\");\n-    this.allocationExec = Execs.scheduledSingleThreaded(supervisorId + \"-Allocation-%d\");\n-    this.lagComputationExec = Execs.scheduledSingleThreaded(supervisorId + \"-Computation-%d\");\n+    this.exec = Execs.singleThreaded(StringUtils.encodeForFormat(supervisorId));\n+    this.scheduledExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Scheduler-%d\");\n+    this.reportingExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Reporting-%d\");\n+    this.allocationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Allocation-%d\");\n+    this.lagComputationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Computation-%d\");\n+\n     this.stateManager = new SeekableStreamSupervisorStateManager(\n         spec.getSupervisorStateManagerConfig(),\n         spec.isSuspended()\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 54904e8b4a..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -741,8 +654,6 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     this.exec = Execs.singleThreaded(StringUtils.encodeForFormat(supervisorId));\n     this.scheduledExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Scheduler-%d\");\n     this.reportingExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Reporting-%d\");\n-    this.allocationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Allocation-%d\");\n-    this.lagComputationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Computation-%d\");\n \n     this.stateManager = new SeekableStreamSupervisorStateManager(\n         spec.getSupervisorStateManagerConfig(),\n", "next_change": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..0b5c238997 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -661,7 +665,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     );\n \n     int workerThreads;\n-    if (enableDynamicAllocationTasks) {\n+    if (enableTaskAutoscaler) {\n       workerThreads = (this.tuningConfig.getWorkerThreads() != null\n               ? this.tuningConfig.getWorkerThreads()\n               : Math.min(10, taskCountMax));\n", "next_change": {"commit": "25fec0ff18d0acb79734dd93bedccff3ab43308a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 0b5c238997..eb2797cc58 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -665,14 +651,27 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     );\n \n     int workerThreads;\n-    if (enableTaskAutoscaler) {\n+    int chatThreads;\n+    if (autoscalerConfigMap != null && !autoscalerConfigMap.isEmpty() && autoScalerConfig.getEnableTaskAutoscaler()) {\n+      log.info(\"enableTaskAutoscaler for datasource [%s]\", dataSource);\n+\n       workerThreads = (this.tuningConfig.getWorkerThreads() != null\n               ? this.tuningConfig.getWorkerThreads()\n-              : Math.min(10, taskCountMax));\n+              : Math.min(10, autoScalerConfig.getTaskCountMax()));\n+\n+      chatThreads = (this.tuningConfig.getChatThreads() != null\n+              ? this.tuningConfig.getChatThreads()\n+              : Math.min(10, autoScalerConfig.getTaskCountMax() * this.ioConfig.getReplicas()));\n     } else {\n+      log.info(\"Disable dynamic allocate tasks for [%s]\", dataSource);\n+\n       workerThreads = (this.tuningConfig.getWorkerThreads() != null\n               ? this.tuningConfig.getWorkerThreads()\n               : Math.min(10, this.ioConfig.getTaskCount()));\n+\n+      chatThreads = (this.tuningConfig.getChatThreads() != null\n+              ? this.tuningConfig.getChatThreads()\n+              : Math.min(10, this.ioConfig.getTaskCount() * this.ioConfig.getReplicas()));\n     }\n \n     this.workerExec = MoreExecutors.listeningDecorator(\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwNzEzMw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530007133", "body": "I don't think this log or the one below is needed since there aren't logs for the other Execs", "bodyText": "I don't think this log or the one below is needed since there aren't logs for the other Execs", "bodyHTML": "<p dir=\"auto\">I don't think this log or the one below is needed since there aren't logs for the other Execs</p>", "author": "capistrant", "createdAt": "2020-11-24T23:32:56Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -652,6 +857,11 @@ public void stop(boolean stopGracefully)\n       try {\n         scheduledExec.shutdownNow(); // stop recurring executions\n         reportingExec.shutdownNow();\n+        log.info(\"Shut Down allocationExec now\");", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY3NjYzNw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531676637", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwNzEzMw=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -857,9 +884,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       try {\n         scheduledExec.shutdownNow(); // stop recurring executions\n         reportingExec.shutdownNow();\n-        log.info(\"Shut Down allocationExec now\");\n         allocationExec.shutdownNow();\n-        log.info(\"Shut Down lagComputationExec now\");\n         lagComputationExec.shutdownNow();\n \n \n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -884,8 +809,6 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       try {\n         scheduledExec.shutdownNow(); // stop recurring executions\n         reportingExec.shutdownNow();\n-        allocationExec.shutdownNow();\n-        lagComputationExec.shutdownNow();\n \n \n         if (started) {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwOTU5Nw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530009597", "body": "is this supposed to be `collectAndComputeLags()`? As far as I can tell, the log on line 982 seems to suggest that is the name you may have meant to use", "bodyText": "is this supposed to be collectAndComputeLags()? As far as I can tell, the log on line 982 seems to suggest that is the name you may have meant to use", "bodyHTML": "<p dir=\"auto\">is this supposed to be <code>collectAndComputeLags()</code>? As far as I can tell, the log on line 982 seems to suggest that is the name you may have meant to use</p>", "author": "capistrant", "createdAt": "2020-11-24T23:35:38Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -791,6 +1016,38 @@ public void tryInit()\n     }\n   }\n \n+  private Runnable collectAndcollectLags()", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MDY2MQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530060661", "bodyText": "also, a javadoc would be helpful too if you don't mind", "author": "capistrant", "createdAt": "2020-11-25T02:05:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwOTU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY3NjkzOQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531676939", "bodyText": "Yes, collectAndComputeLags() is expected. Done :)", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwOTU5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -1016,7 +1041,11 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n   }\n \n-  private Runnable collectAndcollectLags()\n+  /**\n+   * This method compute current consume lags. Get the total lags of all partition and fill in lagMetricsQueue\n+   * @return a Runnbale object to do collect and compute action.\n+   */\n+  private Runnable collectAndComputeLags()\n   {\n     return new Runnable() {\n       @Override\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -1041,40 +948,10 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n   }\n \n-  /**\n-   * This method compute current consume lags. Get the total lags of all partition and fill in lagMetricsQueue\n-   * @return a Runnbale object to do collect and compute action.\n-   */\n-  private Runnable collectAndComputeLags()\n-  {\n-    return new Runnable() {\n-      @Override\n-      public void run()\n-      {\n-        lock.lock();\n-        try {\n-          if (!spec.isSuspended()) {\n-            ArrayList<Long> metricsInfo = new ArrayList<>(3);\n-            collectLag(metricsInfo);\n-            long totalLags = metricsInfo.size() < 3 ? 0 : metricsInfo.get(1);\n-            lagMetricsQueue.offer(totalLags > 0 ? totalLags : 0);\n-            log.debug(\"Current lag metric points [%s] for dataSource [%s].\", new ArrayList<>(lagMetricsQueue), dataSource);\n-          } else {\n-            log.debug(\"[%s] supervisor is suspended, skip to collect kafka lags\", dataSource);\n-          }\n-        }\n-        catch (Exception e) {\n-          log.warn(e, \"Error, When collect kafka lags\");\n-        }\n-        finally {\n-          lock.unlock();\n-        }\n-      }\n-    };\n-  }\n-  private Runnable buildDynamicAllocationTask()\n+  @Override\n+  public Runnable buildDynamicAllocationTask(Callable<Integer> scaleAction)\n   {\n-    return () -> notices.add(new DynamicAllocationTasksNotice());\n+    return () -> notices.add(new DynamicAllocationTasksNotice(scaleAction));\n   }\n \n   private Runnable buildRunTask()\n", "next_change": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..0b5c238997 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -948,7 +952,6 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n   }\n \n-  @Override\n   public Runnable buildDynamicAllocationTask(Callable<Integer> scaleAction)\n   {\n     return () -> notices.add(new DynamicAllocationTasksNotice(scaleAction));\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxOTc4Ng==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530019786", "body": "as your comment says below, this could be null. Should we annotate as nullable?", "bodyText": "as your comment says below, this could be null. Should we annotate as nullable?", "bodyHTML": "<p dir=\"auto\">as your comment says below, this could be null. Should we annotate as nullable?</p>", "author": "capistrant", "createdAt": "2020-11-24T23:55:28Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java", "diffHunk": "@@ -46,6 +48,7 @@\n   private final Optional<Duration> lateMessageRejectionPeriod;\n   private final Optional<Duration> earlyMessageRejectionPeriod;\n   private final Optional<DateTime> lateMessageRejectionStartDateTime;\n+  private final Map<String, Object> dynamicAllocationTasksProperties;", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY3NzI5Mw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531677293", "bodyText": "Of course.", "author": "zhangyue19921010", "createdAt": "2020-11-27T16:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxOTc4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\nindex 31dc360f17..80671c5eef 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n", "chunk": "@@ -48,7 +48,7 @@ public abstract class SeekableStreamSupervisorIOConfig\n   private final Optional<Duration> lateMessageRejectionPeriod;\n   private final Optional<Duration> earlyMessageRejectionPeriod;\n   private final Optional<DateTime> lateMessageRejectionStartDateTime;\n-  private final Map<String, Object> dynamicAllocationTasksProperties;\n+  @Nullable private final Map<String, Object> dynamicAllocationTasksProperties;\n \n   public SeekableStreamSupervisorIOConfig(\n       String stream,\n", "next_change": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\nindex 80671c5eef..754b1e7f08 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n", "chunk": "@@ -48,7 +48,7 @@ public abstract class SeekableStreamSupervisorIOConfig\n   private final Optional<Duration> lateMessageRejectionPeriod;\n   private final Optional<Duration> earlyMessageRejectionPeriod;\n   private final Optional<DateTime> lateMessageRejectionStartDateTime;\n-  @Nullable private final Map<String, Object> dynamicAllocationTasksProperties;\n+  @Nullable private final Map<String, Object> autoscalerConfig;\n \n   public SeekableStreamSupervisorIOConfig(\n       String stream,\n", "next_change": {"commit": "0733590862fa43068e19b15d85dc5507732f7620", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\nindex 754b1e7f08..ca25a16fe4 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n", "chunk": "@@ -48,7 +47,7 @@ public abstract class SeekableStreamSupervisorIOConfig\n   private final Optional<Duration> lateMessageRejectionPeriod;\n   private final Optional<Duration> earlyMessageRejectionPeriod;\n   private final Optional<DateTime> lateMessageRejectionStartDateTime;\n-  @Nullable private final Map<String, Object> autoscalerConfig;\n+  @Nullable private final AutoScalerConfig autoscalerConfig;\n \n   public SeekableStreamSupervisorIOConfig(\n       String stream,\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\nindex ca25a16fe4..3ed55ec1ec 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n", "chunk": "@@ -47,7 +47,7 @@ public abstract class SeekableStreamSupervisorIOConfig\n   private final Optional<Duration> lateMessageRejectionPeriod;\n   private final Optional<Duration> earlyMessageRejectionPeriod;\n   private final Optional<DateTime> lateMessageRejectionStartDateTime;\n-  @Nullable private final AutoScalerConfig autoscalerConfig;\n+  @Nullable private final AutoScalerConfig autoScalerConfig;\n \n   public SeekableStreamSupervisorIOConfig(\n       String stream,\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMDE0Nw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530020147", "body": "should this be annotated as nullable if the instance can be null as your comment in the constructor suggests?", "bodyText": "should this be annotated as nullable if the instance can be null as your comment in the constructor suggests?", "bodyHTML": "<p dir=\"auto\">should this be annotated as nullable if the instance can be null as your comment in the constructor suggests?</p>", "author": "capistrant", "createdAt": "2020-11-24T23:56:34Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java", "diffHunk": "@@ -113,12 +119,23 @@ public Integer getReplicas()\n     return replicas;\n   }\n \n+  @JsonProperty", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY3MDk5OA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531670998", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMDE0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\nindex 31dc360f17..80671c5eef 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n", "chunk": "@@ -119,6 +119,7 @@ public abstract class SeekableStreamSupervisorIOConfig\n     return replicas;\n   }\n \n+  @Nullable\n   @JsonProperty\n   public Map<String, Object> getDynamicAllocationTasksProperties()\n   {\n", "next_change": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\nindex 80671c5eef..754b1e7f08 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n", "chunk": "@@ -121,9 +121,9 @@ public abstract class SeekableStreamSupervisorIOConfig\n \n   @Nullable\n   @JsonProperty\n-  public Map<String, Object> getDynamicAllocationTasksProperties()\n+  public Map<String, Object> getautoscalerConfig()\n   {\n-    return dynamicAllocationTasksProperties;\n+    return autoscalerConfig;\n   }\n \n   @JsonProperty\n", "next_change": {"commit": "71bdfbbad7c8ff87de78d388dd65c2a25903ca3e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\nindex 754b1e7f08..92af2be818 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n", "chunk": "@@ -121,7 +121,7 @@ public abstract class SeekableStreamSupervisorIOConfig\n \n   @Nullable\n   @JsonProperty\n-  public Map<String, Object> getautoscalerConfig()\n+  public Map<String, Object> getAutoscalerConfig()\n   {\n     return autoscalerConfig;\n   }\n", "next_change": {"commit": "0733590862fa43068e19b15d85dc5507732f7620", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\nindex 92af2be818..ca25a16fe4 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n", "chunk": "@@ -121,7 +120,7 @@ public abstract class SeekableStreamSupervisorIOConfig\n \n   @Nullable\n   @JsonProperty\n-  public Map<String, Object> getAutoscalerConfig()\n+  public AutoScalerConfig getAutoscalerConfig()\n   {\n     return autoscalerConfig;\n   }\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\nindex ca25a16fe4..3ed55ec1ec 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorIOConfig.java\n", "chunk": "@@ -122,7 +127,7 @@ public abstract class SeekableStreamSupervisorIOConfig\n   @JsonProperty\n   public AutoScalerConfig getAutoscalerConfig()\n   {\n-    return autoscalerConfig;\n+    return autoScalerConfig;\n   }\n \n   @JsonProperty\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMTA5OA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530021098", "body": "pretty straightforward method, but a short javadoc would be nice since we are updating an important lag related object", "bodyText": "pretty straightforward method, but a short javadoc would be nice since we are updating an important lag related object", "bodyHTML": "<p dir=\"auto\">pretty straightforward method, but a short javadoc would be nice since we are updating an important lag related object</p>", "author": "capistrant", "createdAt": "2020-11-24T23:59:29Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -3526,6 +3789,25 @@ protected void emitLag()\n     }\n   }\n \n+\n+  protected void computeLags(Map<PartitionIdType, Long> partitionLags, ArrayList<Long> lags)", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY3MDg3Mg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531670872", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:46:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMTA5OA=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -3790,11 +3819,13 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n   }\n \n \n+  /**\n+   * This method compute maxLag, totalLag and avgLag then fill in 'lags'\n+   * @param partitionLags lags per partition\n+   * @param lags a arraylist in order of maxLag, totalLag and avgLag\n+   */\n   protected void computeLags(Map<PartitionIdType, Long> partitionLags, ArrayList<Long> lags)\n   {\n-    if (partitionLags == null) {\n-      return;\n-    }\n     long maxLag = 0, totalLag = 0, avgLag;\n     for (long lag : partitionLags.values()) {\n       if (lag > maxLag) {\n", "next_change": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..0b5c238997 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -3822,9 +3699,8 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n   /**\n    * This method compute maxLag, totalLag and avgLag then fill in 'lags'\n    * @param partitionLags lags per partition\n-   * @param lags a arraylist in order of maxLag, totalLag and avgLag\n    */\n-  protected void computeLags(Map<PartitionIdType, Long> partitionLags, ArrayList<Long> lags)\n+  protected LagStats computeLags(Map<PartitionIdType, Long> partitionLags)\n   {\n     long maxLag = 0, totalLag = 0, avgLag;\n     for (long lag : partitionLags.values()) {\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 0b5c238997..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -3697,7 +3696,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n \n \n   /**\n-   * This method compute maxLag, totalLag and avgLag then fill in 'lags'\n+   *  This method computes maxLag, totalLag and avgLag\n    * @param partitionLags lags per partition\n    */\n   protected LagStats computeLags(Map<PartitionIdType, Long> partitionLags)\n", "next_change": null}]}}, {"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..0b5c238997 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -3834,9 +3710,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       totalLag += lag;\n     }\n     avgLag = partitionLags.size() == 0 ? 0 : totalLag / partitionLags.size();\n-    lags.add(maxLag);\n-    lags.add(totalLag);\n-    lags.add(avgLag);\n+    return new LagStats(maxLag, totalLag, avgLag);\n   }\n \n   /**\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMjAwNQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530022005", "body": "what are the implications of this failing? we are catching and carrying on. Can anything negative come from that?", "bodyText": "what are the implications of this failing? we are catching and carrying on. Can anything negative come from that?", "bodyHTML": "<p dir=\"auto\">what are the implications of this failing? we are catching and carrying on. Can anything negative come from that?</p>", "author": "capistrant", "createdAt": "2020-11-25T00:02:23Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -1137,6 +1394,20 @@ public void gracefulShutdownInternal() throws ExecutionException, InterruptedExc\n   @VisibleForTesting\n   public void resetInternal(DataSourceMetadata dataSourceMetadata)\n   {\n+    // clear queue for kafka lags\n+    if (enableDynamicAllocationTasks && queue != null) {\n+      try {\n+        lock.lock();\n+        queue.clear();\n+      }\n+      catch (Exception e) {\n+        log.warn(e, \"Error,when clear queue in rest action\");", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY3MDgxMw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531670813", "bodyText": "If this clear action is failed. The collection of lag points may be not as accurate as expected. May interfere with scale action. But this failing rarely happens and the  impact is acceptable. Because scale action is graceful and no data will lose or duplicate.", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMjAwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -1395,10 +1424,10 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n   public void resetInternal(DataSourceMetadata dataSourceMetadata)\n   {\n     // clear queue for kafka lags\n-    if (enableDynamicAllocationTasks && queue != null) {\n+    if (enableDynamicAllocationTasks && lagMetricsQueue != null) {\n       try {\n         lock.lock();\n-        queue.clear();\n+        lagMetricsQueue.clear();\n       }\n       catch (Exception e) {\n         log.warn(e, \"Error,when clear queue in rest action\");\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -1423,20 +1301,6 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n   @VisibleForTesting\n   public void resetInternal(DataSourceMetadata dataSourceMetadata)\n   {\n-    // clear queue for kafka lags\n-    if (enableDynamicAllocationTasks && lagMetricsQueue != null) {\n-      try {\n-        lock.lock();\n-        lagMetricsQueue.clear();\n-      }\n-      catch (Exception e) {\n-        log.warn(e, \"Error,when clear queue in rest action\");\n-      }\n-      finally {\n-        lock.unlock();\n-      }\n-    }\n-\n     if (dataSourceMetadata == null) {\n       // Reset everything\n       boolean result = indexerMetadataStorageCoordinator.deleteDataSourceMetadata(dataSource);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMjIyMA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530022220", "body": "I think refactoring with a more descriptive name would be beneficial for readability ", "bodyText": "I think refactoring with a more descriptive name would be beneficial for readability", "bodyHTML": "<p dir=\"auto\">I think refactoring with a more descriptive name would be beneficial for readability</p>", "author": "capistrant", "createdAt": "2020-11-25T00:03:05Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -495,6 +655,12 @@ boolean isValidTaskGroup(int taskGroupId, @Nullable TaskGroup taskGroup)\n   private volatile boolean stopped = false;\n   private volatile boolean lifecycleStarted = false;\n   private final ServiceEmitter emitter;\n+  private final boolean enableDynamicAllocationTasks;\n+  private volatile long metricsCollectionIntervalMillis;\n+  private volatile long metricsCollectionRangeMillis;\n+  private volatile long dynamicCheckStartDelayMillis;\n+  private volatile long dynamicCheckPeriod;\n+  private volatile CircularFifoQueue<Long> queue;", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY3NzU5Mw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531677593", "bodyText": "Done. renamed as lagMetricsQueue", "author": "zhangyue19921010", "createdAt": "2020-11-27T16:01:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMjIyMA=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -656,11 +667,21 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n   private volatile boolean lifecycleStarted = false;\n   private final ServiceEmitter emitter;\n   private final boolean enableDynamicAllocationTasks;\n-  private volatile long metricsCollectionIntervalMillis;\n-  private volatile long metricsCollectionRangeMillis;\n-  private volatile long dynamicCheckStartDelayMillis;\n-  private volatile long dynamicCheckPeriod;\n-  private volatile CircularFifoQueue<Long> queue;\n+  private long metricsCollectionIntervalMillis;\n+  private long metricsCollectionRangeMillis;\n+  private long scaleOutThreshold;\n+  private double triggerScaleOutThresholdFrequency;\n+  private long scaleInThreshold;\n+  private double triggerScaleInThresholdFrequency;\n+  private long dynamicCheckStartDelayMillis;\n+  private long dynamicCheckPeriod;\n+  private int taskCountMax;\n+  private int taskCountMin;\n+  private int scaleInStep;\n+  private int scaleOutStep;\n+  private long minTriggerDynamicFrequency;\n+\n+  private volatile CircularFifoQueue<Long> lagMetricsQueue;\n \n   public SeekableStreamSupervisor(\n       final String supervisorId,\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -661,28 +605,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n   private int initRetryCounter = 0;\n   private volatile DateTime firstRunTime;\n   private volatile DateTime earlyStopTime = null;\n-  protected volatile RecordSupplier<PartitionIdType, SequenceOffsetType> recordSupplier;\n+  protected volatile RecordSupplier<PartitionIdType, SequenceOffsetType, RecordType> recordSupplier;\n   private volatile boolean started = false;\n   private volatile boolean stopped = false;\n   private volatile boolean lifecycleStarted = false;\n   private final ServiceEmitter emitter;\n   private final boolean enableDynamicAllocationTasks;\n-  private long metricsCollectionIntervalMillis;\n-  private long metricsCollectionRangeMillis;\n-  private long scaleOutThreshold;\n-  private double triggerScaleOutThresholdFrequency;\n-  private long scaleInThreshold;\n-  private double triggerScaleInThresholdFrequency;\n-  private long dynamicCheckStartDelayMillis;\n-  private long dynamicCheckPeriod;\n   private int taskCountMax;\n-  private int taskCountMin;\n-  private int scaleInStep;\n-  private int scaleOutStep;\n   private long minTriggerDynamicFrequency;\n \n-  private volatile CircularFifoQueue<Long> lagMetricsQueue;\n-\n   public SeekableStreamSupervisor(\n       final String supervisorId,\n       final TaskStorage taskStorage,\n", "next_change": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..0b5c238997 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -610,7 +614,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n   private volatile boolean stopped = false;\n   private volatile boolean lifecycleStarted = false;\n   private final ServiceEmitter emitter;\n-  private final boolean enableDynamicAllocationTasks;\n+  private final boolean enableTaskAutoscaler;\n   private int taskCountMax;\n   private long minTriggerDynamicFrequency;\n \n", "next_change": {"commit": "25fec0ff18d0acb79734dd93bedccff3ab43308a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 0b5c238997..eb2797cc58 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -614,9 +612,6 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n   private volatile boolean stopped = false;\n   private volatile boolean lifecycleStarted = false;\n   private final ServiceEmitter emitter;\n-  private final boolean enableTaskAutoscaler;\n-  private int taskCountMax;\n-  private long minTriggerDynamicFrequency;\n \n   public SeekableStreamSupervisor(\n       final String supervisorId,\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2NjEzNA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530066134", "body": "I think this method deserves a more specific name as it is actually re-submitting the supervisor. Perhaps `submitSupervisorWithTaskCount` or something of that sort?", "bodyText": "I think this method deserves a more specific name as it is actually re-submitting the supervisor. Perhaps submitSupervisorWithTaskCount or something of that sort?", "bodyHTML": "<p dir=\"auto\">I think this method deserves a more specific name as it is actually re-submitting the supervisor. Perhaps <code>submitSupervisorWithTaskCount</code> or something of that sort?</p>", "author": "capistrant", "createdAt": "2020-11-25T02:23:59Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -317,6 +322,157 @@ public void handle()\n     }\n   }\n \n+  // same as submit supervisor logic\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    @Override\n+    public void handle()\n+    {\n+      lock.lock();\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        long minTriggerDynamicFrequency = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 1200000)));\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        // max(minTriggerDynamicFrequency, metricsCollectionRangeMillis)\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.info(\"PendingCompletionTaskGroups is : \" + pendingCompletionTaskGroups);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [\" + pendingCompletionTaskGroups + \"]\");\n+            return;\n+          }\n+        }\n+        if (nowTime - dynamicTriggerLastRunTime < minTriggerDynamicFrequency) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [\" + (nowTime - dynamicTriggerLastRunTime) + \"]. Defined minTriggerDynamicFrequency is [\" + minTriggerDynamicFrequency + \"] , CLAM DOWN NOW !\");\n+          return;\n+        }\n+        if (!queue.isAtFullCapacity()) {\n+          log.info(\"Metrics collection is not at full capacity, skip to check dynamic allocate task : [\" + queue.size() + \" vs \" + queue.maxSize() + \"]\");\n+          return;\n+        }\n+        List<Long> lags = collectTotalLags();\n+        boolean allocationSuccess = dynamicAllocate(lags);\n+        if (allocationSuccess) {\n+          dynamicTriggerLastRunTime = nowTime;\n+          queue.clear();\n+        }\n+      }\n+      catch (Exception e) {\n+        log.error(e, \"Error, when parse DynamicAllocationTasksNotice\");\n+      }\n+      finally {\n+        lock.unlock();\n+      }\n+    }\n+  }\n+\n+  private boolean dynamicAllocate(List<Long> lags) throws InterruptedException, ExecutionException, TimeoutException\n+  {\n+    // if supervisor is not suspended, ensure required tasks are running\n+    // if suspended, ensure tasks have been requested to gracefully stop\n+    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic\", dataSource);\n+    long scaleOutThreshold = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleOutThreshold\", 5000000)));\n+    long scaleInThreshold = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleInThreshold\", 1000000)));\n+    double triggerSaleOutThresholdFrequency = Double.parseDouble(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"triggerSaleOutThresholdFrequency\", 0.3)));\n+    double triggerSaleInThresholdFrequency = Double.parseDouble(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"triggerSaleInThresholdFrequency\", 0.8)));\n+    int taskCountMax = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"taskCountMax\", 8)));\n+    int taskCountMin = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"taskCountMin\", 1)));\n+    int scaleInStep = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleInStep\", 1)));\n+    int scaleOutStep = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleOutStep\", 2)));\n+    int beyond = 0;\n+    int within = 0;\n+    int metricsCount = lags.size();\n+    for (Long lag : lags) {\n+      if (lag >= scaleOutThreshold) {\n+        beyond++;\n+      }\n+      if (lag <= scaleInThreshold) {\n+        within++;\n+      }\n+    }\n+    double beyondProportion = beyond * 1.0 / metricsCount;\n+    double withinProportion = within * 1.0 / metricsCount;\n+    log.info(\"triggerSaleOutThresholdFrequency is [ \" + triggerSaleOutThresholdFrequency + \" ] and triggerSaleInThresholdFrequency is [ \" + triggerSaleInThresholdFrequency + \" ]\");\n+    log.info(\"beyondProportion is [ \" + beyondProportion + \" ] and withinProportion is [ \" + withinProportion + \" ]\");\n+\n+    int currentActiveTaskCount;\n+    int desireActiveTaskCount;\n+    Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n+    currentActiveTaskCount = activeTaskGroups.size();\n+\n+    if (beyondProportion >= triggerSaleOutThresholdFrequency) {\n+      // Do Scale out\n+      int taskCount = currentActiveTaskCount + scaleOutStep;\n+      if (currentActiveTaskCount == taskCountMax) {\n+        log.info(\"CurrentActiveTaskCount reach task count Max limit, skip to scale out tasks\");\n+        return false;\n+      } else {\n+        desireActiveTaskCount = Math.min(taskCount, taskCountMax);\n+      }\n+      log.info(\"Start to scale out tasks , current active task number [ \" + currentActiveTaskCount + \" ] and desire task number is [ \" + desireActiveTaskCount + \" ] \");\n+      gracefulShutdownInternal();\n+      // clear everything\n+      clearAllocationInfos();\n+      log.info(\"Set Task Count : \" + desireActiveTaskCount);\n+      setTaskCount(desireActiveTaskCount);\n+      return true;\n+    }\n+\n+    if (withinProportion >= triggerSaleInThresholdFrequency) {\n+      // Do Scale in\n+      int taskCount = currentActiveTaskCount - scaleInStep;\n+      if (currentActiveTaskCount == taskCountMin) {\n+        log.info(\"CurrentActiveTaskCount reach task count Min limit, skip to scale in tasks\");\n+        return false;\n+      } else {\n+        desireActiveTaskCount = Math.max(taskCount, taskCountMin);\n+      }\n+      log.info(\"Start to scale in tasks , current active task number [ \" + currentActiveTaskCount + \" ] and desire task number is [ \" + desireActiveTaskCount + \" ] \");\n+      gracefulShutdownInternal();\n+      // clear everything\n+      clearAllocationInfos();\n+      log.info(\"Set Task Count : \" + desireActiveTaskCount);\n+      setTaskCount(desireActiveTaskCount);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private void setTaskCount(int desireActiveTaskCount)", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUwOTQyMg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530509422", "bodyText": "what are the consequences of failure at this point? we have called gracefulShutdownInternal so I assume we will be left with no active supervisor for the datasource?", "author": "capistrant", "createdAt": "2020-11-25T16:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2NjEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4MDU2Mw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531680563", "bodyText": "renamed as changeTaskCountInIOConfig\nthe method gracefulShutdownInternal will not suspend the supervisor. It will make the ingest tasks stop reading and start to publish data. So that whether the func fails or not, the supervisor is always active. What's more, if this func failed, current scale action will be canceled. And will try another scale action in dynamicCheckPeriod.", "author": "zhangyue19921010", "createdAt": "2020-11-27T16:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2NjEzNA=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -395,53 +406,53 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n     double beyondProportion = beyond * 1.0 / metricsCount;\n     double withinProportion = within * 1.0 / metricsCount;\n-    log.info(\"triggerSaleOutThresholdFrequency is [ \" + triggerSaleOutThresholdFrequency + \" ] and triggerSaleInThresholdFrequency is [ \" + triggerSaleInThresholdFrequency + \" ]\");\n-    log.info(\"beyondProportion is [ \" + beyondProportion + \" ] and withinProportion is [ \" + withinProportion + \" ]\");\n+    log.debug(\"triggerScaleOutThresholdFrequency is [%s] and triggerScaleInThresholdFrequency is [%s] for dataSource [%s].\", triggerScaleOutThresholdFrequency, triggerScaleInThresholdFrequency, dataSource);\n+    log.info(\"beyondProportion is [%s] and withinProportion is [%s] for dataSource [%s].\", beyondProportion, withinProportion, dataSource);\n \n     int currentActiveTaskCount;\n     int desireActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (beyondProportion >= triggerSaleOutThresholdFrequency) {\n+    if (beyondProportion >= triggerScaleOutThresholdFrequency) {\n       // Do Scale out\n       int taskCount = currentActiveTaskCount + scaleOutStep;\n       if (currentActiveTaskCount == taskCountMax) {\n-        log.info(\"CurrentActiveTaskCount reach task count Max limit, skip to scale out tasks\");\n+        log.info(\"CurrentActiveTaskCount reach task count Max limit, skip to scale out tasks for dataSource [%s].\", dataSource);\n         return false;\n       } else {\n         desireActiveTaskCount = Math.min(taskCount, taskCountMax);\n       }\n-      log.info(\"Start to scale out tasks , current active task number [ \" + currentActiveTaskCount + \" ] and desire task number is [ \" + desireActiveTaskCount + \" ] \");\n+      log.debug(\"Start to scale out tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Set Task Count : \" + desireActiveTaskCount);\n-      setTaskCount(desireActiveTaskCount);\n+      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n+      changeTaskCountInIOConfig(desireActiveTaskCount);\n       return true;\n     }\n \n-    if (withinProportion >= triggerSaleInThresholdFrequency) {\n+    if (withinProportion >= triggerScaleInThresholdFrequency) {\n       // Do Scale in\n       int taskCount = currentActiveTaskCount - scaleInStep;\n       if (currentActiveTaskCount == taskCountMin) {\n-        log.info(\"CurrentActiveTaskCount reach task count Min limit, skip to scale in tasks\");\n+        log.info(\"CurrentActiveTaskCount reach task count Min limit, skip to scale in tasks for dataSource [%s].\", dataSource);\n         return false;\n       } else {\n         desireActiveTaskCount = Math.max(taskCount, taskCountMin);\n       }\n-      log.info(\"Start to scale in tasks , current active task number [ \" + currentActiveTaskCount + \" ] and desire task number is [ \" + desireActiveTaskCount + \" ] \");\n+      log.debug(\"Start to scale in tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Set Task Count : \" + desireActiveTaskCount);\n-      setTaskCount(desireActiveTaskCount);\n+      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n+      changeTaskCountInIOConfig(desireActiveTaskCount);\n       return true;\n     }\n     return false;\n   }\n \n-  private void setTaskCount(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n   {\n     ioConfig.setTaskCount(desireActiveTaskCount);\n     try {\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -449,7 +401,6 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       changeTaskCountInIOConfig(desireActiveTaskCount);\n       return true;\n     }\n-    return false;\n   }\n \n   private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n", "next_change": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -376,36 +378,36 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desireActiveTaskCount == -1) {\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n       return true;\n     }\n   }\n \n-  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n   {\n-    ioConfig.setTaskCount(desireActiveTaskCount);\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n     try {\n       Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n       if (supervisorManager.isPresent()) {\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -414,7 +428,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n+        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -428,15 +426,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n-      log.warn(\"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n     }\n   }\n \n-  private void clearAllocationInfos()\n+  private void clearAllocationInfo()\n   {\n     activelyReadingTaskGroups.clear();\n     partitionGroups.clear();\n", "next_change": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5NjU5Mw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530496593", "body": "same thought about debug level and context about the supervisor it is referring to", "bodyText": "same thought about debug level and context about the supervisor it is referring to", "bodyHTML": "<p dir=\"auto\">same thought about debug level and context about the supervisor it is referring to</p>", "author": "capistrant", "createdAt": "2020-11-25T16:22:16Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -518,20 +684,52 @@ public SeekableStreamSupervisor(\n     this.useExclusiveStartingSequence = useExclusiveStartingSequence;\n     this.dataSource = spec.getDataSchema().getDataSource();\n     this.ioConfig = spec.getIoConfig();\n+    this.dynamicAllocationTasksProperties = ioConfig.getDynamicAllocationTasksProperties();\n+    log.info(\"Get dynamicAllocationTasksProperties from IOConfig : \" + dynamicAllocationTasksProperties);\n+\n+    if (dynamicAllocationTasksProperties != null && !dynamicAllocationTasksProperties.isEmpty() && Boolean.parseBoolean(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"enableDynamicAllocationTasks\", false)))) {\n+      log.info(\"EnableDynamicAllocationTasks for datasource \" + dataSource);\n+      this.enableDynamicAllocationTasks = true;\n+    } else {\n+      log.info(\"Disable Dynamic Allocate Tasks\");\n+      this.enableDynamicAllocationTasks = false;\n+    }\n+    int taskCountMax = 0;\n+    if (enableDynamicAllocationTasks) {\n+      this.metricsCollectionIntervalMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionIntervalMillis\", 10000)));\n+      this.metricsCollectionRangeMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionRangeMillis\", 6 * 10 * 1000)));\n+      int slots = (int) (metricsCollectionRangeMillis / metricsCollectionIntervalMillis) + 1;\n+      log.info(\" The interval of metrics collection is \" + metricsCollectionIntervalMillis + \", \" + metricsCollectionRangeMillis + \" timeRange will collect \" + slots + \" data points at most.\");\n+      this.queue = new CircularFifoQueue<>(slots);\n+      taskCountMax = Integer.parseInt(String.valueOf(this.dynamicAllocationTasksProperties.getOrDefault(\"taskCountMax\", 8)));\n+      this.dynamicCheckStartDelayMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"dynamicCheckStartDelayMillis\", 300000)));\n+      this.dynamicCheckPeriod = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"dynamicCheckPeriod\", 600000)));\n+      this.metricsCollectionRangeMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionRangeMillis\", 600000)));\n+    }\n+\n     this.tuningConfig = spec.getTuningConfig();\n     this.taskTuningConfig = this.tuningConfig.convertToTaskTuningConfig();\n     this.supervisorId = supervisorId;\n     this.exec = Execs.singleThreaded(supervisorId);\n     this.scheduledExec = Execs.scheduledSingleThreaded(supervisorId + \"-Scheduler-%d\");\n     this.reportingExec = Execs.scheduledSingleThreaded(supervisorId + \"-Reporting-%d\");\n+    this.allocationExec = Execs.scheduledSingleThreaded(supervisorId + \"-Allocation-%d\");\n+    this.lagComputationExec = Execs.scheduledSingleThreaded(supervisorId + \"-Computation-%d\");\n     this.stateManager = new SeekableStreamSupervisorStateManager(\n         spec.getSupervisorStateManagerConfig(),\n         spec.isSuspended()\n     );\n \n-    int workerThreads = (this.tuningConfig.getWorkerThreads() != null\n-                         ? this.tuningConfig.getWorkerThreads()\n-                         : Math.min(10, this.ioConfig.getTaskCount()));\n+    int workerThreads;\n+    if (enableDynamicAllocationTasks) {\n+      workerThreads = (this.tuningConfig.getWorkerThreads() != null\n+              ? this.tuningConfig.getWorkerThreads()\n+              : Math.min(10, taskCountMax));\n+    } else {\n+      workerThreads = (this.tuningConfig.getWorkerThreads() != null\n+              ? this.tuningConfig.getWorkerThreads()\n+              : Math.min(10, this.ioConfig.getTaskCount()));\n+    }\n \n     this.workerExec = MoreExecutors.listeningDecorator(Execs.multiThreaded(workerThreads, supervisorId + \"-Worker-%d\"));\n     log.info(\"Created worker pool with [%d] threads for dataSource [%s]\", workerThreads, this.dataSource);", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY2NzgyMQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531667821", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:40:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5NjU5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "fb70688fa646c0d4826f1a8e224a76cf6a640427", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..54904e8b4a 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -731,7 +760,12 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n               : Math.min(10, this.ioConfig.getTaskCount()));\n     }\n \n-    this.workerExec = MoreExecutors.listeningDecorator(Execs.multiThreaded(workerThreads, supervisorId + \"-Worker-%d\"));\n+    this.workerExec = MoreExecutors.listeningDecorator(\n+        Execs.multiThreaded(\n+            workerThreads,\n+            StringUtils.encodeForFormat(supervisorId) + \"-Worker-%d\"\n+        )\n+    );\n     log.info(\"Created worker pool with [%d] threads for dataSource [%s]\", workerThreads, this.dataSource);\n \n     this.taskInfoProvider = new TaskInfoProvider()\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5ODUwMg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530498502", "body": "wondering if it would be better to have all these defaults be final constants instantiated at top of class for easy reference?", "bodyText": "wondering if it would be better to have all these defaults be final constants instantiated at top of class for easy reference?", "bodyHTML": "<p dir=\"auto\">wondering if it would be better to have all these defaults be final constants instantiated at top of class for easy reference?</p>", "author": "capistrant", "createdAt": "2020-11-25T16:25:06Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -518,20 +684,52 @@ public SeekableStreamSupervisor(\n     this.useExclusiveStartingSequence = useExclusiveStartingSequence;\n     this.dataSource = spec.getDataSchema().getDataSource();\n     this.ioConfig = spec.getIoConfig();\n+    this.dynamicAllocationTasksProperties = ioConfig.getDynamicAllocationTasksProperties();\n+    log.info(\"Get dynamicAllocationTasksProperties from IOConfig : \" + dynamicAllocationTasksProperties);\n+\n+    if (dynamicAllocationTasksProperties != null && !dynamicAllocationTasksProperties.isEmpty() && Boolean.parseBoolean(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"enableDynamicAllocationTasks\", false)))) {\n+      log.info(\"EnableDynamicAllocationTasks for datasource \" + dataSource);\n+      this.enableDynamicAllocationTasks = true;\n+    } else {\n+      log.info(\"Disable Dynamic Allocate Tasks\");\n+      this.enableDynamicAllocationTasks = false;\n+    }\n+    int taskCountMax = 0;\n+    if (enableDynamicAllocationTasks) {\n+      this.metricsCollectionIntervalMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionIntervalMillis\", 10000)));", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4NjcwNw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531686707", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T16:23:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5ODUwMg=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -685,26 +706,32 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     this.dataSource = spec.getDataSchema().getDataSource();\n     this.ioConfig = spec.getIoConfig();\n     this.dynamicAllocationTasksProperties = ioConfig.getDynamicAllocationTasksProperties();\n-    log.info(\"Get dynamicAllocationTasksProperties from IOConfig : \" + dynamicAllocationTasksProperties);\n-\n+    log.debug(\"Get dynamicAllocationTasksProperties from IOConfig : [%s] in [%s]\", dynamicAllocationTasksProperties, dataSource);\n     if (dynamicAllocationTasksProperties != null && !dynamicAllocationTasksProperties.isEmpty() && Boolean.parseBoolean(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"enableDynamicAllocationTasks\", false)))) {\n-      log.info(\"EnableDynamicAllocationTasks for datasource \" + dataSource);\n+      log.info(\"EnableDynamicAllocationTasks for datasource [%s]\", dataSource);\n       this.enableDynamicAllocationTasks = true;\n     } else {\n-      log.info(\"Disable Dynamic Allocate Tasks\");\n+      log.info(\"Disable dynamic allocate tasks for [%s]\", dataSource);\n       this.enableDynamicAllocationTasks = false;\n     }\n-    int taskCountMax = 0;\n     if (enableDynamicAllocationTasks) {\n-      this.metricsCollectionIntervalMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionIntervalMillis\", 10000)));\n-      this.metricsCollectionRangeMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionRangeMillis\", 6 * 10 * 1000)));\n+      this.metricsCollectionIntervalMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionIntervalMillis\", 30000)));\n+      this.metricsCollectionRangeMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionRangeMillis\", 600000)));\n       int slots = (int) (metricsCollectionRangeMillis / metricsCollectionIntervalMillis) + 1;\n-      log.info(\" The interval of metrics collection is \" + metricsCollectionIntervalMillis + \", \" + metricsCollectionRangeMillis + \" timeRange will collect \" + slots + \" data points at most.\");\n-      this.queue = new CircularFifoQueue<>(slots);\n-      taskCountMax = Integer.parseInt(String.valueOf(this.dynamicAllocationTasksProperties.getOrDefault(\"taskCountMax\", 8)));\n+      log.debug(\" The interval of metrics collection is [%s], [%s] timeRange will collect [%s] data points for dataSource [%s].\", metricsCollectionIntervalMillis, metricsCollectionRangeMillis, slots, dataSource);\n+      this.lagMetricsQueue = new CircularFifoQueue<>(slots);\n       this.dynamicCheckStartDelayMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"dynamicCheckStartDelayMillis\", 300000)));\n-      this.dynamicCheckPeriod = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"dynamicCheckPeriod\", 600000)));\n+      this.dynamicCheckPeriod = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"dynamicCheckPeriod\", 60000)));\n       this.metricsCollectionRangeMillis = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"metricsCollectionRangeMillis\", 600000)));\n+      this.scaleOutThreshold = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleOutThreshold\", 6000000)));\n+      this.scaleInThreshold = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleInThreshold\", 1000000)));\n+      this.triggerScaleOutThresholdFrequency = Double.parseDouble(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"triggerScaleOutThresholdFrequency\", 0.3)));\n+      this.triggerScaleInThresholdFrequency = Double.parseDouble(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"triggerScaleInThresholdFrequency\", 0.9)));\n+      this.taskCountMax = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"taskCountMax\", 4)));\n+      this.taskCountMin = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"taskCountMin\", 1)));\n+      this.scaleInStep = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleInStep\", 1)));\n+      this.scaleOutStep = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleOutStep\", 2)));\n+      this.minTriggerDynamicFrequency = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 600000)));\n     }\n \n     this.tuningConfig = spec.getTuningConfig();\n", "next_change": {"commit": "fb70688fa646c0d4826f1a8e224a76cf6a640427", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..54904e8b4a 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -737,11 +738,12 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     this.tuningConfig = spec.getTuningConfig();\n     this.taskTuningConfig = this.tuningConfig.convertToTaskTuningConfig();\n     this.supervisorId = supervisorId;\n-    this.exec = Execs.singleThreaded(supervisorId);\n-    this.scheduledExec = Execs.scheduledSingleThreaded(supervisorId + \"-Scheduler-%d\");\n-    this.reportingExec = Execs.scheduledSingleThreaded(supervisorId + \"-Reporting-%d\");\n-    this.allocationExec = Execs.scheduledSingleThreaded(supervisorId + \"-Allocation-%d\");\n-    this.lagComputationExec = Execs.scheduledSingleThreaded(supervisorId + \"-Computation-%d\");\n+    this.exec = Execs.singleThreaded(StringUtils.encodeForFormat(supervisorId));\n+    this.scheduledExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Scheduler-%d\");\n+    this.reportingExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Reporting-%d\");\n+    this.allocationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Allocation-%d\");\n+    this.lagComputationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Computation-%d\");\n+\n     this.stateManager = new SeekableStreamSupervisorStateManager(\n         spec.getSupervisorStateManagerConfig(),\n         spec.isSuspended()\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 54904e8b4a..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -741,8 +654,6 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     this.exec = Execs.singleThreaded(StringUtils.encodeForFormat(supervisorId));\n     this.scheduledExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Scheduler-%d\");\n     this.reportingExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Reporting-%d\");\n-    this.allocationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Allocation-%d\");\n-    this.lagComputationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Computation-%d\");\n \n     this.stateManager = new SeekableStreamSupervisorStateManager(\n         spec.getSupervisorStateManagerConfig(),\n", "next_change": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..0b5c238997 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -661,7 +665,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     );\n \n     int workerThreads;\n-    if (enableDynamicAllocationTasks) {\n+    if (enableTaskAutoscaler) {\n       workerThreads = (this.tuningConfig.getWorkerThreads() != null\n               ? this.tuningConfig.getWorkerThreads()\n               : Math.min(10, taskCountMax));\n", "next_change": {"commit": "25fec0ff18d0acb79734dd93bedccff3ab43308a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 0b5c238997..eb2797cc58 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -665,14 +651,27 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     );\n \n     int workerThreads;\n-    if (enableTaskAutoscaler) {\n+    int chatThreads;\n+    if (autoscalerConfigMap != null && !autoscalerConfigMap.isEmpty() && autoScalerConfig.getEnableTaskAutoscaler()) {\n+      log.info(\"enableTaskAutoscaler for datasource [%s]\", dataSource);\n+\n       workerThreads = (this.tuningConfig.getWorkerThreads() != null\n               ? this.tuningConfig.getWorkerThreads()\n-              : Math.min(10, taskCountMax));\n+              : Math.min(10, autoScalerConfig.getTaskCountMax()));\n+\n+      chatThreads = (this.tuningConfig.getChatThreads() != null\n+              ? this.tuningConfig.getChatThreads()\n+              : Math.min(10, autoScalerConfig.getTaskCountMax() * this.ioConfig.getReplicas()));\n     } else {\n+      log.info(\"Disable dynamic allocate tasks for [%s]\", dataSource);\n+\n       workerThreads = (this.tuningConfig.getWorkerThreads() != null\n               ? this.tuningConfig.getWorkerThreads()\n               : Math.min(10, this.ioConfig.getTaskCount()));\n+\n+      chatThreads = (this.tuningConfig.getChatThreads() != null\n+              ? this.tuningConfig.getChatThreads()\n+              : Math.min(10, this.ioConfig.getTaskCount() * this.ioConfig.getReplicas()));\n     }\n \n     this.workerExec = MoreExecutors.listeningDecorator(\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5OTQ2Nw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530499467", "body": "wondering if this default value should be final constant instantiated at top of class?", "bodyText": "wondering if this default value should be final constant instantiated at top of class?", "bodyHTML": "<p dir=\"auto\">wondering if this default value should be final constant instantiated at top of class?</p>", "author": "capistrant", "createdAt": "2020-11-25T16:26:24Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -317,6 +322,157 @@ public void handle()\n     }\n   }\n \n+  // same as submit supervisor logic\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    @Override\n+    public void handle()\n+    {\n+      lock.lock();\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        long minTriggerDynamicFrequency = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 1200000)));", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4Njc0OA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531686748", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T16:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5OTQ2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -322,46 +322,47 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n   }\n \n-  // same as submit supervisor logic\n+  // change taskCount without resubmitting.\n   private class DynamicAllocationTasksNotice implements Notice\n   {\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n     @Override\n     public void handle()\n     {\n       lock.lock();\n       try {\n         long nowTime = System.currentTimeMillis();\n-        long minTriggerDynamicFrequency = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 1200000)));\n         // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n-        // max(minTriggerDynamicFrequency, metricsCollectionRangeMillis)\n         if (spec.isSuspended()) {\n           log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n           return;\n         }\n-        log.info(\"PendingCompletionTaskGroups is : \" + pendingCompletionTaskGroups);\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n         for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n           if (!list.isEmpty()) {\n-            log.info(\"Still hand off tasks unfinished, skip to do scale action [\" + pendingCompletionTaskGroups + \"]\");\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n             return;\n           }\n         }\n         if (nowTime - dynamicTriggerLastRunTime < minTriggerDynamicFrequency) {\n-          log.info(\"NowTime - dynamicTriggerLastRunTime is [\" + (nowTime - dynamicTriggerLastRunTime) + \"]. Defined minTriggerDynamicFrequency is [\" + minTriggerDynamicFrequency + \"] , CLAM DOWN NOW !\");\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, minTriggerDynamicFrequency, dataSource);\n           return;\n         }\n-        if (!queue.isAtFullCapacity()) {\n-          log.info(\"Metrics collection is not at full capacity, skip to check dynamic allocate task : [\" + queue.size() + \" vs \" + queue.maxSize() + \"]\");\n+        if (!lagMetricsQueue.isAtFullCapacity()) {\n+          log.info(\"Metrics collection is not at full capacity, may cause unnecessary scale. Skip to check dynamic allocate task : [%s] vs [%s]\", lagMetricsQueue.size(), lagMetricsQueue.maxSize());\n           return;\n         }\n         List<Long> lags = collectTotalLags();\n         boolean allocationSuccess = dynamicAllocate(lags);\n         if (allocationSuccess) {\n           dynamicTriggerLastRunTime = nowTime;\n-          queue.clear();\n+          lagMetricsQueue.clear();\n         }\n       }\n       catch (Exception e) {\n-        log.error(e, \"Error, when parse DynamicAllocationTasksNotice\");\n+        log.warn(e, \"Error, when parse DynamicAllocationTasksNotice\");\n       }\n       finally {\n         lock.unlock();\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -350,98 +356,44 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n           log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, minTriggerDynamicFrequency, dataSource);\n           return;\n         }\n-        if (!lagMetricsQueue.isAtFullCapacity()) {\n-          log.info(\"Metrics collection is not at full capacity, may cause unnecessary scale. Skip to check dynamic allocate task : [%s] vs [%s]\", lagMetricsQueue.size(), lagMetricsQueue.maxSize());\n-          return;\n-        }\n-        List<Long> lags = collectTotalLags();\n-        boolean allocationSuccess = dynamicAllocate(lags);\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n         if (allocationSuccess) {\n           dynamicTriggerLastRunTime = nowTime;\n-          lagMetricsQueue.clear();\n         }\n       }\n-      catch (Exception e) {\n-        log.warn(e, \"Error, when parse DynamicAllocationTasksNotice\");\n-      }\n-      finally {\n-        lock.unlock();\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error, when parse DynamicAllocationTasksNotice\");\n       }\n     }\n   }\n \n   /**\n-   * This method determines whether and how to do scale actions based on collected lag points.\n-   * Current algorithm of scale is simple:\n-   *    First of all, compute the proportion of lag points higher/lower than scaleOutThreshold/scaleInThreshold, getting scaleOutThreshold/scaleInThreshold.\n-   *    Secondly, compare scaleOutThreshold/scaleInThreshold with triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency. P.S. Scale out action has higher priority than scale in action.\n-   *    Finaly, if scaleOutThreshold/scaleInThreshold is higher than triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency, scale out/in action would be triggered.\n+   * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n    * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param lags the lag metrics of Stream(Kafka/Kinesis)\n+   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n    * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(List<Long> lags) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n-    // if supervisor is not suspended, ensure required tasks are running\n-    // if suspended, ensure tasks have been requested to gracefully stop\n-    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic. Current collected lags : [%s]\", dataSource, lags);\n-    int beyond = 0;\n-    int within = 0;\n-    int metricsCount = lags.size();\n-    for (Long lag : lags) {\n-      if (lag >= scaleOutThreshold) {\n-        beyond++;\n-      }\n-      if (lag <= scaleInThreshold) {\n-        within++;\n-      }\n-    }\n-    double beyondProportion = beyond * 1.0 / metricsCount;\n-    double withinProportion = within * 1.0 / metricsCount;\n-    log.debug(\"triggerScaleOutThresholdFrequency is [%s] and triggerScaleInThresholdFrequency is [%s] for dataSource [%s].\", triggerScaleOutThresholdFrequency, triggerScaleInThresholdFrequency, dataSource);\n-    log.info(\"beyondProportion is [%s] and withinProportion is [%s] for dataSource [%s].\", beyondProportion, withinProportion, dataSource);\n-\n     int currentActiveTaskCount;\n-    int desireActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (beyondProportion >= triggerScaleOutThresholdFrequency) {\n-      // Do Scale out\n-      int taskCount = currentActiveTaskCount + scaleOutStep;\n-      if (currentActiveTaskCount == taskCountMax) {\n-        log.info(\"CurrentActiveTaskCount reach task count Max limit, skip to scale out tasks for dataSource [%s].\", dataSource);\n-        return false;\n-      } else {\n-        desireActiveTaskCount = Math.min(taskCount, taskCountMax);\n-      }\n-      log.debug(\"Start to scale out tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n-      gracefulShutdownInternal();\n-      // clear everything\n-      clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n-      return true;\n-    }\n-\n-    if (withinProportion >= triggerScaleInThresholdFrequency) {\n-      // Do Scale in\n-      int taskCount = currentActiveTaskCount - scaleInStep;\n-      if (currentActiveTaskCount == taskCountMin) {\n-        log.info(\"CurrentActiveTaskCount reach task count Min limit, skip to scale in tasks for dataSource [%s].\", dataSource);\n-        return false;\n-      } else {\n-        desireActiveTaskCount = Math.max(taskCount, taskCountMin);\n-      }\n-      log.debug(\"Start to scale in tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+    if (desireActiveTaskCount == -1) {\n+      return false;\n+    } else {\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n       // clear everything\n       clearAllocationInfos();\n", "next_change": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -376,36 +378,36 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desireActiveTaskCount == -1) {\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n       return true;\n     }\n   }\n \n-  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n   {\n-    ioConfig.setTaskCount(desireActiveTaskCount);\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n     try {\n       Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n       if (supervisorManager.isPresent()) {\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -414,7 +428,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n+        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -428,15 +426,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n-      log.warn(\"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n     }\n   }\n \n-  private void clearAllocationInfos()\n+  private void clearAllocationInfo()\n   {\n     activelyReadingTaskGroups.clear();\n     partitionGroups.clear();\n", "next_change": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxMTMzMA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530511330", "body": "logs in this constructor should include info on the supervisor being referred to. I think we should also evaluate what can be debug to reduce chattiness in info level logging.", "bodyText": "logs in this constructor should include info on the supervisor being referred to. I think we should also evaluate what can be debug to reduce chattiness in info level logging.", "bodyHTML": "<p dir=\"auto\">logs in this constructor should include info on the supervisor being referred to. I think we should also evaluate what can be debug to reduce chattiness in info level logging.</p>", "author": "capistrant", "createdAt": "2020-11-25T16:44:17Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -495,6 +655,12 @@ boolean isValidTaskGroup(int taskGroupId, @Nullable TaskGroup taskGroup)\n   private volatile boolean stopped = false;\n   private volatile boolean lifecycleStarted = false;\n   private final ServiceEmitter emitter;\n+  private final boolean enableDynamicAllocationTasks;\n+  private volatile long metricsCollectionIntervalMillis;\n+  private volatile long metricsCollectionRangeMillis;\n+  private volatile long dynamicCheckStartDelayMillis;\n+  private volatile long dynamicCheckPeriod;\n+  private volatile CircularFifoQueue<Long> queue;\n \n   public SeekableStreamSupervisor(", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY2NzY4NA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531667684", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:40:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxMTMzMA=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -656,11 +667,21 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n   private volatile boolean lifecycleStarted = false;\n   private final ServiceEmitter emitter;\n   private final boolean enableDynamicAllocationTasks;\n-  private volatile long metricsCollectionIntervalMillis;\n-  private volatile long metricsCollectionRangeMillis;\n-  private volatile long dynamicCheckStartDelayMillis;\n-  private volatile long dynamicCheckPeriod;\n-  private volatile CircularFifoQueue<Long> queue;\n+  private long metricsCollectionIntervalMillis;\n+  private long metricsCollectionRangeMillis;\n+  private long scaleOutThreshold;\n+  private double triggerScaleOutThresholdFrequency;\n+  private long scaleInThreshold;\n+  private double triggerScaleInThresholdFrequency;\n+  private long dynamicCheckStartDelayMillis;\n+  private long dynamicCheckPeriod;\n+  private int taskCountMax;\n+  private int taskCountMin;\n+  private int scaleInStep;\n+  private int scaleOutStep;\n+  private long minTriggerDynamicFrequency;\n+\n+  private volatile CircularFifoQueue<Long> lagMetricsQueue;\n \n   public SeekableStreamSupervisor(\n       final String supervisorId,\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -661,28 +605,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n   private int initRetryCounter = 0;\n   private volatile DateTime firstRunTime;\n   private volatile DateTime earlyStopTime = null;\n-  protected volatile RecordSupplier<PartitionIdType, SequenceOffsetType> recordSupplier;\n+  protected volatile RecordSupplier<PartitionIdType, SequenceOffsetType, RecordType> recordSupplier;\n   private volatile boolean started = false;\n   private volatile boolean stopped = false;\n   private volatile boolean lifecycleStarted = false;\n   private final ServiceEmitter emitter;\n   private final boolean enableDynamicAllocationTasks;\n-  private long metricsCollectionIntervalMillis;\n-  private long metricsCollectionRangeMillis;\n-  private long scaleOutThreshold;\n-  private double triggerScaleOutThresholdFrequency;\n-  private long scaleInThreshold;\n-  private double triggerScaleInThresholdFrequency;\n-  private long dynamicCheckStartDelayMillis;\n-  private long dynamicCheckPeriod;\n   private int taskCountMax;\n-  private int taskCountMin;\n-  private int scaleInStep;\n-  private int scaleOutStep;\n   private long minTriggerDynamicFrequency;\n \n-  private volatile CircularFifoQueue<Long> lagMetricsQueue;\n-\n   public SeekableStreamSupervisor(\n       final String supervisorId,\n       final TaskStorage taskStorage,\n", "next_change": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..0b5c238997 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -610,7 +614,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n   private volatile boolean stopped = false;\n   private volatile boolean lifecycleStarted = false;\n   private final ServiceEmitter emitter;\n-  private final boolean enableDynamicAllocationTasks;\n+  private final boolean enableTaskAutoscaler;\n   private int taskCountMax;\n   private long minTriggerDynamicFrequency;\n \n", "next_change": {"commit": "25fec0ff18d0acb79734dd93bedccff3ab43308a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 0b5c238997..eb2797cc58 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -614,9 +612,6 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n   private volatile boolean stopped = false;\n   private volatile boolean lifecycleStarted = false;\n   private final ServiceEmitter emitter;\n-  private final boolean enableTaskAutoscaler;\n-  private int taskCountMax;\n-  private long minTriggerDynamicFrequency;\n \n   public SeekableStreamSupervisor(\n       final String supervisorId,\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxMjY4OA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530512688", "body": "include reference to the datasource in this log and the one for the lag computation executor below. Should they be debug to reduce info level chattiness?", "bodyText": "include reference to the datasource in this log and the one for the lag computation executor below. Should they be debug to reduce info level chattiness?", "bodyHTML": "<p dir=\"auto\">include reference to the datasource in this log and the one for the lag computation executor below. Should they be debug to reduce info level chattiness?</p>", "author": "capistrant", "createdAt": "2020-11-25T16:46:16Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -768,7 +978,22 @@ public void tryInit()\n         );\n \n         scheduleReporting(reportingExec);\n-\n+        if (enableDynamicAllocationTasks) {\n+          log.info(\"Collect and compute lags at fixed rate of \" + metricsCollectionIntervalMillis);", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4Njc4Mg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531686782", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T16:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxMjY4OA=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -979,14 +1004,14 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n \n         scheduleReporting(reportingExec);\n         if (enableDynamicAllocationTasks) {\n-          log.info(\"Collect and compute lags at fixed rate of \" + metricsCollectionIntervalMillis);\n+          log.debug(\"Collect and compute lags at fixed rate of [%s] for dataSource[%s].\", metricsCollectionIntervalMillis, dataSource);\n           lagComputationExec.scheduleAtFixedRate(\n-                  collectAndcollectLags(),\n+                  collectAndComputeLags(),\n                   dynamicCheckStartDelayMillis, // wait for tasks to start up\n                   metricsCollectionIntervalMillis,\n                   TimeUnit.MILLISECONDS\n           );\n-          log.info(\"allocate task at fixed rate of \" + dynamicCheckPeriod);\n+          log.debug(\"allocate task at fixed rate of [%s], dataSource [%s].\", dynamicCheckPeriod, dataSource);\n           allocationExec.scheduleAtFixedRate(\n                   buildDynamicAllocationTask(),\n                   dynamicCheckStartDelayMillis + metricsCollectionRangeMillis,\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -1003,22 +926,6 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         );\n \n         scheduleReporting(reportingExec);\n-        if (enableDynamicAllocationTasks) {\n-          log.debug(\"Collect and compute lags at fixed rate of [%s] for dataSource[%s].\", metricsCollectionIntervalMillis, dataSource);\n-          lagComputationExec.scheduleAtFixedRate(\n-                  collectAndComputeLags(),\n-                  dynamicCheckStartDelayMillis, // wait for tasks to start up\n-                  metricsCollectionIntervalMillis,\n-                  TimeUnit.MILLISECONDS\n-          );\n-          log.debug(\"allocate task at fixed rate of [%s], dataSource [%s].\", dynamicCheckPeriod, dataSource);\n-          allocationExec.scheduleAtFixedRate(\n-                  buildDynamicAllocationTask(),\n-                  dynamicCheckStartDelayMillis + metricsCollectionRangeMillis,\n-                  dynamicCheckPeriod,\n-                  TimeUnit.MILLISECONDS\n-          );\n-        }\n         started = true;\n         log.info(\n             \"Started SeekableStreamSupervisor[%s], first run in [%s], with spec: [%s]\",\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxODQ0Mg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530518442", "body": "logs should provide context about what supervisor they are referring. As in other places, lets assess what can be changed to debug to reduce chattiness", "bodyText": "logs should provide context about what supervisor they are referring. As in other places, lets assess what can be changed to debug to reduce chattiness", "bodyHTML": "<p dir=\"auto\">logs should provide context about what supervisor they are referring. As in other places, lets assess what can be changed to debug to reduce chattiness</p>", "author": "capistrant", "createdAt": "2020-11-25T16:55:02Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -791,6 +1016,38 @@ public void tryInit()\n     }\n   }\n \n+  private Runnable collectAndcollectLags()\n+  {\n+    return new Runnable() {\n+      @Override\n+      public void run()", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY2Nzg5NQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531667895", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T15:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxODQ0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -1016,7 +1041,11 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n   }\n \n-  private Runnable collectAndcollectLags()\n+  /**\n+   * This method compute current consume lags. Get the total lags of all partition and fill in lagMetricsQueue\n+   * @return a Runnbale object to do collect and compute action.\n+   */\n+  private Runnable collectAndComputeLags()\n   {\n     return new Runnable() {\n       @Override\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -1041,40 +948,10 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n   }\n \n-  /**\n-   * This method compute current consume lags. Get the total lags of all partition and fill in lagMetricsQueue\n-   * @return a Runnbale object to do collect and compute action.\n-   */\n-  private Runnable collectAndComputeLags()\n-  {\n-    return new Runnable() {\n-      @Override\n-      public void run()\n-      {\n-        lock.lock();\n-        try {\n-          if (!spec.isSuspended()) {\n-            ArrayList<Long> metricsInfo = new ArrayList<>(3);\n-            collectLag(metricsInfo);\n-            long totalLags = metricsInfo.size() < 3 ? 0 : metricsInfo.get(1);\n-            lagMetricsQueue.offer(totalLags > 0 ? totalLags : 0);\n-            log.debug(\"Current lag metric points [%s] for dataSource [%s].\", new ArrayList<>(lagMetricsQueue), dataSource);\n-          } else {\n-            log.debug(\"[%s] supervisor is suspended, skip to collect kafka lags\", dataSource);\n-          }\n-        }\n-        catch (Exception e) {\n-          log.warn(e, \"Error, When collect kafka lags\");\n-        }\n-        finally {\n-          lock.unlock();\n-        }\n-      }\n-    };\n-  }\n-  private Runnable buildDynamicAllocationTask()\n+  @Override\n+  public Runnable buildDynamicAllocationTask(Callable<Integer> scaleAction)\n   {\n-    return () -> notices.add(new DynamicAllocationTasksNotice());\n+    return () -> notices.add(new DynamicAllocationTasksNotice(scaleAction));\n   }\n \n   private Runnable buildRunTask()\n", "next_change": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..0b5c238997 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -948,7 +952,6 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n   }\n \n-  @Override\n   public Runnable buildDynamicAllocationTask(Callable<Integer> scaleAction)\n   {\n     return () -> notices.add(new DynamicAllocationTasksNotice(scaleAction));\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxODgwNQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530518805", "body": "should this be warn if we catch and move on?", "bodyText": "should this be warn if we catch and move on?", "bodyHTML": "<p dir=\"auto\">should this be warn if we catch and move on?</p>", "author": "capistrant", "createdAt": "2020-11-25T16:55:30Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -791,6 +1016,38 @@ public void tryInit()\n     }\n   }\n \n+  private Runnable collectAndcollectLags()\n+  {\n+    return new Runnable() {\n+      @Override\n+      public void run()\n+      {\n+        lock.lock();\n+        try {\n+          if (!spec.isSuspended()) {\n+            ArrayList<Long> metricsInfo = new ArrayList<>(3);\n+            collectLag(metricsInfo);\n+            long totalLags = metricsInfo.size() < 3 ? 0 : metricsInfo.get(1);\n+            queue.offer(totalLags > 0 ? totalLags : 0);\n+            log.info(\"Current lag metric points : \" + new ArrayList<>(queue));\n+          } else {\n+            log.info(\"[%s] supervisor is suspended, skip to collect kafka lags\", dataSource);\n+          }\n+        }\n+        catch (Exception e) {\n+          log.error(e, \"Error, When collect kafka lags\");", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4NjkwNQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531686905", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T16:24:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxODgwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -1028,14 +1057,14 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n             ArrayList<Long> metricsInfo = new ArrayList<>(3);\n             collectLag(metricsInfo);\n             long totalLags = metricsInfo.size() < 3 ? 0 : metricsInfo.get(1);\n-            queue.offer(totalLags > 0 ? totalLags : 0);\n-            log.info(\"Current lag metric points : \" + new ArrayList<>(queue));\n+            lagMetricsQueue.offer(totalLags > 0 ? totalLags : 0);\n+            log.debug(\"Current lag metric points [%s] for dataSource [%s].\", new ArrayList<>(lagMetricsQueue), dataSource);\n           } else {\n-            log.info(\"[%s] supervisor is suspended, skip to collect kafka lags\", dataSource);\n+            log.debug(\"[%s] supervisor is suspended, skip to collect kafka lags\", dataSource);\n           }\n         }\n         catch (Exception e) {\n-          log.error(e, \"Error, When collect kafka lags\");\n+          log.warn(e, \"Error, When collect kafka lags\");\n         }\n         finally {\n           lock.unlock();\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -1041,40 +948,10 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n   }\n \n-  /**\n-   * This method compute current consume lags. Get the total lags of all partition and fill in lagMetricsQueue\n-   * @return a Runnbale object to do collect and compute action.\n-   */\n-  private Runnable collectAndComputeLags()\n-  {\n-    return new Runnable() {\n-      @Override\n-      public void run()\n-      {\n-        lock.lock();\n-        try {\n-          if (!spec.isSuspended()) {\n-            ArrayList<Long> metricsInfo = new ArrayList<>(3);\n-            collectLag(metricsInfo);\n-            long totalLags = metricsInfo.size() < 3 ? 0 : metricsInfo.get(1);\n-            lagMetricsQueue.offer(totalLags > 0 ? totalLags : 0);\n-            log.debug(\"Current lag metric points [%s] for dataSource [%s].\", new ArrayList<>(lagMetricsQueue), dataSource);\n-          } else {\n-            log.debug(\"[%s] supervisor is suspended, skip to collect kafka lags\", dataSource);\n-          }\n-        }\n-        catch (Exception e) {\n-          log.warn(e, \"Error, When collect kafka lags\");\n-        }\n-        finally {\n-          lock.unlock();\n-        }\n-      }\n-    };\n-  }\n-  private Runnable buildDynamicAllocationTask()\n+  @Override\n+  public Runnable buildDynamicAllocationTask(Callable<Integer> scaleAction)\n   {\n-    return () -> notices.add(new DynamicAllocationTasksNotice());\n+    return () -> notices.add(new DynamicAllocationTasksNotice(scaleAction));\n   }\n \n   private Runnable buildRunTask()\n", "next_change": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..0b5c238997 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -948,7 +952,6 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n   }\n \n-  @Override\n   public Runnable buildDynamicAllocationTask(Callable<Integer> scaleAction)\n   {\n     return () -> notices.add(new DynamicAllocationTasksNotice(scaleAction));\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMjU5Nw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530522597", "body": "does this mean we have not collected enough historical lag data to decide on scale in/scale out? I think the log can be updated to be more descriptive since it may not be obvious to log reader why it matters that queue is not full", "bodyText": "does this mean we have not collected enough historical lag data to decide on scale in/scale out? I think the log can be updated to be more descriptive since it may not be obvious to log reader why it matters that queue is not full", "bodyHTML": "<p dir=\"auto\">does this mean we have not collected enough historical lag data to decide on scale in/scale out? I think the log can be updated to be more descriptive since it may not be obvious to log reader why it matters that queue is not full</p>", "author": "capistrant", "createdAt": "2020-11-25T17:01:27Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -317,6 +322,157 @@ public void handle()\n     }\n   }\n \n+  // same as submit supervisor logic\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    @Override\n+    public void handle()\n+    {\n+      lock.lock();\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        long minTriggerDynamicFrequency = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 1200000)));\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        // max(minTriggerDynamicFrequency, metricsCollectionRangeMillis)\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.info(\"PendingCompletionTaskGroups is : \" + pendingCompletionTaskGroups);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [\" + pendingCompletionTaskGroups + \"]\");\n+            return;\n+          }\n+        }\n+        if (nowTime - dynamicTriggerLastRunTime < minTriggerDynamicFrequency) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [\" + (nowTime - dynamicTriggerLastRunTime) + \"]. Defined minTriggerDynamicFrequency is [\" + minTriggerDynamicFrequency + \"] , CLAM DOWN NOW !\");\n+          return;\n+        }\n+        if (!queue.isAtFullCapacity()) {", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4Njk3Nw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531686977", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T16:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMjU5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -322,46 +322,47 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n   }\n \n-  // same as submit supervisor logic\n+  // change taskCount without resubmitting.\n   private class DynamicAllocationTasksNotice implements Notice\n   {\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n     @Override\n     public void handle()\n     {\n       lock.lock();\n       try {\n         long nowTime = System.currentTimeMillis();\n-        long minTriggerDynamicFrequency = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 1200000)));\n         // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n-        // max(minTriggerDynamicFrequency, metricsCollectionRangeMillis)\n         if (spec.isSuspended()) {\n           log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n           return;\n         }\n-        log.info(\"PendingCompletionTaskGroups is : \" + pendingCompletionTaskGroups);\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n         for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n           if (!list.isEmpty()) {\n-            log.info(\"Still hand off tasks unfinished, skip to do scale action [\" + pendingCompletionTaskGroups + \"]\");\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n             return;\n           }\n         }\n         if (nowTime - dynamicTriggerLastRunTime < minTriggerDynamicFrequency) {\n-          log.info(\"NowTime - dynamicTriggerLastRunTime is [\" + (nowTime - dynamicTriggerLastRunTime) + \"]. Defined minTriggerDynamicFrequency is [\" + minTriggerDynamicFrequency + \"] , CLAM DOWN NOW !\");\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, minTriggerDynamicFrequency, dataSource);\n           return;\n         }\n-        if (!queue.isAtFullCapacity()) {\n-          log.info(\"Metrics collection is not at full capacity, skip to check dynamic allocate task : [\" + queue.size() + \" vs \" + queue.maxSize() + \"]\");\n+        if (!lagMetricsQueue.isAtFullCapacity()) {\n+          log.info(\"Metrics collection is not at full capacity, may cause unnecessary scale. Skip to check dynamic allocate task : [%s] vs [%s]\", lagMetricsQueue.size(), lagMetricsQueue.maxSize());\n           return;\n         }\n         List<Long> lags = collectTotalLags();\n         boolean allocationSuccess = dynamicAllocate(lags);\n         if (allocationSuccess) {\n           dynamicTriggerLastRunTime = nowTime;\n-          queue.clear();\n+          lagMetricsQueue.clear();\n         }\n       }\n       catch (Exception e) {\n-        log.error(e, \"Error, when parse DynamicAllocationTasksNotice\");\n+        log.warn(e, \"Error, when parse DynamicAllocationTasksNotice\");\n       }\n       finally {\n         lock.unlock();\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -350,98 +356,44 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n           log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, minTriggerDynamicFrequency, dataSource);\n           return;\n         }\n-        if (!lagMetricsQueue.isAtFullCapacity()) {\n-          log.info(\"Metrics collection is not at full capacity, may cause unnecessary scale. Skip to check dynamic allocate task : [%s] vs [%s]\", lagMetricsQueue.size(), lagMetricsQueue.maxSize());\n-          return;\n-        }\n-        List<Long> lags = collectTotalLags();\n-        boolean allocationSuccess = dynamicAllocate(lags);\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n         if (allocationSuccess) {\n           dynamicTriggerLastRunTime = nowTime;\n-          lagMetricsQueue.clear();\n         }\n       }\n-      catch (Exception e) {\n-        log.warn(e, \"Error, when parse DynamicAllocationTasksNotice\");\n-      }\n-      finally {\n-        lock.unlock();\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error, when parse DynamicAllocationTasksNotice\");\n       }\n     }\n   }\n \n   /**\n-   * This method determines whether and how to do scale actions based on collected lag points.\n-   * Current algorithm of scale is simple:\n-   *    First of all, compute the proportion of lag points higher/lower than scaleOutThreshold/scaleInThreshold, getting scaleOutThreshold/scaleInThreshold.\n-   *    Secondly, compare scaleOutThreshold/scaleInThreshold with triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency. P.S. Scale out action has higher priority than scale in action.\n-   *    Finaly, if scaleOutThreshold/scaleInThreshold is higher than triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency, scale out/in action would be triggered.\n+   * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n    * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param lags the lag metrics of Stream(Kafka/Kinesis)\n+   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n    * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(List<Long> lags) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n-    // if supervisor is not suspended, ensure required tasks are running\n-    // if suspended, ensure tasks have been requested to gracefully stop\n-    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic. Current collected lags : [%s]\", dataSource, lags);\n-    int beyond = 0;\n-    int within = 0;\n-    int metricsCount = lags.size();\n-    for (Long lag : lags) {\n-      if (lag >= scaleOutThreshold) {\n-        beyond++;\n-      }\n-      if (lag <= scaleInThreshold) {\n-        within++;\n-      }\n-    }\n-    double beyondProportion = beyond * 1.0 / metricsCount;\n-    double withinProportion = within * 1.0 / metricsCount;\n-    log.debug(\"triggerScaleOutThresholdFrequency is [%s] and triggerScaleInThresholdFrequency is [%s] for dataSource [%s].\", triggerScaleOutThresholdFrequency, triggerScaleInThresholdFrequency, dataSource);\n-    log.info(\"beyondProportion is [%s] and withinProportion is [%s] for dataSource [%s].\", beyondProportion, withinProportion, dataSource);\n-\n     int currentActiveTaskCount;\n-    int desireActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (beyondProportion >= triggerScaleOutThresholdFrequency) {\n-      // Do Scale out\n-      int taskCount = currentActiveTaskCount + scaleOutStep;\n-      if (currentActiveTaskCount == taskCountMax) {\n-        log.info(\"CurrentActiveTaskCount reach task count Max limit, skip to scale out tasks for dataSource [%s].\", dataSource);\n-        return false;\n-      } else {\n-        desireActiveTaskCount = Math.min(taskCount, taskCountMax);\n-      }\n-      log.debug(\"Start to scale out tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n-      gracefulShutdownInternal();\n-      // clear everything\n-      clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n-      return true;\n-    }\n-\n-    if (withinProportion >= triggerScaleInThresholdFrequency) {\n-      // Do Scale in\n-      int taskCount = currentActiveTaskCount - scaleInStep;\n-      if (currentActiveTaskCount == taskCountMin) {\n-        log.info(\"CurrentActiveTaskCount reach task count Min limit, skip to scale in tasks for dataSource [%s].\", dataSource);\n-        return false;\n-      } else {\n-        desireActiveTaskCount = Math.max(taskCount, taskCountMin);\n-      }\n-      log.debug(\"Start to scale in tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+    if (desireActiveTaskCount == -1) {\n+      return false;\n+    } else {\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n       // clear everything\n       clearAllocationInfos();\n", "next_change": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -376,36 +378,36 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desireActiveTaskCount == -1) {\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n       return true;\n     }\n   }\n \n-  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n   {\n-    ioConfig.setTaskCount(desireActiveTaskCount);\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n     try {\n       Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n       if (supervisorManager.isPresent()) {\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -414,7 +428,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n+        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -428,15 +426,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n-      log.warn(\"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n     }\n   }\n \n-  private void clearAllocationInfos()\n+  private void clearAllocationInfo()\n   {\n     activelyReadingTaskGroups.clear();\n     partitionGroups.clear();\n", "next_change": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNDA3OA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530524078", "body": "I think these may be spelling mistakes in variable name and config value for this and next config. `triggerSale*` --> `triggerScale*` ?", "bodyText": "I think these may be spelling mistakes in variable name and config value for this and next config. triggerSale* --> triggerScale* ?", "bodyHTML": "<p dir=\"auto\">I think these may be spelling mistakes in variable name and config value for this and next config. <code>triggerSale*</code> --&gt; <code>triggerScale*</code> ?</p>", "author": "capistrant", "createdAt": "2020-11-25T17:03:57Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -317,6 +322,157 @@ public void handle()\n     }\n   }\n \n+  // same as submit supervisor logic\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    @Override\n+    public void handle()\n+    {\n+      lock.lock();\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        long minTriggerDynamicFrequency = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 1200000)));\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        // max(minTriggerDynamicFrequency, metricsCollectionRangeMillis)\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.info(\"PendingCompletionTaskGroups is : \" + pendingCompletionTaskGroups);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [\" + pendingCompletionTaskGroups + \"]\");\n+            return;\n+          }\n+        }\n+        if (nowTime - dynamicTriggerLastRunTime < minTriggerDynamicFrequency) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [\" + (nowTime - dynamicTriggerLastRunTime) + \"]. Defined minTriggerDynamicFrequency is [\" + minTriggerDynamicFrequency + \"] , CLAM DOWN NOW !\");\n+          return;\n+        }\n+        if (!queue.isAtFullCapacity()) {\n+          log.info(\"Metrics collection is not at full capacity, skip to check dynamic allocate task : [\" + queue.size() + \" vs \" + queue.maxSize() + \"]\");\n+          return;\n+        }\n+        List<Long> lags = collectTotalLags();\n+        boolean allocationSuccess = dynamicAllocate(lags);\n+        if (allocationSuccess) {\n+          dynamicTriggerLastRunTime = nowTime;\n+          queue.clear();\n+        }\n+      }\n+      catch (Exception e) {\n+        log.error(e, \"Error, when parse DynamicAllocationTasksNotice\");\n+      }\n+      finally {\n+        lock.unlock();\n+      }\n+    }\n+  }\n+\n+  private boolean dynamicAllocate(List<Long> lags) throws InterruptedException, ExecutionException, TimeoutException\n+  {\n+    // if supervisor is not suspended, ensure required tasks are running\n+    // if suspended, ensure tasks have been requested to gracefully stop\n+    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic\", dataSource);\n+    long scaleOutThreshold = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleOutThreshold\", 5000000)));\n+    long scaleInThreshold = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleInThreshold\", 1000000)));\n+    double triggerSaleOutThresholdFrequency = Double.parseDouble(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"triggerSaleOutThresholdFrequency\", 0.3)));", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4NzAxNA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531687014", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T16:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNDA3OA=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -369,19 +370,29 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n   }\n \n+  /**\n+   * This method determines whether and how to do scale actions based on collected lag points.\n+   * Current algorithm of scale is simple:\n+   *    First of all, compute the proportion of lag points higher/lower than scaleOutThreshold/scaleInThreshold, getting scaleOutThreshold/scaleInThreshold.\n+   *    Secondly, compare scaleOutThreshold/scaleInThreshold with triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency. P.S. Scale out action has higher priority than scale in action.\n+   *    Finaly, if scaleOutThreshold/scaleInThreshold is higher than triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency, scale out/in action would be triggered.\n+   * If scale action is triggered :\n+   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n+   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n+   * @param lags the lag metrics of Stream(Kafka/Kinesis)\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n+   * @throws InterruptedException\n+   * @throws ExecutionException\n+   * @throws TimeoutException\n+   */\n   private boolean dynamicAllocate(List<Long> lags) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     // if supervisor is not suspended, ensure required tasks are running\n     // if suspended, ensure tasks have been requested to gracefully stop\n-    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic\", dataSource);\n-    long scaleOutThreshold = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleOutThreshold\", 5000000)));\n-    long scaleInThreshold = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleInThreshold\", 1000000)));\n-    double triggerSaleOutThresholdFrequency = Double.parseDouble(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"triggerSaleOutThresholdFrequency\", 0.3)));\n-    double triggerSaleInThresholdFrequency = Double.parseDouble(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"triggerSaleInThresholdFrequency\", 0.8)));\n-    int taskCountMax = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"taskCountMax\", 8)));\n-    int taskCountMin = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"taskCountMin\", 1)));\n-    int scaleInStep = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleInStep\", 1)));\n-    int scaleOutStep = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleOutStep\", 2)));\n+    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic. Current collected lags : [%s]\", dataSource, lags);\n     int beyond = 0;\n     int within = 0;\n     int metricsCount = lags.size();\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -350,98 +356,44 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n           log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, minTriggerDynamicFrequency, dataSource);\n           return;\n         }\n-        if (!lagMetricsQueue.isAtFullCapacity()) {\n-          log.info(\"Metrics collection is not at full capacity, may cause unnecessary scale. Skip to check dynamic allocate task : [%s] vs [%s]\", lagMetricsQueue.size(), lagMetricsQueue.maxSize());\n-          return;\n-        }\n-        List<Long> lags = collectTotalLags();\n-        boolean allocationSuccess = dynamicAllocate(lags);\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n         if (allocationSuccess) {\n           dynamicTriggerLastRunTime = nowTime;\n-          lagMetricsQueue.clear();\n         }\n       }\n-      catch (Exception e) {\n-        log.warn(e, \"Error, when parse DynamicAllocationTasksNotice\");\n-      }\n-      finally {\n-        lock.unlock();\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error, when parse DynamicAllocationTasksNotice\");\n       }\n     }\n   }\n \n   /**\n-   * This method determines whether and how to do scale actions based on collected lag points.\n-   * Current algorithm of scale is simple:\n-   *    First of all, compute the proportion of lag points higher/lower than scaleOutThreshold/scaleInThreshold, getting scaleOutThreshold/scaleInThreshold.\n-   *    Secondly, compare scaleOutThreshold/scaleInThreshold with triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency. P.S. Scale out action has higher priority than scale in action.\n-   *    Finaly, if scaleOutThreshold/scaleInThreshold is higher than triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency, scale out/in action would be triggered.\n+   * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n    * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param lags the lag metrics of Stream(Kafka/Kinesis)\n+   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n    * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(List<Long> lags) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n-    // if supervisor is not suspended, ensure required tasks are running\n-    // if suspended, ensure tasks have been requested to gracefully stop\n-    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic. Current collected lags : [%s]\", dataSource, lags);\n-    int beyond = 0;\n-    int within = 0;\n-    int metricsCount = lags.size();\n-    for (Long lag : lags) {\n-      if (lag >= scaleOutThreshold) {\n-        beyond++;\n-      }\n-      if (lag <= scaleInThreshold) {\n-        within++;\n-      }\n-    }\n-    double beyondProportion = beyond * 1.0 / metricsCount;\n-    double withinProportion = within * 1.0 / metricsCount;\n-    log.debug(\"triggerScaleOutThresholdFrequency is [%s] and triggerScaleInThresholdFrequency is [%s] for dataSource [%s].\", triggerScaleOutThresholdFrequency, triggerScaleInThresholdFrequency, dataSource);\n-    log.info(\"beyondProportion is [%s] and withinProportion is [%s] for dataSource [%s].\", beyondProportion, withinProportion, dataSource);\n-\n     int currentActiveTaskCount;\n-    int desireActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (beyondProportion >= triggerScaleOutThresholdFrequency) {\n-      // Do Scale out\n-      int taskCount = currentActiveTaskCount + scaleOutStep;\n-      if (currentActiveTaskCount == taskCountMax) {\n-        log.info(\"CurrentActiveTaskCount reach task count Max limit, skip to scale out tasks for dataSource [%s].\", dataSource);\n-        return false;\n-      } else {\n-        desireActiveTaskCount = Math.min(taskCount, taskCountMax);\n-      }\n-      log.debug(\"Start to scale out tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n-      gracefulShutdownInternal();\n-      // clear everything\n-      clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n-      return true;\n-    }\n-\n-    if (withinProportion >= triggerScaleInThresholdFrequency) {\n-      // Do Scale in\n-      int taskCount = currentActiveTaskCount - scaleInStep;\n-      if (currentActiveTaskCount == taskCountMin) {\n-        log.info(\"CurrentActiveTaskCount reach task count Min limit, skip to scale in tasks for dataSource [%s].\", dataSource);\n-        return false;\n-      } else {\n-        desireActiveTaskCount = Math.max(taskCount, taskCountMin);\n-      }\n-      log.debug(\"Start to scale in tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+    if (desireActiveTaskCount == -1) {\n+      return false;\n+    } else {\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n       // clear everything\n       clearAllocationInfos();\n", "next_change": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -376,36 +378,36 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desireActiveTaskCount == -1) {\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n       return true;\n     }\n   }\n \n-  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n   {\n-    ioConfig.setTaskCount(desireActiveTaskCount);\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n     try {\n       Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n       if (supervisorManager.isPresent()) {\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -414,7 +428,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n+        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -428,15 +426,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n-      log.warn(\"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n     }\n   }\n \n-  private void clearAllocationInfos()\n+  private void clearAllocationInfo()\n   {\n     activelyReadingTaskGroups.clear();\n     partitionGroups.clear();\n", "next_change": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNTU2Ng==", "url": "https://github.com/apache/druid/pull/10524#discussion_r530525566", "body": "same spelling callout as above", "bodyText": "same spelling callout as above", "bodyHTML": "<p dir=\"auto\">same spelling callout as above</p>", "author": "capistrant", "createdAt": "2020-11-25T17:06:21Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -317,6 +322,157 @@ public void handle()\n     }\n   }\n \n+  // same as submit supervisor logic\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    @Override\n+    public void handle()\n+    {\n+      lock.lock();\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        long minTriggerDynamicFrequency = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 1200000)));\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        // max(minTriggerDynamicFrequency, metricsCollectionRangeMillis)\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.info(\"PendingCompletionTaskGroups is : \" + pendingCompletionTaskGroups);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [\" + pendingCompletionTaskGroups + \"]\");\n+            return;\n+          }\n+        }\n+        if (nowTime - dynamicTriggerLastRunTime < minTriggerDynamicFrequency) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [\" + (nowTime - dynamicTriggerLastRunTime) + \"]. Defined minTriggerDynamicFrequency is [\" + minTriggerDynamicFrequency + \"] , CLAM DOWN NOW !\");\n+          return;\n+        }\n+        if (!queue.isAtFullCapacity()) {\n+          log.info(\"Metrics collection is not at full capacity, skip to check dynamic allocate task : [\" + queue.size() + \" vs \" + queue.maxSize() + \"]\");\n+          return;\n+        }\n+        List<Long> lags = collectTotalLags();\n+        boolean allocationSuccess = dynamicAllocate(lags);\n+        if (allocationSuccess) {\n+          dynamicTriggerLastRunTime = nowTime;\n+          queue.clear();\n+        }\n+      }\n+      catch (Exception e) {\n+        log.error(e, \"Error, when parse DynamicAllocationTasksNotice\");\n+      }\n+      finally {\n+        lock.unlock();\n+      }\n+    }\n+  }\n+\n+  private boolean dynamicAllocate(List<Long> lags) throws InterruptedException, ExecutionException, TimeoutException\n+  {\n+    // if supervisor is not suspended, ensure required tasks are running\n+    // if suspended, ensure tasks have been requested to gracefully stop\n+    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic\", dataSource);\n+    long scaleOutThreshold = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleOutThreshold\", 5000000)));\n+    long scaleInThreshold = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleInThreshold\", 1000000)));\n+    double triggerSaleOutThresholdFrequency = Double.parseDouble(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"triggerSaleOutThresholdFrequency\", 0.3)));\n+    double triggerSaleInThresholdFrequency = Double.parseDouble(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"triggerSaleInThresholdFrequency\", 0.8)));\n+    int taskCountMax = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"taskCountMax\", 8)));\n+    int taskCountMin = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"taskCountMin\", 1)));\n+    int scaleInStep = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleInStep\", 1)));\n+    int scaleOutStep = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"scaleOutStep\", 2)));\n+    int beyond = 0;\n+    int within = 0;\n+    int metricsCount = lags.size();\n+    for (Long lag : lags) {\n+      if (lag >= scaleOutThreshold) {\n+        beyond++;\n+      }\n+      if (lag <= scaleInThreshold) {\n+        within++;\n+      }\n+    }\n+    double beyondProportion = beyond * 1.0 / metricsCount;\n+    double withinProportion = within * 1.0 / metricsCount;\n+    log.info(\"triggerSaleOutThresholdFrequency is [ \" + triggerSaleOutThresholdFrequency + \" ] and triggerSaleInThresholdFrequency is [ \" + triggerSaleInThresholdFrequency + \" ]\");", "originalCommit": "78cbd45577dccc3abd39fb03db6d2a9298e6c252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4NzA2Ng==", "url": "https://github.com/apache/druid/pull/10524#discussion_r531687066", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2020-11-27T16:24:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNTU2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "215844e6162e7095450b04aa6218989da939f37a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 16abe47e20..22554b7415 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -395,53 +406,53 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     }\n     double beyondProportion = beyond * 1.0 / metricsCount;\n     double withinProportion = within * 1.0 / metricsCount;\n-    log.info(\"triggerSaleOutThresholdFrequency is [ \" + triggerSaleOutThresholdFrequency + \" ] and triggerSaleInThresholdFrequency is [ \" + triggerSaleInThresholdFrequency + \" ]\");\n-    log.info(\"beyondProportion is [ \" + beyondProportion + \" ] and withinProportion is [ \" + withinProportion + \" ]\");\n+    log.debug(\"triggerScaleOutThresholdFrequency is [%s] and triggerScaleInThresholdFrequency is [%s] for dataSource [%s].\", triggerScaleOutThresholdFrequency, triggerScaleInThresholdFrequency, dataSource);\n+    log.info(\"beyondProportion is [%s] and withinProportion is [%s] for dataSource [%s].\", beyondProportion, withinProportion, dataSource);\n \n     int currentActiveTaskCount;\n     int desireActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (beyondProportion >= triggerSaleOutThresholdFrequency) {\n+    if (beyondProportion >= triggerScaleOutThresholdFrequency) {\n       // Do Scale out\n       int taskCount = currentActiveTaskCount + scaleOutStep;\n       if (currentActiveTaskCount == taskCountMax) {\n-        log.info(\"CurrentActiveTaskCount reach task count Max limit, skip to scale out tasks\");\n+        log.info(\"CurrentActiveTaskCount reach task count Max limit, skip to scale out tasks for dataSource [%s].\", dataSource);\n         return false;\n       } else {\n         desireActiveTaskCount = Math.min(taskCount, taskCountMax);\n       }\n-      log.info(\"Start to scale out tasks , current active task number [ \" + currentActiveTaskCount + \" ] and desire task number is [ \" + desireActiveTaskCount + \" ] \");\n+      log.debug(\"Start to scale out tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Set Task Count : \" + desireActiveTaskCount);\n-      setTaskCount(desireActiveTaskCount);\n+      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n+      changeTaskCountInIOConfig(desireActiveTaskCount);\n       return true;\n     }\n \n-    if (withinProportion >= triggerSaleInThresholdFrequency) {\n+    if (withinProportion >= triggerScaleInThresholdFrequency) {\n       // Do Scale in\n       int taskCount = currentActiveTaskCount - scaleInStep;\n       if (currentActiveTaskCount == taskCountMin) {\n-        log.info(\"CurrentActiveTaskCount reach task count Min limit, skip to scale in tasks\");\n+        log.info(\"CurrentActiveTaskCount reach task count Min limit, skip to scale in tasks for dataSource [%s].\", dataSource);\n         return false;\n       } else {\n         desireActiveTaskCount = Math.max(taskCount, taskCountMin);\n       }\n-      log.info(\"Start to scale in tasks , current active task number [ \" + currentActiveTaskCount + \" ] and desire task number is [ \" + desireActiveTaskCount + \" ] \");\n+      log.debug(\"Start to scale in tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Set Task Count : \" + desireActiveTaskCount);\n-      setTaskCount(desireActiveTaskCount);\n+      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n+      changeTaskCountInIOConfig(desireActiveTaskCount);\n       return true;\n     }\n     return false;\n   }\n \n-  private void setTaskCount(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n   {\n     ioConfig.setTaskCount(desireActiveTaskCount);\n     try {\n", "next_change": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -449,7 +401,6 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       changeTaskCountInIOConfig(desireActiveTaskCount);\n       return true;\n     }\n-    return false;\n   }\n \n   private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n", "next_change": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -376,36 +378,36 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desireActiveTaskCount == -1) {\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n       return true;\n     }\n   }\n \n-  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n   {\n-    ioConfig.setTaskCount(desireActiveTaskCount);\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n     try {\n       Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n       if (supervisorManager.isPresent()) {\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -414,7 +428,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n+        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -428,15 +426,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n-      log.warn(\"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n     }\n   }\n \n-  private void clearAllocationInfos()\n+  private void clearAllocationInfo()\n   {\n     activelyReadingTaskGroups.clear();\n     partitionGroups.clear();\n", "next_change": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"oid": "e8b7e09333f086603c824c7983b2eee8b8ef7d21", "url": "https://github.com/apache/druid/commit/e8b7e09333f086603c824c7983b2eee8b8ef7d21", "message": "Merge branch 'master' into kafka-dynamic-scale-ingest-tasks", "committedDate": "2020-11-27T02:12:39Z", "type": "commit"}, {"oid": "215844e6162e7095450b04aa6218989da939f37a", "url": "https://github.com/apache/druid/commit/215844e6162e7095450b04aa6218989da939f37a", "message": "change codes and add docs based on capistrant reviewed", "committedDate": "2020-11-27T12:07:24Z", "type": "commit"}, {"oid": "b3b75b20992d6a31e6c4012b6408eeaf03192c5b", "url": "https://github.com/apache/druid/commit/b3b75b20992d6a31e6c4012b6408eeaf03192c5b", "message": "midify test docs", "committedDate": "2020-11-27T12:10:24Z", "type": "commit"}, {"oid": "18375474208f172c5728a60f3935f4cc023ac981", "url": "https://github.com/apache/druid/commit/18375474208f172c5728a60f3935f4cc023ac981", "message": "modify docs", "committedDate": "2020-11-27T15:37:50Z", "type": "commit"}, {"oid": "50a94cadb70d153e5afc675e19ecf1b08654a8c1", "url": "https://github.com/apache/druid/commit/50a94cadb70d153e5afc675e19ecf1b08654a8c1", "message": "modify docs", "committedDate": "2020-11-27T16:25:40Z", "type": "commit"}, {"oid": "4a0d706626ab82ac438cb4c7c3ba89b4b94e653b", "url": "https://github.com/apache/druid/commit/4a0d706626ab82ac438cb4c7c3ba89b4b94e653b", "message": "modify docs", "committedDate": "2020-11-28T04:49:59Z", "type": "commit"}, {"oid": "aa70a5c33c6e1b50739a1b6f15ab3eb67586fb90", "url": "https://github.com/apache/druid/commit/aa70a5c33c6e1b50739a1b6f15ab3eb67586fb90", "message": "merge from master", "committedDate": "2021-01-15T00:11:13Z", "type": "commit"}, {"oid": "fb70688fa646c0d4826f1a8e224a76cf6a640427", "url": "https://github.com/apache/druid/commit/fb70688fa646c0d4826f1a8e224a76cf6a640427", "message": "merge from master", "committedDate": "2021-01-15T00:15:20Z", "type": "commit"}, {"oid": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "url": "https://github.com/apache/druid/commit/c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "message": "Extract the autoScale logic out of SeekableStreamSupervisor to minimize putting more stuff inside there &&  Make autoscaling algorithm configurable and scalable.", "committedDate": "2021-01-15T10:57:51Z", "type": "commit"}, {"oid": "76db5ba009fbd54d5b45ffcc3193d3c05373fbe0", "url": "https://github.com/apache/druid/commit/76db5ba009fbd54d5b45ffcc3193d3c05373fbe0", "message": "fix ci failed", "committedDate": "2021-01-16T07:52:06Z", "type": "commit"}, {"oid": "751175fc7cf449fe4adf533c3245878e483a70e6", "url": "https://github.com/apache/druid/commit/751175fc7cf449fe4adf533c3245878e483a70e6", "message": "revert msic.xml", "committedDate": "2021-01-16T07:53:16Z", "type": "commit"}, {"oid": "f8a67072ad8deeab6e1035589e568552cd5eec0c", "url": "https://github.com/apache/druid/commit/f8a67072ad8deeab6e1035589e568552cd5eec0c", "message": "add uts to test autoscaler create && scale out/in and kafka ingest with scale enable", "committedDate": "2021-01-16T22:33:41Z", "type": "commit"}, {"oid": "172cff7904038e2b700ca427cad490ea7751cf74", "url": "https://github.com/apache/druid/commit/172cff7904038e2b700ca427cad490ea7751cf74", "message": "add more uts", "committedDate": "2021-01-17T05:39:56Z", "type": "commit"}, {"oid": "57811be4b6fb66a4cfe7e32267a5730bb7e57e48", "url": "https://github.com/apache/druid/commit/57811be4b6fb66a4cfe7e32267a5730bb7e57e48", "message": "fix inner class check", "committedDate": "2021-01-17T06:49:13Z", "type": "commit"}, {"oid": "ff8105c173082116a9d346c6cd3caae44fda42d0", "url": "https://github.com/apache/druid/commit/ff8105c173082116a9d346c6cd3caae44fda42d0", "message": "add IT for kafka ingestion with autoscaler", "committedDate": "2021-01-26T02:39:38Z", "type": "commit"}, {"oid": "05571f7e0a124f3971ecc0716d85d3fb30581d5b", "url": "https://github.com/apache/druid/commit/05571f7e0a124f3971ecc0716d85d3fb30581d5b", "message": "add new IT in groups=kafka-index named testKafkaIndexDataWithWithAutoscaler", "committedDate": "2021-01-26T06:11:02Z", "type": "commit"}, {"oid": "f09d3d5d4f8374f29288994c955945cb1e33199e", "url": "https://github.com/apache/druid/commit/f09d3d5d4f8374f29288994c955945cb1e33199e", "message": "Merge branch 'master' into kafka-dynamic-scale-ingest-tasks", "committedDate": "2021-01-26T06:16:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk4MTY0OQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r556981649", "body": "nit: I see that concept of storing lag stats in `ArrayList<Long>` predates your PR, it might be simpler to define a new class like and change to..... and make related changes in other places where this `ArrayList` is used\r\n\r\n```suggestion\r\n  protected abstract LagStats computeLagStats();\r\n  \r\n  static class LagStats\r\n  {\r\n    private final long maxLag;\r\n    private final long totalLag;\r\n    private final long avgLag;\r\n\r\n    public LagStats(long maxLag, long totalLag, long avgLag)\r\n    {\r\n      this.maxLag = maxLag;\r\n      this.totalLag = totalLag;\r\n      this.avgLag = avgLag;\r\n    }\r\n\r\n    public long getMaxLag()\r\n    {\r\n      return maxLag;\r\n    }\r\n\r\n    public long getTotalLag()\r\n    {\r\n      return totalLag;\r\n    }\r\n\r\n    public long getAvgLag()\r\n    {\r\n      return avgLag;\r\n    }\r\n  }\r\n```", "bodyText": "nit: I see that concept of storing lag stats in ArrayList<Long> predates your PR, it might be simpler to define a new class like and change to..... and make related changes in other places where this ArrayList is used\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected abstract void collectLag(ArrayList<Long> lags);\n          \n          \n            \n              protected abstract LagStats computeLagStats();\n          \n          \n            \n              \n          \n          \n            \n              static class LagStats\n          \n          \n            \n              {\n          \n          \n            \n                private final long maxLag;\n          \n          \n            \n                private final long totalLag;\n          \n          \n            \n                private final long avgLag;\n          \n          \n            \n            \n          \n          \n            \n                public LagStats(long maxLag, long totalLag, long avgLag)\n          \n          \n            \n                {\n          \n          \n            \n                  this.maxLag = maxLag;\n          \n          \n            \n                  this.totalLag = totalLag;\n          \n          \n            \n                  this.avgLag = avgLag;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public long getMaxLag()\n          \n          \n            \n                {\n          \n          \n            \n                  return maxLag;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public long getTotalLag()\n          \n          \n            \n                {\n          \n          \n            \n                  return totalLag;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public long getAvgLag()\n          \n          \n            \n                {\n          \n          \n            \n                  return avgLag;\n          \n          \n            \n                }\n          \n          \n            \n              }", "bodyHTML": "<p dir=\"auto\">nit: I see that concept of storing lag stats in <code>ArrayList&lt;Long&gt;</code> predates your PR, it might be simpler to define a new class like and change to..... and make related changes in other places where this <code>ArrayList</code> is used</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">  <span class=\"pl-k\">protected</span> <span class=\"pl-k\">abstract</span> <span class=\"pl-k x x-first\">void</span><span class=\"x\"> collectLag(</span><span class=\"pl-k\"><span class=\"x\">ArrayList&lt;</span><span class=\"pl-smi x\">Long</span><span class=\"x\">&gt;</span></span><span class=\"x x-last\"> lags</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  <span class=\"pl-k\">protected</span> <span class=\"pl-k\">abstract</span> <span class=\"pl-smi x x-first\">LagStats</span><span class=\"x x-last\"> computeLagStats(</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  </td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  <span class=\"pl-k\">static</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">LagStats</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k\">long</span> maxLag;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k\">long</span> totalLag;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k\">long</span> avgLag;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">public</span> LagStats(<span class=\"pl-k\">long</span> maxLag, <span class=\"pl-k\">long</span> totalLag, <span class=\"pl-k\">long</span> avgLag)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>maxLag <span class=\"pl-k\">=</span> maxLag;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>totalLag <span class=\"pl-k\">=</span> totalLag;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>avgLag <span class=\"pl-k\">=</span> avgLag;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">public</span> <span class=\"pl-k\">long</span> getMaxLag()</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-k\">return</span> maxLag;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">public</span> <span class=\"pl-k\">long</span> getTotalLag()</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-k\">return</span> totalLag;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">public</span> <span class=\"pl-k\">long</span> getAvgLag()</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-k\">return</span> avgLag;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  }</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "himanshug", "createdAt": "2021-01-14T01:16:30Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -3561,4 +3874,11 @@ protected void emitLag()\n    * sequences. In Kafka, start offsets are always inclusive.\n    */\n   protected abstract boolean useExclusiveStartSequenceNumberForNonFirstSequence();\n+\n+  /**\n+   * Collect maxLag, totalLag, avgLag into ArrayList<Long> lags\n+   * Only support Kafka ingestion so far.\n+   * @param lags , Notice : The order of values is maxLag, totalLag and avgLag.\n+   */\n+  protected abstract void collectLag(ArrayList<Long> lags);", "originalCommit": "4a0d706626ab82ac438cb4c7c3ba89b4b94e653b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk3NDA4MA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r569974080", "bodyText": "Nice idea. Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-04T06:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk4MTY0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c0b3ff258020bd17c1e370ac2b71b872b27f25a8", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 22554b7415..712627a03c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -3874,11 +3748,4 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    * sequences. In Kafka, start offsets are always inclusive.\n    */\n   protected abstract boolean useExclusiveStartSequenceNumberForNonFirstSequence();\n-\n-  /**\n-   * Collect maxLag, totalLag, avgLag into ArrayList<Long> lags\n-   * Only support Kafka ingestion so far.\n-   * @param lags , Notice : The order of values is maxLag, totalLag and avgLag.\n-   */\n-  protected abstract void collectLag(ArrayList<Long> lags);\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQ2NzQzNg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r561467436", "body": "can this be added as `default` impl in `SupervisorSpec` interface?", "bodyText": "can this be added as default impl in SupervisorSpec interface?", "bodyHTML": "<p dir=\"auto\">can this be added as <code>default</code> impl in <code>SupervisorSpec</code> interface?</p>", "author": "himanshug", "createdAt": "2021-01-21T02:01:04Z", "path": "extensions-contrib/materialized-view-maintenance/src/main/java/org/apache/druid/indexing/materializedview/MaterializedViewSupervisorSpec.java", "diffHunk": "@@ -361,6 +362,12 @@ public Supervisor createSupervisor()\n     );\n   }\n \n+  @Override\n+  public SupervisorTaskAutoscaler createAutoscaler(Supervisor supervisor)\n+  {\n+    return null;\n+  }\n+", "originalCommit": "57811be4b6fb66a4cfe7e32267a5730bb7e57e48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk3NDEzOQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r569974139", "bodyText": "changed.", "author": "zhangyue19921010", "createdAt": "2021-02-04T06:24:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQ2NzQzNg=="}], "type": "inlineReview", "revised_code": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/extensions-contrib/materialized-view-maintenance/src/main/java/org/apache/druid/indexing/materializedview/MaterializedViewSupervisorSpec.java b/extensions-contrib/materialized-view-maintenance/src/main/java/org/apache/druid/indexing/materializedview/MaterializedViewSupervisorSpec.java\nindex c46a22098b..db63a7316d 100644\n--- a/extensions-contrib/materialized-view-maintenance/src/main/java/org/apache/druid/indexing/materializedview/MaterializedViewSupervisorSpec.java\n+++ b/extensions-contrib/materialized-view-maintenance/src/main/java/org/apache/druid/indexing/materializedview/MaterializedViewSupervisorSpec.java\n", "chunk": "@@ -362,12 +361,6 @@ public class MaterializedViewSupervisorSpec implements SupervisorSpec\n     );\n   }\n \n-  @Override\n-  public SupervisorTaskAutoscaler createAutoscaler(Supervisor supervisor)\n-  {\n-    return null;\n-  }\n-\n   @Override\n   public List<String> getDataSources()\n   {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODIzNTc5OA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r568235798", "body": "At this time, I think this is very specific to `KafkaSupervisor` and it seems that currently we only want to support autoscaling for kafka indexing , so I would say in this PR, we rename `DefaultAutoScaler` to `KafkaIndexingDefaultAutoScaler` and let `KafkaIndexingDefaultAutoScaler` cast `Supervisor` to `KafkaSupervisor` so as to use `KafkaSupervisor.collectLag(..)` directly and not have it in the interface.\r\n\r\nIf, at a later time, Kinesis starts using it in some form, then `Supervisor` interface can be modified at that time.", "bodyText": "At this time, I think this is very specific to KafkaSupervisor and it seems that currently we only want to support autoscaling for kafka indexing , so I would say in this PR, we rename DefaultAutoScaler to KafkaIndexingDefaultAutoScaler and let KafkaIndexingDefaultAutoScaler cast Supervisor to KafkaSupervisor so as to use KafkaSupervisor.collectLag(..) directly and not have it in the interface.\nIf, at a later time, Kinesis starts using it in some form, then Supervisor interface can be modified at that time.", "bodyHTML": "<p dir=\"auto\">At this time, I think this is very specific to <code>KafkaSupervisor</code> and it seems that currently we only want to support autoscaling for kafka indexing , so I would say in this PR, we rename <code>DefaultAutoScaler</code> to <code>KafkaIndexingDefaultAutoScaler</code> and let <code>KafkaIndexingDefaultAutoScaler</code> cast <code>Supervisor</code> to <code>KafkaSupervisor</code> so as to use <code>KafkaSupervisor.collectLag(..)</code> directly and not have it in the interface.</p>\n<p dir=\"auto\">If, at a later time, Kinesis starts using it in some form, then <code>Supervisor</code> interface can be modified at that time.</p>", "author": "himanshug", "createdAt": "2021-02-02T00:25:16Z", "path": "server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java", "diffHunk": "@@ -64,4 +66,18 @@ default Boolean isHealthy()\n    * @param checkpointMetadata metadata for the sequence to currently checkpoint\n    */\n   void checkpoint(int taskGroupId, DataSourceMetadata checkpointMetadata);\n+\n+  /**\n+   * Collect maxLag, totalLag, avgLag into ArrayList<Long> lags\n+   * Only support Kafka ingestion so far.\n+   * @param lags , Notice : The order of values is maxLag, totalLag and avgLag.\n+   */\n+  void collectLag(ArrayList<Long> lags);", "originalCommit": "f09d3d5d4f8374f29288994c955945cb1e33199e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk3OTkxNg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r569979916", "bodyText": "Ya, for now, we only support Kafka autoScaler. But based on \n  \n    \n      druid/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n    \n    \n         Line 3499\n      in\n      118b501\n    \n    \n    \n    \n\n        \n          \n           Map<PartitionIdType, Long> partitionTimeLags = getPartitionTimeLag(); \n        \n    \n  \n\n It   may be not hard to support kinesis autoscaler. And I'm glad to work on it soon. So maybe keep the code abstract is more meaningful and there are plenty preparation to ensure that users will not set kinesis auto scale by accident:\n\nDocs mention\nthrow new UnsupportedOperationException(\"Tasks auto scaler for kinesis is not supported yet. Please remove autoscalerConfig or set it null!\"); in KinesisSupervisorIOConfig\nset autoscalerConfig = null when super(xxx) in KinesisSupervisorIOConfig\n\nAlso we can't cast Supervisor to KafkaSupervisor directly unless add an extra dependency druid-kafka-indexing-service in indexing-service module.", "author": "zhangyue19921010", "createdAt": "2021-02-04T06:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODIzNTc5OA=="}], "type": "inlineReview", "revised_code": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java b/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\nindex b4df1c2c12..b345163b2c 100644\n--- a/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\n+++ b/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\n", "chunk": "@@ -68,16 +67,10 @@ public interface Supervisor\n   void checkpoint(int taskGroupId, DataSourceMetadata checkpointMetadata);\n \n   /**\n-   * Collect maxLag, totalLag, avgLag into ArrayList<Long> lags\n+   * Collect maxLag, totalLag, avgLag\n    * Only support Kafka ingestion so far.\n-   * @param lags , Notice : The order of values is maxLag, totalLag and avgLag.\n    */\n-  void collectLag(ArrayList<Long> lags);\n+  LagStats computeLagStats();\n \n-  /**\n-   * use for autoscaler\n-   */\n-  Runnable buildDynamicAllocationTask(Callable<Integer> scaleAction);\n-\n-  Map getSupervisorTaskInfos();\n+  int getActiveTaskGroupsCount();\n }\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java b/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\nindex b345163b2c..66d11399bd 100644\n--- a/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\n+++ b/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\n", "chunk": "@@ -67,8 +67,8 @@ public interface Supervisor\n   void checkpoint(int taskGroupId, DataSourceMetadata checkpointMetadata);\n \n   /**\n-   * Collect maxLag, totalLag, avgLag\n-   * Only support Kafka ingestion so far.\n+   * Computes maxLag, totalLag and avgLag\n+   * Only supports Kafka ingestion so far.\n    */\n   LagStats computeLagStats();\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODIzNjUyNA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r568236524", "body": "can we instead have `void reconcileTaskCount()` which looks at current task count in the io config, and does things to match that many number of active tasks.\r\n\r\nautoscale impl would be responsible for updating the task count in task io config and then calling this method.", "bodyText": "can we instead have void reconcileTaskCount() which looks at current task count in the io config, and does things to match that many number of active tasks.\nautoscale impl would be responsible for updating the task count in task io config and then calling this method.", "bodyHTML": "<p dir=\"auto\">can we instead have <code>void reconcileTaskCount()</code> which looks at current task count in the io config, and does things to match that many number of active tasks.</p>\n<p dir=\"auto\">autoscale impl would be responsible for updating the task count in task io config and then calling this method.</p>", "author": "himanshug", "createdAt": "2021-02-02T00:27:10Z", "path": "server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java", "diffHunk": "@@ -64,4 +66,18 @@ default Boolean isHealthy()\n    * @param checkpointMetadata metadata for the sequence to currently checkpoint\n    */\n   void checkpoint(int taskGroupId, DataSourceMetadata checkpointMetadata);\n+\n+  /**\n+   * Collect maxLag, totalLag, avgLag into ArrayList<Long> lags\n+   * Only support Kafka ingestion so far.\n+   * @param lags , Notice : The order of values is maxLag, totalLag and avgLag.\n+   */\n+  void collectLag(ArrayList<Long> lags);\n+\n+  /**\n+   * use for autoscaler\n+   */\n+  Runnable buildDynamicAllocationTask(Callable<Integer> scaleAction);", "originalCommit": "f09d3d5d4f8374f29288994c955945cb1e33199e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk4MDk4MQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r569980981", "bodyText": "Nice catch! I review the code and find out there is no need for this buildDynamicAllocationTask  method in Supervisor.java and autoscaler can build autoscale notice itself and supervisor will do scale action.\nSo I removed buildDynamicAllocationTask func in Supervisor.java", "author": "zhangyue19921010", "createdAt": "2021-02-04T06:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODIzNjUyNA=="}], "type": "inlineReview", "revised_code": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java b/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\nindex b4df1c2c12..b345163b2c 100644\n--- a/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\n+++ b/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\n", "chunk": "@@ -68,16 +67,10 @@ public interface Supervisor\n   void checkpoint(int taskGroupId, DataSourceMetadata checkpointMetadata);\n \n   /**\n-   * Collect maxLag, totalLag, avgLag into ArrayList<Long> lags\n+   * Collect maxLag, totalLag, avgLag\n    * Only support Kafka ingestion so far.\n-   * @param lags , Notice : The order of values is maxLag, totalLag and avgLag.\n    */\n-  void collectLag(ArrayList<Long> lags);\n+  LagStats computeLagStats();\n \n-  /**\n-   * use for autoscaler\n-   */\n-  Runnable buildDynamicAllocationTask(Callable<Integer> scaleAction);\n-\n-  Map getSupervisorTaskInfos();\n+  int getActiveTaskGroupsCount();\n }\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java b/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\nindex b345163b2c..66d11399bd 100644\n--- a/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\n+++ b/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\n", "chunk": "@@ -67,8 +67,8 @@ public interface Supervisor\n   void checkpoint(int taskGroupId, DataSourceMetadata checkpointMetadata);\n \n   /**\n-   * Collect maxLag, totalLag, avgLag\n-   * Only support Kafka ingestion so far.\n+   * Computes maxLag, totalLag and avgLag\n+   * Only supports Kafka ingestion so far.\n    */\n   LagStats computeLagStats();\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODIzNzE4Mw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r568237183", "body": "seems we only really need the active task group count, so, can we have `int getActiveTaskGroupsCount()` instead ?", "bodyText": "seems we only really need the active task group count, so, can we have int getActiveTaskGroupsCount() instead ?", "bodyHTML": "<p dir=\"auto\">seems we only really need the active task group count, so, can we have <code>int getActiveTaskGroupsCount()</code> instead ?</p>", "author": "himanshug", "createdAt": "2021-02-02T00:28:07Z", "path": "server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java", "diffHunk": "@@ -64,4 +66,18 @@ default Boolean isHealthy()\n    * @param checkpointMetadata metadata for the sequence to currently checkpoint\n    */\n   void checkpoint(int taskGroupId, DataSourceMetadata checkpointMetadata);\n+\n+  /**\n+   * Collect maxLag, totalLag, avgLag into ArrayList<Long> lags\n+   * Only support Kafka ingestion so far.\n+   * @param lags , Notice : The order of values is maxLag, totalLag and avgLag.\n+   */\n+  void collectLag(ArrayList<Long> lags);\n+\n+  /**\n+   * use for autoscaler\n+   */\n+  Runnable buildDynamicAllocationTask(Callable<Integer> scaleAction);\n+\n+  Map getSupervisorTaskInfos();", "originalCommit": "f09d3d5d4f8374f29288994c955945cb1e33199e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk4MTAzNg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r569981036", "bodyText": "Sure. Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-04T06:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODIzNzE4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java b/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\nindex b4df1c2c12..b345163b2c 100644\n--- a/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\n+++ b/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\n", "chunk": "@@ -68,16 +67,10 @@ public interface Supervisor\n   void checkpoint(int taskGroupId, DataSourceMetadata checkpointMetadata);\n \n   /**\n-   * Collect maxLag, totalLag, avgLag into ArrayList<Long> lags\n+   * Collect maxLag, totalLag, avgLag\n    * Only support Kafka ingestion so far.\n-   * @param lags , Notice : The order of values is maxLag, totalLag and avgLag.\n    */\n-  void collectLag(ArrayList<Long> lags);\n+  LagStats computeLagStats();\n \n-  /**\n-   * use for autoscaler\n-   */\n-  Runnable buildDynamicAllocationTask(Callable<Integer> scaleAction);\n-\n-  Map getSupervisorTaskInfos();\n+  int getActiveTaskGroupsCount();\n }\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java b/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\nindex b345163b2c..66d11399bd 100644\n--- a/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\n+++ b/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\n", "chunk": "@@ -67,8 +67,8 @@ public interface Supervisor\n   void checkpoint(int taskGroupId, DataSourceMetadata checkpointMetadata);\n \n   /**\n-   * Collect maxLag, totalLag, avgLag\n-   * Only support Kafka ingestion so far.\n+   * Computes maxLag, totalLag and avgLag\n+   * Only supports Kafka ingestion so far.\n    */\n   LagStats computeLagStats();\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODIzODE0Mw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r568238143", "body": "these should throw UnSupportedOperationException instead as they are not supposed to be called", "bodyText": "these should throw UnSupportedOperationException instead as they are not supposed to be called", "bodyHTML": "<p dir=\"auto\">these should throw UnSupportedOperationException instead as they are not supposed to be called</p>", "author": "himanshug", "createdAt": "2021-02-02T00:30:43Z", "path": "extensions-contrib/materialized-view-maintenance/src/main/java/org/apache/druid/indexing/materializedview/MaterializedViewSupervisor.java", "diffHunk": "@@ -282,6 +283,23 @@ public void checkpoint(int taskGroupId, DataSourceMetadata checkpointMetadata)\n     // do nothing\n   }\n \n+  @Override\n+  public void collectLag(ArrayList<Long> lags)\n+  {\n+  }\n+\n+  @Override\n+  public Runnable buildDynamicAllocationTask(Callable<Integer> scaleAction)\n+  {\n+    return null;\n+  }\n+\n+  @Override\n+  public Map getSupervisorTaskInfos()\n+  {\n+    return null;\n+  }\n+", "originalCommit": "f09d3d5d4f8374f29288994c955945cb1e33199e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk4MTExMA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r569981110", "bodyText": "Sure. Done.", "author": "zhangyue19921010", "createdAt": "2021-02-04T06:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODIzODE0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/extensions-contrib/materialized-view-maintenance/src/main/java/org/apache/druid/indexing/materializedview/MaterializedViewSupervisor.java b/extensions-contrib/materialized-view-maintenance/src/main/java/org/apache/druid/indexing/materializedview/MaterializedViewSupervisor.java\nindex be6289d2cb..f456cb611c 100644\n--- a/extensions-contrib/materialized-view-maintenance/src/main/java/org/apache/druid/indexing/materializedview/MaterializedViewSupervisor.java\n+++ b/extensions-contrib/materialized-view-maintenance/src/main/java/org/apache/druid/indexing/materializedview/MaterializedViewSupervisor.java\n", "chunk": "@@ -284,20 +284,15 @@ public class MaterializedViewSupervisor implements Supervisor\n   }\n \n   @Override\n-  public void collectLag(ArrayList<Long> lags)\n+  public LagStats computeLagStats()\n   {\n+    throw new UnsupportedOperationException(\"Compute Lag Stats not supported in MaterializedViewSupervisor\");\n   }\n \n   @Override\n-  public Runnable buildDynamicAllocationTask(Callable<Integer> scaleAction)\n+  public int getActiveTaskGroupsCount()\n   {\n-    return null;\n-  }\n-\n-  @Override\n-  public Map getSupervisorTaskInfos()\n-  {\n-    return null;\n+    throw new UnsupportedOperationException(\"Get Active Task Groups Count is not supported in MaterializedViewSupervisor\");\n   }\n \n   /**\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODIzODcxMA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r568238710", "body": "we should actually throw exception if someone sets this on a kinesis supervisor spec ... as that is not expected.", "bodyText": "we should actually throw exception if someone sets this on a kinesis supervisor spec ... as that is not expected.", "bodyHTML": "<p dir=\"auto\">we should actually throw exception if someone sets this on a kinesis supervisor spec ... as that is not expected.</p>", "author": "himanshug", "createdAt": "2021-02-02T00:32:31Z", "path": "extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java", "diffHunk": "@@ -70,6 +72,7 @@ public KinesisSupervisorIOConfig(\n       @JsonProperty(\"fetchDelayMillis\") Integer fetchDelayMillis,\n       @JsonProperty(\"awsAssumedRoleArn\") String awsAssumedRoleArn,\n       @JsonProperty(\"awsExternalId\") String awsExternalId,\n+      @JsonProperty(\"dynamicAllocationTasksProperties\") Map<String, Object> dynamicAllocationTasksProperties,", "originalCommit": "f09d3d5d4f8374f29288994c955945cb1e33199e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDAxNDMwOA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r570014308", "bodyText": "Sure. Done.", "author": "zhangyue19921010", "createdAt": "2021-02-04T07:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODIzODcxMA=="}], "type": "inlineReview", "revised_code": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\nindex 1316981865..d6c2b37749 100644\n--- a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n+++ b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n", "chunk": "@@ -72,7 +72,7 @@ public class KinesisSupervisorIOConfig extends SeekableStreamSupervisorIOConfig\n       @JsonProperty(\"fetchDelayMillis\") Integer fetchDelayMillis,\n       @JsonProperty(\"awsAssumedRoleArn\") String awsAssumedRoleArn,\n       @JsonProperty(\"awsExternalId\") String awsExternalId,\n-      @JsonProperty(\"dynamicAllocationTasksProperties\") Map<String, Object> dynamicAllocationTasksProperties,\n+      @JsonProperty(\"autoscalerConfig\") Map<String, Object> autoscalerConfig,\n       @JsonProperty(\"deaggregate\") boolean deaggregate\n   )\n   {\n", "next_change": {"commit": "0733590862fa43068e19b15d85dc5507732f7620", "changed_code": [{"header": "diff --git a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\nindex d6c2b37749..7db2cce722 100644\n--- a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n+++ b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n", "chunk": "@@ -72,7 +71,7 @@ public class KinesisSupervisorIOConfig extends SeekableStreamSupervisorIOConfig\n       @JsonProperty(\"fetchDelayMillis\") Integer fetchDelayMillis,\n       @JsonProperty(\"awsAssumedRoleArn\") String awsAssumedRoleArn,\n       @JsonProperty(\"awsExternalId\") String awsExternalId,\n-      @JsonProperty(\"autoscalerConfig\") Map<String, Object> autoscalerConfig,\n+      @JsonProperty(\"autoscalerConfig\") AutoScalerConfig autoscalerConfig,\n       @JsonProperty(\"deaggregate\") boolean deaggregate\n   )\n   {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\nindex 7db2cce722..b43cece0e5 100644\n--- a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n+++ b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n", "chunk": "@@ -71,7 +73,7 @@ public class KinesisSupervisorIOConfig extends SeekableStreamSupervisorIOConfig\n       @JsonProperty(\"fetchDelayMillis\") Integer fetchDelayMillis,\n       @JsonProperty(\"awsAssumedRoleArn\") String awsAssumedRoleArn,\n       @JsonProperty(\"awsExternalId\") String awsExternalId,\n-      @JsonProperty(\"autoscalerConfig\") AutoScalerConfig autoscalerConfig,\n+      @Nullable @JsonProperty(\"autoScalerConfig\") AutoScalerConfig autoScalerConfig,\n       @JsonProperty(\"deaggregate\") boolean deaggregate\n   )\n   {\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0NTY1MQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r568245651", "body": "could we instead get a handle to `SupervisorTaskAutoscaler` and have `SupervisorTaskAutoscaler.getMaxTaskCount()` provide maximum task count ?", "bodyText": "could we instead get a handle to SupervisorTaskAutoscaler and have SupervisorTaskAutoscaler.getMaxTaskCount() provide maximum task count ?", "bodyHTML": "<p dir=\"auto\">could we instead get a handle to <code>SupervisorTaskAutoscaler</code> and have <code>SupervisorTaskAutoscaler.getMaxTaskCount()</code> provide maximum task count ?</p>", "author": "himanshug", "createdAt": "2021-02-02T00:49:30Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -519,20 +636,40 @@ public SeekableStreamSupervisor(\n     this.useExclusiveStartingSequence = useExclusiveStartingSequence;\n     this.dataSource = spec.getDataSchema().getDataSource();\n     this.ioConfig = spec.getIoConfig();\n+    this.dynamicAllocationTasksProperties = ioConfig.getDynamicAllocationTasksProperties();", "originalCommit": "f09d3d5d4f8374f29288994c955945cb1e33199e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk4Mzg3MA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r569983870", "bodyText": "Sure, It is a little strange that use map.getOrDefault() here, because default value is hard to be unified.\nI modified the way of obtaining configurations from Map to new interface AutoScalerConfig with a default impl DefaultAutoScaleConfig. So that we can use JackSon to Instantiate a Config with default values instead of map.get/parse everywhere. Also ensure consistency of default values.\nIn this way, we don't need to get a handle to SupervisorTaskAutoscaler, just autoScalerConfig.getTaskCountMax() :)", "author": "zhangyue19921010", "createdAt": "2021-02-04T06:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0NTY1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..0b5c238997 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -636,16 +640,16 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     this.useExclusiveStartingSequence = useExclusiveStartingSequence;\n     this.dataSource = spec.getDataSchema().getDataSource();\n     this.ioConfig = spec.getIoConfig();\n-    this.dynamicAllocationTasksProperties = ioConfig.getDynamicAllocationTasksProperties();\n-    log.debug(\"Get dynamicAllocationTasksProperties from IOConfig : [%s] in [%s]\", dynamicAllocationTasksProperties, dataSource);\n-    if (dynamicAllocationTasksProperties != null && !dynamicAllocationTasksProperties.isEmpty() && Boolean.parseBoolean(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"enableDynamicAllocationTasks\", false)))) {\n-      log.info(\"EnableDynamicAllocationTasks for datasource [%s]\", dataSource);\n-      this.taskCountMax = Integer.parseInt(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"taskCountMax\", 4)));\n-      this.minTriggerDynamicFrequency = Long.parseLong(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 600000)));\n-      this.enableDynamicAllocationTasks = true;\n+    this.autoscalerConfig = ioConfig.getautoscalerConfig();\n+    log.debug(\"Get autoscalerConfig from IOConfig : [%s] in [%s]\", autoscalerConfig, dataSource);\n+    if (autoscalerConfig != null && !autoscalerConfig.isEmpty() && Boolean.parseBoolean(String.valueOf(autoscalerConfig.getOrDefault(\"enableTaskAutoscaler\", true)))) {\n+      log.info(\"enableTaskAutoscaler for datasource [%s]\", dataSource);\n+      this.taskCountMax = Integer.parseInt(String.valueOf(autoscalerConfig.getOrDefault(\"taskCountMax\", TASK_COUNT_MAX)));\n+      this.minTriggerDynamicFrequency = Long.parseLong(String.valueOf(autoscalerConfig.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 600000)));\n+      this.enableTaskAutoscaler = true;\n     } else {\n       log.info(\"Disable dynamic allocate tasks for [%s]\", dataSource);\n-      this.enableDynamicAllocationTasks = false;\n+      this.enableTaskAutoscaler = false;\n     }\n \n     this.tuningConfig = spec.getTuningConfig();\n", "next_change": {"commit": "25fec0ff18d0acb79734dd93bedccff3ab43308a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 0b5c238997..eb2797cc58 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -640,18 +635,9 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     this.useExclusiveStartingSequence = useExclusiveStartingSequence;\n     this.dataSource = spec.getDataSchema().getDataSource();\n     this.ioConfig = spec.getIoConfig();\n-    this.autoscalerConfig = ioConfig.getautoscalerConfig();\n-    log.debug(\"Get autoscalerConfig from IOConfig : [%s] in [%s]\", autoscalerConfig, dataSource);\n-    if (autoscalerConfig != null && !autoscalerConfig.isEmpty() && Boolean.parseBoolean(String.valueOf(autoscalerConfig.getOrDefault(\"enableTaskAutoscaler\", true)))) {\n-      log.info(\"enableTaskAutoscaler for datasource [%s]\", dataSource);\n-      this.taskCountMax = Integer.parseInt(String.valueOf(autoscalerConfig.getOrDefault(\"taskCountMax\", TASK_COUNT_MAX)));\n-      this.minTriggerDynamicFrequency = Long.parseLong(String.valueOf(autoscalerConfig.getOrDefault(\"minTriggerDynamicFrequencyMillis\", 600000)));\n-      this.enableTaskAutoscaler = true;\n-    } else {\n-      log.info(\"Disable dynamic allocate tasks for [%s]\", dataSource);\n-      this.enableTaskAutoscaler = false;\n-    }\n-\n+    Map<String, Object> autoscalerConfigMap = ioConfig.getAutoscalerConfig();\n+    this.autoScalerConfig = mapper.convertValue(autoscalerConfigMap, AutoScalerConfig.class);\n+    log.debug(\"Get autoscalerConfig from IOConfig : [%s] in [%s]\", autoscalerConfigMap, dataSource);\n     this.tuningConfig = spec.getTuningConfig();\n     this.taskTuningConfig = this.tuningConfig.convertToTaskTuningConfig();\n     this.supervisorId = supervisorId;\n", "next_change": {"commit": "0733590862fa43068e19b15d85dc5507732f7620", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex eb2797cc58..21ed86ab31 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -635,9 +635,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     this.useExclusiveStartingSequence = useExclusiveStartingSequence;\n     this.dataSource = spec.getDataSchema().getDataSource();\n     this.ioConfig = spec.getIoConfig();\n-    Map<String, Object> autoscalerConfigMap = ioConfig.getAutoscalerConfig();\n-    this.autoScalerConfig = mapper.convertValue(autoscalerConfigMap, AutoScalerConfig.class);\n-    log.debug(\"Get autoscalerConfig from IOConfig : [%s] in [%s]\", autoscalerConfigMap, dataSource);\n+    this.autoScalerConfig = ioConfig.getAutoscalerConfig();\n     this.tuningConfig = spec.getTuningConfig();\n     this.taskTuningConfig = this.tuningConfig.convertToTaskTuningConfig();\n     this.supervisorId = supervisorId;\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0Nzk0NA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r568247944", "body": "this type of logic should live inside the autoscaler impl I think which should decide when to trigger the autoscaling", "bodyText": "this type of logic should live inside the autoscaler impl I think which should decide when to trigger the autoscaling", "bodyHTML": "<p dir=\"auto\">this type of logic should live inside the autoscaler impl I think which should decide when to trigger the autoscaling</p>", "author": "himanshug", "createdAt": "2021-02-02T00:56:01Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +322,114 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+            return;\n+          }\n+        }\n+        if (nowTime - dynamicTriggerLastRunTime < minTriggerDynamicFrequency) {", "originalCommit": "f09d3d5d4f8374f29288994c955945cb1e33199e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk4ODAwOQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r569988009", "bodyText": "Thanks for your attention.\nActually, there are three hard conditions before do scale action:\n\nDon't scale when supervisor is suspended.\nDon't scale when previous task is handing off to avoid inconsistent state.\nDon't scale durning cool down time to avoid overly frequent scaling.\n\nAnd I think no matter what the task type is, no matter what the autoscaler impl is, it maybe better to follow these three common conditions.\nAlso users can define their own conditions like TaskCountLimitation in specific impl :)", "author": "zhangyue19921010", "createdAt": "2021-02-04T07:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0Nzk0NA=="}], "type": "inlineReview", "revised_code": {"commit": "25fec0ff18d0acb79734dd93bedccff3ab43308a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 712627a03c..eb2797cc58 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -352,8 +354,8 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n             return;\n           }\n         }\n-        if (nowTime - dynamicTriggerLastRunTime < minTriggerDynamicFrequency) {\n-          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, minTriggerDynamicFrequency, dataSource);\n+        if (nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n           return;\n         }\n \n", "next_change": {"commit": "972690294bf199ec0b93d01d5f44e3d9c008720c", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex eb2797cc58..aa1636b3ce 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -354,7 +354,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n             return;\n           }\n         }\n-        if (nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n           log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n           return;\n         }\n", "next_change": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex aa1636b3ce..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -355,7 +355,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n           }\n         }\n         if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n-          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n           return;\n         }\n \n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -340,48 +340,59 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     @Override\n     public void handle()\n     {\n-      try {\n-        long nowTime = System.currentTimeMillis();\n-        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n-        if (spec.isSuspended()) {\n-          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n-          return;\n-        }\n-        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n-        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n-          if (!list.isEmpty()) {\n-            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+      if (autoScalerConfig == null) {\n+        log.warn(\"autoScalerConfig is null but dynamic allocation notice is submitted, how can it be ?\");\n+      } else {\n+        try {\n+          long nowTime = System.currentTimeMillis();\n+          if (spec.isSuspended()) {\n+            log.info(\"Skipping DynamicAllocationTasksNotice execution because [%s] supervisor is suspended\",\n+                    dataSource\n+            );\n             return;\n           }\n+          log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s]\", pendingCompletionTaskGroups,\n+                  dataSource\n+          );\n+          for (CopyOnWriteArrayList<TaskGroup> list : pendingCompletionTaskGroups.values()) {\n+            if (!list.isEmpty()) {\n+              log.info(\n+                      \"Skipping DynamicAllocationTasksNotice execution for datasource [%s] because following tasks are pending [%s]\",\n+                      dataSource, pendingCompletionTaskGroups\n+              );\n+              return;\n+            }\n+          }\n+          if (nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+            log.info(\n+                    \"DynamicAllocationTasksNotice submitted again in [%d] millis, minTriggerDynamicFrequency is [%s] for dataSource [%s], skipping it!\",\n+                    nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource\n+            );\n+            return;\n+          }\n+          Integer desriedTaskCount = scaleAction.call();\n+          boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+          if (allocationSuccess) {\n+            dynamicTriggerLastRunTime = nowTime;\n+          }\n         }\n-        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n-          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n-          return;\n-        }\n-\n-        Integer desriedTaskCount = scaleAction.call();\n-        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n-\n-        if (allocationSuccess) {\n-          dynamicTriggerLastRunTime = nowTime;\n+        catch (Exception ex) {\n+          log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n         }\n       }\n-      catch (Exception ex) {\n-        log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n-      }\n     }\n   }\n \n   /**\n    * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n-   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n-   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n-   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuild in the next 'RunNotice'.\n+   *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\n+   * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\n    * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n-   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n+   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n+   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod' millis.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -387,17 +386,17 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n    *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\n-   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuild in the next 'RunNotice'.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled in the next 'RunNotice'.\n    *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\n    * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\n-   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n-   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n-   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod' millis.\n+   * @param desiredActiveTaskCount desired taskCount computed from AutoScaler\n+   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerScaleActionFrequencyMillis' before next 'changeTaskCount'.\n+   *         If false, it will do 'changeTaskCount' again after 'scaleActionPeriodMillis' millis.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n", "next_change": {"commit": "22339ddc83976758809570dd1c92d7506c26fcfa", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..468363dcbe 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -396,13 +396,13 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean changeTaskCount(int desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n+    if (desiredActiveTaskCount < 0 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n       log.info(\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0OTE2Ng==", "url": "https://github.com/apache/druid/pull/10524#discussion_r568249166", "body": "I am not sure why we need extra property `enableDynamicAllocationTasks`, if user added a non-null `dynamicAllocationTasksProperties` that alone should mean that user wanted to enable autoscaling.", "bodyText": "I am not sure why we need extra property enableDynamicAllocationTasks, if user added a non-null dynamicAllocationTasksProperties that alone should mean that user wanted to enable autoscaling.", "bodyHTML": "<p dir=\"auto\">I am not sure why we need extra property <code>enableDynamicAllocationTasks</code>, if user added a non-null <code>dynamicAllocationTasksProperties</code> that alone should mean that user wanted to enable autoscaling.</p>", "author": "himanshug", "createdAt": "2021-02-02T00:59:31Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java", "diffHunk": "@@ -151,6 +156,29 @@ public DruidMonitorSchedulerConfig getMonitorSchedulerConfig()\n   @Override\n   public abstract Supervisor createSupervisor();\n \n+  /**\n+   * need to notice that autoScaler would be null which means autoscale is dissable.\n+   * @param supervisor\n+   * @return autoScaler, disable autoscale will return dummyAutoScaler and enable autoscale wiil return defaultAutoScaler by default.\n+   */\n+  @Override\n+  @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED\", justification = \"using siwtch(String)\")\n+  public SupervisorTaskAutoscaler createAutoscaler(Supervisor supervisor)\n+  {\n+    String dataSource = getId();\n+    SupervisorTaskAutoscaler autoScaler = new DummyAutoScaler(supervisor, dataSource);\n+    Map<String, Object> dynamicAllocationTasksProperties = ingestionSchema.getIOConfig().getDynamicAllocationTasksProperties();\n+    if (dynamicAllocationTasksProperties != null && !dynamicAllocationTasksProperties.isEmpty() && Boolean.parseBoolean(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"enableDynamicAllocationTasks\", false)))) {", "originalCommit": "f09d3d5d4f8374f29288994c955945cb1e33199e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDAwMjIzNA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r570002234", "bodyText": "The reason for designing this condition is that users can disable/enable autoscaler for a while easily using this config rather than delete all the autoscaler-related configs.\nFor examples, advertising business in Super Bowl. Traffic is much higher during the break time and lower durning Gaming(Large traffic fluctuations in the short term). If users don't set scale-related configs properly, it will trigger scale action too frequently and creates lots of small segments.\nTraffic like this we usually set a larger number of tasks temporarily and set it false to disable autoscaler for a while.\nAlso when scale algorithms become more advanced, it is better to remove this config and let autoscaler to do everything. But for now maybe it would be better if we keep this parameter :)", "author": "zhangyue19921010", "createdAt": "2021-02-04T07:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0OTE2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\nindex d26caddf52..d9e2afbca0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n", "chunk": "@@ -167,13 +167,20 @@ public abstract class SeekableStreamSupervisorSpec implements SupervisorSpec\n   {\n     String dataSource = getId();\n     SupervisorTaskAutoscaler autoScaler = new DummyAutoScaler(supervisor, dataSource);\n-    Map<String, Object> dynamicAllocationTasksProperties = ingestionSchema.getIOConfig().getDynamicAllocationTasksProperties();\n-    if (dynamicAllocationTasksProperties != null && !dynamicAllocationTasksProperties.isEmpty() && Boolean.parseBoolean(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"enableDynamicAllocationTasks\", false)))) {\n-      String autoScalerStrategy = String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"autoScalerStrategy\", \"default\"));\n+    Map<String, Object> autoscalerConfig = ingestionSchema.getIOConfig().getautoscalerConfig();\n+\n+    // kinesis'autoscalerConfig is always null for now, So that kinesis will hold a DummyAutoScaler.\n+    // only SeekableStreamSupervisor is supported here.\n+    if (autoscalerConfig != null\n+            && !autoscalerConfig.isEmpty()\n+            && Boolean.parseBoolean(String.valueOf(autoscalerConfig.getOrDefault(\"enableTaskAutoscaler\", true)))\n+            && supervisor instanceof SeekableStreamSupervisor) {\n+\n+      String autoScalerStrategy = String.valueOf(autoscalerConfig.getOrDefault(\"autoScalerStrategy\", \"default\"));\n \n       // will thorw 'Return value of String.hashCode() ignored : RV_RETURN_VALUE_IGNORED' just Suppress it.\n       switch (StringUtils.toLowerCase(autoScalerStrategy)) {\n-        default: autoScaler = new DefaultAutoScaler(supervisor, dataSource, dynamicAllocationTasksProperties, this);\n+        default: autoScaler = new DefaultAutoScaler(supervisor, dataSource, autoscalerConfig, this);\n       }\n     }\n     return autoScaler;\n", "next_change": {"commit": "25fec0ff18d0acb79734dd93bedccff3ab43308a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\nindex d9e2afbca0..3ce1155eec 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n", "chunk": "@@ -167,20 +168,26 @@ public abstract class SeekableStreamSupervisorSpec implements SupervisorSpec\n   {\n     String dataSource = getId();\n     SupervisorTaskAutoscaler autoScaler = new DummyAutoScaler(supervisor, dataSource);\n-    Map<String, Object> autoscalerConfig = ingestionSchema.getIOConfig().getautoscalerConfig();\n+    Map<String, Object> autoscalerConfigMap = ingestionSchema.getIOConfig().getAutoscalerConfig();\n+\n+    // if autoscalerConfigMap is null then autoScalerConfig will be null\n+    // if autoscalerConfigMap is empty then autoScalerConfig will be default values.\n+    AutoScalerConfig autoScalerConfig = mapper.convertValue(autoscalerConfigMap, AutoScalerConfig.class);\n \n     // kinesis'autoscalerConfig is always null for now, So that kinesis will hold a DummyAutoScaler.\n     // only SeekableStreamSupervisor is supported here.\n-    if (autoscalerConfig != null\n-            && !autoscalerConfig.isEmpty()\n-            && Boolean.parseBoolean(String.valueOf(autoscalerConfig.getOrDefault(\"enableTaskAutoscaler\", true)))\n+    if (autoscalerConfigMap != null\n+            && !autoscalerConfigMap.isEmpty()\n+            && autoScalerConfig.getEnableTaskAutoscaler()\n             && supervisor instanceof SeekableStreamSupervisor) {\n \n-      String autoScalerStrategy = String.valueOf(autoscalerConfig.getOrDefault(\"autoScalerStrategy\", \"default\"));\n+      String autoScalerStrategy = autoScalerConfig.getAutoScalerStrategy();\n \n       // will thorw 'Return value of String.hashCode() ignored : RV_RETURN_VALUE_IGNORED' just Suppress it.\n       switch (StringUtils.toLowerCase(autoScalerStrategy)) {\n-        default: autoScaler = new DefaultAutoScaler(supervisor, dataSource, autoscalerConfig, this);\n+        default: {\n+          autoScaler = new DefaultAutoScaler(supervisor, dataSource, autoScalerConfig, this);\n+        }\n       }\n     }\n     return autoScaler;\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\nindex 3ce1155eec..638769891c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n", "chunk": "@@ -163,34 +160,13 @@ public abstract class SeekableStreamSupervisorSpec implements SupervisorSpec\n    * @return autoScaler, disable autoscale will return dummyAutoScaler and enable autoscale wiil return defaultAutoScaler by default.\n    */\n   @Override\n-  @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED\", justification = \"using siwtch(String)\")\n-  public SupervisorTaskAutoscaler createAutoscaler(Supervisor supervisor)\n-  {\n-    String dataSource = getId();\n-    SupervisorTaskAutoscaler autoScaler = new DummyAutoScaler(supervisor, dataSource);\n-    Map<String, Object> autoscalerConfigMap = ingestionSchema.getIOConfig().getAutoscalerConfig();\n-\n-    // if autoscalerConfigMap is null then autoScalerConfig will be null\n-    // if autoscalerConfigMap is empty then autoScalerConfig will be default values.\n-    AutoScalerConfig autoScalerConfig = mapper.convertValue(autoscalerConfigMap, AutoScalerConfig.class);\n-\n-    // kinesis'autoscalerConfig is always null for now, So that kinesis will hold a DummyAutoScaler.\n-    // only SeekableStreamSupervisor is supported here.\n-    if (autoscalerConfigMap != null\n-            && !autoscalerConfigMap.isEmpty()\n-            && autoScalerConfig.getEnableTaskAutoscaler()\n-            && supervisor instanceof SeekableStreamSupervisor) {\n-\n-      String autoScalerStrategy = autoScalerConfig.getAutoScalerStrategy();\n-\n-      // will thorw 'Return value of String.hashCode() ignored : RV_RETURN_VALUE_IGNORED' just Suppress it.\n-      switch (StringUtils.toLowerCase(autoScalerStrategy)) {\n-        default: {\n-          autoScaler = new DefaultAutoScaler(supervisor, dataSource, autoScalerConfig, this);\n-        }\n-      }\n+  public SupervisorTaskAutoScaler createAutoscaler(Supervisor supervisor)\n+  {\n+    AutoScalerConfig autoScalerConfig = ingestionSchema.getIOConfig().getAutoscalerConfig();\n+    if (autoScalerConfig != null && autoScalerConfig.getEnableTaskAutoScaler() && supervisor instanceof SeekableStreamSupervisor) {\n+      return autoScalerConfig.createAutoScaler(supervisor, this);\n     }\n-    return autoScaler;\n+    return new NoopTaskAutoScaler();\n   }\n \n   @Override\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0OTUyOQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r568249529", "body": "can we create the autoscaler instance using jackson ... i.e. something like `jsonMapper.readValueFrom...()`", "bodyText": "can we create the autoscaler instance using jackson ... i.e. something like jsonMapper.readValueFrom...()", "bodyHTML": "<p dir=\"auto\">can we create the autoscaler instance using jackson ... i.e. something like <code>jsonMapper.readValueFrom...()</code></p>", "author": "himanshug", "createdAt": "2021-02-02T01:00:29Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java", "diffHunk": "@@ -151,6 +156,29 @@ public DruidMonitorSchedulerConfig getMonitorSchedulerConfig()\n   @Override\n   public abstract Supervisor createSupervisor();\n \n+  /**\n+   * need to notice that autoScaler would be null which means autoscale is dissable.\n+   * @param supervisor\n+   * @return autoScaler, disable autoscale will return dummyAutoScaler and enable autoscale wiil return defaultAutoScaler by default.\n+   */\n+  @Override\n+  @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED\", justification = \"using siwtch(String)\")\n+  public SupervisorTaskAutoscaler createAutoscaler(Supervisor supervisor)\n+  {\n+    String dataSource = getId();\n+    SupervisorTaskAutoscaler autoScaler = new DummyAutoScaler(supervisor, dataSource);\n+    Map<String, Object> dynamicAllocationTasksProperties = ingestionSchema.getIOConfig().getDynamicAllocationTasksProperties();\n+    if (dynamicAllocationTasksProperties != null && !dynamicAllocationTasksProperties.isEmpty() && Boolean.parseBoolean(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"enableDynamicAllocationTasks\", false)))) {\n+      String autoScalerStrategy = String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"autoScalerStrategy\", \"default\"));\n+\n+      // will thorw 'Return value of String.hashCode() ignored : RV_RETURN_VALUE_IGNORED' just Suppress it.\n+      switch (StringUtils.toLowerCase(autoScalerStrategy)) {\n+        default: autoScaler = new DefaultAutoScaler(supervisor, dataSource, dynamicAllocationTasksProperties, this);\n+      }", "originalCommit": "f09d3d5d4f8374f29288994c955945cb1e33199e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDAwNDM0Ng==", "url": "https://github.com/apache/druid/pull/10524#discussion_r570004346", "bodyText": "Nice catch!  I modified the way of obtaining configurations using Jackson like I mentioned above.\nIn this way, Users can not only defined their own scale algorithms, but also can build corresponding configuration.\nAlso it is easier to ensure consistency of default values. We don't need to do map.get/parse work anymore.\nAssupervisor instance is newed in Druid everywhere. Is it necessary to create the autoscaler using Jackson which hold supervisor instance ? \ud83e\udd15", "author": "zhangyue19921010", "createdAt": "2021-02-04T07:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0OTUyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "87a694ad10daa29b8934599a05e35bdbfea14059", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\nindex d26caddf52..d9e2afbca0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n", "chunk": "@@ -167,13 +167,20 @@ public abstract class SeekableStreamSupervisorSpec implements SupervisorSpec\n   {\n     String dataSource = getId();\n     SupervisorTaskAutoscaler autoScaler = new DummyAutoScaler(supervisor, dataSource);\n-    Map<String, Object> dynamicAllocationTasksProperties = ingestionSchema.getIOConfig().getDynamicAllocationTasksProperties();\n-    if (dynamicAllocationTasksProperties != null && !dynamicAllocationTasksProperties.isEmpty() && Boolean.parseBoolean(String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"enableDynamicAllocationTasks\", false)))) {\n-      String autoScalerStrategy = String.valueOf(dynamicAllocationTasksProperties.getOrDefault(\"autoScalerStrategy\", \"default\"));\n+    Map<String, Object> autoscalerConfig = ingestionSchema.getIOConfig().getautoscalerConfig();\n+\n+    // kinesis'autoscalerConfig is always null for now, So that kinesis will hold a DummyAutoScaler.\n+    // only SeekableStreamSupervisor is supported here.\n+    if (autoscalerConfig != null\n+            && !autoscalerConfig.isEmpty()\n+            && Boolean.parseBoolean(String.valueOf(autoscalerConfig.getOrDefault(\"enableTaskAutoscaler\", true)))\n+            && supervisor instanceof SeekableStreamSupervisor) {\n+\n+      String autoScalerStrategy = String.valueOf(autoscalerConfig.getOrDefault(\"autoScalerStrategy\", \"default\"));\n \n       // will thorw 'Return value of String.hashCode() ignored : RV_RETURN_VALUE_IGNORED' just Suppress it.\n       switch (StringUtils.toLowerCase(autoScalerStrategy)) {\n-        default: autoScaler = new DefaultAutoScaler(supervisor, dataSource, dynamicAllocationTasksProperties, this);\n+        default: autoScaler = new DefaultAutoScaler(supervisor, dataSource, autoscalerConfig, this);\n       }\n     }\n     return autoScaler;\n", "next_change": {"commit": "25fec0ff18d0acb79734dd93bedccff3ab43308a", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\nindex d9e2afbca0..3ce1155eec 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n", "chunk": "@@ -167,20 +168,26 @@ public abstract class SeekableStreamSupervisorSpec implements SupervisorSpec\n   {\n     String dataSource = getId();\n     SupervisorTaskAutoscaler autoScaler = new DummyAutoScaler(supervisor, dataSource);\n-    Map<String, Object> autoscalerConfig = ingestionSchema.getIOConfig().getautoscalerConfig();\n+    Map<String, Object> autoscalerConfigMap = ingestionSchema.getIOConfig().getAutoscalerConfig();\n+\n+    // if autoscalerConfigMap is null then autoScalerConfig will be null\n+    // if autoscalerConfigMap is empty then autoScalerConfig will be default values.\n+    AutoScalerConfig autoScalerConfig = mapper.convertValue(autoscalerConfigMap, AutoScalerConfig.class);\n \n     // kinesis'autoscalerConfig is always null for now, So that kinesis will hold a DummyAutoScaler.\n     // only SeekableStreamSupervisor is supported here.\n-    if (autoscalerConfig != null\n-            && !autoscalerConfig.isEmpty()\n-            && Boolean.parseBoolean(String.valueOf(autoscalerConfig.getOrDefault(\"enableTaskAutoscaler\", true)))\n+    if (autoscalerConfigMap != null\n+            && !autoscalerConfigMap.isEmpty()\n+            && autoScalerConfig.getEnableTaskAutoscaler()\n             && supervisor instanceof SeekableStreamSupervisor) {\n \n-      String autoScalerStrategy = String.valueOf(autoscalerConfig.getOrDefault(\"autoScalerStrategy\", \"default\"));\n+      String autoScalerStrategy = autoScalerConfig.getAutoScalerStrategy();\n \n       // will thorw 'Return value of String.hashCode() ignored : RV_RETURN_VALUE_IGNORED' just Suppress it.\n       switch (StringUtils.toLowerCase(autoScalerStrategy)) {\n-        default: autoScaler = new DefaultAutoScaler(supervisor, dataSource, autoscalerConfig, this);\n+        default: {\n+          autoScaler = new DefaultAutoScaler(supervisor, dataSource, autoScalerConfig, this);\n+        }\n       }\n     }\n     return autoScaler;\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\nindex 3ce1155eec..638769891c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n", "chunk": "@@ -163,34 +160,13 @@ public abstract class SeekableStreamSupervisorSpec implements SupervisorSpec\n    * @return autoScaler, disable autoscale will return dummyAutoScaler and enable autoscale wiil return defaultAutoScaler by default.\n    */\n   @Override\n-  @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED\", justification = \"using siwtch(String)\")\n-  public SupervisorTaskAutoscaler createAutoscaler(Supervisor supervisor)\n-  {\n-    String dataSource = getId();\n-    SupervisorTaskAutoscaler autoScaler = new DummyAutoScaler(supervisor, dataSource);\n-    Map<String, Object> autoscalerConfigMap = ingestionSchema.getIOConfig().getAutoscalerConfig();\n-\n-    // if autoscalerConfigMap is null then autoScalerConfig will be null\n-    // if autoscalerConfigMap is empty then autoScalerConfig will be default values.\n-    AutoScalerConfig autoScalerConfig = mapper.convertValue(autoscalerConfigMap, AutoScalerConfig.class);\n-\n-    // kinesis'autoscalerConfig is always null for now, So that kinesis will hold a DummyAutoScaler.\n-    // only SeekableStreamSupervisor is supported here.\n-    if (autoscalerConfigMap != null\n-            && !autoscalerConfigMap.isEmpty()\n-            && autoScalerConfig.getEnableTaskAutoscaler()\n-            && supervisor instanceof SeekableStreamSupervisor) {\n-\n-      String autoScalerStrategy = autoScalerConfig.getAutoScalerStrategy();\n-\n-      // will thorw 'Return value of String.hashCode() ignored : RV_RETURN_VALUE_IGNORED' just Suppress it.\n-      switch (StringUtils.toLowerCase(autoScalerStrategy)) {\n-        default: {\n-          autoScaler = new DefaultAutoScaler(supervisor, dataSource, autoScalerConfig, this);\n-        }\n-      }\n+  public SupervisorTaskAutoScaler createAutoscaler(Supervisor supervisor)\n+  {\n+    AutoScalerConfig autoScalerConfig = ingestionSchema.getIOConfig().getAutoscalerConfig();\n+    if (autoScalerConfig != null && autoScalerConfig.getEnableTaskAutoScaler() && supervisor instanceof SeekableStreamSupervisor) {\n+      return autoScalerConfig.createAutoScaler(supervisor, this);\n     }\n-    return autoScaler;\n+    return new NoopTaskAutoScaler();\n   }\n \n   @Override\n", "next_change": null}]}}]}}]}}, {"oid": "e66d5d20428d39e0d71ae68a41c668d7e2d508a2", "url": "https://github.com/apache/druid/commit/e66d5d20428d39e0d71ae68a41c668d7e2d508a2", "message": "Merge branch 'master' into kafka-dynamic-scale-ingest-tasks", "committedDate": "2021-02-02T05:05:10Z", "type": "commit"}, {"oid": "87a694ad10daa29b8934599a05e35bdbfea14059", "url": "https://github.com/apache/druid/commit/87a694ad10daa29b8934599a05e35bdbfea14059", "message": "review change", "committedDate": "2021-02-02T07:28:01Z", "type": "commit"}, {"oid": "71bdfbbad7c8ff87de78d388dd65c2a25903ca3e", "url": "https://github.com/apache/druid/commit/71bdfbbad7c8ff87de78d388dd65c2a25903ca3e", "message": "code review", "committedDate": "2021-02-02T07:49:58Z", "type": "commit"}, {"oid": "96025755975a2de106d7a9aa1930d48b17bc25b6", "url": "https://github.com/apache/druid/commit/96025755975a2de106d7a9aa1930d48b17bc25b6", "message": "remove unused imports", "committedDate": "2021-02-02T09:10:02Z", "type": "commit"}, {"oid": "6bbbf297d1ab84b675d07108f554bd765206ff08", "url": "https://github.com/apache/druid/commit/6bbbf297d1ab84b675d07108f554bd765206ff08", "message": "fix NLP", "committedDate": "2021-02-02T10:23:52Z", "type": "commit"}, {"oid": "0ae6a34821939049e6cae6312c6f8b796eb4af11", "url": "https://github.com/apache/druid/commit/0ae6a34821939049e6cae6312c6f8b796eb4af11", "message": "fix docs and UTs", "committedDate": "2021-02-03T02:20:38Z", "type": "commit"}, {"oid": "16e4f47421c442851a84c50326d39b3283234094", "url": "https://github.com/apache/druid/commit/16e4f47421c442851a84c50326d39b3283234094", "message": "revert misc.xml", "committedDate": "2021-02-03T02:24:43Z", "type": "commit"}, {"oid": "25fec0ff18d0acb79734dd93bedccff3ab43308a", "url": "https://github.com/apache/druid/commit/25fec0ff18d0acb79734dd93bedccff3ab43308a", "message": "use jackson to build autoScaleConfig with default values", "committedDate": "2021-02-03T11:06:24Z", "type": "commit"}, {"oid": "f0c8d7877590876ac9e1e2277eea7b0cb810ec06", "url": "https://github.com/apache/druid/commit/f0c8d7877590876ac9e1e2277eea7b0cb810ec06", "message": "add uts", "committedDate": "2021-02-03T14:27:30Z", "type": "commit"}, {"oid": "0733590862fa43068e19b15d85dc5507732f7620", "url": "https://github.com/apache/druid/commit/0733590862fa43068e19b15d85dc5507732f7620", "message": "use jackson to init AutoScalerConfig in IOConfig instead of Map<>", "committedDate": "2021-02-03T17:22:19Z", "type": "commit"}, {"oid": "972690294bf199ec0b93d01d5f44e3d9c008720c", "url": "https://github.com/apache/druid/commit/972690294bf199ec0b93d01d5f44e3d9c008720c", "message": " autoscalerConfig interface and provide a defaultAutoScalerConfig", "committedDate": "2021-02-04T04:21:32Z", "type": "commit"}, {"oid": "32fffa955c9ab06ed0a57378e95371e517794f4f", "url": "https://github.com/apache/druid/commit/32fffa955c9ab06ed0a57378e95371e517794f4f", "message": "modify uts", "committedDate": "2021-02-04T05:22:00Z", "type": "commit"}, {"oid": "34c2785dd4973dc1fd34b6739464e228654f4d9f", "url": "https://github.com/apache/druid/commit/34c2785dd4973dc1fd34b6739464e228654f4d9f", "message": "modify docs", "committedDate": "2021-02-04T06:18:57Z", "type": "commit"}, {"oid": "eb95830fe960ab0d28d22103b1d115a874fa04c7", "url": "https://github.com/apache/druid/commit/eb95830fe960ab0d28d22103b1d115a874fa04c7", "message": "fix checkstyle", "committedDate": "2021-02-04T10:56:42Z", "type": "commit"}, {"oid": "7de0f10e7b7a6f802d66983fed928dcf19233049", "url": "https://github.com/apache/druid/commit/7de0f10e7b7a6f802d66983fed928dcf19233049", "message": "revert misc.xml", "committedDate": "2021-02-04T10:57:48Z", "type": "commit"}, {"oid": "ce5945b18155d058f6899ea68db26147c3e03015", "url": "https://github.com/apache/druid/commit/ce5945b18155d058f6899ea68db26147c3e03015", "message": "modify uts", "committedDate": "2021-02-05T02:56:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5MzI3OQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r570893279", "body": "```suggestion\r\n   * @return Boolean flag, do scale action successfully or not. If true, it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n          \n          \n            \n               * @return Boolean flag, do scale action successfully or not. If true, it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@return</span> <span class=\"pl-smi\">Boolean</span> flag, <span class=\"pl-k\">do</span> scale action successfully or not. <span class=\"pl-smi\">If</span> <span class=\"pl-c1\">true</span><span class=\"x x-first x-last\"> </span>, it will take at least <span class=\"pl-s\"><span class=\"pl-pds\">'</span>minTriggerDynamicFrequency<span class=\"pl-pds\">'</span></span> before next <span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"x x-first x-last\">dynamicAllocatie</span><span class=\"pl-pds\">'</span></span><span class=\"pl-c1\">.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@return</span> <span class=\"pl-smi\">Boolean</span> flag, <span class=\"pl-k\">do</span> scale action successfully or not. <span class=\"pl-smi\">If</span> <span class=\"pl-c1\">true</span>, it will take at least <span class=\"pl-s\"><span class=\"pl-pds\">'</span>minTriggerDynamicFrequency<span class=\"pl-pds\">'</span></span> before next <span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"x x-first x-last\">dynamicAllocate</span><span class=\"pl-pds\">'</span></span><span class=\"pl-c1\">.</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pjain1", "createdAt": "2021-02-05T11:10:17Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +324,114 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+            return;\n+          }\n+        }\n+        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n+          return;\n+        }\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n+        if (allocationSuccess) {\n+          dynamicTriggerLastRunTime = nowTime;\n+        }\n+      }\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error, when parse DynamicAllocationTasksNotice\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method determines how to do scale actions based on collected lag points.\n+   * If scale action is triggered :\n+   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n+   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.", "originalCommit": "ce5945b18155d058f6899ea68db26147c3e03015", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTA0Nzg1Mg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r571047852", "bodyText": "Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-05T15:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5MzI3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex aa1636b3ce..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -378,36 +378,36 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desireActiveTaskCount == -1) {\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n       return true;\n     }\n   }\n \n-  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n   {\n-    ioConfig.setTaskCount(desireActiveTaskCount);\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n     try {\n       Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n       if (supervisorManager.isPresent()) {\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -414,7 +428,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n+        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -428,15 +426,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n-      log.warn(\"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n     }\n   }\n \n-  private void clearAllocationInfos()\n+  private void clearAllocationInfo()\n   {\n     activelyReadingTaskGroups.clear();\n     partitionGroups.clear();\n", "next_change": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5MzY2Mg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r570893662", "body": "```suggestion\r\n          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n          \n          \n            \n                      log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">          log<span class=\"pl-k\">.</span>info(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], <span class=\"x x-first x-last\">CLAM</span> DOWN NOW !<span class=\"pl-pds\">\"</span></span>, nowTime <span class=\"pl-k\">-</span> dynamicTriggerLastRunTime, autoScalerConfig<span class=\"pl-k\">.</span>getMinTriggerDynamicFrequencyMillis(), dataSource);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          log<span class=\"pl-k\">.</span>info(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], <span class=\"x x-first x-last\">CALM</span> DOWN NOW !<span class=\"pl-pds\">\"</span></span>, nowTime <span class=\"pl-k\">-</span> dynamicTriggerLastRunTime, autoScalerConfig<span class=\"pl-k\">.</span>getMinTriggerDynamicFrequencyMillis(), dataSource);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pjain1", "createdAt": "2021-02-05T11:11:03Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +324,114 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+            return;\n+          }\n+        }\n+        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);", "originalCommit": "ce5945b18155d058f6899ea68db26147c3e03015", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTA0Nzk5MQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r571047991", "bodyText": "Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-05T15:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5MzY2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex aa1636b3ce..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -355,7 +355,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n           }\n         }\n         if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n-          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n           return;\n         }\n \n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -340,48 +340,59 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     @Override\n     public void handle()\n     {\n-      try {\n-        long nowTime = System.currentTimeMillis();\n-        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n-        if (spec.isSuspended()) {\n-          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n-          return;\n-        }\n-        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n-        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n-          if (!list.isEmpty()) {\n-            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+      if (autoScalerConfig == null) {\n+        log.warn(\"autoScalerConfig is null but dynamic allocation notice is submitted, how can it be ?\");\n+      } else {\n+        try {\n+          long nowTime = System.currentTimeMillis();\n+          if (spec.isSuspended()) {\n+            log.info(\"Skipping DynamicAllocationTasksNotice execution because [%s] supervisor is suspended\",\n+                    dataSource\n+            );\n             return;\n           }\n+          log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s]\", pendingCompletionTaskGroups,\n+                  dataSource\n+          );\n+          for (CopyOnWriteArrayList<TaskGroup> list : pendingCompletionTaskGroups.values()) {\n+            if (!list.isEmpty()) {\n+              log.info(\n+                      \"Skipping DynamicAllocationTasksNotice execution for datasource [%s] because following tasks are pending [%s]\",\n+                      dataSource, pendingCompletionTaskGroups\n+              );\n+              return;\n+            }\n+          }\n+          if (nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+            log.info(\n+                    \"DynamicAllocationTasksNotice submitted again in [%d] millis, minTriggerDynamicFrequency is [%s] for dataSource [%s], skipping it!\",\n+                    nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource\n+            );\n+            return;\n+          }\n+          Integer desriedTaskCount = scaleAction.call();\n+          boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+          if (allocationSuccess) {\n+            dynamicTriggerLastRunTime = nowTime;\n+          }\n         }\n-        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n-          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n-          return;\n-        }\n-\n-        Integer desriedTaskCount = scaleAction.call();\n-        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n-\n-        if (allocationSuccess) {\n-          dynamicTriggerLastRunTime = nowTime;\n+        catch (Exception ex) {\n+          log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n         }\n       }\n-      catch (Exception ex) {\n-        log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n-      }\n     }\n   }\n \n   /**\n    * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n-   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n-   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n-   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuild in the next 'RunNotice'.\n+   *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\n+   * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\n    * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n-   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n+   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n+   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod' millis.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -387,17 +386,17 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n    *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\n-   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuild in the next 'RunNotice'.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled in the next 'RunNotice'.\n    *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\n    * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\n-   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n-   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n-   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod' millis.\n+   * @param desiredActiveTaskCount desired taskCount computed from AutoScaler\n+   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerScaleActionFrequencyMillis' before next 'changeTaskCount'.\n+   *         If false, it will do 'changeTaskCount' again after 'scaleActionPeriodMillis' millis.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n", "next_change": {"commit": "22339ddc83976758809570dd1c92d7506c26fcfa", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..468363dcbe 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -396,13 +396,13 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean changeTaskCount(int desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n+    if (desiredActiveTaskCount < 0 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n       log.info(\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5NDExMQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r570894111", "body": "```suggestion\r\n        log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    log.warn(ex, \"Error, when parse DynamicAllocationTasksNotice\");\n          \n          \n            \n                    log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        log<span class=\"pl-k\">.</span>warn(ex, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Error<span class=\"x x-first x-last\">, when parse</span> DynamicAllocationTasksNotice<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        log<span class=\"pl-k\">.</span>warn(ex, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Error<span class=\"x x-first x-last\"> parsing</span> DynamicAllocationTasksNotice<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pjain1", "createdAt": "2021-02-05T11:12:00Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +324,114 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+            return;\n+          }\n+        }\n+        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n+          return;\n+        }\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n+        if (allocationSuccess) {\n+          dynamicTriggerLastRunTime = nowTime;\n+        }\n+      }\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error, when parse DynamicAllocationTasksNotice\");", "originalCommit": "ce5945b18155d058f6899ea68db26147c3e03015", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTA0ODA2Mw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r571048063", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2021-02-05T15:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5NDExMQ=="}], "type": "inlineReview", "revised_code": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex aa1636b3ce..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -367,7 +367,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         }\n       }\n       catch (Exception ex) {\n-        log.warn(ex, \"Error, when parse DynamicAllocationTasksNotice\");\n+        log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n       }\n     }\n   }\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -340,48 +340,59 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     @Override\n     public void handle()\n     {\n-      try {\n-        long nowTime = System.currentTimeMillis();\n-        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n-        if (spec.isSuspended()) {\n-          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n-          return;\n-        }\n-        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n-        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n-          if (!list.isEmpty()) {\n-            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+      if (autoScalerConfig == null) {\n+        log.warn(\"autoScalerConfig is null but dynamic allocation notice is submitted, how can it be ?\");\n+      } else {\n+        try {\n+          long nowTime = System.currentTimeMillis();\n+          if (spec.isSuspended()) {\n+            log.info(\"Skipping DynamicAllocationTasksNotice execution because [%s] supervisor is suspended\",\n+                    dataSource\n+            );\n             return;\n           }\n+          log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s]\", pendingCompletionTaskGroups,\n+                  dataSource\n+          );\n+          for (CopyOnWriteArrayList<TaskGroup> list : pendingCompletionTaskGroups.values()) {\n+            if (!list.isEmpty()) {\n+              log.info(\n+                      \"Skipping DynamicAllocationTasksNotice execution for datasource [%s] because following tasks are pending [%s]\",\n+                      dataSource, pendingCompletionTaskGroups\n+              );\n+              return;\n+            }\n+          }\n+          if (nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+            log.info(\n+                    \"DynamicAllocationTasksNotice submitted again in [%d] millis, minTriggerDynamicFrequency is [%s] for dataSource [%s], skipping it!\",\n+                    nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource\n+            );\n+            return;\n+          }\n+          Integer desriedTaskCount = scaleAction.call();\n+          boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+          if (allocationSuccess) {\n+            dynamicTriggerLastRunTime = nowTime;\n+          }\n         }\n-        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n-          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n-          return;\n-        }\n-\n-        Integer desriedTaskCount = scaleAction.call();\n-        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n-\n-        if (allocationSuccess) {\n-          dynamicTriggerLastRunTime = nowTime;\n+        catch (Exception ex) {\n+          log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n         }\n       }\n-      catch (Exception ex) {\n-        log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n-      }\n     }\n   }\n \n   /**\n    * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n-   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n-   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n-   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuild in the next 'RunNotice'.\n+   *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\n+   * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\n    * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n-   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n+   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n+   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod' millis.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -387,17 +386,17 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n    *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\n-   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuild in the next 'RunNotice'.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled in the next 'RunNotice'.\n    *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\n    * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\n-   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n-   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n-   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod' millis.\n+   * @param desiredActiveTaskCount desired taskCount computed from AutoScaler\n+   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerScaleActionFrequencyMillis' before next 'changeTaskCount'.\n+   *         If false, it will do 'changeTaskCount' again after 'scaleActionPeriodMillis' millis.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n", "next_change": {"commit": "22339ddc83976758809570dd1c92d7506c26fcfa", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..468363dcbe 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -396,13 +396,13 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean changeTaskCount(int desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n+    if (desiredActiveTaskCount < 0 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n       log.info(\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5NDg1OQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r570894859", "body": "```suggestion\r\n   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n          \n          \n            \n               * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-smi\">After</span> changed taskCount in <span class=\"pl-smi\">SeekableStreamSupervisorIOConfig</span>, next <span class=\"pl-smi\">RunNotice</span> will <span class=\"x x-first x-last\">ceate</span> scaled number of ingest tasks without resubmitting supervisors.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-smi\">After</span> changed taskCount in <span class=\"pl-smi\">SeekableStreamSupervisorIOConfig</span>, next <span class=\"pl-smi\">RunNotice</span> will <span class=\"x x-first x-last\">create</span> scaled number of ingest tasks without resubmitting supervisors.</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pjain1", "createdAt": "2021-02-05T11:13:35Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +324,114 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+            return;\n+          }\n+        }\n+        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n+          return;\n+        }\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n+        if (allocationSuccess) {\n+          dynamicTriggerLastRunTime = nowTime;\n+        }\n+      }\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error, when parse DynamicAllocationTasksNotice\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method determines how to do scale actions based on collected lag points.\n+   * If scale action is triggered :\n+   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n+   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.", "originalCommit": "ce5945b18155d058f6899ea68db26147c3e03015", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTA0ODE2MA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r571048160", "bodyText": "Done.", "author": "zhangyue19921010", "createdAt": "2021-02-05T15:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5NDg1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex aa1636b3ce..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -378,36 +378,36 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desireActiveTaskCount == -1) {\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n       return true;\n     }\n   }\n \n-  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n   {\n-    ioConfig.setTaskCount(desireActiveTaskCount);\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n     try {\n       Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n       if (supervisorManager.isPresent()) {\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -414,7 +428,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n+        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -428,15 +426,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n-      log.warn(\"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n     }\n   }\n \n-  private void clearAllocationInfos()\n+  private void clearAllocationInfo()\n   {\n     activelyReadingTaskGroups.clear();\n     partitionGroups.clear();\n", "next_change": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5NjAyNQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r570896025", "body": "We are not checking if `desireActiveTaskCount` is already equal to `currentActiveTaskCount`. If they are equal there is nothing to be done.", "bodyText": "We are not checking if desireActiveTaskCount is already equal to currentActiveTaskCount. If they are equal there is nothing to be done.", "bodyHTML": "<p dir=\"auto\">We are not checking if <code>desireActiveTaskCount</code> is already equal to <code>currentActiveTaskCount</code>. If they are equal there is nothing to be done.</p>", "author": "pjain1", "createdAt": "2021-02-05T11:15:49Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +324,114 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+            return;\n+          }\n+        }\n+        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n+          return;\n+        }\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n+        if (allocationSuccess) {\n+          dynamicTriggerLastRunTime = nowTime;\n+        }\n+      }\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error, when parse DynamicAllocationTasksNotice\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method determines how to do scale actions based on collected lag points.\n+   * If scale action is triggered :\n+   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n+   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n+   * @throws InterruptedException\n+   * @throws ExecutionException\n+   * @throws TimeoutException\n+   */\n+  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  {\n+    int currentActiveTaskCount;\n+    Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n+    currentActiveTaskCount = activeTaskGroups.size();\n+\n+    if (desireActiveTaskCount == -1) {\n+      return false;\n+    } else {", "originalCommit": "ce5945b18155d058f6899ea68db26147c3e03015", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTA0ODgxMA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r571048810", "bodyText": "Nice catch! It is necessary to do this check. Thanks.", "author": "zhangyue19921010", "createdAt": "2021-02-05T15:28:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5NjAyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTA4NjkwNA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r571086904", "bodyText": "Actually desireActiveTaskCount usually can't be equal to currentActiveTaskCount here. Take scale out as an example :\nHere is the logic of computing desireActiveTaskCount in autoscaler\n      if (currentActiveTaskCount == defaultAutoScalerConfig.getTaskCountMax()) {\n        log.info(\"CurrentActiveTaskCount reach task count Max limit, skip to scale out tasks for dataSource [%s].\", dataSource);\n        return -1;\n      } else {\n        desiredActiveTaskCount = Math.min(taskCount, defaultAutoScalerConfig.getTaskCountMax());\n      }\n\nCondition 1: int taskCount = currentActiveTaskCount + defaultAutoScalerConfig.getScaleOutStep()\nCondition 2: currentActiveTaskCount != defaultAutoScalerConfig.getTaskCountMax() otherwise will return -1.\nCondition 3: desiredActiveTaskCount = Math.min(taskCount, defaultAutoScalerConfig.getTaskCountMax())\nCondition 4: defaultAutoScalerConfig.getScaleOutStep() > 0\n=>  get Condition5 based on Condition 1 and Condition 3: desiredActiveTaskCount = Math.min(currentActiveTaskCount + defaultAutoScalerConfig.getScaleOutStep(), defaultAutoScalerConfig.getTaskCountMax())\nAssume desireActiveTaskCount == currentActiveTaskCount\nCombine with Condition 4, 5 and assumption => we can get desiredActiveTaskCount == defaultAutoScalerConfig.getTaskCountMax()\nThen based on Condition 2 => We can get currentActiveTaskCount != desiredActiveTaskCount\nThis conclusion conflicts with the assumption, so the assumption does not hold.\nSo that desireActiveTaskCount can't be equal to currentActiveTaskCount here\nUNLESS! Users set defaultAutoScalerConfig.getScaleOutStep() = 0 by mistake.\nSo I changed the code as you suggested to avoid this scenario.\nThanks for your suggestion!", "author": "zhangyue19921010", "createdAt": "2021-02-05T16:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5NjAyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex aa1636b3ce..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -378,36 +378,36 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desireActiveTaskCount == -1) {\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n       return true;\n     }\n   }\n \n-  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n   {\n-    ioConfig.setTaskCount(desireActiveTaskCount);\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n     try {\n       Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n       if (supervisorManager.isPresent()) {\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -414,7 +428,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n+        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -428,15 +426,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n-      log.warn(\"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n     }\n   }\n \n-  private void clearAllocationInfos()\n+  private void clearAllocationInfo()\n   {\n     activelyReadingTaskGroups.clear();\n     partitionGroups.clear();\n", "next_change": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDkxMDc0OQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r570910749", "body": "I think we should first update the count in metadata and then clear the allocation info. What if the database update fails then its not good to clear the allocation info.", "bodyText": "I think we should first update the count in metadata and then clear the allocation info. What if the database update fails then its not good to clear the allocation info.", "bodyHTML": "<p dir=\"auto\">I think we should first update the count in metadata and then clear the allocation info. What if the database update fails then its not good to clear the allocation info.</p>", "author": "pjain1", "createdAt": "2021-02-05T11:43:35Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +324,114 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+            return;\n+          }\n+        }\n+        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n+          return;\n+        }\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n+        if (allocationSuccess) {\n+          dynamicTriggerLastRunTime = nowTime;\n+        }\n+      }\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error, when parse DynamicAllocationTasksNotice\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method determines how to do scale actions based on collected lag points.\n+   * If scale action is triggered :\n+   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n+   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n+   * @throws InterruptedException\n+   * @throws ExecutionException\n+   * @throws TimeoutException\n+   */\n+  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  {\n+    int currentActiveTaskCount;\n+    Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n+    currentActiveTaskCount = activeTaskGroups.size();\n+\n+    if (desireActiveTaskCount == -1) {\n+      return false;\n+    } else {\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+      gracefulShutdownInternal();\n+      // clear everything\n+      clearAllocationInfos();", "originalCommit": "ce5945b18155d058f6899ea68db26147c3e03015", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTA0OTA3MA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r571049070", "bodyText": "Make sense. Changed!", "author": "zhangyue19921010", "createdAt": "2021-02-05T15:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDkxMDc0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex aa1636b3ce..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -378,36 +378,36 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desireActiveTaskCount == -1) {\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n       return true;\n     }\n   }\n \n-  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n   {\n-    ioConfig.setTaskCount(desireActiveTaskCount);\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n     try {\n       Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n       if (supervisorManager.isPresent()) {\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -414,7 +428,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n+        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -428,15 +426,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n-      log.warn(\"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n     }\n   }\n \n-  private void clearAllocationInfos()\n+  private void clearAllocationInfo()\n   {\n     activelyReadingTaskGroups.clear();\n     partitionGroups.clear();\n", "next_change": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTAwNTcxMg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r571005712", "body": "`desireActiveTaskCount` -> `desiredActiveTaskCount`", "bodyText": "desireActiveTaskCount -> desiredActiveTaskCount", "bodyHTML": "<p dir=\"auto\"><code>desireActiveTaskCount</code> -&gt; <code>desiredActiveTaskCount</code></p>", "author": "pjain1", "createdAt": "2021-02-05T14:29:46Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +324,114 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+            return;\n+          }\n+        }\n+        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CLAM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n+          return;\n+        }\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n+        if (allocationSuccess) {\n+          dynamicTriggerLastRunTime = nowTime;\n+        }\n+      }\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error, when parse DynamicAllocationTasksNotice\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method determines how to do scale actions based on collected lag points.\n+   * If scale action is triggered :\n+   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n+   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n+   * @throws InterruptedException\n+   * @throws ExecutionException\n+   * @throws TimeoutException\n+   */\n+  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException", "originalCommit": "ce5945b18155d058f6899ea68db26147c3e03015", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTA1MTYzNA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r571051634", "bodyText": "All changed.", "author": "zhangyue19921010", "createdAt": "2021-02-05T15:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTAwNTcxMg=="}], "type": "inlineReview", "revised_code": {"commit": "85660b7614a43de30b1859f0e275213b7e1e2343", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex aa1636b3ce..31a4db5118 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -378,36 +378,36 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n    *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n    *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will ceate scaled number of ingest tasks without resubmitting supervisors.\n-   * @param desireActiveTaskCount desire taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n    *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desireActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desireActiveTaskCount == -1) {\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\"Start to scale action tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desireActiveTaskCount, dataSource);\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n       gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n       // clear everything\n       clearAllocationInfos();\n-      log.info(\"Change taskCount to [%s] for dataSource [%s].\", desireActiveTaskCount, dataSource);\n-      changeTaskCountInIOConfig(desireActiveTaskCount);\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n       return true;\n     }\n   }\n \n-  private void changeTaskCountInIOConfig(int desireActiveTaskCount)\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n   {\n-    ioConfig.setTaskCount(desireActiveTaskCount);\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n     try {\n       Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n       if (supervisorManager.isPresent()) {\n", "next_change": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -414,7 +428,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n+        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -428,15 +426,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n-      log.warn(\"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n     }\n   }\n \n-  private void clearAllocationInfos()\n+  private void clearAllocationInfo()\n   {\n     activelyReadingTaskGroups.clear();\n     partitionGroups.clear();\n", "next_change": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}, {"oid": "85660b7614a43de30b1859f0e275213b7e1e2343", "url": "https://github.com/apache/druid/commit/85660b7614a43de30b1859f0e275213b7e1e2343", "message": "reviewed code change", "committedDate": "2021-02-05T15:23:49Z", "type": "commit"}, {"oid": "feb3e1e88f68aed4f3ce8a3459d14caf85b663d6", "url": "https://github.com/apache/druid/commit/feb3e1e88f68aed4f3ce8a3459d14caf85b663d6", "message": "reviewed code change", "committedDate": "2021-02-05T15:30:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDE5NDMzMQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580194331", "body": "```suggestion\r\n      log.info(\"Running Task autoscaler for datasource [%s]\", dataSource);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  log.info(\"enableTaskAutoscaler for datasource [%s]\", dataSource);\n          \n          \n            \n                  log.info(\"Running Task autoscaler for datasource [%s]\", dataSource);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      log<span class=\"pl-k\">.</span>info(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">enableTaskAutoscaler</span> for datasource [%s]<span class=\"pl-pds\">\"</span></span>, dataSource);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      log<span class=\"pl-k\">.</span>info(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">Running Task autoscaler</span> for datasource [%s]<span class=\"pl-pds\">\"</span></span>, dataSource);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pjain1", "createdAt": "2021-02-22T11:58:34Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -519,20 +635,42 @@ public SeekableStreamSupervisor(\n     this.useExclusiveStartingSequence = useExclusiveStartingSequence;\n     this.dataSource = spec.getDataSchema().getDataSource();\n     this.ioConfig = spec.getIoConfig();\n+    this.autoScalerConfig = ioConfig.getAutoscalerConfig();\n     this.tuningConfig = spec.getTuningConfig();\n     this.taskTuningConfig = this.tuningConfig.convertToTaskTuningConfig();\n     this.supervisorId = supervisorId;\n     this.exec = Execs.singleThreaded(StringUtils.encodeForFormat(supervisorId));\n     this.scheduledExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Scheduler-%d\");\n     this.reportingExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Reporting-%d\");\n+\n     this.stateManager = new SeekableStreamSupervisorStateManager(\n         spec.getSupervisorStateManagerConfig(),\n         spec.isSuspended()\n     );\n \n-    int workerThreads = (this.tuningConfig.getWorkerThreads() != null\n-                         ? this.tuningConfig.getWorkerThreads()\n-                         : Math.min(10, this.ioConfig.getTaskCount()));\n+    int workerThreads;\n+    int chatThreads;\n+    if (autoScalerConfig != null && autoScalerConfig.getEnableTaskAutoscaler()) {\n+      log.info(\"enableTaskAutoscaler for datasource [%s]\", dataSource);", "originalCommit": "feb3e1e88f68aed4f3ce8a3459d14caf85b663d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDc4OTk3OA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580789978", "bodyText": "Thanks && Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-23T06:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDE5NDMzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -651,7 +665,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     int workerThreads;\n     int chatThreads;\n     if (autoScalerConfig != null && autoScalerConfig.getEnableTaskAutoscaler()) {\n-      log.info(\"enableTaskAutoscaler for datasource [%s]\", dataSource);\n+      log.info(\"Running Task autoscaler for datasource [%s]\", dataSource);\n \n       workerThreads = (this.tuningConfig.getWorkerThreads() != null\n               ? this.tuningConfig.getWorkerThreads()\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -664,7 +662,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n \n     int workerThreads;\n     int chatThreads;\n-    if (autoScalerConfig != null && autoScalerConfig.getEnableTaskAutoscaler()) {\n+    if (autoScalerConfig != null && autoScalerConfig.getEnableTaskAutoScaler()) {\n       log.info(\"Running Task autoscaler for datasource [%s]\", dataSource);\n \n       workerThreads = (this.tuningConfig.getWorkerThreads() != null\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDE5NDY3Mw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580194673", "body": "IMO this log is not required as this is the default behaviour ", "bodyText": "IMO this log is not required as this is the default behaviour", "bodyHTML": "<p dir=\"auto\">IMO this log is not required as this is the default behaviour</p>", "author": "pjain1", "createdAt": "2021-02-22T11:59:07Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -519,20 +635,42 @@ public SeekableStreamSupervisor(\n     this.useExclusiveStartingSequence = useExclusiveStartingSequence;\n     this.dataSource = spec.getDataSchema().getDataSource();\n     this.ioConfig = spec.getIoConfig();\n+    this.autoScalerConfig = ioConfig.getAutoscalerConfig();\n     this.tuningConfig = spec.getTuningConfig();\n     this.taskTuningConfig = this.tuningConfig.convertToTaskTuningConfig();\n     this.supervisorId = supervisorId;\n     this.exec = Execs.singleThreaded(StringUtils.encodeForFormat(supervisorId));\n     this.scheduledExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Scheduler-%d\");\n     this.reportingExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Reporting-%d\");\n+\n     this.stateManager = new SeekableStreamSupervisorStateManager(\n         spec.getSupervisorStateManagerConfig(),\n         spec.isSuspended()\n     );\n \n-    int workerThreads = (this.tuningConfig.getWorkerThreads() != null\n-                         ? this.tuningConfig.getWorkerThreads()\n-                         : Math.min(10, this.ioConfig.getTaskCount()));\n+    int workerThreads;\n+    int chatThreads;\n+    if (autoScalerConfig != null && autoScalerConfig.getEnableTaskAutoscaler()) {\n+      log.info(\"enableTaskAutoscaler for datasource [%s]\", dataSource);\n+\n+      workerThreads = (this.tuningConfig.getWorkerThreads() != null\n+              ? this.tuningConfig.getWorkerThreads()\n+              : Math.min(10, autoScalerConfig.getTaskCountMax()));\n+\n+      chatThreads = (this.tuningConfig.getChatThreads() != null\n+              ? this.tuningConfig.getChatThreads()\n+              : Math.min(10, autoScalerConfig.getTaskCountMax() * this.ioConfig.getReplicas()));\n+    } else {\n+      log.info(\"Disable dynamic allocate tasks for [%s]\", dataSource);", "originalCommit": "feb3e1e88f68aed4f3ce8a3459d14caf85b663d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDc4OTk5NA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580789994", "bodyText": "Thanks && Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-23T06:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDE5NDY3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -661,8 +675,6 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n               ? this.tuningConfig.getChatThreads()\n               : Math.min(10, autoScalerConfig.getTaskCountMax() * this.ioConfig.getReplicas()));\n     } else {\n-      log.info(\"Disable dynamic allocate tasks for [%s]\", dataSource);\n-\n       workerThreads = (this.tuningConfig.getWorkerThreads() != null\n               ? this.tuningConfig.getWorkerThreads()\n               : Math.min(10, this.ioConfig.getTaskCount()));\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIwMjExNA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580202114", "body": "```suggestion\r\n      if (autoScalerConfig == null) {\r\n        log.warn(\"autoScalerConfig is null but dynamic allocation notice is submitted, how can it be ?\");\r\n      } else {\r\n        try {\r\n          long nowTime = System.currentTimeMillis();\r\n          if (spec.isSuspended()) {\r\n            log.info(\"Skipping DynamicAllocationTasksNotice execution because [%s] supervisor is suspended\",\r\n                dataSource\r\n            );\r\n            return;\r\n          }\r\n          log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s]\", pendingCompletionTaskGroups,\r\n              dataSource\r\n          );\r\n          for (CopyOnWriteArrayList<TaskGroup> list : pendingCompletionTaskGroups.values()) {\r\n            if (!list.isEmpty()) {\r\n              log.info(\r\n                  \"Skipping DynamicAllocationTasksNotice execution for datasource [%s] because following tasks are pending [%s]\",\r\n                  dataSource, pendingCompletionTaskGroups\r\n              );\r\n              return;\r\n            }\r\n          }\r\n          if (nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\r\n            log.info(\r\n                \"DynamicAllocationTasksNotice submitted again in [%d] millis, minTriggerDynamicFrequency is [%s] for dataSource [%s], skipping it!\",\r\n                nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource\r\n            );\r\n            return;\r\n          }\r\n\r\n          Integer desriedTaskCount = scaleAction.call();\r\n          boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\r\n\r\n          if (allocationSuccess) {\r\n            dynamicTriggerLastRunTime = nowTime;\r\n          }\r\n        } catch (Exception ex) {\r\n          log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\r\n        }\r\n      }\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  try {\n          \n          \n            \n                    long nowTime = System.currentTimeMillis();\n          \n          \n            \n                    // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n          \n          \n            \n                    if (spec.isSuspended()) {\n          \n          \n            \n                      log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n          \n          \n            \n                      return;\n          \n          \n            \n                    }\n          \n          \n            \n                    log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n          \n          \n            \n                    for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n          \n          \n            \n                      if (!list.isEmpty()) {\n          \n          \n            \n                        log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n          \n          \n            \n                        return;\n          \n          \n            \n                      }\n          \n          \n            \n                    }\n          \n          \n            \n                    if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n          \n          \n            \n                      log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n          \n          \n            \n                      return;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    Integer desriedTaskCount = scaleAction.call();\n          \n          \n            \n                    boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n          \n          \n            \n            \n          \n          \n            \n                    if (allocationSuccess) {\n          \n          \n            \n                      dynamicTriggerLastRunTime = nowTime;\n          \n          \n            \n                    }\n          \n          \n            \n                  }\n          \n          \n            \n                  catch (Exception ex) {\n          \n          \n            \n                    log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n                  if (autoScalerConfig == null) {\n          \n          \n            \n                    log.warn(\"autoScalerConfig is null but dynamic allocation notice is submitted, how can it be ?\");\n          \n          \n            \n                  } else {\n          \n          \n            \n                    try {\n          \n          \n            \n                      long nowTime = System.currentTimeMillis();\n          \n          \n            \n                      if (spec.isSuspended()) {\n          \n          \n            \n                        log.info(\"Skipping DynamicAllocationTasksNotice execution because [%s] supervisor is suspended\",\n          \n          \n            \n                            dataSource\n          \n          \n            \n                        );\n          \n          \n            \n                        return;\n          \n          \n            \n                      }\n          \n          \n            \n                      log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s]\", pendingCompletionTaskGroups,\n          \n          \n            \n                          dataSource\n          \n          \n            \n                      );\n          \n          \n            \n                      for (CopyOnWriteArrayList<TaskGroup> list : pendingCompletionTaskGroups.values()) {\n          \n          \n            \n                        if (!list.isEmpty()) {\n          \n          \n            \n                          log.info(\n          \n          \n            \n                              \"Skipping DynamicAllocationTasksNotice execution for datasource [%s] because following tasks are pending [%s]\",\n          \n          \n            \n                              dataSource, pendingCompletionTaskGroups\n          \n          \n            \n                          );\n          \n          \n            \n                          return;\n          \n          \n            \n                        }\n          \n          \n            \n                      }\n          \n          \n            \n                      if (nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n          \n          \n            \n                        log.info(\n          \n          \n            \n                            \"DynamicAllocationTasksNotice submitted again in [%d] millis, minTriggerDynamicFrequency is [%s] for dataSource [%s], skipping it!\",\n          \n          \n            \n                            nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource\n          \n          \n            \n                        );\n          \n          \n            \n                        return;\n          \n          \n            \n                      }\n          \n          \n            \n            \n          \n          \n            \n                      Integer desriedTaskCount = scaleAction.call();\n          \n          \n            \n                      boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n          \n          \n            \n            \n          \n          \n            \n                      if (allocationSuccess) {\n          \n          \n            \n                        dynamicTriggerLastRunTime = nowTime;\n          \n          \n            \n                      }\n          \n          \n            \n                    } catch (Exception ex) {\n          \n          \n            \n                      log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n          \n          \n            \n                    }\n          \n          \n            \n                  }", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"382\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      <span class=\"pl-k\">try</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"383\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">long</span> nowTime <span class=\"pl-k\">=</span> <span class=\"pl-smi\">System</span><span class=\"pl-k\">.</span>currentTimeMillis();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"384\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"385\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">if</span> (spec<span class=\"pl-k\">.</span>isSuspended()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"386\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">          log<span class=\"pl-k\">.</span>info(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>[%s] supervisor is suspended, skip to check dynamic allocate task logic<span class=\"pl-pds\">\"</span></span>, dataSource);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"387\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">          <span class=\"pl-k\">return</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"388\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"389\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        log<span class=\"pl-k\">.</span>debug(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>PendingCompletionTaskGroups is [%s] for dataSource [%s].<span class=\"pl-pds\">\"</span></span>, pendingCompletionTaskGroups, dataSource);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"390\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">for</span> (<span class=\"pl-smi\">CopyOnWriteArrayList</span> list <span class=\"pl-k\">:</span> pendingCompletionTaskGroups<span class=\"pl-k\">.</span>values()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"391\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">          <span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>list<span class=\"pl-k\">.</span>isEmpty()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"392\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            log<span class=\"pl-k\">.</span>info(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].<span class=\"pl-pds\">\"</span></span>, pendingCompletionTaskGroups, dataSource);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"393\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">return</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"394\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">          }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"395\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"396\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">if</span> (autoScalerConfig <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span> <span class=\"pl-k\">&amp;&amp;</span> nowTime <span class=\"pl-k\">-</span> dynamicTriggerLastRunTime <span class=\"pl-k\">&lt;</span> autoScalerConfig<span class=\"pl-k\">.</span>getMinTriggerDynamicFrequencyMillis()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"397\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">          log<span class=\"pl-k\">.</span>info(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !<span class=\"pl-pds\">\"</span></span>, nowTime <span class=\"pl-k\">-</span> dynamicTriggerLastRunTime, autoScalerConfig<span class=\"pl-k\">.</span>getMinTriggerDynamicFrequencyMillis(), dataSource);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"398\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">          <span class=\"pl-k\">return</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"399\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"400\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"401\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-smi\">Integer</span> desriedTaskCount <span class=\"pl-k\">=</span> scaleAction<span class=\"pl-k\">.</span>call();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"402\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">boolean</span> allocationSuccess <span class=\"pl-k\">=</span> dynamicAllocate(desriedTaskCount);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"403\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"404\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">if</span> (allocationSuccess) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"405\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">          dynamicTriggerLastRunTime <span class=\"pl-k\">=</span> nowTime;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"406\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"407\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"408\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      <span class=\"pl-k\">catch</span> (<span class=\"pl-smi\">Exception</span> ex) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"409\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        log<span class=\"pl-k\">.</span>warn(ex, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Error parsing DynamicAllocationTasksNotice<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"410\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"411\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"382\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-k\">if</span> (autoScalerConfig <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"383\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        log<span class=\"pl-k\">.</span>warn(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>autoScalerConfig is null but dynamic allocation notice is submitted, how can it be ?<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"384\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      } <span class=\"pl-k\">else</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"385\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">try</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"386\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          <span class=\"pl-k\">long</span> nowTime <span class=\"pl-k\">=</span> <span class=\"pl-smi\">System</span><span class=\"pl-k\">.</span>currentTimeMillis();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"387\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          <span class=\"pl-k\">if</span> (spec<span class=\"pl-k\">.</span>isSuspended()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"388\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            log<span class=\"pl-k\">.</span>info(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Skipping DynamicAllocationTasksNotice execution because [%s] supervisor is suspended<span class=\"pl-pds\">\"</span></span>,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"389\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                dataSource</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"390\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            );</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"391\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">return</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"392\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"393\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          log<span class=\"pl-k\">.</span>debug(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>PendingCompletionTaskGroups is [%s] for dataSource [%s]<span class=\"pl-pds\">\"</span></span>, pendingCompletionTaskGroups,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"394\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">              dataSource</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"395\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          );</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"396\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          <span class=\"pl-k\">for</span> (<span class=\"pl-k\">CopyOnWriteArrayList&lt;<span class=\"pl-smi\">TaskGroup</span>&gt;</span> list <span class=\"pl-k\">:</span> pendingCompletionTaskGroups<span class=\"pl-k\">.</span>values()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"397\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>list<span class=\"pl-k\">.</span>isEmpty()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"398\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">              log<span class=\"pl-k\">.</span>info(</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"399\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Skipping DynamicAllocationTasksNotice execution for datasource [%s] because following tasks are pending [%s]<span class=\"pl-pds\">\"</span></span>,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"400\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                  dataSource, pendingCompletionTaskGroups</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"401\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">              );</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"402\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">              <span class=\"pl-k\">return</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"403\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"404\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"405\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          <span class=\"pl-k\">if</span> (nowTime <span class=\"pl-k\">-</span> dynamicTriggerLastRunTime <span class=\"pl-k\">&lt;</span> autoScalerConfig<span class=\"pl-k\">.</span>getMinTriggerDynamicFrequencyMillis()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"406\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            log<span class=\"pl-k\">.</span>info(</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"407\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>DynamicAllocationTasksNotice submitted again in [%d] millis, minTriggerDynamicFrequency is [%s] for dataSource [%s], skipping it!<span class=\"pl-pds\">\"</span></span>,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"408\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                nowTime <span class=\"pl-k\">-</span> dynamicTriggerLastRunTime, autoScalerConfig<span class=\"pl-k\">.</span>getMinTriggerDynamicFrequencyMillis(), dataSource</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"409\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            );</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"410\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">return</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"411\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"412\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"413\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          <span class=\"pl-smi\">Integer</span> desriedTaskCount <span class=\"pl-k\">=</span> scaleAction<span class=\"pl-k\">.</span>call();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"414\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          <span class=\"pl-k\">boolean</span> allocationSuccess <span class=\"pl-k\">=</span> dynamicAllocate(desriedTaskCount);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"415\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"416\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          <span class=\"pl-k\">if</span> (allocationSuccess) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"417\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            dynamicTriggerLastRunTime <span class=\"pl-k\">=</span> nowTime;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"418\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"419\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        } <span class=\"pl-k\">catch</span> (<span class=\"pl-smi\">Exception</span> ex) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"420\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          log<span class=\"pl-k\">.</span>warn(ex, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Error parsing DynamicAllocationTasksNotice<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"421\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"422\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      }</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pjain1", "createdAt": "2021-02-22T12:11:55Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +324,114 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+            return;\n+          }\n+        }\n+        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n+          return;\n+        }\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n+        if (allocationSuccess) {\n+          dynamicTriggerLastRunTime = nowTime;\n+        }\n+      }\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n+      }\n+    }", "originalCommit": "feb3e1e88f68aed4f3ce8a3459d14caf85b663d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDc5MDAwNw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580790007", "bodyText": "Thanks && Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-23T06:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIwMjExNA=="}], "type": "inlineReview", "revised_code": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -340,48 +340,59 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     @Override\n     public void handle()\n     {\n-      try {\n-        long nowTime = System.currentTimeMillis();\n-        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n-        if (spec.isSuspended()) {\n-          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n-          return;\n-        }\n-        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n-        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n-          if (!list.isEmpty()) {\n-            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+      if (autoScalerConfig == null) {\n+        log.warn(\"autoScalerConfig is null but dynamic allocation notice is submitted, how can it be ?\");\n+      } else {\n+        try {\n+          long nowTime = System.currentTimeMillis();\n+          if (spec.isSuspended()) {\n+            log.info(\"Skipping DynamicAllocationTasksNotice execution because [%s] supervisor is suspended\",\n+                    dataSource\n+            );\n             return;\n           }\n+          log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s]\", pendingCompletionTaskGroups,\n+                  dataSource\n+          );\n+          for (CopyOnWriteArrayList<TaskGroup> list : pendingCompletionTaskGroups.values()) {\n+            if (!list.isEmpty()) {\n+              log.info(\n+                      \"Skipping DynamicAllocationTasksNotice execution for datasource [%s] because following tasks are pending [%s]\",\n+                      dataSource, pendingCompletionTaskGroups\n+              );\n+              return;\n+            }\n+          }\n+          if (nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+            log.info(\n+                    \"DynamicAllocationTasksNotice submitted again in [%d] millis, minTriggerDynamicFrequency is [%s] for dataSource [%s], skipping it!\",\n+                    nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource\n+            );\n+            return;\n+          }\n+          Integer desriedTaskCount = scaleAction.call();\n+          boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+          if (allocationSuccess) {\n+            dynamicTriggerLastRunTime = nowTime;\n+          }\n         }\n-        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n-          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n-          return;\n-        }\n-\n-        Integer desriedTaskCount = scaleAction.call();\n-        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n-\n-        if (allocationSuccess) {\n-          dynamicTriggerLastRunTime = nowTime;\n+        catch (Exception ex) {\n+          log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n         }\n       }\n-      catch (Exception ex) {\n-        log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n-      }\n     }\n   }\n \n   /**\n    * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n-   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n-   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n-   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuild in the next 'RunNotice'.\n+   *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\n+   * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\n    * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n-   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n+   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n+   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod' millis.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -387,17 +386,17 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n    *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\n-   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuild in the next 'RunNotice'.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled in the next 'RunNotice'.\n    *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\n    * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\n-   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n-   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n-   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod' millis.\n+   * @param desiredActiveTaskCount desired taskCount computed from AutoScaler\n+   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerScaleActionFrequencyMillis' before next 'changeTaskCount'.\n+   *         If false, it will do 'changeTaskCount' again after 'scaleActionPeriodMillis' millis.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n", "next_change": {"commit": "22339ddc83976758809570dd1c92d7506c26fcfa", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..468363dcbe 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -396,13 +396,13 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean changeTaskCount(int desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n+    if (desiredActiveTaskCount < 0 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n       log.info(\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIwNzExMA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580207110", "body": "```suggestion\r\n   *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\r\n   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuild in the next 'RunNotice'.\r\n   *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\r\n   * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\r\n   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\r\n   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\r\n   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod' millis.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n          \n          \n            \n               *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n          \n          \n            \n               *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n          \n          \n            \n               * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n          \n          \n            \n               * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n          \n          \n            \n               * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n          \n          \n            \n               *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n          \n          \n            \n               *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\n          \n          \n            \n               *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuild in the next 'RunNotice'.\n          \n          \n            \n               *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\n          \n          \n            \n               * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\n          \n          \n            \n               * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n          \n          \n            \n               * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n          \n          \n            \n               *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod' millis.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span>    <span class=\"pl-smi\">First</span> of all, call gracefulShutdownInternal() which will change the state of <span class=\"x x-first x-last\"> </span>current datasource ingest tasks from reading to publishing.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span>    <span class=\"pl-smi\">Secondly</span>, clear all the stateful data structures<span class=\"pl-k\">:</span> activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. <span class=\"pl-smi\">These</span> structures will be <span class=\"x x-first x-last\">rebuiled</span> next <span class=\"pl-s\"><span class=\"pl-pds\">'</span>RunNotice<span class=\"pl-pds\">'</span></span><span class=\"pl-c1\">.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span>    <span class=\"pl-smi\">Finally</span>, change taskCount in <span class=\"pl-smi\">SeekableStreamSupervisorIOConfig</span> and sync it to <span class=\"pl-smi x x-first x-last\">MetaStorage</span>.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-smi\">After</span> <span class=\"x x-first x-last\">changed</span> taskCount in <span class=\"pl-smi\">SeekableStreamSupervisorIOConfig</span>, next <span class=\"pl-smi\">RunNotice</span> will create scaled number of ingest tasks without resubmitting <span class=\"x x-first x-last\">supervisors</span>.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> desiredActiveTaskCount desired taskCount compute from autoscaler</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@return</span> <span class=\"pl-smi\">Boolean</span> flag<span class=\"x x-first\">, </span><span class=\"pl-k x\">do</span><span class=\"x x-last\"> </span>scale action <span class=\"x x-first x-last\">successfully </span>or not. <span class=\"pl-smi\">If</span> <span class=\"pl-c1\">true</span><span class=\"x x-first x-last\"> </span>, it will <span class=\"x x-first x-last\">take</span> at least <span class=\"pl-s\"><span class=\"pl-pds\">'</span>minTriggerDynamicFrequency<span class=\"pl-pds\">'</span></span> before next <span class=\"pl-s\"><span class=\"pl-pds\">'</span>dynamicAllocate<span class=\"pl-pds\">'</span></span><span class=\"pl-c1\">.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span>         <span class=\"pl-smi\">If</span> <span class=\"pl-c1\">false</span>, it will <span class=\"pl-k\">do</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>dynamicAllocate<span class=\"pl-pds\">'</span></span> again after <span class=\"pl-s\"><span class=\"pl-pds\">'</span>dynamicCheckPeriod<span class=\"pl-pds\">'</span></span><span class=\"pl-c1\">.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span>    <span class=\"pl-smi\">First</span> of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span>    <span class=\"pl-smi\">Secondly</span>, clear all the stateful data structures<span class=\"pl-k\">:</span> activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. <span class=\"pl-smi\">These</span> structures will be <span class=\"x x-first x-last\">rebuild in the</span> next <span class=\"pl-s\"><span class=\"pl-pds\">'</span>RunNotice<span class=\"pl-pds\">'</span></span><span class=\"pl-c1\">.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span>    <span class=\"pl-smi\">Finally</span>, change <span class=\"x x-first x-last\">the </span>taskCount in <span class=\"pl-smi\">SeekableStreamSupervisorIOConfig</span> and sync it to <span class=\"pl-smi x x-first x-last\">MetadataStorage</span>.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-smi\">After</span> <span class=\"x x-first x-last\">the</span> taskCount <span class=\"x x-first x-last\">is changed </span>in <span class=\"pl-smi\">SeekableStreamSupervisorIOConfig</span>, next <span class=\"pl-smi\">RunNotice</span> will create scaled number of ingest tasks without resubmitting <span class=\"x x-first x-last\">the supervisor</span>.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> desiredActiveTaskCount desired taskCount compute from autoscaler</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@return</span> <span class=\"pl-smi\">Boolean</span> flag<span class=\"x x-first\"> indicating </span><span class=\"pl-k x\">if</span><span class=\"x x-last\"> </span>scale action <span class=\"x x-first x-last\">was executed </span>or not. <span class=\"pl-smi\">If</span> <span class=\"pl-c1\">true</span>, it will <span class=\"x x-first x-last\">wait</span> at least <span class=\"pl-s\"><span class=\"pl-pds\">'</span>minTriggerDynamicFrequency<span class=\"pl-pds\">'</span></span> before next <span class=\"pl-s\"><span class=\"pl-pds\">'</span>dynamicAllocate<span class=\"pl-pds\">'</span></span><span class=\"pl-c1\">.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span>         <span class=\"pl-smi\">If</span> <span class=\"pl-c1\">false</span>, it will <span class=\"pl-k\">do</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>dynamicAllocate<span class=\"pl-pds\">'</span></span> again after <span class=\"pl-s\"><span class=\"pl-pds\">'</span>dynamicCheckPeriod<span class=\"pl-pds\">'</span></span><span class=\"x x-first x-last\"> millis</span>.</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pjain1", "createdAt": "2021-02-22T12:20:27Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +324,114 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+            return;\n+          }\n+        }\n+        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n+          return;\n+        }\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n+        if (allocationSuccess) {\n+          dynamicTriggerLastRunTime = nowTime;\n+        }\n+      }\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method determines how to do scale actions based on collected lag points.\n+   * If scale action is triggered :\n+   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n+   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n+   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.", "originalCommit": "feb3e1e88f68aed4f3ce8a3459d14caf85b663d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDc5MDAyMw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580790023", "bodyText": "Thanks && Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-23T06:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIwNzExMA=="}], "type": "inlineReview", "revised_code": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -340,48 +340,59 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     @Override\n     public void handle()\n     {\n-      try {\n-        long nowTime = System.currentTimeMillis();\n-        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n-        if (spec.isSuspended()) {\n-          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n-          return;\n-        }\n-        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n-        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n-          if (!list.isEmpty()) {\n-            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+      if (autoScalerConfig == null) {\n+        log.warn(\"autoScalerConfig is null but dynamic allocation notice is submitted, how can it be ?\");\n+      } else {\n+        try {\n+          long nowTime = System.currentTimeMillis();\n+          if (spec.isSuspended()) {\n+            log.info(\"Skipping DynamicAllocationTasksNotice execution because [%s] supervisor is suspended\",\n+                    dataSource\n+            );\n             return;\n           }\n+          log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s]\", pendingCompletionTaskGroups,\n+                  dataSource\n+          );\n+          for (CopyOnWriteArrayList<TaskGroup> list : pendingCompletionTaskGroups.values()) {\n+            if (!list.isEmpty()) {\n+              log.info(\n+                      \"Skipping DynamicAllocationTasksNotice execution for datasource [%s] because following tasks are pending [%s]\",\n+                      dataSource, pendingCompletionTaskGroups\n+              );\n+              return;\n+            }\n+          }\n+          if (nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+            log.info(\n+                    \"DynamicAllocationTasksNotice submitted again in [%d] millis, minTriggerDynamicFrequency is [%s] for dataSource [%s], skipping it!\",\n+                    nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource\n+            );\n+            return;\n+          }\n+          Integer desriedTaskCount = scaleAction.call();\n+          boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+          if (allocationSuccess) {\n+            dynamicTriggerLastRunTime = nowTime;\n+          }\n         }\n-        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n-          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n-          return;\n-        }\n-\n-        Integer desriedTaskCount = scaleAction.call();\n-        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n-\n-        if (allocationSuccess) {\n-          dynamicTriggerLastRunTime = nowTime;\n+        catch (Exception ex) {\n+          log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n         }\n       }\n-      catch (Exception ex) {\n-        log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n-      }\n     }\n   }\n \n   /**\n    * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n-   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n-   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n-   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n-   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuild in the next 'RunNotice'.\n+   *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\n+   * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\n    * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n-   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n-   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n+   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n+   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod' millis.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -387,17 +386,17 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    * This method determines how to do scale actions based on collected lag points.\n    * If scale action is triggered :\n    *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\n-   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuild in the next 'RunNotice'.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled in the next 'RunNotice'.\n    *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\n    * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\n-   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n-   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n-   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod' millis.\n+   * @param desiredActiveTaskCount desired taskCount computed from AutoScaler\n+   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerScaleActionFrequencyMillis' before next 'changeTaskCount'.\n+   *         If false, it will do 'changeTaskCount' again after 'scaleActionPeriodMillis' millis.\n    * @throws InterruptedException\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n", "next_change": {"commit": "22339ddc83976758809570dd1c92d7506c26fcfa", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..468363dcbe 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -396,13 +396,13 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean changeTaskCount(int desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n+    if (desiredActiveTaskCount < 0 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n       log.info(\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIwNzY0OQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580207649", "body": "```suggestion\r\n      log.debug(\r\n          \"Starting scale action, current active task count is [%d] and desired task count is [%d] for dataSource [%s].\",\r\n          currentActiveTaskCount, desiredActiveTaskCount, dataSource\r\n      );\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n          \n          \n            \n                  log.debug(\n          \n          \n            \n                      \"Starting scale action, current active task count is [%d] and desired task count is [%d] for dataSource [%s].\",\n          \n          \n            \n                      currentActiveTaskCount, desiredActiveTaskCount, dataSource\n          \n          \n            \n                  );", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      log<span class=\"pl-k\">.</span>debug(<span class=\"pl-s\"><span class=\"pl-pds x x-first\">\"</span><span class=\"x\">Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].</span><span class=\"pl-pds x\">\"</span></span><span class=\"x x-last\">, currentActiveTaskCount, desiredActiveTaskCount, dataSource);</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      log<span class=\"pl-k\">.</span>debug(</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Starting scale action, current active task count is [%d] and desired task count is [%d] for dataSource [%s].<span class=\"pl-pds\">\"</span></span>,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          currentActiveTaskCount, desiredActiveTaskCount, dataSource</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      );</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pjain1", "createdAt": "2021-02-22T12:21:22Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +324,114 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+            return;\n+          }\n+        }\n+        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n+          return;\n+        }\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n+        if (allocationSuccess) {\n+          dynamicTriggerLastRunTime = nowTime;\n+        }\n+      }\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method determines how to do scale actions based on collected lag points.\n+   * If scale action is triggered :\n+   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n+   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n+   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n+   * @throws InterruptedException\n+   * @throws ExecutionException\n+   * @throws TimeoutException\n+   */\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  {\n+    int currentActiveTaskCount;\n+    Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n+    currentActiveTaskCount = activeTaskGroups.size();\n+\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n+      return false;\n+    } else {\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);", "originalCommit": "feb3e1e88f68aed4f3ce8a3459d14caf85b663d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDc5MDAyOQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580790029", "bodyText": "Thanks && Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-23T06:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIwNzY0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -395,7 +406,10 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n+      log.debug(\n+              \"Starting scale action, current active task count is [%d] and desired task count is [%d] for dataSource [%s].\",\n+              currentActiveTaskCount, desiredActiveTaskCount, dataSource\n+      );\n       gracefulShutdownInternal();\n       changeTaskCountInIOConfig(desiredActiveTaskCount);\n       // clear everything\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -406,14 +405,13 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n-      log.debug(\n+      log.info(\n               \"Starting scale action, current active task count is [%d] and desired task count is [%d] for dataSource [%s].\",\n               currentActiveTaskCount, desiredActiveTaskCount, dataSource\n       );\n       gracefulShutdownInternal();\n       changeTaskCountInIOConfig(desiredActiveTaskCount);\n-      // clear everything\n-      clearAllocationInfos();\n+      clearAllocationInfo();\n       log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n       return true;\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIwODI4Nw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580208287", "body": "```suggestion\r\n        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n          \n          \n            \n                    log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        log<span class=\"pl-k\">.</span>warn(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>supervisorManager is null in taskMaster, <span class=\"x x-first x-last\">skip to do</span> scale action for dataSource [%s].<span class=\"pl-pds\">\"</span></span>, dataSource);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        log<span class=\"pl-k\">.</span>warn(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>supervisorManager is null in taskMaster, <span class=\"x x-first x-last\">skipping</span> scale action for dataSource [%s].<span class=\"pl-pds\">\"</span></span>, dataSource);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pjain1", "createdAt": "2021-02-22T12:22:23Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +324,114 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lags points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      try {\n+        long nowTime = System.currentTimeMillis();\n+        // Only queue is full and over minTriggerDynamicFrequency can trigger scale out/in\n+        if (spec.isSuspended()) {\n+          log.info(\"[%s] supervisor is suspended, skip to check dynamic allocate task logic\", dataSource);\n+          return;\n+        }\n+        log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+        for (CopyOnWriteArrayList list : pendingCompletionTaskGroups.values()) {\n+          if (!list.isEmpty()) {\n+            log.info(\"Still hand off tasks unfinished, skip to do scale action [%s] for dataSource [%s].\", pendingCompletionTaskGroups, dataSource);\n+            return;\n+          }\n+        }\n+        if (autoScalerConfig != null && nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerDynamicFrequencyMillis()) {\n+          log.info(\"NowTime - dynamicTriggerLastRunTime is [%s]. Defined minTriggerDynamicFrequency is [%s] for dataSource [%s], CALM DOWN NOW !\", nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerDynamicFrequencyMillis(), dataSource);\n+          return;\n+        }\n+\n+        Integer desriedTaskCount = scaleAction.call();\n+        boolean allocationSuccess = dynamicAllocate(desriedTaskCount);\n+\n+        if (allocationSuccess) {\n+          dynamicTriggerLastRunTime = nowTime;\n+        }\n+      }\n+      catch (Exception ex) {\n+        log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method determines how to do scale actions based on collected lag points.\n+   * If scale action is triggered :\n+   *    First of all, call gracefulShutdownInternal() which will change the state of  current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled next 'RunNotice'.\n+   *    Finally, change taskCount in SeekableStreamSupervisorIOConfig and sync it to MetaStorage.\n+   * After changed taskCount in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting supervisors.\n+   * @param desiredActiveTaskCount desired taskCount compute from autoscaler\n+   * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocate'.\n+   *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n+   * @throws InterruptedException\n+   * @throws ExecutionException\n+   * @throws TimeoutException\n+   */\n+  private boolean dynamicAllocate(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  {\n+    int currentActiveTaskCount;\n+    Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n+    currentActiveTaskCount = activeTaskGroups.size();\n+\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n+      return false;\n+    } else {\n+      log.debug(\"Start to scale action tasks, current active task number [%s] and desired task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n+      gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n+      // clear everything\n+      clearAllocationInfos();\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n+      return true;\n+    }\n+  }\n+\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n+  {\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n+    try {\n+      Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n+      if (supervisorManager.isPresent()) {\n+        MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n+        metadataSupervisorManager.insert(dataSource, spec);\n+      } else {\n+        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);", "originalCommit": "feb3e1e88f68aed4f3ce8a3459d14caf85b663d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDc5MDA0Nw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580790047", "bodyText": "Thanks && Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-23T06:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIwODI4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -414,7 +428,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skip to do scale action for dataSource [%s].\", dataSource);\n+        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n", "next_change": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex ea223e78e0..1c7a177d6d 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -428,15 +426,15 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n         MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n         metadataSupervisorManager.insert(dataSource, spec);\n       } else {\n-        log.warn(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n       }\n     }\n     catch (Exception e) {\n-      log.warn(\"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n     }\n   }\n \n-  private void clearAllocationInfos()\n+  private void clearAllocationInfo()\n   {\n     activelyReadingTaskGroups.clear();\n     partitionGroups.clear();\n", "next_change": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIxMDg3OQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580210879", "body": "Not sure what you mean by `fill in 'lags'`\r\n```suggestion\r\n   * This method computes maxLag, totalLag and avgLag \r\n```", "bodyText": "Not sure what you mean by fill in 'lags'\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * This method compute maxLag, totalLag and avgLag then fill in 'lags'\n          \n          \n            \n               * This method computes maxLag, totalLag and avgLag", "bodyHTML": "<p dir=\"auto\">Not sure what you mean by <code>fill in 'lags'</code></p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-smi\">This</span> method <span class=\"x x-first x-last\">compute</span> maxLag, totalLag and avgLag <span class=\"x x-first\">then fill in </span><span class=\"pl-s\"><span class=\"pl-pds x\">'</span><span class=\"x\">lags</span><span class=\"pl-pds x x-last\">'</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-smi\">This</span> method <span class=\"x x-first x-last\">computes</span> maxLag, totalLag and avgLag </td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pjain1", "createdAt": "2021-02-22T12:27:03Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -3543,6 +3682,24 @@ protected void emitLag()\n     }\n   }\n \n+\n+  /**\n+   * This method compute maxLag, totalLag and avgLag then fill in 'lags'", "originalCommit": "feb3e1e88f68aed4f3ce8a3459d14caf85b663d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDc5MDA4MQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580790081", "bodyText": "Thanks && Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-23T06:13:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIxMDg3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 31a4db5118..ea223e78e0 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -3684,7 +3696,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n \n \n   /**\n-   * This method compute maxLag, totalLag and avgLag then fill in 'lags'\n+   *  This method computes maxLag, totalLag and avgLag\n    * @param partitionLags lags per partition\n    */\n   protected LagStats computeLags(Map<PartitionIdType, Long> partitionLags)\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIzMTU0NA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580231544", "body": "if by mistake one submits `autoScalerConfig` for kinesis supervisor then seems like `DefaultAutoScaler ` is created for kinesis also ?", "bodyText": "if by mistake one submits autoScalerConfig for kinesis supervisor then seems like DefaultAutoScaler  is created for kinesis also ?", "bodyHTML": "<p dir=\"auto\">if by mistake one submits <code>autoScalerConfig</code> for kinesis supervisor then seems like <code>DefaultAutoScaler </code> is created for kinesis also ?</p>", "author": "pjain1", "createdAt": "2021-02-22T13:01:05Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java", "diffHunk": "@@ -151,6 +157,37 @@ public DruidMonitorSchedulerConfig getMonitorSchedulerConfig()\n   @Override\n   public abstract Supervisor createSupervisor();\n \n+  /**\n+   * need to notice that autoScaler would be null which means autoscale is dissable.\n+   * @param supervisor\n+   * @return autoScaler, disable autoscale will return dummyAutoScaler and enable autoscale wiil return defaultAutoScaler by default.\n+   */\n+  @Override\n+  @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED\", justification = \"using siwtch(String)\")\n+  public SupervisorTaskAutoscaler createAutoscaler(Supervisor supervisor)\n+  {\n+    String dataSource = getId();\n+    SupervisorTaskAutoscaler autoScaler = new DummyAutoScaler(supervisor, dataSource);\n+    AutoScalerConfig autoScalerConfig = ingestionSchema.getIOConfig().getAutoscalerConfig();\n+\n+    // kinesis'autoscalerConfig is always null for now, So that kinesis will hold a DummyAutoScaler.\n+    // only SeekableStreamSupervisor is supported here.\n+    if (autoScalerConfig != null", "originalCommit": "feb3e1e88f68aed4f3ce8a3459d14caf85b663d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIzMzg3Ng==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580233876", "bodyText": "I see null is being passed from KinesisSupervisorIOConfig so it will be null", "author": "pjain1", "createdAt": "2021-02-22T13:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIzMTU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDI4MDYzNg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580280636", "bodyText": "reviewed till here", "author": "pjain1", "createdAt": "2021-02-22T14:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIzMTU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDc5MDMwNw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r580790307", "bodyText": "Thanks.", "author": "zhangyue19921010", "createdAt": "2021-02-23T06:14:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIzMTU0NA=="}], "type": "inlineReview", "revised_code": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\nindex f4c9417fb9..638769891c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n", "chunk": "@@ -163,29 +160,13 @@ public abstract class SeekableStreamSupervisorSpec implements SupervisorSpec\n    * @return autoScaler, disable autoscale will return dummyAutoScaler and enable autoscale wiil return defaultAutoScaler by default.\n    */\n   @Override\n-  @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED\", justification = \"using siwtch(String)\")\n-  public SupervisorTaskAutoscaler createAutoscaler(Supervisor supervisor)\n+  public SupervisorTaskAutoScaler createAutoscaler(Supervisor supervisor)\n   {\n-    String dataSource = getId();\n-    SupervisorTaskAutoscaler autoScaler = new DummyAutoScaler(supervisor, dataSource);\n     AutoScalerConfig autoScalerConfig = ingestionSchema.getIOConfig().getAutoscalerConfig();\n-\n-    // kinesis'autoscalerConfig is always null for now, So that kinesis will hold a DummyAutoScaler.\n-    // only SeekableStreamSupervisor is supported here.\n-    if (autoScalerConfig != null\n-            && autoScalerConfig.getEnableTaskAutoscaler()\n-            && supervisor instanceof SeekableStreamSupervisor) {\n-\n-      String autoScalerStrategy = autoScalerConfig.getAutoScalerStrategy();\n-\n-      // will thorw 'Return value of String.hashCode() ignored : RV_RETURN_VALUE_IGNORED' just Suppress it.\n-      switch (StringUtils.toLowerCase(autoScalerStrategy)) {\n-        default: {\n-          autoScaler = new DefaultAutoScaler(supervisor, dataSource, autoScalerConfig, this);\n-        }\n-      }\n+    if (autoScalerConfig != null && autoScalerConfig.getEnableTaskAutoScaler() && supervisor instanceof SeekableStreamSupervisor) {\n+      return autoScalerConfig.createAutoScaler(supervisor, this);\n     }\n-    return autoScaler;\n+    return new NoopTaskAutoScaler();\n   }\n \n   @Override\n", "next_change": null}]}}, {"oid": "b6632d6c713f2bf87905de0ebb83756d3716edeb", "url": "https://github.com/apache/druid/commit/b6632d6c713f2bf87905de0ebb83756d3716edeb", "message": "code reviewed", "committedDate": "2021-02-23T06:07:26Z", "type": "commit"}, {"oid": "688b9c4b4ff1841477d8139a7c83e54d36ccb986", "url": "https://github.com/apache/druid/commit/688b9c4b4ff1841477d8139a7c83e54d36ccb986", "message": "Merge branch 'master' into kafka-dynamic-scale-ingest-tasks", "committedDate": "2021-02-23T06:09:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxMzQ4MQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r581913481", "body": "The way `autoScaler` instance is created here does not support custom autoScaler implementation in extensions as switch statement is used to create the instance. If a new strategy is implemented for autoScaler in an extension, this class needs to be changed to support it which is not ideal as its a change in core Druid. I have raised a PR on your branch on how we can fix this - https://github.com/zhangyue19921010/druid/pull/1\r\n\r\nThe changes are - \r\n1. Add `SupervisorTaskAutoScaler createAutoScaler(Supervisor supervisor, SupervisorSpec spec);` method in `AutoScalerConfig` that will be called from `SeekableStreamSupervisorSpec` to create autoScaler.\r\n2. I don't think `getAutoScalerStrategy` method is needed in `AutoScalerConfig` as implementation of `AutoScalerConfig` can return instance of `AutoScaler` directly on call to `createAutoScaler`.", "bodyText": "The way autoScaler instance is created here does not support custom autoScaler implementation in extensions as switch statement is used to create the instance. If a new strategy is implemented for autoScaler in an extension, this class needs to be changed to support it which is not ideal as its a change in core Druid. I have raised a PR on your branch on how we can fix this - zhangyue19921010#1\nThe changes are -\n\nAdd SupervisorTaskAutoScaler createAutoScaler(Supervisor supervisor, SupervisorSpec spec); method in AutoScalerConfig that will be called from SeekableStreamSupervisorSpec to create autoScaler.\nI don't think getAutoScalerStrategy method is needed in AutoScalerConfig as implementation of AutoScalerConfig can return instance of AutoScaler directly on call to createAutoScaler.", "bodyHTML": "<p dir=\"auto\">The way <code>autoScaler</code> instance is created here does not support custom autoScaler implementation in extensions as switch statement is used to create the instance. If a new strategy is implemented for autoScaler in an extension, this class needs to be changed to support it which is not ideal as its a change in core Druid. I have raised a PR on your branch on how we can fix this - <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"815420775\" data-permission-text=\"Title is private\" data-url=\"https://github.com/zhangyue19921010/druid/issues/1\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/zhangyue19921010/druid/pull/1/hovercard\" href=\"https://github.com/zhangyue19921010/druid/pull/1\">zhangyue19921010#1</a></p>\n<p dir=\"auto\">The changes are -</p>\n<ol dir=\"auto\">\n<li>Add <code>SupervisorTaskAutoScaler createAutoScaler(Supervisor supervisor, SupervisorSpec spec);</code> method in <code>AutoScalerConfig</code> that will be called from <code>SeekableStreamSupervisorSpec</code> to create autoScaler.</li>\n<li>I don't think <code>getAutoScalerStrategy</code> method is needed in <code>AutoScalerConfig</code> as implementation of <code>AutoScalerConfig</code> can return instance of <code>AutoScaler</code> directly on call to <code>createAutoScaler</code>.</li>\n</ol>", "author": "pjain1", "createdAt": "2021-02-24T12:21:35Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java", "diffHunk": "@@ -151,6 +157,37 @@ public DruidMonitorSchedulerConfig getMonitorSchedulerConfig()\n   @Override\n   public abstract Supervisor createSupervisor();\n \n+  /**\n+   * need to notice that autoScaler would be null which means autoscale is dissable.\n+   * @param supervisor\n+   * @return autoScaler, disable autoscale will return dummyAutoScaler and enable autoscale wiil return defaultAutoScaler by default.\n+   */\n+  @Override\n+  @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED\", justification = \"using siwtch(String)\")\n+  public SupervisorTaskAutoscaler createAutoscaler(Supervisor supervisor)", "originalCommit": "688b9c4b4ff1841477d8139a7c83e54d36ccb986", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjY2NDA3MA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582664070", "bodyText": "Nice Coding! changed.", "author": "zhangyue19921010", "createdAt": "2021-02-25T09:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxMzQ4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\nindex f4c9417fb9..638769891c 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n", "chunk": "@@ -163,29 +160,13 @@ public abstract class SeekableStreamSupervisorSpec implements SupervisorSpec\n    * @return autoScaler, disable autoscale will return dummyAutoScaler and enable autoscale wiil return defaultAutoScaler by default.\n    */\n   @Override\n-  @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED\", justification = \"using siwtch(String)\")\n-  public SupervisorTaskAutoscaler createAutoscaler(Supervisor supervisor)\n+  public SupervisorTaskAutoScaler createAutoscaler(Supervisor supervisor)\n   {\n-    String dataSource = getId();\n-    SupervisorTaskAutoscaler autoScaler = new DummyAutoScaler(supervisor, dataSource);\n     AutoScalerConfig autoScalerConfig = ingestionSchema.getIOConfig().getAutoscalerConfig();\n-\n-    // kinesis'autoscalerConfig is always null for now, So that kinesis will hold a DummyAutoScaler.\n-    // only SeekableStreamSupervisor is supported here.\n-    if (autoScalerConfig != null\n-            && autoScalerConfig.getEnableTaskAutoscaler()\n-            && supervisor instanceof SeekableStreamSupervisor) {\n-\n-      String autoScalerStrategy = autoScalerConfig.getAutoScalerStrategy();\n-\n-      // will thorw 'Return value of String.hashCode() ignored : RV_RETURN_VALUE_IGNORED' just Suppress it.\n-      switch (StringUtils.toLowerCase(autoScalerStrategy)) {\n-        default: {\n-          autoScaler = new DefaultAutoScaler(supervisor, dataSource, autoScalerConfig, this);\n-        }\n-      }\n+    if (autoScalerConfig != null && autoScalerConfig.getEnableTaskAutoScaler() && supervisor instanceof SeekableStreamSupervisor) {\n+      return autoScalerConfig.createAutoScaler(supervisor, this);\n     }\n-    return autoScaler;\n+    return new NoopTaskAutoScaler();\n   }\n \n   @Override\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxMzkxMg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r581913912", "body": "This is not required as mentioned above and add another method to create auto scaler as mentioned in above comment.", "bodyText": "This is not required as mentioned above and add another method to create auto scaler as mentioned in above comment.", "bodyHTML": "<p dir=\"auto\">This is not required as mentioned above and add another method to create auto scaler as mentioned in above comment.</p>", "author": "pjain1", "createdAt": "2021-02-24T12:22:15Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/AutoScalerConfig.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonSubTypes.Type;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import org.apache.druid.guice.annotations.UnstableApi;\n+\n+@UnstableApi\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"autoScalerStrategy\", defaultImpl = DefaultAutoScalerConfig.class)\n+@JsonSubTypes(value = {\n+        @Type(name = \"default\", value = DefaultAutoScalerConfig.class)\n+})\n+public interface AutoScalerConfig\n+{\n+  boolean getEnableTaskAutoscaler();\n+  long getMinTriggerDynamicFrequencyMillis();\n+  String getAutoScalerStrategy();", "originalCommit": "688b9c4b4ff1841477d8139a7c83e54d36ccb986", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjY2NDEwNA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582664104", "bodyText": "Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-25T09:13:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxMzkxMg=="}], "type": "inlineReview", "revised_code": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/AutoScalerConfig.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/AutoScalerConfig.java\nindex ca3553dda2..53174a17bb 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/AutoScalerConfig.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/AutoScalerConfig.java\n", "chunk": "@@ -23,18 +23,21 @@ import com.fasterxml.jackson.annotation.JsonSubTypes;\n import com.fasterxml.jackson.annotation.JsonSubTypes.Type;\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import org.apache.druid.guice.annotations.UnstableApi;\n+import org.apache.druid.indexing.overlord.supervisor.Supervisor;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorSpec;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoScaler;\n \n @UnstableApi\n-@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"autoScalerStrategy\", defaultImpl = DefaultAutoScalerConfig.class)\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"autoScalerStrategy\", defaultImpl = LagBasedAutoScalerConfig.class)\n @JsonSubTypes(value = {\n-        @Type(name = \"default\", value = DefaultAutoScalerConfig.class)\n+        @Type(name = \"lagBased\", value = LagBasedAutoScalerConfig.class)\n })\n public interface AutoScalerConfig\n {\n-  boolean getEnableTaskAutoscaler();\n-  long getMinTriggerDynamicFrequencyMillis();\n-  String getAutoScalerStrategy();\n+  boolean getEnableTaskAutoScaler();\n+  long getMinTriggerScaleActionFrequencyMillis();\n   int getTaskCountMax();\n   int getTaskCountMin();\n+  SupervisorTaskAutoScaler createAutoScaler(Supervisor supervisor, SupervisorSpec spec);\n }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxNDc2Nw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r581914767", "body": "I think we should change the name of this to `LagBasedAutoScalerConfig` as it is using lag to make decisions about auto scaling. Also we should not use `default` as type names as it is confusing. See https://github.com/zhangyue19921010/druid/pull/1 ", "bodyText": "I think we should change the name of this to LagBasedAutoScalerConfig as it is using lag to make decisions about auto scaling. Also we should not use default as type names as it is confusing. See zhangyue19921010#1", "bodyHTML": "<p dir=\"auto\">I think we should change the name of this to <code>LagBasedAutoScalerConfig</code> as it is using lag to make decisions about auto scaling. Also we should not use <code>default</code> as type names as it is confusing. See <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"815420775\" data-permission-text=\"Title is private\" data-url=\"https://github.com/zhangyue19921010/druid/issues/1\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/zhangyue19921010/druid/pull/1/hovercard\" href=\"https://github.com/zhangyue19921010/druid/pull/1\">zhangyue19921010#1</a></p>", "author": "pjain1", "createdAt": "2021-02-24T12:23:42Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/AutoScalerConfig.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonSubTypes.Type;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import org.apache.druid.guice.annotations.UnstableApi;\n+\n+@UnstableApi\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"autoScalerStrategy\", defaultImpl = DefaultAutoScalerConfig.class)\n+@JsonSubTypes(value = {\n+        @Type(name = \"default\", value = DefaultAutoScalerConfig.class)", "originalCommit": "688b9c4b4ff1841477d8139a7c83e54d36ccb986", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjY2NDE5Mw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582664193", "bodyText": "Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-25T09:13:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxNDc2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/AutoScalerConfig.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/AutoScalerConfig.java\nindex ca3553dda2..53174a17bb 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/AutoScalerConfig.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/AutoScalerConfig.java\n", "chunk": "@@ -23,18 +23,21 @@ import com.fasterxml.jackson.annotation.JsonSubTypes;\n import com.fasterxml.jackson.annotation.JsonSubTypes.Type;\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import org.apache.druid.guice.annotations.UnstableApi;\n+import org.apache.druid.indexing.overlord.supervisor.Supervisor;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorSpec;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoScaler;\n \n @UnstableApi\n-@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"autoScalerStrategy\", defaultImpl = DefaultAutoScalerConfig.class)\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"autoScalerStrategy\", defaultImpl = LagBasedAutoScalerConfig.class)\n @JsonSubTypes(value = {\n-        @Type(name = \"default\", value = DefaultAutoScalerConfig.class)\n+        @Type(name = \"lagBased\", value = LagBasedAutoScalerConfig.class)\n })\n public interface AutoScalerConfig\n {\n-  boolean getEnableTaskAutoscaler();\n-  long getMinTriggerDynamicFrequencyMillis();\n-  String getAutoScalerStrategy();\n+  boolean getEnableTaskAutoScaler();\n+  long getMinTriggerScaleActionFrequencyMillis();\n   int getTaskCountMax();\n   int getTaskCountMin();\n+  SupervisorTaskAutoScaler createAutoScaler(Supervisor supervisor, SupervisorSpec spec);\n }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxNTkwNA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r581915904", "body": "See https://github.com/zhangyue19921010/druid/pull/1/files#diff-f1b33808bb841d1e71e1f5ec3fbaeb3f94899066277b75e192942b66371667ce for suggestions on log lines, method and variable names.", "bodyText": "See https://github.com/zhangyue19921010/druid/pull/1/files#diff-f1b33808bb841d1e71e1f5ec3fbaeb3f94899066277b75e192942b66371667ce for suggestions on log lines, method and variable names.", "bodyHTML": "<p dir=\"auto\">See <a href=\"https://github.com/zhangyue19921010/druid/pull/1/files#diff-f1b33808bb841d1e71e1f5ec3fbaeb3f94899066277b75e192942b66371667ce\">https://github.com/zhangyue19921010/druid/pull/1/files#diff-f1b33808bb841d1e71e1f5ec3fbaeb3f94899066277b75e192942b66371667ce</a> for suggestions on log lines, method and variable names.</p>", "author": "pjain1", "createdAt": "2021-02-24T12:25:31Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DefaultAutoScaler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n+\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.druid.indexing.overlord.supervisor.Supervisor;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorSpec;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.LagStats;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoscaler;\n+import org.apache.druid.indexing.seekablestream.supervisor.SeekableStreamSupervisor;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.emitter.EmittingLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+public class DefaultAutoScaler implements SupervisorTaskAutoscaler", "originalCommit": "688b9c4b4ff1841477d8139a7c83e54d36ccb986", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjY2NDI1Ng==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582664256", "bodyText": "Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-25T09:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxNTkwNA=="}], "type": "inlineReview", "revised_code": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DefaultAutoScaler.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DefaultAutoScaler.java\ndeleted file mode 100644\nindex 031825a371..0000000000\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DefaultAutoScaler.java\n+++ /dev/null\n", "chunk": "@@ -1,244 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n-\n-import org.apache.commons.collections4.queue.CircularFifoQueue;\n-import org.apache.druid.indexing.overlord.supervisor.Supervisor;\n-import org.apache.druid.indexing.overlord.supervisor.SupervisorSpec;\n-import org.apache.druid.indexing.overlord.supervisor.autoscaler.LagStats;\n-import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoscaler;\n-import org.apache.druid.indexing.seekablestream.supervisor.SeekableStreamSupervisor;\n-import org.apache.druid.java.util.common.StringUtils;\n-import org.apache.druid.java.util.common.concurrent.Execs;\n-import org.apache.druid.java.util.emitter.EmittingLogger;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.ReentrantLock;\n-\n-public class DefaultAutoScaler implements SupervisorTaskAutoscaler\n-{\n-  private static final EmittingLogger log = new EmittingLogger(DefaultAutoScaler.class);\n-  private final String dataSource;\n-  private final CircularFifoQueue<Long> lagMetricsQueue;\n-  private final ScheduledExecutorService lagComputationExec;\n-  private final ScheduledExecutorService allocationExec;\n-  private final SupervisorSpec spec;\n-  private final SeekableStreamSupervisor supervisor;\n-  private final DefaultAutoScalerConfig defaultAutoScalerConfig;\n-\n-  private static ReentrantLock lock = new ReentrantLock(true);\n-\n-\n-  public DefaultAutoScaler(Supervisor supervisor, String dataSource, AutoScalerConfig autoScalerConfig, SupervisorSpec spec)\n-  {\n-    this.defaultAutoScalerConfig = (DefaultAutoScalerConfig) autoScalerConfig;\n-    String supervisorId = StringUtils.format(\"KafkaSupervisor-%s\", dataSource);\n-    this.dataSource = dataSource;\n-    int slots = (int) (defaultAutoScalerConfig.getMetricsCollectionRangeMillis() / defaultAutoScalerConfig.getMetricsCollectionIntervalMillis()) + 1;\n-    log.debug(\" The interval of metrics collection is [%s], [%s] timeRange will collect [%s] data points for dataSource [%s].\", defaultAutoScalerConfig.getMetricsCollectionIntervalMillis(), defaultAutoScalerConfig.getMetricsCollectionRangeMillis(), slots, dataSource);\n-    this.lagMetricsQueue = new CircularFifoQueue<>(slots);\n-    this.allocationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Allocation-%d\");\n-    this.lagComputationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Computation-%d\");\n-    this.spec = spec;\n-    this.supervisor = (SeekableStreamSupervisor) supervisor;\n-  }\n-\n-  @Override\n-  public void start()\n-  {\n-    Callable<Integer> scaleAction = new Callable<Integer>() {\n-        @Override\n-        public Integer call()\n-        {\n-          lock.lock();\n-          int desireTaskCount = -1;\n-          try {\n-            desireTaskCount = computeDesireTaskCount(new ArrayList<>(lagMetricsQueue));\n-\n-            if (desireTaskCount != -1) {\n-              lagMetricsQueue.clear();\n-            }\n-          }\n-          catch (Exception ex) {\n-            log.warn(ex, \"Exception when computeDesireTaskCount [%s]\", dataSource);\n-          }\n-          finally {\n-            lock.unlock();\n-          }\n-          return desireTaskCount;\n-        }\n-    };\n-\n-    log.info(\"enableTaskAutoscaler for datasource [%s]\", dataSource);\n-    log.debug(\"Collect and compute lags at fixed rate of [%s] for dataSource[%s].\", defaultAutoScalerConfig.getMetricsCollectionIntervalMillis(), dataSource);\n-    lagComputationExec.scheduleAtFixedRate(\n-            collectAndComputeLags(),\n-            defaultAutoScalerConfig.getDynamicCheckStartDelayMillis(), // wait for tasks to start up\n-            defaultAutoScalerConfig.getMetricsCollectionIntervalMillis(),\n-            TimeUnit.MILLISECONDS\n-    );\n-    log.debug(\"allocate task at fixed rate of [%s], dataSource [%s].\", defaultAutoScalerConfig.getDynamicCheckPeriod(), dataSource);\n-    allocationExec.scheduleAtFixedRate(\n-            supervisor.buildDynamicAllocationTask(scaleAction),\n-            defaultAutoScalerConfig.getDynamicCheckStartDelayMillis() + defaultAutoScalerConfig.getMetricsCollectionRangeMillis(),\n-            defaultAutoScalerConfig.getDynamicCheckPeriod(),\n-            TimeUnit.MILLISECONDS\n-    );\n-  }\n-\n-  @Override\n-  public void stop()\n-  {\n-    allocationExec.shutdownNow();\n-    lagComputationExec.shutdownNow();\n-  }\n-\n-  @Override\n-  public void reset()\n-  {\n-    // clear queue for kafka lags\n-    if (lagMetricsQueue != null) {\n-      try {\n-        lock.lock();\n-        lagMetricsQueue.clear();\n-      }\n-      catch (Exception e) {\n-        log.warn(e, \"Error,when clear queue in rest action\");\n-      }\n-      finally {\n-        lock.unlock();\n-      }\n-    }\n-  }\n-\n-    /**\n-   * This method compute current consume lags. Get the total lags of all partition and fill in lagMetricsQueue\n-   * @return a Runnbale object to do collect and compute action.\n-   */\n-  private Runnable collectAndComputeLags()\n-  {\n-    return new Runnable() {\n-        @Override\n-        public void run()\n-        {\n-          lock.lock();\n-          try {\n-            if (!spec.isSuspended()) {\n-              LagStats lagStats = supervisor.computeLagStats();\n-              if (lagStats == null) {\n-                lagMetricsQueue.offer(0L);\n-              } else {\n-                long totalLags = lagStats.getTotalLag();\n-                lagMetricsQueue.offer(totalLags > 0 ? totalLags : 0L);\n-              }\n-\n-              log.debug(\"Current lag metric points [%s] for dataSource [%s].\", new ArrayList<>(lagMetricsQueue), dataSource);\n-            } else {\n-              log.debug(\"[%s] supervisor is suspended, skip to collect kafka lags\", dataSource);\n-            }\n-          }\n-          catch (Exception e) {\n-            log.warn(e, \"Error, When collect lags\");\n-          }\n-          finally {\n-            lock.unlock();\n-          }\n-        }\n-    };\n-  }\n-\n-    /**\n-     * This method determines whether to do scale actions based on collected lag points.\n-     * Current algorithm of scale is simple:\n-     *    First of all, compute the proportion of lag points higher/lower than scaleOutThreshold/scaleInThreshold, getting scaleOutThreshold/scaleInThreshold.\n-     *    Secondly, compare scaleOutThreshold/scaleInThreshold with triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency. P.S. Scale out action has higher priority than scale in action.\n-     *    Finaly, if scaleOutThreshold/scaleInThreshold is higher than triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency, scale out/in action would be triggered.\n-     * @param lags the lag metrics of Stream(Kafka/Kinesis)\n-     * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n-     *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n-     *\n-     * @return Integer. target number of tasksCount, -1 means skip scale action.\n-     */\n-  private Integer computeDesireTaskCount(List<Long> lags)\n-  {\n-    // if supervisor is not suspended, ensure required tasks are running\n-    // if suspended, ensure tasks have been requested to gracefully stop\n-    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic. Current collected lags : [%s]\", dataSource, lags);\n-    int beyond = 0;\n-    int within = 0;\n-    int metricsCount = lags.size();\n-    for (Long lag : lags) {\n-      if (lag >= defaultAutoScalerConfig.getScaleOutThreshold()) {\n-        beyond++;\n-      }\n-      if (lag <= defaultAutoScalerConfig.getScaleInThreshold()) {\n-        within++;\n-      }\n-    }\n-    double beyondProportion = beyond * 1.0 / metricsCount;\n-    double withinProportion = within * 1.0 / metricsCount;\n-    log.debug(\"triggerScaleOutThresholdFrequency is [%s] and triggerScaleInThresholdFrequency is [%s] for dataSource [%s].\", defaultAutoScalerConfig.getTriggerScaleOutThresholdFrequency(), defaultAutoScalerConfig.getTriggerScaleInThresholdFrequency(), dataSource);\n-    log.info(\"beyondProportion is [%s] and withinProportion is [%s] for dataSource [%s].\", beyondProportion, withinProportion, dataSource);\n-\n-    int currentActiveTaskCount = supervisor.getActiveTaskGroupsCount();\n-    if (currentActiveTaskCount < 0) {\n-      log.info(\"CurrentActiveTaskCount is lower than 0 ??? skip [%s].\", dataSource);\n-      return -1;\n-    }\n-    int desiredActiveTaskCount;\n-\n-    if (beyondProportion >= defaultAutoScalerConfig.getTriggerScaleOutThresholdFrequency()) {\n-        // Do Scale out\n-      int taskCount = currentActiveTaskCount + defaultAutoScalerConfig.getScaleOutStep();\n-      if (currentActiveTaskCount == defaultAutoScalerConfig.getTaskCountMax()) {\n-        log.info(\"CurrentActiveTaskCount reach task count Max limit, skip to scale out tasks for dataSource [%s].\", dataSource);\n-        return -1;\n-      } else {\n-        desiredActiveTaskCount = Math.min(taskCount, defaultAutoScalerConfig.getTaskCountMax());\n-      }\n-\n-      return desiredActiveTaskCount;\n-    }\n-\n-    if (withinProportion >= defaultAutoScalerConfig.getTriggerScaleInThresholdFrequency()) {\n-      // Do Scale in\n-      int taskCount = currentActiveTaskCount - defaultAutoScalerConfig.getScaleInStep();\n-      if (currentActiveTaskCount == defaultAutoScalerConfig.getTaskCountMin()) {\n-        log.info(\"CurrentActiveTaskCount reach task count Min limit, skip to scale in tasks for dataSource [%s].\", dataSource);\n-        return -1;\n-      } else {\n-        desiredActiveTaskCount = Math.max(taskCount, defaultAutoScalerConfig.getTaskCountMin());\n-      }\n-      log.debug(\"Start to scale in tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n-      return desiredActiveTaskCount;\n-    }\n-\n-    return -1;\n-  }\n-\n-  public DefaultAutoScalerConfig getAutoScalerConfig()\n-  {\n-    return defaultAutoScalerConfig;\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxNjQ3OA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r581916478", "body": "not sure why we are encoding `supervisorId`, its already a constant string from line 56. Not sure why this is needed.", "bodyText": "not sure why we are encoding supervisorId, its already a constant string from line 56. Not sure why this is needed.", "bodyHTML": "<p dir=\"auto\">not sure why we are encoding <code>supervisorId</code>, its already a constant string from line 56. Not sure why this is needed.</p>", "author": "pjain1", "createdAt": "2021-02-24T12:26:31Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DefaultAutoScaler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n+\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.druid.indexing.overlord.supervisor.Supervisor;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorSpec;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.LagStats;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoscaler;\n+import org.apache.druid.indexing.seekablestream.supervisor.SeekableStreamSupervisor;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.emitter.EmittingLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+public class DefaultAutoScaler implements SupervisorTaskAutoscaler\n+{\n+  private static final EmittingLogger log = new EmittingLogger(DefaultAutoScaler.class);\n+  private final String dataSource;\n+  private final CircularFifoQueue<Long> lagMetricsQueue;\n+  private final ScheduledExecutorService lagComputationExec;\n+  private final ScheduledExecutorService allocationExec;\n+  private final SupervisorSpec spec;\n+  private final SeekableStreamSupervisor supervisor;\n+  private final DefaultAutoScalerConfig defaultAutoScalerConfig;\n+\n+  private static ReentrantLock lock = new ReentrantLock(true);\n+\n+\n+  public DefaultAutoScaler(Supervisor supervisor, String dataSource, AutoScalerConfig autoScalerConfig, SupervisorSpec spec)\n+  {\n+    this.defaultAutoScalerConfig = (DefaultAutoScalerConfig) autoScalerConfig;\n+    String supervisorId = StringUtils.format(\"KafkaSupervisor-%s\", dataSource);\n+    this.dataSource = dataSource;\n+    int slots = (int) (defaultAutoScalerConfig.getMetricsCollectionRangeMillis() / defaultAutoScalerConfig.getMetricsCollectionIntervalMillis()) + 1;\n+    log.debug(\" The interval of metrics collection is [%s], [%s] timeRange will collect [%s] data points for dataSource [%s].\", defaultAutoScalerConfig.getMetricsCollectionIntervalMillis(), defaultAutoScalerConfig.getMetricsCollectionRangeMillis(), slots, dataSource);\n+    this.lagMetricsQueue = new CircularFifoQueue<>(slots);\n+    this.allocationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Allocation-%d\");", "originalCommit": "688b9c4b4ff1841477d8139a7c83e54d36ccb986", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjY2NDY4OA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582664688", "bodyText": "no need actually, removed. Thanks.", "author": "zhangyue19921010", "createdAt": "2021-02-25T09:14:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxNjQ3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjkwNzYwMQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582907601", "bodyText": "Sorry. I just found it is necessary to do encoding for supervisorId.\nIf supervisorID itself contains special characters %s like \"dataSource\": \"kafka_transactional_parallelized_indexing_service_test_2ec894f4-3bb4-4909-91ca-8f934e14bc84 %\u0420\u043e\u0441\u0441\u0438\u044f \ud55c\uad6d \u4e2d\u56fd!?\" mentioned in Job 41, It will throw Caused by: java.util.UnknownFormatConversionException: Conversion = &apos;?&apos; exception without encoding(https://travis-ci.com/github/apache/druid/jobs/486176708)\nSo I revert this change here.", "author": "zhangyue19921010", "createdAt": "2021-02-25T15:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxNjQ3OA=="}], "type": "inlineReview", "revised_code": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DefaultAutoScaler.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DefaultAutoScaler.java\ndeleted file mode 100644\nindex 031825a371..0000000000\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DefaultAutoScaler.java\n+++ /dev/null\n", "chunk": "@@ -1,244 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n-\n-import org.apache.commons.collections4.queue.CircularFifoQueue;\n-import org.apache.druid.indexing.overlord.supervisor.Supervisor;\n-import org.apache.druid.indexing.overlord.supervisor.SupervisorSpec;\n-import org.apache.druid.indexing.overlord.supervisor.autoscaler.LagStats;\n-import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoscaler;\n-import org.apache.druid.indexing.seekablestream.supervisor.SeekableStreamSupervisor;\n-import org.apache.druid.java.util.common.StringUtils;\n-import org.apache.druid.java.util.common.concurrent.Execs;\n-import org.apache.druid.java.util.emitter.EmittingLogger;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.ReentrantLock;\n-\n-public class DefaultAutoScaler implements SupervisorTaskAutoscaler\n-{\n-  private static final EmittingLogger log = new EmittingLogger(DefaultAutoScaler.class);\n-  private final String dataSource;\n-  private final CircularFifoQueue<Long> lagMetricsQueue;\n-  private final ScheduledExecutorService lagComputationExec;\n-  private final ScheduledExecutorService allocationExec;\n-  private final SupervisorSpec spec;\n-  private final SeekableStreamSupervisor supervisor;\n-  private final DefaultAutoScalerConfig defaultAutoScalerConfig;\n-\n-  private static ReentrantLock lock = new ReentrantLock(true);\n-\n-\n-  public DefaultAutoScaler(Supervisor supervisor, String dataSource, AutoScalerConfig autoScalerConfig, SupervisorSpec spec)\n-  {\n-    this.defaultAutoScalerConfig = (DefaultAutoScalerConfig) autoScalerConfig;\n-    String supervisorId = StringUtils.format(\"KafkaSupervisor-%s\", dataSource);\n-    this.dataSource = dataSource;\n-    int slots = (int) (defaultAutoScalerConfig.getMetricsCollectionRangeMillis() / defaultAutoScalerConfig.getMetricsCollectionIntervalMillis()) + 1;\n-    log.debug(\" The interval of metrics collection is [%s], [%s] timeRange will collect [%s] data points for dataSource [%s].\", defaultAutoScalerConfig.getMetricsCollectionIntervalMillis(), defaultAutoScalerConfig.getMetricsCollectionRangeMillis(), slots, dataSource);\n-    this.lagMetricsQueue = new CircularFifoQueue<>(slots);\n-    this.allocationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Allocation-%d\");\n-    this.lagComputationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Computation-%d\");\n-    this.spec = spec;\n-    this.supervisor = (SeekableStreamSupervisor) supervisor;\n-  }\n-\n-  @Override\n-  public void start()\n-  {\n-    Callable<Integer> scaleAction = new Callable<Integer>() {\n-        @Override\n-        public Integer call()\n-        {\n-          lock.lock();\n-          int desireTaskCount = -1;\n-          try {\n-            desireTaskCount = computeDesireTaskCount(new ArrayList<>(lagMetricsQueue));\n-\n-            if (desireTaskCount != -1) {\n-              lagMetricsQueue.clear();\n-            }\n-          }\n-          catch (Exception ex) {\n-            log.warn(ex, \"Exception when computeDesireTaskCount [%s]\", dataSource);\n-          }\n-          finally {\n-            lock.unlock();\n-          }\n-          return desireTaskCount;\n-        }\n-    };\n-\n-    log.info(\"enableTaskAutoscaler for datasource [%s]\", dataSource);\n-    log.debug(\"Collect and compute lags at fixed rate of [%s] for dataSource[%s].\", defaultAutoScalerConfig.getMetricsCollectionIntervalMillis(), dataSource);\n-    lagComputationExec.scheduleAtFixedRate(\n-            collectAndComputeLags(),\n-            defaultAutoScalerConfig.getDynamicCheckStartDelayMillis(), // wait for tasks to start up\n-            defaultAutoScalerConfig.getMetricsCollectionIntervalMillis(),\n-            TimeUnit.MILLISECONDS\n-    );\n-    log.debug(\"allocate task at fixed rate of [%s], dataSource [%s].\", defaultAutoScalerConfig.getDynamicCheckPeriod(), dataSource);\n-    allocationExec.scheduleAtFixedRate(\n-            supervisor.buildDynamicAllocationTask(scaleAction),\n-            defaultAutoScalerConfig.getDynamicCheckStartDelayMillis() + defaultAutoScalerConfig.getMetricsCollectionRangeMillis(),\n-            defaultAutoScalerConfig.getDynamicCheckPeriod(),\n-            TimeUnit.MILLISECONDS\n-    );\n-  }\n-\n-  @Override\n-  public void stop()\n-  {\n-    allocationExec.shutdownNow();\n-    lagComputationExec.shutdownNow();\n-  }\n-\n-  @Override\n-  public void reset()\n-  {\n-    // clear queue for kafka lags\n-    if (lagMetricsQueue != null) {\n-      try {\n-        lock.lock();\n-        lagMetricsQueue.clear();\n-      }\n-      catch (Exception e) {\n-        log.warn(e, \"Error,when clear queue in rest action\");\n-      }\n-      finally {\n-        lock.unlock();\n-      }\n-    }\n-  }\n-\n-    /**\n-   * This method compute current consume lags. Get the total lags of all partition and fill in lagMetricsQueue\n-   * @return a Runnbale object to do collect and compute action.\n-   */\n-  private Runnable collectAndComputeLags()\n-  {\n-    return new Runnable() {\n-        @Override\n-        public void run()\n-        {\n-          lock.lock();\n-          try {\n-            if (!spec.isSuspended()) {\n-              LagStats lagStats = supervisor.computeLagStats();\n-              if (lagStats == null) {\n-                lagMetricsQueue.offer(0L);\n-              } else {\n-                long totalLags = lagStats.getTotalLag();\n-                lagMetricsQueue.offer(totalLags > 0 ? totalLags : 0L);\n-              }\n-\n-              log.debug(\"Current lag metric points [%s] for dataSource [%s].\", new ArrayList<>(lagMetricsQueue), dataSource);\n-            } else {\n-              log.debug(\"[%s] supervisor is suspended, skip to collect kafka lags\", dataSource);\n-            }\n-          }\n-          catch (Exception e) {\n-            log.warn(e, \"Error, When collect lags\");\n-          }\n-          finally {\n-            lock.unlock();\n-          }\n-        }\n-    };\n-  }\n-\n-    /**\n-     * This method determines whether to do scale actions based on collected lag points.\n-     * Current algorithm of scale is simple:\n-     *    First of all, compute the proportion of lag points higher/lower than scaleOutThreshold/scaleInThreshold, getting scaleOutThreshold/scaleInThreshold.\n-     *    Secondly, compare scaleOutThreshold/scaleInThreshold with triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency. P.S. Scale out action has higher priority than scale in action.\n-     *    Finaly, if scaleOutThreshold/scaleInThreshold is higher than triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency, scale out/in action would be triggered.\n-     * @param lags the lag metrics of Stream(Kafka/Kinesis)\n-     * @return Boolean flag, do scale action successfully or not. If true , it will take at least 'minTriggerDynamicFrequency' before next 'dynamicAllocatie'.\n-     *         If false, it will do 'dynamicAllocate' again after 'dynamicCheckPeriod'.\n-     *\n-     * @return Integer. target number of tasksCount, -1 means skip scale action.\n-     */\n-  private Integer computeDesireTaskCount(List<Long> lags)\n-  {\n-    // if supervisor is not suspended, ensure required tasks are running\n-    // if suspended, ensure tasks have been requested to gracefully stop\n-    log.info(\"[%s] supervisor is running, start to check dynamic allocate task logic. Current collected lags : [%s]\", dataSource, lags);\n-    int beyond = 0;\n-    int within = 0;\n-    int metricsCount = lags.size();\n-    for (Long lag : lags) {\n-      if (lag >= defaultAutoScalerConfig.getScaleOutThreshold()) {\n-        beyond++;\n-      }\n-      if (lag <= defaultAutoScalerConfig.getScaleInThreshold()) {\n-        within++;\n-      }\n-    }\n-    double beyondProportion = beyond * 1.0 / metricsCount;\n-    double withinProportion = within * 1.0 / metricsCount;\n-    log.debug(\"triggerScaleOutThresholdFrequency is [%s] and triggerScaleInThresholdFrequency is [%s] for dataSource [%s].\", defaultAutoScalerConfig.getTriggerScaleOutThresholdFrequency(), defaultAutoScalerConfig.getTriggerScaleInThresholdFrequency(), dataSource);\n-    log.info(\"beyondProportion is [%s] and withinProportion is [%s] for dataSource [%s].\", beyondProportion, withinProportion, dataSource);\n-\n-    int currentActiveTaskCount = supervisor.getActiveTaskGroupsCount();\n-    if (currentActiveTaskCount < 0) {\n-      log.info(\"CurrentActiveTaskCount is lower than 0 ??? skip [%s].\", dataSource);\n-      return -1;\n-    }\n-    int desiredActiveTaskCount;\n-\n-    if (beyondProportion >= defaultAutoScalerConfig.getTriggerScaleOutThresholdFrequency()) {\n-        // Do Scale out\n-      int taskCount = currentActiveTaskCount + defaultAutoScalerConfig.getScaleOutStep();\n-      if (currentActiveTaskCount == defaultAutoScalerConfig.getTaskCountMax()) {\n-        log.info(\"CurrentActiveTaskCount reach task count Max limit, skip to scale out tasks for dataSource [%s].\", dataSource);\n-        return -1;\n-      } else {\n-        desiredActiveTaskCount = Math.min(taskCount, defaultAutoScalerConfig.getTaskCountMax());\n-      }\n-\n-      return desiredActiveTaskCount;\n-    }\n-\n-    if (withinProportion >= defaultAutoScalerConfig.getTriggerScaleInThresholdFrequency()) {\n-      // Do Scale in\n-      int taskCount = currentActiveTaskCount - defaultAutoScalerConfig.getScaleInStep();\n-      if (currentActiveTaskCount == defaultAutoScalerConfig.getTaskCountMin()) {\n-        log.info(\"CurrentActiveTaskCount reach task count Min limit, skip to scale in tasks for dataSource [%s].\", dataSource);\n-        return -1;\n-      } else {\n-        desiredActiveTaskCount = Math.max(taskCount, defaultAutoScalerConfig.getTaskCountMin());\n-      }\n-      log.debug(\"Start to scale in tasks, current active task number [%s] and desire task number is [%s] for dataSource [%s].\", currentActiveTaskCount, desiredActiveTaskCount, dataSource);\n-      return desiredActiveTaskCount;\n-    }\n-\n-    return -1;\n-  }\n-\n-  public DefaultAutoScalerConfig getAutoScalerConfig()\n-  {\n-    return defaultAutoScalerConfig;\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxNzYzOA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r581917638", "body": "See https://github.com/zhangyue19921010/druid/pull/1/files#diff-943c4b0695e902cb2a3465b69f593a584dac7308037288db0f9fd97054efb12b for suggestions on log lines, method and variable names.", "bodyText": "See https://github.com/zhangyue19921010/druid/pull/1/files#diff-943c4b0695e902cb2a3465b69f593a584dac7308037288db0f9fd97054efb12b for suggestions on log lines, method and variable names.", "bodyHTML": "<p dir=\"auto\">See <a href=\"https://github.com/zhangyue19921010/druid/pull/1/files#diff-943c4b0695e902cb2a3465b69f593a584dac7308037288db0f9fd97054efb12b\">https://github.com/zhangyue19921010/druid/pull/1/files#diff-943c4b0695e902cb2a3465b69f593a584dac7308037288db0f9fd97054efb12b</a> for suggestions on log lines, method and variable names.</p>", "author": "pjain1", "createdAt": "2021-02-24T12:28:14Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DefaultAutoScalerConfig.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import javax.annotation.Nullable;\n+\n+public class DefaultAutoScalerConfig implements AutoScalerConfig", "originalCommit": "688b9c4b4ff1841477d8139a7c83e54d36ccb986", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjY2NDc1NQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582664755", "bodyText": "Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-25T09:14:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxNzYzOA=="}], "type": "inlineReview", "revised_code": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DefaultAutoScalerConfig.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScalerConfig.java\nsimilarity index 60%\nrename from indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DefaultAutoScalerConfig.java\nrename to indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScalerConfig.java\nindex f4169529a4..2651661845 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DefaultAutoScalerConfig.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScalerConfig.java\n", "chunk": "@@ -21,15 +21,19 @@ package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.apache.druid.indexing.overlord.supervisor.Supervisor;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorSpec;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoScaler;\n+import org.apache.druid.indexing.seekablestream.supervisor.SeekableStreamSupervisor;\n \n import javax.annotation.Nullable;\n \n-public class DefaultAutoScalerConfig implements AutoScalerConfig\n+public class LagBasedAutoScalerConfig implements AutoScalerConfig\n {\n-  private final long metricsCollectionIntervalMillis;\n-  private final long metricsCollectionRangeMillis;\n-  private final long dynamicCheckStartDelayMillis;\n-  private final long dynamicCheckPeriod;\n+  private final long lagCollectionIntervalMillis;\n+  private final long lagCollectionRangeMillis;\n+  private final long scaleActionStartDelayMillis;\n+  private final long scaleActionPeriodMillis;\n   private final long scaleOutThreshold;\n   private final long scaleInThreshold;\n   private final double triggerScaleOutThresholdFrequency;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxODAzOQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r581918039", "body": "I think we can call this `NoopAutoScaler`.", "bodyText": "I think we can call this NoopAutoScaler.", "bodyHTML": "<p dir=\"auto\">I think we can call this <code>NoopAutoScaler</code>.</p>", "author": "pjain1", "createdAt": "2021-02-24T12:28:53Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DummyAutoScaler.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n+\n+import org.apache.druid.indexing.overlord.supervisor.Supervisor;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoscaler;\n+\n+public class DummyAutoScaler implements SupervisorTaskAutoscaler", "originalCommit": "688b9c4b4ff1841477d8139a7c83e54d36ccb986", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxODQzNw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r581918437", "bodyText": "https://github.com/zhangyue19921010/druid/pull/1/files#diff-0621db18fa2257d0cd499178c842d96ae73df2264038ccc7de23d7a7ed5235a5", "author": "pjain1", "createdAt": "2021-02-24T12:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxODAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjY2NjA5MQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582666091", "bodyText": "NoopAutoScaler is used for mm autoscale. I just renamed it to NoopTaskAutoScaler :)", "author": "zhangyue19921010", "createdAt": "2021-02-25T09:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxODAzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DummyAutoScaler.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/NoopTaskAutoScaler.java\nsimilarity index 83%\nrename from indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DummyAutoScaler.java\nrename to indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/NoopTaskAutoScaler.java\nindex 2d779e09c3..9bf41e5b0b 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DummyAutoScaler.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/NoopTaskAutoScaler.java\n", "chunk": "@@ -19,12 +19,11 @@\n \n package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n \n-import org.apache.druid.indexing.overlord.supervisor.Supervisor;\n-import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoscaler;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoScaler;\n \n-public class DummyAutoScaler implements SupervisorTaskAutoscaler\n+public class NoopTaskAutoScaler implements SupervisorTaskAutoScaler\n {\n-  public DummyAutoScaler(Supervisor supervisor, String dataSource)\n+  public NoopTaskAutoScaler()\n   {\n   }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxODE4MQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r581918181", "body": "This can be no-arg constructor.", "bodyText": "This can be no-arg constructor.", "bodyHTML": "<p dir=\"auto\">This can be no-arg constructor.</p>", "author": "pjain1", "createdAt": "2021-02-24T12:29:03Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DummyAutoScaler.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n+\n+import org.apache.druid.indexing.overlord.supervisor.Supervisor;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoscaler;\n+\n+public class DummyAutoScaler implements SupervisorTaskAutoscaler\n+{\n+  public DummyAutoScaler(Supervisor supervisor, String dataSource)", "originalCommit": "688b9c4b4ff1841477d8139a7c83e54d36ccb986", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjY2NjE2Nw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582666167", "bodyText": "Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-25T09:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkxODE4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DummyAutoScaler.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/NoopTaskAutoScaler.java\nsimilarity index 83%\nrename from indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DummyAutoScaler.java\nrename to indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/NoopTaskAutoScaler.java\nindex 2d779e09c3..9bf41e5b0b 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/DummyAutoScaler.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/NoopTaskAutoScaler.java\n", "chunk": "@@ -19,12 +19,11 @@\n \n package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n \n-import org.apache.druid.indexing.overlord.supervisor.Supervisor;\n-import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoscaler;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoScaler;\n \n-public class DummyAutoScaler implements SupervisorTaskAutoscaler\n+public class NoopTaskAutoScaler implements SupervisorTaskAutoScaler\n {\n-  public DummyAutoScaler(Supervisor supervisor, String dataSource)\n+  public NoopTaskAutoScaler()\n   {\n   }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkyMDA2MQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r581920061", "body": "```suggestion\r\n  /**\r\n   * Computes maxLag, totalLag and avgLag\r\n   * Only supports Kafka ingestion so far.\r\n   */\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /**\n          \n          \n            \n               * Collect maxLag, totalLag, avgLag\n          \n          \n            \n               * Only support Kafka ingestion so far.\n          \n          \n            \n               */\n          \n          \n            \n              /**\n          \n          \n            \n               * Computes maxLag, totalLag and avgLag\n          \n          \n            \n               * Only supports Kafka ingestion so far.\n          \n          \n            \n               */", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"72\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">  <span class=\"pl-c\"><span class=\"pl-c\">/**</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"73\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-smi x x-first x-last\">Collect</span> maxLag, totalLag<span class=\"x x-first x-last\">,</span> avgLag</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"74\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Only</span> <span class=\"x x-first x-last\">support</span> <span class=\"pl-smi\">Kafka</span> ingestion so far.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"75\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*/</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"72\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  <span class=\"pl-c\"><span class=\"pl-c\">/**</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"73\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-smi x x-first x-last\">Computes</span> maxLag, totalLag<span class=\"x x-first x-last\"> and</span> avgLag</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"74\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Only</span> <span class=\"x x-first x-last\">supports</span> <span class=\"pl-smi\">Kafka</span> ingestion so far.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"75\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*/</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pjain1", "createdAt": "2021-02-24T12:32:07Z", "path": "server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java", "diffHunk": "@@ -64,4 +65,12 @@ default Boolean isHealthy()\n    * @param checkpointMetadata metadata for the sequence to currently checkpoint\n    */\n   void checkpoint(int taskGroupId, DataSourceMetadata checkpointMetadata);\n+\n+  /**\n+   * Collect maxLag, totalLag, avgLag\n+   * Only support Kafka ingestion so far.\n+   */", "originalCommit": "688b9c4b4ff1841477d8139a7c83e54d36ccb986", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjY2NjI4Mw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582666283", "bodyText": "Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-25T09:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkyMDA2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java b/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\nindex b345163b2c..66d11399bd 100644\n--- a/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\n+++ b/server/src/main/java/org/apache/druid/indexing/overlord/supervisor/Supervisor.java\n", "chunk": "@@ -67,8 +67,8 @@ public interface Supervisor\n   void checkpoint(int taskGroupId, DataSourceMetadata checkpointMetadata);\n \n   /**\n-   * Collect maxLag, totalLag, avgLag\n-   * Only support Kafka ingestion so far.\n+   * Computes maxLag, totalLag and avgLag\n+   * Only supports Kafka ingestion so far.\n    */\n   LagStats computeLagStats();\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkyNzIxMA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r581927210", "body": "We can just pass `autoscalerConfig` here and it will be null because if its not null then exception will be thrown at line 96. ", "bodyText": "We can just pass autoscalerConfig here and it will be null because if its not null then exception will be thrown at line 96.", "bodyHTML": "<p dir=\"auto\">We can just pass <code>autoscalerConfig</code> here and it will be null because if its not null then exception will be thrown at line 96.</p>", "author": "pjain1", "createdAt": "2021-02-24T12:43:34Z", "path": "extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java", "diffHunk": "@@ -85,8 +87,16 @@ public KinesisSupervisorIOConfig(\n         completionTimeout,\n         lateMessageRejectionPeriod,\n         earlyMessageRejectionPeriod,\n+        null,", "originalCommit": "688b9c4b4ff1841477d8139a7c83e54d36ccb986", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjY2NjQwOQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582666409", "bodyText": "changed.", "author": "zhangyue19921010", "createdAt": "2021-02-25T09:16:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkyNzIxMA=="}], "type": "inlineReview", "revised_code": {"commit": "00758e647c7137166b3e149607305a54db284dfb", "changed_code": [{"header": "diff --git a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\nindex dac32e5197..b43cece0e5 100644\n--- a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n+++ b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorIOConfig.java\n", "chunk": "@@ -87,14 +89,14 @@ public class KinesisSupervisorIOConfig extends SeekableStreamSupervisorIOConfig\n         completionTimeout,\n         lateMessageRejectionPeriod,\n         earlyMessageRejectionPeriod,\n-        null,\n+        autoScalerConfig,\n         lateMessageRejectionStartDateTime\n     );\n \n     // for now dynamic Allocation Tasks is not supported here\n     // throw UnsupportedOperationException in case someone sets this on a kinesis supervisor spec.\n-    if (autoscalerConfig != null) {\n-      throw new UnsupportedOperationException(\"Tasks auto scaler for kinesis is not supported yet. Please remove autoscalerConfig or set it null!\");\n+    if (autoScalerConfig != null) {\n+      throw new UnsupportedOperationException(\"Tasks auto scaler for kinesis is not supported yet. Please remove autoScalerConfig or set it to null!\");\n     }\n \n     this.endpoint = endpoint != null\n", "next_change": null}]}}, {"oid": "00758e647c7137166b3e149607305a54db284dfb", "url": "https://github.com/apache/druid/commit/00758e647c7137166b3e149607305a54db284dfb", "message": "code review", "committedDate": "2021-02-25T09:10:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjY2OTg2Mg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582669862", "body": "```suggestion\r\n      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\r\n```\r\nprobably you copied the above one by mistake", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n          \n          \n            \n                  log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n          \n      \n    \n    \n  \n\nprobably you copied the above one by mistake", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      log<span class=\"pl-k\">.</span>error(<span class=\"pl-s\"><span class=\"pl-pds x x-first\">\"</span><span class=\"x x-last\">supervisorManager is null in taskMaster, skipping scale action</span> for dataSource [%s].<span class=\"pl-pds\">\"</span></span>, dataSource);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      log<span class=\"pl-k\">.</span>error(<span class=\"x x-first\">e, </span><span class=\"pl-s\"><span class=\"pl-pds x\">\"</span><span class=\"x x-last\">Failed to sync taskCount to MetaStorage</span> for dataSource [%s].<span class=\"pl-pds\">\"</span></span>, dataSource);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">probably you copied the above one by mistake</p>", "author": "pjain1", "createdAt": "2021-02-25T09:21:19Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +323,127 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lag points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      if (autoScalerConfig == null) {\n+        log.warn(\"autoScalerConfig is null but dynamic allocation notice is submitted, how can it be ?\");\n+      } else {\n+        try {\n+          long nowTime = System.currentTimeMillis();\n+          if (spec.isSuspended()) {\n+            log.info(\"Skipping DynamicAllocationTasksNotice execution because [%s] supervisor is suspended\",\n+                    dataSource\n+            );\n+            return;\n+          }\n+          log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s]\", pendingCompletionTaskGroups,\n+                  dataSource\n+          );\n+          for (CopyOnWriteArrayList<TaskGroup> list : pendingCompletionTaskGroups.values()) {\n+            if (!list.isEmpty()) {\n+              log.info(\n+                      \"Skipping DynamicAllocationTasksNotice execution for datasource [%s] because following tasks are pending [%s]\",\n+                      dataSource, pendingCompletionTaskGroups\n+              );\n+              return;\n+            }\n+          }\n+          if (nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerScaleActionFrequencyMillis()) {\n+            log.info(\n+                    \"DynamicAllocationTasksNotice submitted again in [%d] millis, minTriggerDynamicFrequency is [%s] for dataSource [%s], skipping it!\",\n+                    nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerScaleActionFrequencyMillis(), dataSource\n+            );\n+            return;\n+          }\n+          final Integer desriedTaskCount = scaleAction.call();\n+          boolean allocationSuccess = changeTaskCount(desriedTaskCount);\n+          if (allocationSuccess) {\n+            dynamicTriggerLastRunTime = nowTime;\n+          }\n+        }\n+        catch (Exception ex) {\n+          log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method determines how to do scale actions based on collected lag points.\n+   * If scale action is triggered :\n+   *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled in the next 'RunNotice'.\n+   *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\n+   * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\n+   * @param desiredActiveTaskCount desired taskCount computed from AutoScaler\n+   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerScaleActionFrequencyMillis' before next 'changeTaskCount'.\n+   *         If false, it will do 'changeTaskCount' again after 'scaleActionPeriodMillis' millis.\n+   * @throws InterruptedException\n+   * @throws ExecutionException\n+   * @throws TimeoutException\n+   */\n+  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  {\n+    int currentActiveTaskCount;\n+    Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n+    currentActiveTaskCount = activeTaskGroups.size();\n+\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n+      return false;\n+    } else {\n+      log.info(\n+              \"Starting scale action, current active task count is [%d] and desired task count is [%d] for dataSource [%s].\",\n+              currentActiveTaskCount, desiredActiveTaskCount, dataSource\n+      );\n+      gracefulShutdownInternal();\n+      changeTaskCountInIOConfig(desiredActiveTaskCount);\n+      clearAllocationInfo();\n+      log.info(\"Changed taskCount to [%s] for dataSource [%s].\", desiredActiveTaskCount, dataSource);\n+      return true;\n+    }\n+  }\n+\n+  private void changeTaskCountInIOConfig(int desiredActiveTaskCount)\n+  {\n+    ioConfig.setTaskCount(desiredActiveTaskCount);\n+    try {\n+      Optional<SupervisorManager> supervisorManager = taskMaster.getSupervisorManager();\n+      if (supervisorManager.isPresent()) {\n+        MetadataSupervisorManager metadataSupervisorManager = supervisorManager.get().getMetadataSupervisorManager();\n+        metadataSupervisorManager.insert(dataSource, spec);\n+      } else {\n+        log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      }\n+    }\n+    catch (Exception e) {\n+      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);", "originalCommit": "00758e647c7137166b3e149607305a54db284dfb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjkwODA0NA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582908044", "bodyText": "Woooo.. Changed.", "author": "zhangyue19921010", "createdAt": "2021-02-25T15:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjY2OTg2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 1c7a177d6d..7db219b727 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -430,7 +430,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n       }\n     }\n     catch (Exception e) {\n-      log.error(\"supervisorManager is null in taskMaster, skipping scale action for dataSource [%s].\", dataSource);\n+      log.error(e, \"Failed to sync taskCount to MetaStorage for dataSource [%s].\", dataSource);\n     }\n   }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjY3NTYwNw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582675607", "body": "```suggestion\r\n  /**\r\n   * An autoScaler instance will be returned depending on the autoScalerConfig. In case autoScalerConfig is null or autoScaler is disabled then NoopTaskAutoScaler will be returned.\r\n   * @param supervisor\r\n   * @return autoScaler\r\n   */\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /**\n          \n          \n            \n               * need to notice that autoScaler would be null which means autoscale is dissable.\n          \n          \n            \n               * @param supervisor\n          \n          \n            \n               * @return autoScaler, disable autoscale will return dummyAutoScaler and enable autoscale wiil return defaultAutoScaler by default.\n          \n          \n            \n               */\n          \n          \n            \n              /**\n          \n          \n            \n               * An autoScaler instance will be returned depending on the autoScalerConfig. In case autoScalerConfig is null or autoScaler is disabled then NoopTaskAutoScaler will be returned.\n          \n          \n            \n               * @param supervisor\n          \n          \n            \n               * @return autoScaler\n          \n          \n            \n               */", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"161\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">  <span class=\"pl-c\"><span class=\"pl-c\">/**</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"162\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"x x-first\">need to notice that autoScaler would be </span><span class=\"pl-c1 x\">null</span><span class=\"x x-last\"> which means autoscale </span>is <span class=\"x x-first x-last\">dissable</span>.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"163\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> supervisor</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"164\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@return</span> autoScaler<span class=\"x x-first\">, disable autoscale will </span><span class=\"pl-k x\">return</span><span class=\"x\"> dummyAutoScaler and enable autoscale wiil </span><span class=\"pl-k x\">return</span><span class=\"x\"> defaultAutoScaler by </span><span class=\"pl-k x\">default</span><span class=\"x x-last\">.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"165\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*/</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"161\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  <span class=\"pl-c\"><span class=\"pl-c\">/**</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"162\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-smi x x-first\">An</span><span class=\"x\"> autoScaler instance will be returned depending on the autoScalerConfig. </span><span class=\"pl-smi x\">In</span><span class=\"x\"> </span><span class=\"pl-k x\">case</span><span class=\"x x-last\"> autoScalerConfig </span>is <span class=\"pl-c1 x x-first\">null</span><span class=\"x\"> or autoScaler is disabled then </span><span class=\"pl-smi x\">NoopTaskAutoScaler</span><span class=\"x x-last\"> will be returned</span>.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"163\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> supervisor</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"164\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@return</span> autoScaler</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"165\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*/</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pjain1", "createdAt": "2021-02-25T09:29:05Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java", "diffHunk": "@@ -151,6 +154,21 @@ public DruidMonitorSchedulerConfig getMonitorSchedulerConfig()\n   @Override\n   public abstract Supervisor createSupervisor();\n \n+  /**\n+   * need to notice that autoScaler would be null which means autoscale is dissable.\n+   * @param supervisor\n+   * @return autoScaler, disable autoscale will return dummyAutoScaler and enable autoscale wiil return defaultAutoScaler by default.\n+   */", "originalCommit": "00758e647c7137166b3e149607305a54db284dfb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjkwODI2Mw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r582908263", "bodyText": "Done. Thanks for your review!", "author": "zhangyue19921010", "createdAt": "2021-02-25T15:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjY3NTYwNw=="}], "type": "inlineReview", "revised_code": {"commit": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\nindex 638769891c..ff1d31756b 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisorSpec.java\n", "chunk": "@@ -155,9 +155,9 @@ public abstract class SeekableStreamSupervisorSpec implements SupervisorSpec\n   public abstract Supervisor createSupervisor();\n \n   /**\n-   * need to notice that autoScaler would be null which means autoscale is dissable.\n+   * An autoScaler instance will be returned depending on the autoScalerConfig. In case autoScalerConfig is null or autoScaler is disabled then NoopTaskAutoScaler will be returned.\n    * @param supervisor\n-   * @return autoScaler, disable autoscale will return dummyAutoScaler and enable autoscale wiil return defaultAutoScaler by default.\n+   * @return autoScaler\n    */\n   @Override\n   public SupervisorTaskAutoScaler createAutoscaler(Supervisor supervisor)\n", "next_change": null}]}}, {"oid": "1f1008266a0040a74f9bd8c0deffddf923d67d9e", "url": "https://github.com/apache/druid/commit/1f1008266a0040a74f9bd8c0deffddf923d67d9e", "message": "log changed", "committedDate": "2021-02-25T11:21:37Z", "type": "commit"}, {"oid": "6334e2ba0ddf48ddfd884fcdfe9361cee1431e6b", "url": "https://github.com/apache/druid/commit/6334e2ba0ddf48ddfd884fcdfe9361cee1431e6b", "message": "do StringUtils.encodeForFormat when create allocationExec", "committedDate": "2021-02-25T13:13:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2MDcxMQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r585160711", "body": "why shouldn't we expect lagStats.getTotalLag() to return a value >= 0 ?", "bodyText": "why shouldn't we expect lagStats.getTotalLag() to return a value >= 0 ?", "bodyHTML": "<p dir=\"auto\">why shouldn't we expect lagStats.getTotalLag() to return a value &gt;= 0 ?</p>", "author": "himanshug", "createdAt": "2021-03-02T00:43:00Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScaler.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n+\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorSpec;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.LagStats;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoScaler;\n+import org.apache.druid.indexing.seekablestream.supervisor.SeekableStreamSupervisor;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.emitter.EmittingLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+public class LagBasedAutoScaler implements SupervisorTaskAutoScaler\n+{\n+  private static final EmittingLogger log = new EmittingLogger(LagBasedAutoScaler.class);\n+  private final String dataSource;\n+  private final CircularFifoQueue<Long> lagMetricsQueue;\n+  private final ScheduledExecutorService lagComputationExec;\n+  private final ScheduledExecutorService allocationExec;\n+  private final SupervisorSpec spec;\n+  private final SeekableStreamSupervisor supervisor;\n+  private final LagBasedAutoScalerConfig lagBasedAutoScalerConfig;\n+\n+  private static final ReentrantLock LOCK = new ReentrantLock(true);\n+\n+  public LagBasedAutoScaler(SeekableStreamSupervisor supervisor, String dataSource,\n+      LagBasedAutoScalerConfig autoScalerConfig, SupervisorSpec spec\n+  )\n+  {\n+    this.lagBasedAutoScalerConfig = autoScalerConfig;\n+    final String supervisorId = StringUtils.format(\"Supervisor-%s\", dataSource);\n+    this.dataSource = dataSource;\n+    final int slots = (int) (lagBasedAutoScalerConfig.getLagCollectionRangeMillis() / lagBasedAutoScalerConfig\n+        .getLagCollectionIntervalMillis()) + 1;\n+    this.lagMetricsQueue = new CircularFifoQueue<>(slots);\n+    this.allocationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Allocation-%d\");\n+    this.lagComputationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Computation-%d\");\n+    this.spec = spec;\n+    this.supervisor = supervisor;\n+  }\n+\n+  @Override\n+  public void start()\n+  {\n+    Callable<Integer> scaleAction = () -> {\n+      LOCK.lock();\n+      int desiredTaskCount = -1;\n+      try {\n+        desiredTaskCount = computeDesiredTaskCount(new ArrayList<>(lagMetricsQueue));\n+\n+        if (desiredTaskCount != -1) {\n+          lagMetricsQueue.clear();\n+        }\n+      }\n+      catch (Exception ex) {\n+        log.warn(ex, \"Exception while computing desired task count for [%s]\", dataSource);\n+      }\n+      finally {\n+        LOCK.unlock();\n+      }\n+      return desiredTaskCount;\n+    };\n+\n+    lagComputationExec.scheduleAtFixedRate(\n+        computeAndCollectLag(),\n+        lagBasedAutoScalerConfig.getScaleActionStartDelayMillis(), // wait for tasks to start up\n+        lagBasedAutoScalerConfig.getLagCollectionIntervalMillis(),\n+        TimeUnit.MILLISECONDS\n+    );\n+    allocationExec.scheduleAtFixedRate(\n+        supervisor.buildDynamicAllocationTask(scaleAction),\n+        lagBasedAutoScalerConfig.getScaleActionStartDelayMillis() + lagBasedAutoScalerConfig\n+            .getLagCollectionRangeMillis(),\n+        lagBasedAutoScalerConfig.getScaleActionPeriodMillis(),\n+        TimeUnit.MILLISECONDS\n+    );\n+    log.info(\n+        \"LagBasedAutoScaler will collect lag every [%d] millis and will keep [%d] data points for the last [%d] millis for dataSource [%s]\",\n+        lagBasedAutoScalerConfig.getLagCollectionIntervalMillis(), lagMetricsQueue.size(),\n+        lagBasedAutoScalerConfig.getLagCollectionRangeMillis(), dataSource\n+    );\n+  }\n+\n+  @Override\n+  public void stop()\n+  {\n+    allocationExec.shutdownNow();\n+    lagComputationExec.shutdownNow();\n+  }\n+\n+  @Override\n+  public void reset()\n+  {\n+    // clear queue for kafka lags\n+    if (lagMetricsQueue != null) {\n+      try {\n+        LOCK.lock();\n+        lagMetricsQueue.clear();\n+      }\n+      catch (Exception e) {\n+        log.warn(e, \"Error,when clear queue in rest action\");\n+      }\n+      finally {\n+        LOCK.unlock();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method computes current consumer lag. Gets the total lag of all partitions and fill in the lagMetricsQueue\n+   *\n+   * @return a Runnbale object to compute and collect lag.\n+   */\n+  private Runnable computeAndCollectLag()\n+  {\n+    return () -> {\n+      LOCK.lock();\n+      try {\n+        if (!spec.isSuspended()) {\n+          LagStats lagStats = supervisor.computeLagStats();\n+          if (lagStats == null) {\n+            lagMetricsQueue.offer(0L);\n+          } else {\n+            long totalLags = lagStats.getTotalLag();\n+            lagMetricsQueue.offer(totalLags > 0 ? totalLags : 0L);", "originalCommit": "6334e2ba0ddf48ddfd884fcdfe9361cee1431e6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTMyNTY4Nw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r585325687", "bodyText": "Because we can occasionally get negative lags in our practice. Something like https://stackoverflow.com/questions/60847952/how-to-get-rid-of-negative-consumer-lag-in-kafka\nNegative lag values is un-necessary and a poison into our lag metrics. So just filter it here.", "author": "zhangyue19921010", "createdAt": "2021-03-02T07:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2MDcxMQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2MjI3NA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r585162274", "body": "```suggestion\r\n  private int computeDesiredTaskCount(List<Long> lags)\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private Integer computeDesiredTaskCount(List<Long> lags)\n          \n          \n            \n              private int computeDesiredTaskCount(List<Long> lags)", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">  <span class=\"pl-k\">private</span> <span class=\"pl-smi x x-first x-last\">Integer</span> computeDesiredTaskCount(<span class=\"pl-k\">List&lt;<span class=\"pl-smi\">Long</span>&gt;</span> lags)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  <span class=\"pl-k\">private</span> <span class=\"pl-k x x-first x-last\">int</span> computeDesiredTaskCount(<span class=\"pl-k\">List&lt;<span class=\"pl-smi\">Long</span>&gt;</span> lags)</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "himanshug", "createdAt": "2021-03-02T00:47:07Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScaler.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n+\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorSpec;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.LagStats;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoScaler;\n+import org.apache.druid.indexing.seekablestream.supervisor.SeekableStreamSupervisor;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.emitter.EmittingLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+public class LagBasedAutoScaler implements SupervisorTaskAutoScaler\n+{\n+  private static final EmittingLogger log = new EmittingLogger(LagBasedAutoScaler.class);\n+  private final String dataSource;\n+  private final CircularFifoQueue<Long> lagMetricsQueue;\n+  private final ScheduledExecutorService lagComputationExec;\n+  private final ScheduledExecutorService allocationExec;\n+  private final SupervisorSpec spec;\n+  private final SeekableStreamSupervisor supervisor;\n+  private final LagBasedAutoScalerConfig lagBasedAutoScalerConfig;\n+\n+  private static final ReentrantLock LOCK = new ReentrantLock(true);\n+\n+  public LagBasedAutoScaler(SeekableStreamSupervisor supervisor, String dataSource,\n+      LagBasedAutoScalerConfig autoScalerConfig, SupervisorSpec spec\n+  )\n+  {\n+    this.lagBasedAutoScalerConfig = autoScalerConfig;\n+    final String supervisorId = StringUtils.format(\"Supervisor-%s\", dataSource);\n+    this.dataSource = dataSource;\n+    final int slots = (int) (lagBasedAutoScalerConfig.getLagCollectionRangeMillis() / lagBasedAutoScalerConfig\n+        .getLagCollectionIntervalMillis()) + 1;\n+    this.lagMetricsQueue = new CircularFifoQueue<>(slots);\n+    this.allocationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Allocation-%d\");\n+    this.lagComputationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Computation-%d\");\n+    this.spec = spec;\n+    this.supervisor = supervisor;\n+  }\n+\n+  @Override\n+  public void start()\n+  {\n+    Callable<Integer> scaleAction = () -> {\n+      LOCK.lock();\n+      int desiredTaskCount = -1;\n+      try {\n+        desiredTaskCount = computeDesiredTaskCount(new ArrayList<>(lagMetricsQueue));\n+\n+        if (desiredTaskCount != -1) {\n+          lagMetricsQueue.clear();\n+        }\n+      }\n+      catch (Exception ex) {\n+        log.warn(ex, \"Exception while computing desired task count for [%s]\", dataSource);\n+      }\n+      finally {\n+        LOCK.unlock();\n+      }\n+      return desiredTaskCount;\n+    };\n+\n+    lagComputationExec.scheduleAtFixedRate(\n+        computeAndCollectLag(),\n+        lagBasedAutoScalerConfig.getScaleActionStartDelayMillis(), // wait for tasks to start up\n+        lagBasedAutoScalerConfig.getLagCollectionIntervalMillis(),\n+        TimeUnit.MILLISECONDS\n+    );\n+    allocationExec.scheduleAtFixedRate(\n+        supervisor.buildDynamicAllocationTask(scaleAction),\n+        lagBasedAutoScalerConfig.getScaleActionStartDelayMillis() + lagBasedAutoScalerConfig\n+            .getLagCollectionRangeMillis(),\n+        lagBasedAutoScalerConfig.getScaleActionPeriodMillis(),\n+        TimeUnit.MILLISECONDS\n+    );\n+    log.info(\n+        \"LagBasedAutoScaler will collect lag every [%d] millis and will keep [%d] data points for the last [%d] millis for dataSource [%s]\",\n+        lagBasedAutoScalerConfig.getLagCollectionIntervalMillis(), lagMetricsQueue.size(),\n+        lagBasedAutoScalerConfig.getLagCollectionRangeMillis(), dataSource\n+    );\n+  }\n+\n+  @Override\n+  public void stop()\n+  {\n+    allocationExec.shutdownNow();\n+    lagComputationExec.shutdownNow();\n+  }\n+\n+  @Override\n+  public void reset()\n+  {\n+    // clear queue for kafka lags\n+    if (lagMetricsQueue != null) {\n+      try {\n+        LOCK.lock();\n+        lagMetricsQueue.clear();\n+      }\n+      catch (Exception e) {\n+        log.warn(e, \"Error,when clear queue in rest action\");\n+      }\n+      finally {\n+        LOCK.unlock();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method computes current consumer lag. Gets the total lag of all partitions and fill in the lagMetricsQueue\n+   *\n+   * @return a Runnbale object to compute and collect lag.\n+   */\n+  private Runnable computeAndCollectLag()\n+  {\n+    return () -> {\n+      LOCK.lock();\n+      try {\n+        if (!spec.isSuspended()) {\n+          LagStats lagStats = supervisor.computeLagStats();\n+          if (lagStats == null) {\n+            lagMetricsQueue.offer(0L);\n+          } else {\n+            long totalLags = lagStats.getTotalLag();\n+            lagMetricsQueue.offer(totalLags > 0 ? totalLags : 0L);\n+          }\n+          log.debug(\"Current lags [%s] for dataSource [%s].\", new ArrayList<>(lagMetricsQueue), dataSource);\n+        } else {\n+          log.warn(\"[%s] supervisor is suspended, skipping lag collection\", dataSource);\n+        }\n+      }\n+      catch (Exception e) {\n+        log.error(e, \"Error while collecting lags\");\n+      }\n+      finally {\n+        LOCK.unlock();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * This method determines whether to do scale actions based on collected lag points.\n+   * Current algorithm of scale is simple:\n+   * First of all, compute the proportion of lag points higher/lower than scaleOutThreshold/scaleInThreshold, getting scaleOutThreshold/scaleInThreshold.\n+   * Secondly, compare scaleOutThreshold/scaleInThreshold with triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency. P.S. Scale out action has higher priority than scale in action.\n+   * Finaly, if scaleOutThreshold/scaleInThreshold is higher than triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency, scale out/in action would be triggered.\n+   *\n+   * @param lags the lag metrics of Stream(Kafka/Kinesis)\n+   * @return Integer. target number of tasksCount, -1 means skip scale action.\n+   */\n+  private Integer computeDesiredTaskCount(List<Long> lags)", "originalCommit": "6334e2ba0ddf48ddfd884fcdfe9361cee1431e6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTMyNTgwMw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r585325803", "bodyText": "Thanks && changed.", "author": "zhangyue19921010", "createdAt": "2021-03-02T07:40:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2MjI3NA=="}], "type": "inlineReview", "revised_code": {"commit": "22339ddc83976758809570dd1c92d7506c26fcfa", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScaler.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScaler.java\nindex 9a82648a8e..a0fe1af924 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScaler.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScaler.java\n", "chunk": "@@ -167,13 +167,13 @@ public class LagBasedAutoScaler implements SupervisorTaskAutoScaler\n    * This method determines whether to do scale actions based on collected lag points.\n    * Current algorithm of scale is simple:\n    * First of all, compute the proportion of lag points higher/lower than scaleOutThreshold/scaleInThreshold, getting scaleOutThreshold/scaleInThreshold.\n-   * Secondly, compare scaleOutThreshold/scaleInThreshold with triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency. P.S. Scale out action has higher priority than scale in action.\n-   * Finaly, if scaleOutThreshold/scaleInThreshold is higher than triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency, scale out/in action would be triggered.\n+   * Secondly, compare scaleOutThreshold/scaleInThreshold with triggerScaleOutFractionThreshold/triggerScaleInFractionThreshold. P.S. Scale out action has higher priority than scale in action.\n+   * Finaly, if scaleOutThreshold/scaleInThreshold is higher than triggerScaleOutFractionThreshold/triggerScaleInFractionThreshold, scale out/in action would be triggered.\n    *\n    * @param lags the lag metrics of Stream(Kafka/Kinesis)\n    * @return Integer. target number of tasksCount, -1 means skip scale action.\n    */\n-  private Integer computeDesiredTaskCount(List<Long> lags)\n+  private int computeDesiredTaskCount(List<Long> lags)\n   {\n     // if supervisor is not suspended, ensure required tasks are running\n     // if suspended, ensure tasks have been requested to gracefully stop\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2MzU3MA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r585163570", "body": "is it legitimate for `supervisor.getActiveTaskGroupsCount()` to return a negative value? if not, then `supervisor.getActiveTaskGroupsCount()` should always return a value >= 0 and this check shouldn't be needed.", "bodyText": "is it legitimate for supervisor.getActiveTaskGroupsCount() to return a negative value? if not, then supervisor.getActiveTaskGroupsCount() should always return a value >= 0 and this check shouldn't be needed.", "bodyHTML": "<p dir=\"auto\">is it legitimate for <code>supervisor.getActiveTaskGroupsCount()</code> to return a negative value? if not, then <code>supervisor.getActiveTaskGroupsCount()</code> should always return a value &gt;= 0 and this check shouldn't be needed.</p>", "author": "himanshug", "createdAt": "2021-03-02T00:50:15Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScaler.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n+\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorSpec;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.LagStats;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoScaler;\n+import org.apache.druid.indexing.seekablestream.supervisor.SeekableStreamSupervisor;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.emitter.EmittingLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+public class LagBasedAutoScaler implements SupervisorTaskAutoScaler\n+{\n+  private static final EmittingLogger log = new EmittingLogger(LagBasedAutoScaler.class);\n+  private final String dataSource;\n+  private final CircularFifoQueue<Long> lagMetricsQueue;\n+  private final ScheduledExecutorService lagComputationExec;\n+  private final ScheduledExecutorService allocationExec;\n+  private final SupervisorSpec spec;\n+  private final SeekableStreamSupervisor supervisor;\n+  private final LagBasedAutoScalerConfig lagBasedAutoScalerConfig;\n+\n+  private static final ReentrantLock LOCK = new ReentrantLock(true);\n+\n+  public LagBasedAutoScaler(SeekableStreamSupervisor supervisor, String dataSource,\n+      LagBasedAutoScalerConfig autoScalerConfig, SupervisorSpec spec\n+  )\n+  {\n+    this.lagBasedAutoScalerConfig = autoScalerConfig;\n+    final String supervisorId = StringUtils.format(\"Supervisor-%s\", dataSource);\n+    this.dataSource = dataSource;\n+    final int slots = (int) (lagBasedAutoScalerConfig.getLagCollectionRangeMillis() / lagBasedAutoScalerConfig\n+        .getLagCollectionIntervalMillis()) + 1;\n+    this.lagMetricsQueue = new CircularFifoQueue<>(slots);\n+    this.allocationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Allocation-%d\");\n+    this.lagComputationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Computation-%d\");\n+    this.spec = spec;\n+    this.supervisor = supervisor;\n+  }\n+\n+  @Override\n+  public void start()\n+  {\n+    Callable<Integer> scaleAction = () -> {\n+      LOCK.lock();\n+      int desiredTaskCount = -1;\n+      try {\n+        desiredTaskCount = computeDesiredTaskCount(new ArrayList<>(lagMetricsQueue));\n+\n+        if (desiredTaskCount != -1) {\n+          lagMetricsQueue.clear();\n+        }\n+      }\n+      catch (Exception ex) {\n+        log.warn(ex, \"Exception while computing desired task count for [%s]\", dataSource);\n+      }\n+      finally {\n+        LOCK.unlock();\n+      }\n+      return desiredTaskCount;\n+    };\n+\n+    lagComputationExec.scheduleAtFixedRate(\n+        computeAndCollectLag(),\n+        lagBasedAutoScalerConfig.getScaleActionStartDelayMillis(), // wait for tasks to start up\n+        lagBasedAutoScalerConfig.getLagCollectionIntervalMillis(),\n+        TimeUnit.MILLISECONDS\n+    );\n+    allocationExec.scheduleAtFixedRate(\n+        supervisor.buildDynamicAllocationTask(scaleAction),\n+        lagBasedAutoScalerConfig.getScaleActionStartDelayMillis() + lagBasedAutoScalerConfig\n+            .getLagCollectionRangeMillis(),\n+        lagBasedAutoScalerConfig.getScaleActionPeriodMillis(),\n+        TimeUnit.MILLISECONDS\n+    );\n+    log.info(\n+        \"LagBasedAutoScaler will collect lag every [%d] millis and will keep [%d] data points for the last [%d] millis for dataSource [%s]\",\n+        lagBasedAutoScalerConfig.getLagCollectionIntervalMillis(), lagMetricsQueue.size(),\n+        lagBasedAutoScalerConfig.getLagCollectionRangeMillis(), dataSource\n+    );\n+  }\n+\n+  @Override\n+  public void stop()\n+  {\n+    allocationExec.shutdownNow();\n+    lagComputationExec.shutdownNow();\n+  }\n+\n+  @Override\n+  public void reset()\n+  {\n+    // clear queue for kafka lags\n+    if (lagMetricsQueue != null) {\n+      try {\n+        LOCK.lock();\n+        lagMetricsQueue.clear();\n+      }\n+      catch (Exception e) {\n+        log.warn(e, \"Error,when clear queue in rest action\");\n+      }\n+      finally {\n+        LOCK.unlock();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method computes current consumer lag. Gets the total lag of all partitions and fill in the lagMetricsQueue\n+   *\n+   * @return a Runnbale object to compute and collect lag.\n+   */\n+  private Runnable computeAndCollectLag()\n+  {\n+    return () -> {\n+      LOCK.lock();\n+      try {\n+        if (!spec.isSuspended()) {\n+          LagStats lagStats = supervisor.computeLagStats();\n+          if (lagStats == null) {\n+            lagMetricsQueue.offer(0L);\n+          } else {\n+            long totalLags = lagStats.getTotalLag();\n+            lagMetricsQueue.offer(totalLags > 0 ? totalLags : 0L);\n+          }\n+          log.debug(\"Current lags [%s] for dataSource [%s].\", new ArrayList<>(lagMetricsQueue), dataSource);\n+        } else {\n+          log.warn(\"[%s] supervisor is suspended, skipping lag collection\", dataSource);\n+        }\n+      }\n+      catch (Exception e) {\n+        log.error(e, \"Error while collecting lags\");\n+      }\n+      finally {\n+        LOCK.unlock();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * This method determines whether to do scale actions based on collected lag points.\n+   * Current algorithm of scale is simple:\n+   * First of all, compute the proportion of lag points higher/lower than scaleOutThreshold/scaleInThreshold, getting scaleOutThreshold/scaleInThreshold.\n+   * Secondly, compare scaleOutThreshold/scaleInThreshold with triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency. P.S. Scale out action has higher priority than scale in action.\n+   * Finaly, if scaleOutThreshold/scaleInThreshold is higher than triggerScaleOutThresholdFrequency/triggerScaleInThresholdFrequency, scale out/in action would be triggered.\n+   *\n+   * @param lags the lag metrics of Stream(Kafka/Kinesis)\n+   * @return Integer. target number of tasksCount, -1 means skip scale action.\n+   */\n+  private Integer computeDesiredTaskCount(List<Long> lags)\n+  {\n+    // if supervisor is not suspended, ensure required tasks are running\n+    // if suspended, ensure tasks have been requested to gracefully stop\n+    log.debug(\"Computing desired task count for [%s], based on following lags : [%s]\", dataSource, lags);\n+    int beyond = 0;\n+    int within = 0;\n+    int metricsCount = lags.size();\n+    for (Long lag : lags) {\n+      if (lag >= lagBasedAutoScalerConfig.getScaleOutThreshold()) {\n+        beyond++;\n+      }\n+      if (lag <= lagBasedAutoScalerConfig.getScaleInThreshold()) {\n+        within++;\n+      }\n+    }\n+    double beyondProportion = beyond * 1.0 / metricsCount;\n+    double withinProportion = within * 1.0 / metricsCount;\n+\n+    log.debug(\"Calculated beyondProportion is [%s] and withinProportion is [%s] for dataSource [%s].\", beyondProportion,\n+        withinProportion, dataSource\n+    );\n+\n+    int currentActiveTaskCount = supervisor.getActiveTaskGroupsCount();\n+    if (currentActiveTaskCount < 0) {", "originalCommit": "6334e2ba0ddf48ddfd884fcdfe9361cee1431e6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTMyNTk1MA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r585325950", "bodyText": "Thanks && removed.", "author": "zhangyue19921010", "createdAt": "2021-03-02T07:40:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2MzU3MA=="}], "type": "inlineReview", "revised_code": {"commit": "22339ddc83976758809570dd1c92d7506c26fcfa", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScaler.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScaler.java\nindex 9a82648a8e..a0fe1af924 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScaler.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScaler.java\n", "chunk": "@@ -197,29 +197,31 @@ public class LagBasedAutoScaler implements SupervisorTaskAutoScaler\n     );\n \n     int currentActiveTaskCount = supervisor.getActiveTaskGroupsCount();\n-    if (currentActiveTaskCount < 0) {\n-      log.warn(\"CurrentActiveTaskCount is lower than 0 ? skipping computation of desired task count for [%s].\",\n-          dataSource\n-      );\n-      return -1;\n-    }\n     int desiredActiveTaskCount;\n \n-    if (beyondProportion >= lagBasedAutoScalerConfig.getTriggerScaleOutThresholdFrequency()) {\n+    if (beyondProportion >= lagBasedAutoScalerConfig.getTriggerScaleOutFractionThreshold()) {\n       // Do Scale out\n       int taskCount = currentActiveTaskCount + lagBasedAutoScalerConfig.getScaleOutStep();\n-      if (currentActiveTaskCount == lagBasedAutoScalerConfig.getTaskCountMax()) {\n+\n+      int partitionNumbers = supervisor.getPartitionNumbers();\n+      if (partitionNumbers <= 0) {\n+        log.warn(\"Partition number for [%s] <= 0 ? how can it be?\", dataSource);\n+        return -1;\n+      }\n+\n+      int actualTaskCountMax = Math.min(lagBasedAutoScalerConfig.getTaskCountMax(), partitionNumbers);\n+      if (currentActiveTaskCount == actualTaskCountMax) {\n         log.warn(\"CurrentActiveTaskCount reached task count Max limit, skipping scale out action for dataSource [%s].\",\n             dataSource\n         );\n         return -1;\n       } else {\n-        desiredActiveTaskCount = Math.min(taskCount, lagBasedAutoScalerConfig.getTaskCountMax());\n+        desiredActiveTaskCount = Math.min(taskCount, actualTaskCountMax);\n       }\n       return desiredActiveTaskCount;\n     }\n \n-    if (withinProportion >= lagBasedAutoScalerConfig.getTriggerScaleInThresholdFrequency()) {\n+    if (withinProportion >= lagBasedAutoScalerConfig.getTriggerScaleInFractionThreshold()) {\n       // Do Scale in\n       int taskCount = currentActiveTaskCount - lagBasedAutoScalerConfig.getScaleInStep();\n       if (currentActiveTaskCount == lagBasedAutoScalerConfig.getTaskCountMin()) {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2NzA3OQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r585167079", "body": "```suggestion\r\n  private boolean changeTaskCount(int desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n          \n          \n            \n              private boolean changeTaskCount(int desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">  <span class=\"pl-k\">private</span> <span class=\"pl-k\">boolean</span> changeTaskCount(<span class=\"pl-smi x x-first x-last\">Integer</span> desiredActiveTaskCount) throws <span class=\"pl-smi\">InterruptedException</span>, <span class=\"pl-smi\">ExecutionException</span>, <span class=\"pl-smi\">TimeoutException</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  <span class=\"pl-k\">private</span> <span class=\"pl-k\">boolean</span> changeTaskCount(<span class=\"pl-k x x-first x-last\">int</span> desiredActiveTaskCount) throws <span class=\"pl-smi\">InterruptedException</span>, <span class=\"pl-smi\">ExecutionException</span>, <span class=\"pl-smi\">TimeoutException</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "himanshug", "createdAt": "2021-03-02T00:59:17Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +323,127 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lag points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      if (autoScalerConfig == null) {\n+        log.warn(\"autoScalerConfig is null but dynamic allocation notice is submitted, how can it be ?\");\n+      } else {\n+        try {\n+          long nowTime = System.currentTimeMillis();\n+          if (spec.isSuspended()) {\n+            log.info(\"Skipping DynamicAllocationTasksNotice execution because [%s] supervisor is suspended\",\n+                    dataSource\n+            );\n+            return;\n+          }\n+          log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s]\", pendingCompletionTaskGroups,\n+                  dataSource\n+          );\n+          for (CopyOnWriteArrayList<TaskGroup> list : pendingCompletionTaskGroups.values()) {\n+            if (!list.isEmpty()) {\n+              log.info(\n+                      \"Skipping DynamicAllocationTasksNotice execution for datasource [%s] because following tasks are pending [%s]\",\n+                      dataSource, pendingCompletionTaskGroups\n+              );\n+              return;\n+            }\n+          }\n+          if (nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerScaleActionFrequencyMillis()) {\n+            log.info(\n+                    \"DynamicAllocationTasksNotice submitted again in [%d] millis, minTriggerDynamicFrequency is [%s] for dataSource [%s], skipping it!\",\n+                    nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerScaleActionFrequencyMillis(), dataSource\n+            );\n+            return;\n+          }\n+          final Integer desriedTaskCount = scaleAction.call();\n+          boolean allocationSuccess = changeTaskCount(desriedTaskCount);\n+          if (allocationSuccess) {\n+            dynamicTriggerLastRunTime = nowTime;\n+          }\n+        }\n+        catch (Exception ex) {\n+          log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method determines how to do scale actions based on collected lag points.\n+   * If scale action is triggered :\n+   *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled in the next 'RunNotice'.\n+   *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\n+   * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\n+   * @param desiredActiveTaskCount desired taskCount computed from AutoScaler\n+   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerScaleActionFrequencyMillis' before next 'changeTaskCount'.\n+   *         If false, it will do 'changeTaskCount' again after 'scaleActionPeriodMillis' millis.\n+   * @throws InterruptedException\n+   * @throws ExecutionException\n+   * @throws TimeoutException\n+   */\n+  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException", "originalCommit": "6334e2ba0ddf48ddfd884fcdfe9361cee1431e6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTMyNjAxNw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r585326017", "bodyText": "changed.", "author": "zhangyue19921010", "createdAt": "2021-03-02T07:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2NzA3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "22339ddc83976758809570dd1c92d7506c26fcfa", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 7db219b727..468363dcbe 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -396,13 +396,13 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean changeTaskCount(int desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n+    if (desiredActiveTaskCount < 0 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n       log.info(\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2NzI3MQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r585167271", "body": "```suggestion\r\n    if (desiredActiveTaskCount < 0 || desiredActiveTaskCount == currentActiveTaskCount) {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n          \n          \n            \n                if (desiredActiveTaskCount < 0 || desiredActiveTaskCount == currentActiveTaskCount) {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">if</span> (desiredActiveTaskCount <span class=\"pl-k x x-first\">==</span><span class=\"x\"> </span><span class=\"pl-k x\">-</span><span class=\"pl-c1 x x-last\">1</span> <span class=\"pl-k\">||</span> desiredActiveTaskCount <span class=\"pl-k\">==</span> currentActiveTaskCount) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">if</span> (desiredActiveTaskCount <span class=\"pl-k x x-first\">&lt;</span><span class=\"x\"> </span><span class=\"pl-c1 x x-last\">0</span> <span class=\"pl-k\">||</span> desiredActiveTaskCount <span class=\"pl-k\">==</span> currentActiveTaskCount) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "himanshug", "createdAt": "2021-03-02T00:59:40Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -318,6 +323,127 @@ public void handle()\n     }\n   }\n \n+  // change taskCount without resubmitting.\n+  private class DynamicAllocationTasksNotice implements Notice\n+  {\n+    Callable<Integer> scaleAction;\n+\n+    DynamicAllocationTasksNotice(Callable<Integer> scaleAction)\n+    {\n+      this.scaleAction = scaleAction;\n+    }\n+\n+    /**\n+     * This method will do lag points collection and check dynamic scale action is necessary or not.\n+     */\n+    @Override\n+    public void handle()\n+    {\n+      if (autoScalerConfig == null) {\n+        log.warn(\"autoScalerConfig is null but dynamic allocation notice is submitted, how can it be ?\");\n+      } else {\n+        try {\n+          long nowTime = System.currentTimeMillis();\n+          if (spec.isSuspended()) {\n+            log.info(\"Skipping DynamicAllocationTasksNotice execution because [%s] supervisor is suspended\",\n+                    dataSource\n+            );\n+            return;\n+          }\n+          log.debug(\"PendingCompletionTaskGroups is [%s] for dataSource [%s]\", pendingCompletionTaskGroups,\n+                  dataSource\n+          );\n+          for (CopyOnWriteArrayList<TaskGroup> list : pendingCompletionTaskGroups.values()) {\n+            if (!list.isEmpty()) {\n+              log.info(\n+                      \"Skipping DynamicAllocationTasksNotice execution for datasource [%s] because following tasks are pending [%s]\",\n+                      dataSource, pendingCompletionTaskGroups\n+              );\n+              return;\n+            }\n+          }\n+          if (nowTime - dynamicTriggerLastRunTime < autoScalerConfig.getMinTriggerScaleActionFrequencyMillis()) {\n+            log.info(\n+                    \"DynamicAllocationTasksNotice submitted again in [%d] millis, minTriggerDynamicFrequency is [%s] for dataSource [%s], skipping it!\",\n+                    nowTime - dynamicTriggerLastRunTime, autoScalerConfig.getMinTriggerScaleActionFrequencyMillis(), dataSource\n+            );\n+            return;\n+          }\n+          final Integer desriedTaskCount = scaleAction.call();\n+          boolean allocationSuccess = changeTaskCount(desriedTaskCount);\n+          if (allocationSuccess) {\n+            dynamicTriggerLastRunTime = nowTime;\n+          }\n+        }\n+        catch (Exception ex) {\n+          log.warn(ex, \"Error parsing DynamicAllocationTasksNotice\");\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method determines how to do scale actions based on collected lag points.\n+   * If scale action is triggered :\n+   *    First of all, call gracefulShutdownInternal() which will change the state of current datasource ingest tasks from reading to publishing.\n+   *    Secondly, clear all the stateful data structures: activelyReadingTaskGroups, partitionGroups, partitionOffsets, pendingCompletionTaskGroups, partitionIds. These structures will be rebuiled in the next 'RunNotice'.\n+   *    Finally, change the taskCount in SeekableStreamSupervisorIOConfig and sync it to MetadataStorage.\n+   * After the taskCount is changed in SeekableStreamSupervisorIOConfig, next RunNotice will create scaled number of ingest tasks without resubmitting the supervisor.\n+   * @param desiredActiveTaskCount desired taskCount computed from AutoScaler\n+   * @return Boolean flag indicating if scale action was executed or not. If true, it will wait at least 'minTriggerScaleActionFrequencyMillis' before next 'changeTaskCount'.\n+   *         If false, it will do 'changeTaskCount' again after 'scaleActionPeriodMillis' millis.\n+   * @throws InterruptedException\n+   * @throws ExecutionException\n+   * @throws TimeoutException\n+   */\n+  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  {\n+    int currentActiveTaskCount;\n+    Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n+    currentActiveTaskCount = activeTaskGroups.size();\n+\n+    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {", "originalCommit": "6334e2ba0ddf48ddfd884fcdfe9361cee1431e6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTMzMjM4Mg==", "url": "https://github.com/apache/druid/pull/10524#discussion_r585332382", "bodyText": "Thanks && changed.", "author": "zhangyue19921010", "createdAt": "2021-03-02T07:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2NzI3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "22339ddc83976758809570dd1c92d7506c26fcfa", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 7db219b727..468363dcbe 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -396,13 +396,13 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n    * @throws ExecutionException\n    * @throws TimeoutException\n    */\n-  private boolean changeTaskCount(Integer desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n+  private boolean changeTaskCount(int desiredActiveTaskCount) throws InterruptedException, ExecutionException, TimeoutException\n   {\n     int currentActiveTaskCount;\n     Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values();\n     currentActiveTaskCount = activeTaskGroups.size();\n \n-    if (desiredActiveTaskCount == -1 || desiredActiveTaskCount == currentActiveTaskCount) {\n+    if (desiredActiveTaskCount < 0 || desiredActiveTaskCount == currentActiveTaskCount) {\n       return false;\n     } else {\n       log.info(\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2ODk0Ng==", "url": "https://github.com/apache/druid/pull/10524#discussion_r585168946", "body": "not sure why `lagCollectionRangeMillis` was added to `scaleActionStartDelayMillis` .", "bodyText": "not sure why lagCollectionRangeMillis was added to scaleActionStartDelayMillis .", "bodyHTML": "<p dir=\"auto\">not sure why <code>lagCollectionRangeMillis</code> was added to <code>scaleActionStartDelayMillis</code> .</p>", "author": "himanshug", "createdAt": "2021-03-02T01:03:50Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/autoscaler/LagBasedAutoScaler.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.seekablestream.supervisor.autoscaler;\n+\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorSpec;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.LagStats;\n+import org.apache.druid.indexing.overlord.supervisor.autoscaler.SupervisorTaskAutoScaler;\n+import org.apache.druid.indexing.seekablestream.supervisor.SeekableStreamSupervisor;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.emitter.EmittingLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+public class LagBasedAutoScaler implements SupervisorTaskAutoScaler\n+{\n+  private static final EmittingLogger log = new EmittingLogger(LagBasedAutoScaler.class);\n+  private final String dataSource;\n+  private final CircularFifoQueue<Long> lagMetricsQueue;\n+  private final ScheduledExecutorService lagComputationExec;\n+  private final ScheduledExecutorService allocationExec;\n+  private final SupervisorSpec spec;\n+  private final SeekableStreamSupervisor supervisor;\n+  private final LagBasedAutoScalerConfig lagBasedAutoScalerConfig;\n+\n+  private static final ReentrantLock LOCK = new ReentrantLock(true);\n+\n+  public LagBasedAutoScaler(SeekableStreamSupervisor supervisor, String dataSource,\n+      LagBasedAutoScalerConfig autoScalerConfig, SupervisorSpec spec\n+  )\n+  {\n+    this.lagBasedAutoScalerConfig = autoScalerConfig;\n+    final String supervisorId = StringUtils.format(\"Supervisor-%s\", dataSource);\n+    this.dataSource = dataSource;\n+    final int slots = (int) (lagBasedAutoScalerConfig.getLagCollectionRangeMillis() / lagBasedAutoScalerConfig\n+        .getLagCollectionIntervalMillis()) + 1;\n+    this.lagMetricsQueue = new CircularFifoQueue<>(slots);\n+    this.allocationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Allocation-%d\");\n+    this.lagComputationExec = Execs.scheduledSingleThreaded(StringUtils.encodeForFormat(supervisorId) + \"-Computation-%d\");\n+    this.spec = spec;\n+    this.supervisor = supervisor;\n+  }\n+\n+  @Override\n+  public void start()\n+  {\n+    Callable<Integer> scaleAction = () -> {\n+      LOCK.lock();\n+      int desiredTaskCount = -1;\n+      try {\n+        desiredTaskCount = computeDesiredTaskCount(new ArrayList<>(lagMetricsQueue));\n+\n+        if (desiredTaskCount != -1) {\n+          lagMetricsQueue.clear();\n+        }\n+      }\n+      catch (Exception ex) {\n+        log.warn(ex, \"Exception while computing desired task count for [%s]\", dataSource);\n+      }\n+      finally {\n+        LOCK.unlock();\n+      }\n+      return desiredTaskCount;\n+    };\n+\n+    lagComputationExec.scheduleAtFixedRate(\n+        computeAndCollectLag(),\n+        lagBasedAutoScalerConfig.getScaleActionStartDelayMillis(), // wait for tasks to start up\n+        lagBasedAutoScalerConfig.getLagCollectionIntervalMillis(),\n+        TimeUnit.MILLISECONDS\n+    );\n+    allocationExec.scheduleAtFixedRate(\n+        supervisor.buildDynamicAllocationTask(scaleAction),\n+        lagBasedAutoScalerConfig.getScaleActionStartDelayMillis() + lagBasedAutoScalerConfig\n+            .getLagCollectionRangeMillis(),", "originalCommit": "6334e2ba0ddf48ddfd884fcdfe9361cee1431e6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTMyNjA3OQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r585326079", "bodyText": "When scaleActionStartDelayMillis meets, lagComputationExec start to work to collect metrics. And allocationExec need to wait for another lagCollectionRangeMillis which means wait for lagComputationExec to collect enough lag metrics.", "author": "zhangyue19921010", "createdAt": "2021-03-02T07:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2ODk0Ng=="}], "type": "inlineReview", "revised_code": null}, {"oid": "22339ddc83976758809570dd1c92d7506c26fcfa", "url": "https://github.com/apache/druid/commit/22339ddc83976758809570dd1c92d7506c26fcfa", "message": "code review && limit taskCountMax to partitionNumbers", "committedDate": "2021-03-02T06:06:57Z", "type": "commit"}, {"oid": "644e7320ce2f51521b470b022f3406395054bd60", "url": "https://github.com/apache/druid/commit/644e7320ce2f51521b470b022f3406395054bd60", "message": "modify docs", "committedDate": "2021-03-02T07:33:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Nzc5MjYxMw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r587792613", "body": "nit:\r\n```suggestion\r\n  public int getPartitionsCount()\r\n```", "bodyText": "nit:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public int getPartitionNumbers()\n          \n          \n            \n              public int getPartitionsCount()", "bodyHTML": "<p dir=\"auto\">nit:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">  <span class=\"pl-k\">public</span> <span class=\"pl-k\">int</span> <span class=\"x x-first x-last\">getPartitionNumbers</span>()</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  <span class=\"pl-k\">public</span> <span class=\"pl-k\">int</span> <span class=\"x x-first x-last\">getPartitionsCount</span>()</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "himanshug", "createdAt": "2021-03-04T20:10:52Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java", "diffHunk": "@@ -1901,6 +2058,11 @@ protected boolean supportsPartitionExpiration()\n     return false;\n   }\n \n+  public int getPartitionNumbers()", "originalCommit": "644e7320ce2f51521b470b022f3406395054bd60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODAzMzYxMw==", "url": "https://github.com/apache/druid/pull/10524#discussion_r588033613", "bodyText": "Done. Thanks a lot for your review and approval!", "author": "zhangyue19921010", "createdAt": "2021-03-05T04:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Nzc5MjYxMw=="}], "type": "inlineReview", "revised_code": {"commit": "1a9a09d05411476a27de69b0e22e8ddebe0d5f90", "changed_code": [{"header": "diff --git a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\nindex 468363dcbe..11339d4f4a 100644\n--- a/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n+++ b/indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/supervisor/SeekableStreamSupervisor.java\n", "chunk": "@@ -2058,7 +2058,7 @@ public abstract class SeekableStreamSupervisor<PartitionIdType, SequenceOffsetTy\n     return false;\n   }\n \n-  public int getPartitionNumbers()\n+  public int getPartitionCount()\n   {\n     return recordSupplier.getPartitionIds(ioConfig.getStream()).size();\n   }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzkwMzY5NA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r587903694", "body": "Should this be included in toString below?", "bodyText": "Should this be included in toString below?", "bodyHTML": "<p dir=\"auto\">Should this be included in toString below?</p>", "author": "capistrant", "createdAt": "2021-03-04T23:20:56Z", "path": "extensions-core/kafka-indexing-service/src/main/java/org/apache/druid/indexing/kafka/supervisor/KafkaSupervisorIOConfig.java", "diffHunk": "@@ -51,6 +53,7 @@ public KafkaSupervisorIOConfig(\n       @JsonProperty(\"taskCount\") Integer taskCount,\n       @JsonProperty(\"taskDuration\") Period taskDuration,\n       @JsonProperty(\"consumerProperties\") Map<String, Object> consumerProperties,\n+      @Nullable @JsonProperty(\"autoScalerConfig\") AutoScalerConfig autoScalerConfig,", "originalCommit": "644e7320ce2f51521b470b022f3406395054bd60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODAzMTI0NQ==", "url": "https://github.com/apache/druid/pull/10524#discussion_r588031245", "bodyText": "Sure && Done.", "author": "zhangyue19921010", "createdAt": "2021-03-05T04:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzkwMzY5NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzkwNDIwNA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r587904204", "body": "Not sure if UnsupportedOperationException would be better here or if null is fine.", "bodyText": "Not sure if UnsupportedOperationException would be better here or if null is fine.", "bodyHTML": "<p dir=\"auto\">Not sure if UnsupportedOperationException would be better here or if null is fine.</p>", "author": "capistrant", "createdAt": "2021-03-04T23:22:21Z", "path": "extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java", "diffHunk": "@@ -378,6 +379,13 @@ protected boolean useExclusiveStartSequenceNumberForNonFirstSequence()\n     return true;\n   }\n \n+  // not yet supported, will be implemented in the future maybe? need to find a proper way to measure kinesis lag.\n+  @Override\n+  public LagStats computeLagStats()", "originalCommit": "644e7320ce2f51521b470b022f3406395054bd60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODAzMTI2NA==", "url": "https://github.com/apache/druid/pull/10524#discussion_r588031264", "bodyText": "Sure && Done.", "author": "zhangyue19921010", "createdAt": "2021-03-05T04:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzkwNDIwNA=="}], "type": "inlineReview", "revised_code": {"commit": "1a9a09d05411476a27de69b0e22e8ddebe0d5f90", "changed_code": [{"header": "diff --git a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\nindex 6d6bf99fe8..92defd2315 100644\n--- a/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\n+++ b/extensions-core/kinesis-indexing-service/src/main/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisor.java\n", "chunk": "@@ -383,7 +383,7 @@ public class KinesisSupervisor extends SeekableStreamSupervisor<String, String,\n   @Override\n   public LagStats computeLagStats()\n   {\n-    return null;\n+    throw new UnsupportedOperationException(\"Compute Lag Stats is not supported in KinesisSupervisor yet.\");\n   }\n \n   @Override\n", "next_change": null}]}}, {"oid": "1a9a09d05411476a27de69b0e22e8ddebe0d5f90", "url": "https://github.com/apache/druid/commit/1a9a09d05411476a27de69b0e22e8ddebe0d5f90", "message": "code review", "committedDate": "2021-03-05T02:40:11Z", "type": "commit"}]}