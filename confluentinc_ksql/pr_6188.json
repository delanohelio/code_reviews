{"pr_number": 6188, "pr_title": "fix: register correct unwrapped schema", "pr_author": "big-andy-coates", "pr_createdAt": "2020-09-11T19:58:49Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6188", "timeline": [{"oid": "a7f23ff55fd3eba9543bd437ffd594c7d04b8ab5", "url": "https://github.com/confluentinc/ksql/commit/a7f23ff55fd3eba9543bd437ffd594c7d04b8ab5", "message": "fix: register correct unwrapped schema\n\nThis commit fixes several issues and refactors a lot of the serde code around wrapping and unwrapping single values.\n\nThe main issues being fixed are:\n  1. allow each format to define if it supported wrapping and/or unwrapping. (Not possible with current design)\n  2. pass the correct wrapping / unwrapping flags are passed to key vs value formats when creating serde. (bug in code passes same SerdeOptions to key and value).\n  3. register the correct wrapped / unwrapped schema with the SR. (bug in existing code meant registered format is always wrapped).\n\nAt the same time, the way wrapping / unwrapping was handled in the code wasn't great. Formats like `JSON` needed to be able to handle both wrapped and unwrapped schemas and values, depending on whether the user _explicitly_ set wrapping or unwrapping, vs the default behaviour of the format. This commit refactors the code such that the format will always be passed the a consistent schema and the set of serde features the format should use when creating the serde. This simplifies things and paves the way to user-define-serde.", "committedDate": "2020-09-11T19:56:39Z", "type": "commit"}, {"oid": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6", "url": "https://github.com/confluentinc/ksql/commit/8cf7cf11e94cb14801bfc6ba02d040eb5835ded6", "message": "test: historic plans", "committedDate": "2020-09-11T22:10:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5NDQxMQ==", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488094411", "body": "nit: did you mean Java type?\r\n```suggestion\r\n     * Convert the supplied Connect {@code schema} to its corresponding Java type.\r\n```\r\n(same below in `@return`)", "bodyText": "nit: did you mean Java type?\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Convert the supplied Connect {@code schema} to its corresponding SQL type.\n          \n          \n            \n                 * Convert the supplied Connect {@code schema} to its corresponding Java type.\n          \n      \n    \n    \n  \n\n(same below in @return)", "bodyHTML": "<p dir=\"auto\">nit: did you mean Java type?</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Convert</span> the supplied <span class=\"pl-smi\">Connect</span> {<span class=\"pl-k\">@code</span> schema} to its corresponding <span class=\"pl-c1 x x-first x-last\">SQL</span> type.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Convert</span> the supplied <span class=\"pl-smi\">Connect</span> {<span class=\"pl-k\">@code</span> schema} to its corresponding <span class=\"pl-smi x x-first x-last\">Java</span> type.</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">(same below in <code>@return</code>)</p>", "author": "agavra", "createdAt": "2020-09-14T17:13:37Z", "path": "ksqldb-common/src/main/java/io/confluent/ksql/schema/ksql/SchemaConverters.java", "diffHunk": "@@ -123,6 +123,16 @@ private SchemaConverters() {\n     Schema toConnectSchema(SqlType sqlType, String name, String doc);\n   }\n \n+  public interface ConnectToJavaTypeConverter {\n+    /**\n+     * Convert the supplied Connect {@code schema} to its corresponding SQL type.", "originalCommit": "a7f23ff55fd3eba9543bd437ffd594c7d04b8ab5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MDk1OA==", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488270958", "bodyText": "done.", "author": "big-andy-coates", "createdAt": "2020-09-14T22:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5NDQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMTUwNw==", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488101507", "body": "not really part of your change, but I'm wondering why we have both `SerdeFeature` and `SerdeOption`? what's the difference between them? can we javadoc it for the future?", "bodyText": "not really part of your change, but I'm wondering why we have both SerdeFeature and SerdeOption? what's the difference between them? can we javadoc it for the future?", "bodyHTML": "<p dir=\"auto\">not really part of your change, but I'm wondering why we have both <code>SerdeFeature</code> and <code>SerdeOption</code>? what's the difference between them? can we javadoc it for the future?</p>", "author": "agavra", "createdAt": "2020-09-14T17:24:44Z", "path": "ksqldb-common/src/main/java/io/confluent/ksql/serde/EnabledSerdeFeatures.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde;\n+\n+import static io.confluent.ksql.serde.SerdeFeature.UNWRAP_SINGLES;\n+import static io.confluent.ksql.serde.SerdeFeature.WRAP_SINGLES;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.errorprone.annotations.Immutable;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+\n+/**\n+ * Validated set of enabled features\n+ *\n+ * <p>Known to not have conflicting features enabled\n+ */\n+@Immutable\n+public final class EnabledSerdeFeatures {\n+\n+  private final ImmutableSet<SerdeFeature> features;", "originalCommit": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MTg3Ng==", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488271876", "bodyText": "All will become clear once SerdeOption.WRAP_SINGLE_KEYS is added, which will map to SerdeFeature.WRAP_SINGLE the same as SerdeOption.WRAP_SINGLE_VALUES does.", "author": "big-andy-coates", "createdAt": "2020-09-14T22:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMTUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4MzEyNQ==", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488283125", "bodyText": "\ud83d\udca1", "author": "agavra", "createdAt": "2020-09-14T22:56:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMTUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMjY3MA==", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488102670", "body": "why not just `EnabledSerdeFeatures.of(supported)`?", "bodyText": "why not just EnabledSerdeFeatures.of(supported)?", "bodyHTML": "<p dir=\"auto\">why not just <code>EnabledSerdeFeatures.of(supported)</code>?</p>", "author": "agavra", "createdAt": "2020-09-14T17:26:43Z", "path": "ksqldb-examples/src/main/java/io/confluent/ksql/datagen/DataGenProducer.java", "diffHunk": "@@ -160,18 +162,16 @@ private static void produceOne(\n   private Serializer<Struct> getKeySerializer(\n       final ConnectSchema keySchema\n   ) {\n-    final PersistenceSchema schema = PersistenceSchema.from(\n-        keySchema,\n-        keySerializerFactory.format().supportedFeatures().contains(SerdeFeature.UNWRAP_SINGLES)\n-    );\n-\n+    final Set<SerdeFeature> supported = keySerializerFactory.format().supportedFeatures();\n+    final EnabledSerdeFeatures features = supported.contains(SerdeFeature.UNWRAP_SINGLES)", "originalCommit": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3Mzc1Nw==", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488273757", "bodyText": "The code wants to turn on unwrapping, where its supported, which is what it does. The code doesn't want to turn on any other feature the format may support, e.g. wrapping, or any feature added in the future.", "author": "big-andy-coates", "createdAt": "2020-09-14T22:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMjY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwNTM5OQ==", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488105399", "body": "Any reason not to just always add these? it's unlikely that they exist for `STRUCT`, `ARRAY` and `MAP` but technically not impossible (I think)", "bodyText": "Any reason not to just always add these? it's unlikely that they exist for STRUCT, ARRAY and MAP but technically not impossible (I think)", "bodyHTML": "<p dir=\"auto\">Any reason not to just always add these? it's unlikely that they exist for <code>STRUCT</code>, <code>ARRAY</code> and <code>MAP</code> but technically not impossible (I think)</p>", "author": "agavra", "createdAt": "2020-09-14T17:31:35Z", "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/avro/AvroSchemas.java", "diffHunk": "@@ -86,7 +86,12 @@ private static Schema buildAvroCompatibleSchema(\n           return schema;\n         }\n \n-        schemaBuilder = new SchemaBuilder(schema.type());\n+        schemaBuilder = new SchemaBuilder(schema.type())\n+            .name(schema.name());\n+\n+        if (schema.parameters() != null) {\n+          schemaBuilder.parameters(schema.parameters());\n+        }", "originalCommit": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3NDQ5Nw==", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488274497", "bodyText": "I'll take a look.", "author": "big-andy-coates", "createdAt": "2020-09-14T22:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwNTM5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3OTU0Nw==", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488279547", "bodyText": "done.", "author": "big-andy-coates", "createdAt": "2020-09-14T22:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwNTM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEyMTQ5NQ==", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488121495", "body": "it seems a little weird to encapsulate this above (`applySinglesUnwrapping`) but then check for it explicitly here", "bodyText": "it seems a little weird to encapsulate this above (applySinglesUnwrapping) but then check for it explicitly here", "bodyHTML": "<p dir=\"auto\">it seems a little weird to encapsulate this above (<code>applySinglesUnwrapping</code>) but then check for it explicitly here</p>", "author": "agavra", "createdAt": "2020-09-14T18:00:18Z", "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/connect/ConnectFormat.java", "diffHunk": "@@ -65,52 +74,100 @@ public boolean supportsSchemaInference() {\n \n   @Override\n   public List<SimpleColumn> toColumns(final ParsedSchema schema) {\n-    final Schema connectSchema = toKsqlTransformer.apply(toConnectSchema(schema));\n+    Schema connectSchema = toConnectSchema(schema);\n \n-    return connectSchema.fields().stream()\n+    if (connectSchema.type() != Type.STRUCT) {\n+      if (!supportsFeature(SerdeFeature.UNWRAP_SINGLES)) {\n+        throw new KsqlException(\"Schema returned from schema registry is anonymous type, \"\n+            + \"but format \" + name() + \" does not support anonymous types. \"\n+            + \"schema: \" + schema);\n+      }\n+\n+      connectSchema = SerdeUtils.wrapSingle(connectSchema);\n+    }\n+\n+    final Schema rowSchema = toKsqlTransformer.apply(connectSchema);\n+\n+    return rowSchema.fields().stream()\n         .map(ConnectFormat::toColumn)\n         .collect(Collectors.toList());\n   }\n \n   public ParsedSchema toParsedSchema(\n       final List<? extends SimpleColumn> columns,\n-      final SerdeOptions serdeOptions,\n+      final EnabledSerdeFeatures serdeFeatures,\n       final FormatInfo formatInfo\n   ) {\n+    SerdeUtils.throwOnUnsupportedFeatures(serdeFeatures, supportedFeatures());\n+\n     final SchemaBuilder schemaBuilder = SchemaBuilder.struct();\n     columns.forEach(col -> schemaBuilder.field(\n         col.name().text(),\n         SchemaConverters.sqlToConnectConverter().toConnectSchema(col.type()))\n     );\n \n-    final PersistenceSchema persistenceSchema =\n-        buildValuePhysical(schemaBuilder.build(), serdeOptions);\n+    final Schema schema = SerdeUtils.applySinglesUnwrapping(schemaBuilder.build(), serdeFeatures);\n \n-    return fromConnectSchema(persistenceSchema.serializedSchema(), formatInfo);\n+    return fromConnectSchema(schema, formatInfo);\n   }\n \n-  protected abstract Schema toConnectSchema(ParsedSchema schema);\n+  @Override\n+  public Serde<Struct> getSerde(\n+      final PersistenceSchema schema,\n+      final Map<String, String> formatProps,\n+      final KsqlConfig config,\n+      final Supplier<SchemaRegistryClient> srFactory\n+  ) {\n+    SerdeUtils.throwOnUnsupportedFeatures(schema.features(), supportedFeatures());\n \n-  protected abstract ParsedSchema fromConnectSchema(Schema schema, FormatInfo formatInfo);\n+    final ConnectSchema outerSchema = schema.connectSchema();\n+    final ConnectSchema innerSchema = SerdeUtils\n+        .applySinglesUnwrapping(outerSchema, schema.features());\n \n-  private static PersistenceSchema buildValuePhysical(\n-      final Schema valueConnectSchema,\n-      final SerdeOptions serdeOptions\n-  ) {\n-    final boolean singleField = valueConnectSchema.fields().size() == 1;\n+    final Class<?> targetType = SchemaConverters.connectToJavaTypeConverter()\n+        .toJavaType(innerSchema);\n \n-    final boolean unwrapSingle = serdeOptions.valueWrapping()\n-        .map(option -> option == SerdeOption.UNWRAP_SINGLE_VALUES)\n-        .orElse(false);\n+    if (schema.features().enabled(SerdeFeature.UNWRAP_SINGLES)) {", "originalCommit": "8cf7cf11e94cb14801bfc6ba02d040eb5835ded6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3ODI2MA==", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488278260", "bodyText": "Why?  applySinglesUnwrapping(outerSchema) only extracts the inner schema. That's only half the storey. The code still needs to build a serde that can handle the unwrapping, i.e. extracting the value of the single column from the Struct passed to serialize and the reverse for deserialize.", "author": "big-andy-coates", "createdAt": "2020-09-14T22:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEyMTQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4Mjk2Nw==", "url": "https://github.com/confluentinc/ksql/pull/6188#discussion_r488282967", "bodyText": "I feel like if I'm already checking the UNWRAP_SINGLES variable here, i might as well just extract the inner schema there as well. Not a biggie, but now we're checking it in two places and doing a no-op in one of them if it's disabled.", "author": "agavra", "createdAt": "2020-09-14T22:55:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEyMTQ5NQ=="}], "type": "inlineReview"}, {"oid": "7c764c7a29ea096080d2376d4c3e2d8463532d39", "url": "https://github.com/confluentinc/ksql/commit/7c764c7a29ea096080d2376d4c3e2d8463532d39", "message": "chore: almog's requested changes", "committedDate": "2020-09-14T22:45:35Z", "type": "commit"}]}