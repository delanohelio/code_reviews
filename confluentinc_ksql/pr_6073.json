{"pr_number": 6073, "pr_title": "fix: CREATE IF NOT EXISTS does not work at all", "pr_author": "hemantgs", "pr_createdAt": "2020-08-21T15:38:55Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6073", "merge_commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "timeline": [{"oid": "04546cc0c95c82da1233926eed8a7b69e2b10d19", "url": "https://github.com/confluentinc/ksql/commit/04546cc0c95c82da1233926eed8a7b69e2b10d19", "message": "Fix for streams IF NOT EXISTS failing", "committedDate": "2020-09-01T17:30:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxNzc1NQ==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r481317755", "body": "@big-andy-coates @spena \r\nI noticed that `CreateStreamCommand` did not have the boolean flag for ifNotExists set here , I thought if this approach is ok , I will add that too and fail the query if its not set and source exists", "bodyText": "@big-andy-coates @spena\nI noticed that CreateStreamCommand did not have the boolean flag for ifNotExists set here , I thought if this approach is ok , I will add that too and fail the query if its not set and source exists", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/big-andy-coates/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/big-andy-coates\">@big-andy-coates</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spena/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spena\">@spena</a><br>\nI noticed that <code>CreateStreamCommand</code> did not have the boolean flag for ifNotExists set here , I thought if this approach is ok , I will add that too and fail the query if its not set and source exists</p>", "author": "hemantgs", "createdAt": "2020-09-01T17:37:02Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java", "diffHunk": "@@ -75,6 +75,13 @@ public DdlCommandResult executeCreateStream(final CreateStreamCommand createStre\n           withQuery,\n           getKsqlTopic(createStream)\n       );\n+", "originalCommit": "04546cc0c95c82da1233926eed8a7b69e2b10d19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0OTI2MA==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r481349260", "bodyText": "The place to put the check is in the CreateSourceFactory.  You'll need to pass the MetaStore in to the factory's constructor.\nSee DropSourceFactory for an example of the pattern.", "author": "big-andy-coates", "createdAt": "2020-09-01T18:33:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxNzc1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3f58cd7f36ac21a669a065df18216a070b47f92c", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 89d1e2266be..cc22c52acba 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -76,18 +86,21 @@ public class DdlCommandExec {\n           getKsqlTopic(createStream)\n       );\n \n-      if (metaStore.validateSource(ksqlStream, createStream.isOrReplace())) {\n-        return new DdlCommandResult(true, String.format(\n-            \"Cannot add stream '%s': A stream with the same name already exists\",\n-            ksqlStream.getName()\n-        ));\n-      }\n       metaStore.putSource(ksqlStream, createStream.isOrReplace());\n       return new DdlCommandResult(true, \"Stream created\");\n     }\n \n     @Override\n     public DdlCommandResult executeCreateTable(final CreateTableCommand createTable) {\n+      final SourceName sourceName = createTable.getSourceName();\n+      final DataSource dataSource = metaStore.getSource(sourceName);\n+\n+      if (dataSource != null && !createTable.isOrReplace()) {\n+        return new DdlCommandResult(true,\n+            String.format(\"Cannot add table %s: A table with the same name \"\n+                    + \"already exists.\",\n+                sourceName));\n+      }\n       final KsqlTable<?> ksqlTable = new KsqlTable<>(\n           sql,\n           createTable.getSourceName(),\n", "next_change": {"commit": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex cc22c52acba..3ec826835f7 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -105,12 +120,12 @@ public class DdlCommandExec {\n           sql,\n           createTable.getSourceName(),\n           createTable.getSchema(),\n-          createTable.getFormats().getOptions(),\n           createTable.getTimestampColumn(),\n           withQuery,\n           getKsqlTopic(createTable)\n       );\n       metaStore.putSource(ksqlTable, createTable.isOrReplace());\n+      metaStore.addSourceReferences(ksqlTable.getName(), withQuerySources);\n       return new DdlCommandResult(true, \"Table created\");\n     }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 89d1e2266be..94a587fdc2f 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -51,53 +58,76 @@ public class DdlCommandExec {\n   public DdlCommandResult execute(\n       final String sql,\n       final DdlCommand ddlCommand,\n-      final boolean withQuery) {\n-    return new Executor(sql, withQuery).execute(ddlCommand);\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources\n+  ) {\n+    return new Executor(sql, withQuery, withQuerySources).execute(ddlCommand);\n   }\n \n   private final class Executor implements io.confluent.ksql.execution.ddl.commands.Executor {\n     private final String sql;\n     private final boolean withQuery;\n+    private final Set<SourceName> withQuerySources;\n \n-    private Executor(final String sql, final boolean withQuery) {\n+    private Executor(\n+        final String sql,\n+        final boolean withQuery,\n+        final Set<SourceName> withQuerySources\n+    ) {\n       this.sql = Objects.requireNonNull(sql, \"sql\");\n       this.withQuery = withQuery;\n+      this.withQuerySources = Objects.requireNonNull(withQuerySources, \"withQuerySources\");\n     }\n \n     @Override\n     public DdlCommandResult executeCreateStream(final CreateStreamCommand createStream) {\n+      final SourceName sourceName = createStream.getSourceName();\n+      final DataSource dataSource = metaStore.getSource(sourceName);\n+\n+      if (dataSource != null && !createStream.isOrReplace()) {\n+        final String sourceType = dataSource.getDataSourceType().getKsqlType();\n+        return new DdlCommandResult(true,\n+            String.format(\"Cannot add stream %s: A %s with the same name \"\n+                    + \"already exists.\",\n+                sourceName, sourceType.toLowerCase()));\n+      }\n+\n       final KsqlStream<?> ksqlStream = new KsqlStream<>(\n           sql,\n           createStream.getSourceName(),\n           createStream.getSchema(),\n-          createStream.getFormats().getOptions(),\n           createStream.getTimestampColumn(),\n           withQuery,\n           getKsqlTopic(createStream)\n       );\n \n-      if (metaStore.validateSource(ksqlStream, createStream.isOrReplace())) {\n-        return new DdlCommandResult(true, String.format(\n-            \"Cannot add stream '%s': A stream with the same name already exists\",\n-            ksqlStream.getName()\n-        ));\n-      }\n       metaStore.putSource(ksqlStream, createStream.isOrReplace());\n+      metaStore.addSourceReferences(ksqlStream.getName(), withQuerySources);\n       return new DdlCommandResult(true, \"Stream created\");\n     }\n \n     @Override\n     public DdlCommandResult executeCreateTable(final CreateTableCommand createTable) {\n+      final SourceName sourceName = createTable.getSourceName();\n+      final DataSource dataSource = metaStore.getSource(sourceName);\n+\n+      if (dataSource != null && !createTable.isOrReplace()) {\n+        final String sourceType = dataSource.getDataSourceType().getKsqlType();\n+        return new DdlCommandResult(true,\n+            String.format(\"Cannot add table %s: A %s with the same name \"\n+                    + \"already exists.\",\n+                sourceName, sourceType.toLowerCase()));\n+      }\n       final KsqlTable<?> ksqlTable = new KsqlTable<>(\n           sql,\n           createTable.getSourceName(),\n           createTable.getSchema(),\n-          createTable.getFormats().getOptions(),\n           createTable.getTimestampColumn(),\n           withQuery,\n           getKsqlTopic(createTable)\n       );\n       metaStore.putSource(ksqlTable, createTable.isOrReplace());\n+      metaStore.addSourceReferences(ksqlTable.getName(), withQuerySources);\n       return new DdlCommandResult(true, \"Table created\");\n     }\n \n", "next_change": {"commit": "70565f2969df109c6fd4ae6bb7c48c5365c45f9d", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 94a587fdc2f..5b863f6adda 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -118,13 +118,15 @@ public class DdlCommandExec {\n                     + \"already exists.\",\n                 sourceName, sourceType.toLowerCase()));\n       }\n+\n       final KsqlTable<?> ksqlTable = new KsqlTable<>(\n           sql,\n           createTable.getSourceName(),\n           createTable.getSchema(),\n           createTable.getTimestampColumn(),\n           withQuery,\n-          getKsqlTopic(createTable)\n+          getKsqlTopic(createTable),\n+          createTable.isSource()\n       );\n       metaStore.putSource(ksqlTable, createTable.isOrReplace());\n       metaStore.addSourceReferences(ksqlTable.getName(), withQuerySources);\n", "next_change": {"commit": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 5b863f6adda..5cac8a2b6e5 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -126,7 +127,7 @@ public class DdlCommandExec {\n           createTable.getTimestampColumn(),\n           withQuery,\n           getKsqlTopic(createTable),\n-          createTable.isSource()\n+          createTable.getIsSource()\n       );\n       metaStore.putSource(ksqlTable, createTable.isOrReplace());\n       metaStore.addSourceReferences(ksqlTable.getName(), withQuerySources);\n", "next_change": {"commit": "e2c3211c23eac9c92806d013c7ad8e4f1bef7ae7", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 5cac8a2b6e5..259d04e5d88 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -130,7 +130,13 @@ public class DdlCommandExec {\n           createTable.getIsSource()\n       );\n       metaStore.putSource(ksqlTable, createTable.isOrReplace());\n-      metaStore.addSourceReferences(ksqlTable.getName(), withQuerySources);\n+\n+      // Source tables only has a query source reference to itself. We don't need to register\n+      // this source for source tables.\n+      if (!createTable.getIsSource()) {\n+        metaStore.addSourceReferences(ksqlTable.getName(), withQuerySources);\n+      }\n+\n       return new DdlCommandResult(true, \"Table created\");\n     }\n \n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "70565f2969df109c6fd4ae6bb7c48c5365c45f9d", "committedDate": "2021-08-11 16:10:36 -0500", "message": "feat: add CREATE SOURCE TABLE syntax and metadata info (#7945)"}, {"oid": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "committedDate": "2021-08-18 12:27:21 -0700", "message": "feat: add CREATE SOURCE STREAM syntax and metadata info (#8004)"}, {"oid": "e2c3211c23eac9c92806d013c7ad8e4f1bef7ae7", "committedDate": "2021-08-27 22:01:18 -0500", "message": "feat: execute source table query plans (#8061)"}, {"oid": "db070a211b51cfb9ef7138c9b05238ba41798f4b", "committedDate": "2022-02-25 13:58:08 -0600", "message": "fix: restore process fails due to DROP constraints (#8803)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0OTc1OA==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r481349758", "body": "We shouldn't be splitting this into two methods, as this makes it much more likely someone will call `putSource` and inadvertently overwrite a source that they shouldn't.", "bodyText": "We shouldn't be splitting this into two methods, as this makes it much more likely someone will call putSource and inadvertently overwrite a source that they shouldn't.", "bodyHTML": "<p dir=\"auto\">We shouldn't be splitting this into two methods, as this makes it much more likely someone will call <code>putSource</code> and inadvertently overwrite a source that they shouldn't.</p>", "author": "big-andy-coates", "createdAt": "2020-09-01T18:34:33Z", "path": "ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java", "diffHunk": "@@ -77,22 +77,20 @@ public DataSource getSource(final SourceName sourceName) {\n   }\n \n   @Override\n-  public void putSource(final DataSource dataSource, final boolean allowReplace) {\n+  public boolean validateSource(final DataSource dataSource, final boolean allowReplace) {", "originalCommit": "04546cc0c95c82da1233926eed8a7b69e2b10d19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzODQ4Mg==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r482038482", "bodyText": "That's a good point,\nI looked at DropSourceFactory , even there\n if (dataSource == null) {\n      if (!ifExists) {\n        throw new KsqlException(\"Source \" + sourceName.text() + \" does not exist.\");\n      }\n    }\n\nWe throw an Exception which will Fail the command which should not be the outcome right ,\nThe only place I could find other than DdlCommandExec that had capability to pass along a warning was in KsqlResource.handleKsqlStatements()\nwhere if an exception is thrown in MetaStoreImpl we could possibly catch that and throw a warning like\ncatch (final KsqlStatementException e) {\n      LOG.info(\"Processed unsuccessfully: \" + request + \", reason: \" + e.getMessage());\n      Errors.badStatement(\"\",e.getSqlStatement(),new KsqlEntityList(\n          Arrays.asList(new WarningEntity(e.getSqlStatement(),\"Source Exists\"))\n      ));\n\nEven here the first parameter to badStatement() seems it needs to be an empty string , else the msg is printed in the client in red . What do you suggest we do", "author": "hemantgs", "createdAt": "2020-09-02T12:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0OTc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUyNDU0OQ==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r482524549", "bodyText": "We throw an Exception which will Fail the command which should not be the outcome right ,\n\nThat code looks correct to me for dropping a source.  It means if I say DROP TABLE IF EXISTS FOO that it won't throw if FOO doesn't exist, which is what we want.\nAs to where to put this new check - you'll need two changes:\n\n\nas above, put a check in CreateSourceFactory so that it throws an exception if IF NOT EXIST is not present and a source with the same name already exists.  (Following a similar pattern to DropSourceFactory).\n\n\nIn DdlCommandExec.executeCreateStream and executeCreateTable you will need to add a check to see if a source with the same name already exists and isOrReplace() is false, e.g.\n\n\n    @Override\n    public DdlCommandResult executeCreateStream(final CreateStreamCommand createStream) {\n      final SourceName sourceName = createStream.getSourceName();\n      final DataSource existing = metaStore.getSource(sourceName);\n      if (existing != null && !createStream.isOrReplace()) {\n        return new DdlCommandResult(true, \"Stream \" + sourceName + \" does not exist.\");\n      }\n\n      final KsqlStream<?> ksqlStream = new KsqlStream<>(\n          sql,\n          sourceName,\n          createStream.getSchema(),\n          createStream.getFormats().getOptions(),\n          createStream.getTimestampColumn(),\n          withQuery,\n          getKsqlTopic(createStream)\n      );\n      \n      metaStore.putSource(ksqlStream, createStream.isOrReplace());\n      return new DdlCommandResult(true, \"Stream created\");\n    }", "author": "big-andy-coates", "createdAt": "2020-09-02T22:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0OTc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5MTI4Mg==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r483591282", "bodyText": "That code looks correct to me for dropping a source. It means if I say DROP TABLE IF EXISTS FOO that it won't throw if FOO doesn't exist, which is what we want.\n\n@big-andy-coates I always seem to confuse myself with that part :| , so anyway I have made the changes\ni have made changes to KsqlEngineTest.shouldNotThrowWhenExecutingDuplicateStream() and KsqlEngineTest.shouldThrowWhenExecutingDuplicateTable() , these tests were failing when the query plans for both create source queries had different Kafka topics one had FOO(stream name) and other had BAR, before this PR the test would have failed much before getting to the planning phase, so I have made changes to the queries in the tests , I am unsure if that is alright\nAlso build in Jenkins has failed I get 404 when I try to open the link ,\nWhen I try mvn verify I get\n[INFO] [ERROR] Failed to execute goal on project my-first-test-udf: Could not resolve dependencies for project com.acme.ksql.functions:my-first-test-udf:jar:0.1.0-SNAPSHOT: Could not find artifact io.confluent.ksql:ksqldb-udf:jar:6.1.0-SNAPSHOT in confluent (https://packages.confluent.io/maven/) -> [Help 1]\n[INFO] org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal on project my-first-test-udf: Could not resolve dependencies for project com.acme.ksql.functions:my-first-test-udf:jar:0.1.0-SNAPSHOT: Could not find artifact io.confluent.ksql:ksqldb-udf:jar:6.1.0-SNAPSHOT in confluent (https://packages.confluent.io/maven/)\n\nand it fails\nI am a bit unsure as to how to run all the tests", "author": "hemantgs", "createdAt": "2020-09-04T12:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0OTc1OA=="}], "type": "inlineReview", "revised_code": {"commit": "3f58cd7f36ac21a669a065df18216a070b47f92c", "changed_code": [{"header": "diff --git a/ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java b/ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java\nindex 243dcda2d42..1392b5ec95e 100644\n--- a/ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java\n+++ b/ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java\n", "chunk": "@@ -77,20 +77,22 @@ public final class MetaStoreImpl implements MutableMetaStore {\n   }\n \n   @Override\n-  public boolean validateSource(final DataSource dataSource, final boolean allowReplace) {\n+  public void putSource(final DataSource dataSource, final boolean allowReplace) {\n     final SourceInfo existing = dataSources.get(dataSource.getName());\n     if (existing != null && !allowReplace) {\n-      return true;\n+      final SourceName name = dataSource.getName();\n+      final String newType = dataSource.getDataSourceType().getKsqlType().toLowerCase();\n+      final String existingType = existing.source.getDataSourceType().getKsqlType().toLowerCase();\n+\n+      throw new KsqlException(String.format(\n+          \"Cannot add %s '%s': A %s with the same name already exists\",\n+          newType, name.text(), existingType));\n     } else if (existing != null) {\n       existing.source.canUpgradeTo(dataSource).ifPresent(msg -> {\n         throw new KsqlException(\"Cannot REPLACE data source: \" + msg);\n       });\n     }\n-    return false;\n-  }\n \n-  @Override\n-  public void putSource(final DataSource dataSource, final boolean allowReplace) {\n     dataSources.put(dataSource.getName(), new SourceInfo(dataSource));\n   }\n \n", "next_change": {"commit": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "changed_code": [{"header": "diff --git a/ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java b/ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java\nindex 1392b5ec95e..5a0397e27f9 100644\n--- a/ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java\n+++ b/ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java\n", "chunk": "@@ -89,121 +99,110 @@ public final class MetaStoreImpl implements MutableMetaStore {\n           newType, name.text(), existingType));\n     } else if (existing != null) {\n       existing.source.canUpgradeTo(dataSource).ifPresent(msg -> {\n-        throw new KsqlException(\"Cannot REPLACE data source: \" + msg);\n+        throw new KsqlException(\"Cannot upgrade data source: \" + msg);\n       });\n     }\n \n-    dataSources.put(dataSource.getName(), new SourceInfo(dataSource));\n+    // Replace the dataSource if one exists, which may contain changes in the Schema, with\n+    // a copy of the previous source info\n+    dataSources.put(dataSource.getName(),\n+        (existing != null) ? existing.copyWith(dataSource) : new SourceInfo(dataSource));\n   }\n \n   @Override\n   public void deleteSource(final SourceName sourceName) {\n-    synchronized (referentialIntegrityLock) {\n-      dataSources.compute(sourceName, (ignored, source) -> {\n-        if (source == null) {\n+    synchronized (metaStoreLock) {\n+      dataSources.compute(sourceName, (ignored, sourceInfo) -> {\n+        if (sourceInfo == null) {\n           throw new KsqlException(String.format(\"No data source with name %s exists.\",\n               sourceName.text()));\n         }\n \n-        final String sourceForQueriesMessage = source.referentialIntegrity\n-            .getSourceForQueries()\n-            .stream()\n-            .collect(Collectors.joining(\", \"));\n-\n-        final String sinkForQueriesMessage = source.referentialIntegrity\n-            .getSinkForQueries()\n-            .stream()\n-            .collect(Collectors.joining(\", \"));\n-\n-        if (!sourceForQueriesMessage.isEmpty() || !sinkForQueriesMessage.isEmpty()) {\n-          throw new KsqlReferentialIntegrityException(\n-              String.format(\"Cannot drop %s.%n\"\n-                      + \"The following queries read from this source: [%s].%n\"\n-                      + \"The following queries write into this source: [%s].%n\"\n-                      + \"You need to terminate them before dropping %s.\",\n-                  sourceName.toString(FormatOptions.noEscape()),\n-                  sourceForQueriesMessage,\n-                  sinkForQueriesMessage,\n-                  sourceName.toString(FormatOptions.noEscape())));\n+        if (dropConstraints.containsKey(sourceName)) {\n+          throw new KsqlReferentialIntegrityException(String.format(\n+              \"Cannot drop %s.%n\"\n+                  + \"The following streams and/or tables read from this source: [%s].%n\"\n+                  + \"You need to drop them before dropping %s.\",\n+              sourceName.text(),\n+              dropConstraints.get(sourceName).stream().map(SourceName::text)\n+                  .sorted().collect(Collectors.joining(\", \")),\n+              sourceName.text()\n+          ));\n         }\n \n+        // Remove drop constraints from the referenced sources\n+        sourceInfo.references.stream().forEach(ref -> dropConstraint(ref, sourceName));\n+\n         return null;\n       });\n     }\n   }\n \n   @Override\n-  public Map<SourceName, DataSource> getAllDataSources() {\n-    return dataSources\n-        .entrySet()\n-        .stream()\n-        .collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().source));\n-  }\n-\n-  @Override\n-  public void updateForPersistentQuery(\n-      final String queryId,\n-      final Set<SourceName> sourceNames,\n-      final Set<SourceName> sinkNames\n+  public void addSourceReferences(\n+      final SourceName sourceName,\n+      final Set<SourceName> sourceReferences\n   ) {\n-    synchronized (referentialIntegrityLock) {\n-      final String sourceAlreadyRegistered = streamSources(sourceNames)\n-          .filter(source -> source.referentialIntegrity.getSourceForQueries().contains(queryId))\n-          .map(source -> source.source.getName())\n-          .map(Object::toString)\n-          .collect(Collectors.joining(\",\"));\n-\n-      final String sinkAlreadyRegistered = streamSources(sinkNames)\n-          .filter(source -> source.referentialIntegrity.getSinkForQueries().contains(queryId))\n-          .map(source -> source.source.getName())\n-          .map(Object::toString)\n-          .collect(Collectors.joining(\",\"));\n-\n-      if (!sourceAlreadyRegistered.isEmpty() || !sinkAlreadyRegistered.isEmpty()) {\n-        throw new KsqlException(\"query already registered.\"\n-            + \" queryId: \" + queryId\n-            + \", registeredAgainstSource: \" + sourceAlreadyRegistered\n-            + \", registeredAgainstSink: \" + sinkAlreadyRegistered);\n+    synchronized (metaStoreLock) {\n+      if (sourceReferences.contains(sourceName)) {\n+        throw new KsqlException(String.format(\"Source name '%s' should not be referenced itself.\",\n+            sourceName.text()));\n       }\n \n-      streamSources(sourceNames)\n-          .forEach(source -> source.referentialIntegrity.addSourceForQueries(queryId));\n-      streamSources(sinkNames)\n-          .forEach(source -> source.referentialIntegrity.addSinkForQueries(queryId));\n-    }\n-  }\n+      Iterables.concat(Collections.singleton(sourceName), sourceReferences).forEach(name -> {\n+        if (!dataSources.containsKey(name)) {\n+          throw new KsqlException(\n+              String.format(\"No data source with name '%s' exists.\", name.text())\n+          );\n+        }\n+      });\n \n-  @Override\n-  public void removePersistentQuery(final String queryId) {\n-    synchronized (referentialIntegrityLock) {\n-      for (final SourceInfo sourceInfo : dataSources.values()) {\n-        sourceInfo.referentialIntegrity.removeQuery(queryId);\n-      }\n+      // add a constraint to the referenced sources to prevent deleting them\n+      sourceReferences.forEach(s -> addConstraint(s, sourceName));\n+\n+      // add all references to the source\n+      dataSources.get(sourceName).references.addAll(sourceReferences);\n     }\n   }\n \n-  @Override\n-  public Set<String> getQueriesWithSource(final SourceName sourceName) {\n+  Set<SourceName> getSourceReferences(final SourceName sourceName) {\n     final SourceInfo sourceInfo = dataSources.get(sourceName);\n     if (sourceInfo == null) {\n       return Collections.emptySet();\n     }\n-    return sourceInfo.referentialIntegrity.getSourceForQueries();\n+\n+    return sourceInfo.references;\n+  }\n+\n+  private void addConstraint(final SourceName source, final SourceName sourceWithReference) {\n+    dropConstraints.computeIfAbsent(source, x -> ConcurrentHashMap.newKeySet())\n+        .add(sourceWithReference);\n+  }\n+\n+  private void dropConstraint(final SourceName source, final SourceName sourceWithReference) {\n+    dropConstraints.computeIfPresent(source, (k , info) -> {\n+      info.remove(sourceWithReference);\n+      return (info.isEmpty()) ? null : info;\n+    });\n   }\n \n   @Override\n-  public Set<String> getQueriesWithSink(final SourceName sourceName) {\n-    final SourceInfo sourceInfo = dataSources.get(sourceName);\n-    if (sourceInfo == null) {\n-      return Collections.emptySet();\n-    }\n-    return sourceInfo.referentialIntegrity.getSinkForQueries();\n+  public Set<SourceName> getSourceConstraints(final SourceName sourceName) {\n+    return dropConstraints.getOrDefault(sourceName, Collections.emptySet());\n+  }\n+\n+  @Override\n+  public Map<SourceName, DataSource> getAllDataSources() {\n+    return dataSources\n+        .entrySet()\n+        .stream()\n+        .collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().source));\n   }\n \n   @Override\n   public MutableMetaStore copy() {\n-    synchronized (referentialIntegrityLock) {\n-      return new MetaStoreImpl(dataSources, functionRegistry, typeRegistry);\n+    synchronized (metaStoreLock) {\n+      return new MetaStoreImpl(dataSources, functionRegistry, typeRegistry, dropConstraints);\n     }\n   }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java b/ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java\nindex 243dcda2d42..5a0397e27f9 100644\n--- a/ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java\n+++ b/ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java\n", "chunk": "@@ -77,131 +87,122 @@ public final class MetaStoreImpl implements MutableMetaStore {\n   }\n \n   @Override\n-  public boolean validateSource(final DataSource dataSource, final boolean allowReplace) {\n+  public void putSource(final DataSource dataSource, final boolean allowReplace) {\n     final SourceInfo existing = dataSources.get(dataSource.getName());\n     if (existing != null && !allowReplace) {\n-      return true;\n+      final SourceName name = dataSource.getName();\n+      final String newType = dataSource.getDataSourceType().getKsqlType().toLowerCase();\n+      final String existingType = existing.source.getDataSourceType().getKsqlType().toLowerCase();\n+\n+      throw new KsqlException(String.format(\n+          \"Cannot add %s '%s': A %s with the same name already exists\",\n+          newType, name.text(), existingType));\n     } else if (existing != null) {\n       existing.source.canUpgradeTo(dataSource).ifPresent(msg -> {\n-        throw new KsqlException(\"Cannot REPLACE data source: \" + msg);\n+        throw new KsqlException(\"Cannot upgrade data source: \" + msg);\n       });\n     }\n-    return false;\n-  }\n \n-  @Override\n-  public void putSource(final DataSource dataSource, final boolean allowReplace) {\n-    dataSources.put(dataSource.getName(), new SourceInfo(dataSource));\n+    // Replace the dataSource if one exists, which may contain changes in the Schema, with\n+    // a copy of the previous source info\n+    dataSources.put(dataSource.getName(),\n+        (existing != null) ? existing.copyWith(dataSource) : new SourceInfo(dataSource));\n   }\n \n   @Override\n   public void deleteSource(final SourceName sourceName) {\n-    synchronized (referentialIntegrityLock) {\n-      dataSources.compute(sourceName, (ignored, source) -> {\n-        if (source == null) {\n+    synchronized (metaStoreLock) {\n+      dataSources.compute(sourceName, (ignored, sourceInfo) -> {\n+        if (sourceInfo == null) {\n           throw new KsqlException(String.format(\"No data source with name %s exists.\",\n               sourceName.text()));\n         }\n \n-        final String sourceForQueriesMessage = source.referentialIntegrity\n-            .getSourceForQueries()\n-            .stream()\n-            .collect(Collectors.joining(\", \"));\n-\n-        final String sinkForQueriesMessage = source.referentialIntegrity\n-            .getSinkForQueries()\n-            .stream()\n-            .collect(Collectors.joining(\", \"));\n-\n-        if (!sourceForQueriesMessage.isEmpty() || !sinkForQueriesMessage.isEmpty()) {\n-          throw new KsqlReferentialIntegrityException(\n-              String.format(\"Cannot drop %s.%n\"\n-                      + \"The following queries read from this source: [%s].%n\"\n-                      + \"The following queries write into this source: [%s].%n\"\n-                      + \"You need to terminate them before dropping %s.\",\n-                  sourceName.toString(FormatOptions.noEscape()),\n-                  sourceForQueriesMessage,\n-                  sinkForQueriesMessage,\n-                  sourceName.toString(FormatOptions.noEscape())));\n+        if (dropConstraints.containsKey(sourceName)) {\n+          throw new KsqlReferentialIntegrityException(String.format(\n+              \"Cannot drop %s.%n\"\n+                  + \"The following streams and/or tables read from this source: [%s].%n\"\n+                  + \"You need to drop them before dropping %s.\",\n+              sourceName.text(),\n+              dropConstraints.get(sourceName).stream().map(SourceName::text)\n+                  .sorted().collect(Collectors.joining(\", \")),\n+              sourceName.text()\n+          ));\n         }\n \n+        // Remove drop constraints from the referenced sources\n+        sourceInfo.references.stream().forEach(ref -> dropConstraint(ref, sourceName));\n+\n         return null;\n       });\n     }\n   }\n \n   @Override\n-  public Map<SourceName, DataSource> getAllDataSources() {\n-    return dataSources\n-        .entrySet()\n-        .stream()\n-        .collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().source));\n-  }\n-\n-  @Override\n-  public void updateForPersistentQuery(\n-      final String queryId,\n-      final Set<SourceName> sourceNames,\n-      final Set<SourceName> sinkNames\n+  public void addSourceReferences(\n+      final SourceName sourceName,\n+      final Set<SourceName> sourceReferences\n   ) {\n-    synchronized (referentialIntegrityLock) {\n-      final String sourceAlreadyRegistered = streamSources(sourceNames)\n-          .filter(source -> source.referentialIntegrity.getSourceForQueries().contains(queryId))\n-          .map(source -> source.source.getName())\n-          .map(Object::toString)\n-          .collect(Collectors.joining(\",\"));\n-\n-      final String sinkAlreadyRegistered = streamSources(sinkNames)\n-          .filter(source -> source.referentialIntegrity.getSinkForQueries().contains(queryId))\n-          .map(source -> source.source.getName())\n-          .map(Object::toString)\n-          .collect(Collectors.joining(\",\"));\n-\n-      if (!sourceAlreadyRegistered.isEmpty() || !sinkAlreadyRegistered.isEmpty()) {\n-        throw new KsqlException(\"query already registered.\"\n-            + \" queryId: \" + queryId\n-            + \", registeredAgainstSource: \" + sourceAlreadyRegistered\n-            + \", registeredAgainstSink: \" + sinkAlreadyRegistered);\n+    synchronized (metaStoreLock) {\n+      if (sourceReferences.contains(sourceName)) {\n+        throw new KsqlException(String.format(\"Source name '%s' should not be referenced itself.\",\n+            sourceName.text()));\n       }\n \n-      streamSources(sourceNames)\n-          .forEach(source -> source.referentialIntegrity.addSourceForQueries(queryId));\n-      streamSources(sinkNames)\n-          .forEach(source -> source.referentialIntegrity.addSinkForQueries(queryId));\n-    }\n-  }\n+      Iterables.concat(Collections.singleton(sourceName), sourceReferences).forEach(name -> {\n+        if (!dataSources.containsKey(name)) {\n+          throw new KsqlException(\n+              String.format(\"No data source with name '%s' exists.\", name.text())\n+          );\n+        }\n+      });\n \n-  @Override\n-  public void removePersistentQuery(final String queryId) {\n-    synchronized (referentialIntegrityLock) {\n-      for (final SourceInfo sourceInfo : dataSources.values()) {\n-        sourceInfo.referentialIntegrity.removeQuery(queryId);\n-      }\n+      // add a constraint to the referenced sources to prevent deleting them\n+      sourceReferences.forEach(s -> addConstraint(s, sourceName));\n+\n+      // add all references to the source\n+      dataSources.get(sourceName).references.addAll(sourceReferences);\n     }\n   }\n \n-  @Override\n-  public Set<String> getQueriesWithSource(final SourceName sourceName) {\n+  Set<SourceName> getSourceReferences(final SourceName sourceName) {\n     final SourceInfo sourceInfo = dataSources.get(sourceName);\n     if (sourceInfo == null) {\n       return Collections.emptySet();\n     }\n-    return sourceInfo.referentialIntegrity.getSourceForQueries();\n+\n+    return sourceInfo.references;\n+  }\n+\n+  private void addConstraint(final SourceName source, final SourceName sourceWithReference) {\n+    dropConstraints.computeIfAbsent(source, x -> ConcurrentHashMap.newKeySet())\n+        .add(sourceWithReference);\n+  }\n+\n+  private void dropConstraint(final SourceName source, final SourceName sourceWithReference) {\n+    dropConstraints.computeIfPresent(source, (k , info) -> {\n+      info.remove(sourceWithReference);\n+      return (info.isEmpty()) ? null : info;\n+    });\n   }\n \n   @Override\n-  public Set<String> getQueriesWithSink(final SourceName sourceName) {\n-    final SourceInfo sourceInfo = dataSources.get(sourceName);\n-    if (sourceInfo == null) {\n-      return Collections.emptySet();\n-    }\n-    return sourceInfo.referentialIntegrity.getSinkForQueries();\n+  public Set<SourceName> getSourceConstraints(final SourceName sourceName) {\n+    return dropConstraints.getOrDefault(sourceName, Collections.emptySet());\n+  }\n+\n+  @Override\n+  public Map<SourceName, DataSource> getAllDataSources() {\n+    return dataSources\n+        .entrySet()\n+        .stream()\n+        .collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().source));\n   }\n \n   @Override\n   public MutableMetaStore copy() {\n-    synchronized (referentialIntegrityLock) {\n-      return new MetaStoreImpl(dataSources, functionRegistry, typeRegistry);\n+    synchronized (metaStoreLock) {\n+      return new MetaStoreImpl(dataSources, functionRegistry, typeRegistry, dropConstraints);\n     }\n   }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "96645b5f9cacf599326fd65e1fce7b5594309d3a", "committedDate": "2020-12-16 16:04:39 -0800", "message": "chore: improve error messages on invalid GROUP BYs (#6790)"}, {"oid": "972f1e3650dac9d3fc3a58203f14bb6c334c1d87", "committedDate": "2021-02-17 11:56:10 -0800", "message": "refactor: use SqlArgument wrapper to look up functions (#7011)"}, {"oid": "db070a211b51cfb9ef7138c9b05238ba41798f4b", "committedDate": "2022-02-25 13:58:08 -0600", "message": "fix: restore process fails due to DROP constraints (#8803)"}, {"oid": "02899ff6e2f4ce61a910c992f59108c8a9f3e748", "committedDate": "2022-08-02 14:46:03 -0400", "message": "feat: UDAFs with multiple/variadic args (#9361)"}, {"oid": "173a2ca4c74d5f35b3abca7bc6e8e5b1f654d50a", "committedDate": "2022-09-16 11:01:13 +0200", "message": "fix-9243: improving error messages (#9531)"}, {"oid": "b0205ac1037c092a7a759bcdb90fa7c84e428822", "committedDate": "2022-09-22 11:42:50 +0200", "message": "fix: enhance error messages when source has extra/lacks double quotes (#9573)"}]}, {"oid": "3f58cd7f36ac21a669a065df18216a070b47f92c", "url": "https://github.com/confluentinc/ksql/commit/3f58cd7f36ac21a669a065df18216a070b47f92c", "message": "Fix for streams IF NOT EXISTS failing\n\nChanges reverted and added to CommandFactories\n\nFixed and added tests\n\nFixed and added tests", "committedDate": "2020-09-03T07:48:05Z", "type": "forcePushed"}, {"oid": "2559b8c8fd3072aa00c9b9808ef6b88fd41497c6", "url": "https://github.com/confluentinc/ksql/commit/2559b8c8fd3072aa00c9b9808ef6b88fd41497c6", "message": "Fix for streams IF NOT EXISTS failing\n\nChanges reverted and added to CommandFactories\n\nFixed and added tests\n\nFixed and added tests\n\nFixed tests", "committedDate": "2020-09-03T14:56:11Z", "type": "forcePushed"}, {"oid": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "url": "https://github.com/confluentinc/ksql/commit/fa376379e975aebdaa414b59d5f8ebd7616cb433", "message": "Fixed tests", "committedDate": "2020-09-04T10:59:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2MjQyNg==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r486962426", "body": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state. i.e. use `requireNonNull`.", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state. i.e. use requireNonNull.", "bodyHTML": "<p dir=\"auto\">nit: validate params that will be stored in object state; ensuring object does not get into an invalid state. i.e. use <code>requireNonNull</code>.</p>", "author": "big-andy-coates", "createdAt": "2020-09-11T10:41:26Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java", "diffHunk": "@@ -68,20 +72,32 @@ public CreateSourceFactory(final ServiceContext serviceContext) {\n       final ServiceContext serviceContext,\n       final SerdeOptionsSupplier serdeOptionsSupplier,\n       final KeySerdeFactory keySerdeFactory,\n-      final ValueSerdeFactory valueSerdeFactory\n+      final ValueSerdeFactory valueSerdeFactory,\n+      final MetaStore metaStore\n   ) {\n     this.serviceContext = Objects.requireNonNull(serviceContext, \"serviceContext\");\n     this.serdeOptionsSupplier =\n         Objects.requireNonNull(serdeOptionsSupplier, \"serdeOptionsSupplier\");\n     this.keySerdeFactory = Objects.requireNonNull(keySerdeFactory, \"keySerdeFactory\");\n     this.valueSerdeFactory = Objects.requireNonNull(valueSerdeFactory, \"valueSerdeFactory\");\n+    this.metaStore = metaStore;", "originalCommit": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQzNjYzMg==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r495436632", "bodyText": "this is done", "author": "hemantgs", "createdAt": "2020-09-26T09:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2MjQyNg=="}], "type": "inlineReview", "revised_code": {"commit": "678163151432e1e935c4acbb426f41b75b22b488", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 50d0ca3b228..e9fa1737d27 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -80,7 +82,7 @@ public final class CreateSourceFactory {\n         Objects.requireNonNull(serdeOptionsSupplier, \"serdeOptionsSupplier\");\n     this.keySerdeFactory = Objects.requireNonNull(keySerdeFactory, \"keySerdeFactory\");\n     this.valueSerdeFactory = Objects.requireNonNull(valueSerdeFactory, \"valueSerdeFactory\");\n-    this.metaStore = metaStore;\n+    this.metaStore = Objects.requireNonNull(metaStore);\n   }\n \n   public CreateStreamCommand createStreamCommand(\n", "next_change": {"commit": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex e9fa1737d27..b7e4f0450d5 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -72,17 +75,20 @@ public final class CreateSourceFactory {\n   @VisibleForTesting\n   CreateSourceFactory(\n       final ServiceContext serviceContext,\n-      final SerdeOptionsSupplier serdeOptionsSupplier,\n+      final SerdeFeaturessSupplier keySerdeFeaturesSupplier,\n+      final SerdeFeaturessSupplier valueSerdeFeaturesSupplier,\n       final KeySerdeFactory keySerdeFactory,\n       final ValueSerdeFactory valueSerdeFactory,\n       final MetaStore metaStore\n   ) {\n-    this.serviceContext = Objects.requireNonNull(serviceContext, \"serviceContext\");\n-    this.serdeOptionsSupplier =\n-        Objects.requireNonNull(serdeOptionsSupplier, \"serdeOptionsSupplier\");\n-    this.keySerdeFactory = Objects.requireNonNull(keySerdeFactory, \"keySerdeFactory\");\n-    this.valueSerdeFactory = Objects.requireNonNull(valueSerdeFactory, \"valueSerdeFactory\");\n-    this.metaStore = Objects.requireNonNull(metaStore);\n+    this.serviceContext = requireNonNull(serviceContext, \"serviceContext\");\n+    this.keySerdeFeaturesSupplier =\n+        requireNonNull(keySerdeFeaturesSupplier, \"keySerdeFeaturesSupplier\");\n+    this.valueSerdeFeaturesSupplier =\n+        requireNonNull(valueSerdeFeaturesSupplier, \"valueSerdeFeaturesSupplier\");\n+    this.keySerdeFactory = requireNonNull(keySerdeFactory, \"keySerdeFactory\");\n+    this.valueSerdeFactory = requireNonNull(valueSerdeFactory, \"valueSerdeFactory\");\n+    this.metaStore = requireNonNull(metaStore);\n   }\n \n   public CreateStreamCommand createStreamCommand(\n", "next_change": {"commit": "b1ea1535fbf00211e33449cddf2ba64792c1b9c3", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex b7e4f0450d5..a92560d4424 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -91,6 +92,18 @@ public final class CreateSourceFactory {\n     this.metaStore = requireNonNull(metaStore);\n   }\n \n+  public CreateStreamCommand createStreamCommand(final KsqlStructuredDataOutputNode outputNode) {\n+    return new CreateStreamCommand(\n+        outputNode.getIntoSourceName(),\n+        outputNode.getSchema(),\n+        outputNode.getTimestampColumn(),\n+        outputNode.getKsqlTopic().getKafkaTopicName(),\n+        Formats.from(outputNode.getKsqlTopic()),\n+        outputNode.getKsqlTopic().getKeyFormat().getWindowInfo(),\n+        Optional.of(outputNode.getOrReplace())\n+    );\n+  }\n+\n   public CreateStreamCommand createStreamCommand(\n       final CreateStream statement,\n       final KsqlConfig ksqlConfig\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 50d0ca3b228..08680b76c43 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -70,17 +76,32 @@ public final class CreateSourceFactory {\n   @VisibleForTesting\n   CreateSourceFactory(\n       final ServiceContext serviceContext,\n-      final SerdeOptionsSupplier serdeOptionsSupplier,\n+      final SerdeFeaturessSupplier keySerdeFeaturesSupplier,\n+      final SerdeFeaturessSupplier valueSerdeFeaturesSupplier,\n       final KeySerdeFactory keySerdeFactory,\n       final ValueSerdeFactory valueSerdeFactory,\n       final MetaStore metaStore\n   ) {\n-    this.serviceContext = Objects.requireNonNull(serviceContext, \"serviceContext\");\n-    this.serdeOptionsSupplier =\n-        Objects.requireNonNull(serdeOptionsSupplier, \"serdeOptionsSupplier\");\n-    this.keySerdeFactory = Objects.requireNonNull(keySerdeFactory, \"keySerdeFactory\");\n-    this.valueSerdeFactory = Objects.requireNonNull(valueSerdeFactory, \"valueSerdeFactory\");\n-    this.metaStore = metaStore;\n+    this.serviceContext = requireNonNull(serviceContext, \"serviceContext\");\n+    this.keySerdeFeaturesSupplier =\n+        requireNonNull(keySerdeFeaturesSupplier, \"keySerdeFeaturesSupplier\");\n+    this.valueSerdeFeaturesSupplier =\n+        requireNonNull(valueSerdeFeaturesSupplier, \"valueSerdeFeaturesSupplier\");\n+    this.keySerdeFactory = requireNonNull(keySerdeFactory, \"keySerdeFactory\");\n+    this.valueSerdeFactory = requireNonNull(valueSerdeFactory, \"valueSerdeFactory\");\n+    this.metaStore = requireNonNull(metaStore);\n+  }\n+\n+  public CreateStreamCommand createStreamCommand(final KsqlStructuredDataOutputNode outputNode) {\n+    return new CreateStreamCommand(\n+        outputNode.getIntoSourceName(),\n+        outputNode.getSchema(),\n+        outputNode.getTimestampColumn(),\n+        outputNode.getKsqlTopic().getKafkaTopicName(),\n+        Formats.from(outputNode.getKsqlTopic()),\n+        outputNode.getKsqlTopic().getKeyFormat().getWindowInfo(),\n+        Optional.of(outputNode.getOrReplace())\n+    );\n   }\n \n   public CreateStreamCommand createStreamCommand(\n", "next_change": {"commit": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 08680b76c43..0ac33f5f40a 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -92,18 +92,21 @@ public final class CreateSourceFactory {\n     this.metaStore = requireNonNull(metaStore);\n   }\n \n+  // This method is called by CREATE_AS statements\n   public CreateStreamCommand createStreamCommand(final KsqlStructuredDataOutputNode outputNode) {\n     return new CreateStreamCommand(\n-        outputNode.getIntoSourceName(),\n+        outputNode.getSinkName().get(),\n         outputNode.getSchema(),\n         outputNode.getTimestampColumn(),\n         outputNode.getKsqlTopic().getKafkaTopicName(),\n         Formats.from(outputNode.getKsqlTopic()),\n         outputNode.getKsqlTopic().getKeyFormat().getWindowInfo(),\n-        Optional.of(outputNode.getOrReplace())\n+        Optional.of(outputNode.getOrReplace()),\n+        Optional.of(false)\n     );\n   }\n \n+  // This method is called by simple CREATE statements\n   public CreateStreamCommand createStreamCommand(\n       final CreateStream statement,\n       final KsqlConfig ksqlConfig\n", "next_change": {"commit": "7d5cb0397d14e20a8305cf88c9052256e9d569f1", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 0ac33f5f40a..9ce5ba743a1 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -114,7 +114,7 @@ public final class CreateSourceFactory {\n     final SourceName sourceName = statement.getName();\n     final CreateSourceProperties props = statement.getProperties();\n     final String topicName = ensureTopicExists(props, serviceContext);\n-    final LogicalSchema schema = buildSchema(statement.getElements());\n+    final LogicalSchema schema = buildSchema(statement.getElements(), ksqlConfig);\n     final Optional<TimestampColumn> timestampColumn =\n         buildTimestampColumn(ksqlConfig, props, schema);\n     final DataSource dataSource = metaStore.getSource(sourceName);\n", "next_change": {"commit": "a234ee5d5b5aa800d51466137f7b514d68455f08", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 9ce5ba743a1..f462c0b45f0 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -114,7 +116,7 @@ public final class CreateSourceFactory {\n     final SourceName sourceName = statement.getName();\n     final CreateSourceProperties props = statement.getProperties();\n     final String topicName = ensureTopicExists(props, serviceContext);\n-    final LogicalSchema schema = buildSchema(statement.getElements(), ksqlConfig);\n+    final LogicalSchema schema = buildSchema(statement.getElements());\n     final Optional<TimestampColumn> timestampColumn =\n         buildTimestampColumn(ksqlConfig, props, schema);\n     final DataSource dataSource = metaStore.getSource(sourceName);\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "6cdce0a2632bd0512407e4a9e7d27b58fd1df1e6", "committedDate": "2021-05-23 08:25:17 -0700", "message": "chore: add FK-join logical to physical plan translation (#7570)"}, {"oid": "bdb7143330a04a483a5b5faba5fa5d6563c9de48", "committedDate": "2021-07-22 10:49:12 -0700", "message": "chore: improve error messages for user columns with reserved names (#7829)"}, {"oid": "70565f2969df109c6fd4ae6bb7c48c5365c45f9d", "committedDate": "2021-08-11 16:10:36 -0500", "message": "feat: add CREATE SOURCE TABLE syntax and metadata info (#7945)"}, {"oid": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "committedDate": "2021-08-18 12:27:21 -0700", "message": "feat: add CREATE SOURCE STREAM syntax and metadata info (#8004)"}, {"oid": "7d5cb0397d14e20a8305cf88c9052256e9d569f1", "committedDate": "2021-09-22 21:27:17 -0700", "message": "chore: feature flag for ROWPARTITION and ROWOFFSET (#8120)"}, {"oid": "abe47c335e148c41befa5213e6f116474128ec4b", "committedDate": "2021-09-30 16:25:12 -0500", "message": "chore: disable CREATE OR REPLACE on source streams and tables (#8199)"}, {"oid": "2af201f45f45092d596a4844ca5f139455328844", "committedDate": "2022-07-07 14:15:28 -0700", "message": "feat: enable new emit-final implementation (#9141)"}, {"oid": "a234ee5d5b5aa800d51466137f7b514d68455f08", "committedDate": "2022-08-03 09:12:17 -0400", "message": "chore: remove rowpartition/rowoffset feature flag (#9373)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2MzAwNw==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r486963007", "body": "```suggestion\r\n    if (dataSource != null && !statement.isOrReplace()) {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (dataSource != null) {\n          \n          \n            \n                if (dataSource != null && !statement.isOrReplace()) {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">if</span> (dataSource <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">if</span> (dataSource <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span><span class=\"x x-first\"> </span><span class=\"pl-k x\">&amp;&amp;</span><span class=\"x\"> </span><span class=\"pl-k x\">!</span><span class=\"x\">statement</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">isOrReplace()</span>) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "big-andy-coates", "createdAt": "2020-09-11T10:42:47Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java", "diffHunk": "@@ -115,6 +131,17 @@ public CreateTableCommand createTableCommand(\n       final KsqlConfig ksqlConfig\n   ) {\n     final SourceName sourceName = statement.getName();\n+    final DataSource dataSource = metaStore.getSource(sourceName);\n+\n+    if (dataSource != null) {", "originalCommit": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQzNjYzNw==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r495436637", "bodyText": "this is done", "author": "hemantgs", "createdAt": "2020-09-26T09:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2MzAwNw=="}], "type": "inlineReview", "revised_code": {"commit": "678163151432e1e935c4acbb426f41b75b22b488", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 50d0ca3b228..e9fa1737d27 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -131,28 +135,28 @@ public final class CreateSourceFactory {\n       final KsqlConfig ksqlConfig\n   ) {\n     final SourceName sourceName = statement.getName();\n+    final CreateSourceProperties props = statement.getProperties();\n+    final String topicName = ensureTopicExists(props, serviceContext);\n+    final LogicalSchema schema = buildSchema(statement.getElements());\n     final DataSource dataSource = metaStore.getSource(sourceName);\n \n-    if (dataSource != null) {\n+    if (dataSource != null && !statement.isOrReplace()) {\n       final String sourceType = dataSource.getDataSourceType().getKsqlType();\n       if (!statement.isNotExists()) {\n         throw new KsqlException(\n-            String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n-                sourceType, sourceName.text(), sourceType));\n+            String.format(\"Cannot add table '%s': A %s with the same name already exists\",\n+                sourceName.text(), sourceType.toLowerCase()));\n       }\n     }\n-\n-    final KsqlTopic topic = buildTopic(statement.getProperties(), serviceContext);\n-    final LogicalSchema schema = buildSchema(statement.getElements());\n     if (schema.key().isEmpty()) {\n-      final boolean usingSchemaInference = statement.getProperties().getSchemaId().isPresent();\n+      final boolean usingSchemaInference = props.getSchemaId().isPresent();\n \n       final String additional = usingSchemaInference\n           ? System.lineSeparator()\n           + \"Use a partial schema to define the primary key and still load the value columns from \"\n           + \"the Schema Registry, for example:\"\n           + System.lineSeparator()\n-          + \"\\tCREATE TABLE \" + statement.getName().text() + \" (ID INT PRIMARY KEY) WITH (...);\"\n+          + \"\\tCREATE TABLE \" + sourceName.text() + \" (ID INT PRIMARY KEY) WITH (...);\"\n           : \"\";\n \n       throw new KsqlException(\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 50d0ca3b228..08680b76c43 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -88,71 +109,68 @@ public final class CreateSourceFactory {\n       final KsqlConfig ksqlConfig\n   ) {\n     final SourceName sourceName = statement.getName();\n+    final CreateSourceProperties props = statement.getProperties();\n+    final String topicName = ensureTopicExists(props, serviceContext);\n+    final LogicalSchema schema = buildSchema(statement.getElements());\n+    final Optional<TimestampColumn> timestampColumn =\n+        buildTimestampColumn(ksqlConfig, props, schema);\n     final DataSource dataSource = metaStore.getSource(sourceName);\n \n-    if (dataSource != null && !statement.isOrReplace()) {\n+    if (dataSource != null && !statement.isOrReplace() && !statement.isNotExists()) {\n       final String sourceType = dataSource.getDataSourceType().getKsqlType();\n-      if (!statement.isNotExists()) {\n-        throw new KsqlException(\n-            String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n-                sourceType, sourceName.text(), sourceType));\n-      }\n+      throw new KsqlException(\n+          String.format(\"Cannot add stream '%s': A %s with the same name already exists\",\n+             sourceName.text(), sourceType.toLowerCase()));\n     }\n-    final KsqlTopic topic = buildTopic(statement.getProperties(), serviceContext);\n-    final LogicalSchema schema = buildSchema(statement.getElements());\n-    final Optional<TimestampColumn> timestampColumn = buildTimestampColumn(\n-        ksqlConfig,\n-        statement.getProperties(),\n-        schema\n-    );\n-\n-    final SerdeOptions serdeOptions = serdeOptionsSupplier.build(\n-        schema,\n-        topic.getValueFormat().getFormat(),\n-        statement.getProperties().getSerdeOptions(),\n-        ksqlConfig\n-    );\n-\n-    validateSerdesCanHandleSchemas(ksqlConfig, PhysicalSchema.from(schema, serdeOptions), topic);\n \n     return new CreateStreamCommand(\n         sourceName,\n         schema,\n         timestampColumn,\n-        topic.getKafkaTopicName(),\n-        Formats.of(topic.getKeyFormat(), topic.getValueFormat(), serdeOptions),\n-        topic.getKeyFormat().getWindowInfo(),\n+        topicName,\n+        buildFormats(statement.getName(), schema, props, ksqlConfig),\n+        getWindowInfo(props),\n         Optional.of(statement.isOrReplace())\n     );\n   }\n \n+  public CreateTableCommand createTableCommand(final KsqlStructuredDataOutputNode outputNode) {\n+    return new CreateTableCommand(\n+        outputNode.getIntoSourceName(),\n+        outputNode.getSchema(),\n+        outputNode.getTimestampColumn(),\n+        outputNode.getKsqlTopic().getKafkaTopicName(),\n+        Formats.from(outputNode.getKsqlTopic()),\n+        outputNode.getKsqlTopic().getKeyFormat().getWindowInfo(),\n+        Optional.of(outputNode.getOrReplace())\n+    );\n+  }\n+\n   public CreateTableCommand createTableCommand(\n       final CreateTable statement,\n       final KsqlConfig ksqlConfig\n   ) {\n     final SourceName sourceName = statement.getName();\n+    final CreateSourceProperties props = statement.getProperties();\n+    final String topicName = ensureTopicExists(props, serviceContext);\n+    final LogicalSchema schema = buildSchema(statement.getElements());\n     final DataSource dataSource = metaStore.getSource(sourceName);\n \n-    if (dataSource != null) {\n+    if (dataSource != null && !statement.isOrReplace() && !statement.isNotExists()) {\n       final String sourceType = dataSource.getDataSourceType().getKsqlType();\n-      if (!statement.isNotExists()) {\n-        throw new KsqlException(\n-            String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n-                sourceType, sourceName.text(), sourceType));\n-      }\n+      throw new KsqlException(\n+          String.format(\"Cannot add table '%s': A %s with the same name already exists\",\n+              sourceName.text(), sourceType.toLowerCase()));\n     }\n-\n-    final KsqlTopic topic = buildTopic(statement.getProperties(), serviceContext);\n-    final LogicalSchema schema = buildSchema(statement.getElements());\n     if (schema.key().isEmpty()) {\n-      final boolean usingSchemaInference = statement.getProperties().getSchemaId().isPresent();\n+      final boolean usingSchemaInference = props.getValueSchemaId().isPresent();\n \n       final String additional = usingSchemaInference\n           ? System.lineSeparator()\n           + \"Use a partial schema to define the primary key and still load the value columns from \"\n           + \"the Schema Registry, for example:\"\n           + System.lineSeparator()\n-          + \"\\tCREATE TABLE \" + statement.getName().text() + \" (ID INT PRIMARY KEY) WITH (...);\"\n+          + \"\\tCREATE TABLE \" + sourceName.text() + \" (ID INT PRIMARY KEY) WITH (...);\"\n           : \"\";\n \n       throw new KsqlException(\n", "next_change": {"commit": "abe47c335e148c41befa5213e6f116474128ec4b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 08680b76c43..96b9d6de3cd 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -178,6 +188,8 @@ public final class CreateSourceFactory {\n       );\n     }\n \n+    throwIfCreateOrReplaceOnSourceStreamOrTable(statement, dataSource);\n+\n     final Optional<TimestampColumn> timestampColumn =\n         buildTimestampColumn(ksqlConfig, props, schema);\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "6cdce0a2632bd0512407e4a9e7d27b58fd1df1e6", "committedDate": "2021-05-23 08:25:17 -0700", "message": "chore: add FK-join logical to physical plan translation (#7570)"}, {"oid": "bdb7143330a04a483a5b5faba5fa5d6563c9de48", "committedDate": "2021-07-22 10:49:12 -0700", "message": "chore: improve error messages for user columns with reserved names (#7829)"}, {"oid": "70565f2969df109c6fd4ae6bb7c48c5365c45f9d", "committedDate": "2021-08-11 16:10:36 -0500", "message": "feat: add CREATE SOURCE TABLE syntax and metadata info (#7945)"}, {"oid": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "committedDate": "2021-08-18 12:27:21 -0700", "message": "feat: add CREATE SOURCE STREAM syntax and metadata info (#8004)"}, {"oid": "7d5cb0397d14e20a8305cf88c9052256e9d569f1", "committedDate": "2021-09-22 21:27:17 -0700", "message": "chore: feature flag for ROWPARTITION and ROWOFFSET (#8120)"}, {"oid": "abe47c335e148c41befa5213e6f116474128ec4b", "committedDate": "2021-09-30 16:25:12 -0500", "message": "chore: disable CREATE OR REPLACE on source streams and tables (#8199)"}, {"oid": "2af201f45f45092d596a4844ca5f139455328844", "committedDate": "2022-07-07 14:15:28 -0700", "message": "feat: enable new emit-final implementation (#9141)"}, {"oid": "a234ee5d5b5aa800d51466137f7b514d68455f08", "committedDate": "2022-08-03 09:12:17 -0400", "message": "chore: remove rowpartition/rowoffset feature flag (#9373)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2MzM0OA==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r486963348", "body": "```suggestion\r\n            String.format(\"Cannot add stream '%s': A %s with the same name already exists\",\r\n                sourceName.text(), sourceType.toLowerCase()));\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n          \n          \n            \n                            sourceType, sourceName.text(), sourceType));\n          \n          \n            \n                        String.format(\"Cannot add stream '%s': A %s with the same name already exists\",\n          \n          \n            \n                            sourceName.text(), sourceType.toLowerCase()));", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-smi\">String</span><span class=\"pl-k\">.</span>format(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Cannot add <span class=\"x x-first x-last\">%s</span> '%s': A %s with the same name already exists<span class=\"pl-pds\">\"</span></span>,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"x x-first x-last\">sourceType, </span>sourceName<span class=\"pl-k\">.</span>text(), sourceType));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-smi\">String</span><span class=\"pl-k\">.</span>format(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Cannot add <span class=\"x x-first x-last\">stream</span> '%s': A %s with the same name already exists<span class=\"pl-pds\">\"</span></span>,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                sourceName<span class=\"pl-k\">.</span>text(), sourceType<span class=\"pl-k x x-first\">.</span><span class=\"x x-last\">toLowerCase()</span>));</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "big-andy-coates", "createdAt": "2020-09-11T10:43:32Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java", "diffHunk": "@@ -68,20 +72,32 @@ public CreateSourceFactory(final ServiceContext serviceContext) {\n       final ServiceContext serviceContext,\n       final SerdeOptionsSupplier serdeOptionsSupplier,\n       final KeySerdeFactory keySerdeFactory,\n-      final ValueSerdeFactory valueSerdeFactory\n+      final ValueSerdeFactory valueSerdeFactory,\n+      final MetaStore metaStore\n   ) {\n     this.serviceContext = Objects.requireNonNull(serviceContext, \"serviceContext\");\n     this.serdeOptionsSupplier =\n         Objects.requireNonNull(serdeOptionsSupplier, \"serdeOptionsSupplier\");\n     this.keySerdeFactory = Objects.requireNonNull(keySerdeFactory, \"keySerdeFactory\");\n     this.valueSerdeFactory = Objects.requireNonNull(valueSerdeFactory, \"valueSerdeFactory\");\n+    this.metaStore = metaStore;\n   }\n \n   public CreateStreamCommand createStreamCommand(\n       final CreateStream statement,\n       final KsqlConfig ksqlConfig\n   ) {\n     final SourceName sourceName = statement.getName();\n+    final DataSource dataSource = metaStore.getSource(sourceName);\n+\n+    if (dataSource != null && !statement.isOrReplace()) {\n+      final String sourceType = dataSource.getDataSourceType().getKsqlType();\n+      if (!statement.isNotExists()) {\n+        throw new KsqlException(\n+            String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n+                sourceType, sourceName.text(), sourceType));", "originalCommit": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQzNjY0MA==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r495436640", "bodyText": "this is done", "author": "hemantgs", "createdAt": "2020-09-26T09:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2MzM0OA=="}], "type": "inlineReview", "revised_code": {"commit": "678163151432e1e935c4acbb426f41b75b22b488", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 50d0ca3b228..e9fa1737d27 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -88,40 +90,42 @@ public final class CreateSourceFactory {\n       final KsqlConfig ksqlConfig\n   ) {\n     final SourceName sourceName = statement.getName();\n+    final CreateSourceProperties props = statement.getProperties();\n+    final String topicName = ensureTopicExists(props, serviceContext);\n+    final LogicalSchema schema = buildSchema(statement.getElements());\n+    final Optional<TimestampColumn> timestampColumn =\n+        buildTimestampColumn(ksqlConfig, props, schema);\n     final DataSource dataSource = metaStore.getSource(sourceName);\n \n     if (dataSource != null && !statement.isOrReplace()) {\n       final String sourceType = dataSource.getDataSourceType().getKsqlType();\n       if (!statement.isNotExists()) {\n         throw new KsqlException(\n-            String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n-                sourceType, sourceName.text(), sourceType));\n+            String.format(\"Cannot add stream '%s': A %s with the same name already exists\",\n+               sourceName.text(), sourceType.toLowerCase()));\n       }\n     }\n-    final KsqlTopic topic = buildTopic(statement.getProperties(), serviceContext);\n-    final LogicalSchema schema = buildSchema(statement.getElements());\n-    final Optional<TimestampColumn> timestampColumn = buildTimestampColumn(\n-        ksqlConfig,\n-        statement.getProperties(),\n-        schema\n-    );\n+\n+    final FormatInfo keyFormat = SourcePropertiesUtil.getKeyFormat(props);\n+    final FormatInfo valueFormat = SourcePropertiesUtil.getValueFormat(props);\n \n     final SerdeOptions serdeOptions = serdeOptionsSupplier.build(\n         schema,\n-        topic.getValueFormat().getFormat(),\n-        statement.getProperties().getSerdeOptions(),\n+        FormatFactory.of(keyFormat),\n+        FormatFactory.of(valueFormat),\n+        props.getSerdeOptions(),\n         ksqlConfig\n     );\n \n-    validateSerdesCanHandleSchemas(ksqlConfig, PhysicalSchema.from(schema, serdeOptions), topic);\n+    validateSerdesCanHandleSchemas(ksqlConfig, schema, serdeOptions, keyFormat, valueFormat);\n \n     return new CreateStreamCommand(\n         sourceName,\n         schema,\n         timestampColumn,\n-        topic.getKafkaTopicName(),\n-        Formats.of(topic.getKeyFormat(), topic.getValueFormat(), serdeOptions),\n-        topic.getKeyFormat().getWindowInfo(),\n+        topicName,\n+        Formats.of(keyFormat, valueFormat, serdeOptions),\n+        getWindowInfo(props),\n         Optional.of(statement.isOrReplace())\n     );\n   }\n", "next_change": {"commit": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex e9fa1737d27..b7e4f0450d5 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -97,34 +103,19 @@ public final class CreateSourceFactory {\n         buildTimestampColumn(ksqlConfig, props, schema);\n     final DataSource dataSource = metaStore.getSource(sourceName);\n \n-    if (dataSource != null && !statement.isOrReplace()) {\n+    if (dataSource != null && !statement.isOrReplace() && !statement.isNotExists()) {\n       final String sourceType = dataSource.getDataSourceType().getKsqlType();\n-      if (!statement.isNotExists()) {\n-        throw new KsqlException(\n-            String.format(\"Cannot add stream '%s': A %s with the same name already exists\",\n-               sourceName.text(), sourceType.toLowerCase()));\n-      }\n+      throw new KsqlException(\n+          String.format(\"Cannot add stream '%s': A %s with the same name already exists\",\n+             sourceName.text(), sourceType.toLowerCase()));\n     }\n \n-    final FormatInfo keyFormat = SourcePropertiesUtil.getKeyFormat(props);\n-    final FormatInfo valueFormat = SourcePropertiesUtil.getValueFormat(props);\n-\n-    final SerdeOptions serdeOptions = serdeOptionsSupplier.build(\n-        schema,\n-        FormatFactory.of(keyFormat),\n-        FormatFactory.of(valueFormat),\n-        props.getSerdeOptions(),\n-        ksqlConfig\n-    );\n-\n-    validateSerdesCanHandleSchemas(ksqlConfig, schema, serdeOptions, keyFormat, valueFormat);\n-\n     return new CreateStreamCommand(\n         sourceName,\n         schema,\n         timestampColumn,\n         topicName,\n-        Formats.of(keyFormat, valueFormat, serdeOptions),\n+        buildFormats(schema, props, ksqlConfig),\n         getWindowInfo(props),\n         Optional.of(statement.isOrReplace())\n     );\n", "next_change": {"commit": "b1ea1535fbf00211e33449cddf2ba64792c1b9c3", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex b7e4f0450d5..a92560d4424 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -121,6 +134,18 @@ public final class CreateSourceFactory {\n     );\n   }\n \n+  public CreateTableCommand createTableCommand(final KsqlStructuredDataOutputNode outputNode) {\n+    return new CreateTableCommand(\n+        outputNode.getIntoSourceName(),\n+        outputNode.getSchema(),\n+        outputNode.getTimestampColumn(),\n+        outputNode.getKsqlTopic().getKafkaTopicName(),\n+        Formats.from(outputNode.getKsqlTopic()),\n+        outputNode.getKsqlTopic().getKeyFormat().getWindowInfo(),\n+        Optional.of(outputNode.getOrReplace())\n+    );\n+  }\n+\n   public CreateTableCommand createTableCommand(\n       final CreateTable statement,\n       final KsqlConfig ksqlConfig\n", "next_change": {"commit": "2965dcdfbf2497364f33506bc22997f9f2bded83", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex a92560d4424..81af59366d7 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -154,14 +140,6 @@ public final class CreateSourceFactory {\n     final CreateSourceProperties props = statement.getProperties();\n     final String topicName = ensureTopicExists(props, serviceContext);\n     final LogicalSchema schema = buildSchema(statement.getElements());\n-    final DataSource dataSource = metaStore.getSource(sourceName);\n-\n-    if (dataSource != null && !statement.isOrReplace() && !statement.isNotExists()) {\n-      final String sourceType = dataSource.getDataSourceType().getKsqlType();\n-      throw new KsqlException(\n-          String.format(\"Cannot add table '%s': A %s with the same name already exists\",\n-              sourceName.text(), sourceType.toLowerCase()));\n-    }\n     if (schema.key().isEmpty()) {\n       final boolean usingSchemaInference = props.getValueSchemaId().isPresent();\n \n", "next_change": {"commit": "b01aebc5c183bccf95895a9952edd7e40aed243f", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 81af59366d7..5e5b6e68ec6 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -140,6 +156,16 @@ public final class CreateSourceFactory {\n     final CreateSourceProperties props = statement.getProperties();\n     final String topicName = ensureTopicExists(props, serviceContext);\n     final LogicalSchema schema = buildSchema(statement.getElements());\n+    final DataSource dataSource = metaStore.getSource(sourceName);\n+\n+    if (dataSource != null) {\n+      final String sourceType = dataSource.getDataSourceType().getKsqlType();\n+      if (!statement.isNotExists()) {\n+        throw new KsqlException(\n+            String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n+                sourceType, sourceName.text(), sourceType));\n+      }\n+    }\n     if (schema.key().isEmpty()) {\n       final boolean usingSchemaInference = props.getValueSchemaId().isPresent();\n \n", "next_change": {"commit": "b86142608b747306c05e75a72537ede230189c87", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 5e5b6e68ec6..932024531c1 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -158,12 +158,12 @@ public final class CreateSourceFactory {\n     final LogicalSchema schema = buildSchema(statement.getElements());\n     final DataSource dataSource = metaStore.getSource(sourceName);\n \n-    if (dataSource != null) {\n+    if (dataSource != null && !statement.isOrReplace()) {\n       final String sourceType = dataSource.getDataSourceType().getKsqlType();\n       if (!statement.isNotExists()) {\n         throw new KsqlException(\n-            String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n-                sourceType, sourceName.text(), sourceType));\n+            String.format(\"Cannot add table '%s': A %s with the same name already exists\",\n+                sourceName.text(), sourceType.toLowerCase()));\n       }\n     }\n     if (schema.key().isEmpty()) {\n", "next_change": {"commit": "ff9c504abdc3f4c58e8066e277b9ffc08ad12b6a", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 932024531c1..08680b76c43 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -158,13 +156,11 @@ public final class CreateSourceFactory {\n     final LogicalSchema schema = buildSchema(statement.getElements());\n     final DataSource dataSource = metaStore.getSource(sourceName);\n \n-    if (dataSource != null && !statement.isOrReplace()) {\n+    if (dataSource != null && !statement.isOrReplace() && !statement.isNotExists()) {\n       final String sourceType = dataSource.getDataSourceType().getKsqlType();\n-      if (!statement.isNotExists()) {\n-        throw new KsqlException(\n-            String.format(\"Cannot add table '%s': A %s with the same name already exists\",\n-                sourceName.text(), sourceType.toLowerCase()));\n-      }\n+      throw new KsqlException(\n+          String.format(\"Cannot add table '%s': A %s with the same name already exists\",\n+              sourceName.text(), sourceType.toLowerCase()));\n     }\n     if (schema.key().isEmpty()) {\n       final boolean usingSchemaInference = props.getValueSchemaId().isPresent();\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 50d0ca3b228..08680b76c43 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -88,71 +109,68 @@ public final class CreateSourceFactory {\n       final KsqlConfig ksqlConfig\n   ) {\n     final SourceName sourceName = statement.getName();\n+    final CreateSourceProperties props = statement.getProperties();\n+    final String topicName = ensureTopicExists(props, serviceContext);\n+    final LogicalSchema schema = buildSchema(statement.getElements());\n+    final Optional<TimestampColumn> timestampColumn =\n+        buildTimestampColumn(ksqlConfig, props, schema);\n     final DataSource dataSource = metaStore.getSource(sourceName);\n \n-    if (dataSource != null && !statement.isOrReplace()) {\n+    if (dataSource != null && !statement.isOrReplace() && !statement.isNotExists()) {\n       final String sourceType = dataSource.getDataSourceType().getKsqlType();\n-      if (!statement.isNotExists()) {\n-        throw new KsqlException(\n-            String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n-                sourceType, sourceName.text(), sourceType));\n-      }\n+      throw new KsqlException(\n+          String.format(\"Cannot add stream '%s': A %s with the same name already exists\",\n+             sourceName.text(), sourceType.toLowerCase()));\n     }\n-    final KsqlTopic topic = buildTopic(statement.getProperties(), serviceContext);\n-    final LogicalSchema schema = buildSchema(statement.getElements());\n-    final Optional<TimestampColumn> timestampColumn = buildTimestampColumn(\n-        ksqlConfig,\n-        statement.getProperties(),\n-        schema\n-    );\n-\n-    final SerdeOptions serdeOptions = serdeOptionsSupplier.build(\n-        schema,\n-        topic.getValueFormat().getFormat(),\n-        statement.getProperties().getSerdeOptions(),\n-        ksqlConfig\n-    );\n-\n-    validateSerdesCanHandleSchemas(ksqlConfig, PhysicalSchema.from(schema, serdeOptions), topic);\n \n     return new CreateStreamCommand(\n         sourceName,\n         schema,\n         timestampColumn,\n-        topic.getKafkaTopicName(),\n-        Formats.of(topic.getKeyFormat(), topic.getValueFormat(), serdeOptions),\n-        topic.getKeyFormat().getWindowInfo(),\n+        topicName,\n+        buildFormats(statement.getName(), schema, props, ksqlConfig),\n+        getWindowInfo(props),\n         Optional.of(statement.isOrReplace())\n     );\n   }\n \n+  public CreateTableCommand createTableCommand(final KsqlStructuredDataOutputNode outputNode) {\n+    return new CreateTableCommand(\n+        outputNode.getIntoSourceName(),\n+        outputNode.getSchema(),\n+        outputNode.getTimestampColumn(),\n+        outputNode.getKsqlTopic().getKafkaTopicName(),\n+        Formats.from(outputNode.getKsqlTopic()),\n+        outputNode.getKsqlTopic().getKeyFormat().getWindowInfo(),\n+        Optional.of(outputNode.getOrReplace())\n+    );\n+  }\n+\n   public CreateTableCommand createTableCommand(\n       final CreateTable statement,\n       final KsqlConfig ksqlConfig\n   ) {\n     final SourceName sourceName = statement.getName();\n+    final CreateSourceProperties props = statement.getProperties();\n+    final String topicName = ensureTopicExists(props, serviceContext);\n+    final LogicalSchema schema = buildSchema(statement.getElements());\n     final DataSource dataSource = metaStore.getSource(sourceName);\n \n-    if (dataSource != null) {\n+    if (dataSource != null && !statement.isOrReplace() && !statement.isNotExists()) {\n       final String sourceType = dataSource.getDataSourceType().getKsqlType();\n-      if (!statement.isNotExists()) {\n-        throw new KsqlException(\n-            String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n-                sourceType, sourceName.text(), sourceType));\n-      }\n+      throw new KsqlException(\n+          String.format(\"Cannot add table '%s': A %s with the same name already exists\",\n+              sourceName.text(), sourceType.toLowerCase()));\n     }\n-\n-    final KsqlTopic topic = buildTopic(statement.getProperties(), serviceContext);\n-    final LogicalSchema schema = buildSchema(statement.getElements());\n     if (schema.key().isEmpty()) {\n-      final boolean usingSchemaInference = statement.getProperties().getSchemaId().isPresent();\n+      final boolean usingSchemaInference = props.getValueSchemaId().isPresent();\n \n       final String additional = usingSchemaInference\n           ? System.lineSeparator()\n           + \"Use a partial schema to define the primary key and still load the value columns from \"\n           + \"the Schema Registry, for example:\"\n           + System.lineSeparator()\n-          + \"\\tCREATE TABLE \" + statement.getName().text() + \" (ID INT PRIMARY KEY) WITH (...);\"\n+          + \"\\tCREATE TABLE \" + sourceName.text() + \" (ID INT PRIMARY KEY) WITH (...);\"\n           : \"\";\n \n       throw new KsqlException(\n", "next_change": {"commit": "abe47c335e148c41befa5213e6f116474128ec4b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 08680b76c43..96b9d6de3cd 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -178,6 +188,8 @@ public final class CreateSourceFactory {\n       );\n     }\n \n+    throwIfCreateOrReplaceOnSourceStreamOrTable(statement, dataSource);\n+\n     final Optional<TimestampColumn> timestampColumn =\n         buildTimestampColumn(ksqlConfig, props, schema);\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "6cdce0a2632bd0512407e4a9e7d27b58fd1df1e6", "committedDate": "2021-05-23 08:25:17 -0700", "message": "chore: add FK-join logical to physical plan translation (#7570)"}, {"oid": "bdb7143330a04a483a5b5faba5fa5d6563c9de48", "committedDate": "2021-07-22 10:49:12 -0700", "message": "chore: improve error messages for user columns with reserved names (#7829)"}, {"oid": "70565f2969df109c6fd4ae6bb7c48c5365c45f9d", "committedDate": "2021-08-11 16:10:36 -0500", "message": "feat: add CREATE SOURCE TABLE syntax and metadata info (#7945)"}, {"oid": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "committedDate": "2021-08-18 12:27:21 -0700", "message": "feat: add CREATE SOURCE STREAM syntax and metadata info (#8004)"}, {"oid": "7d5cb0397d14e20a8305cf88c9052256e9d569f1", "committedDate": "2021-09-22 21:27:17 -0700", "message": "chore: feature flag for ROWPARTITION and ROWOFFSET (#8120)"}, {"oid": "abe47c335e148c41befa5213e6f116474128ec4b", "committedDate": "2021-09-30 16:25:12 -0500", "message": "chore: disable CREATE OR REPLACE on source streams and tables (#8199)"}, {"oid": "2af201f45f45092d596a4844ca5f139455328844", "committedDate": "2022-07-07 14:15:28 -0700", "message": "feat: enable new emit-final implementation (#9141)"}, {"oid": "a234ee5d5b5aa800d51466137f7b514d68455f08", "committedDate": "2022-08-03 09:12:17 -0400", "message": "chore: remove rowpartition/rowoffset feature flag (#9373)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2MzUwNA==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r486963504", "body": "```suggestion\r\n            String.format(\"Cannot add table '%s': A %s with the same name already exists\",\r\n                sourceName.text(), sourceType.toLowerCase()));\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n          \n          \n            \n                            sourceType, sourceName.text(), sourceType));\n          \n          \n            \n                        String.format(\"Cannot add table '%s': A %s with the same name already exists\",\n          \n          \n            \n                            sourceName.text(), sourceType.toLowerCase()));", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-smi\">String</span><span class=\"pl-k\">.</span>format(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Cannot add <span class=\"x x-first x-last\">%s</span> '%s': A %s with the same name already exists<span class=\"pl-pds\">\"</span></span>,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"x x-first x-last\">sourceType, </span>sourceName<span class=\"pl-k\">.</span>text(), sourceType));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-smi\">String</span><span class=\"pl-k\">.</span>format(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Cannot add <span class=\"x x-first x-last\">table</span> '%s': A %s with the same name already exists<span class=\"pl-pds\">\"</span></span>,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                sourceName<span class=\"pl-k\">.</span>text(), sourceType<span class=\"pl-k x x-first\">.</span><span class=\"x x-last\">toLowerCase()</span>));</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "big-andy-coates", "createdAt": "2020-09-11T10:43:53Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java", "diffHunk": "@@ -115,6 +131,17 @@ public CreateTableCommand createTableCommand(\n       final KsqlConfig ksqlConfig\n   ) {\n     final SourceName sourceName = statement.getName();\n+    final DataSource dataSource = metaStore.getSource(sourceName);\n+\n+    if (dataSource != null) {\n+      final String sourceType = dataSource.getDataSourceType().getKsqlType();\n+      if (!statement.isNotExists()) {\n+        throw new KsqlException(\n+            String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n+                sourceType, sourceName.text(), sourceType));", "originalCommit": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQzNjY0OA==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r495436648", "bodyText": "this is done", "author": "hemantgs", "createdAt": "2020-09-26T09:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2MzUwNA=="}], "type": "inlineReview", "revised_code": {"commit": "678163151432e1e935c4acbb426f41b75b22b488", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 50d0ca3b228..e9fa1737d27 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -131,28 +135,28 @@ public final class CreateSourceFactory {\n       final KsqlConfig ksqlConfig\n   ) {\n     final SourceName sourceName = statement.getName();\n+    final CreateSourceProperties props = statement.getProperties();\n+    final String topicName = ensureTopicExists(props, serviceContext);\n+    final LogicalSchema schema = buildSchema(statement.getElements());\n     final DataSource dataSource = metaStore.getSource(sourceName);\n \n-    if (dataSource != null) {\n+    if (dataSource != null && !statement.isOrReplace()) {\n       final String sourceType = dataSource.getDataSourceType().getKsqlType();\n       if (!statement.isNotExists()) {\n         throw new KsqlException(\n-            String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n-                sourceType, sourceName.text(), sourceType));\n+            String.format(\"Cannot add table '%s': A %s with the same name already exists\",\n+                sourceName.text(), sourceType.toLowerCase()));\n       }\n     }\n-\n-    final KsqlTopic topic = buildTopic(statement.getProperties(), serviceContext);\n-    final LogicalSchema schema = buildSchema(statement.getElements());\n     if (schema.key().isEmpty()) {\n-      final boolean usingSchemaInference = statement.getProperties().getSchemaId().isPresent();\n+      final boolean usingSchemaInference = props.getSchemaId().isPresent();\n \n       final String additional = usingSchemaInference\n           ? System.lineSeparator()\n           + \"Use a partial schema to define the primary key and still load the value columns from \"\n           + \"the Schema Registry, for example:\"\n           + System.lineSeparator()\n-          + \"\\tCREATE TABLE \" + statement.getName().text() + \" (ID INT PRIMARY KEY) WITH (...);\"\n+          + \"\\tCREATE TABLE \" + sourceName.text() + \" (ID INT PRIMARY KEY) WITH (...);\"\n           : \"\";\n \n       throw new KsqlException(\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 50d0ca3b228..08680b76c43 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -88,71 +109,68 @@ public final class CreateSourceFactory {\n       final KsqlConfig ksqlConfig\n   ) {\n     final SourceName sourceName = statement.getName();\n+    final CreateSourceProperties props = statement.getProperties();\n+    final String topicName = ensureTopicExists(props, serviceContext);\n+    final LogicalSchema schema = buildSchema(statement.getElements());\n+    final Optional<TimestampColumn> timestampColumn =\n+        buildTimestampColumn(ksqlConfig, props, schema);\n     final DataSource dataSource = metaStore.getSource(sourceName);\n \n-    if (dataSource != null && !statement.isOrReplace()) {\n+    if (dataSource != null && !statement.isOrReplace() && !statement.isNotExists()) {\n       final String sourceType = dataSource.getDataSourceType().getKsqlType();\n-      if (!statement.isNotExists()) {\n-        throw new KsqlException(\n-            String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n-                sourceType, sourceName.text(), sourceType));\n-      }\n+      throw new KsqlException(\n+          String.format(\"Cannot add stream '%s': A %s with the same name already exists\",\n+             sourceName.text(), sourceType.toLowerCase()));\n     }\n-    final KsqlTopic topic = buildTopic(statement.getProperties(), serviceContext);\n-    final LogicalSchema schema = buildSchema(statement.getElements());\n-    final Optional<TimestampColumn> timestampColumn = buildTimestampColumn(\n-        ksqlConfig,\n-        statement.getProperties(),\n-        schema\n-    );\n-\n-    final SerdeOptions serdeOptions = serdeOptionsSupplier.build(\n-        schema,\n-        topic.getValueFormat().getFormat(),\n-        statement.getProperties().getSerdeOptions(),\n-        ksqlConfig\n-    );\n-\n-    validateSerdesCanHandleSchemas(ksqlConfig, PhysicalSchema.from(schema, serdeOptions), topic);\n \n     return new CreateStreamCommand(\n         sourceName,\n         schema,\n         timestampColumn,\n-        topic.getKafkaTopicName(),\n-        Formats.of(topic.getKeyFormat(), topic.getValueFormat(), serdeOptions),\n-        topic.getKeyFormat().getWindowInfo(),\n+        topicName,\n+        buildFormats(statement.getName(), schema, props, ksqlConfig),\n+        getWindowInfo(props),\n         Optional.of(statement.isOrReplace())\n     );\n   }\n \n+  public CreateTableCommand createTableCommand(final KsqlStructuredDataOutputNode outputNode) {\n+    return new CreateTableCommand(\n+        outputNode.getIntoSourceName(),\n+        outputNode.getSchema(),\n+        outputNode.getTimestampColumn(),\n+        outputNode.getKsqlTopic().getKafkaTopicName(),\n+        Formats.from(outputNode.getKsqlTopic()),\n+        outputNode.getKsqlTopic().getKeyFormat().getWindowInfo(),\n+        Optional.of(outputNode.getOrReplace())\n+    );\n+  }\n+\n   public CreateTableCommand createTableCommand(\n       final CreateTable statement,\n       final KsqlConfig ksqlConfig\n   ) {\n     final SourceName sourceName = statement.getName();\n+    final CreateSourceProperties props = statement.getProperties();\n+    final String topicName = ensureTopicExists(props, serviceContext);\n+    final LogicalSchema schema = buildSchema(statement.getElements());\n     final DataSource dataSource = metaStore.getSource(sourceName);\n \n-    if (dataSource != null) {\n+    if (dataSource != null && !statement.isOrReplace() && !statement.isNotExists()) {\n       final String sourceType = dataSource.getDataSourceType().getKsqlType();\n-      if (!statement.isNotExists()) {\n-        throw new KsqlException(\n-            String.format(\"Cannot add %s '%s': A %s with the same name already exists\",\n-                sourceType, sourceName.text(), sourceType));\n-      }\n+      throw new KsqlException(\n+          String.format(\"Cannot add table '%s': A %s with the same name already exists\",\n+              sourceName.text(), sourceType.toLowerCase()));\n     }\n-\n-    final KsqlTopic topic = buildTopic(statement.getProperties(), serviceContext);\n-    final LogicalSchema schema = buildSchema(statement.getElements());\n     if (schema.key().isEmpty()) {\n-      final boolean usingSchemaInference = statement.getProperties().getSchemaId().isPresent();\n+      final boolean usingSchemaInference = props.getValueSchemaId().isPresent();\n \n       final String additional = usingSchemaInference\n           ? System.lineSeparator()\n           + \"Use a partial schema to define the primary key and still load the value columns from \"\n           + \"the Schema Registry, for example:\"\n           + System.lineSeparator()\n-          + \"\\tCREATE TABLE \" + statement.getName().text() + \" (ID INT PRIMARY KEY) WITH (...);\"\n+          + \"\\tCREATE TABLE \" + sourceName.text() + \" (ID INT PRIMARY KEY) WITH (...);\"\n           : \"\";\n \n       throw new KsqlException(\n", "next_change": {"commit": "abe47c335e148c41befa5213e6f116474128ec4b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\nindex 08680b76c43..96b9d6de3cd 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/CreateSourceFactory.java\n", "chunk": "@@ -178,6 +188,8 @@ public final class CreateSourceFactory {\n       );\n     }\n \n+    throwIfCreateOrReplaceOnSourceStreamOrTable(statement, dataSource);\n+\n     final Optional<TimestampColumn> timestampColumn =\n         buildTimestampColumn(ksqlConfig, props, schema);\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "6cdce0a2632bd0512407e4a9e7d27b58fd1df1e6", "committedDate": "2021-05-23 08:25:17 -0700", "message": "chore: add FK-join logical to physical plan translation (#7570)"}, {"oid": "bdb7143330a04a483a5b5faba5fa5d6563c9de48", "committedDate": "2021-07-22 10:49:12 -0700", "message": "chore: improve error messages for user columns with reserved names (#7829)"}, {"oid": "70565f2969df109c6fd4ae6bb7c48c5365c45f9d", "committedDate": "2021-08-11 16:10:36 -0500", "message": "feat: add CREATE SOURCE TABLE syntax and metadata info (#7945)"}, {"oid": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "committedDate": "2021-08-18 12:27:21 -0700", "message": "feat: add CREATE SOURCE STREAM syntax and metadata info (#8004)"}, {"oid": "7d5cb0397d14e20a8305cf88c9052256e9d569f1", "committedDate": "2021-09-22 21:27:17 -0700", "message": "chore: feature flag for ROWPARTITION and ROWOFFSET (#8120)"}, {"oid": "abe47c335e148c41befa5213e6f116474128ec4b", "committedDate": "2021-09-30 16:25:12 -0500", "message": "chore: disable CREATE OR REPLACE on source streams and tables (#8199)"}, {"oid": "2af201f45f45092d596a4844ca5f139455328844", "committedDate": "2022-07-07 14:15:28 -0700", "message": "feat: enable new emit-final implementation (#9141)"}, {"oid": "a234ee5d5b5aa800d51466137f7b514d68455f08", "committedDate": "2022-08-03 09:12:17 -0400", "message": "chore: remove rowpartition/rowoffset feature flag (#9373)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NDkxMA==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r486964910", "body": "Isn't this check now redundant, given there is code in `CreateSourceFactory` to do this now?  We should let the code do what it used to do, which is throw an exception, not return a success code!", "bodyText": "Isn't this check now redundant, given there is code in CreateSourceFactory to do this now?  We should let the code do what it used to do, which is throw an exception, not return a success code!", "bodyHTML": "<p dir=\"auto\">Isn't this check now redundant, given there is code in <code>CreateSourceFactory</code> to do this now?  We should let the code do what it used to do, which is throw an exception, not return a success code!</p>", "author": "big-andy-coates", "createdAt": "2020-09-11T10:46:57Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java", "diffHunk": "@@ -66,6 +66,16 @@ private Executor(final String sql, final boolean withQuery) {\n \n     @Override\n     public DdlCommandResult executeCreateStream(final CreateStreamCommand createStream) {\n+      final SourceName sourceName = createStream.getSourceName();\n+      final DataSource dataSource = metaStore.getSource(sourceName);\n+\n+      if (dataSource != null && !createStream.isOrReplace()) {\n+        return new DdlCommandResult(true,\n+            String.format(\"Cannot add stream %s: A stream with the same name \"\n+                    + \"already exists.\",\n+                sourceName));\n+      }", "originalCommit": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQzNzA1Ng==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r495437056", "bodyText": "@big-andy-coates The code in CreateSourceFactory checks if a dataSource  already exists , if isOrReplace() is not set and ifNotExists is also not set and throws exception , which seems right\nIf the code passes the checks in that gate ,it means in DdlCommandExec it would mean the ifNotExists flag is set to true and we need to ensure that the statement does NOT fail ?", "author": "hemantgs", "createdAt": "2020-09-26T09:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NDkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAxNjc4MA==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r516016780", "bodyText": "Seems redundant, but it is what DROP IF NOT EXIST does too. It has a check in the DropSourceCommand and another in this class, which returns the DdlCommandResult message without causing a failure.", "author": "spena", "createdAt": "2020-11-02T14:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NDkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk0NDEyNg==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r518944126", "bodyText": "I figured out why we need this repeated code. Turns out that CreateSourceFactory is only called for CREATE without queries statements. For CREATE AS, a different code path is called, which creates the Create command similar to the CreateSourceFactory, but without the factory validations and with more parameters. That path is EngineExecutor.maybeCreateSinkDdl.\nI was thinking on refactor the code, but seems it requires several changes. For now, I leave this temporary and do a check inside the maybeCreateSinkDdl for the isNotExists value. I'll do the refactor in another PR.", "author": "spena", "createdAt": "2020-11-06T18:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NDkxMA=="}], "type": "inlineReview", "revised_code": {"commit": "2965dcdfbf2497364f33506bc22997f9f2bded83", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex cc22c52acba..0586b2453a0 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -51,66 +58,54 @@ public class DdlCommandExec {\n   public DdlCommandResult execute(\n       final String sql,\n       final DdlCommand ddlCommand,\n-      final boolean withQuery) {\n-    return new Executor(sql, withQuery).execute(ddlCommand);\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources\n+  ) {\n+    return new Executor(sql, withQuery, withQuerySources).execute(ddlCommand);\n   }\n \n   private final class Executor implements io.confluent.ksql.execution.ddl.commands.Executor {\n     private final String sql;\n     private final boolean withQuery;\n+    private final Set<SourceName> withQuerySources;\n \n-    private Executor(final String sql, final boolean withQuery) {\n+    private Executor(\n+        final String sql,\n+        final boolean withQuery,\n+        final Set<SourceName> withQuerySources\n+    ) {\n       this.sql = Objects.requireNonNull(sql, \"sql\");\n       this.withQuery = withQuery;\n+      this.withQuerySources = Objects.requireNonNull(withQuerySources, \"withQuerySources\");\n     }\n \n     @Override\n     public DdlCommandResult executeCreateStream(final CreateStreamCommand createStream) {\n-      final SourceName sourceName = createStream.getSourceName();\n-      final DataSource dataSource = metaStore.getSource(sourceName);\n-\n-      if (dataSource != null && !createStream.isOrReplace()) {\n-        return new DdlCommandResult(true,\n-            String.format(\"Cannot add stream %s: A stream with the same name \"\n-                    + \"already exists.\",\n-                sourceName));\n-      }\n-\n       final KsqlStream<?> ksqlStream = new KsqlStream<>(\n           sql,\n           createStream.getSourceName(),\n           createStream.getSchema(),\n-          createStream.getFormats().getOptions(),\n           createStream.getTimestampColumn(),\n           withQuery,\n           getKsqlTopic(createStream)\n       );\n-\n       metaStore.putSource(ksqlStream, createStream.isOrReplace());\n+      metaStore.addSourceReferences(ksqlStream.getName(), withQuerySources);\n       return new DdlCommandResult(true, \"Stream created\");\n     }\n \n     @Override\n     public DdlCommandResult executeCreateTable(final CreateTableCommand createTable) {\n-      final SourceName sourceName = createTable.getSourceName();\n-      final DataSource dataSource = metaStore.getSource(sourceName);\n-\n-      if (dataSource != null && !createTable.isOrReplace()) {\n-        return new DdlCommandResult(true,\n-            String.format(\"Cannot add table %s: A table with the same name \"\n-                    + \"already exists.\",\n-                sourceName));\n-      }\n       final KsqlTable<?> ksqlTable = new KsqlTable<>(\n           sql,\n           createTable.getSourceName(),\n           createTable.getSchema(),\n-          createTable.getFormats().getOptions(),\n           createTable.getTimestampColumn(),\n           withQuery,\n           getKsqlTopic(createTable)\n       );\n       metaStore.putSource(ksqlTable, createTable.isOrReplace());\n+      metaStore.addSourceReferences(ksqlTable.getName(), withQuerySources);\n       return new DdlCommandResult(true, \"Table created\");\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex cc22c52acba..94a587fdc2f 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -70,23 +85,24 @@ public class DdlCommandExec {\n       final DataSource dataSource = metaStore.getSource(sourceName);\n \n       if (dataSource != null && !createStream.isOrReplace()) {\n+        final String sourceType = dataSource.getDataSourceType().getKsqlType();\n         return new DdlCommandResult(true,\n-            String.format(\"Cannot add stream %s: A stream with the same name \"\n+            String.format(\"Cannot add stream %s: A %s with the same name \"\n                     + \"already exists.\",\n-                sourceName));\n+                sourceName, sourceType.toLowerCase()));\n       }\n \n       final KsqlStream<?> ksqlStream = new KsqlStream<>(\n           sql,\n           createStream.getSourceName(),\n           createStream.getSchema(),\n-          createStream.getFormats().getOptions(),\n           createStream.getTimestampColumn(),\n           withQuery,\n           getKsqlTopic(createStream)\n       );\n \n       metaStore.putSource(ksqlStream, createStream.isOrReplace());\n+      metaStore.addSourceReferences(ksqlStream.getName(), withQuerySources);\n       return new DdlCommandResult(true, \"Stream created\");\n     }\n \n", "next_change": {"commit": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 94a587fdc2f..5cac8a2b6e5 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -98,7 +98,8 @@ public class DdlCommandExec {\n           createStream.getSchema(),\n           createStream.getTimestampColumn(),\n           withQuery,\n-          getKsqlTopic(createStream)\n+          getKsqlTopic(createStream),\n+          createStream.getIsSource()\n       );\n \n       metaStore.putSource(ksqlStream, createStream.isOrReplace());\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "70565f2969df109c6fd4ae6bb7c48c5365c45f9d", "committedDate": "2021-08-11 16:10:36 -0500", "message": "feat: add CREATE SOURCE TABLE syntax and metadata info (#7945)"}, {"oid": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "committedDate": "2021-08-18 12:27:21 -0700", "message": "feat: add CREATE SOURCE STREAM syntax and metadata info (#8004)"}, {"oid": "e2c3211c23eac9c92806d013c7ad8e4f1bef7ae7", "committedDate": "2021-08-27 22:01:18 -0500", "message": "feat: execute source table query plans (#8061)"}, {"oid": "db070a211b51cfb9ef7138c9b05238ba41798f4b", "committedDate": "2022-02-25 13:58:08 -0600", "message": "fix: restore process fails due to DROP constraints (#8803)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NTAzMg==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r486965032", "body": "Isn't this check now redundant, given there is code in `CreateSourceFactory` to do this now?  We should let the code do what it used to do, which is throw an exception, not return a success code!", "bodyText": "Isn't this check now redundant, given there is code in CreateSourceFactory to do this now?  We should let the code do what it used to do, which is throw an exception, not return a success code!", "bodyHTML": "<p dir=\"auto\">Isn't this check now redundant, given there is code in <code>CreateSourceFactory</code> to do this now?  We should let the code do what it used to do, which is throw an exception, not return a success code!</p>", "author": "big-andy-coates", "createdAt": "2020-09-11T10:47:10Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java", "diffHunk": "@@ -75,12 +85,22 @@ public DdlCommandResult executeCreateStream(final CreateStreamCommand createStre\n           withQuery,\n           getKsqlTopic(createStream)\n       );\n+\n       metaStore.putSource(ksqlStream, createStream.isOrReplace());\n       return new DdlCommandResult(true, \"Stream created\");\n     }\n \n     @Override\n     public DdlCommandResult executeCreateTable(final CreateTableCommand createTable) {\n+      final SourceName sourceName = createTable.getSourceName();\n+      final DataSource dataSource = metaStore.getSource(sourceName);\n+\n+      if (dataSource != null && !createTable.isOrReplace()) {\n+        return new DdlCommandResult(true,\n+            String.format(\"Cannot add table %s: A table with the same name \"\n+                    + \"already exists.\",\n+                sourceName));\n+      }", "originalCommit": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex cc22c52acba..3ec826835f7 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -105,12 +120,12 @@ public class DdlCommandExec {\n           sql,\n           createTable.getSourceName(),\n           createTable.getSchema(),\n-          createTable.getFormats().getOptions(),\n           createTable.getTimestampColumn(),\n           withQuery,\n           getKsqlTopic(createTable)\n       );\n       metaStore.putSource(ksqlTable, createTable.isOrReplace());\n+      metaStore.addSourceReferences(ksqlTable.getName(), withQuerySources);\n       return new DdlCommandResult(true, \"Table created\");\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex cc22c52acba..94a587fdc2f 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -96,21 +112,22 @@ public class DdlCommandExec {\n       final DataSource dataSource = metaStore.getSource(sourceName);\n \n       if (dataSource != null && !createTable.isOrReplace()) {\n+        final String sourceType = dataSource.getDataSourceType().getKsqlType();\n         return new DdlCommandResult(true,\n-            String.format(\"Cannot add table %s: A table with the same name \"\n+            String.format(\"Cannot add table %s: A %s with the same name \"\n                     + \"already exists.\",\n-                sourceName));\n+                sourceName, sourceType.toLowerCase()));\n       }\n       final KsqlTable<?> ksqlTable = new KsqlTable<>(\n           sql,\n           createTable.getSourceName(),\n           createTable.getSchema(),\n-          createTable.getFormats().getOptions(),\n           createTable.getTimestampColumn(),\n           withQuery,\n           getKsqlTopic(createTable)\n       );\n       metaStore.putSource(ksqlTable, createTable.isOrReplace());\n+      metaStore.addSourceReferences(ksqlTable.getName(), withQuerySources);\n       return new DdlCommandResult(true, \"Table created\");\n     }\n \n", "next_change": {"commit": "70565f2969df109c6fd4ae6bb7c48c5365c45f9d", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 94a587fdc2f..5b863f6adda 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -118,13 +118,15 @@ public class DdlCommandExec {\n                     + \"already exists.\",\n                 sourceName, sourceType.toLowerCase()));\n       }\n+\n       final KsqlTable<?> ksqlTable = new KsqlTable<>(\n           sql,\n           createTable.getSourceName(),\n           createTable.getSchema(),\n           createTable.getTimestampColumn(),\n           withQuery,\n-          getKsqlTopic(createTable)\n+          getKsqlTopic(createTable),\n+          createTable.isSource()\n       );\n       metaStore.putSource(ksqlTable, createTable.isOrReplace());\n       metaStore.addSourceReferences(ksqlTable.getName(), withQuerySources);\n", "next_change": {"commit": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 5b863f6adda..5cac8a2b6e5 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -126,7 +127,7 @@ public class DdlCommandExec {\n           createTable.getTimestampColumn(),\n           withQuery,\n           getKsqlTopic(createTable),\n-          createTable.isSource()\n+          createTable.getIsSource()\n       );\n       metaStore.putSource(ksqlTable, createTable.isOrReplace());\n       metaStore.addSourceReferences(ksqlTable.getName(), withQuerySources);\n", "next_change": {"commit": "e2c3211c23eac9c92806d013c7ad8e4f1bef7ae7", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 5cac8a2b6e5..259d04e5d88 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -130,7 +130,13 @@ public class DdlCommandExec {\n           createTable.getIsSource()\n       );\n       metaStore.putSource(ksqlTable, createTable.isOrReplace());\n-      metaStore.addSourceReferences(ksqlTable.getName(), withQuerySources);\n+\n+      // Source tables only has a query source reference to itself. We don't need to register\n+      // this source for source tables.\n+      if (!createTable.getIsSource()) {\n+        metaStore.addSourceReferences(ksqlTable.getName(), withQuerySources);\n+      }\n+\n       return new DdlCommandResult(true, \"Table created\");\n     }\n \n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "70565f2969df109c6fd4ae6bb7c48c5365c45f9d", "committedDate": "2021-08-11 16:10:36 -0500", "message": "feat: add CREATE SOURCE TABLE syntax and metadata info (#7945)"}, {"oid": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "committedDate": "2021-08-18 12:27:21 -0700", "message": "feat: add CREATE SOURCE STREAM syntax and metadata info (#8004)"}, {"oid": "e2c3211c23eac9c92806d013c7ad8e4f1bef7ae7", "committedDate": "2021-08-27 22:01:18 -0500", "message": "feat: execute source table query plans (#8061)"}, {"oid": "db070a211b51cfb9ef7138c9b05238ba41798f4b", "committedDate": "2022-02-25 13:58:08 -0600", "message": "fix: restore process fails due to DROP constraints (#8803)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NTY0OA==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r486965648", "body": "Add another two tests testing it does NOT throw if `IF NOT EXIST` is set.", "bodyText": "Add another two tests testing it does NOT throw if IF NOT EXIST is set.", "bodyHTML": "<p dir=\"auto\">Add another two tests testing it does NOT throw if <code>IF NOT EXIST</code> is set.</p>", "author": "big-andy-coates", "createdAt": "2020-09-11T10:48:20Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java", "diffHunk": "@@ -904,6 +921,41 @@ public void shouldThrowIfTableIsMissingPrimaryKey() {\n         containsString(\"Tables require a PRIMARY KEY. Please define the PRIMARY KEY.\"));\n   }\n \n+  @Test\n+  public void shouldThrowIfStreamExits() {\n+    // Given:\n+    final CreateStream ddlStatement =\n+        new CreateStream(SOME_NAME, STREAM_ELEMENTS, false, false, withProperties);\n+\n+    // When:\n+    final Exception e = assertThrows(\n+        KsqlException.class, () -> createSourceFactory\n+            .createStreamCommand(ddlStatement, ksqlConfig));\n+\n+    // Then:\n+    assertThat(e.getMessage(),\n+        containsString(\"A STREAM with the same name already exists\"));\n+  }\n+\n+  @Test\n+  public void shouldThrowIfTableExits() {\n+    //Given\n+    final CreateTable ddlStatement = new CreateTable(TABLE_NAME,\n+        TableElements.of(\n+            tableElement(PRIMARY_KEY, \"COL1\", new Type(BIGINT)),\n+            tableElement(VALUE, \"COL2\", new Type(SqlTypes.STRING))),\n+        false, false, withProperties);\n+\n+    // When:\n+    final Exception e = assertThrows(\n+        KsqlException.class, () -> createSourceFactory\n+            .createTableCommand(ddlStatement, ksqlConfig));\n+\n+    // Then:\n+    assertThat(e.getMessage(),\n+        containsString(\"A TABLE with the same name already exists\"));\n+  }", "originalCommit": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "678163151432e1e935c4acbb426f41b75b22b488", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\nindex ba99c2a130f..79f38a71e1e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n", "chunk": "@@ -953,7 +961,7 @@ public class CreateSourceFactoryTest {\n \n     // Then:\n     assertThat(e.getMessage(),\n-        containsString(\"A TABLE with the same name already exists\"));\n+        containsString(\"Cannot add table 'table_bob': A table with the same name already exists\"));\n   }\n \n   private void givenProperty(final String name, final Literal value) {\n", "next_change": {"commit": "2965dcdfbf2497364f33506bc22997f9f2bded83", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\nindex 79f38a71e1e..0533cad186c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n", "chunk": "@@ -929,41 +1014,6 @@ public class CreateSourceFactoryTest {\n         containsString(\"Tables require a PRIMARY KEY. Please define the PRIMARY KEY.\"));\n   }\n \n-  @Test\n-  public void shouldThrowIfStreamExits() {\n-    // Given:\n-    final CreateStream ddlStatement =\n-        new CreateStream(SOME_NAME, STREAM_ELEMENTS, false, false, withProperties);\n-\n-    // When:\n-    final Exception e = assertThrows(\n-        KsqlException.class, () -> createSourceFactory\n-            .createStreamCommand(ddlStatement, ksqlConfig));\n-\n-    // Then:\n-    assertThat(e.getMessage(),\n-        containsString(\"Cannot add stream 'bob': A stream with the same name already exists\"));\n-  }\n-\n-  @Test\n-  public void shouldThrowIfTableExits() {\n-    //Given\n-    final CreateTable ddlStatement = new CreateTable(TABLE_NAME,\n-        TableElements.of(\n-            tableElement(PRIMARY_KEY, \"COL1\", new Type(BIGINT)),\n-            tableElement(VALUE, \"COL2\", new Type(SqlTypes.STRING))),\n-        false, false, withProperties);\n-\n-    // When:\n-    final Exception e = assertThrows(\n-        KsqlException.class, () -> createSourceFactory\n-            .createTableCommand(ddlStatement, ksqlConfig));\n-\n-    // Then:\n-    assertThat(e.getMessage(),\n-        containsString(\"Cannot add table 'table_bob': A table with the same name already exists\"));\n-  }\n-\n   private void givenProperty(final String name, final Literal value) {\n     givenProperties(ImmutableMap.of(name, value));\n   }\n", "next_change": {"commit": "b01aebc5c183bccf95895a9952edd7e40aed243f", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\nindex 0533cad186c..e3a8be69f87 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n", "chunk": "@@ -1014,6 +1020,41 @@ public class CreateSourceFactoryTest {\n         containsString(\"Tables require a PRIMARY KEY. Please define the PRIMARY KEY.\"));\n   }\n \n+  @Test\n+  public void shouldThrowIfStreamExits() {\n+    // Given:\n+    final CreateStream ddlStatement =\n+        new CreateStream(SOME_NAME, STREAM_ELEMENTS, false, false, withProperties);\n+\n+    // When:\n+    final Exception e = assertThrows(\n+        KsqlException.class, () -> createSourceFactory\n+            .createStreamCommand(ddlStatement, ksqlConfig));\n+\n+    // Then:\n+    assertThat(e.getMessage(),\n+        containsString(\"A STREAM with the same name already exists\"));\n+  }\n+\n+  @Test\n+  public void shouldThrowIfTableExits() {\n+    //Given\n+    final CreateTable ddlStatement = new CreateTable(TABLE_NAME,\n+        TableElements.of(\n+            tableElement(PRIMARY_KEY, \"COL1\", new Type(BIGINT)),\n+            tableElement(VALUE, \"COL2\", new Type(SqlTypes.STRING))),\n+        false, false, withProperties);\n+\n+    // When:\n+    final Exception e = assertThrows(\n+        KsqlException.class, () -> createSourceFactory\n+            .createTableCommand(ddlStatement, ksqlConfig));\n+\n+    // Then:\n+    assertThat(e.getMessage(),\n+        containsString(\"A TABLE with the same name already exists\"));\n+  }\n+\n   private void givenProperty(final String name, final Literal value) {\n     givenProperties(ImmutableMap.of(name, value));\n   }\n", "next_change": {"commit": "6bc0a99931a32165c416d02b1de6a9bb90325caf", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\nindex e3a8be69f87..6c4729f2165 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n", "chunk": "@@ -1052,7 +1052,7 @@ public class CreateSourceFactoryTest {\n \n     // Then:\n     assertThat(e.getMessage(),\n-        containsString(\"A TABLE with the same name already exists\"));\n+        containsString(\"Cannot add table 'table_bob': A table with the same name already exists\"));\n   }\n \n   private void givenProperty(final String name, final Literal value) {\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\nindex ba99c2a130f..0560d554788 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n", "chunk": "@@ -953,7 +1095,7 @@ public class CreateSourceFactoryTest {\n \n     // Then:\n     assertThat(e.getMessage(),\n-        containsString(\"A TABLE with the same name already exists\"));\n+        containsString(\"Cannot add table 'table_bob': A table with the same name already exists\"));\n   }\n \n   private void givenProperty(final String name, final Literal value) {\n", "next_change": {"commit": "abe47c335e148c41befa5213e6f116474128ec4b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\nindex 0560d554788..f4f23cc0ff4 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n", "chunk": "@@ -1098,6 +1141,99 @@ public class CreateSourceFactoryTest {\n         containsString(\"Cannot add table 'table_bob': A table with the same name already exists\"));\n   }\n \n+  @Test\n+  public void shouldThrowInCreateStreamOrReplaceSource() {\n+    // Given:\n+    final CreateStream ddlStatement =\n+        new CreateStream(SOME_NAME, STREAM_ELEMENTS, true, false, withProperties, true);\n+\n+    // When:\n+    final Exception e = assertThrows(\n+        KsqlException.class, () -> createSourceFactory\n+            .createStreamCommand(ddlStatement, ksqlConfig));\n+\n+    // Then:\n+    assertThat(e.getMessage(),\n+        containsString(\n+            \"Cannot add stream 'bob': CREATE OR REPLACE is not supported on \"\n+                + \"source streams.\"));\n+  }\n+\n+  @Test\n+  public void shouldThrowInCreateStreamOrReplaceOnSourceStreams() {\n+    // Given:\n+    final SourceName existingStreamName = SourceName.of(\"existingStreamName\");\n+    final KsqlStream existingStream = mock(KsqlStream.class);\n+\n+    when(existingStream.getDataSourceType()).thenReturn(DataSourceType.KSTREAM);\n+    when(existingStream.isSource()).thenReturn(true);\n+    when(metaStore.getSource(existingStreamName)).thenReturn(existingStream);\n+\n+    final CreateStream ddlStatement =\n+        new CreateStream(existingStreamName,\n+            STREAM_ELEMENTS, true, false, withProperties, false);\n+\n+    // When:\n+    final Exception e = assertThrows(\n+        KsqlException.class, () -> createSourceFactory\n+            .createStreamCommand(ddlStatement, ksqlConfig));\n+\n+    // Then:\n+    assertThat(e.getMessage(),\n+        containsString(\n+            \"Cannot add stream 'existingStreamName': CREATE OR REPLACE is not supported on \"\n+                + \"source streams.\"));\n+  }\n+\n+  @Test\n+  public void shouldThrowInCreateTableOrReplaceSource() {\n+    // Given:\n+    final CreateTable ddlStatement = new CreateTable(TABLE_NAME,\n+        TableElements.of(\n+            tableElement(PRIMARY_KEY, \"COL1\", new Type(BIGINT)),\n+            tableElement(VALUE, \"COL2\", new Type(SqlTypes.STRING))),\n+        true, false, withProperties, true);\n+\n+    // When:\n+    final Exception e = assertThrows(\n+        KsqlException.class, () -> createSourceFactory\n+            .createTableCommand(ddlStatement, ksqlConfig));\n+\n+    // Then:\n+    assertThat(e.getMessage(),\n+        containsString(\n+            \"Cannot add table 'table_bob': CREATE OR REPLACE is not supported on \"\n+                + \"source tables.\"));\n+  }\n+\n+  @Test\n+  public void shouldThrowInCreateStreamOrReplaceOnSourceTables() {\n+    // Given:\n+    final SourceName existingTableName = SourceName.of(\"existingTableName\");\n+    final KsqlTable existingTable = mock(KsqlTable.class);\n+\n+    when(existingTable.getDataSourceType()).thenReturn(DataSourceType.KTABLE);\n+    when(existingTable.isSource()).thenReturn(true);\n+    when(metaStore.getSource(existingTableName)).thenReturn(existingTable);\n+\n+    final CreateTable ddlStatement = new CreateTable(existingTableName,\n+        TableElements.of(\n+            tableElement(PRIMARY_KEY, \"COL1\", new Type(BIGINT)),\n+            tableElement(VALUE, \"COL2\", new Type(SqlTypes.STRING))),\n+        true, false, withProperties, false);\n+\n+    // When:\n+    final Exception e = assertThrows(\n+        KsqlException.class, () -> createSourceFactory\n+            .createTableCommand(ddlStatement, ksqlConfig));\n+\n+    // Then:\n+    assertThat(e.getMessage(),\n+        containsString(\n+            \"Cannot add table 'existingTableName': CREATE OR REPLACE is not supported on \"\n+                + \"source tables.\"));\n+  }\n+\n   private void givenProperty(final String name, final Literal value) {\n     givenProperties(ImmutableMap.of(name, value));\n   }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "9988e6af3266319e8caf978a904f5d55c8986623", "committedDate": "2021-02-05 16:26:35 -0800", "message": "Revert \"fix: throw error message on create source with no value columns (#6680)\" (#6959)"}, {"oid": "6cdce0a2632bd0512407e4a9e7d27b58fd1df1e6", "committedDate": "2021-05-23 08:25:17 -0700", "message": "chore: add FK-join logical to physical plan translation (#7570)"}, {"oid": "70565f2969df109c6fd4ae6bb7c48c5365c45f9d", "committedDate": "2021-08-11 16:10:36 -0500", "message": "feat: add CREATE SOURCE TABLE syntax and metadata info (#7945)"}, {"oid": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "committedDate": "2021-08-18 12:27:21 -0700", "message": "feat: add CREATE SOURCE STREAM syntax and metadata info (#8004)"}, {"oid": "abe47c335e148c41befa5213e6f116474128ec4b", "committedDate": "2021-09-30 16:25:12 -0500", "message": "chore: disable CREATE OR REPLACE on source streams and tables (#8199)"}, {"oid": "db76b3ec11c97edf7ba870a073e5805c340b9ec6", "committedDate": "2021-11-15 13:55:38 -0800", "message": "feat: add syntax for HEADER(<key>) columns (#8350)"}, {"oid": "31d7456a03b03d46b9de33622c75b53b54c80c7f", "committedDate": "2021-11-30 10:22:32 -0800", "message": "chore: add key/value schema name prop and refactor (#8418)"}, {"oid": "2af201f45f45092d596a4844ca5f139455328844", "committedDate": "2022-07-07 14:15:28 -0700", "message": "feat: enable new emit-final implementation (#9141)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NTg3Ng==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r486965876", "body": "This test change should be reverted, right?  ", "bodyText": "This test change should be reverted, right?", "bodyHTML": "<p dir=\"auto\">This test change should be reverted, right?</p>", "author": "big-andy-coates", "createdAt": "2020-09-11T10:48:51Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DdlCommandExecTest.java", "diffHunk": "@@ -271,17 +271,18 @@ public void shouldDropMissingType() {\n   }\n \n   @Test\n-  public void shouldFailAddDuplicateStreamWithoutReplace() {\n+  public void shouldWarnAddDuplicateStreamWithoutReplace() {\n     // Given:\n     givenCreateStream();\n     cmdExec.execute(SQL_TEXT, createStream, false);\n \n     // When:\n     givenCreateStream(SCHEMA2, false);\n-    final KsqlException e = assertThrows(KsqlException.class, () -> cmdExec.execute(SQL_TEXT, createStream, false));\n+    final DdlCommandResult result =cmdExec.execute(SQL_TEXT, createStream, false);\n \n     // Then:\n-    assertThat(e.getMessage(), containsString(\"A stream with the same name already exists\"));\n+    assertThat(\"Expected successful execution\", result.isSuccess());\n+    assertThat(result.getMessage(), containsString(\"A stream with the same name already exists\"));", "originalCommit": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DdlCommandExecTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DdlCommandExecTest.java\nindex e9218243365..7c4b4940c2a 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DdlCommandExecTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DdlCommandExecTest.java\n", "chunk": "@@ -274,19 +453,40 @@ public class DdlCommandExecTest {\n   public void shouldWarnAddDuplicateStreamWithoutReplace() {\n     // Given:\n     givenCreateStream();\n-    cmdExec.execute(SQL_TEXT, createStream, false);\n+    cmdExec.execute(SQL_TEXT, createStream, false, NO_QUERY_SOURCES);\n \n     // When:\n     givenCreateStream(SCHEMA2, false);\n-    final DdlCommandResult result =cmdExec.execute(SQL_TEXT, createStream, false);\n+    final DdlCommandResult result =cmdExec.execute(SQL_TEXT, createStream,\n+        false, NO_QUERY_SOURCES);\n \n     // Then:\n     assertThat(\"Expected successful execution\", result.isSuccess());\n     assertThat(result.getMessage(), containsString(\"A stream with the same name already exists\"));\n   }\n \n+  @Test\n+  public void shouldWarnAddDuplicateTableWithoutReplace() {\n+    // Given:\n+    givenCreateTable();\n+    cmdExec.execute(SQL_TEXT, createTable, false, NO_QUERY_SOURCES);\n+\n+    // When:\n+    givenCreateTable(false);\n+    final DdlCommandResult result =cmdExec.execute(SQL_TEXT, createTable,\n+        false, NO_QUERY_SOURCES);\n+\n+    // Then:\n+    assertThat(\"Expected successful execution\", result.isSuccess());\n+    assertThat(result.getMessage(), containsString(\"A table with the same name already exists\"));\n+  }\n+\n   private void givenDropSourceCommand(final SourceName name) {\n-    dropSource = new DropSourceCommand(name);\n+    dropSource = buildDropSourceCommand(name);\n+  }\n+\n+  private DropSourceCommand buildDropSourceCommand(final SourceName name) {\n+    return new DropSourceCommand(name);\n   }\n \n   private void givenCreateStream() {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DdlCommandExecTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DdlCommandExecTest.java\nindex e9218243365..9e65a0722dc 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DdlCommandExecTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DdlCommandExecTest.java\n", "chunk": "@@ -274,19 +451,40 @@ public class DdlCommandExecTest {\n   public void shouldWarnAddDuplicateStreamWithoutReplace() {\n     // Given:\n     givenCreateStream();\n-    cmdExec.execute(SQL_TEXT, createStream, false);\n+    cmdExec.execute(SQL_TEXT, createStream, false, NO_QUERY_SOURCES);\n \n     // When:\n     givenCreateStream(SCHEMA2, false);\n-    final DdlCommandResult result =cmdExec.execute(SQL_TEXT, createStream, false);\n+    final DdlCommandResult result =cmdExec.execute(SQL_TEXT, createStream,\n+        false, NO_QUERY_SOURCES);\n \n     // Then:\n     assertThat(\"Expected successful execution\", result.isSuccess());\n     assertThat(result.getMessage(), containsString(\"A stream with the same name already exists\"));\n   }\n \n+  @Test\n+  public void shouldWarnAddDuplicateTableWithoutReplace() {\n+    // Given:\n+    givenCreateTable();\n+    cmdExec.execute(SQL_TEXT, createTable, false, NO_QUERY_SOURCES);\n+\n+    // When:\n+    givenCreateTable(false);\n+    final DdlCommandResult result =cmdExec.execute(SQL_TEXT, createTable,\n+        false, NO_QUERY_SOURCES);\n+\n+    // Then:\n+    assertThat(\"Expected successful execution\", result.isSuccess());\n+    assertThat(result.getMessage(), containsString(\"A table with the same name already exists\"));\n+  }\n+\n   private void givenDropSourceCommand(final SourceName name) {\n-    dropSource = new DropSourceCommand(name);\n+    dropSource = buildDropSourceCommand(name);\n+  }\n+\n+  private DropSourceCommand buildDropSourceCommand(final SourceName name) {\n+    return new DropSourceCommand(name);\n   }\n \n   private void givenCreateStream() {\n", "next_change": {"commit": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DdlCommandExecTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DdlCommandExecTest.java\nindex 9e65a0722dc..f4aaed85857 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DdlCommandExecTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/DdlCommandExecTest.java\n", "chunk": "@@ -492,13 +566,14 @@ public class DdlCommandExecTest {\n   }\n \n   private void givenCreateStream(final LogicalSchema schema, final boolean allowReplace) {\n-    createStream = buildCreateStream(STREAM_NAME, schema, allowReplace);\n+    createStream = buildCreateStream(STREAM_NAME, schema, allowReplace, false);\n   }\n \n   private CreateStreamCommand buildCreateStream(\n       final SourceName streamName,\n       final LogicalSchema schema,\n-      final boolean allowReplace\n+      final boolean allowReplace,\n+      final Boolean isSource\n   ) {\n     return new CreateStreamCommand(\n         streamName,\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "70565f2969df109c6fd4ae6bb7c48c5365c45f9d", "committedDate": "2021-08-11 16:10:36 -0500", "message": "feat: add CREATE SOURCE TABLE syntax and metadata info (#7945)"}, {"oid": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "committedDate": "2021-08-18 12:27:21 -0700", "message": "feat: add CREATE SOURCE STREAM syntax and metadata info (#8004)"}, {"oid": "e2c3211c23eac9c92806d013c7ad8e4f1bef7ae7", "committedDate": "2021-08-27 22:01:18 -0500", "message": "feat: execute source table query plans (#8061)"}, {"oid": "0c7da2ea0432c8adb1f137303e7780a7d402d11a", "committedDate": "2021-12-09 19:15:30 -0800", "message": "test: add functional tests for INSERT statements with headers (#8471)"}, {"oid": "db070a211b51cfb9ef7138c9b05238ba41798f4b", "committedDate": "2022-02-25 13:58:08 -0600", "message": "fix: restore process fails due to DROP constraints (#8803)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NjYwNw==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r486966607", "body": "This change should be reverted.", "bodyText": "This change should be reverted.", "bodyHTML": "<p dir=\"auto\">This change should be reverted.</p>", "author": "big-andy-coates", "createdAt": "2020-09-11T10:50:20Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java", "diffHunk": "@@ -981,27 +981,21 @@ public void shouldNotThrowWhenPreparingDuplicateTable() {\n   public void shouldThrowWhenExecutingDuplicateTable() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n-        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"", "originalCommit": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI1ODY0Ng==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r523258646", "bodyText": "This is a new test now that verifies the IF NOT EXISTS works.", "author": "spena", "createdAt": "2020-11-13T22:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NjYwNw=="}], "type": "inlineReview", "revised_code": {"commit": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c184ebae989..8ff4500153e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -978,26 +1216,59 @@ public class KsqlEngineTest {\n   }\n \n   @Test\n-  public void shouldThrowWhenExecutingDuplicateTable() {\n+  public void shouldNotThrowWhenExecutingDuplicateTableWithIfNotExists() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n         \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+            + \"CREATE TABLE IF NOT EXISTS FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, new HashMap<>(), KSQL_CONFIG)\n+        serviceContext, ConfiguredStatement.\n+            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n+    // Ideally, the result should be a message the the stream already exists, but in this case\n+    // it returns the same Query ID that it was created by the first stream. Some code refactoring\n+    // is needed in EngineExecutor.execute() and other places to validate the cases when a\n+    // CREATE IF NOT EXISTS return a warning message only, and not an error. For now, this is a\n+    // temporary solution.\n     assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n+  @Test\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n+    // Given:\n+    final List<ParsedStatement> parsed = ksqlEngine.parse(\n+        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+\n+    givenStatementAlreadyExecuted(parsed.get(0));\n+\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+\n+    // When:\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n+    );\n+\n+    // Then:\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add table 'FOO': A table with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n+  }\n+\n   @Test\n   public void shouldThrowWhenPreparingUnknownSource() {\n     // Given:\n", "next_change": {"commit": "b01aebc5c183bccf95895a9952edd7e40aed243f", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex 8ff4500153e..c7e24a878fd 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1216,59 +1267,26 @@ public class KsqlEngineTest {\n   }\n \n   @Test\n-  public void shouldNotThrowWhenExecutingDuplicateTableWithIfNotExists() {\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n         \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE IF NOT EXISTS FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext, ConfiguredStatement.\n-            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        serviceContext,\n+        of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n-    // Ideally, the result should be a message the the stream already exists, but in this case\n-    // it returns the same Query ID that it was created by the first stream. Some code refactoring\n-    // is needed in EngineExecutor.execute() and other places to validate the cases when a\n-    // CREATE IF NOT EXISTS return a warning message only, and not an error. For now, this is a\n-    // temporary solution.\n     assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n-  @Test\n-  public void shouldThrowWhenExecutingDuplicateTable() {\n-    // Given:\n-    final List<ParsedStatement> parsed = ksqlEngine.parse(\n-        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n-\n-    givenStatementAlreadyExecuted(parsed.get(0));\n-\n-    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n-\n-    // When:\n-    final KsqlStatementException e = assertThrows(\n-        KsqlStatementException.class,\n-        () -> ksqlEngine.execute(\n-            serviceContext,\n-            ConfiguredStatement\n-                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n-        )\n-    );\n-\n-    // Then:\n-    assertThat(e, rawMessage(is(\n-        \"Cannot add table 'FOO': A table with the same name already exists\")));\n-    assertThat(e, statementText(is(\n-        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n-  }\n-\n   @Test\n   public void shouldThrowWhenPreparingUnknownSource() {\n     // Given:\n", "next_change": {"commit": "ff9c504abdc3f4c58e8066e277b9ffc08ad12b6a", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c7e24a878fd..14ba7a3391c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1267,26 +1267,59 @@ public class KsqlEngineTest {\n   }\n \n   @Test\n-  public void shouldThrowWhenExecutingDuplicateTable() {\n+  public void shouldNotThrowWhenExecutingDuplicateTableWithIfNotExists() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n         \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+            + \"CREATE TABLE IF NOT EXISTS FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        serviceContext, ConfiguredStatement.\n+            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n+    // Ideally, the result should be a message the the stream already exists, but in this case\n+    // it returns the same Query ID that it was created by the first stream. Some code refactoring\n+    // is needed in EngineExecutor.execute() and other places to validate the cases when a\n+    // CREATE IF NOT EXISTS return a warning message only, and not an error. For now, this is a\n+    // temporary solution.\n     assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n+  @Test\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n+    // Given:\n+    final List<ParsedStatement> parsed = ksqlEngine.parse(\n+        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+\n+    givenStatementAlreadyExecuted(parsed.get(0));\n+\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+\n+    // When:\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n+    );\n+\n+    // Then:\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add table 'FOO': A table with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n+  }\n+\n   @Test\n   public void shouldThrowWhenPreparingUnknownSource() {\n     // Given:\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c184ebae989..b6b3364d6f2 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -978,24 +1267,54 @@ public class KsqlEngineTest {\n   }\n \n   @Test\n-  public void shouldThrowWhenExecutingDuplicateTable() {\n+  public void shouldNotThrowWhenExecutingDuplicateTableWithIfNotExists() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n         \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+            + \"CREATE TABLE IF NOT EXISTS FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, new HashMap<>(), KSQL_CONFIG)\n+        serviceContext, ConfiguredStatement.\n+            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+    );\n+\n+    // Then:\n+    assertThat(executeResult.getQuery(), is(Optional.empty()));\n+    assertThat(executeResult.getCommandResult(),\n+        is(Optional.of(\"Cannot add table `FOO`: A table with the same name already exists.\")));\n+  }\n+\n+  @Test\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n+    // Given:\n+    final List<ParsedStatement> parsed = ksqlEngine.parse(\n+        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+\n+    givenStatementAlreadyExecuted(parsed.get(0));\n+\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+\n+    // When:\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n     );\n \n     // Then:\n-    assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add table 'FOO': A table with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n   }\n \n   @Test\n", "next_change": null}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "20f631d97b887be07f7f7a2a19f0529aee573f12", "committedDate": "2020-12-10 16:23:28 -0800", "message": "chore: ungate protobuf and remove key.format.enabled config (#6754)"}, {"oid": "8c9e9280bb1f76f8d4ef88bae7c3e33426ff3d48", "committedDate": "2021-02-19 15:56:46 -0800", "message": "fix: incompatible schema causing KsqlEngineTest.shouldNotFailIfAvroSchemaEvolvable failure (#7052)"}, {"oid": "3c8d878ea19e177f458f1b6d9978264860072a0d", "committedDate": "2021-02-19 16:13:17 -0800", "message": "Merge branch '5.5.x' into 6.0.x"}, {"oid": "0de72a463263fc99da86f5dadc4dd6bad794ab21", "committedDate": "2021-02-19 16:13:28 -0800", "message": "Merge branch '6.0.x' into 6.1.x"}, {"oid": "dcce03f891451225a8f425f01eed5e4fc70e2e48", "committedDate": "2021-02-19 16:13:40 -0800", "message": "Merge branch '6.1.x'"}, {"oid": "f3838002fc4c8c085a3f62bfd34073e232416de4", "committedDate": "2021-03-09 21:03:59 -0800", "message": "fix: fix the cache max bytes buffering check (#7181)"}, {"oid": "3604bc86204bae486f6cab3b67a553fa246ad6ee", "committedDate": "2021-04-06 22:01:07 -0700", "message": "refactor: reorganize query management and clean up listeners (#7320)"}, {"oid": "2b7df17d64f4dec9dc5e42e0584dca7f52705c87", "committedDate": "2021-05-05 17:59:32 -0700", "message": "chore: refactor QueryMetadata and PersistentQueryMetadata (#7460)"}, {"oid": "eddac720fc5c045fd5f7059d90b0ed3c666f7bdc", "committedDate": "2021-07-20 15:02:10 -0500", "message": "[KCI-612] Clean up a terminated query's state stores (#7729)"}, {"oid": "9e532cecf7c76d893d8226e54701eee30b4a616b", "committedDate": "2021-08-25 20:18:33 -0500", "message": "refactor: make sink source optional in PersistentQueryMetadata (#8052)"}, {"oid": "44e812952daff844bc646cb92b935ac738f074c1", "committedDate": "2021-08-25 21:21:53 -0500", "message": "feat: shared runtimes (#7721)"}, {"oid": "e2c3211c23eac9c92806d013c7ad8e4f1bef7ae7", "committedDate": "2021-08-27 22:01:18 -0500", "message": "feat: execute source table query plans (#8061)"}, {"oid": "fb966001349fd6ba383764f547796ebc4982ec9c", "committedDate": "2021-08-30 14:34:27 -0500", "message": "chore: reject TERMINATE commands on CST tables (#8071)"}, {"oid": "4831e6b099cca2be51a659d2bb4112ead0cd8387", "committedDate": "2021-09-02 16:02:21 -0500", "message": "feat: introduce stream pull queries for HTTP/1 (#8064)"}, {"oid": "a14f957c1c094920b81552e87c15e72a34e93d0c", "committedDate": "2021-09-09 15:57:34 -0500", "message": "feat: disable stream pull queries by default (#8115)"}, {"oid": "f03755e2c965a3bd15f9090e2e1d8940ea4ecd3d", "committedDate": "2021-09-17 14:08:08 -0500", "message": "fix: CREATE OR REPLACE TABLE on an existing query fails while initializing the kafka streams (#8130)"}, {"oid": "a7c6ebeb946df62aed9d0ca1c8724e6f7dd6a18e", "committedDate": "2021-09-30 14:25:36 -0700", "message": "fix: ClassCastException when dropping sources with 2+ insert queries (#8205)"}, {"oid": "c317788c019889e1154a2b63855b0f8fadafa336", "committedDate": "2021-11-18 00:52:49 -0800", "message": "chore: refactor SharedKafkaStreamsRuntime into abstract class (#8355)"}, {"oid": "6c73a1438722f657c134345234c1be849c891d12", "committedDate": "2021-11-22 14:23:17 -0600", "message": "feat: clean up based on query id for shared runtimes (#8383)"}, {"oid": "cf831c5a3c8ef5ef70446a678be77ca87a08e67a", "committedDate": "2021-12-03 14:51:58 -0600", "message": "Kci 1081/implement endpoint for query scaling server configs (#8334)"}, {"oid": "0c7da2ea0432c8adb1f137303e7780a7d402d11a", "committedDate": "2021-12-09 19:15:30 -0800", "message": "test: add functional tests for INSERT statements with headers (#8471)"}, {"oid": "00072288077232aa3c97dde090879eccf256f633", "committedDate": "2021-12-13 20:21:23 -0600", "message": "refactor: eliminate static metrics registry (#8498)"}, {"oid": "df29d27707de96dcce97f81e76c98f225a7442d2", "committedDate": "2021-12-16 10:37:17 -0600", "message": "feat: new runtime selection (#8472)"}, {"oid": "fbecd71daca4cbe734cb69be2037cc9a36dbf994", "committedDate": "2021-12-17 10:48:54 -0600", "message": "feat: Drop query from assignor (#8523)"}, {"oid": "f42225d2061af37ba0edf04be94d1e6eebd061b9", "committedDate": "2022-01-18 14:52:37 -0800", "message": "fix: back out post-3.1 changes to fix 7.1.x build (#8599)"}, {"oid": "6c3320c670a86a380a46dfe4c7208fdaf1f9159c", "committedDate": "2022-01-19 22:39:25 -0800", "message": "Revert \"fix: back out post-3.1 changes to fix 7.1.x build (#8599)\""}, {"oid": "cd99f26aebffcbf55b29527effa394b9e1c2ee3a", "committedDate": "2022-01-27 08:53:54 -0600", "message": "fix: clean up custom prefixed internal topics (#8640)"}, {"oid": "53ddafe72dd8b2d284e9575cff856680b4280bba", "committedDate": "2022-03-07 18:17:23 -0600", "message": "fix: clean up mistaken topic names (#8857)"}, {"oid": "660c3256abd565067814e436d187d998cd8741b7", "committedDate": "2022-03-28 12:27:07 -0700", "message": "chore: remove SqlFormatInjector as obsolete (#8931)"}, {"oid": "db8e8bcb33d0c53bf2f5e71d5b802962a1a1294d", "committedDate": "2022-03-31 13:37:47 -0700", "message": "fix: preserve old schema behavior for protobuf wrapped primitives (#8934)"}, {"oid": "a4ef4d2377cda3e86e2c406238459e3405828cbd", "committedDate": "2022-03-31 20:35:28 -0700", "message": "chore: remove SqlFormatInjector as obsolete (7.0.x) (#8940)"}, {"oid": "aa458e0b076a249b6a63eed9ef9bd4ec87f30e46", "committedDate": "2022-03-31 20:38:32 -0700", "message": "Merge branch '7.0.x' into 7.1.x"}, {"oid": "20b75ea451468d7f80f905d46e5698a3979160a2", "committedDate": "2022-03-31 20:40:52 -0700", "message": "Merge branch '7.1.x'"}, {"oid": "d2ca6e1cf182e8c7e081401031fdee86b0c9a8e7", "committedDate": "2022-04-01 19:58:35 -0400", "message": "test: fix bad merge from 7.1.x (#8966)"}, {"oid": "57f3596ba3030029a8a08ed38c69952fd5d1dad9", "committedDate": "2022-04-08 11:02:25 +0200", "message": "fix: Improved/fixed aggregate function error messages. (#8977)"}, {"oid": "503e4cd1baa00038491313527fac37972575e64e", "committedDate": "2022-04-19 17:56:07 -0700", "message": "fix: use the engine's KsqlConfig to build queries (#9040)"}, {"oid": "9f0f74a993f2703bc8b381191b9cac6d34152c54", "committedDate": "2022-07-14 22:56:30 -0400", "message": "feat: Support pausing/resuming persistent queries (#9203)"}, {"oid": "a4364bf853ba13ab33867572907008456f5df623", "committedDate": "2022-07-15 13:17:39 -0400", "message": "refactor: Migrate legacy UDAFs to use current annotations (#9272)"}, {"oid": "fe1b0324baad586f61a4a4f7abf890b4bd121636", "committedDate": "2022-08-11 16:15:35 +0300", "message": "chore: improve logging for master (#9428)"}, {"oid": "d4c24d20fe9019356d40627d186128e25e2db958", "committedDate": "2022-08-12 13:07:56 -0700", "message": "test: Fix more tests related to topic validation"}, {"oid": "e591ff35e642ce1c8a81fb695d60de5d6bfa0a98", "committedDate": "2022-08-30 16:14:37 +0200", "message": "feat: hard delete internal schemas for persistent queries. (#9496)"}, {"oid": "173a2ca4c74d5f35b3abca7bc6e8e5b1f654d50a", "committedDate": "2022-09-16 11:01:13 +0200", "message": "fix-9243: improving error messages (#9531)"}, {"oid": "b0205ac1037c092a7a759bcdb90fa7c84e428822", "committedDate": "2022-09-22 11:42:50 +0200", "message": "fix: enhance error messages when source has extra/lacks double quotes (#9573)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NjY5MA==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r486966690", "body": "This change should be reverted.", "bodyText": "This change should be reverted.", "bodyHTML": "<p dir=\"auto\">This change should be reverted.</p>", "author": "big-andy-coates", "createdAt": "2020-09-11T10:50:30Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java", "diffHunk": "@@ -981,27 +981,21 @@ public void shouldNotThrowWhenPreparingDuplicateTable() {\n   public void shouldThrowWhenExecutingDuplicateTable() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n-        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n             + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));", "originalCommit": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "678163151432e1e935c4acbb426f41b75b22b488", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c184ebae989..356b028ea67 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -990,8 +1053,8 @@ public class KsqlEngineTest {\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, new HashMap<>(), KSQL_CONFIG)\n+        serviceContext, ConfiguredStatement.\n+            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n", "next_change": {"commit": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex 356b028ea67..8ff4500153e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1058,9 +1233,42 @@ public class KsqlEngineTest {\n     );\n \n     // Then:\n+    // Ideally, the result should be a message the the stream already exists, but in this case\n+    // it returns the same Query ID that it was created by the first stream. Some code refactoring\n+    // is needed in EngineExecutor.execute() and other places to validate the cases when a\n+    // CREATE IF NOT EXISTS return a warning message only, and not an error. For now, this is a\n+    // temporary solution.\n     assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n+  @Test\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n+    // Given:\n+    final List<ParsedStatement> parsed = ksqlEngine.parse(\n+        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+\n+    givenStatementAlreadyExecuted(parsed.get(0));\n+\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+\n+    // When:\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n+    );\n+\n+    // Then:\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add table 'FOO': A table with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n+  }\n+\n   @Test\n   public void shouldThrowWhenPreparingUnknownSource() {\n     // Given:\n", "next_change": {"commit": "b01aebc5c183bccf95895a9952edd7e40aed243f", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex 8ff4500153e..c7e24a878fd 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1216,59 +1267,26 @@ public class KsqlEngineTest {\n   }\n \n   @Test\n-  public void shouldNotThrowWhenExecutingDuplicateTableWithIfNotExists() {\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n         \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE IF NOT EXISTS FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext, ConfiguredStatement.\n-            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        serviceContext,\n+        of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n-    // Ideally, the result should be a message the the stream already exists, but in this case\n-    // it returns the same Query ID that it was created by the first stream. Some code refactoring\n-    // is needed in EngineExecutor.execute() and other places to validate the cases when a\n-    // CREATE IF NOT EXISTS return a warning message only, and not an error. For now, this is a\n-    // temporary solution.\n     assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n-  @Test\n-  public void shouldThrowWhenExecutingDuplicateTable() {\n-    // Given:\n-    final List<ParsedStatement> parsed = ksqlEngine.parse(\n-        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n-\n-    givenStatementAlreadyExecuted(parsed.get(0));\n-\n-    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n-\n-    // When:\n-    final KsqlStatementException e = assertThrows(\n-        KsqlStatementException.class,\n-        () -> ksqlEngine.execute(\n-            serviceContext,\n-            ConfiguredStatement\n-                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n-        )\n-    );\n-\n-    // Then:\n-    assertThat(e, rawMessage(is(\n-        \"Cannot add table 'FOO': A table with the same name already exists\")));\n-    assertThat(e, statementText(is(\n-        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n-  }\n-\n   @Test\n   public void shouldThrowWhenPreparingUnknownSource() {\n     // Given:\n", "next_change": {"commit": "ff9c504abdc3f4c58e8066e277b9ffc08ad12b6a", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c7e24a878fd..14ba7a3391c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1267,26 +1267,59 @@ public class KsqlEngineTest {\n   }\n \n   @Test\n-  public void shouldThrowWhenExecutingDuplicateTable() {\n+  public void shouldNotThrowWhenExecutingDuplicateTableWithIfNotExists() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n         \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+            + \"CREATE TABLE IF NOT EXISTS FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        serviceContext, ConfiguredStatement.\n+            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n+    // Ideally, the result should be a message the the stream already exists, but in this case\n+    // it returns the same Query ID that it was created by the first stream. Some code refactoring\n+    // is needed in EngineExecutor.execute() and other places to validate the cases when a\n+    // CREATE IF NOT EXISTS return a warning message only, and not an error. For now, this is a\n+    // temporary solution.\n     assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n+  @Test\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n+    // Given:\n+    final List<ParsedStatement> parsed = ksqlEngine.parse(\n+        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+\n+    givenStatementAlreadyExecuted(parsed.get(0));\n+\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+\n+    // When:\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n+    );\n+\n+    // Then:\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add table 'FOO': A table with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n+  }\n+\n   @Test\n   public void shouldThrowWhenPreparingUnknownSource() {\n     // Given:\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c184ebae989..b6b3364d6f2 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -978,24 +1267,54 @@ public class KsqlEngineTest {\n   }\n \n   @Test\n-  public void shouldThrowWhenExecutingDuplicateTable() {\n+  public void shouldNotThrowWhenExecutingDuplicateTableWithIfNotExists() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n         \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+            + \"CREATE TABLE IF NOT EXISTS FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, new HashMap<>(), KSQL_CONFIG)\n+        serviceContext, ConfiguredStatement.\n+            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+    );\n+\n+    // Then:\n+    assertThat(executeResult.getQuery(), is(Optional.empty()));\n+    assertThat(executeResult.getCommandResult(),\n+        is(Optional.of(\"Cannot add table `FOO`: A table with the same name already exists.\")));\n+  }\n+\n+  @Test\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n+    // Given:\n+    final List<ParsedStatement> parsed = ksqlEngine.parse(\n+        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+\n+    givenStatementAlreadyExecuted(parsed.get(0));\n+\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+\n+    // When:\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n     );\n \n     // Then:\n-    assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add table 'FOO': A table with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n   }\n \n   @Test\n", "next_change": null}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "20f631d97b887be07f7f7a2a19f0529aee573f12", "committedDate": "2020-12-10 16:23:28 -0800", "message": "chore: ungate protobuf and remove key.format.enabled config (#6754)"}, {"oid": "8c9e9280bb1f76f8d4ef88bae7c3e33426ff3d48", "committedDate": "2021-02-19 15:56:46 -0800", "message": "fix: incompatible schema causing KsqlEngineTest.shouldNotFailIfAvroSchemaEvolvable failure (#7052)"}, {"oid": "3c8d878ea19e177f458f1b6d9978264860072a0d", "committedDate": "2021-02-19 16:13:17 -0800", "message": "Merge branch '5.5.x' into 6.0.x"}, {"oid": "0de72a463263fc99da86f5dadc4dd6bad794ab21", "committedDate": "2021-02-19 16:13:28 -0800", "message": "Merge branch '6.0.x' into 6.1.x"}, {"oid": "dcce03f891451225a8f425f01eed5e4fc70e2e48", "committedDate": "2021-02-19 16:13:40 -0800", "message": "Merge branch '6.1.x'"}, {"oid": "f3838002fc4c8c085a3f62bfd34073e232416de4", "committedDate": "2021-03-09 21:03:59 -0800", "message": "fix: fix the cache max bytes buffering check (#7181)"}, {"oid": "3604bc86204bae486f6cab3b67a553fa246ad6ee", "committedDate": "2021-04-06 22:01:07 -0700", "message": "refactor: reorganize query management and clean up listeners (#7320)"}, {"oid": "2b7df17d64f4dec9dc5e42e0584dca7f52705c87", "committedDate": "2021-05-05 17:59:32 -0700", "message": "chore: refactor QueryMetadata and PersistentQueryMetadata (#7460)"}, {"oid": "eddac720fc5c045fd5f7059d90b0ed3c666f7bdc", "committedDate": "2021-07-20 15:02:10 -0500", "message": "[KCI-612] Clean up a terminated query's state stores (#7729)"}, {"oid": "9e532cecf7c76d893d8226e54701eee30b4a616b", "committedDate": "2021-08-25 20:18:33 -0500", "message": "refactor: make sink source optional in PersistentQueryMetadata (#8052)"}, {"oid": "44e812952daff844bc646cb92b935ac738f074c1", "committedDate": "2021-08-25 21:21:53 -0500", "message": "feat: shared runtimes (#7721)"}, {"oid": "e2c3211c23eac9c92806d013c7ad8e4f1bef7ae7", "committedDate": "2021-08-27 22:01:18 -0500", "message": "feat: execute source table query plans (#8061)"}, {"oid": "fb966001349fd6ba383764f547796ebc4982ec9c", "committedDate": "2021-08-30 14:34:27 -0500", "message": "chore: reject TERMINATE commands on CST tables (#8071)"}, {"oid": "4831e6b099cca2be51a659d2bb4112ead0cd8387", "committedDate": "2021-09-02 16:02:21 -0500", "message": "feat: introduce stream pull queries for HTTP/1 (#8064)"}, {"oid": "a14f957c1c094920b81552e87c15e72a34e93d0c", "committedDate": "2021-09-09 15:57:34 -0500", "message": "feat: disable stream pull queries by default (#8115)"}, {"oid": "f03755e2c965a3bd15f9090e2e1d8940ea4ecd3d", "committedDate": "2021-09-17 14:08:08 -0500", "message": "fix: CREATE OR REPLACE TABLE on an existing query fails while initializing the kafka streams (#8130)"}, {"oid": "a7c6ebeb946df62aed9d0ca1c8724e6f7dd6a18e", "committedDate": "2021-09-30 14:25:36 -0700", "message": "fix: ClassCastException when dropping sources with 2+ insert queries (#8205)"}, {"oid": "c317788c019889e1154a2b63855b0f8fadafa336", "committedDate": "2021-11-18 00:52:49 -0800", "message": "chore: refactor SharedKafkaStreamsRuntime into abstract class (#8355)"}, {"oid": "6c73a1438722f657c134345234c1be849c891d12", "committedDate": "2021-11-22 14:23:17 -0600", "message": "feat: clean up based on query id for shared runtimes (#8383)"}, {"oid": "cf831c5a3c8ef5ef70446a678be77ca87a08e67a", "committedDate": "2021-12-03 14:51:58 -0600", "message": "Kci 1081/implement endpoint for query scaling server configs (#8334)"}, {"oid": "0c7da2ea0432c8adb1f137303e7780a7d402d11a", "committedDate": "2021-12-09 19:15:30 -0800", "message": "test: add functional tests for INSERT statements with headers (#8471)"}, {"oid": "00072288077232aa3c97dde090879eccf256f633", "committedDate": "2021-12-13 20:21:23 -0600", "message": "refactor: eliminate static metrics registry (#8498)"}, {"oid": "df29d27707de96dcce97f81e76c98f225a7442d2", "committedDate": "2021-12-16 10:37:17 -0600", "message": "feat: new runtime selection (#8472)"}, {"oid": "fbecd71daca4cbe734cb69be2037cc9a36dbf994", "committedDate": "2021-12-17 10:48:54 -0600", "message": "feat: Drop query from assignor (#8523)"}, {"oid": "f42225d2061af37ba0edf04be94d1e6eebd061b9", "committedDate": "2022-01-18 14:52:37 -0800", "message": "fix: back out post-3.1 changes to fix 7.1.x build (#8599)"}, {"oid": "6c3320c670a86a380a46dfe4c7208fdaf1f9159c", "committedDate": "2022-01-19 22:39:25 -0800", "message": "Revert \"fix: back out post-3.1 changes to fix 7.1.x build (#8599)\""}, {"oid": "cd99f26aebffcbf55b29527effa394b9e1c2ee3a", "committedDate": "2022-01-27 08:53:54 -0600", "message": "fix: clean up custom prefixed internal topics (#8640)"}, {"oid": "53ddafe72dd8b2d284e9575cff856680b4280bba", "committedDate": "2022-03-07 18:17:23 -0600", "message": "fix: clean up mistaken topic names (#8857)"}, {"oid": "660c3256abd565067814e436d187d998cd8741b7", "committedDate": "2022-03-28 12:27:07 -0700", "message": "chore: remove SqlFormatInjector as obsolete (#8931)"}, {"oid": "db8e8bcb33d0c53bf2f5e71d5b802962a1a1294d", "committedDate": "2022-03-31 13:37:47 -0700", "message": "fix: preserve old schema behavior for protobuf wrapped primitives (#8934)"}, {"oid": "a4ef4d2377cda3e86e2c406238459e3405828cbd", "committedDate": "2022-03-31 20:35:28 -0700", "message": "chore: remove SqlFormatInjector as obsolete (7.0.x) (#8940)"}, {"oid": "aa458e0b076a249b6a63eed9ef9bd4ec87f30e46", "committedDate": "2022-03-31 20:38:32 -0700", "message": "Merge branch '7.0.x' into 7.1.x"}, {"oid": "20b75ea451468d7f80f905d46e5698a3979160a2", "committedDate": "2022-03-31 20:40:52 -0700", "message": "Merge branch '7.1.x'"}, {"oid": "d2ca6e1cf182e8c7e081401031fdee86b0c9a8e7", "committedDate": "2022-04-01 19:58:35 -0400", "message": "test: fix bad merge from 7.1.x (#8966)"}, {"oid": "57f3596ba3030029a8a08ed38c69952fd5d1dad9", "committedDate": "2022-04-08 11:02:25 +0200", "message": "fix: Improved/fixed aggregate function error messages. (#8977)"}, {"oid": "503e4cd1baa00038491313527fac37972575e64e", "committedDate": "2022-04-19 17:56:07 -0700", "message": "fix: use the engine's KsqlConfig to build queries (#9040)"}, {"oid": "9f0f74a993f2703bc8b381191b9cac6d34152c54", "committedDate": "2022-07-14 22:56:30 -0400", "message": "feat: Support pausing/resuming persistent queries (#9203)"}, {"oid": "a4364bf853ba13ab33867572907008456f5df623", "committedDate": "2022-07-15 13:17:39 -0400", "message": "refactor: Migrate legacy UDAFs to use current annotations (#9272)"}, {"oid": "fe1b0324baad586f61a4a4f7abf890b4bd121636", "committedDate": "2022-08-11 16:15:35 +0300", "message": "chore: improve logging for master (#9428)"}, {"oid": "d4c24d20fe9019356d40627d186128e25e2db958", "committedDate": "2022-08-12 13:07:56 -0700", "message": "test: Fix more tests related to topic validation"}, {"oid": "e591ff35e642ce1c8a81fb695d60de5d6bfa0a98", "committedDate": "2022-08-30 16:14:37 +0200", "message": "feat: hard delete internal schemas for persistent queries. (#9496)"}, {"oid": "173a2ca4c74d5f35b3abca7bc6e8e5b1f654d50a", "committedDate": "2022-09-16 11:01:13 +0200", "message": "fix-9243: improving error messages (#9531)"}, {"oid": "b0205ac1037c092a7a759bcdb90fa7c84e428822", "committedDate": "2022-09-22 11:42:50 +0200", "message": "fix: enhance error messages when source has extra/lacks double quotes (#9573)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NjcyNg==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r486966726", "body": "This change should be reverted.", "bodyText": "This change should be reverted.", "bodyHTML": "<p dir=\"auto\">This change should be reverted.</p>", "author": "big-andy-coates", "createdAt": "2020-09-11T10:50:35Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java", "diffHunk": "@@ -981,27 +981,21 @@ public void shouldNotThrowWhenPreparingDuplicateTable() {\n   public void shouldThrowWhenExecutingDuplicateTable() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n-        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n             + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n \n     // When:\n-    final KsqlStatementException e = assertThrows(\n-        KsqlStatementException.class,\n-        () -> ksqlEngine.execute(\n-            serviceContext,\n-            ConfiguredStatement.of(prepared, new HashMap<>(), KSQL_CONFIG)\n-        )\n+    ExecuteResult executeResult = ksqlEngine.execute(\n+        serviceContext,\n+        of(prepared, new HashMap<>(), KSQL_CONFIG)", "originalCommit": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "678163151432e1e935c4acbb426f41b75b22b488", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c184ebae989..356b028ea67 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -990,8 +1053,8 @@ public class KsqlEngineTest {\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, new HashMap<>(), KSQL_CONFIG)\n+        serviceContext, ConfiguredStatement.\n+            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n", "next_change": {"commit": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex 356b028ea67..8ff4500153e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1058,9 +1233,42 @@ public class KsqlEngineTest {\n     );\n \n     // Then:\n+    // Ideally, the result should be a message the the stream already exists, but in this case\n+    // it returns the same Query ID that it was created by the first stream. Some code refactoring\n+    // is needed in EngineExecutor.execute() and other places to validate the cases when a\n+    // CREATE IF NOT EXISTS return a warning message only, and not an error. For now, this is a\n+    // temporary solution.\n     assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n+  @Test\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n+    // Given:\n+    final List<ParsedStatement> parsed = ksqlEngine.parse(\n+        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+\n+    givenStatementAlreadyExecuted(parsed.get(0));\n+\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+\n+    // When:\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n+    );\n+\n+    // Then:\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add table 'FOO': A table with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n+  }\n+\n   @Test\n   public void shouldThrowWhenPreparingUnknownSource() {\n     // Given:\n", "next_change": {"commit": "b01aebc5c183bccf95895a9952edd7e40aed243f", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex 8ff4500153e..c7e24a878fd 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1216,59 +1267,26 @@ public class KsqlEngineTest {\n   }\n \n   @Test\n-  public void shouldNotThrowWhenExecutingDuplicateTableWithIfNotExists() {\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n         \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE IF NOT EXISTS FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext, ConfiguredStatement.\n-            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        serviceContext,\n+        of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n-    // Ideally, the result should be a message the the stream already exists, but in this case\n-    // it returns the same Query ID that it was created by the first stream. Some code refactoring\n-    // is needed in EngineExecutor.execute() and other places to validate the cases when a\n-    // CREATE IF NOT EXISTS return a warning message only, and not an error. For now, this is a\n-    // temporary solution.\n     assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n-  @Test\n-  public void shouldThrowWhenExecutingDuplicateTable() {\n-    // Given:\n-    final List<ParsedStatement> parsed = ksqlEngine.parse(\n-        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n-\n-    givenStatementAlreadyExecuted(parsed.get(0));\n-\n-    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n-\n-    // When:\n-    final KsqlStatementException e = assertThrows(\n-        KsqlStatementException.class,\n-        () -> ksqlEngine.execute(\n-            serviceContext,\n-            ConfiguredStatement\n-                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n-        )\n-    );\n-\n-    // Then:\n-    assertThat(e, rawMessage(is(\n-        \"Cannot add table 'FOO': A table with the same name already exists\")));\n-    assertThat(e, statementText(is(\n-        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n-  }\n-\n   @Test\n   public void shouldThrowWhenPreparingUnknownSource() {\n     // Given:\n", "next_change": {"commit": "ff9c504abdc3f4c58e8066e277b9ffc08ad12b6a", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c7e24a878fd..14ba7a3391c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1267,26 +1267,59 @@ public class KsqlEngineTest {\n   }\n \n   @Test\n-  public void shouldThrowWhenExecutingDuplicateTable() {\n+  public void shouldNotThrowWhenExecutingDuplicateTableWithIfNotExists() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n         \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+            + \"CREATE TABLE IF NOT EXISTS FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        serviceContext, ConfiguredStatement.\n+            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n+    // Ideally, the result should be a message the the stream already exists, but in this case\n+    // it returns the same Query ID that it was created by the first stream. Some code refactoring\n+    // is needed in EngineExecutor.execute() and other places to validate the cases when a\n+    // CREATE IF NOT EXISTS return a warning message only, and not an error. For now, this is a\n+    // temporary solution.\n     assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n+  @Test\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n+    // Given:\n+    final List<ParsedStatement> parsed = ksqlEngine.parse(\n+        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+\n+    givenStatementAlreadyExecuted(parsed.get(0));\n+\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+\n+    // When:\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n+    );\n+\n+    // Then:\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add table 'FOO': A table with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n+  }\n+\n   @Test\n   public void shouldThrowWhenPreparingUnknownSource() {\n     // Given:\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c184ebae989..b6b3364d6f2 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -978,24 +1267,54 @@ public class KsqlEngineTest {\n   }\n \n   @Test\n-  public void shouldThrowWhenExecutingDuplicateTable() {\n+  public void shouldNotThrowWhenExecutingDuplicateTableWithIfNotExists() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n         \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+            + \"CREATE TABLE IF NOT EXISTS FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, new HashMap<>(), KSQL_CONFIG)\n+        serviceContext, ConfiguredStatement.\n+            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+    );\n+\n+    // Then:\n+    assertThat(executeResult.getQuery(), is(Optional.empty()));\n+    assertThat(executeResult.getCommandResult(),\n+        is(Optional.of(\"Cannot add table `FOO`: A table with the same name already exists.\")));\n+  }\n+\n+  @Test\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n+    // Given:\n+    final List<ParsedStatement> parsed = ksqlEngine.parse(\n+        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+\n+    givenStatementAlreadyExecuted(parsed.get(0));\n+\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+\n+    // When:\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n     );\n \n     // Then:\n-    assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add table 'FOO': A table with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n   }\n \n   @Test\n", "next_change": null}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "20f631d97b887be07f7f7a2a19f0529aee573f12", "committedDate": "2020-12-10 16:23:28 -0800", "message": "chore: ungate protobuf and remove key.format.enabled config (#6754)"}, {"oid": "8c9e9280bb1f76f8d4ef88bae7c3e33426ff3d48", "committedDate": "2021-02-19 15:56:46 -0800", "message": "fix: incompatible schema causing KsqlEngineTest.shouldNotFailIfAvroSchemaEvolvable failure (#7052)"}, {"oid": "3c8d878ea19e177f458f1b6d9978264860072a0d", "committedDate": "2021-02-19 16:13:17 -0800", "message": "Merge branch '5.5.x' into 6.0.x"}, {"oid": "0de72a463263fc99da86f5dadc4dd6bad794ab21", "committedDate": "2021-02-19 16:13:28 -0800", "message": "Merge branch '6.0.x' into 6.1.x"}, {"oid": "dcce03f891451225a8f425f01eed5e4fc70e2e48", "committedDate": "2021-02-19 16:13:40 -0800", "message": "Merge branch '6.1.x'"}, {"oid": "f3838002fc4c8c085a3f62bfd34073e232416de4", "committedDate": "2021-03-09 21:03:59 -0800", "message": "fix: fix the cache max bytes buffering check (#7181)"}, {"oid": "3604bc86204bae486f6cab3b67a553fa246ad6ee", "committedDate": "2021-04-06 22:01:07 -0700", "message": "refactor: reorganize query management and clean up listeners (#7320)"}, {"oid": "2b7df17d64f4dec9dc5e42e0584dca7f52705c87", "committedDate": "2021-05-05 17:59:32 -0700", "message": "chore: refactor QueryMetadata and PersistentQueryMetadata (#7460)"}, {"oid": "eddac720fc5c045fd5f7059d90b0ed3c666f7bdc", "committedDate": "2021-07-20 15:02:10 -0500", "message": "[KCI-612] Clean up a terminated query's state stores (#7729)"}, {"oid": "9e532cecf7c76d893d8226e54701eee30b4a616b", "committedDate": "2021-08-25 20:18:33 -0500", "message": "refactor: make sink source optional in PersistentQueryMetadata (#8052)"}, {"oid": "44e812952daff844bc646cb92b935ac738f074c1", "committedDate": "2021-08-25 21:21:53 -0500", "message": "feat: shared runtimes (#7721)"}, {"oid": "e2c3211c23eac9c92806d013c7ad8e4f1bef7ae7", "committedDate": "2021-08-27 22:01:18 -0500", "message": "feat: execute source table query plans (#8061)"}, {"oid": "fb966001349fd6ba383764f547796ebc4982ec9c", "committedDate": "2021-08-30 14:34:27 -0500", "message": "chore: reject TERMINATE commands on CST tables (#8071)"}, {"oid": "4831e6b099cca2be51a659d2bb4112ead0cd8387", "committedDate": "2021-09-02 16:02:21 -0500", "message": "feat: introduce stream pull queries for HTTP/1 (#8064)"}, {"oid": "a14f957c1c094920b81552e87c15e72a34e93d0c", "committedDate": "2021-09-09 15:57:34 -0500", "message": "feat: disable stream pull queries by default (#8115)"}, {"oid": "f03755e2c965a3bd15f9090e2e1d8940ea4ecd3d", "committedDate": "2021-09-17 14:08:08 -0500", "message": "fix: CREATE OR REPLACE TABLE on an existing query fails while initializing the kafka streams (#8130)"}, {"oid": "a7c6ebeb946df62aed9d0ca1c8724e6f7dd6a18e", "committedDate": "2021-09-30 14:25:36 -0700", "message": "fix: ClassCastException when dropping sources with 2+ insert queries (#8205)"}, {"oid": "c317788c019889e1154a2b63855b0f8fadafa336", "committedDate": "2021-11-18 00:52:49 -0800", "message": "chore: refactor SharedKafkaStreamsRuntime into abstract class (#8355)"}, {"oid": "6c73a1438722f657c134345234c1be849c891d12", "committedDate": "2021-11-22 14:23:17 -0600", "message": "feat: clean up based on query id for shared runtimes (#8383)"}, {"oid": "cf831c5a3c8ef5ef70446a678be77ca87a08e67a", "committedDate": "2021-12-03 14:51:58 -0600", "message": "Kci 1081/implement endpoint for query scaling server configs (#8334)"}, {"oid": "0c7da2ea0432c8adb1f137303e7780a7d402d11a", "committedDate": "2021-12-09 19:15:30 -0800", "message": "test: add functional tests for INSERT statements with headers (#8471)"}, {"oid": "00072288077232aa3c97dde090879eccf256f633", "committedDate": "2021-12-13 20:21:23 -0600", "message": "refactor: eliminate static metrics registry (#8498)"}, {"oid": "df29d27707de96dcce97f81e76c98f225a7442d2", "committedDate": "2021-12-16 10:37:17 -0600", "message": "feat: new runtime selection (#8472)"}, {"oid": "fbecd71daca4cbe734cb69be2037cc9a36dbf994", "committedDate": "2021-12-17 10:48:54 -0600", "message": "feat: Drop query from assignor (#8523)"}, {"oid": "f42225d2061af37ba0edf04be94d1e6eebd061b9", "committedDate": "2022-01-18 14:52:37 -0800", "message": "fix: back out post-3.1 changes to fix 7.1.x build (#8599)"}, {"oid": "6c3320c670a86a380a46dfe4c7208fdaf1f9159c", "committedDate": "2022-01-19 22:39:25 -0800", "message": "Revert \"fix: back out post-3.1 changes to fix 7.1.x build (#8599)\""}, {"oid": "cd99f26aebffcbf55b29527effa394b9e1c2ee3a", "committedDate": "2022-01-27 08:53:54 -0600", "message": "fix: clean up custom prefixed internal topics (#8640)"}, {"oid": "53ddafe72dd8b2d284e9575cff856680b4280bba", "committedDate": "2022-03-07 18:17:23 -0600", "message": "fix: clean up mistaken topic names (#8857)"}, {"oid": "660c3256abd565067814e436d187d998cd8741b7", "committedDate": "2022-03-28 12:27:07 -0700", "message": "chore: remove SqlFormatInjector as obsolete (#8931)"}, {"oid": "db8e8bcb33d0c53bf2f5e71d5b802962a1a1294d", "committedDate": "2022-03-31 13:37:47 -0700", "message": "fix: preserve old schema behavior for protobuf wrapped primitives (#8934)"}, {"oid": "a4ef4d2377cda3e86e2c406238459e3405828cbd", "committedDate": "2022-03-31 20:35:28 -0700", "message": "chore: remove SqlFormatInjector as obsolete (7.0.x) (#8940)"}, {"oid": "aa458e0b076a249b6a63eed9ef9bd4ec87f30e46", "committedDate": "2022-03-31 20:38:32 -0700", "message": "Merge branch '7.0.x' into 7.1.x"}, {"oid": "20b75ea451468d7f80f905d46e5698a3979160a2", "committedDate": "2022-03-31 20:40:52 -0700", "message": "Merge branch '7.1.x'"}, {"oid": "d2ca6e1cf182e8c7e081401031fdee86b0c9a8e7", "committedDate": "2022-04-01 19:58:35 -0400", "message": "test: fix bad merge from 7.1.x (#8966)"}, {"oid": "57f3596ba3030029a8a08ed38c69952fd5d1dad9", "committedDate": "2022-04-08 11:02:25 +0200", "message": "fix: Improved/fixed aggregate function error messages. (#8977)"}, {"oid": "503e4cd1baa00038491313527fac37972575e64e", "committedDate": "2022-04-19 17:56:07 -0700", "message": "fix: use the engine's KsqlConfig to build queries (#9040)"}, {"oid": "9f0f74a993f2703bc8b381191b9cac6d34152c54", "committedDate": "2022-07-14 22:56:30 -0400", "message": "feat: Support pausing/resuming persistent queries (#9203)"}, {"oid": "a4364bf853ba13ab33867572907008456f5df623", "committedDate": "2022-07-15 13:17:39 -0400", "message": "refactor: Migrate legacy UDAFs to use current annotations (#9272)"}, {"oid": "fe1b0324baad586f61a4a4f7abf890b4bd121636", "committedDate": "2022-08-11 16:15:35 +0300", "message": "chore: improve logging for master (#9428)"}, {"oid": "d4c24d20fe9019356d40627d186128e25e2db958", "committedDate": "2022-08-12 13:07:56 -0700", "message": "test: Fix more tests related to topic validation"}, {"oid": "e591ff35e642ce1c8a81fb695d60de5d6bfa0a98", "committedDate": "2022-08-30 16:14:37 +0200", "message": "feat: hard delete internal schemas for persistent queries. (#9496)"}, {"oid": "173a2ca4c74d5f35b3abca7bc6e8e5b1f654d50a", "committedDate": "2022-09-16 11:01:13 +0200", "message": "fix-9243: improving error messages (#9531)"}, {"oid": "b0205ac1037c092a7a759bcdb90fa7c84e428822", "committedDate": "2022-09-22 11:42:50 +0200", "message": "fix: enhance error messages when source has extra/lacks double quotes (#9573)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2Njc1MQ==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r486966751", "body": "This change should be reverted.", "bodyText": "This change should be reverted.", "bodyHTML": "<p dir=\"auto\">This change should be reverted.</p>", "author": "big-andy-coates", "createdAt": "2020-09-11T10:50:39Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java", "diffHunk": "@@ -981,27 +981,21 @@ public void shouldNotThrowWhenPreparingDuplicateTable() {\n   public void shouldThrowWhenExecutingDuplicateTable() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n-        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n             + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n \n     // When:\n-    final KsqlStatementException e = assertThrows(\n-        KsqlStatementException.class,\n-        () -> ksqlEngine.execute(\n-            serviceContext,\n-            ConfiguredStatement.of(prepared, new HashMap<>(), KSQL_CONFIG)\n-        )\n+    ExecuteResult executeResult = ksqlEngine.execute(\n+        serviceContext,\n+        of(prepared, new HashMap<>(), KSQL_CONFIG)\n     );\n \n     // Then:\n-    assertThat(e, rawMessage(is(\n-        \"Cannot add table 'FOO': A table with the same name already exists\")));\n-    assertThat(e, statementText(is(\n-        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n+    assertThat(executeResult.getQuery(), is(not(Optional.empty())));", "originalCommit": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "678163151432e1e935c4acbb426f41b75b22b488", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c184ebae989..356b028ea67 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -990,8 +1053,8 @@ public class KsqlEngineTest {\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, new HashMap<>(), KSQL_CONFIG)\n+        serviceContext, ConfiguredStatement.\n+            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n", "next_change": {"commit": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex 356b028ea67..8ff4500153e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1058,9 +1233,42 @@ public class KsqlEngineTest {\n     );\n \n     // Then:\n+    // Ideally, the result should be a message the the stream already exists, but in this case\n+    // it returns the same Query ID that it was created by the first stream. Some code refactoring\n+    // is needed in EngineExecutor.execute() and other places to validate the cases when a\n+    // CREATE IF NOT EXISTS return a warning message only, and not an error. For now, this is a\n+    // temporary solution.\n     assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n+  @Test\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n+    // Given:\n+    final List<ParsedStatement> parsed = ksqlEngine.parse(\n+        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+\n+    givenStatementAlreadyExecuted(parsed.get(0));\n+\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+\n+    // When:\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n+    );\n+\n+    // Then:\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add table 'FOO': A table with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n+  }\n+\n   @Test\n   public void shouldThrowWhenPreparingUnknownSource() {\n     // Given:\n", "next_change": {"commit": "b01aebc5c183bccf95895a9952edd7e40aed243f", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex 8ff4500153e..c7e24a878fd 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1216,59 +1267,26 @@ public class KsqlEngineTest {\n   }\n \n   @Test\n-  public void shouldNotThrowWhenExecutingDuplicateTableWithIfNotExists() {\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n         \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE IF NOT EXISTS FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext, ConfiguredStatement.\n-            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        serviceContext,\n+        of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n-    // Ideally, the result should be a message the the stream already exists, but in this case\n-    // it returns the same Query ID that it was created by the first stream. Some code refactoring\n-    // is needed in EngineExecutor.execute() and other places to validate the cases when a\n-    // CREATE IF NOT EXISTS return a warning message only, and not an error. For now, this is a\n-    // temporary solution.\n     assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n-  @Test\n-  public void shouldThrowWhenExecutingDuplicateTable() {\n-    // Given:\n-    final List<ParsedStatement> parsed = ksqlEngine.parse(\n-        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n-\n-    givenStatementAlreadyExecuted(parsed.get(0));\n-\n-    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n-\n-    // When:\n-    final KsqlStatementException e = assertThrows(\n-        KsqlStatementException.class,\n-        () -> ksqlEngine.execute(\n-            serviceContext,\n-            ConfiguredStatement\n-                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n-        )\n-    );\n-\n-    // Then:\n-    assertThat(e, rawMessage(is(\n-        \"Cannot add table 'FOO': A table with the same name already exists\")));\n-    assertThat(e, statementText(is(\n-        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n-  }\n-\n   @Test\n   public void shouldThrowWhenPreparingUnknownSource() {\n     // Given:\n", "next_change": {"commit": "ff9c504abdc3f4c58e8066e277b9ffc08ad12b6a", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c7e24a878fd..14ba7a3391c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1267,26 +1267,59 @@ public class KsqlEngineTest {\n   }\n \n   @Test\n-  public void shouldThrowWhenExecutingDuplicateTable() {\n+  public void shouldNotThrowWhenExecutingDuplicateTableWithIfNotExists() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n         \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+            + \"CREATE TABLE IF NOT EXISTS FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        serviceContext, ConfiguredStatement.\n+            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n+    // Ideally, the result should be a message the the stream already exists, but in this case\n+    // it returns the same Query ID that it was created by the first stream. Some code refactoring\n+    // is needed in EngineExecutor.execute() and other places to validate the cases when a\n+    // CREATE IF NOT EXISTS return a warning message only, and not an error. For now, this is a\n+    // temporary solution.\n     assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n+  @Test\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n+    // Given:\n+    final List<ParsedStatement> parsed = ksqlEngine.parse(\n+        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+\n+    givenStatementAlreadyExecuted(parsed.get(0));\n+\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+\n+    // When:\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n+    );\n+\n+    // Then:\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add table 'FOO': A table with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n+  }\n+\n   @Test\n   public void shouldThrowWhenPreparingUnknownSource() {\n     // Given:\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c184ebae989..b6b3364d6f2 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -978,24 +1267,54 @@ public class KsqlEngineTest {\n   }\n \n   @Test\n-  public void shouldThrowWhenExecutingDuplicateTable() {\n+  public void shouldNotThrowWhenExecutingDuplicateTableWithIfNotExists() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n         \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2; \"\n-            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+            + \"CREATE TABLE IF NOT EXISTS FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n-    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, new HashMap<>(), KSQL_CONFIG)\n+        serviceContext, ConfiguredStatement.\n+            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+    );\n+\n+    // Then:\n+    assertThat(executeResult.getQuery(), is(Optional.empty()));\n+    assertThat(executeResult.getCommandResult(),\n+        is(Optional.of(\"Cannot add table `FOO`: A table with the same name already exists.\")));\n+  }\n+\n+  @Test\n+  public void shouldThrowWhenExecutingDuplicateTable() {\n+    // Given:\n+    final List<ParsedStatement> parsed = ksqlEngine.parse(\n+        \"CREATE TABLE FOO AS SELECT * FROM TEST2; \"\n+            + \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\");\n+\n+    givenStatementAlreadyExecuted(parsed.get(0));\n+\n+    final PreparedStatement<?> prepared = prepare(parsed.get(1));\n+\n+    // When:\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n     );\n \n     // Then:\n-    assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add table 'FOO': A table with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE TABLE FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM TEST2;\")));\n   }\n \n   @Test\n", "next_change": null}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "20f631d97b887be07f7f7a2a19f0529aee573f12", "committedDate": "2020-12-10 16:23:28 -0800", "message": "chore: ungate protobuf and remove key.format.enabled config (#6754)"}, {"oid": "8c9e9280bb1f76f8d4ef88bae7c3e33426ff3d48", "committedDate": "2021-02-19 15:56:46 -0800", "message": "fix: incompatible schema causing KsqlEngineTest.shouldNotFailIfAvroSchemaEvolvable failure (#7052)"}, {"oid": "3c8d878ea19e177f458f1b6d9978264860072a0d", "committedDate": "2021-02-19 16:13:17 -0800", "message": "Merge branch '5.5.x' into 6.0.x"}, {"oid": "0de72a463263fc99da86f5dadc4dd6bad794ab21", "committedDate": "2021-02-19 16:13:28 -0800", "message": "Merge branch '6.0.x' into 6.1.x"}, {"oid": "dcce03f891451225a8f425f01eed5e4fc70e2e48", "committedDate": "2021-02-19 16:13:40 -0800", "message": "Merge branch '6.1.x'"}, {"oid": "f3838002fc4c8c085a3f62bfd34073e232416de4", "committedDate": "2021-03-09 21:03:59 -0800", "message": "fix: fix the cache max bytes buffering check (#7181)"}, {"oid": "3604bc86204bae486f6cab3b67a553fa246ad6ee", "committedDate": "2021-04-06 22:01:07 -0700", "message": "refactor: reorganize query management and clean up listeners (#7320)"}, {"oid": "2b7df17d64f4dec9dc5e42e0584dca7f52705c87", "committedDate": "2021-05-05 17:59:32 -0700", "message": "chore: refactor QueryMetadata and PersistentQueryMetadata (#7460)"}, {"oid": "eddac720fc5c045fd5f7059d90b0ed3c666f7bdc", "committedDate": "2021-07-20 15:02:10 -0500", "message": "[KCI-612] Clean up a terminated query's state stores (#7729)"}, {"oid": "9e532cecf7c76d893d8226e54701eee30b4a616b", "committedDate": "2021-08-25 20:18:33 -0500", "message": "refactor: make sink source optional in PersistentQueryMetadata (#8052)"}, {"oid": "44e812952daff844bc646cb92b935ac738f074c1", "committedDate": "2021-08-25 21:21:53 -0500", "message": "feat: shared runtimes (#7721)"}, {"oid": "e2c3211c23eac9c92806d013c7ad8e4f1bef7ae7", "committedDate": "2021-08-27 22:01:18 -0500", "message": "feat: execute source table query plans (#8061)"}, {"oid": "fb966001349fd6ba383764f547796ebc4982ec9c", "committedDate": "2021-08-30 14:34:27 -0500", "message": "chore: reject TERMINATE commands on CST tables (#8071)"}, {"oid": "4831e6b099cca2be51a659d2bb4112ead0cd8387", "committedDate": "2021-09-02 16:02:21 -0500", "message": "feat: introduce stream pull queries for HTTP/1 (#8064)"}, {"oid": "a14f957c1c094920b81552e87c15e72a34e93d0c", "committedDate": "2021-09-09 15:57:34 -0500", "message": "feat: disable stream pull queries by default (#8115)"}, {"oid": "f03755e2c965a3bd15f9090e2e1d8940ea4ecd3d", "committedDate": "2021-09-17 14:08:08 -0500", "message": "fix: CREATE OR REPLACE TABLE on an existing query fails while initializing the kafka streams (#8130)"}, {"oid": "a7c6ebeb946df62aed9d0ca1c8724e6f7dd6a18e", "committedDate": "2021-09-30 14:25:36 -0700", "message": "fix: ClassCastException when dropping sources with 2+ insert queries (#8205)"}, {"oid": "c317788c019889e1154a2b63855b0f8fadafa336", "committedDate": "2021-11-18 00:52:49 -0800", "message": "chore: refactor SharedKafkaStreamsRuntime into abstract class (#8355)"}, {"oid": "6c73a1438722f657c134345234c1be849c891d12", "committedDate": "2021-11-22 14:23:17 -0600", "message": "feat: clean up based on query id for shared runtimes (#8383)"}, {"oid": "cf831c5a3c8ef5ef70446a678be77ca87a08e67a", "committedDate": "2021-12-03 14:51:58 -0600", "message": "Kci 1081/implement endpoint for query scaling server configs (#8334)"}, {"oid": "0c7da2ea0432c8adb1f137303e7780a7d402d11a", "committedDate": "2021-12-09 19:15:30 -0800", "message": "test: add functional tests for INSERT statements with headers (#8471)"}, {"oid": "00072288077232aa3c97dde090879eccf256f633", "committedDate": "2021-12-13 20:21:23 -0600", "message": "refactor: eliminate static metrics registry (#8498)"}, {"oid": "df29d27707de96dcce97f81e76c98f225a7442d2", "committedDate": "2021-12-16 10:37:17 -0600", "message": "feat: new runtime selection (#8472)"}, {"oid": "fbecd71daca4cbe734cb69be2037cc9a36dbf994", "committedDate": "2021-12-17 10:48:54 -0600", "message": "feat: Drop query from assignor (#8523)"}, {"oid": "f42225d2061af37ba0edf04be94d1e6eebd061b9", "committedDate": "2022-01-18 14:52:37 -0800", "message": "fix: back out post-3.1 changes to fix 7.1.x build (#8599)"}, {"oid": "6c3320c670a86a380a46dfe4c7208fdaf1f9159c", "committedDate": "2022-01-19 22:39:25 -0800", "message": "Revert \"fix: back out post-3.1 changes to fix 7.1.x build (#8599)\""}, {"oid": "cd99f26aebffcbf55b29527effa394b9e1c2ee3a", "committedDate": "2022-01-27 08:53:54 -0600", "message": "fix: clean up custom prefixed internal topics (#8640)"}, {"oid": "53ddafe72dd8b2d284e9575cff856680b4280bba", "committedDate": "2022-03-07 18:17:23 -0600", "message": "fix: clean up mistaken topic names (#8857)"}, {"oid": "660c3256abd565067814e436d187d998cd8741b7", "committedDate": "2022-03-28 12:27:07 -0700", "message": "chore: remove SqlFormatInjector as obsolete (#8931)"}, {"oid": "db8e8bcb33d0c53bf2f5e71d5b802962a1a1294d", "committedDate": "2022-03-31 13:37:47 -0700", "message": "fix: preserve old schema behavior for protobuf wrapped primitives (#8934)"}, {"oid": "a4ef4d2377cda3e86e2c406238459e3405828cbd", "committedDate": "2022-03-31 20:35:28 -0700", "message": "chore: remove SqlFormatInjector as obsolete (7.0.x) (#8940)"}, {"oid": "aa458e0b076a249b6a63eed9ef9bd4ec87f30e46", "committedDate": "2022-03-31 20:38:32 -0700", "message": "Merge branch '7.0.x' into 7.1.x"}, {"oid": "20b75ea451468d7f80f905d46e5698a3979160a2", "committedDate": "2022-03-31 20:40:52 -0700", "message": "Merge branch '7.1.x'"}, {"oid": "d2ca6e1cf182e8c7e081401031fdee86b0c9a8e7", "committedDate": "2022-04-01 19:58:35 -0400", "message": "test: fix bad merge from 7.1.x (#8966)"}, {"oid": "57f3596ba3030029a8a08ed38c69952fd5d1dad9", "committedDate": "2022-04-08 11:02:25 +0200", "message": "fix: Improved/fixed aggregate function error messages. (#8977)"}, {"oid": "503e4cd1baa00038491313527fac37972575e64e", "committedDate": "2022-04-19 17:56:07 -0700", "message": "fix: use the engine's KsqlConfig to build queries (#9040)"}, {"oid": "9f0f74a993f2703bc8b381191b9cac6d34152c54", "committedDate": "2022-07-14 22:56:30 -0400", "message": "feat: Support pausing/resuming persistent queries (#9203)"}, {"oid": "a4364bf853ba13ab33867572907008456f5df623", "committedDate": "2022-07-15 13:17:39 -0400", "message": "refactor: Migrate legacy UDAFs to use current annotations (#9272)"}, {"oid": "fe1b0324baad586f61a4a4f7abf890b4bd121636", "committedDate": "2022-08-11 16:15:35 +0300", "message": "chore: improve logging for master (#9428)"}, {"oid": "d4c24d20fe9019356d40627d186128e25e2db958", "committedDate": "2022-08-12 13:07:56 -0700", "message": "test: Fix more tests related to topic validation"}, {"oid": "e591ff35e642ce1c8a81fb695d60de5d6bfa0a98", "committedDate": "2022-08-30 16:14:37 +0200", "message": "feat: hard delete internal schemas for persistent queries. (#9496)"}, {"oid": "173a2ca4c74d5f35b3abca7bc6e8e5b1f654d50a", "committedDate": "2022-09-16 11:01:13 +0200", "message": "fix-9243: improving error messages (#9531)"}, {"oid": "b0205ac1037c092a7a759bcdb90fa7c84e428822", "committedDate": "2022-09-22 11:42:50 +0200", "message": "fix: enhance error messages when source has extra/lacks double quotes (#9573)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NjgxMA==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r486966810", "body": "This change should be reverted.", "bodyText": "This change should be reverted.", "bodyHTML": "<p dir=\"auto\">This change should be reverted.</p>", "author": "big-andy-coates", "createdAt": "2020-09-11T10:50:47Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java", "diffHunk": "@@ -1036,32 +1030,24 @@ public void shouldNotThrowWhenPreparingDuplicateStream() {\n   }\n \n   @Test\n-  public void shouldThrowWhenExecutingDuplicateStream() {\n+  public void shouldNotThrowWhenExecutingDuplicateStream() {\n     // Given:\n     final List<ParsedStatement> parsed = ksqlEngine.parse(\n-        \"CREATE STREAM FOO AS SELECT * FROM ORDERS; \"\n+        \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS; \"\n             + \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS;\");\n \n     givenStatementAlreadyExecuted(parsed.get(0));\n \n     final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n \n     // When:\n-    final KsqlStatementException e = assertThrows(\n-        KsqlStatementException.class,\n-        () -> ksqlEngine.execute(\n-            serviceContext,\n-            of(prepared, new HashMap<>(), KSQL_CONFIG)\n-        )\n+    ExecuteResult executeResult = ksqlEngine.execute(\n+        serviceContext,\n+        of(prepared, new HashMap<>(), KSQL_CONFIG)\n     );\n \n     // Then:\n-    assertThat(e, rawMessage(\n-        is(\n-            \"Cannot add stream 'FOO': A stream with the same name already exists\")));\n-    assertThat(e, statementText(\n-        is(\n-            \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS;\")));\n+    assertThat(executeResult.getQuery(), is(not(Optional.empty())));", "originalCommit": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "678163151432e1e935c4acbb426f41b75b22b488", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c184ebae989..356b028ea67 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1042,8 +1105,8 @@ public class KsqlEngineTest {\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, new HashMap<>(), KSQL_CONFIG)\n+        serviceContext, ConfiguredStatement.\n+            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n", "next_change": {"commit": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex 356b028ea67..8ff4500153e 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1110,9 +1318,42 @@ public class KsqlEngineTest {\n     );\n \n     // Then:\n+    // Ideally, the result should be a message the the stream already exists, but in this case\n+    // it returns the same Query ID that it was created by the first stream. Some code refactoring\n+    // is needed in EngineExecutor.execute() and other places to validate the cases when a\n+    // CREATE IF NOT EXISTS return a warning message only, and not an error. For now, this is a\n+    // temporary solution.\n     assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n+  @Test\n+  public void shouldThrowWhenExecutingDuplicateStream() {\n+    // Given:\n+    final List<ParsedStatement> parsed = ksqlEngine.parse(\n+        \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS; \"\n+            + \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS;\");\n+\n+    givenStatementAlreadyExecuted(parsed.get(0));\n+\n+    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n+\n+    // When:\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n+    );\n+\n+    // Then:\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add stream 'FOO': A stream with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS;\")));\n+  }\n+\n   @Test\n   public void shouldThrowWhenExecutingQueriesIfCsasCreatesTable() {\n     // When:\n", "next_change": {"commit": "2965dcdfbf2497364f33506bc22997f9f2bded83", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex 8ff4500153e..aba0368ceee 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1348,10 +1346,12 @@ public class KsqlEngineTest {\n     );\n \n     // Then:\n-    assertThat(e, rawMessage(is(\n-        \"Cannot add stream 'FOO': A stream with the same name already exists\")));\n-    assertThat(e, statementText(is(\n-        \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS;\")));\n+    assertThat(e, rawMessage(\n+        is(\n+            \"Cannot add stream 'FOO': A stream with the same name already exists\")));\n+    assertThat(e, statementText(\n+        is(\n+            \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS;\")));\n   }\n \n   @Test\n", "next_change": {"commit": "b01aebc5c183bccf95895a9952edd7e40aed243f", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex aba0368ceee..c7e24a878fd 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1336,22 +1330,13 @@ public class KsqlEngineTest {\n     final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n \n     // When:\n-    final KsqlStatementException e = assertThrows(\n-        KsqlStatementException.class,\n-        () -> ksqlEngine.execute(\n-            serviceContext,\n-            ConfiguredStatement\n-                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n-        )\n+    ExecuteResult executeResult = ksqlEngine.execute(\n+        serviceContext,\n+        of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n-    assertThat(e, rawMessage(\n-        is(\n-            \"Cannot add stream 'FOO': A stream with the same name already exists\")));\n-    assertThat(e, statementText(\n-        is(\n-            \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS;\")));\n+    assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n   @Test\n", "next_change": {"commit": "b86142608b747306c05e75a72537ede230189c87", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c7e24a878fd..6850b5c22e9 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1331,8 +1331,8 @@ public class KsqlEngineTest {\n \n     // When:\n     ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        serviceContext, ConfiguredStatement.\n+            of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n     );\n \n     // Then:\n", "next_change": {"commit": "ff9c504abdc3f4c58e8066e277b9ffc08ad12b6a", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex 6850b5c22e9..14ba7a3391c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1336,9 +1369,42 @@ public class KsqlEngineTest {\n     );\n \n     // Then:\n+    // Ideally, the result should be a message the the stream already exists, but in this case\n+    // it returns the same Query ID that it was created by the first stream. Some code refactoring\n+    // is needed in EngineExecutor.execute() and other places to validate the cases when a\n+    // CREATE IF NOT EXISTS return a warning message only, and not an error. For now, this is a\n+    // temporary solution.\n     assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n   }\n \n+  @Test\n+  public void shouldThrowWhenExecutingDuplicateStream() {\n+    // Given:\n+    final List<ParsedStatement> parsed = ksqlEngine.parse(\n+        \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS; \"\n+            + \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS;\");\n+\n+    givenStatementAlreadyExecuted(parsed.get(0));\n+\n+    final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n+\n+    // When:\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n+    );\n+\n+    // Then:\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add stream 'FOO': A stream with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS;\")));\n+  }\n+\n   @Test\n   public void shouldThrowWhenExecutingQueriesIfCsasCreatesTable() {\n     // When:\n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex c184ebae989..b6b3364d6f2 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1041,13 +1383,20 @@ public class KsqlEngineTest {\n     final PreparedStatement<?> prepared = ksqlEngine.prepare(parsed.get(1));\n \n     // When:\n-    ExecuteResult executeResult = ksqlEngine.execute(\n-        serviceContext,\n-        of(prepared, new HashMap<>(), KSQL_CONFIG)\n+    final KsqlStatementException e = assertThrows(\n+        KsqlStatementException.class,\n+        () -> ksqlEngine.execute(\n+            serviceContext,\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+        )\n     );\n \n     // Then:\n-    assertThat(executeResult.getQuery(), is(not(Optional.empty())));\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add stream 'FOO': A stream with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS;\")));\n   }\n \n   @Test\n", "next_change": {"commit": "8c9e9280bb1f76f8d4ef88bae7c3e33426ff3d48", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex b6b3364d6f2..37236fcdc0c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -1387,16 +988,17 @@ public class KsqlEngineTest {\n         KsqlStatementException.class,\n         () -> ksqlEngine.execute(\n             serviceContext,\n-            ConfiguredStatement\n-                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n+            of(prepared, new HashMap<>(), KSQL_CONFIG)\n         )\n     );\n \n     // Then:\n-    assertThat(e, rawMessage(is(\n-        \"Cannot add stream 'FOO': A stream with the same name already exists\")));\n-    assertThat(e, statementText(is(\n-        \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS;\")));\n+    assertThat(e, rawMessage(\n+        is(\n+            \"Cannot add stream 'FOO': A stream with the same name already exists\")));\n+    assertThat(e, statementText(\n+        is(\n+            \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS;\")));\n   }\n \n   @Test\n", "next_change": {"commit": "dcce03f891451225a8f425f01eed5e4fc70e2e48", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\nindex 37236fcdc0c..2f31106a02f 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/engine/KsqlEngineTest.java\n", "chunk": "@@ -988,17 +1387,16 @@ public class KsqlEngineTest {\n         KsqlStatementException.class,\n         () -> ksqlEngine.execute(\n             serviceContext,\n-            of(prepared, new HashMap<>(), KSQL_CONFIG)\n+            ConfiguredStatement\n+                .of(prepared, SessionConfig.of(KSQL_CONFIG, new HashMap<>()))\n         )\n     );\n \n     // Then:\n-    assertThat(e, rawMessage(\n-        is(\n-            \"Cannot add stream 'FOO': A stream with the same name already exists\")));\n-    assertThat(e, statementText(\n-        is(\n-            \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS;\")));\n+    assertThat(e, rawMessage(is(\n+        \"Cannot add stream 'FOO': A stream with the same name already exists\")));\n+    assertThat(e, statementText(is(\n+        \"CREATE STREAM FOO WITH (KAFKA_TOPIC='BAR') AS SELECT * FROM ORDERS;\")));\n   }\n \n   @Test\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "20f631d97b887be07f7f7a2a19f0529aee573f12", "committedDate": "2020-12-10 16:23:28 -0800", "message": "chore: ungate protobuf and remove key.format.enabled config (#6754)"}, {"oid": "8c9e9280bb1f76f8d4ef88bae7c3e33426ff3d48", "committedDate": "2021-02-19 15:56:46 -0800", "message": "fix: incompatible schema causing KsqlEngineTest.shouldNotFailIfAvroSchemaEvolvable failure (#7052)"}, {"oid": "3c8d878ea19e177f458f1b6d9978264860072a0d", "committedDate": "2021-02-19 16:13:17 -0800", "message": "Merge branch '5.5.x' into 6.0.x"}, {"oid": "0de72a463263fc99da86f5dadc4dd6bad794ab21", "committedDate": "2021-02-19 16:13:28 -0800", "message": "Merge branch '6.0.x' into 6.1.x"}, {"oid": "dcce03f891451225a8f425f01eed5e4fc70e2e48", "committedDate": "2021-02-19 16:13:40 -0800", "message": "Merge branch '6.1.x'"}, {"oid": "f3838002fc4c8c085a3f62bfd34073e232416de4", "committedDate": "2021-03-09 21:03:59 -0800", "message": "fix: fix the cache max bytes buffering check (#7181)"}, {"oid": "3604bc86204bae486f6cab3b67a553fa246ad6ee", "committedDate": "2021-04-06 22:01:07 -0700", "message": "refactor: reorganize query management and clean up listeners (#7320)"}, {"oid": "2b7df17d64f4dec9dc5e42e0584dca7f52705c87", "committedDate": "2021-05-05 17:59:32 -0700", "message": "chore: refactor QueryMetadata and PersistentQueryMetadata (#7460)"}, {"oid": "eddac720fc5c045fd5f7059d90b0ed3c666f7bdc", "committedDate": "2021-07-20 15:02:10 -0500", "message": "[KCI-612] Clean up a terminated query's state stores (#7729)"}, {"oid": "9e532cecf7c76d893d8226e54701eee30b4a616b", "committedDate": "2021-08-25 20:18:33 -0500", "message": "refactor: make sink source optional in PersistentQueryMetadata (#8052)"}, {"oid": "44e812952daff844bc646cb92b935ac738f074c1", "committedDate": "2021-08-25 21:21:53 -0500", "message": "feat: shared runtimes (#7721)"}, {"oid": "e2c3211c23eac9c92806d013c7ad8e4f1bef7ae7", "committedDate": "2021-08-27 22:01:18 -0500", "message": "feat: execute source table query plans (#8061)"}, {"oid": "fb966001349fd6ba383764f547796ebc4982ec9c", "committedDate": "2021-08-30 14:34:27 -0500", "message": "chore: reject TERMINATE commands on CST tables (#8071)"}, {"oid": "4831e6b099cca2be51a659d2bb4112ead0cd8387", "committedDate": "2021-09-02 16:02:21 -0500", "message": "feat: introduce stream pull queries for HTTP/1 (#8064)"}, {"oid": "a14f957c1c094920b81552e87c15e72a34e93d0c", "committedDate": "2021-09-09 15:57:34 -0500", "message": "feat: disable stream pull queries by default (#8115)"}, {"oid": "f03755e2c965a3bd15f9090e2e1d8940ea4ecd3d", "committedDate": "2021-09-17 14:08:08 -0500", "message": "fix: CREATE OR REPLACE TABLE on an existing query fails while initializing the kafka streams (#8130)"}, {"oid": "a7c6ebeb946df62aed9d0ca1c8724e6f7dd6a18e", "committedDate": "2021-09-30 14:25:36 -0700", "message": "fix: ClassCastException when dropping sources with 2+ insert queries (#8205)"}, {"oid": "c317788c019889e1154a2b63855b0f8fadafa336", "committedDate": "2021-11-18 00:52:49 -0800", "message": "chore: refactor SharedKafkaStreamsRuntime into abstract class (#8355)"}, {"oid": "6c73a1438722f657c134345234c1be849c891d12", "committedDate": "2021-11-22 14:23:17 -0600", "message": "feat: clean up based on query id for shared runtimes (#8383)"}, {"oid": "cf831c5a3c8ef5ef70446a678be77ca87a08e67a", "committedDate": "2021-12-03 14:51:58 -0600", "message": "Kci 1081/implement endpoint for query scaling server configs (#8334)"}, {"oid": "0c7da2ea0432c8adb1f137303e7780a7d402d11a", "committedDate": "2021-12-09 19:15:30 -0800", "message": "test: add functional tests for INSERT statements with headers (#8471)"}, {"oid": "00072288077232aa3c97dde090879eccf256f633", "committedDate": "2021-12-13 20:21:23 -0600", "message": "refactor: eliminate static metrics registry (#8498)"}, {"oid": "df29d27707de96dcce97f81e76c98f225a7442d2", "committedDate": "2021-12-16 10:37:17 -0600", "message": "feat: new runtime selection (#8472)"}, {"oid": "fbecd71daca4cbe734cb69be2037cc9a36dbf994", "committedDate": "2021-12-17 10:48:54 -0600", "message": "feat: Drop query from assignor (#8523)"}, {"oid": "f42225d2061af37ba0edf04be94d1e6eebd061b9", "committedDate": "2022-01-18 14:52:37 -0800", "message": "fix: back out post-3.1 changes to fix 7.1.x build (#8599)"}, {"oid": "6c3320c670a86a380a46dfe4c7208fdaf1f9159c", "committedDate": "2022-01-19 22:39:25 -0800", "message": "Revert \"fix: back out post-3.1 changes to fix 7.1.x build (#8599)\""}, {"oid": "cd99f26aebffcbf55b29527effa394b9e1c2ee3a", "committedDate": "2022-01-27 08:53:54 -0600", "message": "fix: clean up custom prefixed internal topics (#8640)"}, {"oid": "53ddafe72dd8b2d284e9575cff856680b4280bba", "committedDate": "2022-03-07 18:17:23 -0600", "message": "fix: clean up mistaken topic names (#8857)"}, {"oid": "660c3256abd565067814e436d187d998cd8741b7", "committedDate": "2022-03-28 12:27:07 -0700", "message": "chore: remove SqlFormatInjector as obsolete (#8931)"}, {"oid": "db8e8bcb33d0c53bf2f5e71d5b802962a1a1294d", "committedDate": "2022-03-31 13:37:47 -0700", "message": "fix: preserve old schema behavior for protobuf wrapped primitives (#8934)"}, {"oid": "a4ef4d2377cda3e86e2c406238459e3405828cbd", "committedDate": "2022-03-31 20:35:28 -0700", "message": "chore: remove SqlFormatInjector as obsolete (7.0.x) (#8940)"}, {"oid": "aa458e0b076a249b6a63eed9ef9bd4ec87f30e46", "committedDate": "2022-03-31 20:38:32 -0700", "message": "Merge branch '7.0.x' into 7.1.x"}, {"oid": "20b75ea451468d7f80f905d46e5698a3979160a2", "committedDate": "2022-03-31 20:40:52 -0700", "message": "Merge branch '7.1.x'"}, {"oid": "d2ca6e1cf182e8c7e081401031fdee86b0c9a8e7", "committedDate": "2022-04-01 19:58:35 -0400", "message": "test: fix bad merge from 7.1.x (#8966)"}, {"oid": "57f3596ba3030029a8a08ed38c69952fd5d1dad9", "committedDate": "2022-04-08 11:02:25 +0200", "message": "fix: Improved/fixed aggregate function error messages. (#8977)"}, {"oid": "503e4cd1baa00038491313527fac37972575e64e", "committedDate": "2022-04-19 17:56:07 -0700", "message": "fix: use the engine's KsqlConfig to build queries (#9040)"}, {"oid": "9f0f74a993f2703bc8b381191b9cac6d34152c54", "committedDate": "2022-07-14 22:56:30 -0400", "message": "feat: Support pausing/resuming persistent queries (#9203)"}, {"oid": "a4364bf853ba13ab33867572907008456f5df623", "committedDate": "2022-07-15 13:17:39 -0400", "message": "refactor: Migrate legacy UDAFs to use current annotations (#9272)"}, {"oid": "fe1b0324baad586f61a4a4f7abf890b4bd121636", "committedDate": "2022-08-11 16:15:35 +0300", "message": "chore: improve logging for master (#9428)"}, {"oid": "d4c24d20fe9019356d40627d186128e25e2db958", "committedDate": "2022-08-12 13:07:56 -0700", "message": "test: Fix more tests related to topic validation"}, {"oid": "e591ff35e642ce1c8a81fb695d60de5d6bfa0a98", "committedDate": "2022-08-30 16:14:37 +0200", "message": "feat: hard delete internal schemas for persistent queries. (#9496)"}, {"oid": "173a2ca4c74d5f35b3abca7bc6e8e5b1f654d50a", "committedDate": "2022-09-16 11:01:13 +0200", "message": "fix-9243: improving error messages (#9531)"}, {"oid": "b0205ac1037c092a7a759bcdb90fa7c84e428822", "committedDate": "2022-09-22 11:42:50 +0200", "message": "fix: enhance error messages when source has extra/lacks double quotes (#9573)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2Njg0NQ==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r486966845", "body": "This change should be reverted.", "bodyText": "This change should be reverted.", "bodyHTML": "<p dir=\"auto\">This change should be reverted.</p>", "author": "big-andy-coates", "createdAt": "2020-09-11T10:50:52Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java", "diffHunk": "@@ -63,6 +63,7 @@\n import io.confluent.ksql.version.metrics.ActivenessRegistrar;\n import java.net.URL;\n import java.time.Duration;\n+import java.util.Arrays;", "originalCommit": "fa376379e975aebdaa414b59d5f8ebd7616cb433", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "changed_code": [{"header": "diff --git a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\nindex 7787fd972b9..8cd7e4b3e31 100644\n--- a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\n+++ b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\n", "chunk": "@@ -63,7 +63,6 @@ import io.confluent.ksql.util.KsqlStatementException;\n import io.confluent.ksql.version.metrics.ActivenessRegistrar;\n import java.net.URL;\n import java.time.Duration;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n", "next_change": {"commit": "b01aebc5c183bccf95895a9952edd7e40aed243f", "changed_code": [{"header": "diff --git a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\nindex 8cd7e4b3e31..d042121d6ec 100644\n--- a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\n+++ b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\n", "chunk": "@@ -63,6 +63,7 @@ import io.confluent.ksql.util.KsqlStatementException;\n import io.confluent.ksql.version.metrics.ActivenessRegistrar;\n import java.net.URL;\n import java.time.Duration;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n", "next_change": {"commit": "7dfd7f5c9b3ceddd3a3db61aed750b6f82044927", "changed_code": [{"header": "diff --git a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\nindex d042121d6ec..8cd7e4b3e31 100644\n--- a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\n+++ b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\n", "chunk": "@@ -63,7 +63,6 @@ import io.confluent.ksql.util.KsqlStatementException;\n import io.confluent.ksql.version.metrics.ActivenessRegistrar;\n import java.net.URL;\n import java.time.Duration;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\nindex 7787fd972b9..8cd7e4b3e31 100644\n--- a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\n+++ b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\n", "chunk": "@@ -63,7 +63,6 @@ import io.confluent.ksql.util.KsqlStatementException;\n import io.confluent.ksql.version.metrics.ActivenessRegistrar;\n import java.net.URL;\n import java.time.Duration;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n", "next_change": {"commit": "53e361edda83be80f9ea51b69488f2d25b9491f9", "changed_code": [{"header": "diff --git a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\nindex 8cd7e4b3e31..5126cd4a495 100644\n--- a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\n+++ b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\n", "chunk": "@@ -64,6 +64,7 @@ import io.confluent.ksql.version.metrics.ActivenessRegistrar;\n import java.net.URL;\n import java.time.Duration;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n", "next_change": {"commit": "adac20b731bf548846f55c25eeff26261d6ca5c9", "changed_code": [{"header": "diff --git a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\nindex 5126cd4a495..bdfefe93c12 100644\n--- a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\n+++ b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\n", "chunk": "@@ -55,14 +61,22 @@ import io.confluent.ksql.services.SandboxedServiceContext;\n import io.confluent.ksql.services.ServiceContext;\n import io.confluent.ksql.statement.Injector;\n import io.confluent.ksql.statement.Injectors;\n+import io.confluent.ksql.tools.test.SqlTestExecutor;\n+import io.confluent.ksql.tools.test.parser.SqlTestLoader;\n+import io.confluent.ksql.tools.test.parser.SqlTestLoader.SqlTest;\n import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlConfigurable;\n import io.confluent.ksql.util.KsqlException;\n import io.confluent.ksql.util.KsqlHostInfo;\n import io.confluent.ksql.util.KsqlRequestConfig;\n import io.confluent.ksql.util.KsqlStatementException;\n import io.confluent.ksql.version.metrics.ActivenessRegistrar;\n+import java.io.IOException;\n import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.time.Duration;\n+import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n", "next_change": null}, {"header": "diff --git a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\nindex 5126cd4a495..bdfefe93c12 100644\n--- a/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\n+++ b/ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java\n", "chunk": "@@ -73,6 +87,7 @@ import java.util.Set;\n import java.util.function.BiFunction;\n import java.util.function.Supplier;\n import java.util.regex.PatternSyntaxException;\n+import org.apache.commons.io.FileUtils;\n import org.apache.kafka.streams.StreamsConfig;\n import org.apache.kafka.streams.state.HostInfo;\n import org.slf4j.Logger;\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "3893bb372cead9ae830f801954e82f8710258d42", "committedDate": "2021-03-09 09:46:56 -0800", "message": "chore: improve error logs (#7182)"}, {"oid": "53e361edda83be80f9ea51b69488f2d25b9491f9", "committedDate": "2021-03-26 12:39:36 +0000", "message": "Set should fail for config that cannot be changed in session (#7289)"}, {"oid": "f6dd212a50a6c247f2c7a946da3144a0f1460fc7", "committedDate": "2021-03-29 09:03:06 -0700", "message": "feat: enable variable substitution for /query-stream and /ksql endpoints (#7271)"}, {"oid": "438f42a7837599900518c4bac26a766a09dee99c", "committedDate": "2021-04-13 12:39:39 -0700", "message": "fix: add sessionVariables to /ksql endpoint validator (#7365)"}, {"oid": "3b54e439ecd0ab58ed851a72a66e4e60fc04a3d5", "committedDate": "2021-05-18 12:58:31 +0100", "message": "Run query anon logger (#7523)"}, {"oid": "cf831c5a3c8ef5ef70446a678be77ca87a08e67a", "committedDate": "2021-12-03 14:51:58 -0600", "message": "Kci 1081/implement endpoint for query scaling server configs (#8334)"}, {"oid": "c4b4d67ed993b9bab0b5cfe4b1d705bfd62060e7", "committedDate": "2021-12-16 15:09:44 +0100", "message": "feat: Allow to plug-in custom error handling for Connect server errors (#8480)"}, {"oid": "d8ff588d6b8afcc7059f08a7c6eb0002fc6ecd43", "committedDate": "2022-02-03 22:41:37 -0600", "message": "feat: include checking the the config during validation of SET (#8718)"}, {"oid": "7b3fb6b078a02c48ab4fe976ca836b8efe514a59", "committedDate": "2022-04-08 09:55:06 -0700", "message": "revert: custom error handling plugin for Connect server errors (#8983)"}, {"oid": "f63e10f102670067f2a56cdd28697ee83705d491", "committedDate": "2022-04-08 22:01:24 -0500", "message": "chore: resolve configs before checking if they are query level (#8985)"}, {"oid": "503e4cd1baa00038491313527fac37972575e64e", "committedDate": "2022-04-19 17:56:07 -0700", "message": "fix: use the engine's KsqlConfig to build queries (#9040)"}, {"oid": "86d4fbbe8f438044aa0f43542fe1809d36174978", "committedDate": "2022-05-31 09:55:19 -0500", "message": "fix: move misplaced query-level configs to the correct list (#9144)"}, {"oid": "848e1791d02fc548342d8805d9b09483debf2192", "committedDate": "2022-07-12 18:06:17 -0700", "message": "fix: masked properties for create connector statement (#9244)"}, {"oid": "fe1b0324baad586f61a4a4f7abf890b4bd121636", "committedDate": "2022-08-11 16:15:35 +0300", "message": "chore: improve logging for master (#9428)"}, {"oid": "b2b5584214835a04723823d96116a6989e5e092b", "committedDate": "2022-08-12 11:30:31 -0400", "message": "fix: apply custom error handler to KsqlStatementException (MINOR) (#9442)"}, {"oid": "adac20b731bf548846f55c25eeff26261d6ca5c9", "committedDate": "2022-10-19 15:58:39 -0700", "message": "feat: add endpoint to run sql tests (#9617)"}, {"oid": "58c9b55de7aaa69a03c79334d0a70dbf15e7e65b", "committedDate": "2022-11-04 00:12:18 -0700", "message": "chore: Use QueryLogger any time we log a query (#9681)"}, {"oid": "1170d714395b6c020e7d7e34d73fa58708554c53", "committedDate": "2022-11-13 12:26:36 -0600", "message": "chore: Use QueryLogger to log queries, part 2 (#9695)"}]}, {"oid": "678163151432e1e935c4acbb426f41b75b22b488", "url": "https://github.com/confluentinc/ksql/commit/678163151432e1e935c4acbb426f41b75b22b488", "message": "Fixed tests", "committedDate": "2020-09-26T07:42:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAxODk0MQ==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r516018941", "body": "Could you add two more tests shouldNotThrowWhenCreateStreamIfNotExistsIsSet and same for a table?", "bodyText": "Could you add two more tests shouldNotThrowWhenCreateStreamIfNotExistsIsSet and same for a table?", "bodyHTML": "<p dir=\"auto\">Could you add two more tests shouldNotThrowWhenCreateStreamIfNotExistsIsSet and same for a table?</p>", "author": "spena", "createdAt": "2020-11-02T14:43:51Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java", "diffHunk": "@@ -911,6 +929,41 @@ public void shouldThrowIfTableIsMissingPrimaryKey() {\n         containsString(\"Tables require a PRIMARY KEY. Please define the PRIMARY KEY.\"));\n   }\n \n+  @Test\n+  public void shouldThrowIfStreamExits() {", "originalCommit": "7e21ffdca8e2558c7baef50a474643a2d260bd2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\nindex 79f38a71e1e..cfcd02ea5bb 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n", "chunk": "@@ -930,7 +954,21 @@ public class CreateSourceFactoryTest {\n   }\n \n   @Test\n-  public void shouldThrowIfStreamExits() {\n+  public void shouldNotThrowOnCreateStreamIfNotExistsIsSet() {\n+    // Given:\n+    final CreateStream ddlStatement =\n+        new CreateStream(SOME_NAME, STREAM_ELEMENTS, false, true, withProperties);\n+\n+    // When:\n+    final CreateStreamCommand result = createSourceFactory\n+        .createStreamCommand(ddlStatement, ksqlConfig);\n+\n+    // Then:\n+    assertThat(result.getSourceName(), is(SOME_NAME));\n+  }\n+\n+  @Test\n+  public void shouldThrowIfStreamExists() {\n     // Given:\n     final CreateStream ddlStatement =\n         new CreateStream(SOME_NAME, STREAM_ELEMENTS, false, false, withProperties);\n", "next_change": {"commit": "2965dcdfbf2497364f33506bc22997f9f2bded83", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\nindex cfcd02ea5bb..0533cad186c 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n", "chunk": "@@ -953,72 +1014,6 @@ public class CreateSourceFactoryTest {\n         containsString(\"Tables require a PRIMARY KEY. Please define the PRIMARY KEY.\"));\n   }\n \n-  @Test\n-  public void shouldNotThrowOnCreateStreamIfNotExistsIsSet() {\n-    // Given:\n-    final CreateStream ddlStatement =\n-        new CreateStream(SOME_NAME, STREAM_ELEMENTS, false, true, withProperties);\n-\n-    // When:\n-    final CreateStreamCommand result = createSourceFactory\n-        .createStreamCommand(ddlStatement, ksqlConfig);\n-\n-    // Then:\n-    assertThat(result.getSourceName(), is(SOME_NAME));\n-  }\n-\n-  @Test\n-  public void shouldThrowIfStreamExists() {\n-    // Given:\n-    final CreateStream ddlStatement =\n-        new CreateStream(SOME_NAME, STREAM_ELEMENTS, false, false, withProperties);\n-\n-    // When:\n-    final Exception e = assertThrows(\n-        KsqlException.class, () -> createSourceFactory\n-            .createStreamCommand(ddlStatement, ksqlConfig));\n-\n-    // Then:\n-    assertThat(e.getMessage(),\n-        containsString(\"Cannot add stream 'bob': A stream with the same name already exists\"));\n-  }\n-\n-  @Test\n-  public void shouldNotThrowOnCreateTableIfNotExistsIsSet() {\n-    //Given\n-    final CreateTable ddlStatement = new CreateTable(TABLE_NAME,\n-        TableElements.of(\n-            tableElement(PRIMARY_KEY, \"COL1\", new Type(BIGINT)),\n-            tableElement(VALUE, \"COL2\", new Type(SqlTypes.STRING))),\n-        false, true, withProperties);\n-\n-    // When:\n-    final CreateTableCommand result = createSourceFactory\n-        .createTableCommand(ddlStatement, ksqlConfig);\n-\n-    // Then:\n-    assertThat(result.getSourceName(), is(TABLE_NAME));\n-  }\n-\n-  @Test\n-  public void shouldThrowIfTableExists() {\n-    //Given\n-    final CreateTable ddlStatement = new CreateTable(TABLE_NAME,\n-        TableElements.of(\n-            tableElement(PRIMARY_KEY, \"COL1\", new Type(BIGINT)),\n-            tableElement(VALUE, \"COL2\", new Type(SqlTypes.STRING))),\n-        false, false, withProperties);\n-\n-    // When:\n-    final Exception e = assertThrows(\n-        KsqlException.class, () -> createSourceFactory\n-            .createTableCommand(ddlStatement, ksqlConfig));\n-\n-    // Then:\n-    assertThat(e.getMessage(),\n-        containsString(\"Cannot add table 'table_bob': A table with the same name already exists\"));\n-  }\n-\n   private void givenProperty(final String name, final Literal value) {\n     givenProperties(ImmutableMap.of(name, value));\n   }\n", "next_change": {"commit": "b01aebc5c183bccf95895a9952edd7e40aed243f", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\nindex 0533cad186c..e3a8be69f87 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n", "chunk": "@@ -1014,6 +1020,41 @@ public class CreateSourceFactoryTest {\n         containsString(\"Tables require a PRIMARY KEY. Please define the PRIMARY KEY.\"));\n   }\n \n+  @Test\n+  public void shouldThrowIfStreamExits() {\n+    // Given:\n+    final CreateStream ddlStatement =\n+        new CreateStream(SOME_NAME, STREAM_ELEMENTS, false, false, withProperties);\n+\n+    // When:\n+    final Exception e = assertThrows(\n+        KsqlException.class, () -> createSourceFactory\n+            .createStreamCommand(ddlStatement, ksqlConfig));\n+\n+    // Then:\n+    assertThat(e.getMessage(),\n+        containsString(\"A STREAM with the same name already exists\"));\n+  }\n+\n+  @Test\n+  public void shouldThrowIfTableExits() {\n+    //Given\n+    final CreateTable ddlStatement = new CreateTable(TABLE_NAME,\n+        TableElements.of(\n+            tableElement(PRIMARY_KEY, \"COL1\", new Type(BIGINT)),\n+            tableElement(VALUE, \"COL2\", new Type(SqlTypes.STRING))),\n+        false, false, withProperties);\n+\n+    // When:\n+    final Exception e = assertThrows(\n+        KsqlException.class, () -> createSourceFactory\n+            .createTableCommand(ddlStatement, ksqlConfig));\n+\n+    // Then:\n+    assertThat(e.getMessage(),\n+        containsString(\"A TABLE with the same name already exists\"));\n+  }\n+\n   private void givenProperty(final String name, final Literal value) {\n     givenProperties(ImmutableMap.of(name, value));\n   }\n", "next_change": {"commit": "6bc0a99931a32165c416d02b1de6a9bb90325caf", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\nindex e3a8be69f87..6c4729f2165 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n", "chunk": "@@ -1052,7 +1052,7 @@ public class CreateSourceFactoryTest {\n \n     // Then:\n     assertThat(e.getMessage(),\n-        containsString(\"A TABLE with the same name already exists\"));\n+        containsString(\"Cannot add table 'table_bob': A table with the same name already exists\"));\n   }\n \n   private void givenProperty(final String name, final Literal value) {\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\nindex 79f38a71e1e..0560d554788 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n", "chunk": "@@ -930,7 +1033,21 @@ public class CreateSourceFactoryTest {\n   }\n \n   @Test\n-  public void shouldThrowIfStreamExits() {\n+  public void shouldNotThrowOnCreateStreamIfNotExistsIsSet() {\n+    // Given:\n+    final CreateStream ddlStatement =\n+        new CreateStream(SOME_NAME, STREAM_ELEMENTS, false, true, withProperties);\n+\n+    // When:\n+    final CreateStreamCommand result = createSourceFactory\n+        .createStreamCommand(ddlStatement, ksqlConfig);\n+\n+    // Then:\n+    assertThat(result.getSourceName(), is(SOME_NAME));\n+  }\n+\n+  @Test\n+  public void shouldThrowIfStreamExists() {\n     // Given:\n     final CreateStream ddlStatement =\n         new CreateStream(SOME_NAME, STREAM_ELEMENTS, false, false, withProperties);\n", "next_change": {"commit": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\nindex 0560d554788..726c4a8b403 100644\n--- a/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n+++ b/ksqldb-engine/src/test/java/io/confluent/ksql/ddl/commands/CreateSourceFactoryTest.java\n", "chunk": "@@ -1050,7 +1093,7 @@ public class CreateSourceFactoryTest {\n   public void shouldThrowIfStreamExists() {\n     // Given:\n     final CreateStream ddlStatement =\n-        new CreateStream(SOME_NAME, STREAM_ELEMENTS, false, false, withProperties);\n+        new CreateStream(SOME_NAME, STREAM_ELEMENTS, false, false, withProperties, false);\n \n     // When:\n     final Exception e = assertThrows(\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "9988e6af3266319e8caf978a904f5d55c8986623", "committedDate": "2021-02-05 16:26:35 -0800", "message": "Revert \"fix: throw error message on create source with no value columns (#6680)\" (#6959)"}, {"oid": "6cdce0a2632bd0512407e4a9e7d27b58fd1df1e6", "committedDate": "2021-05-23 08:25:17 -0700", "message": "chore: add FK-join logical to physical plan translation (#7570)"}, {"oid": "70565f2969df109c6fd4ae6bb7c48c5365c45f9d", "committedDate": "2021-08-11 16:10:36 -0500", "message": "feat: add CREATE SOURCE TABLE syntax and metadata info (#7945)"}, {"oid": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "committedDate": "2021-08-18 12:27:21 -0700", "message": "feat: add CREATE SOURCE STREAM syntax and metadata info (#8004)"}, {"oid": "abe47c335e148c41befa5213e6f116474128ec4b", "committedDate": "2021-09-30 16:25:12 -0500", "message": "chore: disable CREATE OR REPLACE on source streams and tables (#8199)"}, {"oid": "db76b3ec11c97edf7ba870a073e5805c340b9ec6", "committedDate": "2021-11-15 13:55:38 -0800", "message": "feat: add syntax for HEADER(<key>) columns (#8350)"}, {"oid": "31d7456a03b03d46b9de33622c75b53b54c80c7f", "committedDate": "2021-11-30 10:22:32 -0800", "message": "chore: add key/value schema name prop and refactor (#8418)"}, {"oid": "2af201f45f45092d596a4844ca5f139455328844", "committedDate": "2022-07-07 14:15:28 -0700", "message": "feat: enable new emit-final implementation (#9141)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAxOTk4NQ==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r516019985", "body": "Is this part of the changes? Should it be reverted?", "bodyText": "Is this part of the changes? Should it be reverted?", "bodyHTML": "<p dir=\"auto\">Is this part of the changes? Should it be reverted?</p>", "author": "spena", "createdAt": "2020-11-02T14:45:20Z", "path": "ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java", "diffHunk": "@@ -109,11 +109,11 @@ public void init() {\n \n     final String endpointHttp = supportConfig.getEndpointHttp();\n     final String endpointHttps = supportConfig.getEndpointHttps();\n-    final String proxyURI = supportConfig.getProxy();\n+    final String proxyUri = supportConfig.getProxy();", "originalCommit": "7e21ffdca8e2558c7baef50a474643a2d260bd2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "changed_code": [{"header": "diff --git a/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java b/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java\nindex 00c33e9fd05..24df8518616 100644\n--- a/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java\n+++ b/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java\n", "chunk": "@@ -109,11 +109,11 @@ public abstract class BaseMetricsReporter extends Thread implements Closeable {\n \n     final String endpointHttp = supportConfig.getEndpointHttp();\n     final String endpointHttps = supportConfig.getEndpointHttps();\n-    final String proxyUri = supportConfig.getProxy();\n+    final String proxyURI = supportConfig.getProxy();\n \n     if (!endpointHttp.isEmpty() || !endpointHttps.isEmpty()) {\n       confluentSubmitter = new ConfluentSubmitter(customerId, endpointHttp, endpointHttps,\n-          proxyUri, responseHandler);\n+          proxyURI, responseHandler);\n     } else {\n       confluentSubmitter = null;\n     }\n", "next_change": {"commit": "7dfd7f5c9b3ceddd3a3db61aed750b6f82044927", "changed_code": [{"header": "diff --git a/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java b/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java\nindex 24df8518616..00c33e9fd05 100644\n--- a/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java\n+++ b/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java\n", "chunk": "@@ -109,11 +109,11 @@ public abstract class BaseMetricsReporter extends Thread implements Closeable {\n \n     final String endpointHttp = supportConfig.getEndpointHttp();\n     final String endpointHttps = supportConfig.getEndpointHttps();\n-    final String proxyURI = supportConfig.getProxy();\n+    final String proxyUri = supportConfig.getProxy();\n \n     if (!endpointHttp.isEmpty() || !endpointHttps.isEmpty()) {\n       confluentSubmitter = new ConfluentSubmitter(customerId, endpointHttp, endpointHttps,\n-          proxyURI, responseHandler);\n+          proxyUri, responseHandler);\n     } else {\n       confluentSubmitter = null;\n     }\n", "next_change": {"commit": "ff9c504abdc3f4c58e8066e277b9ffc08ad12b6a", "changed_code": [{"header": "diff --git a/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java b/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java\nindex 00c33e9fd05..24df8518616 100644\n--- a/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java\n+++ b/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java\n", "chunk": "@@ -109,11 +109,11 @@ public abstract class BaseMetricsReporter extends Thread implements Closeable {\n \n     final String endpointHttp = supportConfig.getEndpointHttp();\n     final String endpointHttps = supportConfig.getEndpointHttps();\n-    final String proxyUri = supportConfig.getProxy();\n+    final String proxyURI = supportConfig.getProxy();\n \n     if (!endpointHttp.isEmpty() || !endpointHttps.isEmpty()) {\n       confluentSubmitter = new ConfluentSubmitter(customerId, endpointHttp, endpointHttps,\n-          proxyUri, responseHandler);\n+          proxyURI, responseHandler);\n     } else {\n       confluentSubmitter = null;\n     }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java b/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java\nindex 00c33e9fd05..24df8518616 100644\n--- a/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java\n+++ b/ksqldb-version-metrics-client/src/main/java/io/confluent/support/metrics/BaseMetricsReporter.java\n", "chunk": "@@ -109,11 +109,11 @@ public abstract class BaseMetricsReporter extends Thread implements Closeable {\n \n     final String endpointHttp = supportConfig.getEndpointHttp();\n     final String endpointHttps = supportConfig.getEndpointHttps();\n-    final String proxyUri = supportConfig.getProxy();\n+    final String proxyURI = supportConfig.getProxy();\n \n     if (!endpointHttp.isEmpty() || !endpointHttps.isEmpty()) {\n       confluentSubmitter = new ConfluentSubmitter(customerId, endpointHttp, endpointHttps,\n-          proxyUri, responseHandler);\n+          proxyURI, responseHandler);\n     } else {\n       confluentSubmitter = null;\n     }\n", "next_change": null}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "b13f1c289bb70fc3f528514ea4624acbdaef7c7c", "committedDate": "2021-07-27 20:45:22 -0700", "message": "build: update multiple modules for spotbug 4.3.0 and re-enable plugin (#7818)"}]}, {"oid": "b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "url": "https://github.com/confluentinc/ksql/commit/b7aada836ecdaaa0aa882d5d1a5fd1a26fac263b", "message": "fix: check IF NOT EXISTS is set in EngineExecutor", "committedDate": "2020-11-06T18:51:47Z", "type": "forcePushed"}, {"oid": "b1ea1535fbf00211e33449cddf2ba64792c1b9c3", "url": "https://github.com/confluentinc/ksql/commit/b1ea1535fbf00211e33449cddf2ba64792c1b9c3", "message": "fix: display warning message with C*AS + IF NOT EXISTS statements", "committedDate": "2020-11-13T22:01:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI1ODM4NQ==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r523258385", "body": "I had to build the query information from the plan instead of executing it. This avoids failing with an error if the `IF NOT EXISTS` keyword is used in the CREATE_AS statement. Also, this seems a better approach than execution 'cause this injector is only registering the schema in SR.", "bodyText": "I had to build the query information from the plan instead of executing it. This avoids failing with an error if the IF NOT EXISTS keyword is used in the CREATE_AS statement. Also, this seems a better approach than execution 'cause this injector is only registering the schema in SR.", "bodyHTML": "<p dir=\"auto\">I had to build the query information from the plan instead of executing it. This avoids failing with an error if the <code>IF NOT EXISTS</code> keyword is used in the CREATE_AS statement. Also, this seems a better approach than execution 'cause this injector is only registering the schema in SR.</p>", "author": "spena", "createdAt": "2020-11-13T22:05:11Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java", "diffHunk": "@@ -110,26 +109,28 @@ private void registerForCreateSource(final ConfiguredStatement<? extends CreateS\n   }\n \n   private void registerForCreateAs(final ConfiguredStatement<? extends CreateAsSelect> cas) {\n-    final ServiceContext sandboxServiceContext = SandboxedServiceContext.create(serviceContext);\n-    final ExecuteResult executeResult = executionContext\n-        .createSandbox(sandboxServiceContext)\n-        .execute(sandboxServiceContext, cas);\n-\n-    final PersistentQueryMetadata queryMetadata = (PersistentQueryMetadata) executeResult\n-        .getQuery()\n-        .orElseThrow(() -> new KsqlStatementException(\n-            \"Could not determine output schema for query due to error: \"\n-                + executeResult.getCommandResult(),\n-            cas.getStatementText()\n-        ));\n+    final CreateSourceCommand createSourceCommand;\n+\n+    try {\n+      final ServiceContext sandboxServiceContext = SandboxedServiceContext.create(serviceContext);\n+      createSourceCommand = (CreateSourceCommand)\n+          executionContext.createSandbox(sandboxServiceContext)\n+              .plan(sandboxServiceContext, cas)\n+              .getDdlCommand()\n+              .get();\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          \"Could not determine output schema for query due to error: \"\n+              + e.getMessage(), cas.getStatementText(), e);\n+    }\n \n     registerSchemas(\n-        queryMetadata.getLogicalSchema(),\n-        queryMetadata.getResultTopic().getKafkaTopicName(),\n-        queryMetadata.getResultTopic().getKeyFormat().getFormatInfo(),\n-        queryMetadata.getPhysicalSchema().keySchema().features(),\n-        queryMetadata.getResultTopic().getValueFormat().getFormatInfo(),\n-        queryMetadata.getPhysicalSchema().valueSchema().features(),\n+        createSourceCommand.getSchema(),\n+        createSourceCommand.getTopicName(),\n+        createSourceCommand.getFormats().getKeyFormat(),\n+        createSourceCommand.getFormats().getKeyFeatures(),\n+        createSourceCommand.getFormats().getValueFormat(),\n+        createSourceCommand.getFormats().getValueFeatures(),", "originalCommit": "b1ea1535fbf00211e33449cddf2ba64792c1b9c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2965dcdfbf2497364f33506bc22997f9f2bded83", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java b/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java\nindex 342b740a387..e0b6fafdc27 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java\n", "chunk": "@@ -109,28 +111,26 @@ public class SchemaRegisterInjector implements Injector {\n   }\n \n   private void registerForCreateAs(final ConfiguredStatement<? extends CreateAsSelect> cas) {\n-    final CreateSourceCommand createSourceCommand;\n-\n-    try {\n-      final ServiceContext sandboxServiceContext = SandboxedServiceContext.create(serviceContext);\n-      createSourceCommand = (CreateSourceCommand)\n-          executionContext.createSandbox(sandboxServiceContext)\n-              .plan(sandboxServiceContext, cas)\n-              .getDdlCommand()\n-              .get();\n-    } catch (final Exception e) {\n-      throw new KsqlStatementException(\n-          \"Could not determine output schema for query due to error: \"\n-              + e.getMessage(), cas.getStatementText(), e);\n-    }\n+    final ServiceContext sandboxServiceContext = SandboxedServiceContext.create(serviceContext);\n+    final ExecuteResult executeResult = executionContext\n+        .createSandbox(sandboxServiceContext)\n+        .execute(sandboxServiceContext, cas);\n+\n+    final PersistentQueryMetadata queryMetadata = (PersistentQueryMetadata) executeResult\n+        .getQuery()\n+        .orElseThrow(() -> new KsqlStatementException(\n+            \"Could not determine output schema for query due to error: \"\n+                + executeResult.getCommandResult(),\n+            cas.getStatementText()\n+        ));\n \n     registerSchemas(\n-        createSourceCommand.getSchema(),\n-        createSourceCommand.getTopicName(),\n-        createSourceCommand.getFormats().getKeyFormat(),\n-        createSourceCommand.getFormats().getKeyFeatures(),\n-        createSourceCommand.getFormats().getValueFormat(),\n-        createSourceCommand.getFormats().getValueFeatures(),\n+        queryMetadata.getLogicalSchema(),\n+        queryMetadata.getResultTopic().getKafkaTopicName(),\n+        queryMetadata.getResultTopic().getKeyFormat().getFormatInfo(),\n+        queryMetadata.getPhysicalSchema().keySchema().features(),\n+        queryMetadata.getResultTopic().getValueFormat().getFormatInfo(),\n+        queryMetadata.getPhysicalSchema().valueSchema().features(),\n         cas.getSessionConfig().getConfig(false),\n         cas.getStatementText(),\n         true\n", "next_change": {"commit": "9fe2c4aa6d6f6d44305d43bb1e03c6a757634b49", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java b/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java\nindex e0b6fafdc27..a1ab70129e0 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java\n", "chunk": "@@ -111,26 +110,28 @@ public class SchemaRegisterInjector implements Injector {\n   }\n \n   private void registerForCreateAs(final ConfiguredStatement<? extends CreateAsSelect> cas) {\n-    final ServiceContext sandboxServiceContext = SandboxedServiceContext.create(serviceContext);\n-    final ExecuteResult executeResult = executionContext\n-        .createSandbox(sandboxServiceContext)\n-        .execute(sandboxServiceContext, cas);\n-\n-    final PersistentQueryMetadata queryMetadata = (PersistentQueryMetadata) executeResult\n-        .getQuery()\n-        .orElseThrow(() -> new KsqlStatementException(\n-            \"Could not determine output schema for query due to error: \"\n-                + executeResult.getCommandResult(),\n-            cas.getStatementText()\n-        ));\n+    final CreateSourceCommand createSourceCommand;\n+\n+    try {\n+      final ServiceContext sandboxServiceContext = SandboxedServiceContext.create(serviceContext);\n+      createSourceCommand = (CreateSourceCommand)\n+          executionContext.createSandbox(sandboxServiceContext)\n+              .plan(sandboxServiceContext, cas)\n+              .getDdlCommand()\n+              .get();\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          \"Could not determine output schema for query due to error: \"\n+              + e.getMessage(), cas.getStatementText(), e);\n+    }\n \n     registerSchemas(\n-        queryMetadata.getLogicalSchema(),\n-        queryMetadata.getResultTopic().getKafkaTopicName(),\n-        queryMetadata.getResultTopic().getKeyFormat().getFormatInfo(),\n-        queryMetadata.getPhysicalSchema().keySchema().features(),\n-        queryMetadata.getResultTopic().getValueFormat().getFormatInfo(),\n-        queryMetadata.getPhysicalSchema().valueSchema().features(),\n+        createSourceCommand.getSchema(),\n+        createSourceCommand.getTopicName(),\n+        createSourceCommand.getFormats().getKeyFormat(),\n+        createSourceCommand.getFormats().getKeyFeatures(),\n+        createSourceCommand.getFormats().getValueFormat(),\n+        createSourceCommand.getFormats().getValueFeatures(),\n         cas.getSessionConfig().getConfig(false),\n         cas.getStatementText(),\n         true\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "b490204eefcdbf3fbdf8ae34a16beaa9c229ec1b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java b/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java\nindex 342b740a387..55d474f1d02 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java\n", "chunk": "@@ -124,8 +134,14 @@ public class SchemaRegisterInjector implements Injector {\n               + e.getMessage(), cas.getStatementText(), e);\n     }\n \n+    final SchemaAndId rawKeySchema = (SchemaAndId) cas.getSessionConfig().getOverrides()\n+        .get(CommonCreateConfigs.KEY_SCHEMA_ID);\n+    final SchemaAndId rawValueSchema = (SchemaAndId) cas.getSessionConfig().getOverrides()\n+        .get(CommonCreateConfigs.VALUE_SCHEMA_ID);\n+\n     registerSchemas(\n         createSourceCommand.getSchema(),\n+        Pair.of(rawKeySchema, rawValueSchema),\n         createSourceCommand.getTopicName(),\n         createSourceCommand.getFormats().getKeyFormat(),\n         createSourceCommand.getFormats().getKeyFeatures(),\n", "next_change": {"commit": "fe1b0324baad586f61a4a4f7abf890b4bd121636", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java b/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java\nindex 55d474f1d02..ab8ad529454 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java\n", "chunk": "@@ -148,7 +203,7 @@ public class SchemaRegisterInjector implements Injector {\n         createSourceCommand.getFormats().getValueFormat(),\n         createSourceCommand.getFormats().getValueFeatures(),\n         cas.getSessionConfig().getConfig(false),\n-        cas.getStatementText(),\n+        cas.getMaskedStatementText(),\n         true\n     );\n   }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "5010d55a529a63710899eed4b4ee6395f8d02377", "committedDate": "2020-12-08 13:31:28 -0800", "message": "chore: remove usage of SRClient#getAllSubjects (#6737)"}, {"oid": "5ea1ce4c9129260272608aa8d8263e22a23a9188", "committedDate": "2021-02-10 11:24:03 -0800", "message": "feat: Support timestamp protobuf serde (#6927)"}, {"oid": "54eb419f12ab6ffec2edf7d9dfbdbfb6ba8d78b9", "committedDate": "2021-07-13 09:11:48 -0500", "message": "refactor: wrap SchemaRegistry authorization errors into a KsqlSchemaAuthorizationException (#7783)"}, {"oid": "b490204eefcdbf3fbdf8ae34a16beaa9c229ec1b", "committedDate": "2021-12-01 18:36:09 -0800", "message": "chore: register raw parsed schema fetched from schema id if exist (#8421)"}, {"oid": "6b15250f8f012022945b26ed5eade85dd7674dbc", "committedDate": "2021-12-02 10:47:49 -0800", "message": "fix: fix broken test (#8439)"}, {"oid": "a60bb21ac2daae78788143ab7c42185ece2292c2", "committedDate": "2021-12-08 08:22:09 -0800", "message": "chore: inject schema using schema id for cas (#8441)"}, {"oid": "5ddb852afc37939baa72d9cf6e55dfde9d1e6400", "committedDate": "2022-03-09 09:59:49 -0800", "message": "fix: do not include schema id in session config (#8869)"}, {"oid": "fe1b0324baad586f61a4a4f7abf890b4bd121636", "committedDate": "2022-08-11 16:15:35 +0300", "message": "chore: improve logging for master (#9428)"}, {"oid": "1170d714395b6c020e7d7e34d73fa58708554c53", "committedDate": "2022-11-13 12:26:36 -0600", "message": "chore: Use QueryLogger to log queries, part 2 (#9695)"}]}, {"oid": "a8a1850d3d7d44231692c64c6d24e74e6e8273f2", "url": "https://github.com/confluentinc/ksql/commit/a8a1850d3d7d44231692c64c6d24e74e6e8273f2", "message": "fix: display warning message with C*AS + IF NOT EXISTS statements", "committedDate": "2020-11-19T14:34:02Z", "type": "forcePushed"}, {"oid": "9a1c44072fa8f33ae5d1faaa185bbabf1c066525", "url": "https://github.com/confluentinc/ksql/commit/9a1c44072fa8f33ae5d1faaa185bbabf1c066525", "message": "chore: fix test issue", "committedDate": "2020-12-01T03:22:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNDkyNA==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r537914924", "body": "nit: i think we should use `dataSource.getDataSourceType().getKsqlType()` here and in `executeCreateTable`", "bodyText": "nit: i think we should use dataSource.getDataSourceType().getKsqlType() here and in executeCreateTable", "bodyHTML": "<p dir=\"auto\">nit: i think we should use <code>dataSource.getDataSourceType().getKsqlType()</code> here and in <code>executeCreateTable</code></p>", "author": "jzaralim", "createdAt": "2020-12-07T23:31:07Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java", "diffHunk": "@@ -81,6 +81,16 @@ private Executor(\n \n     @Override\n     public DdlCommandResult executeCreateStream(final CreateStreamCommand createStream) {\n+      final SourceName sourceName = createStream.getSourceName();\n+      final DataSource dataSource = metaStore.getSource(sourceName);\n+\n+      if (dataSource != null && !createStream.isOrReplace()) {\n+        return new DdlCommandResult(true,\n+            String.format(\"Cannot add stream %s: A stream with the same name \"", "originalCommit": "9a1c44072fa8f33ae5d1faaa185bbabf1c066525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3NzYxNA==", "url": "https://github.com/confluentinc/ksql/pull/6073#discussion_r537977614", "bodyText": "Thanks. I updated the PR.", "author": "spena", "createdAt": "2020-12-08T02:08:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNDkyNA=="}], "type": "inlineReview", "revised_code": {"commit": "2965dcdfbf2497364f33506bc22997f9f2bded83", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 3ec826835f7..0586b2453a0 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -81,16 +81,6 @@ public class DdlCommandExec {\n \n     @Override\n     public DdlCommandResult executeCreateStream(final CreateStreamCommand createStream) {\n-      final SourceName sourceName = createStream.getSourceName();\n-      final DataSource dataSource = metaStore.getSource(sourceName);\n-\n-      if (dataSource != null && !createStream.isOrReplace()) {\n-        return new DdlCommandResult(true,\n-            String.format(\"Cannot add stream %s: A stream with the same name \"\n-                    + \"already exists.\",\n-                sourceName));\n-      }\n-\n       final KsqlStream<?> ksqlStream = new KsqlStream<>(\n           sql,\n           createStream.getSourceName(),\n", "next_change": {"commit": "b01aebc5c183bccf95895a9952edd7e40aed243f", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 0586b2453a0..3ec826835f7 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -81,6 +81,16 @@ public class DdlCommandExec {\n \n     @Override\n     public DdlCommandResult executeCreateStream(final CreateStreamCommand createStream) {\n+      final SourceName sourceName = createStream.getSourceName();\n+      final DataSource dataSource = metaStore.getSource(sourceName);\n+\n+      if (dataSource != null && !createStream.isOrReplace()) {\n+        return new DdlCommandResult(true,\n+            String.format(\"Cannot add stream %s: A stream with the same name \"\n+                    + \"already exists.\",\n+                sourceName));\n+      }\n+\n       final KsqlStream<?> ksqlStream = new KsqlStream<>(\n           sql,\n           createStream.getSourceName(),\n", "next_change": {"commit": "8a847007e1406f7ddab8263b7f824013be25f230", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 3ec826835f7..94a587fdc2f 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -85,10 +85,11 @@ public class DdlCommandExec {\n       final DataSource dataSource = metaStore.getSource(sourceName);\n \n       if (dataSource != null && !createStream.isOrReplace()) {\n+        final String sourceType = dataSource.getDataSourceType().getKsqlType();\n         return new DdlCommandResult(true,\n-            String.format(\"Cannot add stream %s: A stream with the same name \"\n+            String.format(\"Cannot add stream %s: A %s with the same name \"\n                     + \"already exists.\",\n-                sourceName));\n+                sourceName, sourceType.toLowerCase()));\n       }\n \n       final KsqlStream<?> ksqlStream = new KsqlStream<>(\n", "next_change": null}]}}, {"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 0586b2453a0..3ec826835f7 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -89,6 +99,7 @@ public class DdlCommandExec {\n           withQuery,\n           getKsqlTopic(createStream)\n       );\n+\n       metaStore.putSource(ksqlStream, createStream.isOrReplace());\n       metaStore.addSourceReferences(ksqlStream.getName(), withQuerySources);\n       return new DdlCommandResult(true, \"Stream created\");\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 3ec826835f7..94a587fdc2f 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -85,10 +85,11 @@ public class DdlCommandExec {\n       final DataSource dataSource = metaStore.getSource(sourceName);\n \n       if (dataSource != null && !createStream.isOrReplace()) {\n+        final String sourceType = dataSource.getDataSourceType().getKsqlType();\n         return new DdlCommandResult(true,\n-            String.format(\"Cannot add stream %s: A stream with the same name \"\n+            String.format(\"Cannot add stream %s: A %s with the same name \"\n                     + \"already exists.\",\n-                sourceName));\n+                sourceName, sourceType.toLowerCase()));\n       }\n \n       final KsqlStream<?> ksqlStream = new KsqlStream<>(\n", "next_change": {"commit": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "changed_code": [{"header": "diff --git a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\nindex 94a587fdc2f..5cac8a2b6e5 100644\n--- a/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n+++ b/ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java\n", "chunk": "@@ -98,7 +98,8 @@ public class DdlCommandExec {\n           createStream.getSchema(),\n           createStream.getTimestampColumn(),\n           withQuery,\n-          getKsqlTopic(createStream)\n+          getKsqlTopic(createStream),\n+          createStream.getIsSource()\n       );\n \n       metaStore.putSource(ksqlStream, createStream.isOrReplace());\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6edf7ec27aa346198d2548287b1f9f11b9729a3b", "message": "Merge commit", "committedDate": null}, {"oid": "70565f2969df109c6fd4ae6bb7c48c5365c45f9d", "committedDate": "2021-08-11 16:10:36 -0500", "message": "feat: add CREATE SOURCE TABLE syntax and metadata info (#7945)"}, {"oid": "0d0e85a0d85b02ad506f3096db6ae556f1191ac0", "committedDate": "2021-08-18 12:27:21 -0700", "message": "feat: add CREATE SOURCE STREAM syntax and metadata info (#8004)"}, {"oid": "e2c3211c23eac9c92806d013c7ad8e4f1bef7ae7", "committedDate": "2021-08-27 22:01:18 -0500", "message": "feat: execute source table query plans (#8061)"}, {"oid": "db070a211b51cfb9ef7138c9b05238ba41798f4b", "committedDate": "2022-02-25 13:58:08 -0600", "message": "fix: restore process fails due to DROP constraints (#8803)"}]}, {"oid": "2965dcdfbf2497364f33506bc22997f9f2bded83", "url": "https://github.com/confluentinc/ksql/commit/2965dcdfbf2497364f33506bc22997f9f2bded83", "message": "docs: Added missing IF NOT EXISTS to Streams and Tables doc", "committedDate": "2020-12-08T02:07:47Z", "type": "commit"}, {"oid": "b01aebc5c183bccf95895a9952edd7e40aed243f", "url": "https://github.com/confluentinc/ksql/commit/b01aebc5c183bccf95895a9952edd7e40aed243f", "message": "Fix for streams IF NOT EXISTS failing\n\nChanges reverted and added to CommandFactories\n\nFixed and added tests\n\nFixed and added tests\n\nFixed tests", "committedDate": "2020-12-08T02:07:47Z", "type": "commit"}, {"oid": "a21ee7f4984d61247c6c1c760c496e6496b95ee4", "url": "https://github.com/confluentinc/ksql/commit/a21ee7f4984d61247c6c1c760c496e6496b95ee4", "message": "Fixed tests", "committedDate": "2020-12-08T02:07:47Z", "type": "commit"}, {"oid": "b86142608b747306c05e75a72537ede230189c87", "url": "https://github.com/confluentinc/ksql/commit/b86142608b747306c05e75a72537ede230189c87", "message": "Review comments", "committedDate": "2020-12-08T02:07:47Z", "type": "commit"}, {"oid": "6bc0a99931a32165c416d02b1de6a9bb90325caf", "url": "https://github.com/confluentinc/ksql/commit/6bc0a99931a32165c416d02b1de6a9bb90325caf", "message": "Fixed tests", "committedDate": "2020-12-08T02:07:47Z", "type": "commit"}, {"oid": "7dfd7f5c9b3ceddd3a3db61aed750b6f82044927", "url": "https://github.com/confluentinc/ksql/commit/7dfd7f5c9b3ceddd3a3db61aed750b6f82044927", "message": "Checkstyle fix", "committedDate": "2020-12-08T02:07:48Z", "type": "commit"}, {"oid": "ff9c504abdc3f4c58e8066e277b9ffc08ad12b6a", "url": "https://github.com/confluentinc/ksql/commit/ff9c504abdc3f4c58e8066e277b9ffc08ad12b6a", "message": "fix: check IF NOT EXISTS is set in EngineExecutor", "committedDate": "2020-12-08T02:07:48Z", "type": "commit"}, {"oid": "9fe2c4aa6d6f6d44305d43bb1e03c6a757634b49", "url": "https://github.com/confluentinc/ksql/commit/9fe2c4aa6d6f6d44305d43bb1e03c6a757634b49", "message": "fix: display warning message with C*AS + IF NOT EXISTS statements", "committedDate": "2020-12-08T02:07:48Z", "type": "commit"}, {"oid": "8a847007e1406f7ddab8263b7f824013be25f230", "url": "https://github.com/confluentinc/ksql/commit/8a847007e1406f7ddab8263b7f824013be25f230", "message": "chore: fix test issue", "committedDate": "2020-12-08T02:07:48Z", "type": "commit"}, {"oid": "8a847007e1406f7ddab8263b7f824013be25f230", "url": "https://github.com/confluentinc/ksql/commit/8a847007e1406f7ddab8263b7f824013be25f230", "message": "chore: fix test issue", "committedDate": "2020-12-08T02:07:48Z", "type": "forcePushed"}]}