{"pr_number": 5465, "pr_title": "chore: switch synthetic join key to use ROWKEY", "pr_author": "big-andy-coates", "pr_createdAt": "2020-05-22T19:29:47Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5465", "timeline": [{"oid": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5", "url": "https://github.com/confluentinc/ksql/commit/bc83066ca0d27b465ee8d70bb880e23ed8a769f5", "message": "chore: switch synthetic join key to use ROWKEY\n\nThis change switching the naming of the synthetic key column created by some joins to use the name `ROWKEY`, or `ROWKEY_1`, `ROWKEY_2` etc if the is a name clash.\n\nThe change also contains tidy up and refactoring. Specifically, realizing that the validation `Analyzer` does is shared with pull queries, so it doesn't make sense to move this validation.  Instead, given the synthetic key column is a short to medium term problem only, i.e. it will go away with time, switched the design so that all validation returns to `Analyzer`, except is now won't through on an unknown column is it _might_ be a synthetic key column.  Validation of potential synthetic key columns are handled by the logic model. This works because pull queries don't (yet) have this problem.\n\n - There was duplicate logic between `AstSantizer` and `Analayzer` around reporting ambiguous and unknown columns.\n    - Changed so that, for now, `AstSanitzer` reports ambiguous columns and `Analyzer` reports unknown columns. Not perfect, but better than both attempting to do both.\n - It puts back the validation of Selects in `Analyser` and enhanced it and `ColumnReferenceValidator` to know when a synthetic key column is possible and to not throw on one. False positives are possible, but are caught by the logical model.\n - Simplified the logical model to only worry about validating synthetic key columns in projections.\n - Split `RepartitionNode` into classes specific for its two use-cases.", "committedDate": "2020-05-22T19:28:47Z", "type": "commit"}, {"oid": "f71f852804cc9570179e7d3532f5ab7e2af60dba", "url": "https://github.com/confluentinc/ksql/commit/f71f852804cc9570179e7d3532f5ab7e2af60dba", "message": "test: test code", "committedDate": "2020-05-22T19:30:59Z", "type": "commit"}, {"oid": "0a6a8013a5fb0b52eb79a3a699e4833d5e7aadeb", "url": "https://github.com/confluentinc/ksql/commit/0a6a8013a5fb0b52eb79a3a699e4833d5e7aadeb", "message": "test: historical plans", "committedDate": "2020-05-22T19:31:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NzU2NQ==", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429487565", "body": "```suggestion\r\n            // AstSanitizer should catch ambiguous columns\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // AstSanitizer should catches ambiguous columns\n          \n          \n            \n                        // AstSanitizer should catch ambiguous columns", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-c\"><span class=\"pl-c\">//</span> AstSanitizer should <span class=\"x x-first x-last\">catches</span> ambiguous columns</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-c\"><span class=\"pl-c\">//</span> AstSanitizer should <span class=\"x x-first x-last\">catch</span> ambiguous columns</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "agavra", "createdAt": "2020-05-22T23:23:39Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java", "diffHunk": "@@ -85,46 +83,55 @@ public Void visitQualifiedColumnReference(\n         final QualifiedColumnReferenceExp node,\n         final Object context\n     ) {\n-      getSource(node.getLocation(), Optional.of(node.getQualifier()), node.getColumnName())\n-          .ifPresent(referencedSources::add);\n+      validateColumn(node);\n       return null;\n     }\n \n-    private Optional<SourceName> getSource(\n-        final Optional<NodeLocation> location,\n-        final Optional<SourceName> sourceName,\n-        final ColumnName name\n-    ) {\n-      final Set<SourceName> sourcesWithField = sourceSchemas.sourcesWithField(sourceName, name);\n+    private void validateColumn(final ColumnReferenceExp colRef) {\n+      final Set<SourceName> sourcesWithField = sourceSchemas\n+          .sourcesWithField(colRef.maybeQualifier(), colRef.getColumnName());\n+\n       if (sourcesWithField.isEmpty()) {\n-        throw new KsqlException(errorPrefix(location) + \"column '\"\n-            + sourceName.map(n -> n.text() + KsqlConstants.DOT + name.text())\n-            .orElse(name.text())\n-            + \"' cannot be resolved.\");\n+        if (couldBeSyntheticJoinColumn(colRef)) {\n+          // Validating this is handled in the logical model.\n+          return;\n+        }\n+\n+        throw new UnknownColumnException(clauseType, colRef);\n       }\n \n-      if (sourcesWithField.size() > 1) {\n-        final String possibilities = sourcesWithField.stream()\n-            .map(source -> new QualifiedColumnReferenceExp(source, name))\n-            .map(Objects::toString)\n-            .sorted()\n-            .collect(Collectors.joining(\", \"));\n+      final SourceName source = colRef.maybeQualifier()\n+          .orElseGet(() -> {\n+            // AstSanitizer should catches ambiguous columns", "originalCommit": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NzcxMw==", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429487713", "body": "seems like if we're checking equality it should be made either an enum or a constant", "bodyText": "seems like if we're checking equality it should be made either an enum or a constant", "bodyHTML": "<p dir=\"auto\">seems like if we're checking equality it should be made either an enum or a constant</p>", "author": "agavra", "createdAt": "2020-05-22T23:24:49Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/ColumnReferenceValidator.java", "diffHunk": "@@ -85,46 +83,55 @@ public Void visitQualifiedColumnReference(\n         final QualifiedColumnReferenceExp node,\n         final Object context\n     ) {\n-      getSource(node.getLocation(), Optional.of(node.getQualifier()), node.getColumnName())\n-          .ifPresent(referencedSources::add);\n+      validateColumn(node);\n       return null;\n     }\n \n-    private Optional<SourceName> getSource(\n-        final Optional<NodeLocation> location,\n-        final Optional<SourceName> sourceName,\n-        final ColumnName name\n-    ) {\n-      final Set<SourceName> sourcesWithField = sourceSchemas.sourcesWithField(sourceName, name);\n+    private void validateColumn(final ColumnReferenceExp colRef) {\n+      final Set<SourceName> sourcesWithField = sourceSchemas\n+          .sourcesWithField(colRef.maybeQualifier(), colRef.getColumnName());\n+\n       if (sourcesWithField.isEmpty()) {\n-        throw new KsqlException(errorPrefix(location) + \"column '\"\n-            + sourceName.map(n -> n.text() + KsqlConstants.DOT + name.text())\n-            .orElse(name.text())\n-            + \"' cannot be resolved.\");\n+        if (couldBeSyntheticJoinColumn(colRef)) {\n+          // Validating this is handled in the logical model.\n+          return;\n+        }\n+\n+        throw new UnknownColumnException(clauseType, colRef);\n       }\n \n-      if (sourcesWithField.size() > 1) {\n-        final String possibilities = sourcesWithField.stream()\n-            .map(source -> new QualifiedColumnReferenceExp(source, name))\n-            .map(Objects::toString)\n-            .sorted()\n-            .collect(Collectors.joining(\", \"));\n+      final SourceName source = colRef.maybeQualifier()\n+          .orElseGet(() -> {\n+            // AstSanitizer should catches ambiguous columns\n+            return Iterables.getOnlyElement(sourcesWithField);\n+          });\n+\n+      referencedSources.add(source);\n+    }\n \n-        throw new KsqlException(errorPrefix(location) + \"column '\"\n-            + name.text() + \"' is ambiguous. \"\n-            + \"Could be any of: \" + possibilities);\n+    private boolean couldBeSyntheticJoinColumn(final ColumnReferenceExp colRef) {\n+      if (!possibleSyntheticColumns) {\n+        // Some queries never have synthetic columns, e.g. pull or aggregations.\n+        return false;\n       }\n \n-      return Optional.of(Iterables.getOnlyElement(sourcesWithField));\n-    }\n+      if (!sourceSchemas.isJoin()) {\n+        // Synthetic join columns only occur in joins... duh!\n+        return false;\n+      }\n \n-    private String errorPrefix(final Optional<NodeLocation> location) {\n-      final String loc = location\n-          .map(Objects::toString)\n-          .map(text -> text + \": \")\n-          .orElse(\"\");\n+      if (colRef instanceof QualifiedColumnReferenceExp) {\n+        // Synthetic join columns can't be qualified, as they don't belong to any source\n+        return false;\n+      }\n+\n+      if (!clauseType.equals(\"SELECT\")) {", "originalCommit": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5Mzk5NQ==", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429493995", "bodyText": "Normally I'd agree, but it's only short term code and there are tests to ensure it does what we need.", "author": "big-andy-coates", "createdAt": "2020-05-23T00:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NzcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4ODE1OA==", "url": "https://github.com/confluentinc/ksql/pull/5465#discussion_r429488158", "body": "would be nice to javadoc", "bodyText": "would be nice to javadoc", "bodyHTML": "<p dir=\"auto\">would be nice to javadoc</p>", "author": "agavra", "createdAt": "2020-05-22T23:27:38Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+\n+public class PreJoinRepartitionNode extends RepartitionNode {", "originalCommit": "bc83066ca0d27b465ee8d70bb880e23ed8a769f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b1d5bbdbaa4861f579825099865fe2ce5d87887d", "url": "https://github.com/confluentinc/ksql/commit/b1d5bbdbaa4861f579825099865fe2ce5d87887d", "message": "chore: almog's requested changes", "committedDate": "2020-05-23T00:10:51Z", "type": "commit"}]}