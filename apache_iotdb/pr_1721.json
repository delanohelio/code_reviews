{"pr_number": 1721, "pr_title": "[IOTDB-868] fix comma bug for mlog", "pr_author": "mychaow", "pr_createdAt": "2020-09-10T09:01:12Z", "pr_url": "https://github.com/apache/iotdb/pull/1721", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxODkyMw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486718923", "body": "It seems that this method is only used in tests, maybe we could add comments", "bodyText": "It seems that this method is only used in tests, maybe we could add comments", "bodyHTML": "<p dir=\"auto\">It seems that this method is only used in tests, maybe we could add comments</p>", "author": "samperson1997", "createdAt": "2020-09-11T01:22:06Z", "path": "server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java", "diffHunk": "@@ -41,13 +42,26 @@\n   private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n   private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n   private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private long forcePeriodInMs = 0;\n \n-  public LogWriter(String logFilePath) {\n+  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    this.forcePeriodInMs = forcePeriodInMs;\n+\n+    if (channel == null) {\n+      fileOutputStream = new FileOutputStream(logFile, true);\n+      channel = fileOutputStream.getChannel();\n+    }\n   }", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjEwOQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486736109", "bodyText": "Yes, I will add some comments.", "author": "mychaow", "createdAt": "2020-09-11T02:26:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxODkyMw=="}], "type": "inlineReview", "revised_code": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex c7f6f82650..f91caddeb4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -18,50 +18,55 @@\n  */\n package org.apache.iotdb.db.writelog.io;\n \n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n import java.nio.channels.FileChannel;\n import java.util.zip.CRC32;\n-import org.apache.iotdb.db.conf.IoTDBConfig;\n-import org.apache.iotdb.db.conf.IoTDBDescriptor;\n-import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n \n /**\n- * LogWriter writes the binarized logs into a file using FileChannel together with check sums of\n+ * LogWriter writes the binary logs into a file using FileChannel together with check sums of\n  * each log calculated using CRC32.\n  */\n public class LogWriter implements ILogWriter {\n+  private static final Logger logger = LoggerFactory.getLogger(LogWriter.class);\n \n   private File logFile;\n   private FileOutputStream fileOutputStream;\n   private FileChannel channel;\n-  private CRC32 checkSummer = new CRC32();\n-  private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-  private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n-  private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n-  private long forcePeriodInMs = 0;\n+  private final CRC32 checkSummer = new CRC32();\n+  private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n+  private final ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private final long forcePeriodInMs;\n \n+  /**\n+   * @param logFilePath\n+   * @param forcePeriodInMs\n+   * @throws FileNotFoundException\n+   */\n+  @TestOnly\n   public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n     this.logFile = logFile;\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   @Override\n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex f91caddeb4..16ae42720a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -45,25 +45,25 @@ public class LogWriter implements ILogWriter {\n   private final CRC32 checkSummer = new CRC32();\n   private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n   private final ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n-  private final long forcePeriodInMs;\n+  private final boolean forceEachWrite;\n \n   /**\n    * @param logFilePath\n-   * @param forcePeriodInMs\n+   * @param forceEachWrite\n    * @throws FileNotFoundException\n    */\n   @TestOnly\n-  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n+  public LogWriter(String logFilePath, boolean forceEachWrite) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n-    this.forcePeriodInMs = forcePeriodInMs;\n+    this.forceEachWrite = forceEachWrite;\n \n     fileOutputStream = new FileOutputStream(logFile, true);\n     channel = fileOutputStream.getChannel();\n   }\n \n-  public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n+  public LogWriter(File logFile, boolean forceEachWrite) throws FileNotFoundException {\n     this.logFile = logFile;\n-    this.forcePeriodInMs = forcePeriodInMs;\n+    this.forceEachWrite = forceEachWrite;\n \n     fileOutputStream = new FileOutputStream(logFile, true);\n     channel = fileOutputStream.getChannel();\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMTIwOQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486721209", "body": "true if and only if the file or directory is successfully deleted\r\n```suggestion\r\n      if (!oldMLogFile.delete()) {\r\n```", "bodyText": "true if and only if the file or directory is successfully deleted\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (oldMLogFile.delete()) {\n          \n          \n            \n                  if (!oldMLogFile.delete()) {", "bodyHTML": "<p dir=\"auto\">true if and only if the file or directory is successfully deleted</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      <span class=\"pl-k\">if</span> (oldMLogFile<span class=\"pl-k\">.</span>delete()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-k\">if</span> (<span class=\"pl-k x x-first x-last\">!</span>oldMLogFile<span class=\"pl-k\">.</span>delete()) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "samperson1997", "createdAt": "2020-09-11T01:30:44Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -203,6 +203,13 @@ public void checkConfig() throws IOException {\n       }\n       // rename tmpLogFile to mlog\n       FileUtils.moveFile(tmpMLogFile, mlogFile);\n+\n+      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+          + MetadataConstant.METADATA_OLD_LOG);\n+\n+      if (oldMLogFile.delete()) {", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjQwMA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486736400", "bodyText": "yes, thank you for pointing this out.", "author": "mychaow", "createdAt": "2020-09-11T02:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMTIwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex ea83824b55..23b680251b 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -186,66 +186,34 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // need to upgrade from 0.9 to 0.10\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      checkUnClosedTsFileV1();\n-      MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n-      upgradePropertiesFile();\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-          + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n-      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_OLD_LOG);\n+    // upgrade from mlog.txt to mlog.bin\n+    MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n+    // finish upgrade, remove old mlog.txt and mlog.txt.tmp\n+    File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+      + MetadataConstant.METADATA_OLD_LOG);\n+    File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(oldMLogFile.getAbsolutePath()\n+      + \".tmp\");\n \n-      if (oldMLogFile.delete()) {\n-        throw new IOException(\"Deleting old mlog \" + oldMLogFile + \"failed.\");\n-      }\n+    if (!oldMLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt \" + oldMLogFile + \"failed.\");\n     }\n-    checkProperties();\n-  }\n \n-  /**\n-   * upgrade 0.9 properties to 0.10 properties\n-   */\n-  private void upgradePropertiesFile()\n-      throws IOException {\n-    // create an empty tmpPropertiesFile\n-    if (tmpPropertiesFile.createNewFile()) {\n-      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n-    } else {\n-      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n-      System.exit(-1);\n+    if (!tmpMLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldMLogFile + \"failed.\");\n     }\n \n-    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n-      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n-      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n-      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n-      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n-      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n-      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n-      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+    // move mlog.bin.tmp to mlog.bin\n+    File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+      + MetadataConstant.METADATA_LOG);\n+    tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n+      + \".tmp\");\n+    // rename tmpLogFile to mlog\n+    FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n-      // upgrade finished, delete old system.properties file\n-      if (propertiesFile.exists()) {\n-        Files.delete(propertiesFile.toPath());\n-      }\n-    }\n-    // rename system.properties.tmp to system.properties\n-    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n+    checkProperties();\n   }\n \n-\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 23b680251b..05bb3090cb 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -189,27 +189,6 @@ public class IoTDBConfigCheck {\n \n     // upgrade from mlog.txt to mlog.bin\n     MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n-    // finish upgrade, remove old mlog.txt and mlog.txt.tmp\n-    File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-      + MetadataConstant.METADATA_OLD_LOG);\n-    File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(oldMLogFile.getAbsolutePath()\n-      + \".tmp\");\n-\n-    if (!oldMLogFile.delete()) {\n-      throw new IOException(\"Deleting old mlog.txt \" + oldMLogFile + \"failed.\");\n-    }\n-\n-    if (!tmpMLogFile.delete()) {\n-      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldMLogFile + \"failed.\");\n-    }\n-\n-    // move mlog.bin.tmp to mlog.bin\n-    File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-      + MetadataConstant.METADATA_LOG);\n-    tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-      + \".tmp\");\n-    // rename tmpLogFile to mlog\n-    FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n     checkProperties();\n   }\n", "next_change": {"commit": "df0282f1249629b08e83f6e465ac060ff3864a00", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 05bb3090cb..74737a45a4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -186,6 +186,31 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n+    // check whether upgrading from v0.9 to v0.11\n+    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n+          + \" Please upgrade to v0.10 first\");\n+      System.exit(-1);\n+    }\n+    // check whether upgrading from v0.10 to v0.11\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n+      checkUnClosedTsFileV2();\n+      upgradePropertiesFile();\n+      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n+\n+      // upgrade mlog finished, delete old mlog file\n+      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+        + MetadataConstant.METADATA_LOG);\n+      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n+        + \".tmp\");\n+\n+      if (!mlogFile.delete()) {\n+        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n+      }\n+      // rename tmpLogFile to mlog\n+      FileUtils.moveFile(tmpMLogFile, mlogFile);\n+    }\n \n     // upgrade from mlog.txt to mlog.bin\n     MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n", "next_change": {"commit": "7a5ad6d7312a641efad62a814f07be5ce4aade56", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 74737a45a4..3e2d54572c 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -186,34 +185,14 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.11\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n-          + \" Please upgrade to v0.10 first\");\n+    // check whether upgrading from v0.9 to v0.12\n+    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n+      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n+          + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n-    // check whether upgrading from v0.10 to v0.11\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n-      checkUnClosedTsFileV2();\n-      upgradePropertiesFile();\n-      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-        + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-        + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n-    }\n-\n-    // upgrade from mlog.txt to mlog.bin\n-    MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n+    MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n", "next_change": {"commit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 3e2d54572c..0ca9b49734 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -197,37 +197,6 @@ public class IoTDBConfigCheck {\n     checkProperties();\n   }\n \n-  /**\n-   * upgrade 0.10 properties to 0.11 properties\n-   */\n-  private void upgradePropertiesFile()\n-      throws IOException {\n-    // create an empty tmpPropertiesFile\n-    if (tmpPropertiesFile.createNewFile()) {\n-      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n-    } else {\n-      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n-      System.exit(-1);\n-    }\n-\n-    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n-      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n-      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n-      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n-      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n-      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n-      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n-      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n-\n-      // upgrade finished, delete old system.properties file\n-      if (propertiesFile.exists()) {\n-        Files.delete(propertiesFile.toPath());\n-      }\n-    }\n-    // rename system.properties.tmp to system.properties\n-    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n-  }\n-\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 0ca9b49734..be1689ec8e 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -197,6 +197,37 @@ public class IoTDBConfigCheck {\n     checkProperties();\n   }\n \n+  /**\n+   * upgrade 0.10 properties to 0.11 properties\n+   */\n+  private void upgradePropertiesFile()\n+    throws IOException {\n+    // create an empty tmpPropertiesFile\n+    if (tmpPropertiesFile.createNewFile()) {\n+      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n+    } else {\n+      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n+      System.exit(-1);\n+    }\n+\n+    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n+      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n+      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n+      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n+      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n+      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n+      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n+      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+\n+      // upgrade finished, delete old system.properties file\n+      if (propertiesFile.exists()) {\n+        Files.delete(propertiesFile.toPath());\n+      }\n+    }\n+    // rename system.properties.tmp to system.properties\n+    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n+  }\n+\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex be1689ec8e..d00a287f5a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -229,6 +231,8 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n+=======\n+>>>>>>> 614e18466 (fix some snoar warn)\n    * repair 0.10 properties\n    */\n   private void upgradePropertiesFileFromBrokenFile()\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex d00a287f5a..9db3407287 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -231,8 +230,6 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n-=======\n->>>>>>> 614e18466 (fix some snoar warn)\n    * repair 0.10 properties\n    */\n   private void upgradePropertiesFileFromBrokenFile()\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 05bb3090cb..74737a45a4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -193,6 +218,37 @@ public class IoTDBConfigCheck {\n     checkProperties();\n   }\n \n+  /**\n+   * upgrade 0.10 properties to 0.11 properties\n+   */\n+  private void upgradePropertiesFile()\n+      throws IOException {\n+    // create an empty tmpPropertiesFile\n+    if (tmpPropertiesFile.createNewFile()) {\n+      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n+    } else {\n+      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n+      System.exit(-1);\n+    }\n+\n+    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n+      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n+      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n+      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n+      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n+      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n+      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n+      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+\n+      // upgrade finished, delete old system.properties file\n+      if (propertiesFile.exists()) {\n+        Files.delete(propertiesFile.toPath());\n+      }\n+    }\n+    // rename system.properties.tmp to system.properties\n+    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n+  }\n+\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 74737a45a4..0ca9b49734 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -186,69 +185,18 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.11\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n-          + \" Please upgrade to v0.10 first\");\n+    // check whether upgrading from v0.9 to v0.12\n+    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n+      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n+          + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n-    // check whether upgrading from v0.10 to v0.11\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n-      checkUnClosedTsFileV2();\n-      upgradePropertiesFile();\n-      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-        + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-        + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n-    }\n-\n-    // upgrade from mlog.txt to mlog.bin\n-    MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n+    MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n \n-  /**\n-   * upgrade 0.10 properties to 0.11 properties\n-   */\n-  private void upgradePropertiesFile()\n-      throws IOException {\n-    // create an empty tmpPropertiesFile\n-    if (tmpPropertiesFile.createNewFile()) {\n-      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n-    } else {\n-      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n-      System.exit(-1);\n-    }\n-\n-    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n-      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n-      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n-      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n-      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n-      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n-      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n-      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n-\n-      // upgrade finished, delete old system.properties file\n-      if (propertiesFile.exists()) {\n-        Files.delete(propertiesFile.toPath());\n-      }\n-    }\n-    // rename system.properties.tmp to system.properties\n-    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n-  }\n-\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 0ca9b49734..be1689ec8e 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -197,6 +197,37 @@ public class IoTDBConfigCheck {\n     checkProperties();\n   }\n \n+  /**\n+   * upgrade 0.10 properties to 0.11 properties\n+   */\n+  private void upgradePropertiesFile()\n+    throws IOException {\n+    // create an empty tmpPropertiesFile\n+    if (tmpPropertiesFile.createNewFile()) {\n+      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n+    } else {\n+      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n+      System.exit(-1);\n+    }\n+\n+    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n+      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n+      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n+      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n+      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n+      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n+      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n+      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+\n+      // upgrade finished, delete old system.properties file\n+      if (propertiesFile.exists()) {\n+        Files.delete(propertiesFile.toPath());\n+      }\n+    }\n+    // rename system.properties.tmp to system.properties\n+    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n+  }\n+\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex be1689ec8e..d00a287f5a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -229,6 +231,8 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n+=======\n+>>>>>>> 614e18466 (fix some snoar warn)\n    * repair 0.10 properties\n    */\n   private void upgradePropertiesFileFromBrokenFile()\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex d00a287f5a..9db3407287 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -231,8 +230,6 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n-=======\n->>>>>>> 614e18466 (fix some snoar warn)\n    * repair 0.10 properties\n    */\n   private void upgradePropertiesFileFromBrokenFile()\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzE0NQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486723145", "body": "Could we catch `FileNotFoundException` here so that we won't throw it to other classes?", "bodyText": "Could we catch FileNotFoundException here so that we won't throw it to other classes?", "bodyHTML": "<p dir=\"auto\">Could we catch <code>FileNotFoundException</code> here so that we won't throw it to other classes?</p>", "author": "samperson1997", "createdAt": "2020-09-11T01:38:30Z", "path": "server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java", "diffHunk": "@@ -41,13 +42,26 @@\n   private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n   private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n   private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private long forcePeriodInMs = 0;\n \n-  public LogWriter(String logFilePath) {\n+  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    this.forcePeriodInMs = forcePeriodInMs;\n+\n+    if (channel == null) {\n+      fileOutputStream = new FileOutputStream(logFile, true);\n+      channel = fileOutputStream.getChannel();\n+    }\n   }\n \n-  public LogWriter(File logFile) {\n+  public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n     this.logFile = logFile;\n+    this.forcePeriodInMs = forcePeriodInMs;\n+\n+    if (channel == null) {\n+      fileOutputStream = new FileOutputStream(logFile, true);", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjkzOQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486736939", "bodyText": "I think we should throw the exception for it's not normal, because fileoutputstream could create it if not exist.", "author": "mychaow", "createdAt": "2020-09-11T02:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex c7f6f82650..f91caddeb4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -18,50 +18,55 @@\n  */\n package org.apache.iotdb.db.writelog.io;\n \n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n import java.nio.channels.FileChannel;\n import java.util.zip.CRC32;\n-import org.apache.iotdb.db.conf.IoTDBConfig;\n-import org.apache.iotdb.db.conf.IoTDBDescriptor;\n-import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n \n /**\n- * LogWriter writes the binarized logs into a file using FileChannel together with check sums of\n+ * LogWriter writes the binary logs into a file using FileChannel together with check sums of\n  * each log calculated using CRC32.\n  */\n public class LogWriter implements ILogWriter {\n+  private static final Logger logger = LoggerFactory.getLogger(LogWriter.class);\n \n   private File logFile;\n   private FileOutputStream fileOutputStream;\n   private FileChannel channel;\n-  private CRC32 checkSummer = new CRC32();\n-  private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-  private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n-  private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n-  private long forcePeriodInMs = 0;\n+  private final CRC32 checkSummer = new CRC32();\n+  private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n+  private final ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private final long forcePeriodInMs;\n \n+  /**\n+   * @param logFilePath\n+   * @param forcePeriodInMs\n+   * @throws FileNotFoundException\n+   */\n+  @TestOnly\n   public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n     this.logFile = logFile;\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   @Override\n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex f91caddeb4..16ae42720a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -45,25 +45,25 @@ public class LogWriter implements ILogWriter {\n   private final CRC32 checkSummer = new CRC32();\n   private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n   private final ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n-  private final long forcePeriodInMs;\n+  private final boolean forceEachWrite;\n \n   /**\n    * @param logFilePath\n-   * @param forcePeriodInMs\n+   * @param forceEachWrite\n    * @throws FileNotFoundException\n    */\n   @TestOnly\n-  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n+  public LogWriter(String logFilePath, boolean forceEachWrite) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n-    this.forcePeriodInMs = forcePeriodInMs;\n+    this.forceEachWrite = forceEachWrite;\n \n     fileOutputStream = new FileOutputStream(logFile, true);\n     channel = fileOutputStream.getChannel();\n   }\n \n-  public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n+  public LogWriter(File logFile, boolean forceEachWrite) throws FileNotFoundException {\n     this.logFile = logFile;\n-    this.forcePeriodInMs = forcePeriodInMs;\n+    this.forceEachWrite = forceEachWrite;\n \n     fileOutputStream = new FileOutputStream(logFile, true);\n     channel = fileOutputStream.getChannel();\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzcyOQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486723729", "body": "Replace `if` statement with `switch` statement", "bodyText": "Replace if statement with switch statement", "bodyHTML": "<p dir=\"auto\">Replace <code>if</code> statement with <code>switch</code> statement</p>", "author": "samperson1997", "createdAt": "2020-09-11T01:40:36Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java", "diffHunk": "@@ -156,4 +178,20 @@ private void checkShowTimeseries(Statement statement) throws SQLException {\n       Assert.assertEquals(8, cnt);\n     }\n   }\n+\n+  private PhysicalPlan convertFromString(String str) {\n+    String[] words = str.split(\",\");\n+    if (words[0].equals(\"2\")) {", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNzAxNg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486737016", "bodyText": "ok, thanks!", "author": "mychaow", "createdAt": "2020-09-11T02:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzcyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "changed_code": [{"header": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\nindex 0bde3e92f8..d024346626 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n", "chunk": "@@ -181,15 +178,16 @@ public class IoTDBCreateSnapshotIT {\n \n   private PhysicalPlan convertFromString(String str) {\n     String[] words = str.split(\",\");\n-    if (words[0].equals(\"2\")) {\n-      return new MeasurementNodePlan(words[1],words[2].equals(\"\") ? null :  words[2], Long.parseLong(words[words.length - 2]),\n+    switch (words[0]) {\n+      case \"2\":\n+      return new MeasurementMNodePlan(words[1],words[2].equals(\"\") ? null :  words[2], Long.parseLong(words[words.length - 2]),\n         Integer.parseInt(words[words.length - 1]),\n         new MeasurementSchema(words[1], TSDataType.values()[Integer.parseInt(words[3])],\n           TSEncoding.values()[Integer.parseInt(words[4])], CompressionType.values()[Integer.parseInt(words[5])]\n           ));\n-    } else if (words[0].equals(\"1\")) {\n+      case \"1\":\n       return new StorageGroupMNodePlan(words[1], Long.parseLong(words[2]), Integer.parseInt(words[3]));\n-    } else if (words[0].equals(\"0\")) {\n+      case \"0\":\n       return new MNodePlan(words[1], Integer.parseInt(words[2]));\n     }\n     return null;\n", "next_change": {"commit": "7a5ad6d7312a641efad62a814f07be5ce4aade56", "changed_code": [{"header": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\nindex d024346626..73ff187ad9 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n", "chunk": "@@ -175,21 +187,4 @@ public class IoTDBCreateSnapshotIT {\n       Assert.assertEquals(8, cnt);\n     }\n   }\n-\n-  private PhysicalPlan convertFromString(String str) {\n-    String[] words = str.split(\",\");\n-    switch (words[0]) {\n-      case \"2\":\n-      return new MeasurementMNodePlan(words[1],words[2].equals(\"\") ? null :  words[2], Long.parseLong(words[words.length - 2]),\n-        Integer.parseInt(words[words.length - 1]),\n-        new MeasurementSchema(words[1], TSDataType.values()[Integer.parseInt(words[3])],\n-          TSEncoding.values()[Integer.parseInt(words[4])], CompressionType.values()[Integer.parseInt(words[5])]\n-          ));\n-      case \"1\":\n-      return new StorageGroupMNodePlan(words[1], Long.parseLong(words[2]), Integer.parseInt(words[3]));\n-      case \"0\":\n-      return new MNodePlan(words[1], Integer.parseInt(words[2]));\n-    }\n-    return null;\n-  }\n }\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\nindex 73ff187ad9..9c07ad9ed1 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n", "chunk": "@@ -187,4 +175,20 @@ public class IoTDBCreateSnapshotIT {\n       Assert.assertEquals(8, cnt);\n     }\n   }\n+\n+  private PhysicalPlan convertFromString(String str) {\n+    String[] words = str.split(\",\");\n+    if (words[0].equals(\"2\")) {\n+      return new MeasurementNodePlan(words[1],words[2].equals(\"\") ? null :  words[2], Long.parseLong(words[words.length - 2]),\n+        Integer.parseInt(words[words.length - 1]),\n+        new MeasurementSchema(words[1], TSDataType.values()[Integer.parseInt(words[3])],\n+          TSEncoding.values()[Integer.parseInt(words[4])], CompressionType.values()[Integer.parseInt(words[5])]\n+          ));\n+    } else if (words[0].equals(\"1\")) {\n+      return new StorageGroupMNodePlan(words[1], Long.parseLong(words[2]), Integer.parseInt(words[3]));\n+    } else if (words[0].equals(\"0\")) {\n+      return new MNodePlan(words[1], Integer.parseInt(words[2]));\n+    }\n+    return null;\n+  }\n }\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\nindex 9c07ad9ed1..a268ff0988 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n", "chunk": "@@ -178,15 +189,16 @@ public class IoTDBCreateSnapshotIT {\n \n   private PhysicalPlan convertFromString(String str) {\n     String[] words = str.split(\",\");\n-    if (words[0].equals(\"2\")) {\n-      return new MeasurementNodePlan(words[1],words[2].equals(\"\") ? null :  words[2], Long.parseLong(words[words.length - 2]),\n+    switch (words[0]) {\n+      case \"2\":\n+      return new MeasurementMNodePlan(words[1],words[2].equals(\"\") ? null :  words[2], Long.parseLong(words[words.length - 2]),\n         Integer.parseInt(words[words.length - 1]),\n         new MeasurementSchema(words[1], TSDataType.values()[Integer.parseInt(words[3])],\n           TSEncoding.values()[Integer.parseInt(words[4])], CompressionType.values()[Integer.parseInt(words[5])]\n           ));\n-    } else if (words[0].equals(\"1\")) {\n+      case \"1\":\n       return new StorageGroupMNodePlan(words[1], Long.parseLong(words[2]), Integer.parseInt(words[3]));\n-    } else if (words[0].equals(\"0\")) {\n+      case \"0\":\n       return new MNodePlan(words[1], Integer.parseInt(words[2]));\n     }\n     return null;\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\nindex a268ff0988..73ff187ad9 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n", "chunk": "@@ -186,21 +187,4 @@ public class IoTDBCreateSnapshotIT {\n       Assert.assertEquals(8, cnt);\n     }\n   }\n-\n-  private PhysicalPlan convertFromString(String str) {\n-    String[] words = str.split(\",\");\n-    switch (words[0]) {\n-      case \"2\":\n-      return new MeasurementMNodePlan(words[1],words[2].equals(\"\") ? null :  words[2], Long.parseLong(words[words.length - 2]),\n-        Integer.parseInt(words[words.length - 1]),\n-        new MeasurementSchema(words[1], TSDataType.values()[Integer.parseInt(words[3])],\n-          TSEncoding.values()[Integer.parseInt(words[4])], CompressionType.values()[Integer.parseInt(words[5])]\n-          ));\n-      case \"1\":\n-      return new StorageGroupMNodePlan(words[1], Long.parseLong(words[2]), Integer.parseInt(words[3]));\n-      case \"0\":\n-      return new MNodePlan(words[1], Integer.parseInt(words[2]));\n-    }\n-    return null;\n-  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyNTI0NA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486725244", "body": "with `finally`, we could close `mLogReader` only once", "bodyText": "with finally, we could close mLogReader only once", "bodyHTML": "<p dir=\"auto\">with <code>finally</code>, we could close <code>mLogReader</code> only once</p>", "author": "samperson1997", "createdAt": "2020-09-11T01:45:59Z", "path": "server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java", "diffHunk": "@@ -272,18 +274,25 @@ public SyncStatus checkDataMD5(String md5OfSender) throws TException {\n   private void loadMetadata() {\n     logger.info(\"Start to load metadata in sync process.\");\n     if (currentFile.get().exists()) {\n-      try (BufferedReader br = new BufferedReader(\n-          new java.io.FileReader(currentFile.get()))) {\n-        String metadataOperation;\n-        while ((metadataOperation = br.readLine()) != null) {\n+      MLogReader mLogReader = null;\n+      try {\n+        mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);\n+        while (mLogReader.hasNext()) {\n+          PhysicalPlan plan = mLogReader.next();\n           try {\n-            IoTDB.metaManager.operation(metadataOperation);\n-          } catch (IOException | MetadataException e) {\n-            logger.error(\"Can not operate metadata operation {} \", metadataOperation, e);\n+            if (plan == null) {\n+              continue;\n+            }\n+            IoTDB.metaManager.operation(plan);\n+          } catch (Exception e) {\n+            logger.error(\"Can not operate metadata operation {} for err:{}\", plan.getOperatorType(), e);\n           }\n         }\n+        mLogReader.close();\n       } catch (IOException e) {\n         logger.error(\"Cannot read the file {}.\", currentFile.get().getAbsoluteFile(), e);\n+      } finally {\n+        mLogReader.close();", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNzA3MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486737070", "bodyText": "yes!", "author": "mychaow", "createdAt": "2020-09-11T02:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyNTI0NA=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java b/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\nindex 755a6edbb1..b44374349a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\n+++ b/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\n", "chunk": "@@ -288,11 +288,12 @@ public class SyncServiceImpl implements SyncService.Iface {\n             logger.error(\"Can not operate metadata operation {} for err:{}\", plan.getOperatorType(), e);\n           }\n         }\n-        mLogReader.close();\n       } catch (IOException e) {\n         logger.error(\"Cannot read the file {}.\", currentFile.get().getAbsoluteFile(), e);\n       } finally {\n-        mLogReader.close();\n+        if (mLogReader != null) {\n+          mLogReader.close();\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "18bb0557753e46238c0a17cd131af13a072eb09c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java b/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\nindex b44374349a..4dfd40f8b5 100644\n--- a/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\n+++ b/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\n", "chunk": "@@ -290,10 +284,6 @@ public class SyncServiceImpl implements SyncService.Iface {\n         }\n       } catch (IOException e) {\n         logger.error(\"Cannot read the file {}.\", currentFile.get().getAbsoluteFile(), e);\n-      } finally {\n-        if (mLogReader != null) {\n-          mLogReader.close();\n-        }\n       }\n     }\n   }\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java b/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\nindex 4dfd40f8b5..0aa74b689f 100644\n--- a/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\n+++ b/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\n", "chunk": "@@ -282,8 +285,11 @@ public class SyncServiceImpl implements SyncService.Iface {\n             logger.error(\"Can not operate metadata operation {} for err:{}\", plan.getOperatorType(), e);\n           }\n         }\n+        mLogReader.close();\n       } catch (IOException e) {\n         logger.error(\"Cannot read the file {}.\", currentFile.get().getAbsoluteFile(), e);\n+      } finally {\n+        mLogReader.close();\n       }\n     }\n   }\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java b/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\nindex 0aa74b689f..5500d32775 100644\n--- a/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\n+++ b/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\n", "chunk": "@@ -285,11 +285,12 @@ public class SyncServiceImpl implements SyncService.Iface {\n             logger.error(\"Can not operate metadata operation {} for err:{}\", plan.getOperatorType(), e);\n           }\n         }\n-        mLogReader.close();\n       } catch (IOException e) {\n         logger.error(\"Cannot read the file {}.\", currentFile.get().getAbsoluteFile(), e);\n       } finally {\n-        mLogReader.close();\n+        if (mLogReader != null) {\n+          mLogReader.close();\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java b/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\nindex 5500d32775..7d8df48f52 100644\n--- a/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\n+++ b/server/src/main/java/org/apache/iotdb/db/sync/receiver/transfer/SyncServiceImpl.java\n", "chunk": "@@ -287,10 +284,6 @@ public class SyncServiceImpl implements SyncService.Iface {\n         }\n       } catch (IOException e) {\n         logger.error(\"Cannot read the file {}.\", currentFile.get().getAbsoluteFile(), e);\n-      } finally {\n-        if (mLogReader != null) {\n-          mLogReader.close();\n-        }\n       }\n     }\n   }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyNjIxMw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486726213", "body": "I understand it's convenient to make them extends `PhysicalPlan`, but I still think it is a little bit strange to make `StorageGroupMNode`, `MNode` and `MeasurementNode` as a **plan**... How did you consider about it?", "bodyText": "I understand it's convenient to make them extends PhysicalPlan, but I still think it is a little bit strange to make StorageGroupMNode, MNode and MeasurementNode as a plan... How did you consider about it?", "bodyHTML": "<p dir=\"auto\">I understand it's convenient to make them extends <code>PhysicalPlan</code>, but I still think it is a little bit strange to make <code>StorageGroupMNode</code>, <code>MNode</code> and <code>MeasurementNode</code> as a <strong>plan</strong>... How did you consider about it?</p>", "author": "samperson1997", "createdAt": "2020-09-11T01:49:39Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.qp.physical.sys;\n+\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.logical.Operator;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class StorageGroupMNodePlan extends PhysicalPlan {", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNzM5MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486737390", "bodyText": "haha, I will change it. It's a mistake.", "author": "mychaow", "createdAt": "2020-09-11T02:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyNjIxMw=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\nindex 902a8a99f7..95b7229b31 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n", "chunk": "@@ -30,10 +30,8 @@ import java.util.ArrayList;\n import java.util.List;\n import java.util.Objects;\n \n-public class StorageGroupMNodePlan extends PhysicalPlan {\n-  private String name;\n+public class StorageGroupMNodePlan extends MNodePlan {\n   private long dataTTL;\n-  private int childSize;\n \n   public StorageGroupMNodePlan() {\n     super(false, Operator.OperatorType.STORAGE_GROUP_MNODE);\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\nindex 95b7229b31..902a8a99f7 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n", "chunk": "@@ -30,8 +30,10 @@ import java.util.ArrayList;\n import java.util.List;\n import java.util.Objects;\n \n-public class StorageGroupMNodePlan extends MNodePlan {\n+public class StorageGroupMNodePlan extends PhysicalPlan {\n+  private String name;\n   private long dataTTL;\n+  private int childSize;\n \n   public StorageGroupMNodePlan() {\n     super(false, Operator.OperatorType.STORAGE_GROUP_MNODE);\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\nindex 902a8a99f7..95b7229b31 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n", "chunk": "@@ -30,10 +30,8 @@ import java.util.ArrayList;\n import java.util.List;\n import java.util.Objects;\n \n-public class StorageGroupMNodePlan extends PhysicalPlan {\n-  private String name;\n+public class StorageGroupMNodePlan extends MNodePlan {\n   private long dataTTL;\n-  private int childSize;\n \n   public StorageGroupMNodePlan() {\n     super(false, Operator.OperatorType.STORAGE_GROUP_MNODE);\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyODIzNA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486728234", "body": "```suggestion\r\n  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void seriallizeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n          \n          \n            \n              public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">  <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> <span class=\"x x-first x-last\">seriallizeStorageGroupMNode</span>(<span class=\"pl-smi\">StorageGroupMNode</span> node) throws <span class=\"pl-smi\">IOException</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> <span class=\"x x-first x-last\">serializeStorageGroupMNode</span>(<span class=\"pl-smi\">StorageGroupMNode</span> node) throws <span class=\"pl-smi\">IOException</span> {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "samperson1997", "createdAt": "2020-09-11T01:56:48Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.info(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementNodePlan plan = new MeasurementNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void seriallizeStorageGroupMNode(StorageGroupMNode node) throws IOException {", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..5b258f16ed 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -200,7 +200,7 @@ public class MLogWriter {\n     }\n   }\n \n-  public void seriallizeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n     try {\n       int childSize = 0;\n       if (node.getChildren() != null) {\n", "next_change": {"commit": "18bb0557753e46238c0a17cd131af13a072eb09c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -196,7 +207,7 @@ public class MLogWriter implements AutoCloseable {\n       putLog(plan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+        LOG_TOO_LARGE_INFO, e);\n     }\n   }\n \n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -202,16 +191,16 @@ public class MLogWriter implements AutoCloseable {\n       if (node.getChildren() != null) {\n         childSize = node.getChildren().size();\n       }\n-      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+      MeasurementNodePlan plan = new MeasurementNodePlan(node.getName(), node.getAlias(),\n         node.getOffset(), childSize, node.getSchema());\n       putLog(plan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        LOG_TOO_LARGE_INFO, e);\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n     }\n   }\n \n-  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+  public void seriallizeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n     try {\n       int childSize = 0;\n       if (node.getChildren() != null) {\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -200,7 +200,7 @@ public class MLogWriter {\n     }\n   }\n \n-  public void seriallizeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n     try {\n       int childSize = 0;\n       if (node.getChildren() != null) {\n", "next_change": {"commit": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -196,7 +207,7 @@ public class MLogWriter implements AutoCloseable {\n       putLog(plan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+        LOG_TOO_LARGE_INFO, e);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTc5Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486729796", "body": "Line 190 to line 205 is the part of upgrading v0.9 mlog to v0.10. Since the `MetadataConstant.METADATA_LOG` has changed, I don't think that upgrading will work correctly. Should we remove that?", "bodyText": "Line 190 to line 205 is the part of upgrading v0.9 mlog to v0.10. Since the MetadataConstant.METADATA_LOG has changed, I don't think that upgrading will work correctly. Should we remove that?", "bodyHTML": "<p dir=\"auto\">Line 190 to line 205 is the part of upgrading v0.9 mlog to v0.10. Since the <code>MetadataConstant.METADATA_LOG</code> has changed, I don't think that upgrading will work correctly. Should we remove that?</p>", "author": "HTHou", "createdAt": "2020-09-11T02:02:29Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -203,6 +203,13 @@ public void checkConfig() throws IOException {\n       }\n       // rename tmpLogFile to mlog\n       FileUtils.moveFile(tmpMLogFile, mlogFile);\n+\n+      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+          + MetadataConstant.METADATA_OLD_LOG);", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0MjY0OA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486742648", "bodyText": "yes, it's no meaning.", "author": "mychaow", "createdAt": "2020-09-11T02:50:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTc5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex ea83824b55..23b680251b 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -186,66 +186,34 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // need to upgrade from 0.9 to 0.10\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      checkUnClosedTsFileV1();\n-      MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n-      upgradePropertiesFile();\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-          + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n-      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_OLD_LOG);\n+    // upgrade from mlog.txt to mlog.bin\n+    MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n+    // finish upgrade, remove old mlog.txt and mlog.txt.tmp\n+    File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+      + MetadataConstant.METADATA_OLD_LOG);\n+    File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(oldMLogFile.getAbsolutePath()\n+      + \".tmp\");\n \n-      if (oldMLogFile.delete()) {\n-        throw new IOException(\"Deleting old mlog \" + oldMLogFile + \"failed.\");\n-      }\n+    if (!oldMLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt \" + oldMLogFile + \"failed.\");\n     }\n-    checkProperties();\n-  }\n \n-  /**\n-   * upgrade 0.9 properties to 0.10 properties\n-   */\n-  private void upgradePropertiesFile()\n-      throws IOException {\n-    // create an empty tmpPropertiesFile\n-    if (tmpPropertiesFile.createNewFile()) {\n-      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n-    } else {\n-      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n-      System.exit(-1);\n+    if (!tmpMLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldMLogFile + \"failed.\");\n     }\n \n-    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n-      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n-      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n-      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n-      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n-      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n-      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n-      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+    // move mlog.bin.tmp to mlog.bin\n+    File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+      + MetadataConstant.METADATA_LOG);\n+    tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n+      + \".tmp\");\n+    // rename tmpLogFile to mlog\n+    FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n-      // upgrade finished, delete old system.properties file\n-      if (propertiesFile.exists()) {\n-        Files.delete(propertiesFile.toPath());\n-      }\n-    }\n-    // rename system.properties.tmp to system.properties\n-    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n+    checkProperties();\n   }\n \n-\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 23b680251b..05bb3090cb 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -189,27 +189,6 @@ public class IoTDBConfigCheck {\n \n     // upgrade from mlog.txt to mlog.bin\n     MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n-    // finish upgrade, remove old mlog.txt and mlog.txt.tmp\n-    File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-      + MetadataConstant.METADATA_OLD_LOG);\n-    File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(oldMLogFile.getAbsolutePath()\n-      + \".tmp\");\n-\n-    if (!oldMLogFile.delete()) {\n-      throw new IOException(\"Deleting old mlog.txt \" + oldMLogFile + \"failed.\");\n-    }\n-\n-    if (!tmpMLogFile.delete()) {\n-      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldMLogFile + \"failed.\");\n-    }\n-\n-    // move mlog.bin.tmp to mlog.bin\n-    File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-      + MetadataConstant.METADATA_LOG);\n-    tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-      + \".tmp\");\n-    // rename tmpLogFile to mlog\n-    FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n     checkProperties();\n   }\n", "next_change": {"commit": "df0282f1249629b08e83f6e465ac060ff3864a00", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 05bb3090cb..74737a45a4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -186,6 +186,31 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n+    // check whether upgrading from v0.9 to v0.11\n+    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n+          + \" Please upgrade to v0.10 first\");\n+      System.exit(-1);\n+    }\n+    // check whether upgrading from v0.10 to v0.11\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n+      checkUnClosedTsFileV2();\n+      upgradePropertiesFile();\n+      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n+\n+      // upgrade mlog finished, delete old mlog file\n+      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+        + MetadataConstant.METADATA_LOG);\n+      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n+        + \".tmp\");\n+\n+      if (!mlogFile.delete()) {\n+        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n+      }\n+      // rename tmpLogFile to mlog\n+      FileUtils.moveFile(tmpMLogFile, mlogFile);\n+    }\n \n     // upgrade from mlog.txt to mlog.bin\n     MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n", "next_change": {"commit": "7a5ad6d7312a641efad62a814f07be5ce4aade56", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 74737a45a4..3e2d54572c 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -186,34 +185,14 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.11\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n-          + \" Please upgrade to v0.10 first\");\n+    // check whether upgrading from v0.9 to v0.12\n+    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n+      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n+          + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n-    // check whether upgrading from v0.10 to v0.11\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n-      checkUnClosedTsFileV2();\n-      upgradePropertiesFile();\n-      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-        + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-        + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n-    }\n-\n-    // upgrade from mlog.txt to mlog.bin\n-    MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n+    MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n", "next_change": {"commit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 3e2d54572c..0ca9b49734 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -197,37 +197,6 @@ public class IoTDBConfigCheck {\n     checkProperties();\n   }\n \n-  /**\n-   * upgrade 0.10 properties to 0.11 properties\n-   */\n-  private void upgradePropertiesFile()\n-      throws IOException {\n-    // create an empty tmpPropertiesFile\n-    if (tmpPropertiesFile.createNewFile()) {\n-      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n-    } else {\n-      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n-      System.exit(-1);\n-    }\n-\n-    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n-      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n-      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n-      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n-      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n-      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n-      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n-      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n-\n-      // upgrade finished, delete old system.properties file\n-      if (propertiesFile.exists()) {\n-        Files.delete(propertiesFile.toPath());\n-      }\n-    }\n-    // rename system.properties.tmp to system.properties\n-    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n-  }\n-\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 0ca9b49734..be1689ec8e 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -197,6 +197,37 @@ public class IoTDBConfigCheck {\n     checkProperties();\n   }\n \n+  /**\n+   * upgrade 0.10 properties to 0.11 properties\n+   */\n+  private void upgradePropertiesFile()\n+    throws IOException {\n+    // create an empty tmpPropertiesFile\n+    if (tmpPropertiesFile.createNewFile()) {\n+      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n+    } else {\n+      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n+      System.exit(-1);\n+    }\n+\n+    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n+      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n+      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n+      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n+      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n+      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n+      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n+      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+\n+      // upgrade finished, delete old system.properties file\n+      if (propertiesFile.exists()) {\n+        Files.delete(propertiesFile.toPath());\n+      }\n+    }\n+    // rename system.properties.tmp to system.properties\n+    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n+  }\n+\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex be1689ec8e..d00a287f5a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -229,6 +231,8 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n+=======\n+>>>>>>> 614e18466 (fix some snoar warn)\n    * repair 0.10 properties\n    */\n   private void upgradePropertiesFileFromBrokenFile()\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex d00a287f5a..9db3407287 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -231,8 +230,6 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n-=======\n->>>>>>> 614e18466 (fix some snoar warn)\n    * repair 0.10 properties\n    */\n   private void upgradePropertiesFileFromBrokenFile()\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 05bb3090cb..74737a45a4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -193,6 +218,37 @@ public class IoTDBConfigCheck {\n     checkProperties();\n   }\n \n+  /**\n+   * upgrade 0.10 properties to 0.11 properties\n+   */\n+  private void upgradePropertiesFile()\n+      throws IOException {\n+    // create an empty tmpPropertiesFile\n+    if (tmpPropertiesFile.createNewFile()) {\n+      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n+    } else {\n+      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n+      System.exit(-1);\n+    }\n+\n+    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n+      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n+      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n+      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n+      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n+      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n+      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n+      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+\n+      // upgrade finished, delete old system.properties file\n+      if (propertiesFile.exists()) {\n+        Files.delete(propertiesFile.toPath());\n+      }\n+    }\n+    // rename system.properties.tmp to system.properties\n+    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n+  }\n+\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 74737a45a4..0ca9b49734 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -186,69 +185,18 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.11\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n-          + \" Please upgrade to v0.10 first\");\n+    // check whether upgrading from v0.9 to v0.12\n+    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n+      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n+          + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n-    // check whether upgrading from v0.10 to v0.11\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n-      checkUnClosedTsFileV2();\n-      upgradePropertiesFile();\n-      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-        + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-        + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n-    }\n-\n-    // upgrade from mlog.txt to mlog.bin\n-    MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n+    MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n \n-  /**\n-   * upgrade 0.10 properties to 0.11 properties\n-   */\n-  private void upgradePropertiesFile()\n-      throws IOException {\n-    // create an empty tmpPropertiesFile\n-    if (tmpPropertiesFile.createNewFile()) {\n-      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n-    } else {\n-      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n-      System.exit(-1);\n-    }\n-\n-    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n-      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n-      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n-      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n-      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n-      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n-      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n-      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n-\n-      // upgrade finished, delete old system.properties file\n-      if (propertiesFile.exists()) {\n-        Files.delete(propertiesFile.toPath());\n-      }\n-    }\n-    // rename system.properties.tmp to system.properties\n-    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n-  }\n-\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 0ca9b49734..be1689ec8e 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -197,6 +197,37 @@ public class IoTDBConfigCheck {\n     checkProperties();\n   }\n \n+  /**\n+   * upgrade 0.10 properties to 0.11 properties\n+   */\n+  private void upgradePropertiesFile()\n+    throws IOException {\n+    // create an empty tmpPropertiesFile\n+    if (tmpPropertiesFile.createNewFile()) {\n+      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n+    } else {\n+      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n+      System.exit(-1);\n+    }\n+\n+    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n+      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n+      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n+      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n+      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n+      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n+      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n+      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+\n+      // upgrade finished, delete old system.properties file\n+      if (propertiesFile.exists()) {\n+        Files.delete(propertiesFile.toPath());\n+      }\n+    }\n+    // rename system.properties.tmp to system.properties\n+    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n+  }\n+\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex be1689ec8e..d00a287f5a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -229,6 +231,8 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n+=======\n+>>>>>>> 614e18466 (fix some snoar warn)\n    * repair 0.10 properties\n    */\n   private void upgradePropertiesFileFromBrokenFile()\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex d00a287f5a..9db3407287 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -231,8 +230,6 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n-=======\n->>>>>>> 614e18466 (fix some snoar warn)\n    * repair 0.10 properties\n    */\n   private void upgradePropertiesFileFromBrokenFile()\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjU4Nw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486736587", "body": "Use try with resource to avoid new sonar code smell..", "bodyText": "Use try with resource to avoid new sonar code smell..", "bodyHTML": "<p dir=\"auto\">Use try with resource to avoid new sonar code smell..</p>", "author": "HTHou", "createdAt": "2020-09-11T02:28:14Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -1002,55 +1008,74 @@ private void findNodes(MNode node, PartialPath path, List<PartialPath> res, int\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (BufferedWriter bw = new BufferedWriter(\n-        new FileWriter(SystemFileFactory.INSTANCE.getFile(snapshotPath)))) {\n-      root.serializeTo(bw);\n+    MLogWriter mLogWriter = null;\n+    try {\n+      mLogWriter = new MLogWriter(snapshotPath);\n+      root.serializeTo(mLogWriter);\n+    } finally {\n+      if (mLogWriter != null) {\n+        mLogWriter.close();\n+      }\n     }\n   }\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-    try (BufferedReader br = new BufferedReader(new FileReader(mtreeSnapshot))) {\n-      String s;\n+    MLogReader mlogReader = null;\n+    try {", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0MjY4MQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486742681", "bodyText": "Got it!", "author": "mychaow", "createdAt": "2020-09-11T02:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjU4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex bbbe2eec01..87d0dcdde3 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1008,22 +1004,15 @@ public class MTree implements Serializable {\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    MLogWriter mLogWriter = null;\n-    try {\n-      mLogWriter = new MLogWriter(snapshotPath);\n+    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n       root.serializeTo(mLogWriter);\n-    } finally {\n-      if (mLogWriter != null) {\n-        mLogWriter.close();\n-      }\n     }\n   }\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-    MLogReader mlogReader = null;\n-    try {\n-      mlogReader = new MLogReader(mtreeSnapshot);\n+\n+    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n       Deque<MNode> nodeStack = new ArrayDeque<>();\n       MNode node = null;\n \n", "next_change": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 87d0dcdde3..314af82411 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1009,55 +1218,9 @@ public class MTree implements Serializable {\n     }\n   }\n \n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-\n-    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n-      Deque<MNode> nodeStack = new ArrayDeque<>();\n-      MNode node = null;\n-\n-      while (mlogReader.hasNext()) {\n-        PhysicalPlan plan = null;\n-        try {\n-          plan = mlogReader.next();\n-          if (plan == null) {\n-            continue;\n-          }\n-          int childrenSize = 0;\n-          if (plan instanceof StorageGroupMNodePlan) {\n-            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n-            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MeasurementMNodePlan) {\n-            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n-            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MNodePlan) {\n-            node = new MNode(null, ((MNodePlan) plan).getName());\n-            childrenSize = ((MNodePlan) plan).getChildSize();\n-          }\n-\n-          if (childrenSize == 0) {\n-            nodeStack.push(node);\n-          } else {\n-            Map<String, MNode> childrenMap = new LinkedHashMap<>();\n-            for (int i = 0; i < childrenSize; i++) {\n-              MNode child = nodeStack.removeFirst();\n-              child.setParent(node);\n-              childrenMap.put(child.getName(), child);\n-              if (child instanceof MeasurementMNode) {\n-                String alias = ((MeasurementMNode) child).getAlias();\n-                if (alias != null) {\n-                  node.addAlias(alias, child);\n-                }\n-              }\n-            }\n-            node.setChildren(childrenMap);\n-            nodeStack.push(node);\n-          }\n-        } catch (Exception e) {\n-          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n-        }\n-      }\n-      return new MTree(node);\n+    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n+      return deserializeFromReader(mLogReader);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 314af82411..1b0807e9d5 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1213,18 +1218,74 @@ public class MTree implements Serializable {\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n+    MLogWriter mLogWriter = null;\n+    try {\n+      mLogWriter = new MLogWriter(snapshotPath);\n       root.serializeTo(mLogWriter);\n+    } finally {\n+      if (mLogWriter != null) {\n+        mLogWriter.close();\n+      }\n     }\n   }\n \n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n-      return deserializeFromReader(mLogReader);\n+    MLogReader mlogReader = null;\n+    try {\n+      mlogReader = new MLogReader(mtreeSnapshot);\n+      Deque<MNode> nodeStack = new ArrayDeque<>();\n+      MNode node = null;\n+\n+      while (mlogReader.hasNext()) {\n+        PhysicalPlan plan = null;\n+        try {\n+          plan = mlogReader.next();\n+          if (plan == null) {\n+            continue;\n+          }\n+          int childrenSize = 0;\n+          if (plan instanceof StorageGroupMNodePlan) {\n+            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MeasurementNodePlan) {\n+            node = MeasurementMNode.deserializeFrom((MeasurementNodePlan) plan);\n+            childrenSize = ((MeasurementNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MNodePlan) {\n+            node = new MNode(null, ((MNodePlan) plan).getName());\n+            childrenSize = ((MNodePlan) plan).getChildSize();\n+          }\n+\n+          if (childrenSize == 0) {\n+            nodeStack.push(node);\n+          } else {\n+            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+            for (int i = 0; i < childrenSize; i++) {\n+              MNode child = nodeStack.removeFirst();\n+              child.setParent(node);\n+              childrenMap.put(child.getName(), child);\n+              if (child instanceof MeasurementMNode) {\n+                String alias = ((MeasurementMNode) child).getAlias();\n+                if (alias != null) {\n+                  node.addAlias(alias, child);\n+                }\n+              }\n+            }\n+            node.setChildren(childrenMap);\n+            nodeStack.push(node);\n+          }\n+        } catch (Exception e) {\n+          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n+        }\n+      }\n+      return new MTree(node);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n     } finally {\n+      if (mlogReader != null) {\n+        mlogReader.close();\n+      }\n       limit = new ThreadLocal<>();\n       offset = new ThreadLocal<>();\n       count = new ThreadLocal<>();\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 1b0807e9d5..31fbef0463 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1283,9 +1276,6 @@ public class MTree implements Serializable {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n     } finally {\n-      if (mlogReader != null) {\n-        mlogReader.close();\n-      }\n       limit = new ThreadLocal<>();\n       offset = new ThreadLocal<>();\n       count = new ThreadLocal<>();\n", "next_change": {"commit": "bc0aea4a6ee1f92a2b379da57acb77ad20a447a1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 31fbef0463..a0e62f2ca2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1223,55 +1222,9 @@ public class MTree implements Serializable {\n     }\n   }\n \n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-\n-    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n-      Deque<MNode> nodeStack = new ArrayDeque<>();\n-      MNode node = null;\n-\n-      while (mlogReader.hasNext()) {\n-        PhysicalPlan plan = null;\n-        try {\n-          plan = mlogReader.next();\n-          if (plan == null) {\n-            continue;\n-          }\n-          int childrenSize = 0;\n-          if (plan instanceof StorageGroupMNodePlan) {\n-            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n-            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MeasurementMNodePlan) {\n-            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n-            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MNodePlan) {\n-            node = new MNode(null, ((MNodePlan) plan).getName());\n-            childrenSize = ((MNodePlan) plan).getChildSize();\n-          }\n-\n-          if (childrenSize == 0) {\n-            nodeStack.push(node);\n-          } else {\n-            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n-            for (int i = 0; i < childrenSize; i++) {\n-              MNode child = nodeStack.removeFirst();\n-              child.setParent(node);\n-              childrenMap.put(child.getName(), child);\n-              if (child instanceof MeasurementMNode) {\n-                String alias = ((MeasurementMNode) child).getAlias();\n-                if (alias != null) {\n-                  node.addAlias(alias, child);\n-                }\n-              }\n-            }\n-            node.setChildren(childrenMap);\n-            nodeStack.push(node);\n-          }\n-        } catch (Exception e) {\n-          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n-        }\n-      }\n-      return new MTree(node);\n+    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n+      return deserializeFromReader(mLogReader);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n", "next_change": null}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 31fbef0463..a0e62f2ca2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1283,6 +1236,53 @@ public class MTree implements Serializable {\n     }\n   }\n \n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  private static MTree deserializeFromReader(MLogReader mLogReader) {\n+    Deque<MNode> nodeStack = new ArrayDeque<>();\n+    MNode node = null;\n+    while (mLogReader.hasNext()) {\n+      PhysicalPlan plan = null;\n+      try {\n+        plan = mLogReader.next();\n+        if (plan == null) {\n+          continue;\n+        }\n+        int childrenSize = 0;\n+        if (plan instanceof StorageGroupMNodePlan) {\n+          node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+          childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+        } else if (plan instanceof MeasurementMNodePlan) {\n+          node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n+          childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n+        } else if (plan instanceof MNodePlan) {\n+          node = new MNode(null, ((MNodePlan) plan).getName());\n+          childrenSize = ((MNodePlan) plan).getChildSize();\n+        }\n+\n+        if (childrenSize != 0) {\n+          ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+          for (int i = 0; i < childrenSize; i++) {\n+            MNode child = nodeStack.removeFirst();\n+            child.setParent(node);\n+            childrenMap.put(child.getName(), child);\n+            if (child instanceof MeasurementMNode) {\n+              String alias = ((MeasurementMNode) child).getAlias();\n+              if (alias != null) {\n+                node.addAlias(alias, child);\n+              }\n+            }\n+          }\n+          node.setChildren(childrenMap);\n+        }\n+        nodeStack.push(node);\n+      } catch (Exception e) {\n+        logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n+      }\n+    }\n+\n+    return new MTree(node);\n+  }\n+\n   @Override\n   public String toString() {\n     JsonObject jsonObject = new JsonObject();\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjY4MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486736680", "body": "Use try with resource", "bodyText": "Use try with resource", "bodyHTML": "<p dir=\"auto\">Use try with resource</p>", "author": "HTHou", "createdAt": "2020-09-11T02:28:38Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -1002,55 +1008,74 @@ private void findNodes(MNode node, PartialPath path, List<PartialPath> res, int\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (BufferedWriter bw = new BufferedWriter(\n-        new FileWriter(SystemFileFactory.INSTANCE.getFile(snapshotPath)))) {\n-      root.serializeTo(bw);\n+    MLogWriter mLogWriter = null;\n+    try {\n+      mLogWriter = new MLogWriter(snapshotPath);\n+      root.serializeTo(mLogWriter);\n+    } finally {\n+      if (mLogWriter != null) {\n+        mLogWriter.close();\n+      }\n     }", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex bbbe2eec01..87d0dcdde3 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1008,22 +1004,15 @@ public class MTree implements Serializable {\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    MLogWriter mLogWriter = null;\n-    try {\n-      mLogWriter = new MLogWriter(snapshotPath);\n+    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n       root.serializeTo(mLogWriter);\n-    } finally {\n-      if (mLogWriter != null) {\n-        mLogWriter.close();\n-      }\n     }\n   }\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-    MLogReader mlogReader = null;\n-    try {\n-      mlogReader = new MLogReader(mtreeSnapshot);\n+\n+    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n       Deque<MNode> nodeStack = new ArrayDeque<>();\n       MNode node = null;\n \n", "next_change": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 87d0dcdde3..314af82411 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1009,55 +1218,9 @@ public class MTree implements Serializable {\n     }\n   }\n \n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-\n-    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n-      Deque<MNode> nodeStack = new ArrayDeque<>();\n-      MNode node = null;\n-\n-      while (mlogReader.hasNext()) {\n-        PhysicalPlan plan = null;\n-        try {\n-          plan = mlogReader.next();\n-          if (plan == null) {\n-            continue;\n-          }\n-          int childrenSize = 0;\n-          if (plan instanceof StorageGroupMNodePlan) {\n-            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n-            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MeasurementMNodePlan) {\n-            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n-            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MNodePlan) {\n-            node = new MNode(null, ((MNodePlan) plan).getName());\n-            childrenSize = ((MNodePlan) plan).getChildSize();\n-          }\n-\n-          if (childrenSize == 0) {\n-            nodeStack.push(node);\n-          } else {\n-            Map<String, MNode> childrenMap = new LinkedHashMap<>();\n-            for (int i = 0; i < childrenSize; i++) {\n-              MNode child = nodeStack.removeFirst();\n-              child.setParent(node);\n-              childrenMap.put(child.getName(), child);\n-              if (child instanceof MeasurementMNode) {\n-                String alias = ((MeasurementMNode) child).getAlias();\n-                if (alias != null) {\n-                  node.addAlias(alias, child);\n-                }\n-              }\n-            }\n-            node.setChildren(childrenMap);\n-            nodeStack.push(node);\n-          }\n-        } catch (Exception e) {\n-          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n-        }\n-      }\n-      return new MTree(node);\n+    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n+      return deserializeFromReader(mLogReader);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 314af82411..1b0807e9d5 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1213,18 +1218,74 @@ public class MTree implements Serializable {\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n+    MLogWriter mLogWriter = null;\n+    try {\n+      mLogWriter = new MLogWriter(snapshotPath);\n       root.serializeTo(mLogWriter);\n+    } finally {\n+      if (mLogWriter != null) {\n+        mLogWriter.close();\n+      }\n     }\n   }\n \n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n-      return deserializeFromReader(mLogReader);\n+    MLogReader mlogReader = null;\n+    try {\n+      mlogReader = new MLogReader(mtreeSnapshot);\n+      Deque<MNode> nodeStack = new ArrayDeque<>();\n+      MNode node = null;\n+\n+      while (mlogReader.hasNext()) {\n+        PhysicalPlan plan = null;\n+        try {\n+          plan = mlogReader.next();\n+          if (plan == null) {\n+            continue;\n+          }\n+          int childrenSize = 0;\n+          if (plan instanceof StorageGroupMNodePlan) {\n+            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MeasurementNodePlan) {\n+            node = MeasurementMNode.deserializeFrom((MeasurementNodePlan) plan);\n+            childrenSize = ((MeasurementNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MNodePlan) {\n+            node = new MNode(null, ((MNodePlan) plan).getName());\n+            childrenSize = ((MNodePlan) plan).getChildSize();\n+          }\n+\n+          if (childrenSize == 0) {\n+            nodeStack.push(node);\n+          } else {\n+            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+            for (int i = 0; i < childrenSize; i++) {\n+              MNode child = nodeStack.removeFirst();\n+              child.setParent(node);\n+              childrenMap.put(child.getName(), child);\n+              if (child instanceof MeasurementMNode) {\n+                String alias = ((MeasurementMNode) child).getAlias();\n+                if (alias != null) {\n+                  node.addAlias(alias, child);\n+                }\n+              }\n+            }\n+            node.setChildren(childrenMap);\n+            nodeStack.push(node);\n+          }\n+        } catch (Exception e) {\n+          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n+        }\n+      }\n+      return new MTree(node);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n     } finally {\n+      if (mlogReader != null) {\n+        mlogReader.close();\n+      }\n       limit = new ThreadLocal<>();\n       offset = new ThreadLocal<>();\n       count = new ThreadLocal<>();\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 1b0807e9d5..31fbef0463 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1283,9 +1276,6 @@ public class MTree implements Serializable {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n     } finally {\n-      if (mlogReader != null) {\n-        mlogReader.close();\n-      }\n       limit = new ThreadLocal<>();\n       offset = new ThreadLocal<>();\n       count = new ThreadLocal<>();\n", "next_change": {"commit": "bc0aea4a6ee1f92a2b379da57acb77ad20a447a1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 31fbef0463..a0e62f2ca2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1223,55 +1222,9 @@ public class MTree implements Serializable {\n     }\n   }\n \n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-\n-    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n-      Deque<MNode> nodeStack = new ArrayDeque<>();\n-      MNode node = null;\n-\n-      while (mlogReader.hasNext()) {\n-        PhysicalPlan plan = null;\n-        try {\n-          plan = mlogReader.next();\n-          if (plan == null) {\n-            continue;\n-          }\n-          int childrenSize = 0;\n-          if (plan instanceof StorageGroupMNodePlan) {\n-            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n-            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MeasurementMNodePlan) {\n-            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n-            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MNodePlan) {\n-            node = new MNode(null, ((MNodePlan) plan).getName());\n-            childrenSize = ((MNodePlan) plan).getChildSize();\n-          }\n-\n-          if (childrenSize == 0) {\n-            nodeStack.push(node);\n-          } else {\n-            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n-            for (int i = 0; i < childrenSize; i++) {\n-              MNode child = nodeStack.removeFirst();\n-              child.setParent(node);\n-              childrenMap.put(child.getName(), child);\n-              if (child instanceof MeasurementMNode) {\n-                String alias = ((MeasurementMNode) child).getAlias();\n-                if (alias != null) {\n-                  node.addAlias(alias, child);\n-                }\n-              }\n-            }\n-            node.setChildren(childrenMap);\n-            nodeStack.push(node);\n-          }\n-        } catch (Exception e) {\n-          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n-        }\n-      }\n-      return new MTree(node);\n+    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n+      return deserializeFromReader(mLogReader);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n", "next_change": null}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 31fbef0463..a0e62f2ca2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1283,6 +1236,53 @@ public class MTree implements Serializable {\n     }\n   }\n \n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  private static MTree deserializeFromReader(MLogReader mLogReader) {\n+    Deque<MNode> nodeStack = new ArrayDeque<>();\n+    MNode node = null;\n+    while (mLogReader.hasNext()) {\n+      PhysicalPlan plan = null;\n+      try {\n+        plan = mLogReader.next();\n+        if (plan == null) {\n+          continue;\n+        }\n+        int childrenSize = 0;\n+        if (plan instanceof StorageGroupMNodePlan) {\n+          node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+          childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+        } else if (plan instanceof MeasurementMNodePlan) {\n+          node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n+          childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n+        } else if (plan instanceof MNodePlan) {\n+          node = new MNode(null, ((MNodePlan) plan).getName());\n+          childrenSize = ((MNodePlan) plan).getChildSize();\n+        }\n+\n+        if (childrenSize != 0) {\n+          ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+          for (int i = 0; i < childrenSize; i++) {\n+            MNode child = nodeStack.removeFirst();\n+            child.setParent(node);\n+            childrenMap.put(child.getName(), child);\n+            if (child instanceof MeasurementMNode) {\n+              String alias = ((MeasurementMNode) child).getAlias();\n+              if (alias != null) {\n+                node.addAlias(alias, child);\n+              }\n+            }\n+          }\n+          node.setChildren(childrenMap);\n+        }\n+        nodeStack.push(node);\n+      } catch (Exception e) {\n+        logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n+      }\n+    }\n+\n+    return new MTree(node);\n+  }\n+\n   @Override\n   public String toString() {\n     JsonObject jsonObject = new JsonObject();\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjgzNg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486736836", "body": "Use try with resource", "bodyText": "Use try with resource", "bodyHTML": "<p dir=\"auto\">Use try with resource</p>", "author": "HTHou", "createdAt": "2020-09-11T02:29:15Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -248,21 +237,32 @@ private int initFromLog(File logFile) throws IOException {\n     // init the metadata from the operation log\n     if (logFile.exists()) {\n       int idx = 0;\n-      try (FileReader fr = new FileReader(logFile);\n-          BufferedReader br = new BufferedReader(fr)) {\n-        String cmd;\n-        while ((cmd = br.readLine()) != null) {\n+      MLogReader mLogReader = null;\n+      try {\n+        mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex 358c1fc0e2..b4812ce2ea 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n", "chunk": "@@ -237,9 +237,8 @@ public class MManager {\n     // init the metadata from the operation log\n     if (logFile.exists()) {\n       int idx = 0;\n-      MLogReader mLogReader = null;\n-      try {\n-        mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);\n+      try (MLogReader mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);) {\n+\n         while (mLogReader.hasNext()) {\n           PhysicalPlan plan = null;\n           try {\n", "next_change": {"commit": "18bb0557753e46238c0a17cd131af13a072eb09c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex b4812ce2ea..f13ed7a4d5 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n", "chunk": "@@ -238,7 +268,6 @@ public class MManager {\n     if (logFile.exists()) {\n       int idx = 0;\n       try (MLogReader mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);) {\n-\n         while (mLogReader.hasNext()) {\n           PhysicalPlan plan = null;\n           try {\n", "next_change": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex f13ed7a4d5..23f64db273 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n", "chunk": "@@ -268,19 +269,7 @@ public class MManager {\n     if (logFile.exists()) {\n       int idx = 0;\n       try (MLogReader mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);) {\n-        while (mLogReader.hasNext()) {\n-          PhysicalPlan plan = null;\n-          try {\n-            plan = mLogReader.next();\n-            if (plan == null) {\n-              continue;\n-            }\n-            operation(plan);\n-            idx++;\n-          } catch (Exception e) {\n-            logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n-          }\n-        }\n+        idx = applyMlog(mLogReader);\n         logger.debug(\"spend {} ms to deserialize mtree from mlog.bin\",\n             System.currentTimeMillis() - time);\n         return idx;\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex 23f64db273..b68316845c 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n", "chunk": "@@ -268,37 +268,39 @@ public class MManager {\n     // init the metadata from the operation log\n     if (logFile.exists()) {\n       int idx = 0;\n-      try (MLogReader mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);) {\n-        idx = applyMlog(mLogReader);\n+      MLogReader mLogReader = null;\n+      try {\n+        mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);\n+        while (mLogReader.hasNext()) {\n+          PhysicalPlan plan = null;\n+          try {\n+            plan = mLogReader.next();\n+            if (plan == null) {\n+              continue;\n+            }\n+            operation(plan);\n+            idx++;\n+          } catch (Exception e) {\n+            logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n+          }\n+        }\n         logger.debug(\"spend {} ms to deserialize mtree from mlog.bin\",\n             System.currentTimeMillis() - time);\n         return idx;\n       } catch (Exception e) {\n         throw new IOException(\"Failed to parser mlog.bin for err:\" +  e.toString());\n+      } finally {\n+        if (mLogReader != null) {\n+          mLogReader.close();\n+        }\n       }\n+    } else if (mtreeSnapshot.exists()) {\n+      throw new IOException(\"mtree snapshot file exists but mlog.txt does not exist.\");\n     } else {\n       return 0;\n     }\n   }\n \n-  private int applyMlog(MLogReader mLogReader) {\n-    int idx = 0;\n-    while (mLogReader.hasNext()) {\n-      PhysicalPlan plan = null;\n-      try {\n-        plan = mLogReader.next();\n-        if (plan == null) {\n-          continue;\n-        }\n-        operation(plan);\n-        idx++;\n-      } catch (Exception e) {\n-        logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n-      }\n-    }\n-    return idx;\n-  }\n-\n   /**\n    * function for clearing MTree\n    */\n", "next_change": {"commit": "bc0aea4a6ee1f92a2b379da57acb77ad20a447a1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex b68316845c..f7bc057ee8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n", "chunk": "@@ -268,39 +269,37 @@ public class MManager {\n     // init the metadata from the operation log\n     if (logFile.exists()) {\n       int idx = 0;\n-      MLogReader mLogReader = null;\n-      try {\n-        mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);\n-        while (mLogReader.hasNext()) {\n-          PhysicalPlan plan = null;\n-          try {\n-            plan = mLogReader.next();\n-            if (plan == null) {\n-              continue;\n-            }\n-            operation(plan);\n-            idx++;\n-          } catch (Exception e) {\n-            logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n-          }\n-        }\n+      try (MLogReader mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);) {\n+        idx = applyMlog(mLogReader);\n         logger.debug(\"spend {} ms to deserialize mtree from mlog.bin\",\n             System.currentTimeMillis() - time);\n         return idx;\n       } catch (Exception e) {\n         throw new IOException(\"Failed to parser mlog.bin for err:\" +  e.toString());\n-      } finally {\n-        if (mLogReader != null) {\n-          mLogReader.close();\n-        }\n       }\n-    } else if (mtreeSnapshot.exists()) {\n-      throw new IOException(\"mtree snapshot file exists but mlog.txt does not exist.\");\n     } else {\n       return 0;\n     }\n   }\n \n+  private int applyMlog(MLogReader mLogReader) {\n+    int idx = 0;\n+    while (mLogReader.hasNext()) {\n+      PhysicalPlan plan = null;\n+      try {\n+        plan = mLogReader.next();\n+        if (plan == null) {\n+          continue;\n+        }\n+        operation(plan);\n+        idx++;\n+      } catch (Exception e) {\n+        logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n+      }\n+    }\n+    return idx;\n+  }\n+\n   /**\n    * function for clearing MTree\n    */\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNzQ0NA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486737444", "body": "info -> warn?", "bodyText": "info -> warn?", "bodyHTML": "<p dir=\"auto\">info -&gt; warn?</p>", "author": "HTHou", "createdAt": "2020-09-11T02:31:27Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.info(\"create schema folder {} failed.\", metadataDir);", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..5b258f16ed 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -58,7 +58,7 @@ public class MLogWriter {\n       if (metadataDir.mkdirs()) {\n         logger.info(\"create schema folder {}.\", metadataDir);\n       } else {\n-        logger.info(\"create schema folder {} failed.\", metadataDir);\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n       }\n     }\n \n", "next_change": {"commit": "7a5ad6d7312a641efad62a814f07be5ce4aade56", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -63,18 +80,16 @@ public class MLogWriter implements AutoCloseable {\n     }\n \n     logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n-    // always flush\n-    logWriter = new LogWriter(logFile, 0L);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n   }\n \n   public MLogWriter(String logFilePath) throws IOException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n-    // always flush\n-    logWriter = new LogWriter(logFile, 0L);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n   }\n \n+  @Override\n   public void close() throws IOException {\n-    sync();\n     logWriter.close();\n   }\n \n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -66,30 +52,29 @@ public class MLogWriter implements AutoCloseable {\n   private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n-  // we write log to channel every time, so we need not to call channel.force every time\n-  private final long DUMMY_FLUSH_TIME = 100;\n-\n   public MLogWriter(String schemaDir, String logFileName) throws IOException {\n     File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n     if (!metadataDir.exists()) {\n       if (metadataDir.mkdirs()) {\n         logger.info(\"create schema folder {}.\", metadataDir);\n       } else {\n-        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+        logger.info(\"create schema folder {} failed.\", metadataDir);\n       }\n     }\n \n     logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n-    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n   }\n \n   public MLogWriter(String logFilePath) throws IOException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n-    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n   }\n \n-  @Override\n   public void close() throws IOException {\n+    sync();\n     logWriter.close();\n   }\n \n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -73,6 +74,7 @@ public class MLogWriter {\n     logWriter = new LogWriter(logFile, 0L);\n   }\n \n+  @Override\n   public void close() throws IOException {\n     sync();\n     logWriter.close();\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -64,19 +80,16 @@ public class MLogWriter implements AutoCloseable {\n     }\n \n     logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n-    // always flush\n-    logWriter = new LogWriter(logFile, 0L);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n   }\n \n   public MLogWriter(String logFilePath) throws IOException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n-    // always flush\n-    logWriter = new LogWriter(logFile, 0L);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n   }\n \n   @Override\n   public void close() throws IOException {\n-    sync();\n     logWriter.close();\n   }\n \n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..9fea13282d 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -80,12 +81,12 @@ public class MLogWriter implements AutoCloseable {\n     }\n \n     logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n-    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+    logWriter = new LogWriter(logFile, false);\n   }\n \n   public MLogWriter(String logFilePath) throws IOException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n-    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+    logWriter = new LogWriter(logFile, false);\n   }\n \n   @Override\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNzc1MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486737750", "body": "use try with resource", "bodyText": "use try with resource", "bodyHTML": "<p dir=\"auto\">use try with resource</p>", "author": "HTHou", "createdAt": "2020-09-11T02:32:35Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.info(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementNodePlan plan = new MeasurementNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void seriallizeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+\n+    if (oldLogFile.exists()) {\n+      MLogWriter mLogWriter = null;\n+      OldMLogReader oldMLogReader = null;\n+      try {\n+        // upgrade from old character log file to new binary mlog\n+        mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n+        oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG);", "originalCommit": "329c11ffdc000c45dbea71fcd95f003cb57e4487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2NDc2Mg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486764762", "bodyText": "Got it!", "author": "mychaow", "createdAt": "2020-09-11T04:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNzc1MA=="}], "type": "inlineReview", "revised_code": {"commit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..5b258f16ed 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -221,12 +221,9 @@ public class MLogWriter {\n         schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n \n     if (oldLogFile.exists()) {\n-      MLogWriter mLogWriter = null;\n-      OldMLogReader oldMLogReader = null;\n-      try {\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n+        OldMLogReader oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n         // upgrade from old character log file to new binary mlog\n-        mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n-        oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG);\n         while (oldMLogReader.hasNext()) {\n           String cmd = oldMLogReader.next();\n           try {\n", "next_change": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -222,36 +222,45 @@ public class MLogWriter implements AutoCloseable {\n \n     if (oldLogFile.exists()) {\n       try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n-        OldMLogReader oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n+        MLogTxtReader MLogTxtReader = new MLogTxtReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n         // upgrade from old character log file to new binary mlog\n-        while (oldMLogReader.hasNext()) {\n-          String cmd = oldMLogReader.next();\n+        while (MLogTxtReader.hasNext()) {\n+          String cmd = MLogTxtReader.next();\n           try {\n             mLogWriter.operation(cmd);\n           } catch (MetadataException e) {\n             logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n           }\n         }\n-\n-        return;\n       }\n-    }\n-\n-    // if both old mlog and mlog.tmp do not exist, nothing to do\n-    if (!logFile.exists() && !tmpLogFile.exists()) {\n-      return;\n+    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n+      // if both old mlog.bin and mlog.bin.tmp do not exist, nothing to do\n     } else if (!logFile.exists() && tmpLogFile.exists()) {\n-      // if old mlog doesn't exist but mlog.tmp exists, rename tmp file to mlog\n+      // if old mlog.bin doesn't exist but mlog.bin.tmp exists, rename tmp file to mlog\n       FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n-      return;\n-    }\n-\n-    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n-    if (tmpLogFile.exists()) {\n+    } else if (tmpLogFile.exists()) {\n+      // if both old mlog.bin and mlog.bin.tmp exist, delete mlog.bin.tmp\n       if (!tmpLogFile.delete()) {\n         throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n       }\n     }\n+\n+    // do some clean job\n+\n+    // remove old mlog.txt and mlog.txt.tmp\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n+\n+    if (oldLogFile.exists() && !oldLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt \" + oldLogFile + \"failed.\");\n+    }\n+\n+    if (tmpLogFile.exists() && !tmpLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldLogFile + \"failed.\");\n+    }\n+\n+    // rename mlog.bin.tmp to mlog.bin\n+    FileUtils.moveFile(tmpLogFile, logFile);\n   }\n \n   public void clear() throws IOException {\n", "next_change": {"commit": "7a5ad6d7312a641efad62a814f07be5ce4aade56", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -214,53 +224,63 @@ public class MLogWriter implements AutoCloseable {\n     }\n   }\n \n-  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n-    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n+                                     String newFileName, boolean isSnapshot) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n     File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n     File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n-        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+      schemaDir + File.separator + oldFileName);\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n+\n+    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n \n-    if (oldLogFile.exists()) {\n-      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n-        MLogTxtReader MLogTxtReader = new MLogTxtReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n+      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n+        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n+      }\n+\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n+           MLogTxtReader MLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n         // upgrade from old character log file to new binary mlog\n         while (MLogTxtReader.hasNext()) {\n           String cmd = MLogTxtReader.next();\n           try {\n-            mLogWriter.operation(cmd);\n+            mLogWriter.operation(cmd, isSnapshot);\n           } catch (MetadataException e) {\n             logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n           }\n         }\n       }\n     } else if (!logFile.exists() && !tmpLogFile.exists()) {\n-      // if both old mlog.bin and mlog.bin.tmp do not exist, nothing to do\n+      // if both .bin and .bin.tmp do not exist, nothing to do\n     } else if (!logFile.exists() && tmpLogFile.exists()) {\n-      // if old mlog.bin doesn't exist but mlog.bin.tmp exists, rename tmp file to mlog\n+      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n       FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n     } else if (tmpLogFile.exists()) {\n-      // if both old mlog.bin and mlog.bin.tmp exist, delete mlog.bin.tmp\n+      // if both .bin and .bin.tmp exist, delete .bin.tmp\n       if (!tmpLogFile.delete()) {\n         throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n       }\n     }\n \n     // do some clean job\n-\n-    // remove old mlog.txt and mlog.txt.tmp\n-    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n-      + \".tmp\");\n-\n+    // remove old .txt and .txt.tmp\n     if (oldLogFile.exists() && !oldLogFile.delete()) {\n       throw new IOException(\"Deleting old mlog.txt \" + oldLogFile + \"failed.\");\n     }\n \n-    if (tmpLogFile.exists() && !tmpLogFile.delete()) {\n+    if (tmpOldLogFile.exists() && !tmpOldLogFile.delete()) {\n       throw new IOException(\"Deleting old mlog.txt.tmp \" + oldLogFile + \"failed.\");\n     }\n \n-    // rename mlog.bin.tmp to mlog.bin\n-    FileUtils.moveFile(tmpLogFile, logFile);\n+    // rename .bin.tmp to .bin\n+    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+  }\n+\n+  public static void upgradeMLog() throws IOException {\n+    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n+    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n+    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n   }\n \n   public void clear() throws IOException {\n", "next_change": {"commit": "18bb0557753e46238c0a17cd131af13a072eb09c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -287,10 +286,8 @@ public class MLogWriter implements AutoCloseable {\n     sync();\n     logWriter.close();\n     mlogBuffer.clear();\n-    if (logFile != null) {\n-      if (logFile.exists()) {\n-        Files.delete(logFile.toPath());\n-      }\n+    if (logFile != null && logFile.exists()) {\n+      Files.delete(logFile.toPath());\n     }\n     logNum = 0;\n     logWriter = new LogWriter(logFile, 0L);\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -221,73 +210,68 @@ public class MLogWriter implements AutoCloseable {\n       putLog(plan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        LOG_TOO_LARGE_INFO, e);\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n     }\n   }\n \n-  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n-                                     String newFileName, boolean isSnapshot) throws IOException {\n-    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n+  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n     File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n     File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n-      schemaDir + File.separator + oldFileName);\n-    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n-      + \".tmp\");\n-\n-    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n+        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n \n-      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n-        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n-      }\n-\n-      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n-           MLogTxtReader mLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n+    if (oldLogFile.exists()) {\n+      MLogWriter mLogWriter = null;\n+      OldMLogReader oldMLogReader = null;\n+      try {\n         // upgrade from old character log file to new binary mlog\n-        while (mLogTxtReader.hasNext()) {\n-          String cmd = mLogTxtReader.next();\n+        mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n+        oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG);\n+        while (oldMLogReader.hasNext()) {\n+          String cmd = oldMLogReader.next();\n           try {\n-            mLogWriter.operation(cmd, isSnapshot);\n+            mLogWriter.operation(cmd);\n           } catch (MetadataException e) {\n             logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n           }\n         }\n+\n+        return;\n+      } finally {\n+        if (mLogWriter != null) {\n+          mLogWriter.close();\n+        }\n+        if (oldMLogReader != null) {\n+          oldMLogReader.close();\n+        }\n       }\n-    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n-      // if both .bin and .bin.tmp do not exist, nothing to do\n-    } else if (!logFile.exists() && tmpLogFile.exists()) {\n-      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n-      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n-    } else if (tmpLogFile.exists() && !tmpLogFile.delete()) {\n-      // if both .bin and .bin.tmp exist, delete .bin.tmp\n-      throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n     }\n \n-    // do some clean job\n-    // remove old .txt and .txt.tmp\n-    if (oldLogFile.exists() && !oldLogFile.delete()) {\n-      throw new IOException(\"Deleting old mlog.txt \" + oldLogFile + \"failed.\");\n+    // if both old mlog and mlog.tmp do not exist, nothing to do\n+    if (!logFile.exists() && !tmpLogFile.exists()) {\n+      return;\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old mlog doesn't exsit but mlog.tmp exists, rename tmp file to mlog  \n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+      return;\n     }\n \n-    if (tmpOldLogFile.exists() && !tmpOldLogFile.delete()) {\n-      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldLogFile + \"failed.\");\n+    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n+    if (tmpLogFile.exists()) {\n+      if (!tmpLogFile.delete()) {\n+        throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n+      }\n     }\n-\n-    // rename .bin.tmp to .bin\n-    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n-  }\n-\n-  public static void upgradeMLog() throws IOException {\n-    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n-    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n-    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n   }\n \n   public void clear() throws IOException {\n     sync();\n     logWriter.close();\n     mlogBuffer.clear();\n-    if (logFile != null && logFile.exists()) {\n-      Files.delete(logFile.toPath());\n+    if (logFile != null) {\n+      if (logFile.exists()) {\n+        Files.delete(logFile.toPath());\n+      }\n     }\n     logNum = 0;\n     logWriter = new LogWriter(logFile, 0L);\n", "next_change": {"commit": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -210,68 +221,73 @@ public class MLogWriter {\n       putLog(plan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+        LOG_TOO_LARGE_INFO, e);\n     }\n   }\n \n-  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n-    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n+                                     String newFileName, boolean isSnapshot) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n     File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n     File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n-        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+      schemaDir + File.separator + oldFileName);\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n \n-    if (oldLogFile.exists()) {\n-      MLogWriter mLogWriter = null;\n-      OldMLogReader oldMLogReader = null;\n-      try {\n+    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n+\n+      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n+        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n+      }\n+\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n+           MLogTxtReader mLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n         // upgrade from old character log file to new binary mlog\n-        mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n-        oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG);\n-        while (oldMLogReader.hasNext()) {\n-          String cmd = oldMLogReader.next();\n+        while (mLogTxtReader.hasNext()) {\n+          String cmd = mLogTxtReader.next();\n           try {\n-            mLogWriter.operation(cmd);\n+            mLogWriter.operation(cmd, isSnapshot);\n           } catch (MetadataException e) {\n             logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n           }\n         }\n-\n-        return;\n-      } finally {\n-        if (mLogWriter != null) {\n-          mLogWriter.close();\n-        }\n-        if (oldMLogReader != null) {\n-          oldMLogReader.close();\n-        }\n       }\n-    }\n-\n-    // if both old mlog and mlog.tmp do not exist, nothing to do\n-    if (!logFile.exists() && !tmpLogFile.exists()) {\n-      return;\n+    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp do not exist, nothing to do\n     } else if (!logFile.exists() && tmpLogFile.exists()) {\n-      // if old mlog doesn't exsit but mlog.tmp exists, rename tmp file to mlog  \n+      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n       FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n-      return;\n+    } else if (tmpLogFile.exists() && !tmpLogFile.delete()) {\n+      // if both .bin and .bin.tmp exist, delete .bin.tmp\n+      throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n     }\n \n-    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n-    if (tmpLogFile.exists()) {\n-      if (!tmpLogFile.delete()) {\n-        throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n-      }\n+    // do some clean job\n+    // remove old .txt and .txt.tmp\n+    if (oldLogFile.exists() && !oldLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt \" + oldLogFile + \"failed.\");\n     }\n+\n+    if (tmpOldLogFile.exists() && !tmpOldLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldLogFile + \"failed.\");\n+    }\n+\n+    // rename .bin.tmp to .bin\n+    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+  }\n+\n+  public static void upgradeMLog() throws IOException {\n+    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n+    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n+    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n   }\n \n   public void clear() throws IOException {\n     sync();\n     logWriter.close();\n     mlogBuffer.clear();\n-    if (logFile != null) {\n-      if (logFile.exists()) {\n-        Files.delete(logFile.toPath());\n-      }\n+    if (logFile != null && logFile.exists()) {\n+      Files.delete(logFile.toPath());\n     }\n     logNum = 0;\n     logWriter = new LogWriter(logFile, 0L);\n", "next_change": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..7d1522fef9 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -290,7 +305,7 @@ public class MLogWriter implements AutoCloseable {\n       Files.delete(logFile.toPath());\n     }\n     logNum = 0;\n-    logWriter = new LogWriter(logFile, 0L);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n   }\n \n   public int getLogNum() {\n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 7d1522fef9..9fea13282d 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -305,7 +303,7 @@ public class MLogWriter implements AutoCloseable {\n       Files.delete(logFile.toPath());\n     }\n     logNum = 0;\n-    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+    logWriter = new LogWriter(logFile, false);\n   }\n \n   public int getLogNum() {\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "url": "https://github.com/apache/iotdb/commit/6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "message": "fix upgrade mlog bug", "committedDate": "2020-09-11T06:08:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5OTMzNA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r486799334", "body": "Hi, may I ask why we put operations like `serializeMNode` to log? ", "bodyText": "Hi, may I ask why we put operations like serializeMNode to log?", "bodyHTML": "<p dir=\"auto\">Hi, may I ask why we put operations like <code>serializeMNode</code> to log?</p>", "author": "samperson1997", "createdAt": "2020-09-11T06:24:10Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzMDM4MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487030380", "bodyText": "It's snapshot file, not mlog.bin, I just serialize the snapshot and mlog by the same logwriter class. So, the snapshot file has the same format with mlog.bin.", "author": "mychaow", "createdAt": "2020-09-11T13:04:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5OTMzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4ODI5OA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487388298", "bodyText": "Ah... I understand, it used to be the snapshot file which serializes the MTree. @qiaojialin Do you think it is acceptable?", "author": "samperson1997", "createdAt": "2020-09-12T09:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5OTMzNA=="}], "type": "inlineReview", "revised_code": {"commit": "18bb0557753e46238c0a17cd131af13a072eb09c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -181,7 +192,7 @@ public class MLogWriter implements AutoCloseable {\n       putLog(plan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+        LOG_TOO_LARGE_INFO, e);\n     }\n   }\n \n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -192,7 +181,7 @@ public class MLogWriter implements AutoCloseable {\n       putLog(plan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        LOG_TOO_LARGE_INFO, e);\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n     }\n   }\n \n", "next_change": {"commit": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -181,7 +192,7 @@ public class MLogWriter {\n       putLog(plan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+        LOG_TOO_LARGE_INFO, e);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc2MDE5Mw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487760193", "body": "larger?", "bodyText": "larger?", "bodyHTML": "<p dir=\"auto\">larger?</p>", "author": "qiaojialin", "createdAt": "2020-09-14T09:03:14Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -168,6 +168,12 @@\n    */\n   private int walBufferSize = 16 * 1024 * 1024;\n \n+  /**\n+   * Size of log buffer for every MetaData operation. If the size of a MetaData operation plan\n+   * is smaller than this parameter, then the MetaData operation plan will be rejected by MManager.", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java\nindex 171172c6fe..9f65aee727 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java\n", "chunk": "@@ -164,16 +164,22 @@ public class IoTDBConfig {\n \n   /**\n    * Size of log buffer in each log node(in byte). If WAL is enabled and the size of a insert plan\n-   * is smaller than this parameter, then the insert plan will be rejected by WAL.\n+   * is larger than this parameter, then the insert plan will be rejected by WAL.\n    */\n   private int walBufferSize = 16 * 1024 * 1024;\n \n   /**\n    * Size of log buffer for every MetaData operation. If the size of a MetaData operation plan\n-   * is smaller than this parameter, then the MetaData operation plan will be rejected by MManager.\n+   * is larger than this parameter, then the MetaData operation plan will be rejected by MManager.\n    */\n   private int mlogBufferSize = 64 * 1024;\n \n+  /**\n+   * The cycle when meta log is periodically forced to be written to disk(in milliseconds) If\n+   * set this parameter to 0 it means call outputStream.force(true) after every each insert\n+   */\n+  private long forceMlogPeriodInMs = 100;\n+\n   /**\n    * system base dir, stores all system metadata and wal\n    */\n", "next_change": {"commit": "df0282f1249629b08e83f6e465ac060ff3864a00", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java\nindex 9f65aee727..46227bb703 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java\n", "chunk": "@@ -181,36 +217,36 @@ public class IoTDBConfig {\n   private long forceMlogPeriodInMs = 100;\n \n   /**\n-   * system base dir, stores all system metadata and wal\n+   * default base dir, stores all IoTDB runtime files\n    */\n-  private String baseDir = \"data\";\n+  private static final String DEFAULT_BASE_DIR = \"data\";\n \n   /**\n    * System directory, including version file for each storage group and metadata\n    */\n-  private String systemDir = baseDir + File.separator + IoTDBConstant.SYSTEM_FOLDER_NAME;\n+  private String systemDir = DEFAULT_BASE_DIR + File.separator + IoTDBConstant.SYSTEM_FOLDER_NAME;\n \n   /**\n    * Schema directory, including storage set of values.\n    */\n-  private String schemaDir = baseDir + File.separator + IoTDBConstant.SYSTEM_FOLDER_NAME\n+  private String schemaDir = DEFAULT_BASE_DIR + File.separator + IoTDBConstant.SYSTEM_FOLDER_NAME\n       + File.separator + IoTDBConstant.SCHEMA_FOLDER_NAME;\n \n   /**\n    * Sync directory, including the lock file, uuid file, device owner map\n    */\n-  private String syncDir = baseDir + File.separator + IoTDBConstant.SYSTEM_FOLDER_NAME\n+  private String syncDir = DEFAULT_BASE_DIR + File.separator + IoTDBConstant.SYSTEM_FOLDER_NAME\n       + File.separator + IoTDBConstant.SYNC_FOLDER_NAME;\n \n   /**\n    * Performance tracing directory, stores performance tracing files\n    */\n-  private String tracingDir = baseDir + File.separator + IoTDBConstant.TRACING_FOLDER_NAME;\n+  private String tracingDir = DEFAULT_BASE_DIR + File.separator + IoTDBConstant.TRACING_FOLDER_NAME;\n \n   /**\n    * Query directory, stores temporary files of query\n    */\n-  private String queryDir = baseDir + File.separator + IoTDBConstant.QUERY_FOLDER_NAME;\n+  private String queryDir = DEFAULT_BASE_DIR + File.separator + IoTDBConstant.QUERY_FOLDER_NAME;\n \n   /**\n    * Data directory of data. It can be settled as dataDirs = {\"data1\", \"data2\", \"data3\"};\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3ODgyNQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487778825", "body": "```suggestion\r\n    // if both old mlog.txt and mlog.bin.tmp do not exist, nothing to do\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // if both old mlog and mlog.tmp do not exist, nothing to do\n          \n          \n            \n                // if both old mlog.txt and mlog.bin.tmp do not exist, nothing to do", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-c\"><span class=\"pl-c\">//</span> if both old mlog and mlog.tmp do not exist, nothing to do</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-c\"><span class=\"pl-c\">//</span> if both old mlog<span class=\"x x-first x-last\">.txt</span> and mlog<span class=\"x x-first x-last\">.bin</span>.tmp do not exist, nothing to do</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "qiaojialin", "createdAt": "2020-09-14T09:34:40Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+\n+    if (oldLogFile.exists()) {\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n+        OldMLogReader oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n+        // upgrade from old character log file to new binary mlog\n+        while (oldMLogReader.hasNext()) {\n+          String cmd = oldMLogReader.next();\n+          try {\n+            mLogWriter.operation(cmd);\n+          } catch (MetadataException e) {\n+            logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n+          }\n+        }\n+\n+        return;\n+      }\n+    }\n+\n+    // if both old mlog and mlog.tmp do not exist, nothing to do", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -222,36 +222,45 @@ public class MLogWriter implements AutoCloseable {\n \n     if (oldLogFile.exists()) {\n       try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n-        OldMLogReader oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n+        MLogTxtReader MLogTxtReader = new MLogTxtReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n         // upgrade from old character log file to new binary mlog\n-        while (oldMLogReader.hasNext()) {\n-          String cmd = oldMLogReader.next();\n+        while (MLogTxtReader.hasNext()) {\n+          String cmd = MLogTxtReader.next();\n           try {\n             mLogWriter.operation(cmd);\n           } catch (MetadataException e) {\n             logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n           }\n         }\n-\n-        return;\n       }\n-    }\n-\n-    // if both old mlog and mlog.tmp do not exist, nothing to do\n-    if (!logFile.exists() && !tmpLogFile.exists()) {\n-      return;\n+    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n+      // if both old mlog.bin and mlog.bin.tmp do not exist, nothing to do\n     } else if (!logFile.exists() && tmpLogFile.exists()) {\n-      // if old mlog doesn't exist but mlog.tmp exists, rename tmp file to mlog\n+      // if old mlog.bin doesn't exist but mlog.bin.tmp exists, rename tmp file to mlog\n       FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n-      return;\n-    }\n-\n-    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n-    if (tmpLogFile.exists()) {\n+    } else if (tmpLogFile.exists()) {\n+      // if both old mlog.bin and mlog.bin.tmp exist, delete mlog.bin.tmp\n       if (!tmpLogFile.delete()) {\n         throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n       }\n     }\n+\n+    // do some clean job\n+\n+    // remove old mlog.txt and mlog.txt.tmp\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n+\n+    if (oldLogFile.exists() && !oldLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt \" + oldLogFile + \"failed.\");\n+    }\n+\n+    if (tmpLogFile.exists() && !tmpLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldLogFile + \"failed.\");\n+    }\n+\n+    // rename mlog.bin.tmp to mlog.bin\n+    FileUtils.moveFile(tmpLogFile, logFile);\n   }\n \n   public void clear() throws IOException {\n", "next_change": {"commit": "7a5ad6d7312a641efad62a814f07be5ce4aade56", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -214,53 +224,63 @@ public class MLogWriter implements AutoCloseable {\n     }\n   }\n \n-  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n-    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n+                                     String newFileName, boolean isSnapshot) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n     File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n     File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n-        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+      schemaDir + File.separator + oldFileName);\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n+\n+    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n \n-    if (oldLogFile.exists()) {\n-      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n-        MLogTxtReader MLogTxtReader = new MLogTxtReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n+      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n+        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n+      }\n+\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n+           MLogTxtReader MLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n         // upgrade from old character log file to new binary mlog\n         while (MLogTxtReader.hasNext()) {\n           String cmd = MLogTxtReader.next();\n           try {\n-            mLogWriter.operation(cmd);\n+            mLogWriter.operation(cmd, isSnapshot);\n           } catch (MetadataException e) {\n             logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n           }\n         }\n       }\n     } else if (!logFile.exists() && !tmpLogFile.exists()) {\n-      // if both old mlog.bin and mlog.bin.tmp do not exist, nothing to do\n+      // if both .bin and .bin.tmp do not exist, nothing to do\n     } else if (!logFile.exists() && tmpLogFile.exists()) {\n-      // if old mlog.bin doesn't exist but mlog.bin.tmp exists, rename tmp file to mlog\n+      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n       FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n     } else if (tmpLogFile.exists()) {\n-      // if both old mlog.bin and mlog.bin.tmp exist, delete mlog.bin.tmp\n+      // if both .bin and .bin.tmp exist, delete .bin.tmp\n       if (!tmpLogFile.delete()) {\n         throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n       }\n     }\n \n     // do some clean job\n-\n-    // remove old mlog.txt and mlog.txt.tmp\n-    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n-      + \".tmp\");\n-\n+    // remove old .txt and .txt.tmp\n     if (oldLogFile.exists() && !oldLogFile.delete()) {\n       throw new IOException(\"Deleting old mlog.txt \" + oldLogFile + \"failed.\");\n     }\n \n-    if (tmpLogFile.exists() && !tmpLogFile.delete()) {\n+    if (tmpOldLogFile.exists() && !tmpOldLogFile.delete()) {\n       throw new IOException(\"Deleting old mlog.txt.tmp \" + oldLogFile + \"failed.\");\n     }\n \n-    // rename mlog.bin.tmp to mlog.bin\n-    FileUtils.moveFile(tmpLogFile, logFile);\n+    // rename .bin.tmp to .bin\n+    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+  }\n+\n+  public static void upgradeMLog() throws IOException {\n+    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n+    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n+    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n   }\n \n   public void clear() throws IOException {\n", "next_change": {"commit": "18bb0557753e46238c0a17cd131af13a072eb09c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -287,10 +286,8 @@ public class MLogWriter implements AutoCloseable {\n     sync();\n     logWriter.close();\n     mlogBuffer.clear();\n-    if (logFile != null) {\n-      if (logFile.exists()) {\n-        Files.delete(logFile.toPath());\n-      }\n+    if (logFile != null && logFile.exists()) {\n+      Files.delete(logFile.toPath());\n     }\n     logNum = 0;\n     logWriter = new LogWriter(logFile, 0L);\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -221,73 +210,68 @@ public class MLogWriter implements AutoCloseable {\n       putLog(plan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        LOG_TOO_LARGE_INFO, e);\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n     }\n   }\n \n-  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n-                                     String newFileName, boolean isSnapshot) throws IOException {\n-    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n+  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n     File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n     File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n-      schemaDir + File.separator + oldFileName);\n-    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n-      + \".tmp\");\n-\n-    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n+        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n \n-      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n-        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n-      }\n-\n-      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n-           MLogTxtReader mLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n+    if (oldLogFile.exists()) {\n+      MLogWriter mLogWriter = null;\n+      OldMLogReader oldMLogReader = null;\n+      try {\n         // upgrade from old character log file to new binary mlog\n-        while (mLogTxtReader.hasNext()) {\n-          String cmd = mLogTxtReader.next();\n+        mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n+        oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG);\n+        while (oldMLogReader.hasNext()) {\n+          String cmd = oldMLogReader.next();\n           try {\n-            mLogWriter.operation(cmd, isSnapshot);\n+            mLogWriter.operation(cmd);\n           } catch (MetadataException e) {\n             logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n           }\n         }\n+\n+        return;\n+      } finally {\n+        if (mLogWriter != null) {\n+          mLogWriter.close();\n+        }\n+        if (oldMLogReader != null) {\n+          oldMLogReader.close();\n+        }\n       }\n-    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n-      // if both .bin and .bin.tmp do not exist, nothing to do\n-    } else if (!logFile.exists() && tmpLogFile.exists()) {\n-      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n-      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n-    } else if (tmpLogFile.exists() && !tmpLogFile.delete()) {\n-      // if both .bin and .bin.tmp exist, delete .bin.tmp\n-      throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n     }\n \n-    // do some clean job\n-    // remove old .txt and .txt.tmp\n-    if (oldLogFile.exists() && !oldLogFile.delete()) {\n-      throw new IOException(\"Deleting old mlog.txt \" + oldLogFile + \"failed.\");\n+    // if both old mlog and mlog.tmp do not exist, nothing to do\n+    if (!logFile.exists() && !tmpLogFile.exists()) {\n+      return;\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old mlog doesn't exsit but mlog.tmp exists, rename tmp file to mlog  \n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+      return;\n     }\n \n-    if (tmpOldLogFile.exists() && !tmpOldLogFile.delete()) {\n-      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldLogFile + \"failed.\");\n+    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n+    if (tmpLogFile.exists()) {\n+      if (!tmpLogFile.delete()) {\n+        throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n+      }\n     }\n-\n-    // rename .bin.tmp to .bin\n-    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n-  }\n-\n-  public static void upgradeMLog() throws IOException {\n-    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n-    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n-    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n   }\n \n   public void clear() throws IOException {\n     sync();\n     logWriter.close();\n     mlogBuffer.clear();\n-    if (logFile != null && logFile.exists()) {\n-      Files.delete(logFile.toPath());\n+    if (logFile != null) {\n+      if (logFile.exists()) {\n+        Files.delete(logFile.toPath());\n+      }\n     }\n     logNum = 0;\n     logWriter = new LogWriter(logFile, 0L);\n", "next_change": {"commit": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -210,68 +221,73 @@ public class MLogWriter {\n       putLog(plan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+        LOG_TOO_LARGE_INFO, e);\n     }\n   }\n \n-  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n-    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n+                                     String newFileName, boolean isSnapshot) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n     File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n     File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n-        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+      schemaDir + File.separator + oldFileName);\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n \n-    if (oldLogFile.exists()) {\n-      MLogWriter mLogWriter = null;\n-      OldMLogReader oldMLogReader = null;\n-      try {\n+    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n+\n+      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n+        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n+      }\n+\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n+           MLogTxtReader mLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n         // upgrade from old character log file to new binary mlog\n-        mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n-        oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG);\n-        while (oldMLogReader.hasNext()) {\n-          String cmd = oldMLogReader.next();\n+        while (mLogTxtReader.hasNext()) {\n+          String cmd = mLogTxtReader.next();\n           try {\n-            mLogWriter.operation(cmd);\n+            mLogWriter.operation(cmd, isSnapshot);\n           } catch (MetadataException e) {\n             logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n           }\n         }\n-\n-        return;\n-      } finally {\n-        if (mLogWriter != null) {\n-          mLogWriter.close();\n-        }\n-        if (oldMLogReader != null) {\n-          oldMLogReader.close();\n-        }\n       }\n-    }\n-\n-    // if both old mlog and mlog.tmp do not exist, nothing to do\n-    if (!logFile.exists() && !tmpLogFile.exists()) {\n-      return;\n+    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp do not exist, nothing to do\n     } else if (!logFile.exists() && tmpLogFile.exists()) {\n-      // if old mlog doesn't exsit but mlog.tmp exists, rename tmp file to mlog  \n+      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n       FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n-      return;\n+    } else if (tmpLogFile.exists() && !tmpLogFile.delete()) {\n+      // if both .bin and .bin.tmp exist, delete .bin.tmp\n+      throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n     }\n \n-    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n-    if (tmpLogFile.exists()) {\n-      if (!tmpLogFile.delete()) {\n-        throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n-      }\n+    // do some clean job\n+    // remove old .txt and .txt.tmp\n+    if (oldLogFile.exists() && !oldLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt \" + oldLogFile + \"failed.\");\n     }\n+\n+    if (tmpOldLogFile.exists() && !tmpOldLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldLogFile + \"failed.\");\n+    }\n+\n+    // rename .bin.tmp to .bin\n+    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+  }\n+\n+  public static void upgradeMLog() throws IOException {\n+    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n+    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n+    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n   }\n \n   public void clear() throws IOException {\n     sync();\n     logWriter.close();\n     mlogBuffer.clear();\n-    if (logFile != null) {\n-      if (logFile.exists()) {\n-        Files.delete(logFile.toPath());\n-      }\n+    if (logFile != null && logFile.exists()) {\n+      Files.delete(logFile.toPath());\n     }\n     logNum = 0;\n     logWriter = new LogWriter(logFile, 0L);\n", "next_change": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..7d1522fef9 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -290,7 +305,7 @@ public class MLogWriter implements AutoCloseable {\n       Files.delete(logFile.toPath());\n     }\n     logNum = 0;\n-    logWriter = new LogWriter(logFile, 0L);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n   }\n \n   public int getLogNum() {\n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 7d1522fef9..9fea13282d 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -305,7 +303,7 @@ public class MLogWriter implements AutoCloseable {\n       Files.delete(logFile.toPath());\n     }\n     logNum = 0;\n-    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+    logWriter = new LogWriter(logFile, false);\n   }\n \n   public int getLogNum() {\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3OTQ1Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487779456", "body": "```suggestion\r\n    // if both old mlog.txt and mlog.bin.tmp exist, delete mlog.bin.tmp, then do upgrading\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n          \n          \n            \n                // if both old mlog.txt and mlog.bin.tmp exist, delete mlog.bin.tmp, then do upgrading", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-c\"><span class=\"pl-c\">//</span> if both old mlog and mlog.tmp exist, delete mlog<span class=\"x x-first x-last\"> </span>tmp, then do upgrading</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-c\"><span class=\"pl-c\">//</span> if both old mlog<span class=\"x x-first x-last\">.txt</span> and mlog.<span class=\"x x-first x-last\">bin.</span>tmp exist, delete mlog<span class=\"x x-first x-last\">.bin.</span>tmp, then do upgrading</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "qiaojialin", "createdAt": "2020-09-14T09:35:43Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+\n+    if (oldLogFile.exists()) {\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n+        OldMLogReader oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n+        // upgrade from old character log file to new binary mlog\n+        while (oldMLogReader.hasNext()) {\n+          String cmd = oldMLogReader.next();\n+          try {\n+            mLogWriter.operation(cmd);\n+          } catch (MetadataException e) {\n+            logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n+          }\n+        }\n+\n+        return;\n+      }\n+    }\n+\n+    // if both old mlog and mlog.tmp do not exist, nothing to do\n+    if (!logFile.exists() && !tmpLogFile.exists()) {\n+      return;\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old mlog doesn't exist but mlog.tmp exists, rename tmp file to mlog\n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+      return;\n+    }\n+\n+    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -222,36 +222,45 @@ public class MLogWriter implements AutoCloseable {\n \n     if (oldLogFile.exists()) {\n       try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n-        OldMLogReader oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n+        MLogTxtReader MLogTxtReader = new MLogTxtReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n         // upgrade from old character log file to new binary mlog\n-        while (oldMLogReader.hasNext()) {\n-          String cmd = oldMLogReader.next();\n+        while (MLogTxtReader.hasNext()) {\n+          String cmd = MLogTxtReader.next();\n           try {\n             mLogWriter.operation(cmd);\n           } catch (MetadataException e) {\n             logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n           }\n         }\n-\n-        return;\n       }\n-    }\n-\n-    // if both old mlog and mlog.tmp do not exist, nothing to do\n-    if (!logFile.exists() && !tmpLogFile.exists()) {\n-      return;\n+    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n+      // if both old mlog.bin and mlog.bin.tmp do not exist, nothing to do\n     } else if (!logFile.exists() && tmpLogFile.exists()) {\n-      // if old mlog doesn't exist but mlog.tmp exists, rename tmp file to mlog\n+      // if old mlog.bin doesn't exist but mlog.bin.tmp exists, rename tmp file to mlog\n       FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n-      return;\n-    }\n-\n-    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n-    if (tmpLogFile.exists()) {\n+    } else if (tmpLogFile.exists()) {\n+      // if both old mlog.bin and mlog.bin.tmp exist, delete mlog.bin.tmp\n       if (!tmpLogFile.delete()) {\n         throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n       }\n     }\n+\n+    // do some clean job\n+\n+    // remove old mlog.txt and mlog.txt.tmp\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n+\n+    if (oldLogFile.exists() && !oldLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt \" + oldLogFile + \"failed.\");\n+    }\n+\n+    if (tmpLogFile.exists() && !tmpLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldLogFile + \"failed.\");\n+    }\n+\n+    // rename mlog.bin.tmp to mlog.bin\n+    FileUtils.moveFile(tmpLogFile, logFile);\n   }\n \n   public void clear() throws IOException {\n", "next_change": {"commit": "7a5ad6d7312a641efad62a814f07be5ce4aade56", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -214,53 +224,63 @@ public class MLogWriter implements AutoCloseable {\n     }\n   }\n \n-  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n-    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n+                                     String newFileName, boolean isSnapshot) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n     File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n     File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n-        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+      schemaDir + File.separator + oldFileName);\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n+\n+    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n \n-    if (oldLogFile.exists()) {\n-      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n-        MLogTxtReader MLogTxtReader = new MLogTxtReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n+      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n+        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n+      }\n+\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n+           MLogTxtReader MLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n         // upgrade from old character log file to new binary mlog\n         while (MLogTxtReader.hasNext()) {\n           String cmd = MLogTxtReader.next();\n           try {\n-            mLogWriter.operation(cmd);\n+            mLogWriter.operation(cmd, isSnapshot);\n           } catch (MetadataException e) {\n             logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n           }\n         }\n       }\n     } else if (!logFile.exists() && !tmpLogFile.exists()) {\n-      // if both old mlog.bin and mlog.bin.tmp do not exist, nothing to do\n+      // if both .bin and .bin.tmp do not exist, nothing to do\n     } else if (!logFile.exists() && tmpLogFile.exists()) {\n-      // if old mlog.bin doesn't exist but mlog.bin.tmp exists, rename tmp file to mlog\n+      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n       FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n     } else if (tmpLogFile.exists()) {\n-      // if both old mlog.bin and mlog.bin.tmp exist, delete mlog.bin.tmp\n+      // if both .bin and .bin.tmp exist, delete .bin.tmp\n       if (!tmpLogFile.delete()) {\n         throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n       }\n     }\n \n     // do some clean job\n-\n-    // remove old mlog.txt and mlog.txt.tmp\n-    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n-      + \".tmp\");\n-\n+    // remove old .txt and .txt.tmp\n     if (oldLogFile.exists() && !oldLogFile.delete()) {\n       throw new IOException(\"Deleting old mlog.txt \" + oldLogFile + \"failed.\");\n     }\n \n-    if (tmpLogFile.exists() && !tmpLogFile.delete()) {\n+    if (tmpOldLogFile.exists() && !tmpOldLogFile.delete()) {\n       throw new IOException(\"Deleting old mlog.txt.tmp \" + oldLogFile + \"failed.\");\n     }\n \n-    // rename mlog.bin.tmp to mlog.bin\n-    FileUtils.moveFile(tmpLogFile, logFile);\n+    // rename .bin.tmp to .bin\n+    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+  }\n+\n+  public static void upgradeMLog() throws IOException {\n+    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n+    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n+    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n   }\n \n   public void clear() throws IOException {\n", "next_change": {"commit": "18bb0557753e46238c0a17cd131af13a072eb09c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -287,10 +286,8 @@ public class MLogWriter implements AutoCloseable {\n     sync();\n     logWriter.close();\n     mlogBuffer.clear();\n-    if (logFile != null) {\n-      if (logFile.exists()) {\n-        Files.delete(logFile.toPath());\n-      }\n+    if (logFile != null && logFile.exists()) {\n+      Files.delete(logFile.toPath());\n     }\n     logNum = 0;\n     logWriter = new LogWriter(logFile, 0L);\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -221,73 +210,68 @@ public class MLogWriter implements AutoCloseable {\n       putLog(plan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        LOG_TOO_LARGE_INFO, e);\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n     }\n   }\n \n-  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n-                                     String newFileName, boolean isSnapshot) throws IOException {\n-    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n+  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n     File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n     File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n-      schemaDir + File.separator + oldFileName);\n-    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n-      + \".tmp\");\n-\n-    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n+        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n \n-      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n-        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n-      }\n-\n-      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n-           MLogTxtReader mLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n+    if (oldLogFile.exists()) {\n+      MLogWriter mLogWriter = null;\n+      OldMLogReader oldMLogReader = null;\n+      try {\n         // upgrade from old character log file to new binary mlog\n-        while (mLogTxtReader.hasNext()) {\n-          String cmd = mLogTxtReader.next();\n+        mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n+        oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG);\n+        while (oldMLogReader.hasNext()) {\n+          String cmd = oldMLogReader.next();\n           try {\n-            mLogWriter.operation(cmd, isSnapshot);\n+            mLogWriter.operation(cmd);\n           } catch (MetadataException e) {\n             logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n           }\n         }\n+\n+        return;\n+      } finally {\n+        if (mLogWriter != null) {\n+          mLogWriter.close();\n+        }\n+        if (oldMLogReader != null) {\n+          oldMLogReader.close();\n+        }\n       }\n-    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n-      // if both .bin and .bin.tmp do not exist, nothing to do\n-    } else if (!logFile.exists() && tmpLogFile.exists()) {\n-      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n-      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n-    } else if (tmpLogFile.exists() && !tmpLogFile.delete()) {\n-      // if both .bin and .bin.tmp exist, delete .bin.tmp\n-      throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n     }\n \n-    // do some clean job\n-    // remove old .txt and .txt.tmp\n-    if (oldLogFile.exists() && !oldLogFile.delete()) {\n-      throw new IOException(\"Deleting old mlog.txt \" + oldLogFile + \"failed.\");\n+    // if both old mlog and mlog.tmp do not exist, nothing to do\n+    if (!logFile.exists() && !tmpLogFile.exists()) {\n+      return;\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old mlog doesn't exsit but mlog.tmp exists, rename tmp file to mlog  \n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+      return;\n     }\n \n-    if (tmpOldLogFile.exists() && !tmpOldLogFile.delete()) {\n-      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldLogFile + \"failed.\");\n+    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n+    if (tmpLogFile.exists()) {\n+      if (!tmpLogFile.delete()) {\n+        throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n+      }\n     }\n-\n-    // rename .bin.tmp to .bin\n-    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n-  }\n-\n-  public static void upgradeMLog() throws IOException {\n-    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n-    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n-    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n   }\n \n   public void clear() throws IOException {\n     sync();\n     logWriter.close();\n     mlogBuffer.clear();\n-    if (logFile != null && logFile.exists()) {\n-      Files.delete(logFile.toPath());\n+    if (logFile != null) {\n+      if (logFile.exists()) {\n+        Files.delete(logFile.toPath());\n+      }\n     }\n     logNum = 0;\n     logWriter = new LogWriter(logFile, 0L);\n", "next_change": {"commit": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -210,68 +221,73 @@ public class MLogWriter {\n       putLog(plan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+        LOG_TOO_LARGE_INFO, e);\n     }\n   }\n \n-  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n-    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n+                                     String newFileName, boolean isSnapshot) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n     File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n     File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n-        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+      schemaDir + File.separator + oldFileName);\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n \n-    if (oldLogFile.exists()) {\n-      MLogWriter mLogWriter = null;\n-      OldMLogReader oldMLogReader = null;\n-      try {\n+    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n+\n+      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n+        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n+      }\n+\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n+           MLogTxtReader mLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n         // upgrade from old character log file to new binary mlog\n-        mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n-        oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG);\n-        while (oldMLogReader.hasNext()) {\n-          String cmd = oldMLogReader.next();\n+        while (mLogTxtReader.hasNext()) {\n+          String cmd = mLogTxtReader.next();\n           try {\n-            mLogWriter.operation(cmd);\n+            mLogWriter.operation(cmd, isSnapshot);\n           } catch (MetadataException e) {\n             logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n           }\n         }\n-\n-        return;\n-      } finally {\n-        if (mLogWriter != null) {\n-          mLogWriter.close();\n-        }\n-        if (oldMLogReader != null) {\n-          oldMLogReader.close();\n-        }\n       }\n-    }\n-\n-    // if both old mlog and mlog.tmp do not exist, nothing to do\n-    if (!logFile.exists() && !tmpLogFile.exists()) {\n-      return;\n+    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp do not exist, nothing to do\n     } else if (!logFile.exists() && tmpLogFile.exists()) {\n-      // if old mlog doesn't exsit but mlog.tmp exists, rename tmp file to mlog  \n+      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n       FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n-      return;\n+    } else if (tmpLogFile.exists() && !tmpLogFile.delete()) {\n+      // if both .bin and .bin.tmp exist, delete .bin.tmp\n+      throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n     }\n \n-    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n-    if (tmpLogFile.exists()) {\n-      if (!tmpLogFile.delete()) {\n-        throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n-      }\n+    // do some clean job\n+    // remove old .txt and .txt.tmp\n+    if (oldLogFile.exists() && !oldLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt \" + oldLogFile + \"failed.\");\n     }\n+\n+    if (tmpOldLogFile.exists() && !tmpOldLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldLogFile + \"failed.\");\n+    }\n+\n+    // rename .bin.tmp to .bin\n+    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+  }\n+\n+  public static void upgradeMLog() throws IOException {\n+    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n+    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n+    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n   }\n \n   public void clear() throws IOException {\n     sync();\n     logWriter.close();\n     mlogBuffer.clear();\n-    if (logFile != null) {\n-      if (logFile.exists()) {\n-        Files.delete(logFile.toPath());\n-      }\n+    if (logFile != null && logFile.exists()) {\n+      Files.delete(logFile.toPath());\n     }\n     logNum = 0;\n     logWriter = new LogWriter(logFile, 0L);\n", "next_change": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..7d1522fef9 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -290,7 +305,7 @@ public class MLogWriter implements AutoCloseable {\n       Files.delete(logFile.toPath());\n     }\n     logNum = 0;\n-    logWriter = new LogWriter(logFile, 0L);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n   }\n \n   public int getLogNum() {\n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 7d1522fef9..9fea13282d 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -305,7 +303,7 @@ public class MLogWriter implements AutoCloseable {\n       Files.delete(logFile.toPath());\n     }\n     logNum = 0;\n-    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+    logWriter = new LogWriter(logFile, false);\n   }\n \n   public int getLogNum() {\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NTY3NQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487785675", "body": "How about puting the offset to the CreateTimeseriesPlan", "bodyText": "How about puting the offset to the CreateTimeseriesPlan", "bodyHTML": "<p dir=\"auto\">How about puting the offset to the CreateTimeseriesPlan</p>", "author": "qiaojialin", "createdAt": "2020-09-14T09:46:26Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwNTQzMw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r489105433", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-09-16T01:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NTY3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -101,11 +103,9 @@ public class MLogWriter implements AutoCloseable {\n     logNum ++;\n   }\n \n-  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+  public void createTimeseries(CreateTimeSeriesPlan createTimeSeriesPlan) throws IOException {\n     try {\n-      putLog(plan);\n-      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n-      putLog(changeTagOffsetPlan);\n+      putLog(createTimeSeriesPlan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n         \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n", "next_change": {"commit": "18bb0557753e46238c0a17cd131af13a072eb09c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -108,7 +119,7 @@ public class MLogWriter implements AutoCloseable {\n       putLog(createTimeSeriesPlan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+        LOG_TOO_LARGE_INFO, e);\n     }\n   }\n \n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -105,21 +89,26 @@ public class MLogWriter implements AutoCloseable {\n   }\n \n   private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n     try {\n       plan.serialize(mlogBuffer);\n-      sync();\n-      logNum ++;\n     } catch (BufferOverflowException e) {\n-      logger.warn(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n     }\n+    logNum ++;\n   }\n \n-  public void createTimeseries(CreateTimeSeriesPlan createTimeSeriesPlan) throws IOException {\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n     try {\n-      putLog(createTimeSeriesPlan);\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        LOG_TOO_LARGE_INFO, e);\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n     }\n   }\n \n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -101,11 +103,9 @@ public class MLogWriter {\n     logNum ++;\n   }\n \n-  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+  public void createTimeseries(CreateTimeSeriesPlan createTimeSeriesPlan) throws IOException {\n     try {\n-      putLog(plan);\n-      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n-      putLog(changeTagOffsetPlan);\n+      putLog(createTimeSeriesPlan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n         \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n", "next_change": {"commit": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -108,7 +119,7 @@ public class MLogWriter implements AutoCloseable {\n       putLog(createTimeSeriesPlan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+        LOG_TOO_LARGE_INFO, e);\n     }\n   }\n \n", "next_change": null}]}}]}}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -128,7 +117,7 @@ public class MLogWriter implements AutoCloseable {\n       putLog(deleteTimeSeriesPlan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        LOG_TOO_LARGE_INFO, e);\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n     }\n   }\n \n", "next_change": {"commit": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -117,7 +128,7 @@ public class MLogWriter {\n       putLog(deleteTimeSeriesPlan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+        LOG_TOO_LARGE_INFO, e);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NjY1Mg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487786652", "body": "This is not used", "bodyText": "This is not used", "bodyHTML": "<p dir=\"auto\">This is not used</p>", "author": "qiaojialin", "createdAt": "2020-09-14T09:48:01Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+\n+    if (oldLogFile.exists()) {\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n+        OldMLogReader oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n+        // upgrade from old character log file to new binary mlog\n+        while (oldMLogReader.hasNext()) {\n+          String cmd = oldMLogReader.next();\n+          try {\n+            mLogWriter.operation(cmd);\n+          } catch (MetadataException e) {\n+            logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n+          }\n+        }\n+\n+        return;\n+      }\n+    }\n+\n+    // if both old mlog and mlog.tmp do not exist, nothing to do\n+    if (!logFile.exists() && !tmpLogFile.exists()) {\n+      return;\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old mlog doesn't exist but mlog.tmp exists, rename tmp file to mlog\n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+      return;\n+    }\n+\n+    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n+    if (tmpLogFile.exists()) {\n+      if (!tmpLogFile.delete()) {\n+        throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n+      }\n+    }\n+  }\n+\n+  public void clear() throws IOException {\n+    sync();\n+    logWriter.close();\n+    mlogBuffer.clear();\n+    if (logFile != null) {\n+      if (logFile.exists()) {\n+        Files.delete(logFile.toPath());\n+      }\n+    }\n+    logNum = 0;\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public int getLogNum() {\n+    return logNum;\n+  }\n+\n+  /**\n+   * only used for initialize a mlog file writer.\n+   */\n+  public void setLogNum(int number) {\n+    logNum = number;\n+  }\n+\n+  public void operation(String cmd) throws IOException, MetadataException {\n+    // see createTimeseries() to get the detailed format of the cmd\n+    String[] args = cmd.trim().split(\",\", -1);\n+    switch (args[0]) {\n+      case MetadataOperationType.CREATE_TIMESERIES:\n+        Map<String, String> props = null;\n+        if (!args[5].isEmpty()) {\n+          String[] keyValues = args[5].split(\"&\");\n+          String[] kv;\n+          props = new HashMap<>();\n+          for (String keyValue : keyValues) {\n+            kv = keyValue.split(\"=\");\n+            props.put(kv[0], kv[1]);\n+          }\n+        }\n+\n+        String alias = null;\n+        if (!args[6].isEmpty()) {\n+          alias = args[6];\n+        }\n+        long offset = -1L;\n+        Map<String, String> tagMap = null;", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -299,7 +314,6 @@ public class MLogWriter implements AutoCloseable {\n           alias = args[6];\n         }\n         long offset = -1L;\n-        Map<String, String> tagMap = null;\n         if (!args[7].isEmpty()) {\n           offset = Long.parseLong(args[7]);\n         }\n", "next_change": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..17d4c936dc 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -319,25 +380,36 @@ public class MLogWriter implements AutoCloseable {\n         }\n \n         CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan(new PartialPath(args[1]),\n-            TSDataType.deserialize(Short.parseShort(args[2])),\n-            TSEncoding.deserialize(Short.parseShort(args[3])),\n-            CompressionType.deserialize(Short.parseShort(args[4])), props, null, null, alias);\n-        plan.setTagOffset(offset);\n+          TSDataType.deserialize(Short.parseShort(args[2])),\n+          TSEncoding.deserialize(Short.parseShort(args[3])),\n+          CompressionType.deserialize(Short.parseShort(args[4])), props, null, null, alias);\n \n+        plan.setTagOffset(offset);\n         createTimeseries(plan);\n         break;\n       case MetadataOperationType.DELETE_TIMESERIES:\n-        DeleteTimeSeriesPlan deleteTimeSeriesPlan =\n-            new DeleteTimeSeriesPlan(Collections.singletonList(new PartialPath(args[1])));\n-        deleteTimeseries(deleteTimeSeriesPlan);\n+        if (args.length > 2) {\n+          StringBuilder tmp = new StringBuilder();\n+          for (int i = 1; i < args.length - 1; i++) {\n+            tmp.append(args[i]).append(\",\");\n+          }\n+          tmp.append(args[args.length - 1]);\n+          args[1] = tmp.toString();\n+        }\n+        deleteTimeseries(new DeleteTimeSeriesPlan(Collections.singletonList(new PartialPath(args[1]))));\n         break;\n       case MetadataOperationType.SET_STORAGE_GROUP:\n-        setStorageGroup(new PartialPath(args[1]));\n+        try {\n+          setStorageGroup(new PartialPath(args[1]));\n+        }\n+        // two time series may set one storage group concurrently,\n+        // that's normal in our concurrency control protocol\n+        catch (MetadataException e){\n+          logger.info(\"concurrently operate set storage group cmd {} twice\", cmd);\n+        }\n         break;\n       case MetadataOperationType.DELETE_STORAGE_GROUP:\n-        for(int i = 1; i <= args.length; i++) {\n-          deleteStorageGroup(new PartialPath(args[i]));\n-        }\n+        deleteStorageGroup(new PartialPath(args[1]));\n         break;\n       case MetadataOperationType.SET_TTL:\n         setTTL(new PartialPath(args[1]), Long.parseLong(args[2]));\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 17d4c936dc..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -375,41 +309,30 @@ public class MLogWriter implements AutoCloseable {\n           alias = args[6];\n         }\n         long offset = -1L;\n+        Map<String, String> tagMap = null;\n         if (!args[7].isEmpty()) {\n           offset = Long.parseLong(args[7]);\n         }\n \n         CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan(new PartialPath(args[1]),\n-          TSDataType.deserialize(Short.parseShort(args[2])),\n-          TSEncoding.deserialize(Short.parseShort(args[3])),\n-          CompressionType.deserialize(Short.parseShort(args[4])), props, null, null, alias);\n+            TSDataType.deserialize(Short.parseShort(args[2])),\n+            TSEncoding.deserialize(Short.parseShort(args[3])),\n+            CompressionType.deserialize(Short.parseShort(args[4])), props, null, null, alias);\n \n-        plan.setTagOffset(offset);\n-        createTimeseries(plan);\n+        createTimeseries(plan, offset);\n         break;\n       case MetadataOperationType.DELETE_TIMESERIES:\n-        if (args.length > 2) {\n-          StringBuilder tmp = new StringBuilder();\n-          for (int i = 1; i < args.length - 1; i++) {\n-            tmp.append(args[i]).append(\",\");\n-          }\n-          tmp.append(args[args.length - 1]);\n-          args[1] = tmp.toString();\n-        }\n-        deleteTimeseries(new DeleteTimeSeriesPlan(Collections.singletonList(new PartialPath(args[1]))));\n+        DeleteTimeSeriesPlan deleteTimeSeriesPlan =\n+            new DeleteTimeSeriesPlan(Collections.singletonList(new PartialPath(args[1])));\n+        deleteTimeseries(deleteTimeSeriesPlan);\n         break;\n       case MetadataOperationType.SET_STORAGE_GROUP:\n-        try {\n-          setStorageGroup(new PartialPath(args[1]));\n-        }\n-        // two time series may set one storage group concurrently,\n-        // that's normal in our concurrency control protocol\n-        catch (MetadataException e){\n-          logger.info(\"concurrently operate set storage group cmd {} twice\", cmd);\n-        }\n+        setStorageGroup(new PartialPath(args[1]));\n         break;\n       case MetadataOperationType.DELETE_STORAGE_GROUP:\n-        deleteStorageGroup(new PartialPath(args[1]));\n+        for(int i = 1; i <= args.length; i++) {\n+          deleteStorageGroup(new PartialPath(args[i]));\n+        }\n         break;\n       case MetadataOperationType.SET_TTL:\n         setTTL(new PartialPath(args[1]), Long.parseLong(args[2]));\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..322c5d1e09 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -309,30 +376,41 @@ public class MLogWriter {\n           alias = args[6];\n         }\n         long offset = -1L;\n-        Map<String, String> tagMap = null;\n         if (!args[7].isEmpty()) {\n           offset = Long.parseLong(args[7]);\n         }\n \n         CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan(new PartialPath(args[1]),\n-            TSDataType.deserialize(Short.parseShort(args[2])),\n-            TSEncoding.deserialize(Short.parseShort(args[3])),\n-            CompressionType.deserialize(Short.parseShort(args[4])), props, null, null, alias);\n+          TSDataType.deserialize(Short.parseShort(args[2])),\n+          TSEncoding.deserialize(Short.parseShort(args[3])),\n+          CompressionType.deserialize(Short.parseShort(args[4])), props, null, null, alias);\n \n-        createTimeseries(plan, offset);\n+        plan.setTagOffset(offset);\n+        createTimeseries(plan);\n         break;\n       case MetadataOperationType.DELETE_TIMESERIES:\n-        DeleteTimeSeriesPlan deleteTimeSeriesPlan =\n-            new DeleteTimeSeriesPlan(Collections.singletonList(new PartialPath(args[1])));\n-        deleteTimeseries(deleteTimeSeriesPlan);\n+        if (args.length > 2) {\n+          StringBuilder tmp = new StringBuilder();\n+          for (int i = 1; i < args.length - 1; i++) {\n+            tmp.append(args[i]).append(\",\");\n+          }\n+          tmp.append(args[args.length - 1]);\n+          args[1] = tmp.toString();\n+        }\n+        deleteTimeseries(new DeleteTimeSeriesPlan(Collections.singletonList(new PartialPath(args[1]))));\n         break;\n       case MetadataOperationType.SET_STORAGE_GROUP:\n-        setStorageGroup(new PartialPath(args[1]));\n+        try {\n+          setStorageGroup(new PartialPath(args[1]));\n+        }\n+        // two time series may set one storage group concurrently,\n+        // that's normal in our concurrency control protocol\n+        catch (MetadataException e){\n+          logger.info(\"concurrently operate set storage group cmd {} twice\", cmd);\n+        }\n         break;\n       case MetadataOperationType.DELETE_STORAGE_GROUP:\n-        for(int i = 1; i <= args.length; i++) {\n-          deleteStorageGroup(new PartialPath(args[i]));\n-        }\n+        deleteStorageGroup(new PartialPath(args[1]));\n         break;\n       case MetadataOperationType.SET_TTL:\n         setTTL(new PartialPath(args[1]), Long.parseLong(args[2]));\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgxNjM0OQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487816349", "body": "Are these codes duplicated with MLogWriter.upgrade() ? Maybe puting them to MLogWriter.upgrade() is better.", "bodyText": "Are these codes duplicated with MLogWriter.upgrade() ? Maybe puting them to MLogWriter.upgrade() is better.", "bodyHTML": "<p dir=\"auto\">Are these codes duplicated with MLogWriter.upgrade() ? Maybe puting them to MLogWriter.upgrade() is better.</p>", "author": "qiaojialin", "createdAt": "2020-09-14T10:40:21Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -186,59 +186,34 @@ public void checkConfig() throws IOException {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // need to upgrade from 0.9 to 0.10\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      checkUnClosedTsFileV1();\n-      MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n-      upgradePropertiesFile();\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-          + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n+\n+    // upgrade from mlog.txt to mlog.bin\n+    MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n+    // finish upgrade, remove old mlog.txt and mlog.txt.tmp\n+    File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+      + MetadataConstant.METADATA_OLD_LOG);\n+    File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(oldMLogFile.getAbsolutePath()\n+      + \".tmp\");\n+\n+    if (!oldMLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt \" + oldMLogFile + \"failed.\");\n     }\n-    checkProperties();\n-  }\n \n-  /**\n-   * upgrade 0.9 properties to 0.10 properties\n-   */\n-  private void upgradePropertiesFile()\n-      throws IOException {\n-    // create an empty tmpPropertiesFile\n-    if (tmpPropertiesFile.createNewFile()) {\n-      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n-    } else {\n-      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n-      System.exit(-1);\n+    if (!tmpMLogFile.delete()) {\n+      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldMLogFile + \"failed.\");\n     }\n \n-    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n-      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n-      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n-      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n-      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n-      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n-      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n-      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+    // move mlog.bin.tmp to mlog.bin\n+    File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+      + MetadataConstant.METADATA_LOG);\n+    tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n+      + \".tmp\");\n+    // rename tmpLogFile to mlog\n+    FileUtils.moveFile(tmpMLogFile, mlogFile);", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 23b680251b..05bb3090cb 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -189,27 +189,6 @@ public class IoTDBConfigCheck {\n \n     // upgrade from mlog.txt to mlog.bin\n     MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n-    // finish upgrade, remove old mlog.txt and mlog.txt.tmp\n-    File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-      + MetadataConstant.METADATA_OLD_LOG);\n-    File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(oldMLogFile.getAbsolutePath()\n-      + \".tmp\");\n-\n-    if (!oldMLogFile.delete()) {\n-      throw new IOException(\"Deleting old mlog.txt \" + oldMLogFile + \"failed.\");\n-    }\n-\n-    if (!tmpMLogFile.delete()) {\n-      throw new IOException(\"Deleting old mlog.txt.tmp \" + oldMLogFile + \"failed.\");\n-    }\n-\n-    // move mlog.bin.tmp to mlog.bin\n-    File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-      + MetadataConstant.METADATA_LOG);\n-    tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-      + \".tmp\");\n-    // rename tmpLogFile to mlog\n-    FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n     checkProperties();\n   }\n", "next_change": {"commit": "df0282f1249629b08e83f6e465ac060ff3864a00", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 05bb3090cb..74737a45a4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -186,6 +186,31 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n+    // check whether upgrading from v0.9 to v0.11\n+    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n+          + \" Please upgrade to v0.10 first\");\n+      System.exit(-1);\n+    }\n+    // check whether upgrading from v0.10 to v0.11\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n+      checkUnClosedTsFileV2();\n+      upgradePropertiesFile();\n+      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n+\n+      // upgrade mlog finished, delete old mlog file\n+      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+        + MetadataConstant.METADATA_LOG);\n+      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n+        + \".tmp\");\n+\n+      if (!mlogFile.delete()) {\n+        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n+      }\n+      // rename tmpLogFile to mlog\n+      FileUtils.moveFile(tmpMLogFile, mlogFile);\n+    }\n \n     // upgrade from mlog.txt to mlog.bin\n     MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n", "next_change": {"commit": "7a5ad6d7312a641efad62a814f07be5ce4aade56", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 74737a45a4..3e2d54572c 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -186,34 +185,14 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.11\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n-          + \" Please upgrade to v0.10 first\");\n+    // check whether upgrading from v0.9 to v0.12\n+    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n+      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n+          + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n-    // check whether upgrading from v0.10 to v0.11\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n-      checkUnClosedTsFileV2();\n-      upgradePropertiesFile();\n-      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-        + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-        + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n-    }\n-\n-    // upgrade from mlog.txt to mlog.bin\n-    MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n+    MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n", "next_change": {"commit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 3e2d54572c..0ca9b49734 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -197,37 +197,6 @@ public class IoTDBConfigCheck {\n     checkProperties();\n   }\n \n-  /**\n-   * upgrade 0.10 properties to 0.11 properties\n-   */\n-  private void upgradePropertiesFile()\n-      throws IOException {\n-    // create an empty tmpPropertiesFile\n-    if (tmpPropertiesFile.createNewFile()) {\n-      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n-    } else {\n-      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n-      System.exit(-1);\n-    }\n-\n-    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n-      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n-      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n-      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n-      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n-      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n-      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n-      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n-\n-      // upgrade finished, delete old system.properties file\n-      if (propertiesFile.exists()) {\n-        Files.delete(propertiesFile.toPath());\n-      }\n-    }\n-    // rename system.properties.tmp to system.properties\n-    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n-  }\n-\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 0ca9b49734..be1689ec8e 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -197,6 +197,37 @@ public class IoTDBConfigCheck {\n     checkProperties();\n   }\n \n+  /**\n+   * upgrade 0.10 properties to 0.11 properties\n+   */\n+  private void upgradePropertiesFile()\n+    throws IOException {\n+    // create an empty tmpPropertiesFile\n+    if (tmpPropertiesFile.createNewFile()) {\n+      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n+    } else {\n+      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n+      System.exit(-1);\n+    }\n+\n+    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n+      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n+      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n+      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n+      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n+      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n+      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n+      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+\n+      // upgrade finished, delete old system.properties file\n+      if (propertiesFile.exists()) {\n+        Files.delete(propertiesFile.toPath());\n+      }\n+    }\n+    // rename system.properties.tmp to system.properties\n+    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n+  }\n+\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex be1689ec8e..d00a287f5a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -229,6 +231,8 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n+=======\n+>>>>>>> 614e18466 (fix some snoar warn)\n    * repair 0.10 properties\n    */\n   private void upgradePropertiesFileFromBrokenFile()\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex d00a287f5a..9db3407287 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -231,8 +230,6 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n-=======\n->>>>>>> 614e18466 (fix some snoar warn)\n    * repair 0.10 properties\n    */\n   private void upgradePropertiesFileFromBrokenFile()\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 05bb3090cb..74737a45a4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -193,6 +218,37 @@ public class IoTDBConfigCheck {\n     checkProperties();\n   }\n \n+  /**\n+   * upgrade 0.10 properties to 0.11 properties\n+   */\n+  private void upgradePropertiesFile()\n+      throws IOException {\n+    // create an empty tmpPropertiesFile\n+    if (tmpPropertiesFile.createNewFile()) {\n+      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n+    } else {\n+      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n+      System.exit(-1);\n+    }\n+\n+    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n+      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n+      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n+      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n+      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n+      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n+      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n+      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+\n+      // upgrade finished, delete old system.properties file\n+      if (propertiesFile.exists()) {\n+        Files.delete(propertiesFile.toPath());\n+      }\n+    }\n+    // rename system.properties.tmp to system.properties\n+    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n+  }\n+\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 74737a45a4..0ca9b49734 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -186,69 +185,18 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.11\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n-          + \" Please upgrade to v0.10 first\");\n+    // check whether upgrading from v0.9 to v0.12\n+    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n+      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n+          + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n-    // check whether upgrading from v0.10 to v0.11\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n-      checkUnClosedTsFileV2();\n-      upgradePropertiesFile();\n-      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-        + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-        + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n-    }\n-\n-    // upgrade from mlog.txt to mlog.bin\n-    MLogWriter.upgradeMLog(SCHEMA_DIR, MetadataConstant.METADATA_LOG);\n+    MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n \n-  /**\n-   * upgrade 0.10 properties to 0.11 properties\n-   */\n-  private void upgradePropertiesFile()\n-      throws IOException {\n-    // create an empty tmpPropertiesFile\n-    if (tmpPropertiesFile.createNewFile()) {\n-      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n-    } else {\n-      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n-      System.exit(-1);\n-    }\n-\n-    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n-      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n-      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n-      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n-      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n-      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n-      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n-      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n-\n-      // upgrade finished, delete old system.properties file\n-      if (propertiesFile.exists()) {\n-        Files.delete(propertiesFile.toPath());\n-      }\n-    }\n-    // rename system.properties.tmp to system.properties\n-    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n-  }\n-\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 0ca9b49734..be1689ec8e 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -197,6 +197,37 @@ public class IoTDBConfigCheck {\n     checkProperties();\n   }\n \n+  /**\n+   * upgrade 0.10 properties to 0.11 properties\n+   */\n+  private void upgradePropertiesFile()\n+    throws IOException {\n+    // create an empty tmpPropertiesFile\n+    if (tmpPropertiesFile.createNewFile()) {\n+      logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n+    } else {\n+      logger.error(\"Create system.properties.tmp {} failed.\", tmpPropertiesFile);\n+      System.exit(-1);\n+    }\n+\n+    try (FileOutputStream tmpFOS = new FileOutputStream(tmpPropertiesFile.toString())) {\n+      properties.setProperty(PARTITION_INTERVAL_STRING, String.valueOf(partitionInterval));\n+      properties.setProperty(TSFILE_FILE_SYSTEM_STRING, tsfileFileSystem);\n+      properties.setProperty(IOTDB_VERSION_STRING, IoTDBConstant.VERSION);\n+      properties.setProperty(ENABLE_PARTITION_STRING, String.valueOf(enablePartition));\n+      properties.setProperty(TAG_ATTRIBUTE_SIZE_STRING, tagAttributeTotalSize);\n+      properties.setProperty(MAX_DEGREE_OF_INDEX_STRING, maxDegreeOfIndexNode);\n+      properties.store(tmpFOS, SYSTEM_PROPERTIES_STRING);\n+\n+      // upgrade finished, delete old system.properties file\n+      if (propertiesFile.exists()) {\n+        Files.delete(propertiesFile.toPath());\n+      }\n+    }\n+    // rename system.properties.tmp to system.properties\n+    FileUtils.moveFile(tmpPropertiesFile, propertiesFile);\n+  }\n+\n   /**\n    * repair 0.10 properties\n    */\n", "next_change": {"commit": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex be1689ec8e..d00a287f5a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -229,6 +231,8 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n+=======\n+>>>>>>> 614e18466 (fix some snoar warn)\n    * repair 0.10 properties\n    */\n   private void upgradePropertiesFileFromBrokenFile()\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex d00a287f5a..9db3407287 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -231,8 +230,6 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n-=======\n->>>>>>> 614e18466 (fix some snoar warn)\n    * repair 0.10 properties\n    */\n   private void upgradePropertiesFileFromBrokenFile()\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyODEyMw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487828123", "body": "If we throw an IOException here, the user will get an empty MTree, they may feel \"lose their data\". I suggest catch all Exceptions when recovering MManager and recover mlog as much as possible. We could print an error stack and fix it later.", "bodyText": "If we throw an IOException here, the user will get an empty MTree, they may feel \"lose their data\". I suggest catch all Exceptions when recovering MManager and recover mlog as much as possible. We could print an error stack and fix it later.", "bodyHTML": "<p dir=\"auto\">If we throw an IOException here, the user will get an empty MTree, they may feel \"lose their data\". I suggest catch all Exceptions when recovering MManager and recover mlog as much as possible. We could print an error stack and fix it later.</p>", "author": "qiaojialin", "createdAt": "2020-09-14T11:03:20Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -248,21 +237,27 @@ private int initFromLog(File logFile) throws IOException {\n     // init the metadata from the operation log\n     if (logFile.exists()) {\n       int idx = 0;\n-      try (FileReader fr = new FileReader(logFile);\n-          BufferedReader br = new BufferedReader(fr)) {\n-        String cmd;\n-        while ((cmd = br.readLine()) != null) {\n+      try (MLogReader mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);) {\n+\n+        while (mLogReader.hasNext()) {\n+          PhysicalPlan plan = null;\n           try {\n-            operation(cmd);\n+            plan = mLogReader.next();\n+            if (plan == null) {\n+              continue;\n+            }\n+            operation(plan);\n             idx++;\n           } catch (Exception e) {\n-            logger.error(\"Can not operate cmd {}\", cmd, e);\n+            logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n           }\n         }\n+        logger.debug(\"spend {} ms to deserialize mtree from mlog.bin\",\n+            System.currentTimeMillis() - time);\n+        return idx;\n+      } catch (Exception e) {\n+        throw new IOException(\"Failed to parser mlog.bin for err:\" +  e.toString());", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwNTY3Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r489105676", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-09-16T01:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyODEyMw=="}], "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex b4812ce2ea..4854bef75c 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n", "chunk": "@@ -258,8 +265,6 @@ public class MManager {\n       } catch (Exception e) {\n         throw new IOException(\"Failed to parser mlog.bin for err:\" +  e.toString());\n       }\n-    } else if (mtreeSnapshot.exists()) {\n-      throw new IOException(\"mtree snapshot file exists but mlog.txt does not exist.\");\n     } else {\n       return 0;\n     }\n", "next_change": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex 4854bef75c..23f64db273 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n", "chunk": "@@ -270,17 +281,33 @@ public class MManager {\n     }\n   }\n \n+  private int applyMlog(MLogReader mLogReader) {\n+    int idx = 0;\n+    while (mLogReader.hasNext()) {\n+      PhysicalPlan plan = null;\n+      try {\n+        plan = mLogReader.next();\n+        if (plan == null) {\n+          continue;\n+        }\n+        operation(plan);\n+        idx++;\n+      } catch (Exception e) {\n+        logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n+      }\n+    }\n+    return idx;\n+  }\n+\n   /**\n    * function for clearing MTree\n    */\n   public void clear() {\n-    lock.writeLock().lock();\n     try {\n       this.mtree = new MTree();\n       this.mNodeCache.clear();\n       this.tagIndex.clear();\n-      this.seriesNumberInStorageGroups.clear();\n-      this.maxSeriesNumberAmongStorageGroup = 0;\n+      this.totalSeriesNumber.set(0);\n       if (logWriter != null) {\n         logWriter.close();\n         logWriter = null;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5OTY2OQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487899669", "body": "This is not an unusual case, no need to throw an exception. Please help to remove this.", "bodyText": "This is not an unusual case, no need to throw an exception. Please help to remove this.", "bodyHTML": "<p dir=\"auto\">This is not an unusual case, no need to throw an exception. Please help to remove this.</p>", "author": "qiaojialin", "createdAt": "2020-09-14T13:10:54Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -248,21 +237,27 @@ private int initFromLog(File logFile) throws IOException {\n     // init the metadata from the operation log\n     if (logFile.exists()) {\n       int idx = 0;\n-      try (FileReader fr = new FileReader(logFile);\n-          BufferedReader br = new BufferedReader(fr)) {\n-        String cmd;\n-        while ((cmd = br.readLine()) != null) {\n+      try (MLogReader mLogReader = new MLogReader(config.getSchemaDir(), MetadataConstant.METADATA_LOG);) {\n+\n+        while (mLogReader.hasNext()) {\n+          PhysicalPlan plan = null;\n           try {\n-            operation(cmd);\n+            plan = mLogReader.next();\n+            if (plan == null) {\n+              continue;\n+            }\n+            operation(plan);\n             idx++;\n           } catch (Exception e) {\n-            logger.error(\"Can not operate cmd {}\", cmd, e);\n+            logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n           }\n         }\n+        logger.debug(\"spend {} ms to deserialize mtree from mlog.bin\",\n+            System.currentTimeMillis() - time);\n+        return idx;\n+      } catch (Exception e) {\n+        throw new IOException(\"Failed to parser mlog.bin for err:\" +  e.toString());\n       }\n-      logger.debug(\"spend {} ms to deserialize mtree from mlog.txt\",\n-          System.currentTimeMillis() - time);\n-      return idx;\n     } else if (mtreeSnapshot.exists()) {\n       throw new IOException(\"mtree snapshot file exists but mlog.txt does not exist.\");", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex b4812ce2ea..4854bef75c 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n", "chunk": "@@ -258,8 +265,6 @@ public class MManager {\n       } catch (Exception e) {\n         throw new IOException(\"Failed to parser mlog.bin for err:\" +  e.toString());\n       }\n-    } else if (mtreeSnapshot.exists()) {\n-      throw new IOException(\"mtree snapshot file exists but mlog.txt does not exist.\");\n     } else {\n       return 0;\n     }\n", "next_change": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex 4854bef75c..23f64db273 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n", "chunk": "@@ -270,17 +281,33 @@ public class MManager {\n     }\n   }\n \n+  private int applyMlog(MLogReader mLogReader) {\n+    int idx = 0;\n+    while (mLogReader.hasNext()) {\n+      PhysicalPlan plan = null;\n+      try {\n+        plan = mLogReader.next();\n+        if (plan == null) {\n+          continue;\n+        }\n+        operation(plan);\n+        idx++;\n+      } catch (Exception e) {\n+        logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n+      }\n+    }\n+    return idx;\n+  }\n+\n   /**\n    * function for clearing MTree\n    */\n   public void clear() {\n-    lock.writeLock().lock();\n     try {\n       this.mtree = new MTree();\n       this.mNodeCache.clear();\n       this.tagIndex.clear();\n-      this.seriesNumberInStorageGroups.clear();\n-      this.maxSeriesNumberAmongStorageGroup = 0;\n+      this.totalSeriesNumber.set(0);\n       if (logWriter != null) {\n         logWriter.close();\n         logWriter = null;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNTEzOQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487905139", "body": "Add a javadoc indicating for an upgrade from mlog.txt", "bodyText": "Add a javadoc indicating for an upgrade from mlog.txt", "bodyHTML": "<p dir=\"auto\">Add a javadoc indicating for an upgrade from mlog.txt</p>", "author": "qiaojialin", "createdAt": "2020-09-14T13:19:05Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n+    }\n+    logNum ++;\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+    try {\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+    }\n+  }\n+\n+  public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+        schemaDir + File.separator + MetadataConstant.METADATA_OLD_LOG);\n+\n+    if (oldLogFile.exists()) {\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, logFileName + \".tmp\");\n+        OldMLogReader oldMLogReader = new OldMLogReader(schemaDir, MetadataConstant.METADATA_OLD_LOG)) {\n+        // upgrade from old character log file to new binary mlog\n+        while (oldMLogReader.hasNext()) {\n+          String cmd = oldMLogReader.next();\n+          try {\n+            mLogWriter.operation(cmd);\n+          } catch (MetadataException e) {\n+            logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n+          }\n+        }\n+\n+        return;\n+      }\n+    }\n+\n+    // if both old mlog and mlog.tmp do not exist, nothing to do\n+    if (!logFile.exists() && !tmpLogFile.exists()) {\n+      return;\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old mlog doesn't exist but mlog.tmp exists, rename tmp file to mlog\n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+      return;\n+    }\n+\n+    // if both old mlog and mlog.tmp exist, delete mlog tmp, then do upgrading\n+    if (tmpLogFile.exists()) {\n+      if (!tmpLogFile.delete()) {\n+        throw new IOException(\"Deleting \" + tmpLogFile + \"failed.\");\n+      }\n+    }\n+  }\n+\n+  public void clear() throws IOException {\n+    sync();\n+    logWriter.close();\n+    mlogBuffer.clear();\n+    if (logFile != null) {\n+      if (logFile.exists()) {\n+        Files.delete(logFile.toPath());\n+      }\n+    }\n+    logNum = 0;\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public int getLogNum() {\n+    return logNum;\n+  }\n+\n+  /**\n+   * only used for initialize a mlog file writer.\n+   */\n+  public void setLogNum(int number) {\n+    logNum = number;\n+  }\n+\n+  public void operation(String cmd) throws IOException, MetadataException {", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwNTczOQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r489105739", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-09-16T01:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNTEzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -278,6 +287,12 @@ public class MLogWriter implements AutoCloseable {\n     logNum = number;\n   }\n \n+  /**\n+   * upgrade from mlog.txt to mlog.bin\n+   * @param cmd, the old meta operation\n+   * @throws IOException\n+   * @throws MetadataException\n+   */\n   public void operation(String cmd) throws IOException, MetadataException {\n     // see createTimeseries() to get the detailed format of the cmd\n     String[] args = cmd.trim().split(\",\", -1);\n", "next_change": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..17d4c936dc 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -287,17 +317,48 @@ public class MLogWriter implements AutoCloseable {\n     logNum = number;\n   }\n \n+  public void operation(String cmd, boolean isSnapshot) throws IOException, MetadataException {\n+    if (!isSnapshot) {\n+      operation(cmd);\n+    } else {\n+      PhysicalPlan plan = convertFromString(cmd);\n+      try {\n+        if (plan != null) {\n+          putLog(plan);\n+        }\n+      } catch (BufferOverflowException e) {\n+        throw new IOException(\n+          LOG_TOO_LARGE_INFO, e);\n+      }\n+    }\n+  }\n+\n   /**\n    * upgrade from mlog.txt to mlog.bin\n    * @param cmd, the old meta operation\n    * @throws IOException\n    * @throws MetadataException\n    */\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public void operation(String cmd) throws IOException, MetadataException {\n     // see createTimeseries() to get the detailed format of the cmd\n     String[] args = cmd.trim().split(\",\", -1);\n     switch (args[0]) {\n       case MetadataOperationType.CREATE_TIMESERIES:\n+        if (args.length > 8) {\n+          String[] tmpArgs = new String[8];\n+          tmpArgs[0] = args[0];\n+          int i = 1;\n+          tmpArgs[1] = \"\";\n+          for (; i < args.length - 7; i++) {\n+            tmpArgs[1] += args[i] + \",\";\n+          }\n+          tmpArgs[1] += args[i++];\n+          for (int j = 2; j < 8; j++) {\n+            tmpArgs[j] = args[i++];\n+          }\n+          args = tmpArgs;\n+        }\n         Map<String, String> props = null;\n         if (!args[5].isEmpty()) {\n           String[] keyValues = args[5].split(\"&\");\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 17d4c936dc..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -317,48 +288,11 @@ public class MLogWriter implements AutoCloseable {\n     logNum = number;\n   }\n \n-  public void operation(String cmd, boolean isSnapshot) throws IOException, MetadataException {\n-    if (!isSnapshot) {\n-      operation(cmd);\n-    } else {\n-      PhysicalPlan plan = convertFromString(cmd);\n-      try {\n-        if (plan != null) {\n-          putLog(plan);\n-        }\n-      } catch (BufferOverflowException e) {\n-        throw new IOException(\n-          LOG_TOO_LARGE_INFO, e);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * upgrade from mlog.txt to mlog.bin\n-   * @param cmd, the old meta operation\n-   * @throws IOException\n-   * @throws MetadataException\n-   */\n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public void operation(String cmd) throws IOException, MetadataException {\n     // see createTimeseries() to get the detailed format of the cmd\n     String[] args = cmd.trim().split(\",\", -1);\n     switch (args[0]) {\n       case MetadataOperationType.CREATE_TIMESERIES:\n-        if (args.length > 8) {\n-          String[] tmpArgs = new String[8];\n-          tmpArgs[0] = args[0];\n-          int i = 1;\n-          tmpArgs[1] = \"\";\n-          for (; i < args.length - 7; i++) {\n-            tmpArgs[1] += args[i] + \",\";\n-          }\n-          tmpArgs[1] += args[i++];\n-          for (int j = 2; j < 8; j++) {\n-            tmpArgs[j] = args[i++];\n-          }\n-          args = tmpArgs;\n-        }\n         Map<String, String> props = null;\n         if (!args[5].isEmpty()) {\n           String[] keyValues = args[5].split(\"&\");\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..322c5d1e09 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -288,11 +319,47 @@ public class MLogWriter {\n     logNum = number;\n   }\n \n+  public void operation(String cmd, boolean isSnapshot) throws IOException, MetadataException {\n+    if (!isSnapshot) {\n+      operation(cmd);\n+    } else {\n+      PhysicalPlan plan = convertFromString(cmd);\n+      try {\n+        if (plan != null) {\n+          putLog(plan);\n+        }\n+      } catch (BufferOverflowException e) {\n+        throw new IOException(\n+          LOG_TOO_LARGE_INFO, e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * upgrade from mlog.txt to mlog.bin\n+   * @param cmd, the old meta operation\n+   * @throws IOException\n+   * @throws MetadataException\n+   */\n   public void operation(String cmd) throws IOException, MetadataException {\n     // see createTimeseries() to get the detailed format of the cmd\n     String[] args = cmd.trim().split(\",\", -1);\n     switch (args[0]) {\n       case MetadataOperationType.CREATE_TIMESERIES:\n+        if (args.length > 8) {\n+          String[] tmpArgs = new String[8];\n+          tmpArgs[0] = args[0];\n+          int i = 1;\n+          tmpArgs[1] = \"\";\n+          for (; i < args.length - 7; i++) {\n+            tmpArgs[1] += args[i] + \",\";\n+          }\n+          tmpArgs[1] += args[i++];\n+          for (int j = 2; j < 8; j++) {\n+            tmpArgs[j] = args[i++];\n+          }\n+          args = tmpArgs;\n+        }\n         Map<String, String> props = null;\n         if (!args[5].isEmpty()) {\n           String[] keyValues = args[5].split(\"&\");\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNTU1Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487905556", "body": "rename to MLogTXTReader or add a javadoc :  for reading mlog.txt", "bodyText": "rename to MLogTXTReader or add a javadoc :  for reading mlog.txt", "bodyHTML": "<p dir=\"auto\">rename to MLogTXTReader or add a javadoc :  for reading mlog.txt</p>", "author": "qiaojialin", "createdAt": "2020-09-14T13:19:44Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/OldMLogReader.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+\n+\n+public class OldMLogReader implements AutoCloseable {", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/OldMLogReader.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java\nsimilarity index 93%\nrename from server/src/main/java/org/apache/iotdb/db/metadata/logfile/OldMLogReader.java\nrename to server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java\nindex 09f45448b7..526c4281ae 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/OldMLogReader.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java\n", "chunk": "@@ -28,15 +28,17 @@ import java.io.File;\n import java.io.FileReader;\n import java.io.IOException;\n \n-\n-public class OldMLogReader implements AutoCloseable {\n+/**\n+ * reader for reading mlog.txt\n+ */\n+public class MLogTxtReader implements AutoCloseable {\n   private static final Logger logger = LoggerFactory.getLogger(MLogReader.class);\n \n   private BufferedReader bufferedReader;\n   private File logFile;\n   private String cmd;\n \n-  public OldMLogReader(String schemaDir, String logFileName) throws IOException {\n+  public MLogTxtReader(String schemaDir, String logFileName) throws IOException {\n     File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n     if (!metadataDir.exists()) {\n       logger.error(\"no mlog.txt to init MManager.\");\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMjE0NQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487912145", "body": "This is not an error case, change this to debug level is better. The case is: Allocate 16MB for buffer and put log into this buffer one by one, In the end, it always trigger the BufferOverflowException, just reseting the buffer is ok.\r\n\r\nHowever, if one log exceeds 16M, this will throw an exception.", "bodyText": "This is not an error case, change this to debug level is better. The case is: Allocate 16MB for buffer and put log into this buffer one by one, In the end, it always trigger the BufferOverflowException, just reseting the buffer is ok.\nHowever, if one log exceeds 16M, this will throw an exception.", "bodyHTML": "<p dir=\"auto\">This is not an error case, change this to debug level is better. The case is: Allocate 16MB for buffer and put log into this buffer one by one, In the end, it always trigger the BufferOverflowException, just reseting the buffer is ok.</p>\n<p dir=\"auto\">However, if one log exceeds 16M, this will throw an exception.</p>", "author": "qiaojialin", "createdAt": "2020-09-14T13:28:35Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public void close() throws IOException {\n+    sync();\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n+    try {\n+      plan.serialize(mlogBuffer);\n+    } catch (BufferOverflowException e) {\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkwNTM5NA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r489905394", "bodyText": "yes", "author": "mychaow", "createdAt": "2020-09-17T02:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMjE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c9db0fef590ec1f27c44d85e850a77f82743a804", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -93,7 +95,7 @@ public class MLogWriter implements AutoCloseable {\n     try {\n       plan.serialize(mlogBuffer);\n     } catch (BufferOverflowException e) {\n-      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      logger.debug(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n       mlogBuffer.reset();\n       sync();\n       plan.serialize(mlogBuffer);\n", "next_change": {"commit": "7a5ad6d7312a641efad62a814f07be5ce4aade56", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -91,16 +104,13 @@ public class MLogWriter implements AutoCloseable {\n   }\n \n   private void putLog(PhysicalPlan plan) {\n-    mlogBuffer.mark();\n     try {\n       plan.serialize(mlogBuffer);\n-    } catch (BufferOverflowException e) {\n-      logger.debug(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n-      mlogBuffer.reset();\n       sync();\n-      plan.serialize(mlogBuffer);\n+      logNum ++;\n+    } catch (BufferOverflowException e) {\n+      logger.warn(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n     }\n-    logNum ++;\n   }\n \n   public void createTimeseries(CreateTimeSeriesPlan createTimeSeriesPlan) throws IOException {\n", "next_change": {"commit": "18bb0557753e46238c0a17cd131af13a072eb09c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -118,7 +119,7 @@ public class MLogWriter implements AutoCloseable {\n       putLog(createTimeSeriesPlan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+        LOG_TOO_LARGE_INFO, e);\n     }\n   }\n \n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -105,21 +89,26 @@ public class MLogWriter implements AutoCloseable {\n   }\n \n   private void putLog(PhysicalPlan plan) {\n+    mlogBuffer.mark();\n     try {\n       plan.serialize(mlogBuffer);\n-      sync();\n-      logNum ++;\n     } catch (BufferOverflowException e) {\n-      logger.warn(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      logger.error(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+      mlogBuffer.reset();\n+      sync();\n+      plan.serialize(mlogBuffer);\n     }\n+    logNum ++;\n   }\n \n-  public void createTimeseries(CreateTimeSeriesPlan createTimeSeriesPlan) throws IOException {\n+  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n     try {\n-      putLog(createTimeSeriesPlan);\n+      putLog(plan);\n+      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n+      putLog(changeTagOffsetPlan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        LOG_TOO_LARGE_INFO, e);\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n     }\n   }\n \n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -101,11 +103,9 @@ public class MLogWriter {\n     logNum ++;\n   }\n \n-  public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws IOException {\n+  public void createTimeseries(CreateTimeSeriesPlan createTimeSeriesPlan) throws IOException {\n     try {\n-      putLog(plan);\n-      ChangeTagOffsetPlan changeTagOffsetPlan = new ChangeTagOffsetPlan(plan.getPath(), offset);\n-      putLog(changeTagOffsetPlan);\n+      putLog(createTimeSeriesPlan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n         \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n", "next_change": {"commit": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -108,7 +119,7 @@ public class MLogWriter implements AutoCloseable {\n       putLog(createTimeSeriesPlan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+        LOG_TOO_LARGE_INFO, e);\n     }\n   }\n \n", "next_change": null}]}}]}}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -128,7 +117,7 @@ public class MLogWriter implements AutoCloseable {\n       putLog(deleteTimeSeriesPlan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        LOG_TOO_LARGE_INFO, e);\n+        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n     }\n   }\n \n", "next_change": {"commit": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -117,7 +128,7 @@ public class MLogWriter {\n       putLog(deleteTimeSeriesPlan);\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-        \"Log cannot fit into buffer, please increase mlog_buffer_size\", e);\n+        LOG_TOO_LARGE_INFO, e);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNDQxNA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487914414", "body": "If using a buffer like WAL, we also need a thread to sync the buffer periodically like the forceTask in MultiFileLogNodeManager. Otherwise, the last logs in the buffer will never be persisted. \r\n\r\nOne option is to sync the mlog one by one.", "bodyText": "If using a buffer like WAL, we also need a thread to sync the buffer periodically like the forceTask in MultiFileLogNodeManager. Otherwise, the last logs in the buffer will never be persisted.\nOne option is to sync the mlog one by one.", "bodyHTML": "<p dir=\"auto\">If using a buffer like WAL, we also need a thread to sync the buffer periodically like the forceTask in MultiFileLogNodeManager. Otherwise, the last logs in the buffer will never be persisted.</p>\n<p dir=\"auto\">One option is to sync the mlog one by one.</p>", "author": "qiaojialin", "createdAt": "2020-09-14T13:31:14Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkwMzM4Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r489903386", "bodyText": "yes, I think maybe we need to call the forceTask periodically. Because FileChannel.force(true) is more costful than bufferedWriter.flush, this will result in performance degradation of metadata operation.", "author": "mychaow", "createdAt": "2020-09-17T02:45:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNDQxNA=="}], "type": "inlineReview", "revised_code": {"commit": "7a5ad6d7312a641efad62a814f07be5ce4aade56", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -34,15 +29,34 @@ import org.apache.iotdb.db.metadata.mnode.MNode;\n import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n import org.apache.iotdb.db.writelog.io.LogWriter;\n import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n public class MLogWriter implements AutoCloseable {\n \n   private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n", "next_change": {"commit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..a5a1956448 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -53,6 +53,7 @@ import java.io.IOException;\n import java.nio.BufferOverflowException;\n import java.nio.ByteBuffer;\n import java.nio.file.Files;\n+import java.nio.file.Paths;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex a5a1956448..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -29,36 +34,16 @@ import org.apache.iotdb.db.metadata.mnode.MNode;\n import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n import org.apache.iotdb.db.writelog.io.LogWriter;\n import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n-import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.BufferOverflowException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-public class MLogWriter implements AutoCloseable {\n+public class MLogWriter {\n \n   private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n   private File logFile;\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -43,7 +44,7 @@ import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class MLogWriter {\n+public class MLogWriter implements AutoCloseable {\n \n   private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n   private File logFile;\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -35,15 +29,34 @@ import org.apache.iotdb.db.metadata.mnode.MNode;\n import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n import org.apache.iotdb.db.writelog.io.LogWriter;\n import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n public class MLogWriter implements AutoCloseable {\n \n   private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n", "next_change": {"commit": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..a5a1956448 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -53,6 +53,7 @@ import java.io.IOException;\n import java.nio.BufferOverflowException;\n import java.nio.ByteBuffer;\n import java.nio.file.Files;\n+import java.nio.file.Paths;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex a5a1956448..322c5d1e09 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -54,6 +55,7 @@ import java.nio.BufferOverflowException;\n import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n", "next_change": {"commit": "95516e01ca4ba2e1134b4202b86c53ffbfe196ea", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 322c5d1e09..dcaddf4013 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -55,7 +54,6 @@ import java.nio.BufferOverflowException;\n import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.nio.file.Paths;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -53,6 +66,9 @@ public class MLogWriter implements AutoCloseable {\n   private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n+  // we write log to channel every time, so we need not to call channel.force every time\n+  private final long DUMMY_FLUSH_TIME = 100;\n+\n   public MLogWriter(String schemaDir, String logFileName) throws IOException {\n     File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n     if (!metadataDir.exists()) {\n", "next_change": {"commit": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -67,7 +67,8 @@ public class MLogWriter implements AutoCloseable {\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n   // we write log to channel every time, so we need not to call channel.force every time\n-  private final long DUMMY_FLUSH_TIME = 100;\n+  private static final long DUMMY_FLUSH_TIME = 100;\n+  private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n \n   public MLogWriter(String schemaDir, String logFileName) throws IOException {\n     File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..9fea13282d 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -63,11 +64,10 @@ public class MLogWriter implements AutoCloseable {\n   private File logFile;\n   private LogWriter logWriter;\n   private int logNum;\n-  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+  private static final String DELETE_FAILED_FORMAT = \"Deleting %s failed with exception %s\";\n+  private final ByteBuffer mlogBuffer = ByteBuffer.allocate(\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n-  // we write log to channel every time, so we need not to call channel.force every time\n-  private static final long DUMMY_FLUSH_TIME = 100;\n   private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n \n   public MLogWriter(String schemaDir, String logFileName) throws IOException {\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 5b258f16ed..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -52,6 +66,9 @@ public class MLogWriter implements AutoCloseable {\n   private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n+  // we write log to channel every time, so we need not to call channel.force every time\n+  private final long DUMMY_FLUSH_TIME = 100;\n+\n   public MLogWriter(String schemaDir, String logFileName) throws IOException {\n     File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n     if (!metadataDir.exists()) {\n", "next_change": {"commit": "18bb0557753e46238c0a17cd131af13a072eb09c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -67,7 +67,8 @@ public class MLogWriter implements AutoCloseable {\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n   // we write log to channel every time, so we need not to call channel.force every time\n-  private final long DUMMY_FLUSH_TIME = 100;\n+  private static final long DUMMY_FLUSH_TIME = 100;\n+  private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n \n   public MLogWriter(String schemaDir, String logFileName) throws IOException {\n     File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -66,31 +52,29 @@ public class MLogWriter implements AutoCloseable {\n   private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n-  // we write log to channel every time, so we need not to call channel.force every time\n-  private static final long DUMMY_FLUSH_TIME = 100;\n-  private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n-\n   public MLogWriter(String schemaDir, String logFileName) throws IOException {\n     File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n     if (!metadataDir.exists()) {\n       if (metadataDir.mkdirs()) {\n         logger.info(\"create schema folder {}.\", metadataDir);\n       } else {\n-        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+        logger.info(\"create schema folder {} failed.\", metadataDir);\n       }\n     }\n \n     logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n-    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n   }\n \n   public MLogWriter(String logFilePath) throws IOException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n-    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+    // always flush\n+    logWriter = new LogWriter(logFile, 0L);\n   }\n \n-  @Override\n   public void close() throws IOException {\n+    sync();\n     logWriter.close();\n   }\n \n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -73,6 +74,7 @@ public class MLogWriter {\n     logWriter = new LogWriter(logFile, 0L);\n   }\n \n+  @Override\n   public void close() throws IOException {\n     sync();\n     logWriter.close();\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -64,19 +80,16 @@ public class MLogWriter implements AutoCloseable {\n     }\n \n     logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n-    // always flush\n-    logWriter = new LogWriter(logFile, 0L);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n   }\n \n   public MLogWriter(String logFilePath) throws IOException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n-    // always flush\n-    logWriter = new LogWriter(logFile, 0L);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n   }\n \n   @Override\n   public void close() throws IOException {\n-    sync();\n     logWriter.close();\n   }\n \n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..9fea13282d 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -80,12 +81,12 @@ public class MLogWriter implements AutoCloseable {\n     }\n \n     logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n-    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+    logWriter = new LogWriter(logFile, false);\n   }\n \n   public MLogWriter(String logFilePath) throws IOException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n-    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+    logWriter = new LogWriter(logFile, false);\n   }\n \n   @Override\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzNjYxMg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487936612", "body": "The XXMNodePlan is almost the same as the XXMNode, the structure is not a problem. But creating or recovering a snapshot may be slower in this way.  Better to test the performance. If the performance does not decrease a lot, this is acceptable. We could test 10M timeseries (10000 device * 1000 measurement) ", "bodyText": "The XXMNodePlan is almost the same as the XXMNode, the structure is not a problem. But creating or recovering a snapshot may be slower in this way.  Better to test the performance. If the performance does not decrease a lot, this is acceptable. We could test 10M timeseries (10000 device * 1000 measurement)", "bodyHTML": "<p dir=\"auto\">The XXMNodePlan is almost the same as the XXMNode, the structure is not a problem. But creating or recovering a snapshot may be slower in this way.  Better to test the performance. If the performance does not decrease a lot, this is acceptable. We could test 10M timeseries (10000 device * 1000 measurement)</p>", "author": "qiaojialin", "createdAt": "2020-09-14T13:52:25Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -1002,48 +1004,57 @@ private void findNodes(MNode node, PartialPath path, List<PartialPath> res, int\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (BufferedWriter bw = new BufferedWriter(\n-        new FileWriter(SystemFileFactory.INSTANCE.getFile(snapshotPath)))) {\n-      root.serializeTo(bw);\n+    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n+      root.serializeTo(mLogWriter);\n     }\n   }\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-    try (BufferedReader br = new BufferedReader(new FileReader(mtreeSnapshot))) {\n-      String s;\n+\n+    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n       Deque<MNode> nodeStack = new ArrayDeque<>();\n       MNode node = null;\n \n-      while ((s = br.readLine()) != null) {\n-        String[] nodeInfo = s.split(\",\");\n-        short nodeType = Short.parseShort(nodeInfo[0]);\n-        if (nodeType == MetadataConstant.STORAGE_GROUP_MNODE_TYPE) {\n-          node = StorageGroupMNode.deserializeFrom(nodeInfo);\n-        } else if (nodeType == MetadataConstant.MEASUREMENT_MNODE_TYPE) {\n-          node = MeasurementMNode.deserializeFrom(nodeInfo);\n-        } else {\n-          node = new MNode(null, nodeInfo[1]);\n-        }\n+      while (mlogReader.hasNext()) {\n+        PhysicalPlan plan = null;\n+        try {\n+          plan = mlogReader.next();\n+          if (plan == null) {\n+            continue;\n+          }\n+          int childrenSize = 0;\n+          if (plan instanceof StorageGroupMNodePlan) {\n+            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MeasurementMNodePlan) {\n+            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n+            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MNodePlan) {\n+            node = new MNode(null, ((MNodePlan) plan).getName());\n+            childrenSize = ((MNodePlan) plan).getChildSize();\n+          }", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkwMzUwMg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r489903502", "bodyText": "ok, I will do some tests.", "author": "mychaow", "createdAt": "2020-09-17T02:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzNjYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4MTc0Nw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r489981747", "bodyText": "I have done some tests, 1M timeseries,  the cpu cost it almost same.", "author": "mychaow", "createdAt": "2020-09-17T05:36:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzNjYxMg=="}], "type": "inlineReview", "revised_code": {"commit": "9ea4a4afe6a50de659f5cd324ddc2e2f53b5e1d7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 87d0dcdde3..f1b2a752cc 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1038,7 +1183,7 @@ public class MTree implements Serializable {\n           if (childrenSize == 0) {\n             nodeStack.push(node);\n           } else {\n-            Map<String, MNode> childrenMap = new LinkedHashMap<>();\n+            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n             for (int i = 0; i < childrenSize; i++) {\n               MNode child = nodeStack.removeFirst();\n               child.setParent(node);\n", "next_change": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex f1b2a752cc..314af82411 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1154,55 +1218,9 @@ public class MTree implements Serializable {\n     }\n   }\n \n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-\n-    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n-      Deque<MNode> nodeStack = new ArrayDeque<>();\n-      MNode node = null;\n-\n-      while (mlogReader.hasNext()) {\n-        PhysicalPlan plan = null;\n-        try {\n-          plan = mlogReader.next();\n-          if (plan == null) {\n-            continue;\n-          }\n-          int childrenSize = 0;\n-          if (plan instanceof StorageGroupMNodePlan) {\n-            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n-            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MeasurementMNodePlan) {\n-            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n-            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MNodePlan) {\n-            node = new MNode(null, ((MNodePlan) plan).getName());\n-            childrenSize = ((MNodePlan) plan).getChildSize();\n-          }\n-\n-          if (childrenSize == 0) {\n-            nodeStack.push(node);\n-          } else {\n-            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n-            for (int i = 0; i < childrenSize; i++) {\n-              MNode child = nodeStack.removeFirst();\n-              child.setParent(node);\n-              childrenMap.put(child.getName(), child);\n-              if (child instanceof MeasurementMNode) {\n-                String alias = ((MeasurementMNode) child).getAlias();\n-                if (alias != null) {\n-                  node.addAlias(alias, child);\n-                }\n-              }\n-            }\n-            node.setChildren(childrenMap);\n-            nodeStack.push(node);\n-          }\n-        } catch (Exception e) {\n-          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n-        }\n-      }\n-      return new MTree(node);\n+    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n+      return deserializeFromReader(mLogReader);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 314af82411..1b0807e9d5 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1213,18 +1218,74 @@ public class MTree implements Serializable {\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n+    MLogWriter mLogWriter = null;\n+    try {\n+      mLogWriter = new MLogWriter(snapshotPath);\n       root.serializeTo(mLogWriter);\n+    } finally {\n+      if (mLogWriter != null) {\n+        mLogWriter.close();\n+      }\n     }\n   }\n \n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n-      return deserializeFromReader(mLogReader);\n+    MLogReader mlogReader = null;\n+    try {\n+      mlogReader = new MLogReader(mtreeSnapshot);\n+      Deque<MNode> nodeStack = new ArrayDeque<>();\n+      MNode node = null;\n+\n+      while (mlogReader.hasNext()) {\n+        PhysicalPlan plan = null;\n+        try {\n+          plan = mlogReader.next();\n+          if (plan == null) {\n+            continue;\n+          }\n+          int childrenSize = 0;\n+          if (plan instanceof StorageGroupMNodePlan) {\n+            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MeasurementNodePlan) {\n+            node = MeasurementMNode.deserializeFrom((MeasurementNodePlan) plan);\n+            childrenSize = ((MeasurementNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MNodePlan) {\n+            node = new MNode(null, ((MNodePlan) plan).getName());\n+            childrenSize = ((MNodePlan) plan).getChildSize();\n+          }\n+\n+          if (childrenSize == 0) {\n+            nodeStack.push(node);\n+          } else {\n+            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+            for (int i = 0; i < childrenSize; i++) {\n+              MNode child = nodeStack.removeFirst();\n+              child.setParent(node);\n+              childrenMap.put(child.getName(), child);\n+              if (child instanceof MeasurementMNode) {\n+                String alias = ((MeasurementMNode) child).getAlias();\n+                if (alias != null) {\n+                  node.addAlias(alias, child);\n+                }\n+              }\n+            }\n+            node.setChildren(childrenMap);\n+            nodeStack.push(node);\n+          }\n+        } catch (Exception e) {\n+          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n+        }\n+      }\n+      return new MTree(node);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n     } finally {\n+      if (mlogReader != null) {\n+        mlogReader.close();\n+      }\n       limit = new ThreadLocal<>();\n       offset = new ThreadLocal<>();\n       count = new ThreadLocal<>();\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 1b0807e9d5..31fbef0463 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1283,9 +1276,6 @@ public class MTree implements Serializable {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n     } finally {\n-      if (mlogReader != null) {\n-        mlogReader.close();\n-      }\n       limit = new ThreadLocal<>();\n       offset = new ThreadLocal<>();\n       count = new ThreadLocal<>();\n", "next_change": {"commit": "bc0aea4a6ee1f92a2b379da57acb77ad20a447a1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 31fbef0463..a0e62f2ca2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1223,55 +1222,9 @@ public class MTree implements Serializable {\n     }\n   }\n \n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-\n-    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n-      Deque<MNode> nodeStack = new ArrayDeque<>();\n-      MNode node = null;\n-\n-      while (mlogReader.hasNext()) {\n-        PhysicalPlan plan = null;\n-        try {\n-          plan = mlogReader.next();\n-          if (plan == null) {\n-            continue;\n-          }\n-          int childrenSize = 0;\n-          if (plan instanceof StorageGroupMNodePlan) {\n-            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n-            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MeasurementMNodePlan) {\n-            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n-            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MNodePlan) {\n-            node = new MNode(null, ((MNodePlan) plan).getName());\n-            childrenSize = ((MNodePlan) plan).getChildSize();\n-          }\n-\n-          if (childrenSize == 0) {\n-            nodeStack.push(node);\n-          } else {\n-            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n-            for (int i = 0; i < childrenSize; i++) {\n-              MNode child = nodeStack.removeFirst();\n-              child.setParent(node);\n-              childrenMap.put(child.getName(), child);\n-              if (child instanceof MeasurementMNode) {\n-                String alias = ((MeasurementMNode) child).getAlias();\n-                if (alias != null) {\n-                  node.addAlias(alias, child);\n-                }\n-              }\n-            }\n-            node.setChildren(childrenMap);\n-            nodeStack.push(node);\n-          }\n-        } catch (Exception e) {\n-          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n-        }\n-      }\n-      return new MTree(node);\n+    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n+      return deserializeFromReader(mLogReader);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n", "next_change": null}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 31fbef0463..a0e62f2ca2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1283,6 +1236,53 @@ public class MTree implements Serializable {\n     }\n   }\n \n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  private static MTree deserializeFromReader(MLogReader mLogReader) {\n+    Deque<MNode> nodeStack = new ArrayDeque<>();\n+    MNode node = null;\n+    while (mLogReader.hasNext()) {\n+      PhysicalPlan plan = null;\n+      try {\n+        plan = mLogReader.next();\n+        if (plan == null) {\n+          continue;\n+        }\n+        int childrenSize = 0;\n+        if (plan instanceof StorageGroupMNodePlan) {\n+          node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+          childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+        } else if (plan instanceof MeasurementMNodePlan) {\n+          node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n+          childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n+        } else if (plan instanceof MNodePlan) {\n+          node = new MNode(null, ((MNodePlan) plan).getName());\n+          childrenSize = ((MNodePlan) plan).getChildSize();\n+        }\n+\n+        if (childrenSize != 0) {\n+          ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+          for (int i = 0; i < childrenSize; i++) {\n+            MNode child = nodeStack.removeFirst();\n+            child.setParent(node);\n+            childrenMap.put(child.getName(), child);\n+            if (child instanceof MeasurementMNode) {\n+              String alias = ((MeasurementMNode) child).getAlias();\n+              if (alias != null) {\n+                node.addAlias(alias, child);\n+              }\n+            }\n+          }\n+          node.setChildren(childrenMap);\n+        }\n+        nodeStack.push(node);\n+      } catch (Exception e) {\n+        logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n+      }\n+    }\n+\n+    return new MTree(node);\n+  }\n+\n   @Override\n   public String toString() {\n     JsonObject jsonObject = new JsonObject();\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0MTExNg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r487941116", "body": "Pay attention to force mLogWriter before close it. ", "bodyText": "Pay attention to force mLogWriter before close it.", "bodyHTML": "<p dir=\"auto\">Pay attention to force mLogWriter before close it.</p>", "author": "qiaojialin", "createdAt": "2020-09-14T13:56:37Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -1002,48 +1004,57 @@ private void findNodes(MNode node, PartialPath path, List<PartialPath> res, int\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (BufferedWriter bw = new BufferedWriter(\n-        new FileWriter(SystemFileFactory.INSTANCE.getFile(snapshotPath)))) {\n-      root.serializeTo(bw);\n+    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n+      root.serializeTo(mLogWriter);", "originalCommit": "6c6e0d44c946e6ac6a39caabe38dfbe533c982df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 87d0dcdde3..314af82411 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1009,55 +1218,9 @@ public class MTree implements Serializable {\n     }\n   }\n \n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-\n-    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n-      Deque<MNode> nodeStack = new ArrayDeque<>();\n-      MNode node = null;\n-\n-      while (mlogReader.hasNext()) {\n-        PhysicalPlan plan = null;\n-        try {\n-          plan = mlogReader.next();\n-          if (plan == null) {\n-            continue;\n-          }\n-          int childrenSize = 0;\n-          if (plan instanceof StorageGroupMNodePlan) {\n-            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n-            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MeasurementMNodePlan) {\n-            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n-            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MNodePlan) {\n-            node = new MNode(null, ((MNodePlan) plan).getName());\n-            childrenSize = ((MNodePlan) plan).getChildSize();\n-          }\n-\n-          if (childrenSize == 0) {\n-            nodeStack.push(node);\n-          } else {\n-            Map<String, MNode> childrenMap = new LinkedHashMap<>();\n-            for (int i = 0; i < childrenSize; i++) {\n-              MNode child = nodeStack.removeFirst();\n-              child.setParent(node);\n-              childrenMap.put(child.getName(), child);\n-              if (child instanceof MeasurementMNode) {\n-                String alias = ((MeasurementMNode) child).getAlias();\n-                if (alias != null) {\n-                  node.addAlias(alias, child);\n-                }\n-              }\n-            }\n-            node.setChildren(childrenMap);\n-            nodeStack.push(node);\n-          }\n-        } catch (Exception e) {\n-          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n-        }\n-      }\n-      return new MTree(node);\n+    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n+      return deserializeFromReader(mLogReader);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 314af82411..1b0807e9d5 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1213,18 +1218,74 @@ public class MTree implements Serializable {\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n+    MLogWriter mLogWriter = null;\n+    try {\n+      mLogWriter = new MLogWriter(snapshotPath);\n       root.serializeTo(mLogWriter);\n+    } finally {\n+      if (mLogWriter != null) {\n+        mLogWriter.close();\n+      }\n     }\n   }\n \n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n-      return deserializeFromReader(mLogReader);\n+    MLogReader mlogReader = null;\n+    try {\n+      mlogReader = new MLogReader(mtreeSnapshot);\n+      Deque<MNode> nodeStack = new ArrayDeque<>();\n+      MNode node = null;\n+\n+      while (mlogReader.hasNext()) {\n+        PhysicalPlan plan = null;\n+        try {\n+          plan = mlogReader.next();\n+          if (plan == null) {\n+            continue;\n+          }\n+          int childrenSize = 0;\n+          if (plan instanceof StorageGroupMNodePlan) {\n+            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MeasurementNodePlan) {\n+            node = MeasurementMNode.deserializeFrom((MeasurementNodePlan) plan);\n+            childrenSize = ((MeasurementNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MNodePlan) {\n+            node = new MNode(null, ((MNodePlan) plan).getName());\n+            childrenSize = ((MNodePlan) plan).getChildSize();\n+          }\n+\n+          if (childrenSize == 0) {\n+            nodeStack.push(node);\n+          } else {\n+            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+            for (int i = 0; i < childrenSize; i++) {\n+              MNode child = nodeStack.removeFirst();\n+              child.setParent(node);\n+              childrenMap.put(child.getName(), child);\n+              if (child instanceof MeasurementMNode) {\n+                String alias = ((MeasurementMNode) child).getAlias();\n+                if (alias != null) {\n+                  node.addAlias(alias, child);\n+                }\n+              }\n+            }\n+            node.setChildren(childrenMap);\n+            nodeStack.push(node);\n+          }\n+        } catch (Exception e) {\n+          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n+        }\n+      }\n+      return new MTree(node);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n     } finally {\n+      if (mlogReader != null) {\n+        mlogReader.close();\n+      }\n       limit = new ThreadLocal<>();\n       offset = new ThreadLocal<>();\n       count = new ThreadLocal<>();\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 1b0807e9d5..31fbef0463 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1283,9 +1276,6 @@ public class MTree implements Serializable {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n     } finally {\n-      if (mlogReader != null) {\n-        mlogReader.close();\n-      }\n       limit = new ThreadLocal<>();\n       offset = new ThreadLocal<>();\n       count = new ThreadLocal<>();\n", "next_change": {"commit": "bc0aea4a6ee1f92a2b379da57acb77ad20a447a1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 31fbef0463..a0e62f2ca2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1223,55 +1222,9 @@ public class MTree implements Serializable {\n     }\n   }\n \n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-\n-    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n-      Deque<MNode> nodeStack = new ArrayDeque<>();\n-      MNode node = null;\n-\n-      while (mlogReader.hasNext()) {\n-        PhysicalPlan plan = null;\n-        try {\n-          plan = mlogReader.next();\n-          if (plan == null) {\n-            continue;\n-          }\n-          int childrenSize = 0;\n-          if (plan instanceof StorageGroupMNodePlan) {\n-            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n-            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MeasurementMNodePlan) {\n-            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n-            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MNodePlan) {\n-            node = new MNode(null, ((MNodePlan) plan).getName());\n-            childrenSize = ((MNodePlan) plan).getChildSize();\n-          }\n-\n-          if (childrenSize == 0) {\n-            nodeStack.push(node);\n-          } else {\n-            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n-            for (int i = 0; i < childrenSize; i++) {\n-              MNode child = nodeStack.removeFirst();\n-              child.setParent(node);\n-              childrenMap.put(child.getName(), child);\n-              if (child instanceof MeasurementMNode) {\n-                String alias = ((MeasurementMNode) child).getAlias();\n-                if (alias != null) {\n-                  node.addAlias(alias, child);\n-                }\n-              }\n-            }\n-            node.setChildren(childrenMap);\n-            nodeStack.push(node);\n-          }\n-        } catch (Exception e) {\n-          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n-        }\n-      }\n-      return new MTree(node);\n+    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n+      return deserializeFromReader(mLogReader);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n", "next_change": null}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 31fbef0463..a0e62f2ca2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1283,6 +1236,53 @@ public class MTree implements Serializable {\n     }\n   }\n \n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  private static MTree deserializeFromReader(MLogReader mLogReader) {\n+    Deque<MNode> nodeStack = new ArrayDeque<>();\n+    MNode node = null;\n+    while (mLogReader.hasNext()) {\n+      PhysicalPlan plan = null;\n+      try {\n+        plan = mLogReader.next();\n+        if (plan == null) {\n+          continue;\n+        }\n+        int childrenSize = 0;\n+        if (plan instanceof StorageGroupMNodePlan) {\n+          node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+          childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+        } else if (plan instanceof MeasurementMNodePlan) {\n+          node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n+          childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n+        } else if (plan instanceof MNodePlan) {\n+          node = new MNode(null, ((MNodePlan) plan).getName());\n+          childrenSize = ((MNodePlan) plan).getChildSize();\n+        }\n+\n+        if (childrenSize != 0) {\n+          ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+          for (int i = 0; i < childrenSize; i++) {\n+            MNode child = nodeStack.removeFirst();\n+            child.setParent(node);\n+            childrenMap.put(child.getName(), child);\n+            if (child instanceof MeasurementMNode) {\n+              String alias = ((MeasurementMNode) child).getAlias();\n+              if (alias != null) {\n+                node.addAlias(alias, child);\n+              }\n+            }\n+          }\n+          node.setChildren(childrenMap);\n+        }\n+        nodeStack.push(node);\n+      } catch (Exception e) {\n+        logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n+      }\n+    }\n+\n+    return new MTree(node);\n+  }\n+\n   @Override\n   public String toString() {\n     JsonObject jsonObject = new JsonObject();\n", "next_change": null}]}}]}}]}}]}}, {"oid": "c9db0fef590ec1f27c44d85e850a77f82743a804", "url": "https://github.com/apache/iotdb/commit/c9db0fef590ec1f27c44d85e850a77f82743a804", "message": "fix upgrade mlog bug", "committedDate": "2020-09-22T05:29:53Z", "type": "forcePushed"}, {"oid": "72e188cc3e3d4fe1c4583b176aa1badcad400793", "url": "https://github.com/apache/iotdb/commit/72e188cc3e3d4fe1c4583b176aa1badcad400793", "message": "fix upgrade mlog bug", "committedDate": "2020-09-27T05:34:11Z", "type": "forcePushed"}, {"oid": "9ea4a4afe6a50de659f5cd324ddc2e2f53b5e1d7", "url": "https://github.com/apache/iotdb/commit/9ea4a4afe6a50de659f5cd324ddc2e2f53b5e1d7", "message": "fix upgrade mlog bug", "committedDate": "2020-10-12T07:18:36Z", "type": "forcePushed"}, {"oid": "3fd3e5ac8439ead77f6ae9c486137ce0b28c609f", "url": "https://github.com/apache/iotdb/commit/3fd3e5ac8439ead77f6ae9c486137ce0b28c609f", "message": "fix upgrade mlog bug", "committedDate": "2020-10-12T11:18:25Z", "type": "forcePushed"}, {"oid": "5491c8cc75c2d83192f012a5c2a8329bedeadf81", "url": "https://github.com/apache/iotdb/commit/5491c8cc75c2d83192f012a5c2a8329bedeadf81", "message": "fix upgrade mlog bug", "committedDate": "2020-10-12T11:30:23Z", "type": "forcePushed"}, {"oid": "df0282f1249629b08e83f6e465ac060ff3864a00", "url": "https://github.com/apache/iotdb/commit/df0282f1249629b08e83f6e465ac060ff3864a00", "message": "add mlog parser", "committedDate": "2020-11-18T06:18:23Z", "type": "forcePushed"}, {"oid": "7a5ad6d7312a641efad62a814f07be5ce4aade56", "url": "https://github.com/apache/iotdb/commit/7a5ad6d7312a641efad62a814f07be5ce4aade56", "message": "add mlog parser", "committedDate": "2020-11-20T02:22:04Z", "type": "forcePushed"}, {"oid": "18bb0557753e46238c0a17cd131af13a072eb09c", "url": "https://github.com/apache/iotdb/commit/18bb0557753e46238c0a17cd131af13a072eb09c", "message": "remove some code smell warn", "committedDate": "2020-11-20T03:43:30Z", "type": "forcePushed"}, {"oid": "18db49a9f143f75580454df2a3fb002d63c66a2d", "url": "https://github.com/apache/iotdb/commit/18db49a9f143f75580454df2a3fb002d63c66a2d", "message": "fix some snoar warn", "committedDate": "2020-11-24T01:59:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxMDYwMQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529510601", "body": "`ConsoleReader reader` is not used in this method : )", "bodyText": "ConsoleReader reader is not used in this method : )", "bodyHTML": "<p dir=\"auto\"><code>ConsoleReader reader</code> is not used in this method : )</p>", "author": "samperson1997", "createdAt": "2020-11-24T12:33:01Z", "path": "server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 9963355b06..8261635479 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -110,19 +108,15 @@ public class MLogParser {\n       return;\n     }\n \n-    ConsoleReader reader = new ConsoleReader();\n-    reader.setExpandEvents(false);\n     try {\n-      parseBasicParams(commandLine, reader);\n+      parseBasicParams(commandLine);\n       parseFromFile(inputFile, outputFile);\n     } catch (Exception e) {\n       System.out.println(\"Encounter an error, because: \" + e.getMessage());\n-    } finally {\n-      reader.close();\n     }\n   }\n \n-  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+  public static void parseBasicParams(CommandLine commandLine) throws Exception {\n     inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n     outputFile = commandLine.getOptionValue(OUT_ARGS);\n \n", "next_change": {"commit": "61c6f6d47b087075554ed4f3636d4990a6da4395", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 8261635479..f8bbbc6e6c 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -112,11 +115,11 @@ public class MLogParser {\n       parseBasicParams(commandLine);\n       parseFromFile(inputFile, outputFile);\n     } catch (Exception e) {\n-      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+      logger.error(\"Encounter an error, because: {} \", e.getMessage());\n     }\n   }\n \n-  public static void parseBasicParams(CommandLine commandLine) throws Exception {\n+  public static void parseBasicParams(CommandLine commandLine) throws ParseException {\n     inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n     outputFile = commandLine.getOptionValue(OUT_ARGS);\n \n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\ndeleted file mode 100644\nindex f8bbbc6e6c..0000000000\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ /dev/null\n", "chunk": "@@ -1,194 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.iotdb.db.tools.mlog;\n-\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.DefaultParser;\n-import org.apache.commons.cli.HelpFormatter;\n-import org.apache.commons.cli.Option;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.ParseException;\n-import org.apache.iotdb.db.metadata.MLogTxtWriter;\n-import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.metadata.logfile.MLogReader;\n-import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-\n-/**\n- * parse the binary mlog or snapshot to text\n- */\n-public class MLogParser {\n-\n-  private static final Logger logger = LoggerFactory.getLogger(MLogParser.class);\n-  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n-\n-  private static final String FILE_ARGS = \"f\";\n-  private static final String FILE_NAME = \"mlog file\";\n-\n-  private static final String OUT_ARGS = \"o\";\n-  private static final String OUT_NAME = \"output txt file\";\n-\n-  private static final String HELP_ARGS = \"help\";\n-\n-  private static String inputFile;\n-  private static String outputFile;\n-\n-  /**\n-   * create the commandline options.\n-   *\n-   * @return object Options\n-   */\n-  public static Options createOptions() {\n-    Options options = new Options();\n-\n-    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n-      \"Need to specify a binary mlog file to parse (required)\")\n-      .build();\n-    options.addOption(opFile);\n-\n-    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n-      \"Could specify the output file after parse (optional)\")\n-      .build();\n-    options.addOption(opOut);\n-\n-    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n-      .hasArg(false).desc(\"Display help information\")\n-      .build();\n-    options.addOption(opHelp);\n-\n-    return options;\n-  }\n-\n-  public static void main(String[] args) {\n-    Options options = createOptions();\n-    HelpFormatter hf = new HelpFormatter();\n-    hf.setOptionComparator(null);\n-    CommandLine commandLine;\n-    CommandLineParser parser = new DefaultParser();\n-\n-    if (args == null || args.length == 0) {\n-      logger.warn(\"Too few params input, please check the following hint.\");\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    try {\n-      commandLine = parser.parse(options, args);\n-    } catch (ParseException e) {\n-      logger.error(\"Parse error: {}\", e.getMessage());\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    if (commandLine.hasOption(HELP_ARGS)) {\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-\n-    try {\n-      parseBasicParams(commandLine);\n-      parseFromFile(inputFile, outputFile);\n-    } catch (Exception e) {\n-      logger.error(\"Encounter an error, because: {} \", e.getMessage());\n-    }\n-  }\n-\n-  public static void parseBasicParams(CommandLine commandLine) throws ParseException {\n-    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n-    outputFile = commandLine.getOptionValue(OUT_ARGS);\n-\n-    if (outputFile == null) {\n-      outputFile = \"tmp.txt\";\n-    }\n-  }\n-\n-  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n-    throws ParseException {\n-    String str = commandLine.getOptionValue(arg);\n-    if (str == null) {\n-      String msg = String.format(\"Required values for option '%s' not provided\", name);\n-      logger.info(msg);\n-      logger.info(\"Use -help for more information\");\n-      throw new ParseException(msg);\n-    }\n-    return str;\n-  }\n-\n-  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n-    try (MLogReader mLogReader = new MLogReader(inputFile);\n-         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n-\n-      while (mLogReader.hasNext()) {\n-        PhysicalPlan plan = mLogReader.next();\n-        switch (plan.getOperatorType()) {\n-          case CREATE_TIMESERIES:\n-            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n-              ((CreateTimeSeriesPlan) plan).getTagOffset());\n-            break;\n-          case DELETE_TIMESERIES:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteTimeseries(partialPath.getFullPath());\n-            }\n-            break;\n-          case SET_STORAGE_GROUP:\n-            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n-            break;\n-          case DELETE_STORAGE_GROUP:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteStorageGroup(partialPath.getFullPath());\n-            }\n-            break;\n-          case TTL:\n-            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n-              ((SetTTLPlan) plan).getDataTTL());\n-            break;\n-          case CHANGE_ALIAS:\n-            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n-              ((ChangeAliasPlan) plan).getAlias());\n-            break;\n-          case CHANGE_TAG_OFFSET:\n-            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n-              ((ChangeTagOffsetPlan) plan).getOffset());\n-            break;\n-          case MEASUREMENT_MNODE:\n-            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n-            break;\n-          case STORAGE_GROUP_MNODE:\n-            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n-            break;\n-          case MNODE:\n-            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n-            break;\n-          default:\n-            logger.warn(\"unknown plan {}\", plan);\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nnew file mode 100644\nindex 0000000000..56a7a1a6f8\n--- /dev/null\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (inputFile == null) {\n+      inputFile = reader.readLine(\"please input your mlog path:\", '\\0');\n+    }\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {\n+    String str = commandLine.getOptionValue(arg);\n+    if (str == null) {\n+      String msg = String.format(\"Required values for option '%s' not provided\", name);\n+      System.out.println(msg);\n+      System.out.println(\"Use -help for more information\");\n+      throw new Exception(msg);\n+    }\n+    return str;\n+  }\n+\n+  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n+    try (MLogReader mLogReader = new MLogReader(inputFile);\n+         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n+\n+      while (mLogReader.hasNext()) {\n+        PhysicalPlan plan = mLogReader.next();\n+        switch (plan.getOperatorType()) {\n+          case CREATE_TIMESERIES:\n+            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n+              ((CreateTimeSeriesPlan) plan).getTagOffset());\n+            break;\n+          case DELETE_TIMESERIES: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteTimeseries(pathList.get(i).getFullPath());\n+            }\n+          }\n+            break;\n+          case SET_STORAGE_GROUP:\n+            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n+            break;\n+          case DELETE_STORAGE_GROUP: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteStorageGroup(pathList.get(i).getFullPath());\n+            }\n+          }\n+          break;\n+          case TTL:\n+            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n+              ((SetTTLPlan) plan).getDataTTL());\n+            break;\n+          case CHANGE_ALIAS:\n+            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n+              ((ChangeAliasPlan) plan).getAlias());\n+            break;\n+          case CHANGE_TAG_OFFSET:\n+            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n+              ((ChangeTagOffsetPlan) plan).getOffset());\n+            break;\n+          case MEASUREMENT_MNODE:\n+            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n+            break;\n+          case STORAGE_GROUP_MNODE:\n+            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n+            break;\n+          case MNODE:\n+            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n+            break;\n+          default:\n+            System.out.println(\"unknown plan \" + plan.toString());\n+        }\n+      }\n+    }\n+  }\n+}\n", "next_change": {"commit": "92930ca36dbeb586f2be035f297eef6e4041162b", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 56a7a1a6f8..5a303cfbef 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -203,7 +186,7 @@ public class MLogParser {\n             mLogTxtWriter.serializeMNode((MNodePlan) plan);\n             break;\n           default:\n-            System.out.println(\"unknown plan \" + plan.toString());\n+            logger.warn(\"unknown plan {}\", plan);\n         }\n       }\n     }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxNDE1MQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529514151", "body": "It's not recommended to add braces `{}` here. Maybe we could extract `pathList ` outside the `switch` statement?", "bodyText": "It's not recommended to add braces {} here. Maybe we could extract pathList  outside the switch statement?", "bodyHTML": "<p dir=\"auto\">It's not recommended to add braces <code>{}</code> here. Maybe we could extract <code>pathList </code> outside the <code>switch</code> statement?</p>", "author": "samperson1997", "createdAt": "2020-11-24T12:39:26Z", "path": "server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {\n+    String str = commandLine.getOptionValue(arg);\n+    if (str == null) {\n+      String msg = String.format(\"Required values for option '%s' not provided\", name);\n+      System.out.println(msg);\n+      System.out.println(\"Use -help for more information\");\n+      throw new Exception(msg);\n+    }\n+    return str;\n+  }\n+\n+  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n+    try (MLogReader mLogReader = new MLogReader(inputFile);\n+         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n+\n+      while (mLogReader.hasNext()) {\n+        PhysicalPlan plan = mLogReader.next();\n+        switch (plan.getOperatorType()) {\n+          case CREATE_TIMESERIES:\n+            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n+              ((CreateTimeSeriesPlan) plan).getTagOffset());\n+            break;\n+          case DELETE_TIMESERIES: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (PartialPath partialPath : pathList) {\n+              mLogTxtWriter.deleteTimeseries(partialPath.getFullPath());\n+            }\n+          }", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MzEyNw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530063127", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-11-25T02:14:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxNDE1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 9963355b06..8261635479 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -154,23 +148,19 @@ public class MLogParser {\n             mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n               ((CreateTimeSeriesPlan) plan).getTagOffset());\n             break;\n-          case DELETE_TIMESERIES: {\n-            List<PartialPath> pathList = plan.getPaths();\n-            for (PartialPath partialPath : pathList) {\n+          case DELETE_TIMESERIES:\n+            for (PartialPath partialPath : plan.getPaths()) {\n               mLogTxtWriter.deleteTimeseries(partialPath.getFullPath());\n             }\n-          }\n             break;\n           case SET_STORAGE_GROUP:\n             mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n             break;\n-          case DELETE_STORAGE_GROUP: {\n-            List<PartialPath> pathList = plan.getPaths();\n-            for (PartialPath partialPath : pathList) {\n+          case DELETE_STORAGE_GROUP:\n+            for (PartialPath partialPath : plan.getPaths()) {\n               mLogTxtWriter.deleteStorageGroup(partialPath.getFullPath());\n             }\n-          }\n-          break;\n+            break;\n           case TTL:\n             mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n               ((SetTTLPlan) plan).getDataTTL());\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\ndeleted file mode 100644\nindex 8261635479..0000000000\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ /dev/null\n", "chunk": "@@ -1,191 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.iotdb.db.tools.mlog;\n-\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.DefaultParser;\n-import org.apache.commons.cli.HelpFormatter;\n-import org.apache.commons.cli.Option;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.ParseException;\n-import org.apache.iotdb.db.metadata.MLogTxtWriter;\n-import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.metadata.logfile.MLogReader;\n-import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n-\n-import java.io.IOException;\n-\n-/**\n- * parse the binary mlog or snapshot to text\n- */\n-public class MLogParser {\n-\n-  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n-\n-  private static final String FILE_ARGS = \"f\";\n-  private static final String FILE_NAME = \"mlog file\";\n-\n-  private static final String OUT_ARGS = \"o\";\n-  private static final String OUT_NAME = \"output txt file\";\n-\n-  private static final String HELP_ARGS = \"help\";\n-\n-  private static String inputFile;\n-  private static String outputFile;\n-\n-  /**\n-   * create the commandline options.\n-   *\n-   * @return object Options\n-   */\n-  public static Options createOptions() {\n-    Options options = new Options();\n-\n-    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n-      \"Need to specify a binary mlog file to parse (required)\")\n-      .build();\n-    options.addOption(opFile);\n-\n-    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n-      \"Could specify the output file after parse (optional)\")\n-      .build();\n-    options.addOption(opOut);\n-\n-    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n-      .hasArg(false).desc(\"Display help information\")\n-      .build();\n-    options.addOption(opHelp);\n-\n-    return options;\n-  }\n-\n-  public static void main(String[] args) {\n-    Options options = createOptions();\n-    HelpFormatter hf = new HelpFormatter();\n-    hf.setOptionComparator(null);\n-    CommandLine commandLine;\n-    CommandLineParser parser = new DefaultParser();\n-\n-    if (args == null || args.length == 0) {\n-      System.out.println(\"Too few params input, please check the following hint.\");\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    try {\n-      commandLine = parser.parse(options, args);\n-    } catch (ParseException e) {\n-      System.out.println(\"Parse error: \" + e.getMessage());\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    if (commandLine.hasOption(HELP_ARGS)) {\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-\n-    try {\n-      parseBasicParams(commandLine);\n-      parseFromFile(inputFile, outputFile);\n-    } catch (Exception e) {\n-      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n-    }\n-  }\n-\n-  public static void parseBasicParams(CommandLine commandLine) throws Exception {\n-    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n-    outputFile = commandLine.getOptionValue(OUT_ARGS);\n-\n-    if (outputFile == null) {\n-      outputFile = \"tmp.txt\";\n-    }\n-  }\n-\n-  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n-    throws ParseException {\n-    String str = commandLine.getOptionValue(arg);\n-    if (str == null) {\n-      String msg = String.format(\"Required values for option '%s' not provided\", name);\n-      System.out.println(msg);\n-      System.out.println(\"Use -help for more information\");\n-      throw new ParseException(msg);\n-    }\n-    return str;\n-  }\n-\n-  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n-    try (MLogReader mLogReader = new MLogReader(inputFile);\n-         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n-\n-      while (mLogReader.hasNext()) {\n-        PhysicalPlan plan = mLogReader.next();\n-        switch (plan.getOperatorType()) {\n-          case CREATE_TIMESERIES:\n-            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n-              ((CreateTimeSeriesPlan) plan).getTagOffset());\n-            break;\n-          case DELETE_TIMESERIES:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteTimeseries(partialPath.getFullPath());\n-            }\n-            break;\n-          case SET_STORAGE_GROUP:\n-            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n-            break;\n-          case DELETE_STORAGE_GROUP:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteStorageGroup(partialPath.getFullPath());\n-            }\n-            break;\n-          case TTL:\n-            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n-              ((SetTTLPlan) plan).getDataTTL());\n-            break;\n-          case CHANGE_ALIAS:\n-            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n-              ((ChangeAliasPlan) plan).getAlias());\n-            break;\n-          case CHANGE_TAG_OFFSET:\n-            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n-              ((ChangeTagOffsetPlan) plan).getOffset());\n-            break;\n-          case MEASUREMENT_MNODE:\n-            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n-            break;\n-          case STORAGE_GROUP_MNODE:\n-            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n-            break;\n-          case MNODE:\n-            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n-            break;\n-          default:\n-            System.out.println(\"unknown plan \" + plan.toString());\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nnew file mode 100644\nindex 0000000000..56a7a1a6f8\n--- /dev/null\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (inputFile == null) {\n+      inputFile = reader.readLine(\"please input your mlog path:\", '\\0');\n+    }\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {\n+    String str = commandLine.getOptionValue(arg);\n+    if (str == null) {\n+      String msg = String.format(\"Required values for option '%s' not provided\", name);\n+      System.out.println(msg);\n+      System.out.println(\"Use -help for more information\");\n+      throw new Exception(msg);\n+    }\n+    return str;\n+  }\n+\n+  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n+    try (MLogReader mLogReader = new MLogReader(inputFile);\n+         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n+\n+      while (mLogReader.hasNext()) {\n+        PhysicalPlan plan = mLogReader.next();\n+        switch (plan.getOperatorType()) {\n+          case CREATE_TIMESERIES:\n+            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n+              ((CreateTimeSeriesPlan) plan).getTagOffset());\n+            break;\n+          case DELETE_TIMESERIES: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteTimeseries(pathList.get(i).getFullPath());\n+            }\n+          }\n+            break;\n+          case SET_STORAGE_GROUP:\n+            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n+            break;\n+          case DELETE_STORAGE_GROUP: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteStorageGroup(pathList.get(i).getFullPath());\n+            }\n+          }\n+          break;\n+          case TTL:\n+            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n+              ((SetTTLPlan) plan).getDataTTL());\n+            break;\n+          case CHANGE_ALIAS:\n+            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n+              ((ChangeAliasPlan) plan).getAlias());\n+            break;\n+          case CHANGE_TAG_OFFSET:\n+            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n+              ((ChangeTagOffsetPlan) plan).getOffset());\n+            break;\n+          case MEASUREMENT_MNODE:\n+            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n+            break;\n+          case STORAGE_GROUP_MNODE:\n+            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n+            break;\n+          case MNODE:\n+            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n+            break;\n+          default:\n+            System.out.println(\"unknown plan \" + plan.toString());\n+        }\n+      }\n+    }\n+  }\n+}\n", "next_change": {"commit": "92930ca36dbeb586f2be035f297eef6e4041162b", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 56a7a1a6f8..5a303cfbef 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -203,7 +186,7 @@ public class MLogParser {\n             mLogTxtWriter.serializeMNode((MNodePlan) plan);\n             break;\n           default:\n-            System.out.println(\"unknown plan \" + plan.toString());\n+            logger.warn(\"unknown plan {}\", plan);\n         }\n       }\n     }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxNDI0MQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529514241", "body": "... so that braces `{}` could also be omitted here", "bodyText": "... so that braces {} could also be omitted here", "bodyHTML": "<p dir=\"auto\">... so that braces <code>{}</code> could also be omitted here</p>", "author": "samperson1997", "createdAt": "2020-11-24T12:39:34Z", "path": "server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {\n+    String str = commandLine.getOptionValue(arg);\n+    if (str == null) {\n+      String msg = String.format(\"Required values for option '%s' not provided\", name);\n+      System.out.println(msg);\n+      System.out.println(\"Use -help for more information\");\n+      throw new Exception(msg);\n+    }\n+    return str;\n+  }\n+\n+  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n+    try (MLogReader mLogReader = new MLogReader(inputFile);\n+         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n+\n+      while (mLogReader.hasNext()) {\n+        PhysicalPlan plan = mLogReader.next();\n+        switch (plan.getOperatorType()) {\n+          case CREATE_TIMESERIES:\n+            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n+              ((CreateTimeSeriesPlan) plan).getTagOffset());\n+            break;\n+          case DELETE_TIMESERIES: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (PartialPath partialPath : pathList) {\n+              mLogTxtWriter.deleteTimeseries(partialPath.getFullPath());\n+            }\n+          }\n+            break;\n+          case SET_STORAGE_GROUP:\n+            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n+            break;\n+          case DELETE_STORAGE_GROUP: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (PartialPath partialPath : pathList) {\n+              mLogTxtWriter.deleteStorageGroup(partialPath.getFullPath());\n+            }\n+          }", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 9963355b06..8261635479 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -154,23 +148,19 @@ public class MLogParser {\n             mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n               ((CreateTimeSeriesPlan) plan).getTagOffset());\n             break;\n-          case DELETE_TIMESERIES: {\n-            List<PartialPath> pathList = plan.getPaths();\n-            for (PartialPath partialPath : pathList) {\n+          case DELETE_TIMESERIES:\n+            for (PartialPath partialPath : plan.getPaths()) {\n               mLogTxtWriter.deleteTimeseries(partialPath.getFullPath());\n             }\n-          }\n             break;\n           case SET_STORAGE_GROUP:\n             mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n             break;\n-          case DELETE_STORAGE_GROUP: {\n-            List<PartialPath> pathList = plan.getPaths();\n-            for (PartialPath partialPath : pathList) {\n+          case DELETE_STORAGE_GROUP:\n+            for (PartialPath partialPath : plan.getPaths()) {\n               mLogTxtWriter.deleteStorageGroup(partialPath.getFullPath());\n             }\n-          }\n-          break;\n+            break;\n           case TTL:\n             mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n               ((SetTTLPlan) plan).getDataTTL());\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\ndeleted file mode 100644\nindex 8261635479..0000000000\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ /dev/null\n", "chunk": "@@ -1,191 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.iotdb.db.tools.mlog;\n-\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.DefaultParser;\n-import org.apache.commons.cli.HelpFormatter;\n-import org.apache.commons.cli.Option;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.ParseException;\n-import org.apache.iotdb.db.metadata.MLogTxtWriter;\n-import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.metadata.logfile.MLogReader;\n-import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n-\n-import java.io.IOException;\n-\n-/**\n- * parse the binary mlog or snapshot to text\n- */\n-public class MLogParser {\n-\n-  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n-\n-  private static final String FILE_ARGS = \"f\";\n-  private static final String FILE_NAME = \"mlog file\";\n-\n-  private static final String OUT_ARGS = \"o\";\n-  private static final String OUT_NAME = \"output txt file\";\n-\n-  private static final String HELP_ARGS = \"help\";\n-\n-  private static String inputFile;\n-  private static String outputFile;\n-\n-  /**\n-   * create the commandline options.\n-   *\n-   * @return object Options\n-   */\n-  public static Options createOptions() {\n-    Options options = new Options();\n-\n-    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n-      \"Need to specify a binary mlog file to parse (required)\")\n-      .build();\n-    options.addOption(opFile);\n-\n-    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n-      \"Could specify the output file after parse (optional)\")\n-      .build();\n-    options.addOption(opOut);\n-\n-    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n-      .hasArg(false).desc(\"Display help information\")\n-      .build();\n-    options.addOption(opHelp);\n-\n-    return options;\n-  }\n-\n-  public static void main(String[] args) {\n-    Options options = createOptions();\n-    HelpFormatter hf = new HelpFormatter();\n-    hf.setOptionComparator(null);\n-    CommandLine commandLine;\n-    CommandLineParser parser = new DefaultParser();\n-\n-    if (args == null || args.length == 0) {\n-      System.out.println(\"Too few params input, please check the following hint.\");\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    try {\n-      commandLine = parser.parse(options, args);\n-    } catch (ParseException e) {\n-      System.out.println(\"Parse error: \" + e.getMessage());\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    if (commandLine.hasOption(HELP_ARGS)) {\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-\n-    try {\n-      parseBasicParams(commandLine);\n-      parseFromFile(inputFile, outputFile);\n-    } catch (Exception e) {\n-      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n-    }\n-  }\n-\n-  public static void parseBasicParams(CommandLine commandLine) throws Exception {\n-    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n-    outputFile = commandLine.getOptionValue(OUT_ARGS);\n-\n-    if (outputFile == null) {\n-      outputFile = \"tmp.txt\";\n-    }\n-  }\n-\n-  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n-    throws ParseException {\n-    String str = commandLine.getOptionValue(arg);\n-    if (str == null) {\n-      String msg = String.format(\"Required values for option '%s' not provided\", name);\n-      System.out.println(msg);\n-      System.out.println(\"Use -help for more information\");\n-      throw new ParseException(msg);\n-    }\n-    return str;\n-  }\n-\n-  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n-    try (MLogReader mLogReader = new MLogReader(inputFile);\n-         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n-\n-      while (mLogReader.hasNext()) {\n-        PhysicalPlan plan = mLogReader.next();\n-        switch (plan.getOperatorType()) {\n-          case CREATE_TIMESERIES:\n-            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n-              ((CreateTimeSeriesPlan) plan).getTagOffset());\n-            break;\n-          case DELETE_TIMESERIES:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteTimeseries(partialPath.getFullPath());\n-            }\n-            break;\n-          case SET_STORAGE_GROUP:\n-            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n-            break;\n-          case DELETE_STORAGE_GROUP:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteStorageGroup(partialPath.getFullPath());\n-            }\n-            break;\n-          case TTL:\n-            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n-              ((SetTTLPlan) plan).getDataTTL());\n-            break;\n-          case CHANGE_ALIAS:\n-            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n-              ((ChangeAliasPlan) plan).getAlias());\n-            break;\n-          case CHANGE_TAG_OFFSET:\n-            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n-              ((ChangeTagOffsetPlan) plan).getOffset());\n-            break;\n-          case MEASUREMENT_MNODE:\n-            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n-            break;\n-          case STORAGE_GROUP_MNODE:\n-            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n-            break;\n-          case MNODE:\n-            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n-            break;\n-          default:\n-            System.out.println(\"unknown plan \" + plan.toString());\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nnew file mode 100644\nindex 0000000000..56a7a1a6f8\n--- /dev/null\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (inputFile == null) {\n+      inputFile = reader.readLine(\"please input your mlog path:\", '\\0');\n+    }\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {\n+    String str = commandLine.getOptionValue(arg);\n+    if (str == null) {\n+      String msg = String.format(\"Required values for option '%s' not provided\", name);\n+      System.out.println(msg);\n+      System.out.println(\"Use -help for more information\");\n+      throw new Exception(msg);\n+    }\n+    return str;\n+  }\n+\n+  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n+    try (MLogReader mLogReader = new MLogReader(inputFile);\n+         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n+\n+      while (mLogReader.hasNext()) {\n+        PhysicalPlan plan = mLogReader.next();\n+        switch (plan.getOperatorType()) {\n+          case CREATE_TIMESERIES:\n+            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n+              ((CreateTimeSeriesPlan) plan).getTagOffset());\n+            break;\n+          case DELETE_TIMESERIES: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteTimeseries(pathList.get(i).getFullPath());\n+            }\n+          }\n+            break;\n+          case SET_STORAGE_GROUP:\n+            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n+            break;\n+          case DELETE_STORAGE_GROUP: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteStorageGroup(pathList.get(i).getFullPath());\n+            }\n+          }\n+          break;\n+          case TTL:\n+            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n+              ((SetTTLPlan) plan).getDataTTL());\n+            break;\n+          case CHANGE_ALIAS:\n+            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n+              ((ChangeAliasPlan) plan).getAlias());\n+            break;\n+          case CHANGE_TAG_OFFSET:\n+            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n+              ((ChangeTagOffsetPlan) plan).getOffset());\n+            break;\n+          case MEASUREMENT_MNODE:\n+            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n+            break;\n+          case STORAGE_GROUP_MNODE:\n+            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n+            break;\n+          case MNODE:\n+            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n+            break;\n+          default:\n+            System.out.println(\"unknown plan \" + plan.toString());\n+        }\n+      }\n+    }\n+  }\n+}\n", "next_change": {"commit": "92930ca36dbeb586f2be035f297eef6e4041162b", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 56a7a1a6f8..5a303cfbef 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -203,7 +186,7 @@ public class MLogParser {\n             mLogTxtWriter.serializeMNode((MNodePlan) plan);\n             break;\n           default:\n-            System.out.println(\"unknown plan \" + plan.toString());\n+            logger.warn(\"unknown plan {}\", plan);\n         }\n       }\n     }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxNTE5Nw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529515197", "body": "I suggest to define and throw a specific exception. What do you think?", "bodyText": "I suggest to define and throw a specific exception. What do you think?", "bodyHTML": "<p dir=\"auto\">I suggest to define and throw a specific exception. What do you think?</p>", "author": "samperson1997", "createdAt": "2020-11-24T12:41:18Z", "path": "server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {\n+    String str = commandLine.getOptionValue(arg);\n+    if (str == null) {\n+      String msg = String.format(\"Required values for option '%s' not provided\", name);\n+      System.out.println(msg);\n+      System.out.println(\"Use -help for more information\");\n+      throw new Exception(msg);", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MzE2Nw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530063167", "bodyText": "yes", "author": "mychaow", "createdAt": "2020-11-25T02:14:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxNTE5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 9963355b06..8261635479 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -132,13 +126,13 @@ public class MLogParser {\n   }\n \n   public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n-    throws Exception {\n+    throws ParseException {\n     String str = commandLine.getOptionValue(arg);\n     if (str == null) {\n       String msg = String.format(\"Required values for option '%s' not provided\", name);\n       System.out.println(msg);\n       System.out.println(\"Use -help for more information\");\n-      throw new Exception(msg);\n+      throw new ParseException(msg);\n     }\n     return str;\n   }\n", "next_change": {"commit": "61c6f6d47b087075554ed4f3636d4990a6da4395", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 8261635479..f8bbbc6e6c 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -130,8 +133,8 @@ public class MLogParser {\n     String str = commandLine.getOptionValue(arg);\n     if (str == null) {\n       String msg = String.format(\"Required values for option '%s' not provided\", name);\n-      System.out.println(msg);\n-      System.out.println(\"Use -help for more information\");\n+      logger.info(msg);\n+      logger.info(\"Use -help for more information\");\n       throw new ParseException(msg);\n     }\n     return str;\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\ndeleted file mode 100644\nindex f8bbbc6e6c..0000000000\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ /dev/null\n", "chunk": "@@ -1,194 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.iotdb.db.tools.mlog;\n-\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.DefaultParser;\n-import org.apache.commons.cli.HelpFormatter;\n-import org.apache.commons.cli.Option;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.ParseException;\n-import org.apache.iotdb.db.metadata.MLogTxtWriter;\n-import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.metadata.logfile.MLogReader;\n-import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-\n-/**\n- * parse the binary mlog or snapshot to text\n- */\n-public class MLogParser {\n-\n-  private static final Logger logger = LoggerFactory.getLogger(MLogParser.class);\n-  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n-\n-  private static final String FILE_ARGS = \"f\";\n-  private static final String FILE_NAME = \"mlog file\";\n-\n-  private static final String OUT_ARGS = \"o\";\n-  private static final String OUT_NAME = \"output txt file\";\n-\n-  private static final String HELP_ARGS = \"help\";\n-\n-  private static String inputFile;\n-  private static String outputFile;\n-\n-  /**\n-   * create the commandline options.\n-   *\n-   * @return object Options\n-   */\n-  public static Options createOptions() {\n-    Options options = new Options();\n-\n-    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n-      \"Need to specify a binary mlog file to parse (required)\")\n-      .build();\n-    options.addOption(opFile);\n-\n-    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n-      \"Could specify the output file after parse (optional)\")\n-      .build();\n-    options.addOption(opOut);\n-\n-    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n-      .hasArg(false).desc(\"Display help information\")\n-      .build();\n-    options.addOption(opHelp);\n-\n-    return options;\n-  }\n-\n-  public static void main(String[] args) {\n-    Options options = createOptions();\n-    HelpFormatter hf = new HelpFormatter();\n-    hf.setOptionComparator(null);\n-    CommandLine commandLine;\n-    CommandLineParser parser = new DefaultParser();\n-\n-    if (args == null || args.length == 0) {\n-      logger.warn(\"Too few params input, please check the following hint.\");\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    try {\n-      commandLine = parser.parse(options, args);\n-    } catch (ParseException e) {\n-      logger.error(\"Parse error: {}\", e.getMessage());\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    if (commandLine.hasOption(HELP_ARGS)) {\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-\n-    try {\n-      parseBasicParams(commandLine);\n-      parseFromFile(inputFile, outputFile);\n-    } catch (Exception e) {\n-      logger.error(\"Encounter an error, because: {} \", e.getMessage());\n-    }\n-  }\n-\n-  public static void parseBasicParams(CommandLine commandLine) throws ParseException {\n-    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n-    outputFile = commandLine.getOptionValue(OUT_ARGS);\n-\n-    if (outputFile == null) {\n-      outputFile = \"tmp.txt\";\n-    }\n-  }\n-\n-  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n-    throws ParseException {\n-    String str = commandLine.getOptionValue(arg);\n-    if (str == null) {\n-      String msg = String.format(\"Required values for option '%s' not provided\", name);\n-      logger.info(msg);\n-      logger.info(\"Use -help for more information\");\n-      throw new ParseException(msg);\n-    }\n-    return str;\n-  }\n-\n-  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n-    try (MLogReader mLogReader = new MLogReader(inputFile);\n-         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n-\n-      while (mLogReader.hasNext()) {\n-        PhysicalPlan plan = mLogReader.next();\n-        switch (plan.getOperatorType()) {\n-          case CREATE_TIMESERIES:\n-            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n-              ((CreateTimeSeriesPlan) plan).getTagOffset());\n-            break;\n-          case DELETE_TIMESERIES:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteTimeseries(partialPath.getFullPath());\n-            }\n-            break;\n-          case SET_STORAGE_GROUP:\n-            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n-            break;\n-          case DELETE_STORAGE_GROUP:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteStorageGroup(partialPath.getFullPath());\n-            }\n-            break;\n-          case TTL:\n-            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n-              ((SetTTLPlan) plan).getDataTTL());\n-            break;\n-          case CHANGE_ALIAS:\n-            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n-              ((ChangeAliasPlan) plan).getAlias());\n-            break;\n-          case CHANGE_TAG_OFFSET:\n-            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n-              ((ChangeTagOffsetPlan) plan).getOffset());\n-            break;\n-          case MEASUREMENT_MNODE:\n-            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n-            break;\n-          case STORAGE_GROUP_MNODE:\n-            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n-            break;\n-          case MNODE:\n-            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n-            break;\n-          default:\n-            logger.warn(\"unknown plan {}\", plan);\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nnew file mode 100644\nindex 0000000000..56a7a1a6f8\n--- /dev/null\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (inputFile == null) {\n+      inputFile = reader.readLine(\"please input your mlog path:\", '\\0');\n+    }\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {\n+    String str = commandLine.getOptionValue(arg);\n+    if (str == null) {\n+      String msg = String.format(\"Required values for option '%s' not provided\", name);\n+      System.out.println(msg);\n+      System.out.println(\"Use -help for more information\");\n+      throw new Exception(msg);\n+    }\n+    return str;\n+  }\n+\n+  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n+    try (MLogReader mLogReader = new MLogReader(inputFile);\n+         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n+\n+      while (mLogReader.hasNext()) {\n+        PhysicalPlan plan = mLogReader.next();\n+        switch (plan.getOperatorType()) {\n+          case CREATE_TIMESERIES:\n+            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n+              ((CreateTimeSeriesPlan) plan).getTagOffset());\n+            break;\n+          case DELETE_TIMESERIES: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteTimeseries(pathList.get(i).getFullPath());\n+            }\n+          }\n+            break;\n+          case SET_STORAGE_GROUP:\n+            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n+            break;\n+          case DELETE_STORAGE_GROUP: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteStorageGroup(pathList.get(i).getFullPath());\n+            }\n+          }\n+          break;\n+          case TTL:\n+            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n+              ((SetTTLPlan) plan).getDataTTL());\n+            break;\n+          case CHANGE_ALIAS:\n+            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n+              ((ChangeAliasPlan) plan).getAlias());\n+            break;\n+          case CHANGE_TAG_OFFSET:\n+            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n+              ((ChangeTagOffsetPlan) plan).getOffset());\n+            break;\n+          case MEASUREMENT_MNODE:\n+            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n+            break;\n+          case STORAGE_GROUP_MNODE:\n+            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n+            break;\n+          case MNODE:\n+            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n+            break;\n+          default:\n+            System.out.println(\"unknown plan \" + plan.toString());\n+        }\n+      }\n+    }\n+  }\n+}\n", "next_change": {"commit": "92930ca36dbeb586f2be035f297eef6e4041162b", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 56a7a1a6f8..5a303cfbef 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -203,7 +186,7 @@ public class MLogParser {\n             mLogTxtWriter.serializeMNode((MNodePlan) plan);\n             break;\n           default:\n-            System.out.println(\"unknown plan \" + plan.toString());\n+            logger.warn(\"unknown plan {}\", plan);\n         }\n       }\n     }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxNTQxMw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529515413", "body": "... and this `Exception` could be more specific as well", "bodyText": "... and this Exception could be more specific as well", "bodyHTML": "<p dir=\"auto\">... and this <code>Exception</code> could be more specific as well</p>", "author": "samperson1997", "createdAt": "2020-11-24T12:41:38Z", "path": "server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 9963355b06..8261635479 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -132,13 +126,13 @@ public class MLogParser {\n   }\n \n   public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n-    throws Exception {\n+    throws ParseException {\n     String str = commandLine.getOptionValue(arg);\n     if (str == null) {\n       String msg = String.format(\"Required values for option '%s' not provided\", name);\n       System.out.println(msg);\n       System.out.println(\"Use -help for more information\");\n-      throw new Exception(msg);\n+      throw new ParseException(msg);\n     }\n     return str;\n   }\n", "next_change": {"commit": "61c6f6d47b087075554ed4f3636d4990a6da4395", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 8261635479..f8bbbc6e6c 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -130,8 +133,8 @@ public class MLogParser {\n     String str = commandLine.getOptionValue(arg);\n     if (str == null) {\n       String msg = String.format(\"Required values for option '%s' not provided\", name);\n-      System.out.println(msg);\n-      System.out.println(\"Use -help for more information\");\n+      logger.info(msg);\n+      logger.info(\"Use -help for more information\");\n       throw new ParseException(msg);\n     }\n     return str;\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\ndeleted file mode 100644\nindex f8bbbc6e6c..0000000000\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ /dev/null\n", "chunk": "@@ -1,194 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.iotdb.db.tools.mlog;\n-\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.DefaultParser;\n-import org.apache.commons.cli.HelpFormatter;\n-import org.apache.commons.cli.Option;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.ParseException;\n-import org.apache.iotdb.db.metadata.MLogTxtWriter;\n-import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.metadata.logfile.MLogReader;\n-import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-\n-/**\n- * parse the binary mlog or snapshot to text\n- */\n-public class MLogParser {\n-\n-  private static final Logger logger = LoggerFactory.getLogger(MLogParser.class);\n-  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n-\n-  private static final String FILE_ARGS = \"f\";\n-  private static final String FILE_NAME = \"mlog file\";\n-\n-  private static final String OUT_ARGS = \"o\";\n-  private static final String OUT_NAME = \"output txt file\";\n-\n-  private static final String HELP_ARGS = \"help\";\n-\n-  private static String inputFile;\n-  private static String outputFile;\n-\n-  /**\n-   * create the commandline options.\n-   *\n-   * @return object Options\n-   */\n-  public static Options createOptions() {\n-    Options options = new Options();\n-\n-    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n-      \"Need to specify a binary mlog file to parse (required)\")\n-      .build();\n-    options.addOption(opFile);\n-\n-    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n-      \"Could specify the output file after parse (optional)\")\n-      .build();\n-    options.addOption(opOut);\n-\n-    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n-      .hasArg(false).desc(\"Display help information\")\n-      .build();\n-    options.addOption(opHelp);\n-\n-    return options;\n-  }\n-\n-  public static void main(String[] args) {\n-    Options options = createOptions();\n-    HelpFormatter hf = new HelpFormatter();\n-    hf.setOptionComparator(null);\n-    CommandLine commandLine;\n-    CommandLineParser parser = new DefaultParser();\n-\n-    if (args == null || args.length == 0) {\n-      logger.warn(\"Too few params input, please check the following hint.\");\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    try {\n-      commandLine = parser.parse(options, args);\n-    } catch (ParseException e) {\n-      logger.error(\"Parse error: {}\", e.getMessage());\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    if (commandLine.hasOption(HELP_ARGS)) {\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-\n-    try {\n-      parseBasicParams(commandLine);\n-      parseFromFile(inputFile, outputFile);\n-    } catch (Exception e) {\n-      logger.error(\"Encounter an error, because: {} \", e.getMessage());\n-    }\n-  }\n-\n-  public static void parseBasicParams(CommandLine commandLine) throws ParseException {\n-    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n-    outputFile = commandLine.getOptionValue(OUT_ARGS);\n-\n-    if (outputFile == null) {\n-      outputFile = \"tmp.txt\";\n-    }\n-  }\n-\n-  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n-    throws ParseException {\n-    String str = commandLine.getOptionValue(arg);\n-    if (str == null) {\n-      String msg = String.format(\"Required values for option '%s' not provided\", name);\n-      logger.info(msg);\n-      logger.info(\"Use -help for more information\");\n-      throw new ParseException(msg);\n-    }\n-    return str;\n-  }\n-\n-  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n-    try (MLogReader mLogReader = new MLogReader(inputFile);\n-         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n-\n-      while (mLogReader.hasNext()) {\n-        PhysicalPlan plan = mLogReader.next();\n-        switch (plan.getOperatorType()) {\n-          case CREATE_TIMESERIES:\n-            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n-              ((CreateTimeSeriesPlan) plan).getTagOffset());\n-            break;\n-          case DELETE_TIMESERIES:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteTimeseries(partialPath.getFullPath());\n-            }\n-            break;\n-          case SET_STORAGE_GROUP:\n-            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n-            break;\n-          case DELETE_STORAGE_GROUP:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteStorageGroup(partialPath.getFullPath());\n-            }\n-            break;\n-          case TTL:\n-            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n-              ((SetTTLPlan) plan).getDataTTL());\n-            break;\n-          case CHANGE_ALIAS:\n-            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n-              ((ChangeAliasPlan) plan).getAlias());\n-            break;\n-          case CHANGE_TAG_OFFSET:\n-            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n-              ((ChangeTagOffsetPlan) plan).getOffset());\n-            break;\n-          case MEASUREMENT_MNODE:\n-            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n-            break;\n-          case STORAGE_GROUP_MNODE:\n-            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n-            break;\n-          case MNODE:\n-            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n-            break;\n-          default:\n-            logger.warn(\"unknown plan {}\", plan);\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nnew file mode 100644\nindex 0000000000..56a7a1a6f8\n--- /dev/null\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (inputFile == null) {\n+      inputFile = reader.readLine(\"please input your mlog path:\", '\\0');\n+    }\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {\n+    String str = commandLine.getOptionValue(arg);\n+    if (str == null) {\n+      String msg = String.format(\"Required values for option '%s' not provided\", name);\n+      System.out.println(msg);\n+      System.out.println(\"Use -help for more information\");\n+      throw new Exception(msg);\n+    }\n+    return str;\n+  }\n+\n+  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n+    try (MLogReader mLogReader = new MLogReader(inputFile);\n+         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n+\n+      while (mLogReader.hasNext()) {\n+        PhysicalPlan plan = mLogReader.next();\n+        switch (plan.getOperatorType()) {\n+          case CREATE_TIMESERIES:\n+            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n+              ((CreateTimeSeriesPlan) plan).getTagOffset());\n+            break;\n+          case DELETE_TIMESERIES: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteTimeseries(pathList.get(i).getFullPath());\n+            }\n+          }\n+            break;\n+          case SET_STORAGE_GROUP:\n+            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n+            break;\n+          case DELETE_STORAGE_GROUP: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteStorageGroup(pathList.get(i).getFullPath());\n+            }\n+          }\n+          break;\n+          case TTL:\n+            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n+              ((SetTTLPlan) plan).getDataTTL());\n+            break;\n+          case CHANGE_ALIAS:\n+            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n+              ((ChangeAliasPlan) plan).getAlias());\n+            break;\n+          case CHANGE_TAG_OFFSET:\n+            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n+              ((ChangeTagOffsetPlan) plan).getOffset());\n+            break;\n+          case MEASUREMENT_MNODE:\n+            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n+            break;\n+          case STORAGE_GROUP_MNODE:\n+            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n+            break;\n+          case MNODE:\n+            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n+            break;\n+          default:\n+            System.out.println(\"unknown plan \" + plan.toString());\n+        }\n+      }\n+    }\n+  }\n+}\n", "next_change": {"commit": "92930ca36dbeb586f2be035f297eef6e4041162b", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 56a7a1a6f8..5a303cfbef 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -203,7 +186,7 @@ public class MLogParser {\n             mLogTxtWriter.serializeMNode((MNodePlan) plan);\n             break;\n           default:\n-            System.out.println(\"unknown plan \" + plan.toString());\n+            logger.warn(\"unknown plan {}\", plan);\n         }\n       }\n     }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxNjA0Mg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529516042", "body": "Remove unused import", "bodyText": "Remove unused import", "bodyHTML": "<p dir=\"auto\">Remove unused import</p>", "author": "samperson1997", "createdAt": "2020-11-24T12:42:49Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.qp.physical.sys;\n+\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.logical.Operator;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\nindex 81e1c538fa..451475b1b0 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n", "chunk": "@@ -21,7 +21,6 @@ package org.apache.iotdb.db.qp.physical.sys;\n \n import org.apache.iotdb.db.metadata.PartialPath;\n import org.apache.iotdb.db.qp.logical.Operator;\n-import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n \n import java.io.DataOutputStream;\n import java.io.IOException;\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\nindex 451475b1b0..902a8a99f7 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n", "chunk": "@@ -21,6 +21,7 @@ package org.apache.iotdb.db.qp.physical.sys;\n \n import org.apache.iotdb.db.metadata.PartialPath;\n import org.apache.iotdb.db.qp.logical.Operator;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n \n import java.io.DataOutputStream;\n import java.io.IOException;\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\nindex 902a8a99f7..95b7229b31 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n", "chunk": "@@ -30,10 +30,8 @@ import java.util.ArrayList;\n import java.util.List;\n import java.util.Objects;\n \n-public class StorageGroupMNodePlan extends PhysicalPlan {\n-  private String name;\n+public class StorageGroupMNodePlan extends MNodePlan {\n   private long dataTTL;\n-  private int childSize;\n \n   public StorageGroupMNodePlan() {\n     super(false, Operator.OperatorType.STORAGE_GROUP_MNODE);\n", "next_change": null}]}}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\nindex 451475b1b0..902a8a99f7 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n", "chunk": "@@ -29,8 +30,10 @@ import java.util.ArrayList;\n import java.util.List;\n import java.util.Objects;\n \n-public class StorageGroupMNodePlan extends MNodePlan {\n+public class StorageGroupMNodePlan extends PhysicalPlan {\n+  private String name;\n   private long dataTTL;\n+  private int childSize;\n \n   public StorageGroupMNodePlan() {\n     super(false, Operator.OperatorType.STORAGE_GROUP_MNODE);\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\nindex 902a8a99f7..95b7229b31 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/physical/sys/StorageGroupMNodePlan.java\n", "chunk": "@@ -30,10 +30,8 @@ import java.util.ArrayList;\n import java.util.List;\n import java.util.Objects;\n \n-public class StorageGroupMNodePlan extends PhysicalPlan {\n-  private String name;\n+public class StorageGroupMNodePlan extends MNodePlan {\n   private long dataTTL;\n-  private int childSize;\n \n   public StorageGroupMNodePlan() {\n     super(false, Operator.OperatorType.STORAGE_GROUP_MNODE);\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUxODkwOA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529518908", "body": "```suggestion\r\n  private static final Logger logger = LoggerFactory.getLogger(MLogTxtReader.class);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static final Logger logger = LoggerFactory.getLogger(MLogReader.class);\n          \n          \n            \n              private static final Logger logger = LoggerFactory.getLogger(MLogTxtReader.class);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">  <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Logger</span> logger <span class=\"pl-k\">=</span> <span class=\"pl-smi\">LoggerFactory</span><span class=\"pl-k\">.</span>getLogger(<span class=\"pl-smi x x-first x-last\">MLogReader</span><span class=\"pl-k\">.</span>class);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Logger</span> logger <span class=\"pl-k\">=</span> <span class=\"pl-smi\">LoggerFactory</span><span class=\"pl-k\">.</span>getLogger(<span class=\"pl-smi x x-first x-last\">MLogTxtReader</span><span class=\"pl-k\">.</span>class);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "samperson1997", "createdAt": "2020-11-24T12:47:41Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+\n+/**\n+ * reader for reading mlog.txt\n+ */\n+public class MLogTxtReader implements AutoCloseable {\n+  private static final Logger logger = LoggerFactory.getLogger(MLogReader.class);", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java\nindex 912180c792..022d3bea58 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java\n", "chunk": "@@ -32,7 +32,7 @@ import java.io.IOException;\n  * reader for reading mlog.txt\n  */\n public class MLogTxtReader implements AutoCloseable {\n-  private static final Logger logger = LoggerFactory.getLogger(MLogReader.class);\n+  private static final Logger logger = LoggerFactory.getLogger(MLogTxtReader.class);\n \n   private BufferedReader bufferedReader;\n   private File logFile;\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/OldMLogReader.java\nsimilarity index 91%\nrename from server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java\nrename to server/src/main/java/org/apache/iotdb/db/metadata/logfile/OldMLogReader.java\nindex 022d3bea58..8e555967e7 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogTxtReader.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/OldMLogReader.java\n", "chunk": "@@ -28,17 +28,15 @@ import java.io.File;\n import java.io.FileReader;\n import java.io.IOException;\n \n-/**\n- * reader for reading mlog.txt\n- */\n-public class MLogTxtReader implements AutoCloseable {\n-  private static final Logger logger = LoggerFactory.getLogger(MLogTxtReader.class);\n+\n+public class OldMLogReader {\n+  private static final Logger logger = LoggerFactory.getLogger(MLogReader.class);\n \n   private BufferedReader bufferedReader;\n   private File logFile;\n   private String cmd;\n \n-  public MLogTxtReader(String schemaDir, String logFileName) throws IOException {\n+  public OldMLogReader(String schemaDir, String logFileName) throws IOException {\n     File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n     if (!metadataDir.exists()) {\n       logger.error(\"no mlog.txt to init MManager.\");\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyMjI3Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529522276", "body": "Refactor as below may be more logical:\r\n```\r\n        if (childrenSize != 0) {\r\n            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\r\n            for (int i = 0; i < childrenSize; i++) {\r\n              MNode child = nodeStack.removeFirst();\r\n              child.setParent(node);\r\n              childrenMap.put(child.getName(), child);\r\n              if (child instanceof MeasurementMNode) {\r\n                String alias = ((MeasurementMNode) child).getAlias();\r\n                if (alias != null) {\r\n                  node.addAlias(alias, child);\r\n                }\r\n              }\r\n            }\r\n            node.setChildren(childrenMap);\r\n          }\r\n          nodeStack.push(node);\r\n        }\r\n```", "bodyText": "Refactor as below may be more logical:\n        if (childrenSize != 0) {\n            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n            for (int i = 0; i < childrenSize; i++) {\n              MNode child = nodeStack.removeFirst();\n              child.setParent(node);\n              childrenMap.put(child.getName(), child);\n              if (child instanceof MeasurementMNode) {\n                String alias = ((MeasurementMNode) child).getAlias();\n                if (alias != null) {\n                  node.addAlias(alias, child);\n                }\n              }\n            }\n            node.setChildren(childrenMap);\n          }\n          nodeStack.push(node);\n        }", "bodyHTML": "<p dir=\"auto\">Refactor as below may be more logical:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"        if (childrenSize != 0) {\n            ConcurrentHashMap&lt;String, MNode&gt; childrenMap = new ConcurrentHashMap&lt;&gt;();\n            for (int i = 0; i &lt; childrenSize; i++) {\n              MNode child = nodeStack.removeFirst();\n              child.setParent(node);\n              childrenMap.put(child.getName(), child);\n              if (child instanceof MeasurementMNode) {\n                String alias = ((MeasurementMNode) child).getAlias();\n                if (alias != null) {\n                  node.addAlias(alias, child);\n                }\n              }\n            }\n            node.setChildren(childrenMap);\n          }\n          nodeStack.push(node);\n        }\n\"><pre><code>        if (childrenSize != 0) {\n            ConcurrentHashMap&lt;String, MNode&gt; childrenMap = new ConcurrentHashMap&lt;&gt;();\n            for (int i = 0; i &lt; childrenSize; i++) {\n              MNode child = nodeStack.removeFirst();\n              child.setParent(node);\n              childrenMap.put(child.getName(), child);\n              if (child instanceof MeasurementMNode) {\n                String alias = ((MeasurementMNode) child).getAlias();\n                if (alias != null) {\n                  node.addAlias(alias, child);\n                }\n              }\n            }\n            node.setChildren(childrenMap);\n          }\n          nodeStack.push(node);\n        }\n</code></pre></div>", "author": "samperson1997", "createdAt": "2020-11-24T12:53:27Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -1262,9 +1214,68 @@ private void findNodes(MNode node, PartialPath path, List<PartialPath> res, int\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (BufferedWriter bw = new BufferedWriter(\n-        new FileWriter(SystemFileFactory.INSTANCE.getFile(snapshotPath)))) {\n-      root.serializeTo(bw);\n+    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n+      root.serializeTo(mLogWriter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  public static MTree deserializeFrom(File mtreeSnapshot) {\n+\n+    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n+      Deque<MNode> nodeStack = new ArrayDeque<>();\n+      MNode node = null;\n+\n+      while (mlogReader.hasNext()) {\n+        PhysicalPlan plan = null;\n+        try {\n+          plan = mlogReader.next();\n+          if (plan == null) {\n+            continue;\n+          }\n+          int childrenSize = 0;\n+          if (plan instanceof StorageGroupMNodePlan) {\n+            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MeasurementMNodePlan) {\n+            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n+            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MNodePlan) {\n+            node = new MNode(null, ((MNodePlan) plan).getName());\n+            childrenSize = ((MNodePlan) plan).getChildSize();\n+          }\n+\n+          if (childrenSize == 0) {\n+            nodeStack.push(node);\n+          } else {\n+            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+            for (int i = 0; i < childrenSize; i++) {\n+              MNode child = nodeStack.removeFirst();\n+              child.setParent(node);\n+              childrenMap.put(child.getName(), child);\n+              if (child instanceof MeasurementMNode) {\n+                String alias = ((MeasurementMNode) child).getAlias();\n+                if (alias != null) {\n+                  node.addAlias(alias, child);\n+                }\n+              }\n+            }\n+            node.setChildren(childrenMap);\n+            nodeStack.push(node);\n+          }", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MzI2Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530063266", "bodyText": "Good idea!", "author": "mychaow", "createdAt": "2020-11-25T02:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyMjI3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 5b4bfcd5ac..314af82411 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1219,55 +1218,9 @@ public class MTree implements Serializable {\n     }\n   }\n \n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-\n-    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n-      Deque<MNode> nodeStack = new ArrayDeque<>();\n-      MNode node = null;\n-\n-      while (mlogReader.hasNext()) {\n-        PhysicalPlan plan = null;\n-        try {\n-          plan = mlogReader.next();\n-          if (plan == null) {\n-            continue;\n-          }\n-          int childrenSize = 0;\n-          if (plan instanceof StorageGroupMNodePlan) {\n-            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n-            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MeasurementMNodePlan) {\n-            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n-            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MNodePlan) {\n-            node = new MNode(null, ((MNodePlan) plan).getName());\n-            childrenSize = ((MNodePlan) plan).getChildSize();\n-          }\n-\n-          if (childrenSize == 0) {\n-            nodeStack.push(node);\n-          } else {\n-            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n-            for (int i = 0; i < childrenSize; i++) {\n-              MNode child = nodeStack.removeFirst();\n-              child.setParent(node);\n-              childrenMap.put(child.getName(), child);\n-              if (child instanceof MeasurementMNode) {\n-                String alias = ((MeasurementMNode) child).getAlias();\n-                if (alias != null) {\n-                  node.addAlias(alias, child);\n-                }\n-              }\n-            }\n-            node.setChildren(childrenMap);\n-            nodeStack.push(node);\n-          }\n-        } catch (Exception e) {\n-          logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n-        }\n-      }\n-      return new MTree(node);\n+    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n+      return deserializeFromReader(mLogReader);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 314af82411..1b0807e9d5 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1213,18 +1218,74 @@ public class MTree implements Serializable {\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n+    MLogWriter mLogWriter = null;\n+    try {\n+      mLogWriter = new MLogWriter(snapshotPath);\n       root.serializeTo(mLogWriter);\n+    } finally {\n+      if (mLogWriter != null) {\n+        mLogWriter.close();\n+      }\n     }\n   }\n \n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n-      return deserializeFromReader(mLogReader);\n+    MLogReader mlogReader = null;\n+    try {\n+      mlogReader = new MLogReader(mtreeSnapshot);\n+      Deque<MNode> nodeStack = new ArrayDeque<>();\n+      MNode node = null;\n+\n+      while (mlogReader.hasNext()) {\n+        PhysicalPlan plan = null;\n+        try {\n+          plan = mlogReader.next();\n+          if (plan == null) {\n+            continue;\n+          }\n+          int childrenSize = 0;\n+          if (plan instanceof StorageGroupMNodePlan) {\n+            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MeasurementNodePlan) {\n+            node = MeasurementMNode.deserializeFrom((MeasurementNodePlan) plan);\n+            childrenSize = ((MeasurementNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MNodePlan) {\n+            node = new MNode(null, ((MNodePlan) plan).getName());\n+            childrenSize = ((MNodePlan) plan).getChildSize();\n+          }\n+\n+          if (childrenSize == 0) {\n+            nodeStack.push(node);\n+          } else {\n+            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+            for (int i = 0; i < childrenSize; i++) {\n+              MNode child = nodeStack.removeFirst();\n+              child.setParent(node);\n+              childrenMap.put(child.getName(), child);\n+              if (child instanceof MeasurementMNode) {\n+                String alias = ((MeasurementMNode) child).getAlias();\n+                if (alias != null) {\n+                  node.addAlias(alias, child);\n+                }\n+              }\n+            }\n+            node.setChildren(childrenMap);\n+            nodeStack.push(node);\n+          }\n+        } catch (Exception e) {\n+          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n+        }\n+      }\n+      return new MTree(node);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n     } finally {\n+      if (mlogReader != null) {\n+        mlogReader.close();\n+      }\n       limit = new ThreadLocal<>();\n       offset = new ThreadLocal<>();\n       count = new ThreadLocal<>();\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 1b0807e9d5..31fbef0463 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1283,9 +1276,6 @@ public class MTree implements Serializable {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n     } finally {\n-      if (mlogReader != null) {\n-        mlogReader.close();\n-      }\n       limit = new ThreadLocal<>();\n       offset = new ThreadLocal<>();\n       count = new ThreadLocal<>();\n", "next_change": {"commit": "bc0aea4a6ee1f92a2b379da57acb77ad20a447a1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 31fbef0463..a0e62f2ca2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1223,55 +1222,9 @@ public class MTree implements Serializable {\n     }\n   }\n \n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-\n-    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n-      Deque<MNode> nodeStack = new ArrayDeque<>();\n-      MNode node = null;\n-\n-      while (mlogReader.hasNext()) {\n-        PhysicalPlan plan = null;\n-        try {\n-          plan = mlogReader.next();\n-          if (plan == null) {\n-            continue;\n-          }\n-          int childrenSize = 0;\n-          if (plan instanceof StorageGroupMNodePlan) {\n-            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n-            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MeasurementMNodePlan) {\n-            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n-            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MNodePlan) {\n-            node = new MNode(null, ((MNodePlan) plan).getName());\n-            childrenSize = ((MNodePlan) plan).getChildSize();\n-          }\n-\n-          if (childrenSize == 0) {\n-            nodeStack.push(node);\n-          } else {\n-            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n-            for (int i = 0; i < childrenSize; i++) {\n-              MNode child = nodeStack.removeFirst();\n-              child.setParent(node);\n-              childrenMap.put(child.getName(), child);\n-              if (child instanceof MeasurementMNode) {\n-                String alias = ((MeasurementMNode) child).getAlias();\n-                if (alias != null) {\n-                  node.addAlias(alias, child);\n-                }\n-              }\n-            }\n-            node.setChildren(childrenMap);\n-            nodeStack.push(node);\n-          }\n-        } catch (Exception e) {\n-          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n-        }\n-      }\n-      return new MTree(node);\n+    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n+      return deserializeFromReader(mLogReader);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n", "next_change": null}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 31fbef0463..a0e62f2ca2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1283,6 +1236,53 @@ public class MTree implements Serializable {\n     }\n   }\n \n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  private static MTree deserializeFromReader(MLogReader mLogReader) {\n+    Deque<MNode> nodeStack = new ArrayDeque<>();\n+    MNode node = null;\n+    while (mLogReader.hasNext()) {\n+      PhysicalPlan plan = null;\n+      try {\n+        plan = mLogReader.next();\n+        if (plan == null) {\n+          continue;\n+        }\n+        int childrenSize = 0;\n+        if (plan instanceof StorageGroupMNodePlan) {\n+          node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+          childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+        } else if (plan instanceof MeasurementMNodePlan) {\n+          node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n+          childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n+        } else if (plan instanceof MNodePlan) {\n+          node = new MNode(null, ((MNodePlan) plan).getName());\n+          childrenSize = ((MNodePlan) plan).getChildSize();\n+        }\n+\n+        if (childrenSize != 0) {\n+          ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+          for (int i = 0; i < childrenSize; i++) {\n+            MNode child = nodeStack.removeFirst();\n+            child.setParent(node);\n+            childrenMap.put(child.getName(), child);\n+            if (child instanceof MeasurementMNode) {\n+              String alias = ((MeasurementMNode) child).getAlias();\n+              if (alias != null) {\n+                node.addAlias(alias, child);\n+              }\n+            }\n+          }\n+          node.setChildren(childrenMap);\n+        }\n+        nodeStack.push(node);\n+      } catch (Exception e) {\n+        logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n+      }\n+    }\n+\n+    return new MTree(node);\n+  }\n+\n   @Override\n   public String toString() {\n     JsonObject jsonObject = new JsonObject();\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyMjg1NA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529522854", "body": "Maybe this `Exception` could be more specific too?", "bodyText": "Maybe this Exception could be more specific too?", "bodyHTML": "<p dir=\"auto\">Maybe this <code>Exception</code> could be more specific too?</p>", "author": "samperson1997", "createdAt": "2020-11-24T12:54:17Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -1262,9 +1214,68 @@ private void findNodes(MNode node, PartialPath path, List<PartialPath> res, int\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (BufferedWriter bw = new BufferedWriter(\n-        new FileWriter(SystemFileFactory.INSTANCE.getFile(snapshotPath)))) {\n-      root.serializeTo(bw);\n+    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n+      root.serializeTo(mLogWriter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  public static MTree deserializeFrom(File mtreeSnapshot) {\n+\n+    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n+      Deque<MNode> nodeStack = new ArrayDeque<>();\n+      MNode node = null;\n+\n+      while (mlogReader.hasNext()) {\n+        PhysicalPlan plan = null;\n+        try {\n+          plan = mlogReader.next();\n+          if (plan == null) {\n+            continue;\n+          }\n+          int childrenSize = 0;\n+          if (plan instanceof StorageGroupMNodePlan) {\n+            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MeasurementMNodePlan) {\n+            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n+            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MNodePlan) {\n+            node = new MNode(null, ((MNodePlan) plan).getName());\n+            childrenSize = ((MNodePlan) plan).getChildSize();\n+          }\n+\n+          if (childrenSize == 0) {\n+            nodeStack.push(node);\n+          } else {\n+            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+            for (int i = 0; i < childrenSize; i++) {\n+              MNode child = nodeStack.removeFirst();\n+              child.setParent(node);\n+              childrenMap.put(child.getName(), child);\n+              if (child instanceof MeasurementMNode) {\n+                String alias = ((MeasurementMNode) child).getAlias();\n+                if (alias != null) {\n+                  node.addAlias(alias, child);\n+                }\n+              }\n+            }\n+            node.setChildren(childrenMap);\n+            nodeStack.push(node);\n+          }\n+        } catch (Exception e) {", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI0ODkwMQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530248901", "bodyText": "catch all exception", "author": "mychaow", "createdAt": "2020-11-25T10:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyMjg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 5b4bfcd5ac..314af82411 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1219,55 +1218,9 @@ public class MTree implements Serializable {\n     }\n   }\n \n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-\n-    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n-      Deque<MNode> nodeStack = new ArrayDeque<>();\n-      MNode node = null;\n-\n-      while (mlogReader.hasNext()) {\n-        PhysicalPlan plan = null;\n-        try {\n-          plan = mlogReader.next();\n-          if (plan == null) {\n-            continue;\n-          }\n-          int childrenSize = 0;\n-          if (plan instanceof StorageGroupMNodePlan) {\n-            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n-            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MeasurementMNodePlan) {\n-            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n-            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MNodePlan) {\n-            node = new MNode(null, ((MNodePlan) plan).getName());\n-            childrenSize = ((MNodePlan) plan).getChildSize();\n-          }\n-\n-          if (childrenSize == 0) {\n-            nodeStack.push(node);\n-          } else {\n-            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n-            for (int i = 0; i < childrenSize; i++) {\n-              MNode child = nodeStack.removeFirst();\n-              child.setParent(node);\n-              childrenMap.put(child.getName(), child);\n-              if (child instanceof MeasurementMNode) {\n-                String alias = ((MeasurementMNode) child).getAlias();\n-                if (alias != null) {\n-                  node.addAlias(alias, child);\n-                }\n-              }\n-            }\n-            node.setChildren(childrenMap);\n-            nodeStack.push(node);\n-          }\n-        } catch (Exception e) {\n-          logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n-        }\n-      }\n-      return new MTree(node);\n+    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n+      return deserializeFromReader(mLogReader);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 314af82411..1b0807e9d5 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1213,18 +1218,74 @@ public class MTree implements Serializable {\n   }\n \n   public void serializeTo(String snapshotPath) throws IOException {\n-    try (MLogWriter mLogWriter = new MLogWriter(snapshotPath)) {\n+    MLogWriter mLogWriter = null;\n+    try {\n+      mLogWriter = new MLogWriter(snapshotPath);\n       root.serializeTo(mLogWriter);\n+    } finally {\n+      if (mLogWriter != null) {\n+        mLogWriter.close();\n+      }\n     }\n   }\n \n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n-      return deserializeFromReader(mLogReader);\n+    MLogReader mlogReader = null;\n+    try {\n+      mlogReader = new MLogReader(mtreeSnapshot);\n+      Deque<MNode> nodeStack = new ArrayDeque<>();\n+      MNode node = null;\n+\n+      while (mlogReader.hasNext()) {\n+        PhysicalPlan plan = null;\n+        try {\n+          plan = mlogReader.next();\n+          if (plan == null) {\n+            continue;\n+          }\n+          int childrenSize = 0;\n+          if (plan instanceof StorageGroupMNodePlan) {\n+            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MeasurementNodePlan) {\n+            node = MeasurementMNode.deserializeFrom((MeasurementNodePlan) plan);\n+            childrenSize = ((MeasurementNodePlan) plan).getChildSize();\n+          } else if (plan instanceof MNodePlan) {\n+            node = new MNode(null, ((MNodePlan) plan).getName());\n+            childrenSize = ((MNodePlan) plan).getChildSize();\n+          }\n+\n+          if (childrenSize == 0) {\n+            nodeStack.push(node);\n+          } else {\n+            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+            for (int i = 0; i < childrenSize; i++) {\n+              MNode child = nodeStack.removeFirst();\n+              child.setParent(node);\n+              childrenMap.put(child.getName(), child);\n+              if (child instanceof MeasurementMNode) {\n+                String alias = ((MeasurementMNode) child).getAlias();\n+                if (alias != null) {\n+                  node.addAlias(alias, child);\n+                }\n+              }\n+            }\n+            node.setChildren(childrenMap);\n+            nodeStack.push(node);\n+          }\n+        } catch (Exception e) {\n+          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n+        }\n+      }\n+      return new MTree(node);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n     } finally {\n+      if (mlogReader != null) {\n+        mlogReader.close();\n+      }\n       limit = new ThreadLocal<>();\n       offset = new ThreadLocal<>();\n       count = new ThreadLocal<>();\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 1b0807e9d5..31fbef0463 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1283,9 +1276,6 @@ public class MTree implements Serializable {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n     } finally {\n-      if (mlogReader != null) {\n-        mlogReader.close();\n-      }\n       limit = new ThreadLocal<>();\n       offset = new ThreadLocal<>();\n       count = new ThreadLocal<>();\n", "next_change": {"commit": "bc0aea4a6ee1f92a2b379da57acb77ad20a447a1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 31fbef0463..a0e62f2ca2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1223,55 +1222,9 @@ public class MTree implements Serializable {\n     }\n   }\n \n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public static MTree deserializeFrom(File mtreeSnapshot) {\n-\n-    try (MLogReader mlogReader = new MLogReader(mtreeSnapshot)) {\n-      Deque<MNode> nodeStack = new ArrayDeque<>();\n-      MNode node = null;\n-\n-      while (mlogReader.hasNext()) {\n-        PhysicalPlan plan = null;\n-        try {\n-          plan = mlogReader.next();\n-          if (plan == null) {\n-            continue;\n-          }\n-          int childrenSize = 0;\n-          if (plan instanceof StorageGroupMNodePlan) {\n-            node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n-            childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MeasurementMNodePlan) {\n-            node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n-            childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n-          } else if (plan instanceof MNodePlan) {\n-            node = new MNode(null, ((MNodePlan) plan).getName());\n-            childrenSize = ((MNodePlan) plan).getChildSize();\n-          }\n-\n-          if (childrenSize == 0) {\n-            nodeStack.push(node);\n-          } else {\n-            ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n-            for (int i = 0; i < childrenSize; i++) {\n-              MNode child = nodeStack.removeFirst();\n-              child.setParent(node);\n-              childrenMap.put(child.getName(), child);\n-              if (child instanceof MeasurementMNode) {\n-                String alias = ((MeasurementMNode) child).getAlias();\n-                if (alias != null) {\n-                  node.addAlias(alias, child);\n-                }\n-              }\n-            }\n-            node.setChildren(childrenMap);\n-            nodeStack.push(node);\n-          }\n-        } catch (Exception e) {\n-          logger.error(\"Can not operate cmd {} for err:\", plan.getOperatorType(), e);\n-        }\n-      }\n-      return new MTree(node);\n+    try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) {\n+      return deserializeFromReader(mLogReader);\n     } catch (IOException e) {\n       logger.warn(\"Failed to deserialize from {}. Use a new MTree.\", mtreeSnapshot.getPath());\n       return new MTree();\n", "next_change": null}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\nindex 31fbef0463..a0e62f2ca2 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MTree.java\n", "chunk": "@@ -1283,6 +1236,53 @@ public class MTree implements Serializable {\n     }\n   }\n \n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  private static MTree deserializeFromReader(MLogReader mLogReader) {\n+    Deque<MNode> nodeStack = new ArrayDeque<>();\n+    MNode node = null;\n+    while (mLogReader.hasNext()) {\n+      PhysicalPlan plan = null;\n+      try {\n+        plan = mLogReader.next();\n+        if (plan == null) {\n+          continue;\n+        }\n+        int childrenSize = 0;\n+        if (plan instanceof StorageGroupMNodePlan) {\n+          node = StorageGroupMNode.deserializeFrom((StorageGroupMNodePlan) plan);\n+          childrenSize = ((StorageGroupMNodePlan) plan).getChildSize();\n+        } else if (plan instanceof MeasurementMNodePlan) {\n+          node = MeasurementMNode.deserializeFrom((MeasurementMNodePlan) plan);\n+          childrenSize = ((MeasurementMNodePlan) plan).getChildSize();\n+        } else if (plan instanceof MNodePlan) {\n+          node = new MNode(null, ((MNodePlan) plan).getName());\n+          childrenSize = ((MNodePlan) plan).getChildSize();\n+        }\n+\n+        if (childrenSize != 0) {\n+          ConcurrentHashMap<String, MNode> childrenMap = new ConcurrentHashMap<>();\n+          for (int i = 0; i < childrenSize; i++) {\n+            MNode child = nodeStack.removeFirst();\n+            child.setParent(node);\n+            childrenMap.put(child.getName(), child);\n+            if (child instanceof MeasurementMNode) {\n+              String alias = ((MeasurementMNode) child).getAlias();\n+              if (alias != null) {\n+                node.addAlias(alias, child);\n+              }\n+            }\n+          }\n+          node.setChildren(childrenMap);\n+        }\n+        nodeStack.push(node);\n+      } catch (Exception e) {\n+        logger.error(\"Can not operate cmd {} for err:\", plan == null ? \"\" : plan.getOperatorType(), e);\n+      }\n+    }\n+\n+    return new MTree(node);\n+  }\n+\n   @Override\n   public String toString() {\n     JsonObject jsonObject = new JsonObject();\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyNjE4MQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r529526181", "body": "Do you think it is necessary to delete all these codes (`upgradePropertiesFile`, `checkUnClosedTsFileV2`, `checkUnClosedTsFileV2InFolders`) now? I think this check should be modified before 0.12 is released... Or the users who are using v0.9 and intending to upgrade to master may encounter problems ... @qiaojialin ", "bodyText": "Do you think it is necessary to delete all these codes (upgradePropertiesFile, checkUnClosedTsFileV2, checkUnClosedTsFileV2InFolders) now? I think this check should be modified before 0.12 is released... Or the users who are using v0.9 and intending to upgrade to master may encounter problems ... @qiaojialin", "bodyHTML": "<p dir=\"auto\">Do you think it is necessary to delete all these codes (<code>upgradePropertiesFile</code>, <code>checkUnClosedTsFileV2</code>, <code>checkUnClosedTsFileV2InFolders</code>) now? I think this check should be modified before 0.12 is released... Or the users who are using v0.9 and intending to upgrade to master may encounter problems ... <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/qiaojialin/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/qiaojialin\">@qiaojialin</a></p>", "author": "samperson1997", "createdAt": "2020-11-24T12:59:42Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -184,51 +185,16 @@ public void checkConfig() throws IOException {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.11", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0ODQ2MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530048460", "bodyText": "Agree with @samperson1997", "author": "HTHou", "createdAt": "2020-11-25T01:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyNjE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MzA0Mw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530063043", "bodyText": "I think user should upgrade to 0.11, then upgrade to 0.12. So the function is not useful in 0.12.", "author": "mychaow", "createdAt": "2020-11-25T02:13:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyNjE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2NjY5MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530066690", "bodyText": "I mean these methods could be left here. I'll modify and reuse these methods when I implement the upgrade tool.  For now, I think it is OK to do not call these methods.", "author": "HTHou", "createdAt": "2020-11-25T02:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyNjE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI0ODE4Mg==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530248182", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-11-25T10:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyNjE4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 0ca9b49734..be1689ec8e 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -188,7 +188,7 @@ public class IoTDBConfigCheck {\n     // check whether upgrading from v0.9 to v0.12\n     if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n       properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n           + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n", "next_change": {"commit": "61c6f6d47b087075554ed4f3636d4990a6da4395", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex be1689ec8e..9d7efd1c86 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,23 +185,33 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.12\n+    // check whether upgrading from <=v0.10 to v0.12\n     if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n       properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n       logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n           + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n+\n+    // check whether upgrading from v0.11 to v0.12\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n+      logger.info(\"Upgrading IoTDB from v0.11 to v0.12, checking files...\");\n+      checkUnClosedTsFileV2();\n+      upgradePropertiesFile();\n+      logger.info(\"Upgrade to IoTDB v0.12 successfully!\");\n+    }\n+\n     MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n \n   /**\n-   * upgrade 0.10 properties to 0.11 properties\n+   * upgrade 0.11 properties to 0.12 properties\n    */\n+  @SuppressWarnings(\"unused\")\n   private void upgradePropertiesFile()\n-    throws IOException {\n+      throws IOException {\n     // create an empty tmpPropertiesFile\n     if (tmpPropertiesFile.createNewFile()) {\n       logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 9d7efd1c86..c1274ac49f 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,29 +185,45 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from <=v0.10 to v0.12\n-    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n-      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n-          + \" Please upgrade to v0.11 first\");\n+    // check whether upgrading\n+    if (!properties.containsKey(IOTDB_VERSION_STRING)\n+        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")\n+        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.11 or lower version NOW\");\n       System.exit(-1);\n     }\n \n-    // check whether upgrading from v0.11 to v0.12\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n-      logger.info(\"Upgrading IoTDB from v0.11 to v0.12, checking files...\");\n+    // check whether upgrading from v0.10 to v0.11\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n       checkUnClosedTsFileV2();\n       upgradePropertiesFile();\n-      logger.info(\"Upgrade to IoTDB v0.12 successfully!\");\n-    }\n+      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n+\n+      // upgrade mlog finished, delete old mlog file\n+      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+          + MetadataConstant.METADATA_LOG);\n+      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n+          + \".tmp\");\n+\n+      if (!mlogFile.delete()) {\n+        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n+      }\n+      // rename tmpLogFile to mlog\n+      FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n-    MLogWriter.upgradeMLog();\n+      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+          + MetadataConstant.METADATA_OLD_LOG);\n \n+      if (oldMLogFile.delete()) {\n+        throw new IOException(\"Deleting old mlog \" + oldMLogFile + \"failed.\");\n+      }\n+    }\n     checkProperties();\n   }\n \n   /**\n-   * upgrade 0.11 properties to 0.12 properties\n+   * upgrade 0.10 properties to 0.11 properties\n    */\n   @SuppressWarnings(\"unused\")\n   private void upgradePropertiesFile()\n", "next_change": {"commit": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex c1274ac49f..d00a287f5a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,44 +185,20 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)\n-        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")\n-        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.11 or lower version NOW\");\n+    // check whether upgrading from v0.9 to v0.12\n+    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n+      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n+          + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n+    MLogWriter.upgradeMLog();\n \n-    // check whether upgrading from v0.10 to v0.11\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n-      checkUnClosedTsFileV2();\n-      upgradePropertiesFile();\n-      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-          + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n-\n-      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_OLD_LOG);\n-\n-      if (oldMLogFile.delete()) {\n-        throw new IOException(\"Deleting old mlog \" + oldMLogFile + \"failed.\");\n-      }\n-    }\n     checkProperties();\n   }\n \n   /**\n+<<<<<<< HEAD\n    * upgrade 0.10 properties to 0.11 properties\n    */\n   @SuppressWarnings(\"unused\")\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex d00a287f5a..9db3407287 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -198,7 +198,6 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n-<<<<<<< HEAD\n    * upgrade 0.10 properties to 0.11 properties\n    */\n   @SuppressWarnings(\"unused\")\n", "next_change": {"commit": "c76cb3eb323ec320cc7b257caa530bc85e17be82", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 9db3407287..0fe2bf1f60 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,20 +185,29 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.12\n+    // check whether upgrading from <=v0.10 to v0.12\n     if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n       properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n       logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n           + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n+\n+    // check whether upgrading from v0.11 to v0.12\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.info(\"Upgrading IoTDB from v0.11 to v0.12, checking files...\");\n+      checkUnClosedTsFileV2();\n+      upgradePropertiesFile();\n+      logger.info(\"Upgrade to IoTDB v0.12 successfully!\");\n+    }\n+\n     MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n \n   /**\n-   * upgrade 0.10 properties to 0.11 properties\n+   * upgrade 0.11 properties to 0.12 properties\n    */\n   @SuppressWarnings(\"unused\")\n   private void upgradePropertiesFile()\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MjA0Nw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530062047", "body": "If there is a comma in the path of a timeseries, the length of args[] will be larger than 8.\r\nI think adding these lines back is better.\r\n```\r\n        if (args.length > 8) {\t\r\n          String[] tmpArgs = new String[8];\t\r\n          tmpArgs[0] = args[0];\t\r\n          int i = 1;\t\r\n          tmpArgs[1] = \"\";\t\r\n          for (; i < args.length - 7; i++) {\t\r\n            tmpArgs[1] += args[i] + \",\";\t\r\n          }\t\r\n          tmpArgs[1] += args[i++];\t\r\n          for (int j = 2; j < 8; j++) {\t\r\n            tmpArgs[j] = args[i++];\t\r\n          }\t\r\n          args = tmpArgs;\t\r\n        }\r\n```", "bodyText": "If there is a comma in the path of a timeseries, the length of args[] will be larger than 8.\nI think adding these lines back is better.\n        if (args.length > 8) {\t\n          String[] tmpArgs = new String[8];\t\n          tmpArgs[0] = args[0];\t\n          int i = 1;\t\n          tmpArgs[1] = \"\";\t\n          for (; i < args.length - 7; i++) {\t\n            tmpArgs[1] += args[i] + \",\";\t\n          }\t\n          tmpArgs[1] += args[i++];\t\n          for (int j = 2; j < 8; j++) {\t\n            tmpArgs[j] = args[i++];\t\n          }\t\n          args = tmpArgs;\t\n        }", "bodyHTML": "<p dir=\"auto\">If there is a comma in the path of a timeseries, the length of args[] will be larger than 8.<br>\nI think adding these lines back is better.</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"        if (args.length &gt; 8) {\t\n          String[] tmpArgs = new String[8];\t\n          tmpArgs[0] = args[0];\t\n          int i = 1;\t\n          tmpArgs[1] = &quot;&quot;;\t\n          for (; i &lt; args.length - 7; i++) {\t\n            tmpArgs[1] += args[i] + &quot;,&quot;;\t\n          }\t\n          tmpArgs[1] += args[i++];\t\n          for (int j = 2; j &lt; 8; j++) {\t\n            tmpArgs[j] = args[i++];\t\n          }\t\n          args = tmpArgs;\t\n        }\n\"><pre><code>        if (args.length &gt; 8) {\t\n          String[] tmpArgs = new String[8];\t\n          tmpArgs[0] = args[0];\t\n          int i = 1;\t\n          tmpArgs[1] = \"\";\t\n          for (; i &lt; args.length - 7; i++) {\t\n            tmpArgs[1] += args[i] + \",\";\t\n          }\t\n          tmpArgs[1] += args[i++];\t\n          for (int j = 2; j &lt; 8; j++) {\t\n            tmpArgs[j] = args[i++];\t\n          }\t\n          args = tmpArgs;\t\n        }\n</code></pre></div>", "author": "HTHou", "createdAt": "2020-11-25T02:10:21Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  // we write log to channel every time, so we need not to call channel.force every time\n+  private static final long DUMMY_FLUSH_TIME = 100;\n+  private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    try {\n+      plan.serialize(mlogBuffer);\n+      sync();\n+      logNum ++;\n+    } catch (BufferOverflowException e) {\n+      logger.warn(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+    }\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan createTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(createTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n+                                     String newFileName, boolean isSnapshot) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+      schemaDir + File.separator + oldFileName);\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n+\n+    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n+\n+      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n+        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n+      }\n+\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n+           MLogTxtReader mLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n+        // upgrade from old character log file to new binary mlog\n+        while (mLogTxtReader.hasNext()) {\n+          String cmd = mLogTxtReader.next();\n+          try {\n+            mLogWriter.operation(cmd, isSnapshot);\n+          } catch (MetadataException e) {\n+            logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n+          }\n+        }\n+      }\n+    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp do not exist, nothing to do\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+    } else if (tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp exist, delete .bin.tmp\n+      try {\n+        Files.delete(Paths.get(tmpLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(\"Deleting \" + tmpLogFile + \"failed with exception \" + e.getMessage());\n+      }\n+    }\n+\n+    // do some clean job\n+    // remove old .txt and .txt.tmp\n+    if (oldLogFile.exists()) {\n+      try {\n+        Files.delete(Paths.get(oldLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(\"Deleting \" + oldLogFile + \"failed with exception \" + e.getMessage());\n+      }\n+    }\n+\n+    if (tmpOldLogFile.exists()) {\n+      try {\n+        Files.delete(Paths.get(tmpOldLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(\"Deleting \" + tmpOldLogFile + \"failed with exception \" + e.getMessage());\n+      }\n+    }\n+\n+    // rename .bin.tmp to .bin\n+    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+  }\n+\n+  public static void upgradeMLog() throws IOException {\n+    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n+    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n+    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n+  }\n+\n+  public void clear() throws IOException {\n+    sync();\n+    logWriter.close();\n+    mlogBuffer.clear();\n+    if (logFile != null && logFile.exists()) {\n+      Files.delete(logFile.toPath());\n+    }\n+    logNum = 0;\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public int getLogNum() {\n+    return logNum;\n+  }\n+\n+  /**\n+   * only used for initialize a mlog file writer.\n+   */\n+  public void setLogNum(int number) {\n+    logNum = number;\n+  }\n+\n+  public void operation(String cmd, boolean isSnapshot) throws IOException, MetadataException {\n+    if (!isSnapshot) {\n+      operation(cmd);\n+    } else {\n+      PhysicalPlan plan = convertFromString(cmd);\n+      try {\n+        if (plan != null) {\n+          putLog(plan);\n+        }\n+      } catch (BufferOverflowException e) {\n+        throw new IOException(\n+          LOG_TOO_LARGE_INFO, e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * upgrade from mlog.txt to mlog.bin\n+   * @param cmd, the old meta operation\n+   * @throws IOException\n+   * @throws MetadataException\n+   */\n+  public void operation(String cmd) throws IOException, MetadataException {\n+    // see createTimeseries() to get the detailed format of the cmd\n+    String[] args = cmd.trim().split(\",\", -1);\n+    switch (args[0]) {\n+      case MetadataOperationType.CREATE_TIMESERIES:", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MzY5NQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530063695", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-11-25T02:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MjA0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex a5a1956448..17d4c936dc 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -339,11 +339,26 @@ public class MLogWriter implements AutoCloseable {\n    * @throws IOException\n    * @throws MetadataException\n    */\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public void operation(String cmd) throws IOException, MetadataException {\n     // see createTimeseries() to get the detailed format of the cmd\n     String[] args = cmd.trim().split(\",\", -1);\n     switch (args[0]) {\n       case MetadataOperationType.CREATE_TIMESERIES:\n+        if (args.length > 8) {\n+          String[] tmpArgs = new String[8];\n+          tmpArgs[0] = args[0];\n+          int i = 1;\n+          tmpArgs[1] = \"\";\n+          for (; i < args.length - 7; i++) {\n+            tmpArgs[1] += args[i] + \",\";\n+          }\n+          tmpArgs[1] += args[i++];\n+          for (int j = 2; j < 8; j++) {\n+            tmpArgs[j] = args[i++];\n+          }\n+          args = tmpArgs;\n+        }\n         Map<String, String> props = null;\n         if (!args[5].isEmpty()) {\n           String[] keyValues = args[5].split(\"&\");\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 17d4c936dc..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -317,48 +288,11 @@ public class MLogWriter implements AutoCloseable {\n     logNum = number;\n   }\n \n-  public void operation(String cmd, boolean isSnapshot) throws IOException, MetadataException {\n-    if (!isSnapshot) {\n-      operation(cmd);\n-    } else {\n-      PhysicalPlan plan = convertFromString(cmd);\n-      try {\n-        if (plan != null) {\n-          putLog(plan);\n-        }\n-      } catch (BufferOverflowException e) {\n-        throw new IOException(\n-          LOG_TOO_LARGE_INFO, e);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * upgrade from mlog.txt to mlog.bin\n-   * @param cmd, the old meta operation\n-   * @throws IOException\n-   * @throws MetadataException\n-   */\n-  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public void operation(String cmd) throws IOException, MetadataException {\n     // see createTimeseries() to get the detailed format of the cmd\n     String[] args = cmd.trim().split(\",\", -1);\n     switch (args[0]) {\n       case MetadataOperationType.CREATE_TIMESERIES:\n-        if (args.length > 8) {\n-          String[] tmpArgs = new String[8];\n-          tmpArgs[0] = args[0];\n-          int i = 1;\n-          tmpArgs[1] = \"\";\n-          for (; i < args.length - 7; i++) {\n-            tmpArgs[1] += args[i] + \",\";\n-          }\n-          tmpArgs[1] += args[i++];\n-          for (int j = 2; j < 8; j++) {\n-            tmpArgs[j] = args[i++];\n-          }\n-          args = tmpArgs;\n-        }\n         Map<String, String> props = null;\n         if (!args[5].isEmpty()) {\n           String[] keyValues = args[5].split(\"&\");\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..322c5d1e09 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -288,11 +319,47 @@ public class MLogWriter {\n     logNum = number;\n   }\n \n+  public void operation(String cmd, boolean isSnapshot) throws IOException, MetadataException {\n+    if (!isSnapshot) {\n+      operation(cmd);\n+    } else {\n+      PhysicalPlan plan = convertFromString(cmd);\n+      try {\n+        if (plan != null) {\n+          putLog(plan);\n+        }\n+      } catch (BufferOverflowException e) {\n+        throw new IOException(\n+          LOG_TOO_LARGE_INFO, e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * upgrade from mlog.txt to mlog.bin\n+   * @param cmd, the old meta operation\n+   * @throws IOException\n+   * @throws MetadataException\n+   */\n   public void operation(String cmd) throws IOException, MetadataException {\n     // see createTimeseries() to get the detailed format of the cmd\n     String[] args = cmd.trim().split(\",\", -1);\n     switch (args[0]) {\n       case MetadataOperationType.CREATE_TIMESERIES:\n+        if (args.length > 8) {\n+          String[] tmpArgs = new String[8];\n+          tmpArgs[0] = args[0];\n+          int i = 1;\n+          tmpArgs[1] = \"\";\n+          for (; i < args.length - 7; i++) {\n+            tmpArgs[1] += args[i] + \",\";\n+          }\n+          tmpArgs[1] += args[i++];\n+          for (int j = 2; j < 8; j++) {\n+            tmpArgs[j] = args[i++];\n+          }\n+          args = tmpArgs;\n+        }\n         Map<String, String> props = null;\n         if (!args[5].isEmpty()) {\n           String[] keyValues = args[5].split(\"&\");\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2Mjk5NA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530062994", "body": "Same reason. Add these lines.\r\n```\r\nif (args.length > 2) {\r\n  StringBuilder tmp = new StringBuilder();\r\n  for (int i = 1; i < args.length - 1; i++) {\r\n    tmp.append(args[i]).append(\",\");\t\r\n  }\t\r\n  tmp.append(args[args.length - 1]);\t\r\n  args[1] = tmp.toString();\t\r\n}\r\n```", "bodyText": "Same reason. Add these lines.\nif (args.length > 2) {\n  StringBuilder tmp = new StringBuilder();\n  for (int i = 1; i < args.length - 1; i++) {\n    tmp.append(args[i]).append(\",\");\t\n  }\t\n  tmp.append(args[args.length - 1]);\t\n  args[1] = tmp.toString();\t\n}", "bodyHTML": "<p dir=\"auto\">Same reason. Add these lines.</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (args.length &gt; 2) {\n  StringBuilder tmp = new StringBuilder();\n  for (int i = 1; i &lt; args.length - 1; i++) {\n    tmp.append(args[i]).append(&quot;,&quot;);\t\n  }\t\n  tmp.append(args[args.length - 1]);\t\n  args[1] = tmp.toString();\t\n}\n\"><pre><code>if (args.length &gt; 2) {\n  StringBuilder tmp = new StringBuilder();\n  for (int i = 1; i &lt; args.length - 1; i++) {\n    tmp.append(args[i]).append(\",\");\t\n  }\t\n  tmp.append(args[args.length - 1]);\t\n  args[1] = tmp.toString();\t\n}\n</code></pre></div>", "author": "HTHou", "createdAt": "2020-11-25T02:13:32Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  // we write log to channel every time, so we need not to call channel.force every time\n+  private static final long DUMMY_FLUSH_TIME = 100;\n+  private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    try {\n+      plan.serialize(mlogBuffer);\n+      sync();\n+      logNum ++;\n+    } catch (BufferOverflowException e) {\n+      logger.warn(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+    }\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan createTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(createTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n+                                     String newFileName, boolean isSnapshot) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+      schemaDir + File.separator + oldFileName);\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n+\n+    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n+\n+      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n+        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n+      }\n+\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n+           MLogTxtReader mLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n+        // upgrade from old character log file to new binary mlog\n+        while (mLogTxtReader.hasNext()) {\n+          String cmd = mLogTxtReader.next();\n+          try {\n+            mLogWriter.operation(cmd, isSnapshot);\n+          } catch (MetadataException e) {\n+            logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n+          }\n+        }\n+      }\n+    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp do not exist, nothing to do\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+    } else if (tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp exist, delete .bin.tmp\n+      try {\n+        Files.delete(Paths.get(tmpLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(\"Deleting \" + tmpLogFile + \"failed with exception \" + e.getMessage());\n+      }\n+    }\n+\n+    // do some clean job\n+    // remove old .txt and .txt.tmp\n+    if (oldLogFile.exists()) {\n+      try {\n+        Files.delete(Paths.get(oldLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(\"Deleting \" + oldLogFile + \"failed with exception \" + e.getMessage());\n+      }\n+    }\n+\n+    if (tmpOldLogFile.exists()) {\n+      try {\n+        Files.delete(Paths.get(tmpOldLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(\"Deleting \" + tmpOldLogFile + \"failed with exception \" + e.getMessage());\n+      }\n+    }\n+\n+    // rename .bin.tmp to .bin\n+    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+  }\n+\n+  public static void upgradeMLog() throws IOException {\n+    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n+    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n+    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n+  }\n+\n+  public void clear() throws IOException {\n+    sync();\n+    logWriter.close();\n+    mlogBuffer.clear();\n+    if (logFile != null && logFile.exists()) {\n+      Files.delete(logFile.toPath());\n+    }\n+    logNum = 0;\n+    logWriter = new LogWriter(logFile, 0L);\n+  }\n+\n+  public int getLogNum() {\n+    return logNum;\n+  }\n+\n+  /**\n+   * only used for initialize a mlog file writer.\n+   */\n+  public void setLogNum(int number) {\n+    logNum = number;\n+  }\n+\n+  public void operation(String cmd, boolean isSnapshot) throws IOException, MetadataException {\n+    if (!isSnapshot) {\n+      operation(cmd);\n+    } else {\n+      PhysicalPlan plan = convertFromString(cmd);\n+      try {\n+        if (plan != null) {\n+          putLog(plan);\n+        }\n+      } catch (BufferOverflowException e) {\n+        throw new IOException(\n+          LOG_TOO_LARGE_INFO, e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * upgrade from mlog.txt to mlog.bin\n+   * @param cmd, the old meta operation\n+   * @throws IOException\n+   * @throws MetadataException\n+   */\n+  public void operation(String cmd) throws IOException, MetadataException {\n+    // see createTimeseries() to get the detailed format of the cmd\n+    String[] args = cmd.trim().split(\",\", -1);\n+    switch (args[0]) {\n+      case MetadataOperationType.CREATE_TIMESERIES:\n+        Map<String, String> props = null;\n+        if (!args[5].isEmpty()) {\n+          String[] keyValues = args[5].split(\"&\");\n+          String[] kv;\n+          props = new HashMap<>();\n+          for (String keyValue : keyValues) {\n+            kv = keyValue.split(\"=\");\n+            props.put(kv[0], kv[1]);\n+          }\n+        }\n+\n+        String alias = null;\n+        if (!args[6].isEmpty()) {\n+          alias = args[6];\n+        }\n+        long offset = -1L;\n+        if (!args[7].isEmpty()) {\n+          offset = Long.parseLong(args[7]);\n+        }\n+\n+        CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan(new PartialPath(args[1]),\n+            TSDataType.deserialize(Short.parseShort(args[2])),\n+            TSEncoding.deserialize(Short.parseShort(args[3])),\n+            CompressionType.deserialize(Short.parseShort(args[4])), props, null, null, alias);\n+        plan.setTagOffset(offset);\n+\n+        createTimeseries(plan);\n+        break;\n+      case MetadataOperationType.DELETE_TIMESERIES:", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex a5a1956448..17d4c936dc 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -365,25 +380,36 @@ public class MLogWriter implements AutoCloseable {\n         }\n \n         CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan(new PartialPath(args[1]),\n-            TSDataType.deserialize(Short.parseShort(args[2])),\n-            TSEncoding.deserialize(Short.parseShort(args[3])),\n-            CompressionType.deserialize(Short.parseShort(args[4])), props, null, null, alias);\n-        plan.setTagOffset(offset);\n+          TSDataType.deserialize(Short.parseShort(args[2])),\n+          TSEncoding.deserialize(Short.parseShort(args[3])),\n+          CompressionType.deserialize(Short.parseShort(args[4])), props, null, null, alias);\n \n+        plan.setTagOffset(offset);\n         createTimeseries(plan);\n         break;\n       case MetadataOperationType.DELETE_TIMESERIES:\n-        DeleteTimeSeriesPlan deleteTimeSeriesPlan =\n-            new DeleteTimeSeriesPlan(Collections.singletonList(new PartialPath(args[1])));\n-        deleteTimeseries(deleteTimeSeriesPlan);\n+        if (args.length > 2) {\n+          StringBuilder tmp = new StringBuilder();\n+          for (int i = 1; i < args.length - 1; i++) {\n+            tmp.append(args[i]).append(\",\");\n+          }\n+          tmp.append(args[args.length - 1]);\n+          args[1] = tmp.toString();\n+        }\n+        deleteTimeseries(new DeleteTimeSeriesPlan(Collections.singletonList(new PartialPath(args[1]))));\n         break;\n       case MetadataOperationType.SET_STORAGE_GROUP:\n-        setStorageGroup(new PartialPath(args[1]));\n+        try {\n+          setStorageGroup(new PartialPath(args[1]));\n+        }\n+        // two time series may set one storage group concurrently,\n+        // that's normal in our concurrency control protocol\n+        catch (MetadataException e){\n+          logger.info(\"concurrently operate set storage group cmd {} twice\", cmd);\n+        }\n         break;\n       case MetadataOperationType.DELETE_STORAGE_GROUP:\n-        for(int i = 1; i <= args.length; i++) {\n-          deleteStorageGroup(new PartialPath(args[i]));\n-        }\n+        deleteStorageGroup(new PartialPath(args[1]));\n         break;\n       case MetadataOperationType.SET_TTL:\n         setTTL(new PartialPath(args[1]), Long.parseLong(args[2]));\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 17d4c936dc..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -375,41 +309,30 @@ public class MLogWriter implements AutoCloseable {\n           alias = args[6];\n         }\n         long offset = -1L;\n+        Map<String, String> tagMap = null;\n         if (!args[7].isEmpty()) {\n           offset = Long.parseLong(args[7]);\n         }\n \n         CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan(new PartialPath(args[1]),\n-          TSDataType.deserialize(Short.parseShort(args[2])),\n-          TSEncoding.deserialize(Short.parseShort(args[3])),\n-          CompressionType.deserialize(Short.parseShort(args[4])), props, null, null, alias);\n+            TSDataType.deserialize(Short.parseShort(args[2])),\n+            TSEncoding.deserialize(Short.parseShort(args[3])),\n+            CompressionType.deserialize(Short.parseShort(args[4])), props, null, null, alias);\n \n-        plan.setTagOffset(offset);\n-        createTimeseries(plan);\n+        createTimeseries(plan, offset);\n         break;\n       case MetadataOperationType.DELETE_TIMESERIES:\n-        if (args.length > 2) {\n-          StringBuilder tmp = new StringBuilder();\n-          for (int i = 1; i < args.length - 1; i++) {\n-            tmp.append(args[i]).append(\",\");\n-          }\n-          tmp.append(args[args.length - 1]);\n-          args[1] = tmp.toString();\n-        }\n-        deleteTimeseries(new DeleteTimeSeriesPlan(Collections.singletonList(new PartialPath(args[1]))));\n+        DeleteTimeSeriesPlan deleteTimeSeriesPlan =\n+            new DeleteTimeSeriesPlan(Collections.singletonList(new PartialPath(args[1])));\n+        deleteTimeseries(deleteTimeSeriesPlan);\n         break;\n       case MetadataOperationType.SET_STORAGE_GROUP:\n-        try {\n-          setStorageGroup(new PartialPath(args[1]));\n-        }\n-        // two time series may set one storage group concurrently,\n-        // that's normal in our concurrency control protocol\n-        catch (MetadataException e){\n-          logger.info(\"concurrently operate set storage group cmd {} twice\", cmd);\n-        }\n+        setStorageGroup(new PartialPath(args[1]));\n         break;\n       case MetadataOperationType.DELETE_STORAGE_GROUP:\n-        deleteStorageGroup(new PartialPath(args[1]));\n+        for(int i = 1; i <= args.length; i++) {\n+          deleteStorageGroup(new PartialPath(args[i]));\n+        }\n         break;\n       case MetadataOperationType.SET_TTL:\n         setTTL(new PartialPath(args[1]), Long.parseLong(args[2]));\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..322c5d1e09 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -309,30 +376,41 @@ public class MLogWriter {\n           alias = args[6];\n         }\n         long offset = -1L;\n-        Map<String, String> tagMap = null;\n         if (!args[7].isEmpty()) {\n           offset = Long.parseLong(args[7]);\n         }\n \n         CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan(new PartialPath(args[1]),\n-            TSDataType.deserialize(Short.parseShort(args[2])),\n-            TSEncoding.deserialize(Short.parseShort(args[3])),\n-            CompressionType.deserialize(Short.parseShort(args[4])), props, null, null, alias);\n+          TSDataType.deserialize(Short.parseShort(args[2])),\n+          TSEncoding.deserialize(Short.parseShort(args[3])),\n+          CompressionType.deserialize(Short.parseShort(args[4])), props, null, null, alias);\n \n-        createTimeseries(plan, offset);\n+        plan.setTagOffset(offset);\n+        createTimeseries(plan);\n         break;\n       case MetadataOperationType.DELETE_TIMESERIES:\n-        DeleteTimeSeriesPlan deleteTimeSeriesPlan =\n-            new DeleteTimeSeriesPlan(Collections.singletonList(new PartialPath(args[1])));\n-        deleteTimeseries(deleteTimeSeriesPlan);\n+        if (args.length > 2) {\n+          StringBuilder tmp = new StringBuilder();\n+          for (int i = 1; i < args.length - 1; i++) {\n+            tmp.append(args[i]).append(\",\");\n+          }\n+          tmp.append(args[args.length - 1]);\n+          args[1] = tmp.toString();\n+        }\n+        deleteTimeseries(new DeleteTimeSeriesPlan(Collections.singletonList(new PartialPath(args[1]))));\n         break;\n       case MetadataOperationType.SET_STORAGE_GROUP:\n-        setStorageGroup(new PartialPath(args[1]));\n+        try {\n+          setStorageGroup(new PartialPath(args[1]));\n+        }\n+        // two time series may set one storage group concurrently,\n+        // that's normal in our concurrency control protocol\n+        catch (MetadataException e){\n+          logger.info(\"concurrently operate set storage group cmd {} twice\", cmd);\n+        }\n         break;\n       case MetadataOperationType.DELETE_STORAGE_GROUP:\n-        for(int i = 1; i <= args.length; i++) {\n-          deleteStorageGroup(new PartialPath(args[i]));\n-        }\n+        deleteStorageGroup(new PartialPath(args[1]));\n         break;\n       case MetadataOperationType.SET_TTL:\n         setTTL(new PartialPath(args[1]), Long.parseLong(args[2]));\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2NDAyOA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530064028", "body": "```suggestion\r\n      logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n          \n          \n            \n                  logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      logger<span class=\"pl-k\">.</span>error(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>DO NOT UPGRADE IoTDB from v0.<span class=\"x x-first x-last\">9</span> or lower version to v0.12!<span class=\"pl-pds\">\"</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      logger<span class=\"pl-k\">.</span>error(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>DO NOT UPGRADE IoTDB from v0.<span class=\"x x-first x-last\">10</span> or lower version to v0.12!<span class=\"pl-pds\">\"</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "HTHou", "createdAt": "2020-11-25T02:17:04Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -184,51 +185,16 @@ public void checkConfig() throws IOException {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.11\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n-          + \" Please upgrade to v0.10 first\");\n+    // check whether upgrading from v0.9 to v0.12\n+    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n+      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 0ca9b49734..be1689ec8e 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -188,7 +188,7 @@ public class IoTDBConfigCheck {\n     // check whether upgrading from v0.9 to v0.12\n     if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n       properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n           + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n", "next_change": {"commit": "61c6f6d47b087075554ed4f3636d4990a6da4395", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex be1689ec8e..9d7efd1c86 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,23 +185,33 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.12\n+    // check whether upgrading from <=v0.10 to v0.12\n     if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n       properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n       logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n           + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n+\n+    // check whether upgrading from v0.11 to v0.12\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n+      logger.info(\"Upgrading IoTDB from v0.11 to v0.12, checking files...\");\n+      checkUnClosedTsFileV2();\n+      upgradePropertiesFile();\n+      logger.info(\"Upgrade to IoTDB v0.12 successfully!\");\n+    }\n+\n     MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n \n   /**\n-   * upgrade 0.10 properties to 0.11 properties\n+   * upgrade 0.11 properties to 0.12 properties\n    */\n+  @SuppressWarnings(\"unused\")\n   private void upgradePropertiesFile()\n-    throws IOException {\n+      throws IOException {\n     // create an empty tmpPropertiesFile\n     if (tmpPropertiesFile.createNewFile()) {\n       logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 9d7efd1c86..c1274ac49f 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,29 +185,45 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from <=v0.10 to v0.12\n-    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n-      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n-          + \" Please upgrade to v0.11 first\");\n+    // check whether upgrading\n+    if (!properties.containsKey(IOTDB_VERSION_STRING)\n+        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")\n+        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.11 or lower version NOW\");\n       System.exit(-1);\n     }\n \n-    // check whether upgrading from v0.11 to v0.12\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n-      logger.info(\"Upgrading IoTDB from v0.11 to v0.12, checking files...\");\n+    // check whether upgrading from v0.10 to v0.11\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n       checkUnClosedTsFileV2();\n       upgradePropertiesFile();\n-      logger.info(\"Upgrade to IoTDB v0.12 successfully!\");\n-    }\n+      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n+\n+      // upgrade mlog finished, delete old mlog file\n+      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+          + MetadataConstant.METADATA_LOG);\n+      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n+          + \".tmp\");\n+\n+      if (!mlogFile.delete()) {\n+        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n+      }\n+      // rename tmpLogFile to mlog\n+      FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n-    MLogWriter.upgradeMLog();\n+      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+          + MetadataConstant.METADATA_OLD_LOG);\n \n+      if (oldMLogFile.delete()) {\n+        throw new IOException(\"Deleting old mlog \" + oldMLogFile + \"failed.\");\n+      }\n+    }\n     checkProperties();\n   }\n \n   /**\n-   * upgrade 0.11 properties to 0.12 properties\n+   * upgrade 0.10 properties to 0.11 properties\n    */\n   @SuppressWarnings(\"unused\")\n   private void upgradePropertiesFile()\n", "next_change": {"commit": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex c1274ac49f..d00a287f5a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,44 +185,20 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)\n-        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")\n-        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.11 or lower version NOW\");\n+    // check whether upgrading from v0.9 to v0.12\n+    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n+      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n+          + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n+    MLogWriter.upgradeMLog();\n \n-    // check whether upgrading from v0.10 to v0.11\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n-      checkUnClosedTsFileV2();\n-      upgradePropertiesFile();\n-      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-          + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n-\n-      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_OLD_LOG);\n-\n-      if (oldMLogFile.delete()) {\n-        throw new IOException(\"Deleting old mlog \" + oldMLogFile + \"failed.\");\n-      }\n-    }\n     checkProperties();\n   }\n \n   /**\n+<<<<<<< HEAD\n    * upgrade 0.10 properties to 0.11 properties\n    */\n   @SuppressWarnings(\"unused\")\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex d00a287f5a..9db3407287 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -198,7 +198,6 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n-<<<<<<< HEAD\n    * upgrade 0.10 properties to 0.11 properties\n    */\n   @SuppressWarnings(\"unused\")\n", "next_change": {"commit": "c76cb3eb323ec320cc7b257caa530bc85e17be82", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 9db3407287..0fe2bf1f60 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,20 +185,29 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.12\n+    // check whether upgrading from <=v0.10 to v0.12\n     if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n       properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n       logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n           + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n+\n+    // check whether upgrading from v0.11 to v0.12\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.info(\"Upgrading IoTDB from v0.11 to v0.12, checking files...\");\n+      checkUnClosedTsFileV2();\n+      upgradePropertiesFile();\n+      logger.info(\"Upgrade to IoTDB v0.12 successfully!\");\n+    }\n+\n     MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n \n   /**\n-   * upgrade 0.10 properties to 0.11 properties\n+   * upgrade 0.11 properties to 0.12 properties\n    */\n   @SuppressWarnings(\"unused\")\n   private void upgradePropertiesFile()\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0NjQyMQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r530146421", "body": "```suggestion\r\n    CREATE_MULTI_TIMESERIES, CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                CREATE_MULTI_TIMESERIES  , CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n          \n          \n            \n                CREATE_MULTI_TIMESERIES, CREATE_INDEX, DROP_INDEX, QUERY_INDEX,", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-c1\">CREATE_MULTI_TIMESERIES</span><span class=\"x x-first x-last\">  </span>, <span class=\"pl-c1\">CREATE_INDEX</span>, <span class=\"pl-c1\">DROP_INDEX</span>, <span class=\"pl-c1\">QUERY_INDEX</span>,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-c1\">CREATE_MULTI_TIMESERIES</span>, <span class=\"pl-c1\">CREATE_INDEX</span>, <span class=\"pl-c1\">DROP_INDEX</span>, <span class=\"pl-c1\">QUERY_INDEX</span>,</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "HTHou", "createdAt": "2020-11-25T07:03:31Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java", "diffHunk": "@@ -77,7 +77,8 @@ public String toString() {\n     TTL, DELETE_STORAGE_GROUP, LOAD_CONFIGURATION, SHOW, LOAD_FILES, REMOVE_FILE, MOVE_FILE, LAST, GROUP_BY_FILL,\n     ALTER_TIMESERIES, FLUSH, MERGE, FULL_MERGE, CLEAR_CACHE,\n     SHOW_MERGE_STATUS, CREATE_SCHEMA_SNAPSHOT, TRACING, DELETE_PARTITION,\n-    CREATE_MULTI_TIMESERIES\n-    , CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n+    CREATE_MULTI_TIMESERIES  , CREATE_INDEX, DROP_INDEX, QUERY_INDEX,", "originalCommit": "18db49a9f143f75580454df2a3fb002d63c66a2d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java b/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\nindex 267faccb50..13e3749309 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\n", "chunk": "@@ -77,7 +77,7 @@ public abstract class Operator {\n     TTL, DELETE_STORAGE_GROUP, LOAD_CONFIGURATION, SHOW, LOAD_FILES, REMOVE_FILE, MOVE_FILE, LAST, GROUP_BY_FILL,\n     ALTER_TIMESERIES, FLUSH, MERGE, FULL_MERGE, CLEAR_CACHE,\n     SHOW_MERGE_STATUS, CREATE_SCHEMA_SNAPSHOT, TRACING, DELETE_PARTITION,\n-    CREATE_MULTI_TIMESERIES  , CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n+    CREATE_MULTI_TIMESERIES, CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n     CHANGE_TAG_OFFSET, CHANGE_ALIAS, MNODE,\n     MEASUREMENT_MNODE, STORAGE_GROUP_MNODE;\n   }\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java b/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\nindex 13e3749309..267faccb50 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\n", "chunk": "@@ -77,7 +77,7 @@ public abstract class Operator {\n     TTL, DELETE_STORAGE_GROUP, LOAD_CONFIGURATION, SHOW, LOAD_FILES, REMOVE_FILE, MOVE_FILE, LAST, GROUP_BY_FILL,\n     ALTER_TIMESERIES, FLUSH, MERGE, FULL_MERGE, CLEAR_CACHE,\n     SHOW_MERGE_STATUS, CREATE_SCHEMA_SNAPSHOT, TRACING, DELETE_PARTITION,\n-    CREATE_MULTI_TIMESERIES, CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n+    CREATE_MULTI_TIMESERIES  , CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n     CHANGE_TAG_OFFSET, CHANGE_ALIAS, MNODE,\n     MEASUREMENT_MNODE, STORAGE_GROUP_MNODE;\n   }\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java b/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\nindex 267faccb50..13e3749309 100644\n--- a/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\n+++ b/server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java\n", "chunk": "@@ -77,7 +77,7 @@ public abstract class Operator {\n     TTL, DELETE_STORAGE_GROUP, LOAD_CONFIGURATION, SHOW, LOAD_FILES, REMOVE_FILE, MOVE_FILE, LAST, GROUP_BY_FILL,\n     ALTER_TIMESERIES, FLUSH, MERGE, FULL_MERGE, CLEAR_CACHE,\n     SHOW_MERGE_STATUS, CREATE_SCHEMA_SNAPSHOT, TRACING, DELETE_PARTITION,\n-    CREATE_MULTI_TIMESERIES  , CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n+    CREATE_MULTI_TIMESERIES, CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n     CHANGE_TAG_OFFSET, CHANGE_ALIAS, MNODE,\n     MEASUREMENT_MNODE, STORAGE_GROUP_MNODE;\n   }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4MTc1MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r531981750", "body": "Remove unused import", "bodyText": "Remove unused import", "bodyHTML": "<p dir=\"auto\">Remove unused import</p>", "author": "samperson1997", "createdAt": "2020-11-28T07:24:47Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.DeleteFailedException;", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMwNTU5Nw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r532305597", "bodyText": "fixed", "author": "mychaow", "createdAt": "2020-11-30T01:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4MTc1MA=="}], "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 322c5d1e09..17d4c936dc 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -21,7 +21,6 @@ package org.apache.iotdb.db.metadata.logfile;\n import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n-import org.apache.iotdb.db.exception.metadata.DeleteFailedException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n import org.apache.iotdb.db.metadata.MetadataConstant;\n import org.apache.iotdb.db.metadata.MetadataOperationType;\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 17d4c936dc..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -18,7 +18,12 @@\n  */\n package org.apache.iotdb.db.metadata.logfile;\n \n-import org.apache.commons.io.FileUtils;\n+import java.io.*;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.*;\n+\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -24,6 +24,7 @@ import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.util.*;\n \n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -18,12 +18,6 @@\n  */\n package org.apache.iotdb.db.metadata.logfile;\n \n-import java.io.*;\n-import java.nio.BufferOverflowException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.util.*;\n-\n import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..322c5d1e09 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -21,6 +21,7 @@ package org.apache.iotdb.db.metadata.logfile;\n import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.DeleteFailedException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n import org.apache.iotdb.db.metadata.MetadataConstant;\n import org.apache.iotdb.db.metadata.MetadataOperationType;\n", "next_change": {"commit": "95516e01ca4ba2e1134b4202b86c53ffbfe196ea", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 322c5d1e09..dcaddf4013 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -21,7 +21,6 @@ package org.apache.iotdb.db.metadata.logfile;\n import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n-import org.apache.iotdb.db.exception.metadata.DeleteFailedException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n import org.apache.iotdb.db.metadata.MetadataConstant;\n import org.apache.iotdb.db.metadata.MetadataOperationType;\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 17d4c936dc..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -29,36 +34,16 @@ import org.apache.iotdb.db.metadata.mnode.MNode;\n import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n import org.apache.iotdb.db.writelog.io.LogWriter;\n import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n-import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.BufferOverflowException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-public class MLogWriter implements AutoCloseable {\n+public class MLogWriter {\n \n   private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n   private File logFile;\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -43,7 +44,7 @@ import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class MLogWriter {\n+public class MLogWriter implements AutoCloseable {\n \n   private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n   private File logFile;\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -35,15 +29,34 @@ import org.apache.iotdb.db.metadata.mnode.MNode;\n import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n import org.apache.iotdb.db.writelog.io.LogWriter;\n import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n public class MLogWriter implements AutoCloseable {\n \n   private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n", "next_change": {"commit": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..a5a1956448 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -53,6 +53,7 @@ import java.io.IOException;\n import java.nio.BufferOverflowException;\n import java.nio.ByteBuffer;\n import java.nio.file.Files;\n+import java.nio.file.Paths;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex a5a1956448..322c5d1e09 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -54,6 +55,7 @@ import java.nio.BufferOverflowException;\n import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n", "next_change": {"commit": "95516e01ca4ba2e1134b4202b86c53ffbfe196ea", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 322c5d1e09..dcaddf4013 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -55,7 +54,6 @@ import java.nio.BufferOverflowException;\n import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.nio.file.Paths;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -53,6 +66,9 @@ public class MLogWriter implements AutoCloseable {\n   private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n+  // we write log to channel every time, so we need not to call channel.force every time\n+  private final long DUMMY_FLUSH_TIME = 100;\n+\n   public MLogWriter(String schemaDir, String logFileName) throws IOException {\n     File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n     if (!metadataDir.exists()) {\n", "next_change": {"commit": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -67,7 +67,8 @@ public class MLogWriter implements AutoCloseable {\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n   // we write log to channel every time, so we need not to call channel.force every time\n-  private final long DUMMY_FLUSH_TIME = 100;\n+  private static final long DUMMY_FLUSH_TIME = 100;\n+  private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n \n   public MLogWriter(String schemaDir, String logFileName) throws IOException {\n     File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..9fea13282d 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -63,11 +64,10 @@ public class MLogWriter implements AutoCloseable {\n   private File logFile;\n   private LogWriter logWriter;\n   private int logNum;\n-  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+  private static final String DELETE_FAILED_FORMAT = \"Deleting %s failed with exception %s\";\n+  private final ByteBuffer mlogBuffer = ByteBuffer.allocate(\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n-  // we write log to channel every time, so we need not to call channel.force every time\n-  private static final long DUMMY_FLUSH_TIME = 100;\n   private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n \n   public MLogWriter(String schemaDir, String logFileName) throws IOException {\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4Mzk5OA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r531983998", "body": "Remove unused import", "bodyText": "Remove unused import", "bodyHTML": "<p dir=\"auto\">Remove unused import</p>", "author": "samperson1997", "createdAt": "2020-11-28T07:27:44Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.DeleteFailedException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 322c5d1e09..17d4c936dc 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -55,7 +54,6 @@ import java.nio.BufferOverflowException;\n import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.nio.file.Paths;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 17d4c936dc..bcbe74cc61 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -29,36 +34,16 @@ import org.apache.iotdb.db.metadata.mnode.MNode;\n import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;\n import org.apache.iotdb.db.writelog.io.LogWriter;\n import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n-import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.BufferOverflowException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-public class MLogWriter implements AutoCloseable {\n+public class MLogWriter {\n \n   private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n   private File logFile;\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex bcbe74cc61..c26a119c98 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -43,7 +44,7 @@ import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class MLogWriter {\n+public class MLogWriter implements AutoCloseable {\n \n   private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n   private File logFile;\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -35,15 +29,34 @@ import org.apache.iotdb.db.metadata.mnode.MNode;\n import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.*;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n import org.apache.iotdb.db.writelog.io.LogWriter;\n import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n public class MLogWriter implements AutoCloseable {\n \n   private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n", "next_change": {"commit": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..a5a1956448 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -53,6 +53,7 @@ import java.io.IOException;\n import java.nio.BufferOverflowException;\n import java.nio.ByteBuffer;\n import java.nio.file.Files;\n+import java.nio.file.Paths;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex a5a1956448..322c5d1e09 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -54,6 +55,7 @@ import java.nio.BufferOverflowException;\n import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n", "next_change": {"commit": "95516e01ca4ba2e1134b4202b86c53ffbfe196ea", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 322c5d1e09..dcaddf4013 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -55,7 +54,6 @@ import java.nio.BufferOverflowException;\n import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.nio.file.Paths;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex c26a119c98..ee06848d33 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -53,6 +66,9 @@ public class MLogWriter implements AutoCloseable {\n   private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n+  // we write log to channel every time, so we need not to call channel.force every time\n+  private final long DUMMY_FLUSH_TIME = 100;\n+\n   public MLogWriter(String schemaDir, String logFileName) throws IOException {\n     File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n     if (!metadataDir.exists()) {\n", "next_change": {"commit": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ee06848d33..ae7f8479d8 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -67,7 +67,8 @@ public class MLogWriter implements AutoCloseable {\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n   // we write log to channel every time, so we need not to call channel.force every time\n-  private final long DUMMY_FLUSH_TIME = 100;\n+  private static final long DUMMY_FLUSH_TIME = 100;\n+  private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n \n   public MLogWriter(String schemaDir, String logFileName) throws IOException {\n     File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ae7f8479d8..9fea13282d 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -63,11 +64,10 @@ public class MLogWriter implements AutoCloseable {\n   private File logFile;\n   private LogWriter logWriter;\n   private int logNum;\n-  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+  private static final String DELETE_FAILED_FORMAT = \"Deleting %s failed with exception %s\";\n+  private final ByteBuffer mlogBuffer = ByteBuffer.allocate(\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n-  // we write log to channel every time, so we need not to call channel.force every time\n-  private static final long DUMMY_FLUSH_TIME = 100;\n   private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n \n   public MLogWriter(String schemaDir, String logFileName) throws IOException {\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4NDg3Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r531984876", "body": "Remove unused import", "bodyText": "Remove unused import", "bodyHTML": "<p dir=\"auto\">Remove unused import</p>", "author": "samperson1997", "createdAt": "2020-11-28T07:28:48Z", "path": "server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 1300693d92..8261635479 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -18,7 +18,6 @@\n  */\n package org.apache.iotdb.db.tools.mlog;\n \n-import jline.console.ConsoleReader;\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.CommandLineParser;\n import org.apache.commons.cli.DefaultParser;\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\ndeleted file mode 100644\nindex 8261635479..0000000000\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ /dev/null\n", "chunk": "@@ -1,191 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.iotdb.db.tools.mlog;\n-\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.DefaultParser;\n-import org.apache.commons.cli.HelpFormatter;\n-import org.apache.commons.cli.Option;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.ParseException;\n-import org.apache.iotdb.db.metadata.MLogTxtWriter;\n-import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.metadata.logfile.MLogReader;\n-import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n-\n-import java.io.IOException;\n-\n-/**\n- * parse the binary mlog or snapshot to text\n- */\n-public class MLogParser {\n-\n-  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n-\n-  private static final String FILE_ARGS = \"f\";\n-  private static final String FILE_NAME = \"mlog file\";\n-\n-  private static final String OUT_ARGS = \"o\";\n-  private static final String OUT_NAME = \"output txt file\";\n-\n-  private static final String HELP_ARGS = \"help\";\n-\n-  private static String inputFile;\n-  private static String outputFile;\n-\n-  /**\n-   * create the commandline options.\n-   *\n-   * @return object Options\n-   */\n-  public static Options createOptions() {\n-    Options options = new Options();\n-\n-    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n-      \"Need to specify a binary mlog file to parse (required)\")\n-      .build();\n-    options.addOption(opFile);\n-\n-    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n-      \"Could specify the output file after parse (optional)\")\n-      .build();\n-    options.addOption(opOut);\n-\n-    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n-      .hasArg(false).desc(\"Display help information\")\n-      .build();\n-    options.addOption(opHelp);\n-\n-    return options;\n-  }\n-\n-  public static void main(String[] args) {\n-    Options options = createOptions();\n-    HelpFormatter hf = new HelpFormatter();\n-    hf.setOptionComparator(null);\n-    CommandLine commandLine;\n-    CommandLineParser parser = new DefaultParser();\n-\n-    if (args == null || args.length == 0) {\n-      System.out.println(\"Too few params input, please check the following hint.\");\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    try {\n-      commandLine = parser.parse(options, args);\n-    } catch (ParseException e) {\n-      System.out.println(\"Parse error: \" + e.getMessage());\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    if (commandLine.hasOption(HELP_ARGS)) {\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-\n-    try {\n-      parseBasicParams(commandLine);\n-      parseFromFile(inputFile, outputFile);\n-    } catch (Exception e) {\n-      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n-    }\n-  }\n-\n-  public static void parseBasicParams(CommandLine commandLine) throws Exception {\n-    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n-    outputFile = commandLine.getOptionValue(OUT_ARGS);\n-\n-    if (outputFile == null) {\n-      outputFile = \"tmp.txt\";\n-    }\n-  }\n-\n-  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n-    throws ParseException {\n-    String str = commandLine.getOptionValue(arg);\n-    if (str == null) {\n-      String msg = String.format(\"Required values for option '%s' not provided\", name);\n-      System.out.println(msg);\n-      System.out.println(\"Use -help for more information\");\n-      throw new ParseException(msg);\n-    }\n-    return str;\n-  }\n-\n-  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n-    try (MLogReader mLogReader = new MLogReader(inputFile);\n-         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n-\n-      while (mLogReader.hasNext()) {\n-        PhysicalPlan plan = mLogReader.next();\n-        switch (plan.getOperatorType()) {\n-          case CREATE_TIMESERIES:\n-            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n-              ((CreateTimeSeriesPlan) plan).getTagOffset());\n-            break;\n-          case DELETE_TIMESERIES:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteTimeseries(partialPath.getFullPath());\n-            }\n-            break;\n-          case SET_STORAGE_GROUP:\n-            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n-            break;\n-          case DELETE_STORAGE_GROUP:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteStorageGroup(partialPath.getFullPath());\n-            }\n-            break;\n-          case TTL:\n-            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n-              ((SetTTLPlan) plan).getDataTTL());\n-            break;\n-          case CHANGE_ALIAS:\n-            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n-              ((ChangeAliasPlan) plan).getAlias());\n-            break;\n-          case CHANGE_TAG_OFFSET:\n-            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n-              ((ChangeTagOffsetPlan) plan).getOffset());\n-            break;\n-          case MEASUREMENT_MNODE:\n-            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n-            break;\n-          case STORAGE_GROUP_MNODE:\n-            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n-            break;\n-          case MNODE:\n-            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n-            break;\n-          default:\n-            System.out.println(\"unknown plan \" + plan.toString());\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nnew file mode 100644\nindex 0000000000..56a7a1a6f8\n--- /dev/null\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (inputFile == null) {\n+      inputFile = reader.readLine(\"please input your mlog path:\", '\\0');\n+    }\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {\n+    String str = commandLine.getOptionValue(arg);\n+    if (str == null) {\n+      String msg = String.format(\"Required values for option '%s' not provided\", name);\n+      System.out.println(msg);\n+      System.out.println(\"Use -help for more information\");\n+      throw new Exception(msg);\n+    }\n+    return str;\n+  }\n+\n+  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n+    try (MLogReader mLogReader = new MLogReader(inputFile);\n+         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n+\n+      while (mLogReader.hasNext()) {\n+        PhysicalPlan plan = mLogReader.next();\n+        switch (plan.getOperatorType()) {\n+          case CREATE_TIMESERIES:\n+            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n+              ((CreateTimeSeriesPlan) plan).getTagOffset());\n+            break;\n+          case DELETE_TIMESERIES: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteTimeseries(pathList.get(i).getFullPath());\n+            }\n+          }\n+            break;\n+          case SET_STORAGE_GROUP:\n+            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n+            break;\n+          case DELETE_STORAGE_GROUP: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteStorageGroup(pathList.get(i).getFullPath());\n+            }\n+          }\n+          break;\n+          case TTL:\n+            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n+              ((SetTTLPlan) plan).getDataTTL());\n+            break;\n+          case CHANGE_ALIAS:\n+            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n+              ((ChangeAliasPlan) plan).getAlias());\n+            break;\n+          case CHANGE_TAG_OFFSET:\n+            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n+              ((ChangeTagOffsetPlan) plan).getOffset());\n+            break;\n+          case MEASUREMENT_MNODE:\n+            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n+            break;\n+          case STORAGE_GROUP_MNODE:\n+            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n+            break;\n+          case MNODE:\n+            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n+            break;\n+          default:\n+            System.out.println(\"unknown plan \" + plan.toString());\n+        }\n+      }\n+    }\n+  }\n+}\n", "next_change": {"commit": "92930ca36dbeb586f2be035f297eef6e4041162b", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 56a7a1a6f8..5a303cfbef 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -203,7 +186,7 @@ public class MLogParser {\n             mLogTxtWriter.serializeMNode((MNodePlan) plan);\n             break;\n           default:\n-            System.out.println(\"unknown plan \" + plan.toString());\n+            logger.warn(\"unknown plan {}\", plan);\n         }\n       }\n     }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4NDk5OQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r531984999", "body": "Remove unused import", "bodyText": "Remove unused import", "bodyHTML": "<p dir=\"auto\">Remove unused import</p>", "author": "samperson1997", "createdAt": "2020-11-28T07:28:59Z", "path": "server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.IOException;\n+import java.util.List;", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 1300693d92..8261635479 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -40,7 +39,6 @@ import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n \n import java.io.IOException;\n-import java.util.List;\n \n /**\n  * parse the binary mlog or snapshot to text\n", "next_change": {"commit": "61c6f6d47b087075554ed4f3636d4990a6da4395", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 8261635479..f8bbbc6e6c 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -37,6 +37,8 @@ import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n \n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\ndeleted file mode 100644\nindex f8bbbc6e6c..0000000000\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ /dev/null\n", "chunk": "@@ -1,194 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.iotdb.db.tools.mlog;\n-\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.DefaultParser;\n-import org.apache.commons.cli.HelpFormatter;\n-import org.apache.commons.cli.Option;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.ParseException;\n-import org.apache.iotdb.db.metadata.MLogTxtWriter;\n-import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.metadata.logfile.MLogReader;\n-import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-\n-/**\n- * parse the binary mlog or snapshot to text\n- */\n-public class MLogParser {\n-\n-  private static final Logger logger = LoggerFactory.getLogger(MLogParser.class);\n-  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n-\n-  private static final String FILE_ARGS = \"f\";\n-  private static final String FILE_NAME = \"mlog file\";\n-\n-  private static final String OUT_ARGS = \"o\";\n-  private static final String OUT_NAME = \"output txt file\";\n-\n-  private static final String HELP_ARGS = \"help\";\n-\n-  private static String inputFile;\n-  private static String outputFile;\n-\n-  /**\n-   * create the commandline options.\n-   *\n-   * @return object Options\n-   */\n-  public static Options createOptions() {\n-    Options options = new Options();\n-\n-    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n-      \"Need to specify a binary mlog file to parse (required)\")\n-      .build();\n-    options.addOption(opFile);\n-\n-    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n-      \"Could specify the output file after parse (optional)\")\n-      .build();\n-    options.addOption(opOut);\n-\n-    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n-      .hasArg(false).desc(\"Display help information\")\n-      .build();\n-    options.addOption(opHelp);\n-\n-    return options;\n-  }\n-\n-  public static void main(String[] args) {\n-    Options options = createOptions();\n-    HelpFormatter hf = new HelpFormatter();\n-    hf.setOptionComparator(null);\n-    CommandLine commandLine;\n-    CommandLineParser parser = new DefaultParser();\n-\n-    if (args == null || args.length == 0) {\n-      logger.warn(\"Too few params input, please check the following hint.\");\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    try {\n-      commandLine = parser.parse(options, args);\n-    } catch (ParseException e) {\n-      logger.error(\"Parse error: {}\", e.getMessage());\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    if (commandLine.hasOption(HELP_ARGS)) {\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-\n-    try {\n-      parseBasicParams(commandLine);\n-      parseFromFile(inputFile, outputFile);\n-    } catch (Exception e) {\n-      logger.error(\"Encounter an error, because: {} \", e.getMessage());\n-    }\n-  }\n-\n-  public static void parseBasicParams(CommandLine commandLine) throws ParseException {\n-    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n-    outputFile = commandLine.getOptionValue(OUT_ARGS);\n-\n-    if (outputFile == null) {\n-      outputFile = \"tmp.txt\";\n-    }\n-  }\n-\n-  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n-    throws ParseException {\n-    String str = commandLine.getOptionValue(arg);\n-    if (str == null) {\n-      String msg = String.format(\"Required values for option '%s' not provided\", name);\n-      logger.info(msg);\n-      logger.info(\"Use -help for more information\");\n-      throw new ParseException(msg);\n-    }\n-    return str;\n-  }\n-\n-  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n-    try (MLogReader mLogReader = new MLogReader(inputFile);\n-         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n-\n-      while (mLogReader.hasNext()) {\n-        PhysicalPlan plan = mLogReader.next();\n-        switch (plan.getOperatorType()) {\n-          case CREATE_TIMESERIES:\n-            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n-              ((CreateTimeSeriesPlan) plan).getTagOffset());\n-            break;\n-          case DELETE_TIMESERIES:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteTimeseries(partialPath.getFullPath());\n-            }\n-            break;\n-          case SET_STORAGE_GROUP:\n-            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n-            break;\n-          case DELETE_STORAGE_GROUP:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteStorageGroup(partialPath.getFullPath());\n-            }\n-            break;\n-          case TTL:\n-            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n-              ((SetTTLPlan) plan).getDataTTL());\n-            break;\n-          case CHANGE_ALIAS:\n-            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n-              ((ChangeAliasPlan) plan).getAlias());\n-            break;\n-          case CHANGE_TAG_OFFSET:\n-            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n-              ((ChangeTagOffsetPlan) plan).getOffset());\n-            break;\n-          case MEASUREMENT_MNODE:\n-            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n-            break;\n-          case STORAGE_GROUP_MNODE:\n-            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n-            break;\n-          case MNODE:\n-            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n-            break;\n-          default:\n-            logger.warn(\"unknown plan {}\", plan);\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nnew file mode 100644\nindex 0000000000..56a7a1a6f8\n--- /dev/null\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (inputFile == null) {\n+      inputFile = reader.readLine(\"please input your mlog path:\", '\\0');\n+    }\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {\n+    String str = commandLine.getOptionValue(arg);\n+    if (str == null) {\n+      String msg = String.format(\"Required values for option '%s' not provided\", name);\n+      System.out.println(msg);\n+      System.out.println(\"Use -help for more information\");\n+      throw new Exception(msg);\n+    }\n+    return str;\n+  }\n+\n+  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n+    try (MLogReader mLogReader = new MLogReader(inputFile);\n+         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n+\n+      while (mLogReader.hasNext()) {\n+        PhysicalPlan plan = mLogReader.next();\n+        switch (plan.getOperatorType()) {\n+          case CREATE_TIMESERIES:\n+            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n+              ((CreateTimeSeriesPlan) plan).getTagOffset());\n+            break;\n+          case DELETE_TIMESERIES: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteTimeseries(pathList.get(i).getFullPath());\n+            }\n+          }\n+            break;\n+          case SET_STORAGE_GROUP:\n+            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n+            break;\n+          case DELETE_STORAGE_GROUP: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteStorageGroup(pathList.get(i).getFullPath());\n+            }\n+          }\n+          break;\n+          case TTL:\n+            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n+              ((SetTTLPlan) plan).getDataTTL());\n+            break;\n+          case CHANGE_ALIAS:\n+            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n+              ((ChangeAliasPlan) plan).getAlias());\n+            break;\n+          case CHANGE_TAG_OFFSET:\n+            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n+              ((ChangeTagOffsetPlan) plan).getOffset());\n+            break;\n+          case MEASUREMENT_MNODE:\n+            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n+            break;\n+          case STORAGE_GROUP_MNODE:\n+            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n+            break;\n+          case MNODE:\n+            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n+            break;\n+          default:\n+            System.out.println(\"unknown plan \" + plan.toString());\n+        }\n+      }\n+    }\n+  }\n+}\n", "next_change": {"commit": "92930ca36dbeb586f2be035f297eef6e4041162b", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 56a7a1a6f8..5a303cfbef 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -203,7 +186,7 @@ public class MLogParser {\n             mLogTxtWriter.serializeMNode((MNodePlan) plan);\n             break;\n           default:\n-            System.out.println(\"unknown plan \" + plan.toString());\n+            logger.warn(\"unknown plan {}\", plan);\n         }\n       }\n     }\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 8261635479..f8bbbc6e6c 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -45,6 +47,7 @@ import java.io.IOException;\n  */\n public class MLogParser {\n \n+  private static final Logger logger = LoggerFactory.getLogger(MLogParser.class);\n   private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n \n   private static final String FILE_ARGS = \"f\";\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\ndeleted file mode 100644\nindex f8bbbc6e6c..0000000000\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ /dev/null\n", "chunk": "@@ -1,194 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.iotdb.db.tools.mlog;\n-\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.DefaultParser;\n-import org.apache.commons.cli.HelpFormatter;\n-import org.apache.commons.cli.Option;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.ParseException;\n-import org.apache.iotdb.db.metadata.MLogTxtWriter;\n-import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.metadata.logfile.MLogReader;\n-import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-\n-/**\n- * parse the binary mlog or snapshot to text\n- */\n-public class MLogParser {\n-\n-  private static final Logger logger = LoggerFactory.getLogger(MLogParser.class);\n-  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n-\n-  private static final String FILE_ARGS = \"f\";\n-  private static final String FILE_NAME = \"mlog file\";\n-\n-  private static final String OUT_ARGS = \"o\";\n-  private static final String OUT_NAME = \"output txt file\";\n-\n-  private static final String HELP_ARGS = \"help\";\n-\n-  private static String inputFile;\n-  private static String outputFile;\n-\n-  /**\n-   * create the commandline options.\n-   *\n-   * @return object Options\n-   */\n-  public static Options createOptions() {\n-    Options options = new Options();\n-\n-    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n-      \"Need to specify a binary mlog file to parse (required)\")\n-      .build();\n-    options.addOption(opFile);\n-\n-    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n-      \"Could specify the output file after parse (optional)\")\n-      .build();\n-    options.addOption(opOut);\n-\n-    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n-      .hasArg(false).desc(\"Display help information\")\n-      .build();\n-    options.addOption(opHelp);\n-\n-    return options;\n-  }\n-\n-  public static void main(String[] args) {\n-    Options options = createOptions();\n-    HelpFormatter hf = new HelpFormatter();\n-    hf.setOptionComparator(null);\n-    CommandLine commandLine;\n-    CommandLineParser parser = new DefaultParser();\n-\n-    if (args == null || args.length == 0) {\n-      logger.warn(\"Too few params input, please check the following hint.\");\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    try {\n-      commandLine = parser.parse(options, args);\n-    } catch (ParseException e) {\n-      logger.error(\"Parse error: {}\", e.getMessage());\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-    if (commandLine.hasOption(HELP_ARGS)) {\n-      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n-      return;\n-    }\n-\n-    try {\n-      parseBasicParams(commandLine);\n-      parseFromFile(inputFile, outputFile);\n-    } catch (Exception e) {\n-      logger.error(\"Encounter an error, because: {} \", e.getMessage());\n-    }\n-  }\n-\n-  public static void parseBasicParams(CommandLine commandLine) throws ParseException {\n-    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n-    outputFile = commandLine.getOptionValue(OUT_ARGS);\n-\n-    if (outputFile == null) {\n-      outputFile = \"tmp.txt\";\n-    }\n-  }\n-\n-  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n-    throws ParseException {\n-    String str = commandLine.getOptionValue(arg);\n-    if (str == null) {\n-      String msg = String.format(\"Required values for option '%s' not provided\", name);\n-      logger.info(msg);\n-      logger.info(\"Use -help for more information\");\n-      throw new ParseException(msg);\n-    }\n-    return str;\n-  }\n-\n-  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n-    try (MLogReader mLogReader = new MLogReader(inputFile);\n-         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n-\n-      while (mLogReader.hasNext()) {\n-        PhysicalPlan plan = mLogReader.next();\n-        switch (plan.getOperatorType()) {\n-          case CREATE_TIMESERIES:\n-            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n-              ((CreateTimeSeriesPlan) plan).getTagOffset());\n-            break;\n-          case DELETE_TIMESERIES:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteTimeseries(partialPath.getFullPath());\n-            }\n-            break;\n-          case SET_STORAGE_GROUP:\n-            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n-            break;\n-          case DELETE_STORAGE_GROUP:\n-            for (PartialPath partialPath : plan.getPaths()) {\n-              mLogTxtWriter.deleteStorageGroup(partialPath.getFullPath());\n-            }\n-            break;\n-          case TTL:\n-            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n-              ((SetTTLPlan) plan).getDataTTL());\n-            break;\n-          case CHANGE_ALIAS:\n-            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n-              ((ChangeAliasPlan) plan).getAlias());\n-            break;\n-          case CHANGE_TAG_OFFSET:\n-            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n-              ((ChangeTagOffsetPlan) plan).getOffset());\n-            break;\n-          case MEASUREMENT_MNODE:\n-            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n-            break;\n-          case STORAGE_GROUP_MNODE:\n-            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n-            break;\n-          case MNODE:\n-            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n-            break;\n-          default:\n-            logger.warn(\"unknown plan {}\", plan);\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nnew file mode 100644\nindex 0000000000..56a7a1a6f8\n--- /dev/null\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.mlog;\n+\n+import jline.console.ConsoleReader;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.iotdb.db.metadata.MLogTxtWriter;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.logfile.MLogReader;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+\n+/**\n+ * parse the binary mlog or snapshot to text\n+ */\n+public class MLogParser {\n+\n+  private static final String MLOG_CLI_PREFIX = \"MlogParser\";\n+\n+  private static final String FILE_ARGS = \"f\";\n+  private static final String FILE_NAME = \"mlog file\";\n+\n+  private static final String OUT_ARGS = \"o\";\n+  private static final String OUT_NAME = \"output txt file\";\n+\n+  private static final String HELP_ARGS = \"help\";\n+\n+  private static String inputFile;\n+  private static String outputFile;\n+\n+  /**\n+   * create the commandline options.\n+   *\n+   * @return object Options\n+   */\n+  public static Options createOptions() {\n+    Options options = new Options();\n+\n+    Option opFile = Option.builder(FILE_ARGS).required().argName(FILE_NAME).hasArg().desc(\n+      \"Need to specify a binary mlog file to parse (required)\")\n+      .build();\n+    options.addOption(opFile);\n+\n+    Option opOut = Option.builder(OUT_ARGS).required(false).argName(OUT_NAME).hasArg().desc(\n+      \"Could specify the output file after parse (optional)\")\n+      .build();\n+    options.addOption(opOut);\n+\n+    Option opHelp = Option.builder(HELP_ARGS).longOpt(HELP_ARGS)\n+      .hasArg(false).desc(\"Display help information\")\n+      .build();\n+    options.addOption(opHelp);\n+\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    Options options = createOptions();\n+    HelpFormatter hf = new HelpFormatter();\n+    hf.setOptionComparator(null);\n+    CommandLine commandLine;\n+    CommandLineParser parser = new DefaultParser();\n+\n+    if (args == null || args.length == 0) {\n+      System.out.println(\"Too few params input, please check the following hint.\");\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    try {\n+      commandLine = parser.parse(options, args);\n+    } catch (ParseException e) {\n+      System.out.println(\"Parse error: \" + e.getMessage());\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+    if (commandLine.hasOption(HELP_ARGS)) {\n+      hf.printHelp(MLOG_CLI_PREFIX, options, true);\n+      return;\n+    }\n+\n+    ConsoleReader reader = new ConsoleReader();\n+    reader.setExpandEvents(false);\n+    try {\n+      parseBasicParams(commandLine, reader);\n+      parseFromFile(inputFile, outputFile);\n+    } catch (Exception e) {\n+      System.out.println(\"Encounter an error, because: \" + e.getMessage());\n+    } finally {\n+      reader.close();\n+    }\n+  }\n+\n+  public static void parseBasicParams(CommandLine commandLine, ConsoleReader reader) throws Exception {\n+    inputFile = checkRequiredArg(FILE_ARGS, FILE_NAME, commandLine);\n+    outputFile = commandLine.getOptionValue(OUT_ARGS);\n+\n+    if (inputFile == null) {\n+      inputFile = reader.readLine(\"please input your mlog path:\", '\\0');\n+    }\n+    if (outputFile == null) {\n+      outputFile = \"tmp.txt\";\n+    }\n+  }\n+\n+  public static String checkRequiredArg(String arg, String name, CommandLine commandLine)\n+    throws Exception {\n+    String str = commandLine.getOptionValue(arg);\n+    if (str == null) {\n+      String msg = String.format(\"Required values for option '%s' not provided\", name);\n+      System.out.println(msg);\n+      System.out.println(\"Use -help for more information\");\n+      throw new Exception(msg);\n+    }\n+    return str;\n+  }\n+\n+  public static void parseFromFile(String inputFile, String outputFile) throws IOException {\n+    try (MLogReader mLogReader = new MLogReader(inputFile);\n+         MLogTxtWriter mLogTxtWriter = new MLogTxtWriter(outputFile)) {\n+\n+      while (mLogReader.hasNext()) {\n+        PhysicalPlan plan = mLogReader.next();\n+        switch (plan.getOperatorType()) {\n+          case CREATE_TIMESERIES:\n+            mLogTxtWriter.createTimeseries((CreateTimeSeriesPlan)plan,\n+              ((CreateTimeSeriesPlan) plan).getTagOffset());\n+            break;\n+          case DELETE_TIMESERIES: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteTimeseries(pathList.get(i).getFullPath());\n+            }\n+          }\n+            break;\n+          case SET_STORAGE_GROUP:\n+            mLogTxtWriter.setStorageGroup(((SetStorageGroupPlan) plan).getPath().getFullPath());\n+            break;\n+          case DELETE_STORAGE_GROUP: {\n+            List<PartialPath> pathList = plan.getPaths();\n+            for (int i = 0; i < pathList.size(); i++) {\n+              mLogTxtWriter.deleteStorageGroup(pathList.get(i).getFullPath());\n+            }\n+          }\n+          break;\n+          case TTL:\n+            mLogTxtWriter.setTTL(((SetTTLPlan) plan).getStorageGroup().getFullPath(),\n+              ((SetTTLPlan) plan).getDataTTL());\n+            break;\n+          case CHANGE_ALIAS:\n+            mLogTxtWriter.changeAlias(((ChangeAliasPlan) plan).getPath().getFullPath(),\n+              ((ChangeAliasPlan) plan).getAlias());\n+            break;\n+          case CHANGE_TAG_OFFSET:\n+            mLogTxtWriter.changeOffset(((ChangeTagOffsetPlan) plan).getPath().getFullPath(),\n+              ((ChangeTagOffsetPlan) plan).getOffset());\n+            break;\n+          case MEASUREMENT_MNODE:\n+            mLogTxtWriter.serializeMeasurementMNode((MeasurementMNodePlan) plan);\n+            break;\n+          case STORAGE_GROUP_MNODE:\n+            mLogTxtWriter.serializeStorageGroupMNode((StorageGroupMNodePlan) plan);\n+            break;\n+          case MNODE:\n+            mLogTxtWriter.serializeMNode((MNodePlan) plan);\n+            break;\n+          default:\n+            System.out.println(\"unknown plan \" + plan.toString());\n+        }\n+      }\n+    }\n+  }\n+}\n", "next_change": {"commit": "92930ca36dbeb586f2be035f297eef6e4041162b", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\nindex 56a7a1a6f8..5a303cfbef 100644\n--- a/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n+++ b/server/src/main/java/org/apache/iotdb/db/tools/mlog/MLogParser.java\n", "chunk": "@@ -203,7 +186,7 @@ public class MLogParser {\n             mLogTxtWriter.serializeMNode((MNodePlan) plan);\n             break;\n           default:\n-            System.out.println(\"unknown plan \" + plan.toString());\n+            logger.warn(\"unknown plan {}\", plan);\n         }\n       }\n     }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk5MjMzNw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r531992337", "body": "Remove this line", "bodyText": "Remove this line", "bodyHTML": "<p dir=\"auto\">Remove this line</p>", "author": "samperson1997", "createdAt": "2020-11-28T07:38:36Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java", "diffHunk": "@@ -269,6 +267,7 @@ public void testRestartEndTime()\n       };\n       int cnt = 0;\n       try (ResultSet resultSet = statement.getResultSet()) {\n+        System.out.println(resultSet.toString());", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java\nindex e2f6513ee7..9f643c69bd 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java\n", "chunk": "@@ -267,7 +266,6 @@ public class IoTDBRestartIT {\n       };\n       int cnt = 0;\n       try (ResultSet resultSet = statement.getResultSet()) {\n-        System.out.println(resultSet.toString());\n         while (resultSet.next()) {\n           String result = resultSet.getString(TIMESTAMP_STR) + \",\" + resultSet.getString(2);\n           assertEquals(exp[cnt], result);\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java\nindex 9f643c69bd..a49faf3e5c 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java\n", "chunk": "@@ -266,6 +266,7 @@ public class IoTDBRestartIT {\n       };\n       int cnt = 0;\n       try (ResultSet resultSet = statement.getResultSet()) {\n+        System.out.println(resultSet.toString());\n         while (resultSet.next()) {\n           String result = resultSet.getString(TIMESTAMP_STR) + \",\" + resultSet.getString(2);\n           assertEquals(exp[cnt], result);\n", "next_change": {"commit": "95516e01ca4ba2e1134b4202b86c53ffbfe196ea", "changed_code": [{"header": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java\nindex a49faf3e5c..9f643c69bd 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBRestartIT.java\n", "chunk": "@@ -266,7 +266,6 @@ public class IoTDBRestartIT {\n       };\n       int cnt = 0;\n       try (ResultSet resultSet = statement.getResultSet()) {\n-        System.out.println(resultSet.toString());\n         while (resultSet.next()) {\n           String result = resultSet.getString(TIMESTAMP_STR) + \",\" + resultSet.getString(2);\n           assertEquals(exp[cnt], result);\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjAwNDM2Mw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r532004363", "body": "```suggestion\r\n      Set<PhysicalPlan> d0Plans = new HashSet<>(6);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  HashSet<PhysicalPlan> d0Plans = new HashSet<>(6);\n          \n          \n            \n                  Set<PhysicalPlan> d0Plans = new HashSet<>(6);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      <span class=\"pl-k\"><span class=\"x x-first x-last\">HashSet</span>&lt;<span class=\"pl-smi\">PhysicalPlan</span>&gt;</span> d0Plans <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-k\">HashSet&lt;&gt;</span>(<span class=\"pl-c1\">6</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-k\"><span class=\"x x-first x-last\">Set</span>&lt;<span class=\"pl-smi\">PhysicalPlan</span>&gt;</span> d0Plans <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-k\">HashSet&lt;&gt;</span>(<span class=\"pl-c1\">6</span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "samperson1997", "createdAt": "2020-11-28T08:17:53Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java", "diffHunk": "@@ -71,35 +78,52 @@ public void createSnapshotTest() throws ClassNotFoundException {\n \n       // create snapshot\n       statement.execute(\"CREATE SNAPSHOT FOR SCHEMA\");\n-      File snapshotFile = new File(config.getSchemaDir() + File.separator + \"mtree-1.snapshot\");\n+      File snapshotFile = new File(config.getSchemaDir() + File.separator + \"mtree-1.snapshot.bin\");\n \n       // test snapshot file exists\n       Assert.assertTrue(snapshotFile.exists());\n \n       // test snapshot content correct\n-      Set<String> e1 = new HashSet<>(Arrays.asList(\"2,s0,,1,2,1,,-1,0\", \"2,s1,,2,2,1,,-1,0\",\n-          \"2,s2,,3,2,1,,-1,0\", \"2,s3,,5,0,1,,-1,0\", \"2,s4,,0,0,1,,-1,0\"));\n-      Set<String> e2 = new HashSet<>(Arrays.asList(\"2,s0,,1,2,1,,-1,0\", \"2,s1,,5,0,1,,-1,0\",\n-          \"2,s2,,0,0,1,,-1,0\"));\n-\n-      try (BufferedReader br = new BufferedReader(new FileReader(snapshotFile))) {\n-        for (int i = 0; i < 5; ++i) {\n-          String actual = br.readLine();\n-          Assert.assertTrue(e1.removeIf(candidate -> candidate.equals(actual)));\n-        }\n-        Assert.assertTrue(e1.isEmpty());\n+      String[] exp = new String[]{\n+        \"2,s0,,1,2,1,,-1,0\",\n+        \"2,s1,,2,2,1,,-1,0\",\n+        \"2,s2,,3,2,1,,-1,0\",\n+        \"2,s3,,5,0,1,,-1,0\",\n+        \"2,s4,,0,0,1,,-1,0\",\n+        \"1,d0,9223372036854775807,5\",\n+        \"2,s0,,1,2,1,,-1,0\",\n+        \"2,s1,,5,0,1,,-1,0\",\n+        \"2,s2,,0,0,1,,-1,0\",\n+        \"1,d1,9223372036854775807,3\",\n+        \"0,vehicle,2\",\n+        \"0,root,1\"\n+      };\n \n-        Assert.assertEquals(\"1,d0,9223372036854775807,5\", br.readLine());\n+      HashSet<PhysicalPlan> d0Plans = new HashSet<>(6);", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\nindex 73ff187ad9..e52ea00d93 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n", "chunk": "@@ -99,12 +99,12 @@ public class IoTDBCreateSnapshotIT {\n         \"0,root,1\"\n       };\n \n-      HashSet<PhysicalPlan> d0Plans = new HashSet<>(6);\n+      Set<PhysicalPlan> d0Plans = new HashSet<>(6);\n       for (int i = 0; i < 6; i++) {\n         d0Plans.add(MLogWriter.convertFromString(exp[i]));\n       }\n \n-      HashSet<PhysicalPlan> d1Plans = new HashSet<>(6);\n+      Set<PhysicalPlan> d1Plans = new HashSet<>(6);\n       for (int i = 0; i < 6; i++) {\n         d1Plans.add(MLogWriter.convertFromString(exp[i+6]));\n       }\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\nindex e52ea00d93..9c07ad9ed1 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n", "chunk": "@@ -99,31 +101,17 @@ public class IoTDBCreateSnapshotIT {\n         \"0,root,1\"\n       };\n \n-      Set<PhysicalPlan> d0Plans = new HashSet<>(6);\n-      for (int i = 0; i < 6; i++) {\n-        d0Plans.add(MLogWriter.convertFromString(exp[i]));\n-      }\n-\n-      Set<PhysicalPlan> d1Plans = new HashSet<>(6);\n-      for (int i = 0; i < 6; i++) {\n-        d1Plans.add(MLogWriter.convertFromString(exp[i+6]));\n+      PhysicalPlan[] plans = new PhysicalPlan[exp.length];\n+      for (int i = 0; i < exp.length; i++) {\n+        plans[i] = convertFromString(exp[i]);\n       }\n \n       try (MLogReader mLogReader = new MLogReader(snapshotFile)){\n         int i = 0;\n-        while (i < 6 && mLogReader.hasNext()) {\n-          PhysicalPlan plan = mLogReader.next();\n-          assertTrue(d0Plans.removeIf(candidate -> candidate.equals(plan)));\n-          i++;\n-        }\n-        assertTrue(d0Plans.isEmpty());\n-\n-        while (i < 12 && mLogReader.hasNext()) {\n+        while (mLogReader.hasNext()) {\n           PhysicalPlan plan = mLogReader.next();\n-          assertTrue(d1Plans.removeIf(candidate -> candidate.equals(plan)));\n-          i++;\n+          assertEquals(plans[i++], plan);\n         }\n-        assertTrue(d1Plans.isEmpty());\n       }\n     } catch (Exception e) {\n       e.printStackTrace();\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\nindex 9c07ad9ed1..a268ff0988 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n", "chunk": "@@ -101,17 +98,31 @@ public class IoTDBCreateSnapshotIT {\n         \"0,root,1\"\n       };\n \n-      PhysicalPlan[] plans = new PhysicalPlan[exp.length];\n-      for (int i = 0; i < exp.length; i++) {\n-        plans[i] = convertFromString(exp[i]);\n+      HashSet<PhysicalPlan> d0Plans = new HashSet<>(6);\n+      for (int i = 0; i < 6; i++) {\n+        d0Plans.add(convertFromString(exp[i]));\n+      }\n+\n+      HashSet<PhysicalPlan> d1Plans = new HashSet<>(6);\n+      for (int i = 0; i < 6; i++) {\n+        d1Plans.add(convertFromString(exp[i+6]));\n       }\n \n       try (MLogReader mLogReader = new MLogReader(snapshotFile)){\n         int i = 0;\n-        while (mLogReader.hasNext()) {\n+        while (i < 6 && mLogReader.hasNext()) {\n+          PhysicalPlan plan = mLogReader.next();\n+          assertTrue(d0Plans.removeIf(candidate -> candidate.equals(plan)));\n+          i++;\n+        }\n+        assertTrue(d0Plans.isEmpty());\n+\n+        while (i < 12 && mLogReader.hasNext()) {\n           PhysicalPlan plan = mLogReader.next();\n-          assertEquals(plans[i++], plan);\n+          assertTrue(d1Plans.removeIf(candidate -> candidate.equals(plan)));\n+          i++;\n         }\n+        assertTrue(d1Plans.isEmpty());\n       }\n     } catch (Exception e) {\n       e.printStackTrace();\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjAwNDM3MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r532004370", "body": "```suggestion\r\n      Set<PhysicalPlan> d1Plans = new HashSet<>(6);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  HashSet<PhysicalPlan> d1Plans = new HashSet<>(6);\n          \n          \n            \n                  Set<PhysicalPlan> d1Plans = new HashSet<>(6);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      <span class=\"pl-k\"><span class=\"x x-first x-last\">HashSet</span>&lt;<span class=\"pl-smi\">PhysicalPlan</span>&gt;</span> d1Plans <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-k\">HashSet&lt;&gt;</span>(<span class=\"pl-c1\">6</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-k\"><span class=\"x x-first x-last\">Set</span>&lt;<span class=\"pl-smi\">PhysicalPlan</span>&gt;</span> d1Plans <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-k\">HashSet&lt;&gt;</span>(<span class=\"pl-c1\">6</span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "samperson1997", "createdAt": "2020-11-28T08:18:03Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java", "diffHunk": "@@ -71,35 +78,52 @@ public void createSnapshotTest() throws ClassNotFoundException {\n \n       // create snapshot\n       statement.execute(\"CREATE SNAPSHOT FOR SCHEMA\");\n-      File snapshotFile = new File(config.getSchemaDir() + File.separator + \"mtree-1.snapshot\");\n+      File snapshotFile = new File(config.getSchemaDir() + File.separator + \"mtree-1.snapshot.bin\");\n \n       // test snapshot file exists\n       Assert.assertTrue(snapshotFile.exists());\n \n       // test snapshot content correct\n-      Set<String> e1 = new HashSet<>(Arrays.asList(\"2,s0,,1,2,1,,-1,0\", \"2,s1,,2,2,1,,-1,0\",\n-          \"2,s2,,3,2,1,,-1,0\", \"2,s3,,5,0,1,,-1,0\", \"2,s4,,0,0,1,,-1,0\"));\n-      Set<String> e2 = new HashSet<>(Arrays.asList(\"2,s0,,1,2,1,,-1,0\", \"2,s1,,5,0,1,,-1,0\",\n-          \"2,s2,,0,0,1,,-1,0\"));\n-\n-      try (BufferedReader br = new BufferedReader(new FileReader(snapshotFile))) {\n-        for (int i = 0; i < 5; ++i) {\n-          String actual = br.readLine();\n-          Assert.assertTrue(e1.removeIf(candidate -> candidate.equals(actual)));\n-        }\n-        Assert.assertTrue(e1.isEmpty());\n+      String[] exp = new String[]{\n+        \"2,s0,,1,2,1,,-1,0\",\n+        \"2,s1,,2,2,1,,-1,0\",\n+        \"2,s2,,3,2,1,,-1,0\",\n+        \"2,s3,,5,0,1,,-1,0\",\n+        \"2,s4,,0,0,1,,-1,0\",\n+        \"1,d0,9223372036854775807,5\",\n+        \"2,s0,,1,2,1,,-1,0\",\n+        \"2,s1,,5,0,1,,-1,0\",\n+        \"2,s2,,0,0,1,,-1,0\",\n+        \"1,d1,9223372036854775807,3\",\n+        \"0,vehicle,2\",\n+        \"0,root,1\"\n+      };\n \n-        Assert.assertEquals(\"1,d0,9223372036854775807,5\", br.readLine());\n+      HashSet<PhysicalPlan> d0Plans = new HashSet<>(6);\n+      for (int i = 0; i < 6; i++) {\n+        d0Plans.add(MLogWriter.convertFromString(exp[i]));\n+      }\n+\n+      HashSet<PhysicalPlan> d1Plans = new HashSet<>(6);", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\nindex 73ff187ad9..e52ea00d93 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n", "chunk": "@@ -99,12 +99,12 @@ public class IoTDBCreateSnapshotIT {\n         \"0,root,1\"\n       };\n \n-      HashSet<PhysicalPlan> d0Plans = new HashSet<>(6);\n+      Set<PhysicalPlan> d0Plans = new HashSet<>(6);\n       for (int i = 0; i < 6; i++) {\n         d0Plans.add(MLogWriter.convertFromString(exp[i]));\n       }\n \n-      HashSet<PhysicalPlan> d1Plans = new HashSet<>(6);\n+      Set<PhysicalPlan> d1Plans = new HashSet<>(6);\n       for (int i = 0; i < 6; i++) {\n         d1Plans.add(MLogWriter.convertFromString(exp[i+6]));\n       }\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\nindex e52ea00d93..9c07ad9ed1 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n", "chunk": "@@ -99,31 +101,17 @@ public class IoTDBCreateSnapshotIT {\n         \"0,root,1\"\n       };\n \n-      Set<PhysicalPlan> d0Plans = new HashSet<>(6);\n-      for (int i = 0; i < 6; i++) {\n-        d0Plans.add(MLogWriter.convertFromString(exp[i]));\n-      }\n-\n-      Set<PhysicalPlan> d1Plans = new HashSet<>(6);\n-      for (int i = 0; i < 6; i++) {\n-        d1Plans.add(MLogWriter.convertFromString(exp[i+6]));\n+      PhysicalPlan[] plans = new PhysicalPlan[exp.length];\n+      for (int i = 0; i < exp.length; i++) {\n+        plans[i] = convertFromString(exp[i]);\n       }\n \n       try (MLogReader mLogReader = new MLogReader(snapshotFile)){\n         int i = 0;\n-        while (i < 6 && mLogReader.hasNext()) {\n-          PhysicalPlan plan = mLogReader.next();\n-          assertTrue(d0Plans.removeIf(candidate -> candidate.equals(plan)));\n-          i++;\n-        }\n-        assertTrue(d0Plans.isEmpty());\n-\n-        while (i < 12 && mLogReader.hasNext()) {\n+        while (mLogReader.hasNext()) {\n           PhysicalPlan plan = mLogReader.next();\n-          assertTrue(d1Plans.removeIf(candidate -> candidate.equals(plan)));\n-          i++;\n+          assertEquals(plans[i++], plan);\n         }\n-        assertTrue(d1Plans.isEmpty());\n       }\n     } catch (Exception e) {\n       e.printStackTrace();\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\nindex 9c07ad9ed1..a268ff0988 100644\n--- a/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n+++ b/server/src/test/java/org/apache/iotdb/db/integration/IoTDBCreateSnapshotIT.java\n", "chunk": "@@ -101,17 +98,31 @@ public class IoTDBCreateSnapshotIT {\n         \"0,root,1\"\n       };\n \n-      PhysicalPlan[] plans = new PhysicalPlan[exp.length];\n-      for (int i = 0; i < exp.length; i++) {\n-        plans[i] = convertFromString(exp[i]);\n+      HashSet<PhysicalPlan> d0Plans = new HashSet<>(6);\n+      for (int i = 0; i < 6; i++) {\n+        d0Plans.add(convertFromString(exp[i]));\n+      }\n+\n+      HashSet<PhysicalPlan> d1Plans = new HashSet<>(6);\n+      for (int i = 0; i < 6; i++) {\n+        d1Plans.add(convertFromString(exp[i+6]));\n       }\n \n       try (MLogReader mLogReader = new MLogReader(snapshotFile)){\n         int i = 0;\n-        while (mLogReader.hasNext()) {\n+        while (i < 6 && mLogReader.hasNext()) {\n+          PhysicalPlan plan = mLogReader.next();\n+          assertTrue(d0Plans.removeIf(candidate -> candidate.equals(plan)));\n+          i++;\n+        }\n+        assertTrue(d0Plans.isEmpty());\n+\n+        while (i < 12 && mLogReader.hasNext()) {\n           PhysicalPlan plan = mLogReader.next();\n-          assertEquals(plans[i++], plan);\n+          assertTrue(d1Plans.removeIf(candidate -> candidate.equals(plan)));\n+          i++;\n         }\n+        assertTrue(d1Plans.isEmpty());\n       }\n     } catch (Exception e) {\n       e.printStackTrace();\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjAwNDk5Mw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r532004993", "body": "You can add `@TestOnly` for this method", "bodyText": "You can add @TestOnly for this method", "bodyHTML": "<p dir=\"auto\">You can add <code>@TestOnly</code> for this method</p>", "author": "samperson1997", "createdAt": "2020-11-28T08:25:14Z", "path": "server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java", "diffHunk": "@@ -38,16 +38,34 @@\n   private FileOutputStream fileOutputStream;\n   private FileChannel channel;\n   private CRC32 checkSummer = new CRC32();\n-  private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n   private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n   private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private long forcePeriodInMs = 0;\n \n-  public LogWriter(String logFilePath) {\n+  /**\n+   * only used by tests\n+   * @param logFilePath\n+   * @param forcePeriodInMs\n+   * @throws FileNotFoundException\n+   */\n+  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex 4d39671863..e85e08ab1d 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -43,11 +44,11 @@ public class LogWriter implements ILogWriter {\n   private long forcePeriodInMs = 0;\n \n   /**\n-   * only used by tests\n    * @param logFilePath\n    * @param forcePeriodInMs\n    * @throws FileNotFoundException\n    */\n+  @TestOnly\n   public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex e85e08ab1d..66501a7f69 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -39,16 +39,11 @@ public class LogWriter implements ILogWriter {\n   private FileOutputStream fileOutputStream;\n   private FileChannel channel;\n   private CRC32 checkSummer = new CRC32();\n+  private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n   private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n   private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n   private long forcePeriodInMs = 0;\n \n-  /**\n-   * @param logFilePath\n-   * @param forcePeriodInMs\n-   * @throws FileNotFoundException\n-   */\n-  @TestOnly\n   public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex 66501a7f69..a39c6f2533 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -39,11 +39,16 @@ public class LogWriter implements ILogWriter {\n   private FileOutputStream fileOutputStream;\n   private FileChannel channel;\n   private CRC32 checkSummer = new CRC32();\n-  private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n   private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n   private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n   private long forcePeriodInMs = 0;\n \n+  /**\n+   * only used by tests\n+   * @param logFilePath\n+   * @param forcePeriodInMs\n+   * @throws FileNotFoundException\n+   */\n   public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n", "next_change": {"commit": "95516e01ca4ba2e1134b4202b86c53ffbfe196ea", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex a39c6f2533..0752832573 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -44,11 +44,11 @@ public class LogWriter implements ILogWriter {\n   private long forcePeriodInMs = 0;\n \n   /**\n-   * only used by tests\n    * @param logFilePath\n    * @param forcePeriodInMs\n    * @throws FileNotFoundException\n    */\n+  @TestOnly\n   public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n", "next_change": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex 0752832573..f91caddeb4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -53,20 +57,16 @@ public class LogWriter implements ILogWriter {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n     this.logFile = logFile;\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   @Override\n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex f91caddeb4..16ae42720a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -45,25 +45,25 @@ public class LogWriter implements ILogWriter {\n   private final CRC32 checkSummer = new CRC32();\n   private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n   private final ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n-  private final long forcePeriodInMs;\n+  private final boolean forceEachWrite;\n \n   /**\n    * @param logFilePath\n-   * @param forcePeriodInMs\n+   * @param forceEachWrite\n    * @throws FileNotFoundException\n    */\n   @TestOnly\n-  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n+  public LogWriter(String logFilePath, boolean forceEachWrite) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n-    this.forcePeriodInMs = forcePeriodInMs;\n+    this.forceEachWrite = forceEachWrite;\n \n     fileOutputStream = new FileOutputStream(logFile, true);\n     channel = fileOutputStream.getChannel();\n   }\n \n-  public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n+  public LogWriter(File logFile, boolean forceEachWrite) throws FileNotFoundException {\n     this.logFile = logFile;\n-    this.forcePeriodInMs = forcePeriodInMs;\n+    this.forceEachWrite = forceEachWrite;\n \n     fileOutputStream = new FileOutputStream(logFile, true);\n     channel = fileOutputStream.getChannel();\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjAwNjk0OA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r532006948", "body": "```suggestion\r\n  @TestOnly\r\n  public void flushAllMlogForTest() throws IOException {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /**\n          \n          \n            \n               * only for test\n          \n          \n            \n               */\n          \n          \n            \n              public void flushAllMlogForTest() throws IOException {\n          \n          \n            \n              @TestOnly\n          \n          \n            \n              public void flushAllMlogForTest() throws IOException {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"1665\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">  <span class=\"pl-c\"><span class=\"pl-c\">/**</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"1666\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> only <span class=\"pl-k\">for</span> test</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"1667\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*/</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"1668\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">  <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> flushAllMlogForTest() throws <span class=\"pl-smi\">IOException</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"1665\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  <span class=\"pl-k\">@TestOnly</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"1666\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> flushAllMlogForTest() throws <span class=\"pl-smi\">IOException</span> {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "samperson1997", "createdAt": "2020-11-28T08:49:19Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1680,6 +1647,13 @@ public TimeValuePair getLastCache(PartialPath seriesPath) {\n     return null;\n   }\n \n+  /**\n+   * only for test\n+   */\n+  public void flushAllMlogForTest() throws IOException {", "originalCommit": "71ee0a008fd1441ce88eb2e7d8db345a2c3b28de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex f13ed7a4d5..23f64db273 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n", "chunk": "@@ -1647,9 +1657,7 @@ public class MManager {\n     return null;\n   }\n \n-  /**\n-   * only for test\n-   */\n+  @TestOnly\n   public void flushAllMlogForTest() throws IOException {\n     logWriter.close();\n   }\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex 23f64db273..b68316845c 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n", "chunk": "@@ -1657,11 +1657,6 @@ public class MManager {\n     return null;\n   }\n \n-  @TestOnly\n-  public void flushAllMlogForTest() throws IOException {\n-    logWriter.close();\n-  }\n-\n   private void checkMTreeModified() {\n     if (logWriter == null || logFile == null) {\n       // the logWriter is not initialized now, we skip the check once.\n", "next_change": {"commit": "7799fbede947fca9a49d61ce1be81cf359701bf7", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex b68316845c..0ddc10bc9d 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n", "chunk": "@@ -1657,6 +1664,18 @@ public class MManager {\n     return null;\n   }\n \n+  private void forceMlog() {\n+    if (logWriter == null || logFile == null) {\n+      // the logWriter is not initialized now, we skip the check once.\n+      return;\n+    }\n+    try {\n+      logWriter.force();\n+    } catch (IOException e) {\n+      logger.error(\"Cannot force mlog, because \", e);\n+    }\n+  }\n+\n   private void checkMTreeModified() {\n     if (logWriter == null || logFile == null) {\n       // the logWriter is not initialized now, we skip the check once.\n", "next_change": {"commit": "6b7bedc50ce23dac41fedfd29b143e11285794af", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex 0ddc10bc9d..53079ad3e7 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n", "chunk": "@@ -1664,16 +1656,11 @@ public class MManager {\n     return null;\n   }\n \n-  private void forceMlog() {\n-    if (logWriter == null || logFile == null) {\n-      // the logWriter is not initialized now, we skip the check once.\n-      return;\n-    }\n-    try {\n-      logWriter.force();\n-    } catch (IOException e) {\n-      logger.error(\"Cannot force mlog, because \", e);\n-    }\n+  /**\n+   * only for test\n+   */\n+  public void flushAllMlogForTest() throws IOException {\n+    logWriter.close();\n   }\n \n   private void checkMTreeModified() {\n", "next_change": {"commit": "95516e01ca4ba2e1134b4202b86c53ffbfe196ea", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\nindex 53079ad3e7..7655bf02af 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n", "chunk": "@@ -1656,9 +1655,7 @@ public class MManager {\n     return null;\n   }\n \n-  /**\n-   * only for test\n-   */\n+  @TestOnly\n   public void flushAllMlogForTest() throws IOException {\n     logWriter.close();\n   }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzIyOTM5Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r537229396", "body": "do we need to upgrade grom 0.11 to 0.12?", "bodyText": "do we need to upgrade grom 0.11 to 0.12?", "bodyHTML": "<p dir=\"auto\">do we need to upgrade grom 0.11 to 0.12?</p>", "author": "qiaojialin", "createdAt": "2020-12-07T04:50:35Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -184,27 +185,23 @@ public void checkConfig() throws IOException {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.11\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n-          + \" Please upgrade to v0.10 first\");\n+    // check whether upgrading from v0.9 to v0.12\n+    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n+      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n+          + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n-    // check whether upgrading from v0.10 to v0.11\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {", "originalCommit": "5e68450a813c60198cfa99b799ac6f02e039428e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61c6f6d47b087075554ed4f3636d4990a6da4395", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex be1689ec8e..9d7efd1c86 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,23 +185,33 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.12\n+    // check whether upgrading from <=v0.10 to v0.12\n     if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n       properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n       logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n           + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n+\n+    // check whether upgrading from v0.11 to v0.12\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n+      logger.info(\"Upgrading IoTDB from v0.11 to v0.12, checking files...\");\n+      checkUnClosedTsFileV2();\n+      upgradePropertiesFile();\n+      logger.info(\"Upgrade to IoTDB v0.12 successfully!\");\n+    }\n+\n     MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n \n   /**\n-   * upgrade 0.10 properties to 0.11 properties\n+   * upgrade 0.11 properties to 0.12 properties\n    */\n+  @SuppressWarnings(\"unused\")\n   private void upgradePropertiesFile()\n-    throws IOException {\n+      throws IOException {\n     // create an empty tmpPropertiesFile\n     if (tmpPropertiesFile.createNewFile()) {\n       logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 9d7efd1c86..c1274ac49f 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,29 +185,45 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from <=v0.10 to v0.12\n-    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n-      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n-          + \" Please upgrade to v0.11 first\");\n+    // check whether upgrading\n+    if (!properties.containsKey(IOTDB_VERSION_STRING)\n+        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")\n+        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.11 or lower version NOW\");\n       System.exit(-1);\n     }\n \n-    // check whether upgrading from v0.11 to v0.12\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n-      logger.info(\"Upgrading IoTDB from v0.11 to v0.12, checking files...\");\n+    // check whether upgrading from v0.10 to v0.11\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n       checkUnClosedTsFileV2();\n       upgradePropertiesFile();\n-      logger.info(\"Upgrade to IoTDB v0.12 successfully!\");\n-    }\n+      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n+\n+      // upgrade mlog finished, delete old mlog file\n+      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+          + MetadataConstant.METADATA_LOG);\n+      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n+          + \".tmp\");\n+\n+      if (!mlogFile.delete()) {\n+        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n+      }\n+      // rename tmpLogFile to mlog\n+      FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n-    MLogWriter.upgradeMLog();\n+      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+          + MetadataConstant.METADATA_OLD_LOG);\n \n+      if (oldMLogFile.delete()) {\n+        throw new IOException(\"Deleting old mlog \" + oldMLogFile + \"failed.\");\n+      }\n+    }\n     checkProperties();\n   }\n \n   /**\n-   * upgrade 0.11 properties to 0.12 properties\n+   * upgrade 0.10 properties to 0.11 properties\n    */\n   @SuppressWarnings(\"unused\")\n   private void upgradePropertiesFile()\n", "next_change": {"commit": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex c1274ac49f..d00a287f5a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,44 +185,20 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)\n-        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")\n-        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.11 or lower version NOW\");\n+    // check whether upgrading from v0.9 to v0.12\n+    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n+      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n+          + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n+    MLogWriter.upgradeMLog();\n \n-    // check whether upgrading from v0.10 to v0.11\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n-      checkUnClosedTsFileV2();\n-      upgradePropertiesFile();\n-      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-          + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n-\n-      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_OLD_LOG);\n-\n-      if (oldMLogFile.delete()) {\n-        throw new IOException(\"Deleting old mlog \" + oldMLogFile + \"failed.\");\n-      }\n-    }\n     checkProperties();\n   }\n \n   /**\n+<<<<<<< HEAD\n    * upgrade 0.10 properties to 0.11 properties\n    */\n   @SuppressWarnings(\"unused\")\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex d00a287f5a..9db3407287 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -198,7 +198,6 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n-<<<<<<< HEAD\n    * upgrade 0.10 properties to 0.11 properties\n    */\n   @SuppressWarnings(\"unused\")\n", "next_change": {"commit": "c76cb3eb323ec320cc7b257caa530bc85e17be82", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 9db3407287..0fe2bf1f60 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,20 +185,29 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.12\n+    // check whether upgrading from <=v0.10 to v0.12\n     if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n       properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n       logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n           + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n+\n+    // check whether upgrading from v0.11 to v0.12\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.info(\"Upgrading IoTDB from v0.11 to v0.12, checking files...\");\n+      checkUnClosedTsFileV2();\n+      upgradePropertiesFile();\n+      logger.info(\"Upgrade to IoTDB v0.12 successfully!\");\n+    }\n+\n     MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n \n   /**\n-   * upgrade 0.10 properties to 0.11 properties\n+   * upgrade 0.11 properties to 0.12 properties\n    */\n   @SuppressWarnings(\"unused\")\n   private void upgradePropertiesFile()\n", "next_change": null}]}}]}}]}}]}}]}}, {"oid": "c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "url": "https://github.com/apache/iotdb/commit/c11cab15da3cd5bd74b8ef7119d4cb6c38c06d77", "message": "fix some sonar warn", "committedDate": "2020-12-07T07:07:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAzMjM4Mw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r538032383", "body": "from <=0.10 to 0.12", "bodyText": "from <=0.10 to 0.12", "bodyHTML": "<p dir=\"auto\">from &lt;=0.10 to 0.12</p>", "author": "qiaojialin", "createdAt": "2020-12-08T04:48:30Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -184,27 +185,24 @@ public void checkConfig() throws IOException {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.11\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.11!\"\n-          + \" Please upgrade to v0.10 first\");\n+    // check whether upgrading from v0.9 to v0.12", "originalCommit": "3cd0707d05163af2f0b0a725b88ec65a75617262", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61c6f6d47b087075554ed4f3636d4990a6da4395", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 97e32f555b..9d7efd1c86 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,24 +185,33 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.12\n+    // check whether upgrading from <=v0.10 to v0.12\n     if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n       properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n       logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n           + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n+\n+    // check whether upgrading from v0.11 to v0.12\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n+      logger.info(\"Upgrading IoTDB from v0.11 to v0.12, checking files...\");\n+      checkUnClosedTsFileV2();\n+      upgradePropertiesFile();\n+      logger.info(\"Upgrade to IoTDB v0.12 successfully!\");\n+    }\n+\n     MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n \n   /**\n-   * upgrade 0.10 properties to 0.11 properties\n+   * upgrade 0.11 properties to 0.12 properties\n    */\n   @SuppressWarnings(\"unused\")\n   private void upgradePropertiesFile()\n-    throws IOException {\n+      throws IOException {\n     // create an empty tmpPropertiesFile\n     if (tmpPropertiesFile.createNewFile()) {\n       logger.info(\"Create system.properties.tmp {}.\", tmpPropertiesFile);\n", "next_change": {"commit": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 9d7efd1c86..c1274ac49f 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,29 +185,45 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from <=v0.10 to v0.12\n-    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n-      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n-          + \" Please upgrade to v0.11 first\");\n+    // check whether upgrading\n+    if (!properties.containsKey(IOTDB_VERSION_STRING)\n+        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")\n+        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.11 or lower version NOW\");\n       System.exit(-1);\n     }\n \n-    // check whether upgrading from v0.11 to v0.12\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n-      logger.info(\"Upgrading IoTDB from v0.11 to v0.12, checking files...\");\n+    // check whether upgrading from v0.10 to v0.11\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n       checkUnClosedTsFileV2();\n       upgradePropertiesFile();\n-      logger.info(\"Upgrade to IoTDB v0.12 successfully!\");\n-    }\n+      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n+\n+      // upgrade mlog finished, delete old mlog file\n+      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+          + MetadataConstant.METADATA_LOG);\n+      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n+          + \".tmp\");\n+\n+      if (!mlogFile.delete()) {\n+        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n+      }\n+      // rename tmpLogFile to mlog\n+      FileUtils.moveFile(tmpMLogFile, mlogFile);\n \n-    MLogWriter.upgradeMLog();\n+      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n+          + MetadataConstant.METADATA_OLD_LOG);\n \n+      if (oldMLogFile.delete()) {\n+        throw new IOException(\"Deleting old mlog \" + oldMLogFile + \"failed.\");\n+      }\n+    }\n     checkProperties();\n   }\n \n   /**\n-   * upgrade 0.11 properties to 0.12 properties\n+   * upgrade 0.10 properties to 0.11 properties\n    */\n   @SuppressWarnings(\"unused\")\n   private void upgradePropertiesFile()\n", "next_change": {"commit": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex c1274ac49f..d00a287f5a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,44 +185,20 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading\n-    if (!properties.containsKey(IOTDB_VERSION_STRING)\n-        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")\n-        || properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.11\")) {\n-      logger.error(\"DO NOT UPGRADE IoTDB from v0.11 or lower version NOW\");\n+    // check whether upgrading from v0.9 to v0.12\n+    if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n+      properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.error(\"DO NOT UPGRADE IoTDB from v0.9 or lower version to v0.12!\"\n+          + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n+    MLogWriter.upgradeMLog();\n \n-    // check whether upgrading from v0.10 to v0.11\n-    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n-      logger.info(\"Upgrading IoTDB from v0.10 to v0.11, checking files...\");\n-      checkUnClosedTsFileV2();\n-      upgradePropertiesFile();\n-      logger.info(\"Upgrade to IoTDB v0.11 successfully!\");\n-\n-      // upgrade mlog finished, delete old mlog file\n-      File mlogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_LOG);\n-      File tmpMLogFile = SystemFileFactory.INSTANCE.getFile(mlogFile.getAbsolutePath()\n-          + \".tmp\");\n-\n-      if (!mlogFile.delete()) {\n-        throw new IOException(\"Deleting \" + mlogFile + \"failed.\");\n-      }\n-      // rename tmpLogFile to mlog\n-      FileUtils.moveFile(tmpMLogFile, mlogFile);\n-\n-      File oldMLogFile = SystemFileFactory.INSTANCE.getFile(SCHEMA_DIR + File.separator\n-          + MetadataConstant.METADATA_OLD_LOG);\n-\n-      if (oldMLogFile.delete()) {\n-        throw new IOException(\"Deleting old mlog \" + oldMLogFile + \"failed.\");\n-      }\n-    }\n     checkProperties();\n   }\n \n   /**\n+<<<<<<< HEAD\n    * upgrade 0.10 properties to 0.11 properties\n    */\n   @SuppressWarnings(\"unused\")\n", "next_change": {"commit": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex d00a287f5a..9db3407287 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -198,7 +198,6 @@ public class IoTDBConfigCheck {\n   }\n \n   /**\n-<<<<<<< HEAD\n    * upgrade 0.10 properties to 0.11 properties\n    */\n   @SuppressWarnings(\"unused\")\n", "next_change": {"commit": "c76cb3eb323ec320cc7b257caa530bc85e17be82", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\nindex 9db3407287..0fe2bf1f60 100644\n--- a/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n+++ b/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java\n", "chunk": "@@ -185,20 +185,29 @@ public class IoTDBConfigCheck {\n             inputStream, TSFileConfig.STRING_CHARSET)) {\n       properties.load(inputStreamReader);\n     }\n-    // check whether upgrading from v0.9 to v0.12\n+    // check whether upgrading from <=v0.10 to v0.12\n     if (!properties.containsKey(IOTDB_VERSION_STRING) ||\n       properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n       logger.error(\"DO NOT UPGRADE IoTDB from v0.10 or lower version to v0.12!\"\n           + \" Please upgrade to v0.11 first\");\n       System.exit(-1);\n     }\n+\n+    // check whether upgrading from v0.11 to v0.12\n+    if (properties.getProperty(IOTDB_VERSION_STRING).startsWith(\"0.10\")) {\n+      logger.info(\"Upgrading IoTDB from v0.11 to v0.12, checking files...\");\n+      checkUnClosedTsFileV2();\n+      upgradePropertiesFile();\n+      logger.info(\"Upgrade to IoTDB v0.12 successfully!\");\n+    }\n+\n     MLogWriter.upgradeMLog();\n \n     checkProperties();\n   }\n \n   /**\n-   * upgrade 0.10 properties to 0.11 properties\n+   * upgrade 0.11 properties to 0.12 properties\n    */\n   @SuppressWarnings(\"unused\")\n   private void upgradePropertiesFile()\n", "next_change": null}]}}]}}]}}]}}]}}, {"oid": "61c6f6d47b087075554ed4f3636d4990a6da4395", "url": "https://github.com/apache/iotdb/commit/61c6f6d47b087075554ed4f3636d4990a6da4395", "message": "catch exception", "committedDate": "2020-12-11T01:48:42Z", "type": "forcePushed"}, {"oid": "cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "url": "https://github.com/apache/iotdb/commit/cf986b9d2faa74699e7c3b75cad35b86ef5f705e", "message": "[IOTDB-868] fix comma bug for mlog", "committedDate": "2020-12-14T01:42:47Z", "type": "commit"}, {"oid": "7799fbede947fca9a49d61ce1be81cf359701bf7", "url": "https://github.com/apache/iotdb/commit/7799fbede947fca9a49d61ce1be81cf359701bf7", "message": "fix upgrade mlog bug", "committedDate": "2020-12-14T01:42:47Z", "type": "commit"}, {"oid": "6b7bedc50ce23dac41fedfd29b143e11285794af", "url": "https://github.com/apache/iotdb/commit/6b7bedc50ce23dac41fedfd29b143e11285794af", "message": "add mlog parser", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "68e460eeaea122e42f73efa2b6d15016ed3b3624", "url": "https://github.com/apache/iotdb/commit/68e460eeaea122e42f73efa2b6d15016ed3b3624", "message": "fix sonar warning", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "55ebf5b2b1d169250eeba5a250f6c257549c37f1", "url": "https://github.com/apache/iotdb/commit/55ebf5b2b1d169250eeba5a250f6c257549c37f1", "message": "remove some code smell warn", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "f03a6c296b2e70c83d91c306f67dee49a1826a5f", "url": "https://github.com/apache/iotdb/commit/f03a6c296b2e70c83d91c306f67dee49a1826a5f", "message": "fix some snoar warn", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "d71acfea25b58daa9ae506a738ed5ebff4d006ca", "url": "https://github.com/apache/iotdb/commit/d71acfea25b58daa9ae506a738ed5ebff4d006ca", "message": "fix some bug", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "95516e01ca4ba2e1134b4202b86c53ffbfe196ea", "url": "https://github.com/apache/iotdb/commit/95516e01ca4ba2e1134b4202b86c53ffbfe196ea", "message": "remove some unused import", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "bc0aea4a6ee1f92a2b379da57acb77ad20a447a1", "url": "https://github.com/apache/iotdb/commit/bc0aea4a6ee1f92a2b379da57acb77ad20a447a1", "message": "fix some sonar warn", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "92930ca36dbeb586f2be035f297eef6e4041162b", "url": "https://github.com/apache/iotdb/commit/92930ca36dbeb586f2be035f297eef6e4041162b", "message": "replace system.out with logger", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "68564cfa6b7de09a689fc1e884fdc6e62fc787d3", "url": "https://github.com/apache/iotdb/commit/68564cfa6b7de09a689fc1e884fdc6e62fc787d3", "message": "add some suppresswarning", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "546d870f06f004873bf639aca53c53c0ff69d4ae", "url": "https://github.com/apache/iotdb/commit/546d870f06f004873bf639aca53c53c0ff69d4ae", "message": "remove unused pom", "committedDate": "2020-12-14T01:42:48Z", "type": "commit"}, {"oid": "c76cb3eb323ec320cc7b257caa530bc85e17be82", "url": "https://github.com/apache/iotdb/commit/c76cb3eb323ec320cc7b257caa530bc85e17be82", "message": "add upgrade system.properties", "committedDate": "2020-12-14T01:42:49Z", "type": "commit"}, {"oid": "31fa1e063c9e41a81ed4f0977707279e80866710", "url": "https://github.com/apache/iotdb/commit/31fa1e063c9e41a81ed4f0977707279e80866710", "message": "fixed 0.11", "committedDate": "2020-12-14T01:42:49Z", "type": "commit"}, {"oid": "103f13a13536f0385c67bb3a4d94116ed4e9bd19", "url": "https://github.com/apache/iotdb/commit/103f13a13536f0385c67bb3a4d94116ed4e9bd19", "message": "catch exception", "committedDate": "2020-12-14T01:42:49Z", "type": "commit"}, {"oid": "a415549bef189fec0b8239387b99721b0c8749ce", "url": "https://github.com/apache/iotdb/commit/a415549bef189fec0b8239387b99721b0c8749ce", "message": "catch closeInterruptException", "committedDate": "2020-12-14T01:42:49Z", "type": "commit"}, {"oid": "a415549bef189fec0b8239387b99721b0c8749ce", "url": "https://github.com/apache/iotdb/commit/a415549bef189fec0b8239387b99721b0c8749ce", "message": "catch closeInterruptException", "committedDate": "2020-12-14T01:42:49Z", "type": "forcePushed"}, {"oid": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "url": "https://github.com/apache/iotdb/commit/67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "message": "fix code smell", "committedDate": "2020-12-14T01:52:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyNTEyNw==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542125127", "body": "make this consistent with iotdb-engine.properties?", "bodyText": "make this consistent with iotdb-engine.properties?", "bodyHTML": "<p dir=\"auto\">make this consistent with iotdb-engine.properties?</p>", "author": "qiaojialin", "createdAt": "2020-12-14T05:40:55Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -204,12 +204,18 @@\n \n   /**\n    * Size of log buffer in each log node(in byte). If WAL is enabled and the size of a insert plan\n-   * is smaller than this parameter, then the insert plan will be rejected by WAL.\n+   * is larger than this parameter, then the insert plan will be rejected by WAL.\n    */\n   private int walBufferSize = 16 * 1024 * 1024;\n \n   private int estimatedSeriesSize = 300;\n \n+  /**\n+   * Size of log buffer for every MetaData operation. If the size of a MetaData operation plan\n+   * is larger than this parameter, then the MetaData operation plan will be rejected by MManager.\n+   */\n+  private int mlogBufferSize = 1024 * 1024;", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1Mjg4MQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542152881", "bodyText": "There is not a thread to do the periodic Channel.force(true) for MLogWriter, is this meet our expectation?\n\nNot\uff0cjust when we use thread pool to write, and we call shutdown to interrupt the thread, see this\nhttps://stackoverflow.com/questions/1161297/why-are-we-getting-closedbyinterruptexception-from-filechannel-map-in-java-1-6", "author": "mychaow", "createdAt": "2020-12-14T07:00:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyNTEyNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyNjI5Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542126296", "body": "this is always true, said by idea..", "bodyText": "this is always true, said by idea..", "bodyHTML": "<p dir=\"auto\">this is always true, said by idea..</p>", "author": "qiaojialin", "createdAt": "2020-12-14T05:44:30Z", "path": "server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java", "diffHunk": "@@ -18,36 +18,59 @@\n  */\n package org.apache.iotdb.db.writelog.io;\n \n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n import java.nio.channels.FileChannel;\n import java.util.zip.CRC32;\n-import org.apache.iotdb.db.conf.IoTDBConfig;\n-import org.apache.iotdb.db.conf.IoTDBDescriptor;\n-import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n \n /**\n- * LogWriter writes the binarized logs into a file using FileChannel together with check sums of\n+ * LogWriter writes the binary logs into a file using FileChannel together with check sums of\n  * each log calculated using CRC32.\n  */\n public class LogWriter implements ILogWriter {\n+  private static final Logger logger = LoggerFactory.getLogger(LogWriter.class);\n \n   private File logFile;\n   private FileOutputStream fileOutputStream;\n   private FileChannel channel;\n-  private CRC32 checkSummer = new CRC32();\n-  private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-  private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n-  private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private final CRC32 checkSummer = new CRC32();\n+  private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n+  private final ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private final long forcePeriodInMs;\n \n-  public LogWriter(String logFilePath) {\n+  /**\n+   * @param logFilePath\n+   * @param forcePeriodInMs\n+   * @throws FileNotFoundException\n+   */\n+  @TestOnly\n+  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    this.forcePeriodInMs = forcePeriodInMs;\n+\n+    if (channel == null) {", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1MzU3Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542153576", "bodyText": "yes, but I think add a check is not redundancy", "author": "mychaow", "createdAt": "2020-12-14T07:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyNjI5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex 1d21dfff7a..f91caddeb4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -57,20 +57,16 @@ public class LogWriter implements ILogWriter {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n     this.logFile = logFile;\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   @Override\n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex f91caddeb4..16ae42720a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -45,25 +45,25 @@ public class LogWriter implements ILogWriter {\n   private final CRC32 checkSummer = new CRC32();\n   private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n   private final ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n-  private final long forcePeriodInMs;\n+  private final boolean forceEachWrite;\n \n   /**\n    * @param logFilePath\n-   * @param forcePeriodInMs\n+   * @param forceEachWrite\n    * @throws FileNotFoundException\n    */\n   @TestOnly\n-  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n+  public LogWriter(String logFilePath, boolean forceEachWrite) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n-    this.forcePeriodInMs = forcePeriodInMs;\n+    this.forceEachWrite = forceEachWrite;\n \n     fileOutputStream = new FileOutputStream(logFile, true);\n     channel = fileOutputStream.getChannel();\n   }\n \n-  public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n+  public LogWriter(File logFile, boolean forceEachWrite) throws FileNotFoundException {\n     this.logFile = logFile;\n-    this.forcePeriodInMs = forcePeriodInMs;\n+    this.forceEachWrite = forceEachWrite;\n \n     fileOutputStream = new FileOutputStream(logFile, true);\n     channel = fileOutputStream.getChannel();\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyNjM0NQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542126345", "body": "this is always true, said by idea..", "bodyText": "this is always true, said by idea..", "bodyHTML": "<p dir=\"auto\">this is always true, said by idea..</p>", "author": "qiaojialin", "createdAt": "2020-12-14T05:44:37Z", "path": "server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java", "diffHunk": "@@ -18,36 +18,59 @@\n  */\n package org.apache.iotdb.db.writelog.io;\n \n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n import java.nio.channels.FileChannel;\n import java.util.zip.CRC32;\n-import org.apache.iotdb.db.conf.IoTDBConfig;\n-import org.apache.iotdb.db.conf.IoTDBDescriptor;\n-import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n \n /**\n- * LogWriter writes the binarized logs into a file using FileChannel together with check sums of\n+ * LogWriter writes the binary logs into a file using FileChannel together with check sums of\n  * each log calculated using CRC32.\n  */\n public class LogWriter implements ILogWriter {\n+  private static final Logger logger = LoggerFactory.getLogger(LogWriter.class);\n \n   private File logFile;\n   private FileOutputStream fileOutputStream;\n   private FileChannel channel;\n-  private CRC32 checkSummer = new CRC32();\n-  private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-  private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n-  private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private final CRC32 checkSummer = new CRC32();\n+  private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n+  private final ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private final long forcePeriodInMs;\n \n-  public LogWriter(String logFilePath) {\n+  /**\n+   * @param logFilePath\n+   * @param forcePeriodInMs\n+   * @throws FileNotFoundException\n+   */\n+  @TestOnly\n+  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    this.forcePeriodInMs = forcePeriodInMs;\n+\n+    if (channel == null) {\n+      fileOutputStream = new FileOutputStream(logFile, true);\n+      channel = fileOutputStream.getChannel();\n+    }\n   }\n \n-  public LogWriter(File logFile) {\n+  public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n     this.logFile = logFile;\n+    this.forcePeriodInMs = forcePeriodInMs;\n+\n+    if (channel == null) {", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex 1d21dfff7a..f91caddeb4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -57,20 +57,16 @@ public class LogWriter implements ILogWriter {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n     this.logFile = logFile;\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   @Override\n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex f91caddeb4..16ae42720a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -45,25 +45,25 @@ public class LogWriter implements ILogWriter {\n   private final CRC32 checkSummer = new CRC32();\n   private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n   private final ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n-  private final long forcePeriodInMs;\n+  private final boolean forceEachWrite;\n \n   /**\n    * @param logFilePath\n-   * @param forcePeriodInMs\n+   * @param forceEachWrite\n    * @throws FileNotFoundException\n    */\n   @TestOnly\n-  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n+  public LogWriter(String logFilePath, boolean forceEachWrite) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n-    this.forcePeriodInMs = forcePeriodInMs;\n+    this.forceEachWrite = forceEachWrite;\n \n     fileOutputStream = new FileOutputStream(logFile, true);\n     channel = fileOutputStream.getChannel();\n   }\n \n-  public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n+  public LogWriter(File logFile, boolean forceEachWrite) throws FileNotFoundException {\n     this.logFile = logFile;\n-    this.forcePeriodInMs = forcePeriodInMs;\n+    this.forceEachWrite = forceEachWrite;\n \n     fileOutputStream = new FileOutputStream(logFile, true);\n     channel = fileOutputStream.getChannel();\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyNzI5OQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542127299", "body": "The function of this field is the same with a boolean", "bodyText": "The function of this field is the same with a boolean", "bodyHTML": "<p dir=\"auto\">The function of this field is the same with a boolean</p>", "author": "qiaojialin", "createdAt": "2020-12-14T05:47:37Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private static final String DELETE_FAILED_FORMAT = \"Deleting %s failed with exception %s\";\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  // we write log to channel every time, so we need not to call channel.force every time\n+  private static final long DUMMY_FLUSH_TIME = 100;", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ab52b4e895..7d1522fef9 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -65,7 +65,7 @@ public class MLogWriter implements AutoCloseable {\n   private LogWriter logWriter;\n   private int logNum;\n   private static final String DELETE_FAILED_FORMAT = \"Deleting %s failed with exception %s\";\n-  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+  private final ByteBuffer mlogBuffer = ByteBuffer.allocate(\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n   // we write log to channel every time, so we need not to call channel.force every time\n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 7d1522fef9..9fea13282d 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -68,8 +68,6 @@ public class MLogWriter implements AutoCloseable {\n   private final ByteBuffer mlogBuffer = ByteBuffer.allocate(\n     IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n \n-  // we write log to channel every time, so we need not to call channel.force every time\n-  private static final long DUMMY_FLUSH_TIME = 100;\n   private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n \n   public MLogWriter(String schemaDir, String logFileName) throws IOException {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyOTUyNA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542129524", "body": "The actual usage of  'forcePeriodInMs' parameter is a boolean 'forceAtEachWrite'", "bodyText": "The actual usage of  'forcePeriodInMs' parameter is a boolean 'forceAtEachWrite'", "bodyHTML": "<p dir=\"auto\">The actual usage of  'forcePeriodInMs' parameter is a boolean 'forceAtEachWrite'</p>", "author": "qiaojialin", "createdAt": "2020-12-14T05:54:36Z", "path": "server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java", "diffHunk": "@@ -18,36 +18,59 @@\n  */\n package org.apache.iotdb.db.writelog.io;\n \n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n import java.nio.channels.FileChannel;\n import java.util.zip.CRC32;\n-import org.apache.iotdb.db.conf.IoTDBConfig;\n-import org.apache.iotdb.db.conf.IoTDBDescriptor;\n-import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n \n /**\n- * LogWriter writes the binarized logs into a file using FileChannel together with check sums of\n+ * LogWriter writes the binary logs into a file using FileChannel together with check sums of\n  * each log calculated using CRC32.\n  */\n public class LogWriter implements ILogWriter {\n+  private static final Logger logger = LoggerFactory.getLogger(LogWriter.class);\n \n   private File logFile;\n   private FileOutputStream fileOutputStream;\n   private FileChannel channel;\n-  private CRC32 checkSummer = new CRC32();\n-  private IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-  private ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n-  private ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private final CRC32 checkSummer = new CRC32();\n+  private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n+  private final ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n+  private final long forcePeriodInMs;\n \n-  public LogWriter(String logFilePath) {\n+  /**\n+   * @param logFilePath\n+   * @param forcePeriodInMs\n+   * @throws FileNotFoundException\n+   */\n+  @TestOnly\n+  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    this.forcePeriodInMs = forcePeriodInMs;\n+\n+    if (channel == null) {\n+      fileOutputStream = new FileOutputStream(logFile, true);\n+      channel = fileOutputStream.getChannel();\n+    }\n   }\n \n-  public LogWriter(File logFile) {\n+  public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2OTU0MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542169540", "bodyText": "Not that, wal use this to optimize the performance after hundreds  of milliseconds.", "author": "mychaow", "createdAt": "2020-12-14T07:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyOTUyNA=="}], "type": "inlineReview", "revised_code": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex 1d21dfff7a..f91caddeb4 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -57,20 +57,16 @@ public class LogWriter implements ILogWriter {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n     this.logFile = logFile;\n     this.forcePeriodInMs = forcePeriodInMs;\n \n-    if (channel == null) {\n-      fileOutputStream = new FileOutputStream(logFile, true);\n-      channel = fileOutputStream.getChannel();\n-    }\n+    fileOutputStream = new FileOutputStream(logFile, true);\n+    channel = fileOutputStream.getChannel();\n   }\n \n   @Override\n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\nindex f91caddeb4..16ae42720a 100644\n--- a/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/writelog/io/LogWriter.java\n", "chunk": "@@ -45,25 +45,25 @@ public class LogWriter implements ILogWriter {\n   private final CRC32 checkSummer = new CRC32();\n   private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n   private final ByteBuffer checkSumBuffer = ByteBuffer.allocate(8);\n-  private final long forcePeriodInMs;\n+  private final boolean forceEachWrite;\n \n   /**\n    * @param logFilePath\n-   * @param forcePeriodInMs\n+   * @param forceEachWrite\n    * @throws FileNotFoundException\n    */\n   @TestOnly\n-  public LogWriter(String logFilePath, long forcePeriodInMs) throws FileNotFoundException {\n+  public LogWriter(String logFilePath, boolean forceEachWrite) throws FileNotFoundException {\n     logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n-    this.forcePeriodInMs = forcePeriodInMs;\n+    this.forceEachWrite = forceEachWrite;\n \n     fileOutputStream = new FileOutputStream(logFile, true);\n     channel = fileOutputStream.getChannel();\n   }\n \n-  public LogWriter(File logFile, long forcePeriodInMs) throws FileNotFoundException {\n+  public LogWriter(File logFile, boolean forceEachWrite) throws FileNotFoundException {\n     this.logFile = logFile;\n-    this.forcePeriodInMs = forcePeriodInMs;\n+    this.forceEachWrite = forceEachWrite;\n \n     fileOutputStream = new FileOutputStream(logFile, true);\n     channel = fileOutputStream.getChannel();\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzNDY4Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542134686", "body": "The forcePeriodInMs is differenet between clear() and constructor.", "bodyText": "The forcePeriodInMs is differenet between clear() and constructor.", "bodyHTML": "<p dir=\"auto\">The forcePeriodInMs is differenet between clear() and constructor.</p>", "author": "qiaojialin", "createdAt": "2020-12-14T06:10:19Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private static final String DELETE_FAILED_FORMAT = \"Deleting %s failed with exception %s\";\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  // we write log to channel every time, so we need not to call channel.force every time\n+  private static final long DUMMY_FLUSH_TIME = 100;\n+  private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    try {\n+      plan.serialize(mlogBuffer);\n+      sync();\n+      logNum ++;\n+    } catch (BufferOverflowException e) {\n+      logger.warn(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+    }\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan createTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(createTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n+                                     String newFileName, boolean isSnapshot) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+      schemaDir + File.separator + oldFileName);\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()\n+      + \".tmp\");\n+\n+    if (oldLogFile.exists() || tmpOldLogFile.exists()) {\n+\n+      if (tmpOldLogFile.exists() && !oldLogFile.exists()) {\n+        FileUtils.moveFile(tmpOldLogFile, oldLogFile);\n+      }\n+\n+      try (MLogWriter mLogWriter = new MLogWriter(schemaDir, newFileName + \".tmp\");\n+           MLogTxtReader mLogTxtReader = new MLogTxtReader(schemaDir, oldFileName)) {\n+        // upgrade from old character log file to new binary mlog\n+        while (mLogTxtReader.hasNext()) {\n+          String cmd = mLogTxtReader.next();\n+          try {\n+            mLogWriter.operation(cmd, isSnapshot);\n+          } catch (MetadataException e) {\n+            logger.error(\"failed to upgrade cmd {}.\", cmd, e);\n+          }\n+        }\n+      }\n+    } else if (!logFile.exists() && !tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp do not exist, nothing to do\n+    } else if (!logFile.exists() && tmpLogFile.exists()) {\n+      // if old .bin doesn't exist but .bin.tmp exists, rename tmp file to .bin\n+      FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+    } else if (tmpLogFile.exists()) {\n+      // if both .bin and .bin.tmp exist, delete .bin.tmp\n+      try {\n+        Files.delete(Paths.get(tmpLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(String.format(DELETE_FAILED_FORMAT, tmpLogFile, e.getMessage()));\n+      }\n+    }\n+\n+    // do some clean job\n+    // remove old .txt and .txt.tmp\n+    if (oldLogFile.exists()) {\n+      try {\n+        Files.delete(Paths.get(oldLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(String.format(DELETE_FAILED_FORMAT, oldLogFile, e.getMessage()));\n+      }\n+    }\n+\n+    if (tmpOldLogFile.exists()) {\n+      try {\n+        Files.delete(Paths.get(tmpOldLogFile.toURI()));\n+      } catch (IOException e) {\n+        throw new IOException(String.format(DELETE_FAILED_FORMAT, tmpOldLogFile, e.getMessage()));\n+      }\n+    }\n+\n+    // rename .bin.tmp to .bin\n+    FSFactoryProducer.getFSFactory().moveFile(tmpLogFile, logFile);\n+  }\n+\n+  public static void upgradeMLog() throws IOException {\n+    String schemaDir = IoTDBDescriptor.getInstance().getConfig().getSchemaDir();\n+    upgradeTxtToBin(schemaDir, MetadataConstant.METADATA_TXT_LOG, MetadataConstant.METADATA_LOG, false);\n+    upgradeTxtToBin(schemaDir, MetadataConstant.MTREE_TXT_SNAPSHOT, MetadataConstant.MTREE_SNAPSHOT, true);\n+  }\n+\n+  public void clear() throws IOException {\n+    sync();\n+    logWriter.close();\n+    mlogBuffer.clear();\n+    if (logFile != null && logFile.exists()) {\n+      Files.delete(logFile.toPath());\n+    }\n+    logNum = 0;\n+    logWriter = new LogWriter(logFile, 0L);", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3MDg4MQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542170881", "bodyText": "yes,  it's a mistake.", "author": "mychaow", "createdAt": "2020-12-14T07:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzNDY4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex ab52b4e895..7d1522fef9 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -305,7 +305,7 @@ public class MLogWriter implements AutoCloseable {\n       Files.delete(logFile.toPath());\n     }\n     logNum = 0;\n-    logWriter = new LogWriter(logFile, 0L);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n   }\n \n   public int getLogNum() {\n", "next_change": {"commit": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "changed_code": [{"header": "diff --git a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\nindex 7d1522fef9..9fea13282d 100644\n--- a/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n+++ b/server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java\n", "chunk": "@@ -305,7 +303,7 @@ public class MLogWriter implements AutoCloseable {\n       Files.delete(logFile.toPath());\n     }\n     logNum = 0;\n-    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+    logWriter = new LogWriter(logFile, false);\n   }\n \n   public int getLogNum() {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzODM2Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542138366", "body": "what is this file for?  I do not see the generation of this file..", "bodyText": "what is this file for?  I do not see the generation of this file..", "bodyHTML": "<p dir=\"auto\">what is this file for?  I do not see the generation of this file..</p>", "author": "qiaojialin", "createdAt": "2020-12-14T06:21:28Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/logfile/MLogWriter.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.logfile;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.MetadataConstant;\n+import org.apache.iotdb.db.metadata.MetadataOperationType;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.metadata.mnode.StorageGroupMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeAliasPlan;\n+import org.apache.iotdb.db.qp.physical.sys.ChangeTagOffsetPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n+import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MLogWriter implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MLogWriter.class);\n+  private File logFile;\n+  private LogWriter logWriter;\n+  private int logNum;\n+  private static final String DELETE_FAILED_FORMAT = \"Deleting %s failed with exception %s\";\n+  private ByteBuffer mlogBuffer = ByteBuffer.allocate(\n+    IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+\n+  // we write log to channel every time, so we need not to call channel.force every time\n+  private static final long DUMMY_FLUSH_TIME = 100;\n+  private static final String LOG_TOO_LARGE_INFO = \"Log cannot fit into buffer, please increase mlog_buffer_size\";\n+\n+  public MLogWriter(String schemaDir, String logFileName) throws IOException {\n+    File metadataDir = SystemFileFactory.INSTANCE.getFile(schemaDir);\n+    if (!metadataDir.exists()) {\n+      if (metadataDir.mkdirs()) {\n+        logger.info(\"create schema folder {}.\", metadataDir);\n+      } else {\n+        logger.warn(\"create schema folder {} failed.\", metadataDir);\n+      }\n+    }\n+\n+    logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + logFileName);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  public MLogWriter(String logFilePath) throws IOException {\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    logWriter = new LogWriter(logFile, DUMMY_FLUSH_TIME);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    logWriter.close();\n+  }\n+\n+  private void sync() {\n+    try {\n+      logWriter.write(mlogBuffer);\n+    } catch (IOException e) {\n+      logger.error(\"MLog {} sync failed, change system mode to read-only\", logFile.getAbsoluteFile(), e);\n+      IoTDBDescriptor.getInstance().getConfig().setReadOnly(true);\n+    }\n+    mlogBuffer.clear();\n+  }\n+\n+  private void putLog(PhysicalPlan plan) {\n+    try {\n+      plan.serialize(mlogBuffer);\n+      sync();\n+      logNum ++;\n+    } catch (BufferOverflowException e) {\n+      logger.warn(\"MLog {} BufferOverflow !\", plan.getOperatorType(), e);\n+    }\n+  }\n+\n+  public void createTimeseries(CreateTimeSeriesPlan createTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(createTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteTimeseries(DeleteTimeSeriesPlan deleteTimeSeriesPlan) throws IOException {\n+    try {\n+      putLog(deleteTimeSeriesPlan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      SetStorageGroupPlan plan = new SetStorageGroupPlan(storageGroup);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void deleteStorageGroup(PartialPath storageGroup) throws IOException {\n+    try {\n+      DeleteStorageGroupPlan plan = new DeleteStorageGroupPlan(Collections.singletonList(storageGroup));\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void setTTL(PartialPath storageGroup, long ttl) throws IOException {\n+    try {\n+      SetTTLPlan plan = new SetTTLPlan(storageGroup, ttl);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeOffset(PartialPath path, long offset) throws IOException {\n+    try {\n+      ChangeTagOffsetPlan plan = new ChangeTagOffsetPlan(path, offset);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void changeAlias(PartialPath path, String alias) throws IOException {\n+    try {\n+      ChangeAliasPlan plan = new ChangeAliasPlan(path, alias);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMNode(MNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MNodePlan plan = new MNodePlan(node.getName(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeMeasurementMNode(MeasurementMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      MeasurementMNodePlan plan = new MeasurementMNodePlan(node.getName(), node.getAlias(),\n+        node.getOffset(), childSize, node.getSchema());\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  public void serializeStorageGroupMNode(StorageGroupMNode node) throws IOException {\n+    try {\n+      int childSize = 0;\n+      if (node.getChildren() != null) {\n+        childSize = node.getChildren().size();\n+      }\n+      StorageGroupMNodePlan plan = new StorageGroupMNodePlan(node.getName(), node.getDataTTL(), childSize);\n+      putLog(plan);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+        LOG_TOO_LARGE_INFO, e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  public static void upgradeTxtToBin(String schemaDir, String oldFileName,\n+                                     String newFileName, boolean isSnapshot) throws IOException {\n+    File logFile = SystemFileFactory.INSTANCE.getFile(schemaDir + File.separator + newFileName);\n+    File tmpLogFile = SystemFileFactory.INSTANCE.getFile(logFile.getAbsolutePath() + \".tmp\");\n+    File oldLogFile = SystemFileFactory.INSTANCE.getFile(\n+      schemaDir + File.separator + oldFileName);\n+    File tmpOldLogFile = SystemFileFactory.INSTANCE.getFile(oldLogFile.getAbsolutePath()", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3MTg3Ng==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542171876", "bodyText": "when we upgrade, maybe we will find the old temp mlog file, so we need to delete it or rename it to the old mlog.txt", "author": "mychaow", "createdAt": "2020-12-14T07:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzODM2Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE0MTk4NQ==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542141985", "body": "This could be removed, the operator is only generated in SQL parser.", "bodyText": "This could be removed, the operator is only generated in SQL parser.", "bodyHTML": "<p dir=\"auto\">This could be removed, the operator is only generated in SQL parser.</p>", "author": "qiaojialin", "createdAt": "2020-12-14T06:31:45Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java", "diffHunk": "@@ -77,7 +77,8 @@ public String toString() {\n     TTL, DELETE_STORAGE_GROUP, LOAD_CONFIGURATION, SHOW, LOAD_FILES, REMOVE_FILE, MOVE_FILE, LAST, GROUP_BY_FILL,\n     ALTER_TIMESERIES, FLUSH, MERGE, FULL_MERGE, CLEAR_CACHE,\n     SHOW_MERGE_STATUS, CREATE_SCHEMA_SNAPSHOT, TRACING, DELETE_PARTITION,\n-    CREATE_MULTI_TIMESERIES\n-    , CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n+    CREATE_MULTI_TIMESERIES, CREATE_INDEX, DROP_INDEX, QUERY_INDEX,\n+    CHANGE_TAG_OFFSET, CHANGE_ALIAS, MNODE,\n+    MEASUREMENT_MNODE, STORAGE_GROUP_MNODE;", "originalCommit": "67b5e08d8b9a9753f6867ad93a07726007a0cf7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3MzE2MA==", "url": "https://github.com/apache/iotdb/pull/1721#discussion_r542173160", "bodyText": "I use them to unify the wal and mlog, for deserializing the log.", "author": "mychaow", "createdAt": "2020-12-14T07:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE0MTk4NQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "url": "https://github.com/apache/iotdb/commit/06b08e0db0f13ed04bb26cc80e4aa6b87b113d88", "message": "fix clear bug", "committedDate": "2020-12-14T07:51:59Z", "type": "commit"}, {"oid": "13d32ddd336ef4e9b0948f301ca46df9347bdd11", "url": "https://github.com/apache/iotdb/commit/13d32ddd336ef4e9b0948f301ca46df9347bdd11", "message": "unify the conf", "committedDate": "2020-12-14T09:29:24Z", "type": "commit"}, {"oid": "4c71885c26b9fe995efe5660cb24beb8981bd8d5", "url": "https://github.com/apache/iotdb/commit/4c71885c26b9fe995efe5660cb24beb8981bd8d5", "message": "change long to boolean", "committedDate": "2020-12-14T09:52:03Z", "type": "commit"}]}