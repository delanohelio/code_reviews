{"pr_number": 1204, "pr_title": "[IOTDB-622] add count records for all databases", "pr_author": "mychaow", "pr_createdAt": "2020-05-13T04:27:28Z", "pr_url": "https://github.com/apache/iotdb/pull/1204", "timeline": [{"oid": "48489133289c86a40699c26c9f8739dfd2a96809", "url": "https://github.com/apache/iotdb/commit/48489133289c86a40699c26c9f8739dfd2a96809", "message": "[IOTDB-622] add count records for all databases", "committedDate": "2020-05-13T06:16:17Z", "type": "forcePushed"}, {"oid": "82a02fd138719781c3a14ccebbcd895fe073c037", "url": "https://github.com/apache/iotdb/commit/82a02fd138719781c3a14ccebbcd895fe073c037", "message": "[IOTDB-622] add count records for all databases", "committedDate": "2020-05-13T11:07:15Z", "type": "forcePushed"}, {"oid": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6", "url": "https://github.com/apache/iotdb/commit/c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6", "message": "[IOTDB-622] add count records for all databases", "committedDate": "2020-05-16T03:34:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NDc5MA==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426994790", "body": "`dataSet` is not used as a global variable. Actually, `level` and `isByTime` could also be converted to local variables", "bodyText": "dataSet is not used as a global variable. Actually, level and isByTime could also be converted to local variables", "bodyHTML": "<p dir=\"auto\"><code>dataSet</code> is not used as a global variable. Actually, <code>level</code> and <code>isByTime</code> could also be converted to local variables</p>", "author": "samperson1997", "createdAt": "2020-05-19T02:31:19Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;", "originalCommit": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NjQwMA==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426996400", "body": "I think you'd better use `logger.error` instead of assertion, what do you think?", "bodyText": "I think you'd better use logger.error instead of assertion, what do you think?", "bodyHTML": "<p dir=\"auto\">I think you'd better use <code>logger.error</code> instead of assertion, what do you think?</p>", "author": "samperson1997", "createdAt": "2020-05-19T02:36:56Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;\n+  private GroupByPlan groupByPlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByPlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.level = plan.getLevel();\n+    this.isByTime = plan.isByTime();\n+    this.dataSet = dataSet;\n+    this.paths = plan.getPaths();\n+    this.dataTypes = plan.getDataTypes();\n+    this.groupByPlan = plan;\n+    this.context = context;\n+\n+    logger.debug(\"paths \" + this.paths);\n+\n+    RowRecord record = new RowRecord(0);\n+    if (!isByTime) {\n+      initGroupBy();\n+      record = getRecordWithoutTimeInterval();\n+    } else {\n+      // get all records from GroupByDataSet, then we merge them to one record\n+      logger.debug(\"only group by level, paths:\" + groupByPlan.getPaths());\n+      while (dataSet != null && dataSet.hasNextWithoutConstraint()) {\n+        RowRecord curRecord = dataSet.nextWithoutConstraint();\n+        record = mergeRecords(curRecord, record);\n+      }\n+    }\n+\n+    // prepare final records\n+    // group by level\n+    // path -> count\n+    Map<String, Long> finalPaths = new TreeMap<String, Long>();\n+\n+    for (int j = 0; j < this.paths.size(); j++) {\n+      String[] tmpPath = this.paths.get(j).getFullPath().split(\"\\\\.\");\n+\n+      String key;\n+      if (tmpPath.length <= level) {\n+        key = this.paths.get(j).getFullPath();\n+      } else {\n+        StringBuilder path = new StringBuilder();\n+        for (int k = 0; k <= level; k++) {\n+          if (k == 0) {\n+            path.append(tmpPath[k]);\n+          } else {\n+            path.append(\".\" + tmpPath[k]);\n+          }\n+        }\n+        key = path.toString();\n+      }\n+      logger.debug(\"records \" + record.getFields().toString());\n+      finalPaths.put(key,\n+        record.getFields().get(j).getLongV()\n+          + finalPaths.getOrDefault(key, 0L));\n+    }\n+\n+    this.paths = Arrays.asList(new Path(COLUMN_COLUMN), new Path(COLUMN_COUNT));\n+    this.dataTypes = Arrays.asList(TSDataType.TEXT, TSDataType.TEXT);\n+\n+    for (Map.Entry<String, Long> entry : finalPaths.entrySet()) {\n+      RowRecord tmpRecord = new RowRecord(0);\n+      Field field = new Field(TSDataType.TEXT);\n+      field.setBinaryV(new Binary(entry.getKey()));\n+      logger.debug(\"rowRecord \" + entry.getKey());\n+      Field field1 = new Field(TSDataType.TEXT);\n+      field1.setBinaryV(new Binary(Long.toString(entry.getValue())));\n+      tmpRecord.addField(field);\n+      tmpRecord.addField(field1);\n+      records.add(tmpRecord);\n+      logger.info(tmpRecord.toString());\n+    }\n+  }\n+\n+  @Override\n+  protected boolean hasNextWithoutConstraint() throws IOException {\n+    return index < records.size();\n+  }\n+\n+  @Override\n+  protected RowRecord nextWithoutConstraint() {\n+    return records.get(index++);\n+  }\n+\n+  private void initGroupBy()\n+    throws QueryProcessException, StorageEngineException {\n+    // get all aggregation results, then we package them to one record\n+    for (int i = 0; i < paths.size(); i++) {\n+      Path path = paths.get(i);\n+      if (!pathExecutors.containsKey(path)) {\n+        //init GroupByExecutor\n+        pathExecutors.put(path,\n+          getGroupByExecutor(path, groupByPlan.getAllMeasurementsInDevice(path.getDevice()), dataTypes.get(i), this.context, null, null));\n+        resultIndexes.put(path, new ArrayList<>());\n+      } else {\n+        throw new QueryProcessException(\"duplicated path found, path:\" + path);\n+      }\n+      resultIndexes.get(path).add(i);\n+      AggregateResult aggrResult = AggregateResultFactory\n+        .getAggrResultByName(groupByPlan.getDeduplicatedAggregations().get(i), dataTypes.get(i));\n+      pathExecutors.get(path).addAggregateResult(aggrResult);\n+    }\n+  }\n+\n+  private GroupByExecutor getGroupByExecutor(Path path, Set<String> allSensors, TSDataType dataType,\n+                                             QueryContext context, Filter timeFilter, TsFileFilter fileFilter)\n+    throws StorageEngineException, QueryProcessException {\n+    return new LocalGroupByExecutor(path, allSensors, dataType, context, timeFilter, fileFilter);\n+  }\n+\n+  private RowRecord getRecordWithoutTimeInterval()\n+    throws IOException {\n+    RowRecord record = new RowRecord(0);\n+    AggregateResult[] fields = new AggregateResult[paths.size()];\n+\n+    try {\n+      for (Map.Entry<Path, GroupByExecutor> pathToExecutorEntry : pathExecutors.entrySet()) {\n+        GroupByExecutor executor = pathToExecutorEntry.getValue();\n+        List<AggregateResult> aggregations = executor.calcResult(Long.MIN_VALUE, Long.MAX_VALUE);\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          int resultIndex = resultIndexes.get(pathToExecutorEntry.getKey()).get(i);\n+          fields[resultIndex] = aggregations.get(i);\n+        }\n+      }\n+    } catch (QueryProcessException e) {\n+      logger.error(\"GroupByWithoutValueFilterDataSet execute has error\", e);\n+      throw new IOException(e.getMessage(), e);\n+    }\n+\n+    for (AggregateResult res : fields) {\n+      if (res == null) {\n+        record.addField(null);\n+        continue;\n+      }\n+      record.addField(res.getResult(), res.getResultDataType());\n+    }\n+    return record;\n+  }\n+\n+  private RowRecord mergeRecords(RowRecord newRecord, RowRecord oldRecord) {\n+    if (oldRecord.getFields().isEmpty()) {\n+      oldRecord.setFields(newRecord.getFields());\n+    } else {\n+      assert oldRecord.getFields().size() == newRecord.getFields().size();", "originalCommit": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzQwMQ==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r427053401", "bodyText": "ok, assert will help me found bug fastly. I can change it to error.", "author": "mychaow", "createdAt": "2020-05-19T06:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NjQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1NjEyOA==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r427056128", "bodyText": "And, I will maintain the User Guide docluments after merge.", "author": "mychaow", "createdAt": "2020-05-19T06:22:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NjQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk4ODU0NQ==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426988545", "body": "The GroupByPlan is actually GroupByTimePlan, so no need to add a byTime field, we can rename the class.", "bodyText": "The GroupByPlan is actually GroupByTimePlan, so no need to add a byTime field, we can rename the class.", "bodyHTML": "<p dir=\"auto\">The GroupByPlan is actually GroupByTimePlan, so no need to add a byTime field, we can rename the class.</p>", "author": "qiaojialin", "createdAt": "2020-05-19T02:07:15Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/GroupByPlan.java", "diffHunk": "@@ -33,6 +33,8 @@\n   // if it is left close and right open interval\n   private boolean leftCRightO = true;\n \n+  private boolean byTime = false;", "originalCommit": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MTI3Mg==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426991272", "body": "Actually, we support path like this:  root.sg.d.\"s.1\"\r\ns.1 is measurement name", "bodyText": "Actually, we support path like this:  root.sg.d.\"s.1\"\ns.1 is measurement name", "bodyHTML": "<p dir=\"auto\">Actually, we support path like this:  root.sg.d.\"s.1\"<br>\ns.1 is measurement name</p>", "author": "qiaojialin", "createdAt": "2020-05-19T02:17:59Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;\n+  private GroupByPlan groupByPlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByPlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.level = plan.getLevel();\n+    this.isByTime = plan.isByTime();\n+    this.dataSet = dataSet;\n+    this.paths = plan.getPaths();\n+    this.dataTypes = plan.getDataTypes();\n+    this.groupByPlan = plan;\n+    this.context = context;\n+\n+    logger.debug(\"paths \" + this.paths);\n+\n+    RowRecord record = new RowRecord(0);\n+    if (!isByTime) {\n+      initGroupBy();\n+      record = getRecordWithoutTimeInterval();\n+    } else {\n+      // get all records from GroupByDataSet, then we merge them to one record\n+      logger.debug(\"only group by level, paths:\" + groupByPlan.getPaths());\n+      while (dataSet != null && dataSet.hasNextWithoutConstraint()) {\n+        RowRecord curRecord = dataSet.nextWithoutConstraint();\n+        record = mergeRecords(curRecord, record);\n+      }\n+    }\n+\n+    // prepare final records\n+    // group by level\n+    // path -> count\n+    Map<String, Long> finalPaths = new TreeMap<String, Long>();\n+\n+    for (int j = 0; j < this.paths.size(); j++) {\n+      String[] tmpPath = this.paths.get(j).getFullPath().split(\"\\\\.\");", "originalCommit": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MTQ5OQ==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426991499", "body": "add if (logger.isDebugEnabled())", "bodyText": "add if (logger.isDebugEnabled())", "bodyHTML": "<p dir=\"auto\">add if (logger.isDebugEnabled())</p>", "author": "qiaojialin", "createdAt": "2020-05-19T02:18:50Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;\n+  private GroupByPlan groupByPlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByPlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.level = plan.getLevel();\n+    this.isByTime = plan.isByTime();\n+    this.dataSet = dataSet;\n+    this.paths = plan.getPaths();\n+    this.dataTypes = plan.getDataTypes();\n+    this.groupByPlan = plan;\n+    this.context = context;\n+\n+    logger.debug(\"paths \" + this.paths);\n+\n+    RowRecord record = new RowRecord(0);\n+    if (!isByTime) {\n+      initGroupBy();\n+      record = getRecordWithoutTimeInterval();\n+    } else {\n+      // get all records from GroupByDataSet, then we merge them to one record\n+      logger.debug(\"only group by level, paths:\" + groupByPlan.getPaths());\n+      while (dataSet != null && dataSet.hasNextWithoutConstraint()) {\n+        RowRecord curRecord = dataSet.nextWithoutConstraint();\n+        record = mergeRecords(curRecord, record);\n+      }\n+    }\n+\n+    // prepare final records\n+    // group by level\n+    // path -> count\n+    Map<String, Long> finalPaths = new TreeMap<String, Long>();\n+\n+    for (int j = 0; j < this.paths.size(); j++) {\n+      String[] tmpPath = this.paths.get(j).getFullPath().split(\"\\\\.\");\n+\n+      String key;\n+      if (tmpPath.length <= level) {\n+        key = this.paths.get(j).getFullPath();\n+      } else {\n+        StringBuilder path = new StringBuilder();\n+        for (int k = 0; k <= level; k++) {\n+          if (k == 0) {\n+            path.append(tmpPath[k]);\n+          } else {\n+            path.append(\".\" + tmpPath[k]);\n+          }\n+        }\n+        key = path.toString();\n+      }\n+      logger.debug(\"records \" + record.getFields().toString());", "originalCommit": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MTg4OA==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426991888", "body": "please add javadoc and an example", "bodyText": "please add javadoc and an example", "bodyHTML": "<p dir=\"auto\">please add javadoc and an example</p>", "author": "qiaojialin", "createdAt": "2020-05-19T02:20:22Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;\n+  private GroupByPlan groupByPlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByPlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.level = plan.getLevel();\n+    this.isByTime = plan.isByTime();\n+    this.dataSet = dataSet;\n+    this.paths = plan.getPaths();\n+    this.dataTypes = plan.getDataTypes();\n+    this.groupByPlan = plan;\n+    this.context = context;\n+\n+    logger.debug(\"paths \" + this.paths);\n+\n+    RowRecord record = new RowRecord(0);\n+    if (!isByTime) {\n+      initGroupBy();\n+      record = getRecordWithoutTimeInterval();\n+    } else {\n+      // get all records from GroupByDataSet, then we merge them to one record\n+      logger.debug(\"only group by level, paths:\" + groupByPlan.getPaths());\n+      while (dataSet != null && dataSet.hasNextWithoutConstraint()) {\n+        RowRecord curRecord = dataSet.nextWithoutConstraint();\n+        record = mergeRecords(curRecord, record);\n+      }\n+    }\n+\n+    // prepare final records\n+    // group by level\n+    // path -> count\n+    Map<String, Long> finalPaths = new TreeMap<String, Long>();\n+\n+    for (int j = 0; j < this.paths.size(); j++) {\n+      String[] tmpPath = this.paths.get(j).getFullPath().split(\"\\\\.\");\n+\n+      String key;\n+      if (tmpPath.length <= level) {\n+        key = this.paths.get(j).getFullPath();\n+      } else {\n+        StringBuilder path = new StringBuilder();\n+        for (int k = 0; k <= level; k++) {\n+          if (k == 0) {\n+            path.append(tmpPath[k]);\n+          } else {\n+            path.append(\".\" + tmpPath[k]);\n+          }\n+        }\n+        key = path.toString();\n+      }\n+      logger.debug(\"records \" + record.getFields().toString());\n+      finalPaths.put(key,\n+        record.getFields().get(j).getLongV()\n+          + finalPaths.getOrDefault(key, 0L));\n+    }\n+\n+    this.paths = Arrays.asList(new Path(COLUMN_COLUMN), new Path(COLUMN_COUNT));\n+    this.dataTypes = Arrays.asList(TSDataType.TEXT, TSDataType.TEXT);\n+\n+    for (Map.Entry<String, Long> entry : finalPaths.entrySet()) {\n+      RowRecord tmpRecord = new RowRecord(0);\n+      Field field = new Field(TSDataType.TEXT);\n+      field.setBinaryV(new Binary(entry.getKey()));\n+      logger.debug(\"rowRecord \" + entry.getKey());\n+      Field field1 = new Field(TSDataType.TEXT);\n+      field1.setBinaryV(new Binary(Long.toString(entry.getValue())));\n+      tmpRecord.addField(field);\n+      tmpRecord.addField(field1);\n+      records.add(tmpRecord);\n+      logger.info(tmpRecord.toString());\n+    }\n+  }\n+\n+  @Override\n+  protected boolean hasNextWithoutConstraint() throws IOException {\n+    return index < records.size();\n+  }\n+\n+  @Override\n+  protected RowRecord nextWithoutConstraint() {\n+    return records.get(index++);\n+  }\n+\n+  private void initGroupBy()\n+    throws QueryProcessException, StorageEngineException {\n+    // get all aggregation results, then we package them to one record\n+    for (int i = 0; i < paths.size(); i++) {\n+      Path path = paths.get(i);\n+      if (!pathExecutors.containsKey(path)) {\n+        //init GroupByExecutor\n+        pathExecutors.put(path,\n+          getGroupByExecutor(path, groupByPlan.getAllMeasurementsInDevice(path.getDevice()), dataTypes.get(i), this.context, null, null));\n+        resultIndexes.put(path, new ArrayList<>());\n+      } else {\n+        throw new QueryProcessException(\"duplicated path found, path:\" + path);\n+      }\n+      resultIndexes.get(path).add(i);\n+      AggregateResult aggrResult = AggregateResultFactory\n+        .getAggrResultByName(groupByPlan.getDeduplicatedAggregations().get(i), dataTypes.get(i));\n+      pathExecutors.get(path).addAggregateResult(aggrResult);\n+    }\n+  }\n+\n+  private GroupByExecutor getGroupByExecutor(Path path, Set<String> allSensors, TSDataType dataType,\n+                                             QueryContext context, Filter timeFilter, TsFileFilter fileFilter)\n+    throws StorageEngineException, QueryProcessException {\n+    return new LocalGroupByExecutor(path, allSensors, dataType, context, timeFilter, fileFilter);\n+  }\n+\n+  private RowRecord getRecordWithoutTimeInterval()\n+    throws IOException {\n+    RowRecord record = new RowRecord(0);\n+    AggregateResult[] fields = new AggregateResult[paths.size()];\n+\n+    try {\n+      for (Map.Entry<Path, GroupByExecutor> pathToExecutorEntry : pathExecutors.entrySet()) {\n+        GroupByExecutor executor = pathToExecutorEntry.getValue();\n+        List<AggregateResult> aggregations = executor.calcResult(Long.MIN_VALUE, Long.MAX_VALUE);\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          int resultIndex = resultIndexes.get(pathToExecutorEntry.getKey()).get(i);\n+          fields[resultIndex] = aggregations.get(i);\n+        }\n+      }\n+    } catch (QueryProcessException e) {\n+      logger.error(\"GroupByWithoutValueFilterDataSet execute has error\", e);\n+      throw new IOException(e.getMessage(), e);\n+    }\n+\n+    for (AggregateResult res : fields) {\n+      if (res == null) {\n+        record.addField(null);\n+        continue;\n+      }\n+      record.addField(res.getResult(), res.getResultDataType());\n+    }\n+    return record;\n+  }\n+\n+  private RowRecord mergeRecords(RowRecord newRecord, RowRecord oldRecord) {", "originalCommit": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5Mjg0Nw==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426992847", "body": "initGroupByLevel? ", "bodyText": "initGroupByLevel?", "bodyHTML": "<p dir=\"auto\">initGroupByLevel?</p>", "author": "qiaojialin", "createdAt": "2020-05-19T02:23:58Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;\n+  private GroupByPlan groupByPlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByPlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.level = plan.getLevel();\n+    this.isByTime = plan.isByTime();\n+    this.dataSet = dataSet;\n+    this.paths = plan.getPaths();\n+    this.dataTypes = plan.getDataTypes();\n+    this.groupByPlan = plan;\n+    this.context = context;\n+\n+    logger.debug(\"paths \" + this.paths);\n+\n+    RowRecord record = new RowRecord(0);\n+    if (!isByTime) {\n+      initGroupBy();\n+      record = getRecordWithoutTimeInterval();\n+    } else {\n+      // get all records from GroupByDataSet, then we merge them to one record\n+      logger.debug(\"only group by level, paths:\" + groupByPlan.getPaths());\n+      while (dataSet != null && dataSet.hasNextWithoutConstraint()) {\n+        RowRecord curRecord = dataSet.nextWithoutConstraint();\n+        record = mergeRecords(curRecord, record);\n+      }\n+    }\n+\n+    // prepare final records\n+    // group by level\n+    // path -> count\n+    Map<String, Long> finalPaths = new TreeMap<String, Long>();\n+\n+    for (int j = 0; j < this.paths.size(); j++) {\n+      String[] tmpPath = this.paths.get(j).getFullPath().split(\"\\\\.\");\n+\n+      String key;\n+      if (tmpPath.length <= level) {\n+        key = this.paths.get(j).getFullPath();\n+      } else {\n+        StringBuilder path = new StringBuilder();\n+        for (int k = 0; k <= level; k++) {\n+          if (k == 0) {\n+            path.append(tmpPath[k]);\n+          } else {\n+            path.append(\".\" + tmpPath[k]);\n+          }\n+        }\n+        key = path.toString();\n+      }\n+      logger.debug(\"records \" + record.getFields().toString());\n+      finalPaths.put(key,\n+        record.getFields().get(j).getLongV()\n+          + finalPaths.getOrDefault(key, 0L));\n+    }\n+\n+    this.paths = Arrays.asList(new Path(COLUMN_COLUMN), new Path(COLUMN_COUNT));\n+    this.dataTypes = Arrays.asList(TSDataType.TEXT, TSDataType.TEXT);\n+\n+    for (Map.Entry<String, Long> entry : finalPaths.entrySet()) {\n+      RowRecord tmpRecord = new RowRecord(0);\n+      Field field = new Field(TSDataType.TEXT);\n+      field.setBinaryV(new Binary(entry.getKey()));\n+      logger.debug(\"rowRecord \" + entry.getKey());\n+      Field field1 = new Field(TSDataType.TEXT);\n+      field1.setBinaryV(new Binary(Long.toString(entry.getValue())));\n+      tmpRecord.addField(field);\n+      tmpRecord.addField(field1);\n+      records.add(tmpRecord);\n+      logger.info(tmpRecord.toString());\n+    }\n+  }\n+\n+  @Override\n+  protected boolean hasNextWithoutConstraint() throws IOException {\n+    return index < records.size();\n+  }\n+\n+  @Override\n+  protected RowRecord nextWithoutConstraint() {\n+    return records.get(index++);\n+  }\n+\n+  private void initGroupBy()", "originalCommit": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MzAzMA==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426993030", "body": "check if debug enabled", "bodyText": "check if debug enabled", "bodyHTML": "<p dir=\"auto\">check if debug enabled</p>", "author": "qiaojialin", "createdAt": "2020-05-19T02:24:52Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/QueryRouter.java", "diffHunk": "@@ -113,34 +114,45 @@ protected AggregationExecutor getAggregationExecutor(AggregationPlan aggregation\n \n   @Override\n   public QueryDataSet groupBy(GroupByPlan groupByPlan, QueryContext context)\n-      throws QueryFilterOptimizationException, StorageEngineException, QueryProcessException {\n-    long unit = groupByPlan.getInterval();\n-    long slidingStep = groupByPlan.getSlidingStep();\n-    long startTime = groupByPlan.getStartTime();\n-    long endTime = groupByPlan.getEndTime();\n+    throws QueryFilterOptimizationException, StorageEngineException, QueryProcessException, IOException {\n+\n+    logger.debug(\"paths:\" + groupByPlan.getPaths() + \" level:\" + groupByPlan.getLevel() + \" byTime:\" + groupByPlan.isByTime());", "originalCommit": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxNQ==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r427058615", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-05-19T06:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MzAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5Njg0Mg==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426996842", "body": "since there is more than one group by, it's better to use full name.   GroupByLevel and GroupByTime", "bodyText": "since there is more than one group by, it's better to use full name.   GroupByLevel and GroupByTime", "bodyHTML": "<p dir=\"auto\">since there is more than one group by, it's better to use full name.   GroupByLevel and GroupByTime</p>", "author": "qiaojialin", "createdAt": "2020-05-19T02:38:38Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java", "diffHunk": "@@ -664,6 +668,7 @@ public void enterGroupByFillClause(SqlBaseParser.GroupByFillClauseContext ctx) {\n     super.enterGroupByFillClause(ctx);\n     queryOp.setGroupBy(true);\n     queryOp.setFill(true);\n+    queryOp.setGroupByTime(true);", "originalCommit": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTIwOQ==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426999209", "body": "Replace this with an AggregationPlan", "bodyText": "Replace this with an AggregationPlan", "bodyHTML": "<p dir=\"auto\">Replace this with an AggregationPlan</p>", "author": "qiaojialin", "createdAt": "2020-05-19T02:47:56Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;\n+  private GroupByPlan groupByPlan;", "originalCommit": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dfc719dee08337eaffcb4a90ea950255ff25cc9f", "url": "https://github.com/apache/iotdb/commit/dfc719dee08337eaffcb4a90ea950255ff25cc9f", "message": "[IOTDB-622] add count records for all databases", "committedDate": "2020-05-20T07:56:23Z", "type": "forcePushed"}, {"oid": "b0103b4c72df9543419ae31f49929d54d623bfa3", "url": "https://github.com/apache/iotdb/commit/b0103b4c72df9543419ae31f49929d54d623bfa3", "message": "[IOTDB-622] add count records for all databases", "committedDate": "2020-05-20T12:55:30Z", "type": "forcePushed"}, {"oid": "9a1aafb4d7bb71538b9a874c833ef2a78fd734a7", "url": "https://github.com/apache/iotdb/commit/9a1aafb4d7bb71538b9a874c833ef2a78fd734a7", "message": "[IOTDB-622] add count records for all databases", "committedDate": "2020-05-21T02:56:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQwNDk2MQ==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r428404961", "body": "```suggestion\r\npublic class GroupByTimeFillPlan extends GroupByTimePlan {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class GroupByFillTimePlan extends GroupByTimePlan {\n          \n          \n            \n            public class GroupByTimeFillPlan extends GroupByTimePlan {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"pl-k\">public</span> <span class=\"pl-k\">class</span> <span class=\"pl-en x x-first x-last\">GroupByFillTimePlan</span> <span class=\"pl-k\">extends</span> <span class=\"pl-e\">GroupByTimePlan</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-k\">public</span> <span class=\"pl-k\">class</span> <span class=\"pl-en x x-first x-last\">GroupByTimeFillPlan</span> <span class=\"pl-k\">extends</span> <span class=\"pl-e\">GroupByTimePlan</span> {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "qiaojialin", "createdAt": "2020-05-21T02:02:52Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/GroupByFillTimePlan.java", "diffHunk": "@@ -24,11 +24,11 @@\n \n import java.util.Map;\n \n-public class GroupByFillPlan extends GroupByPlan {\n+public class GroupByFillTimePlan extends GroupByTimePlan {", "originalCommit": "b0103b4c72df9543419ae31f49929d54d623bfa3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQwNTc0Ng==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r428405746", "body": "```suggestion\r\n  private boolean isGroupByLevel = false;\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private boolean isGroupBy = false;\n          \n          \n            \n              private boolean isGroupByLevel = false;", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">  <span class=\"pl-k\">private</span> <span class=\"pl-k\">boolean</span> <span class=\"x x-first x-last\">isGroupBy</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">false</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  <span class=\"pl-k\">private</span> <span class=\"pl-k\">boolean</span> <span class=\"x x-first x-last\">isGroupByLevel</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">false</span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "qiaojialin", "createdAt": "2020-05-21T02:06:08Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/crud/QueryOperator.java", "diffHunk": "@@ -42,6 +42,9 @@\n   private Map<TSDataType, IFill> fillTypes;\n   private boolean isFill = false;\n \n+  private boolean isGroupBy = false;", "originalCommit": "b0103b4c72df9543419ae31f49929d54d623bfa3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyNjQxNA==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r429526414", "body": "The GroupByTimePlan extends AggregationPlan extends RawDataQueryPlan extends QueryPlan. \r\n\r\nThe paths in QueryPlan are not duplicated, here we should use plan.getDeduplicatedPath()\r\n\r\nBesides, please add some test for duplicated queries like\r\n\r\nselect count(s1), count(s1) from root.turbine1.d1 group by([1,10),2ms), level=2", "bodyText": "The GroupByTimePlan extends AggregationPlan extends RawDataQueryPlan extends QueryPlan.\nThe paths in QueryPlan are not duplicated, here we should use plan.getDeduplicatedPath()\nBesides, please add some test for duplicated queries like\nselect count(s1), count(s1) from root.turbine1.d1 group by([1,10),2ms), level=2", "bodyHTML": "<p dir=\"auto\">The GroupByTimePlan extends AggregationPlan extends RawDataQueryPlan extends QueryPlan.</p>\n<p dir=\"auto\">The paths in QueryPlan are not duplicated, here we should use plan.getDeduplicatedPath()</p>\n<p dir=\"auto\">Besides, please add some test for duplicated queries like</p>\n<p dir=\"auto\">select count(s1), count(s1) from root.turbine1.d1 group by([1,10),2ms), level=2</p>", "author": "qiaojialin", "createdAt": "2020-05-23T08:19:13Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByTimePlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.db.utils.FilePathUtils;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  protected long queryId;\n+  private GroupByTimePlan groupByTimePlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByTimePlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.paths = plan.getPaths();", "originalCommit": "9a1aafb4d7bb71538b9a874c833ef2a78fd734a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MTE2Mw==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r429541163", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-05-23T12:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyNjQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyODE3Mw==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r429528173", "body": "We need to maintain the time filter user, this implementation can not handle the following sql correctly\r\n\r\nselect count(*) from root where time < 5 group by level=2\r\n\r\n\r\nI suggest extending the AggregationExecutor to do this. It's more intuitive... ", "bodyText": "We need to maintain the time filter user, this implementation can not handle the following sql correctly\nselect count(*) from root where time < 5 group by level=2\nI suggest extending the AggregationExecutor to do this. It's more intuitive...", "bodyHTML": "<p dir=\"auto\">We need to maintain the time filter user, this implementation can not handle the following sql correctly</p>\n<p dir=\"auto\">select count(*) from root where time &lt; 5 group by level=2</p>\n<p dir=\"auto\">I suggest extending the AggregationExecutor to do this. It's more intuitive...</p>", "author": "qiaojialin", "createdAt": "2020-05-23T08:47:52Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByTimePlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.db.utils.FilePathUtils;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  protected long queryId;\n+  private GroupByTimePlan groupByTimePlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByTimePlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.paths = plan.getPaths();\n+    this.dataTypes = plan.getDataTypes();\n+    this.groupByTimePlan = plan;\n+    this.context = context;\n+\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"paths \" + this.paths + \" level:\" + plan.getLevel());\n+    }\n+\n+    Map<Integer, String> pathIndex = new HashMap<>();\n+    Map<String, Long> finalPaths = FilePathUtils.getPathByLevel(plan.getPaths(), plan.getLevel(), pathIndex);\n+\n+    if (!plan.isByTime()) {\n+      // does not has time interval,\n+      // so we could group by time interval [MIN_VALUE, MAX_VALUE] to get the total number\n+      initGroupByLevel();\n+      RowRecord record = mergeRecordByPath(getRecordWithoutTimeInterval(), finalPaths, pathIndex);\n+      if (record != null) {\n+        records.add(record);\n+      }\n+    } else {\n+      // get all records from GroupByDataSet, then we merge every record\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"only group by level, paths:\" + groupByTimePlan.getPaths());\n+      }\n+      while (dataSet != null && dataSet.hasNextWithoutConstraint()) {\n+        RowRecord curRecord = mergeRecordByPath(dataSet.nextWithoutConstraint(), finalPaths, pathIndex);\n+        if (curRecord != null) {\n+          records.add(curRecord);\n+        }\n+      }\n+    }\n+\n+    this.dataTypes = new ArrayList<>();\n+    this.paths = new ArrayList<>();\n+    for (int i = 0; i < finalPaths.size(); i++) {\n+      this.dataTypes.add(TSDataType.INT64);\n+    }\n+  }\n+\n+  @Override\n+  protected boolean hasNextWithoutConstraint() throws IOException {\n+    return index < records.size();\n+  }\n+\n+  @Override\n+  protected RowRecord nextWithoutConstraint() {\n+    return records.get(index++);\n+  }\n+\n+  private void initGroupByLevel()\n+    throws QueryProcessException, StorageEngineException {\n+    // get all aggregation results, then we package them to one record\n+    for (int i = 0; i < paths.size(); i++) {\n+      Path path = paths.get(i);\n+      if (!pathExecutors.containsKey(path)) {\n+        //init GroupByExecutor\n+        pathExecutors.put(path,\n+          getGroupByExecutor(path, groupByTimePlan.getAllMeasurementsInDevice(path.getDevice()), dataTypes.get(i), this.context, null, null));\n+        resultIndexes.put(path, new ArrayList<>());", "originalCommit": "9a1aafb4d7bb71538b9a874c833ef2a78fd734a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "46386cd6a9af2826c6d5d2b8ecbd349269e6ea45", "url": "https://github.com/apache/iotdb/commit/46386cd6a9af2826c6d5d2b8ecbd349269e6ea45", "message": "[IOTDB-622] split group by level to two parts", "committedDate": "2020-05-26T03:45:28Z", "type": "forcePushed"}, {"oid": "a01ec1aa74a337a9c7cfb12fe6fc4391dd58da4f", "url": "https://github.com/apache/iotdb/commit/a01ec1aa74a337a9c7cfb12fe6fc4391dd58da4f", "message": "[IOTDB-622] split group by level to two parts", "committedDate": "2020-06-02T04:24:07Z", "type": "forcePushed"}, {"oid": "03684ce65390625171c2dfaab984c12710ea4827", "url": "https://github.com/apache/iotdb/commit/03684ce65390625171c2dfaab984c12710ea4827", "message": "[IOTDB-622] split group by level to two parts", "committedDate": "2020-06-02T06:16:22Z", "type": "forcePushed"}, {"oid": "fe790833a4927eb8877275b4fd6657eafc0d0290", "url": "https://github.com/apache/iotdb/commit/fe790833a4927eb8877275b4fd6657eafc0d0290", "message": "[IOTDB-622] split group by level to two parts", "committedDate": "2020-06-02T08:18:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMDc5Mg==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r435820792", "body": "Hey, just like @qiaojialin said, you can reuse MetaUtils.getNodesName() method here~", "bodyText": "Hey, just like @qiaojialin said, you can reuse MetaUtils.getNodesName() method here~", "bodyHTML": "<p dir=\"auto\">Hey, just like <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/qiaojialin/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/qiaojialin\">@qiaojialin</a> said, you can reuse MetaUtils.getNodesName() method here~</p>", "author": "Alima777", "createdAt": "2020-06-05T10:02:27Z", "path": "server/src/main/java/org/apache/iotdb/db/utils/FilePathUtils.java", "diffHunk": "@@ -46,4 +54,82 @@ public static String regularizePath(String filePath){\n     return resource.getFile().getAbsolutePath().split(PATH_SPLIT_STRING);\n   }\n \n+  /**\n+   * get paths from group by level, like root.sg1.d2.s0, root.sg1.d1.s1\n+   * level=1, return [root.sg1, 0] and pathIndex turns to be [[0, root.sg1], [1, root.sg1]]\n+   * @param rawPaths\n+   * @param level\n+   * @param pathIndex\n+   * @return\n+   */\n+  public static Map<String, Long> getPathByLevel(List<Path> rawPaths, int level, Map<Integer, String> pathIndex) {\n+    // pathGroupByLevel -> count\n+    Map<String, Long> finalPaths = new TreeMap<>();\n+\n+    int i = 0;\n+    for (Path value : rawPaths) {\n+      String[] tmpPath = value.getFullPath().split(\"\\\\.\");", "originalCommit": "fe790833a4927eb8877275b4fd6657eafc0d0290", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODczNg==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r435828736", "body": "I think this `level` parameter shouldn't be inserted here in Queryplan which is the base class. Maybe groupByTimePlan or AggregationPlan is better.", "bodyText": "I think this level parameter shouldn't be inserted here in Queryplan which is the base class. Maybe groupByTimePlan or AggregationPlan is better.", "bodyHTML": "<p dir=\"auto\">I think this <code>level</code> parameter shouldn't be inserted here in Queryplan which is the base class. Maybe groupByTimePlan or AggregationPlan is better.</p>", "author": "Alima777", "createdAt": "2020-06-05T10:18:52Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/QueryPlan.java", "diffHunk": "@@ -36,6 +36,8 @@\n   private int rowLimit = 0;\n   private int rowOffset = 0;\n \n+  private int level = -1;", "originalCommit": "fe790833a4927eb8877275b4fd6657eafc0d0290", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgzMTM4OA==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r435831388", "body": "```suggestion\r\n        if (plan.getOperatorType() == OperatorType.GROUPBYTIME) {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (plan.getOperatorType() == GROUPBYTIME) {\n          \n          \n            \n                    if (plan.getOperatorType() == OperatorType.GROUPBYTIME) {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">if</span> (plan<span class=\"pl-k\">.</span>getOperatorType() <span class=\"pl-k\">==</span> <span class=\"pl-c1\">GROUPBYTIME</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">if</span> (plan<span class=\"pl-k\">.</span>getOperatorType() <span class=\"pl-k\">==</span> <span class=\"pl-smi x x-first\">OperatorType</span><span class=\"pl-c1\"><span class=\"pl-k x x-last\">.</span>GROUPBYTIME</span>) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "Alima777", "createdAt": "2020-06-05T10:24:28Z", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -549,7 +540,7 @@ private TSExecuteStatementResp internalExecuteQueryStatement(String statement,\n         if (plan.getOperatorType() == OperatorType.FILL) {\n           throw new QueryProcessException(\"Fill doesn't support disable align clause.\");\n         }\n-        if (plan.getOperatorType() == OperatorType.GROUPBY) {\n+        if (plan.getOperatorType() == GROUPBYTIME) {", "originalCommit": "fe790833a4927eb8877275b4fd6657eafc0d0290", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fa298ab3fc549c48a288d4d902746801e57099a1", "url": "https://github.com/apache/iotdb/commit/fa298ab3fc549c48a288d4d902746801e57099a1", "message": "[IOTDB-622] add count records for all databases", "committedDate": "2020-06-05T12:13:24Z", "type": "commit"}, {"oid": "a8b4bcdd344bc7c49851bc0f6335fc96883199c8", "url": "https://github.com/apache/iotdb/commit/a8b4bcdd344bc7c49851bc0f6335fc96883199c8", "message": "[IOTDB-622] split group by level to two parts", "committedDate": "2020-06-05T12:37:04Z", "type": "forcePushed"}, {"oid": "43782cc1224941b8875a8091e8486318e6d1b7fa", "url": "https://github.com/apache/iotdb/commit/43782cc1224941b8875a8091e8486318e6d1b7fa", "message": "[IOTDB-622] split group by level to two parts", "committedDate": "2020-06-06T01:21:30Z", "type": "forcePushed"}, {"oid": "6b530135b6b98d92e482be76dfd51c486ff5f917", "url": "https://github.com/apache/iotdb/commit/6b530135b6b98d92e482be76dfd51c486ff5f917", "message": "[IOTDB-622] split group by level to two parts", "committedDate": "2020-06-06T01:52:24Z", "type": "forcePushed"}, {"oid": "cc37618f912bc52d90e0e9a0a8159f1e62fde199", "url": "https://github.com/apache/iotdb/commit/cc37618f912bc52d90e0e9a0a8159f1e62fde199", "message": "[IOTDB-622] split group by level to two parts", "committedDate": "2020-06-06T02:53:26Z", "type": "forcePushed"}, {"oid": "d9ff8cd7c8250f944cb0ad01b738578822e58028", "url": "https://github.com/apache/iotdb/commit/d9ff8cd7c8250f944cb0ad01b738578822e58028", "message": "[IOTDB-622] split group by level to two parts", "committedDate": "2020-06-06T05:53:19Z", "type": "commit"}, {"oid": "d9ff8cd7c8250f944cb0ad01b738578822e58028", "url": "https://github.com/apache/iotdb/commit/d9ff8cd7c8250f944cb0ad01b738578822e58028", "message": "[IOTDB-622] split group by level to two parts", "committedDate": "2020-06-06T05:53:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0OTI2MQ==", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r436249261", "body": "```suggestion\r\n// To process statement like, select count group by time interval, level = x\r\npublic class GroupByTimeDataSet extends QueryDataSet {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class GroupByTimeDataSet extends QueryDataSet {\n          \n          \n            \n            // To process statement like, select count group by time interval, level = x\n          \n          \n            \n            public class GroupByTimeDataSet extends QueryDataSet {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"42\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"pl-k x x-first\">public</span><span class=\"x\"> </span><span class=\"pl-k x\">class</span><span class=\"x\"> </span><span class=\"pl-en x\">GroupByTimeDataSet</span><span class=\"x\"> </span><span class=\"pl-k x\">extends</span><span class=\"x\"> </span><span class=\"pl-e x\">QueryDataSet</span><span class=\"x x-last\"> {</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"42\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-c\"><span class=\"pl-c x x-first\">//</span><span class=\"x x-last\"> To process statement like, select count group by time interval, level = x</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"43\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-k\">public</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">GroupByTimeDataSet</span> <span class=\"pl-k\">extends</span> <span class=\"pl-e\">QueryDataSet</span> {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "Alima777", "createdAt": "2020-06-06T08:05:03Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByTimeDataSet.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByTimePlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.db.utils.FilePathUtils;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class GroupByTimeDataSet extends QueryDataSet {", "originalCommit": "d9ff8cd7c8250f944cb0ad01b738578822e58028", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}