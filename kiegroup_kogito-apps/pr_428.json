{"pr_number": 428, "pr_title": "KOGITO-3228: add outcome ids to saliency model", "pr_author": "kostola", "pr_createdAt": "2020-09-01T15:25:39Z", "pr_url": "https://github.com/kiegroup/kogito-apps/pull/428", "timeline": [{"oid": "c4de24b95ac188e9ef3d653604c019edb5a8384a", "url": "https://github.com/kiegroup/kogito-apps/commit/c4de24b95ac188e9ef3d653604c019edb5a8384a", "message": "KOGITO-3228: add status details field to explainability result", "committedDate": "2020-09-02T11:16:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMjc2OA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482002768", "body": "What is the reason of this change?\r\n`getPrediction` is plain local method and `localExplainer.explainAsync` already create the `CompletableFuture` internally.\r\nI don't see the reason to add this additional wrapper. Btw you should not use any `*Async` methods without providing the executor in a managed environment", "bodyText": "What is the reason of this change?\ngetPrediction is plain local method and localExplainer.explainAsync already create the CompletableFuture internally.\nI don't see the reason to add this additional wrapper. Btw you should not use any *Async methods without providing the executor in a managed environment", "bodyHTML": "<p dir=\"auto\">What is the reason of this change?<br>\n<code>getPrediction</code> is plain local method and <code>localExplainer.explainAsync</code> already create the <code>CompletableFuture</code> internally.<br>\nI don't see the reason to add this additional wrapper. Btw you should not use any <code>*Async</code> methods without providing the executor in a managed environment</p>", "author": "danielezonca", "createdAt": "2020-09-02T11:38:49Z", "path": "explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java", "diffHunk": "@@ -61,17 +62,17 @@ public ExplanationServiceImpl(\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        Prediction prediction = getPrediction(request.getInputs(), request.getOutputs());\n-        return localExplainer.explainAsync(prediction, predictionProvider)\n+        return CompletableFuture.supplyAsync(() -> getPrediction(request.getInputs(), request.getOutputs()))\n+                .thenCompose(prediction -> localExplainer.explainAsync(prediction, predictionProvider))", "originalCommit": "c4de24b95ac188e9ef3d653604c019edb5a8384a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1NDQ5Mg==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482754492", "bodyText": "This is needed imho. The implementation of LimeExplainer does not wrap everything in a CompletableFuture, but instead does some computation before, that may lead to an exception being thrown (e.g. when the Prediction object it receives has no inputs).\nWith the original implementation, exceptions thrown directly in explainAsync wouldn't be catched by the exceptionally block and then bubble up to the event loop thread, blocking the whole computation (which means no failure message being sent back to the Trusty Service).\nThis way, even if the localExplainer implementation is not perfect, we are sure to catch every exception it may throw in the exceptionally block.", "author": "kostola", "createdAt": "2020-09-03T07:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMjc2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgyMDgwMw==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482820803", "bodyText": "As @danielezonca suggested in a chat discussion we had, I now handled this issue using a try catch block instead of calling CompletableFuture::supplyAsync to avoid overloading the event loop too much.", "author": "kostola", "createdAt": "2020-09-03T09:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMjc2OA=="}], "type": "inlineReview", "revised_code": {"commit": "ef114be0ed09b87b8fe3e93836736f904044bb3b", "changed_code": [{"header": "diff --git a/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java b/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java\nindex e07e06340..0872474b4 100644\n--- a/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java\n+++ b/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java\n", "chunk": "@@ -62,18 +62,19 @@ public class ExplanationServiceImpl implements ExplanationService {\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        return CompletableFuture.supplyAsync(() -> getPrediction(request.getInputs(), request.getOutputs()))\n-                .thenCompose(prediction -> localExplainer.explainAsync(prediction, predictionProvider))\n+        Prediction prediction = getPrediction(request.getInputs(), request.getOutputs());\n+        return localExplainer.explainAsync(prediction, predictionProvider)\n                 .thenApply(input -> createResultDto(input, request.getExecutionId()))\n                 .exceptionally(throwable -> {\n                     LOG.error(\"Exception thrown during explainAsync\", throwable);\n-                    return ExplainabilityResultDto.buildFailed(request.getExecutionId(), \"Failed to calculate values\");\n+                    return new ExplainabilityResultDto(request.getExecutionId(), false, Collections.emptyMap());\n                 });\n     }\n \n     protected static ExplainabilityResultDto createResultDto(Map<String, Saliency> saliencies, String executionId) {\n-        return ExplainabilityResultDto.buildSucceeded(\n+        return new ExplainabilityResultDto(\n                 executionId,\n+                true,\n                 saliencies.entrySet().stream().collect(Collectors.toMap(\n                         Map.Entry::getKey,\n                         e -> new SaliencyDto(e.getValue().getPerFeatureImportance().stream()\n", "next_change": {"commit": "35b20c28fef8328844dc1c01f75db4c5c5349722", "changed_code": [{"header": "diff --git a/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java b/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java\nindex 0872474b4..1aa2e981d 100644\n--- a/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java\n+++ b/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java\n", "chunk": "@@ -67,14 +68,14 @@ public class ExplanationServiceImpl implements ExplanationService {\n                 .thenApply(input -> createResultDto(input, request.getExecutionId()))\n                 .exceptionally(throwable -> {\n                     LOG.error(\"Exception thrown during explainAsync\", throwable);\n-                    return new ExplainabilityResultDto(request.getExecutionId(), false, Collections.emptyMap());\n+                    return new ExplainabilityResultDto(request.getExecutionId(), ExplainabilityStatus.FAILED, Collections.emptyMap());\n                 });\n     }\n \n     protected static ExplainabilityResultDto createResultDto(Map<String, Saliency> saliencies, String executionId) {\n         return new ExplainabilityResultDto(\n                 executionId,\n-                true,\n+                ExplainabilityStatus.SUCCEEDED,\n                 saliencies.entrySet().stream().collect(Collectors.toMap(\n                         Map.Entry::getKey,\n                         e -> new SaliencyDto(e.getValue().getPerFeatureImportance().stream()\n", "next_change": {"commit": "d7a184c1bdcb33d367f48022bd4576266680da81", "changed_code": [{"header": "diff --git a/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java b/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java\nindex 1aa2e981d..e07e06340 100644\n--- a/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java\n+++ b/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java\n", "chunk": "@@ -63,19 +62,18 @@ public class ExplanationServiceImpl implements ExplanationService {\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        Prediction prediction = getPrediction(request.getInputs(), request.getOutputs());\n-        return localExplainer.explainAsync(prediction, predictionProvider)\n+        return CompletableFuture.supplyAsync(() -> getPrediction(request.getInputs(), request.getOutputs()))\n+                .thenCompose(prediction -> localExplainer.explainAsync(prediction, predictionProvider))\n                 .thenApply(input -> createResultDto(input, request.getExecutionId()))\n                 .exceptionally(throwable -> {\n                     LOG.error(\"Exception thrown during explainAsync\", throwable);\n-                    return new ExplainabilityResultDto(request.getExecutionId(), ExplainabilityStatus.FAILED, Collections.emptyMap());\n+                    return ExplainabilityResultDto.buildFailed(request.getExecutionId(), \"Failed to calculate values\");\n                 });\n     }\n \n     protected static ExplainabilityResultDto createResultDto(Map<String, Saliency> saliencies, String executionId) {\n-        return new ExplainabilityResultDto(\n+        return ExplainabilityResultDto.buildSucceeded(\n                 executionId,\n-                ExplainabilityStatus.SUCCEEDED,\n                 saliencies.entrySet().stream().collect(Collectors.toMap(\n                         Map.Entry::getKey,\n                         e -> new SaliencyDto(e.getValue().getPerFeatureImportance().stream()\n", "next_change": {"commit": "6b7e33f13be5d7946926001e9ffd5e53c0168650", "changed_code": [{"header": "diff --git a/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java b/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java\nindex e07e06340..234bce14f 100644\n--- a/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java\n+++ b/explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java\n", "chunk": "@@ -62,16 +63,16 @@ public class ExplanationServiceImpl implements ExplanationService {\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        return CompletableFuture.supplyAsync(() -> getPrediction(request.getInputs(), request.getOutputs()))\n-                .thenCompose(prediction -> localExplainer.explainAsync(prediction, predictionProvider))\n-                .thenApply(input -> createResultDto(input, request.getExecutionId()))\n-                .exceptionally(throwable -> {\n-                    LOG.error(\"Exception thrown during explainAsync\", throwable);\n-                    return ExplainabilityResultDto.buildFailed(request.getExecutionId(), \"Failed to calculate values\");\n-                });\n+        try {\n+            return localExplainer.explainAsync(getPrediction(request.getInputs(), request.getOutputs()), predictionProvider)\n+                    .thenApply(input -> createSucceededResultDto(request.getExecutionId(), input))\n+                    .exceptionally(e -> createFailedResultDto(request.getExecutionId(), e));\n+        } catch (Exception e) {\n+            return CompletableFuture.completedFuture(createFailedResultDto(request.getExecutionId(), e));\n+        }\n     }\n \n-    protected static ExplainabilityResultDto createResultDto(Map<String, Saliency> saliencies, String executionId) {\n+    private static ExplainabilityResultDto createSucceededResultDto(String executionId, Map<String, Saliency> saliencies) {\n         return ExplainabilityResultDto.buildSucceeded(\n                 executionId,\n                 saliencies.entrySet().stream().collect(Collectors.toMap(\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMzczMA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482003730", "body": "Please add an assertion on the value too", "bodyText": "Please add an assertion on the value too", "bodyHTML": "<p dir=\"auto\">Please add an assertion on the value too</p>", "author": "danielezonca", "createdAt": "2020-09-02T11:40:44Z", "path": "explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java", "diffHunk": "@@ -57,27 +58,49 @@ void init() {\n         localExplainerMock = mock(LocalExplainer.class);\n         predictionProviderMock = mock(PredictionProvider.class);\n         explanationService = new ExplanationServiceImpl(localExplainerMock);\n-\n-        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock))).thenReturn(CompletableFuture.completedFuture(SALIENCY_MAP));\n     }\n \n     @Test\n-    void explainAsync() throws InterruptedException, ExecutionException, TimeoutException {\n-        CompletionStage<ExplainabilityResultDto> explainAsync = explanationService.explainAsync(REQUEST, predictionProviderMock);\n+    void testExplainAsyncSucceeded() {\n+        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock)))\n+                .thenReturn(CompletableFuture.completedFuture(SALIENCY_MAP));\n \n-        ExplainabilityResultDto resultDto = explainAsync.toCompletableFuture()\n-                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        ExplainabilityResultDto resultDto = assertDoesNotThrow(() ->\n+                explanationService.explainAsync(REQUEST, predictionProviderMock)\n+                        .toCompletableFuture()\n+                        .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n+        );\n \n         assertNotNull(resultDto);\n         assertEquals(EXECUTION_ID, resultDto.getExecutionId());\n+        assertSame(ExplainabilityStatus.SUCCEEDED, resultDto.getStatus());\n+        assertNull(resultDto.getStatusDetails());\n         assertEquals(SALIENCY_MAP.size(), resultDto.getSaliencies().size());\n         assertTrue(resultDto.getSaliencies().containsKey(\"key\"));\n \n         SaliencyDto saliencyDto = resultDto.getSaliencies().get(\"key\");\n         assertEquals(SALIENCY.getPerFeatureImportance().size(), saliencyDto.getFeatureImportance().size());\n \n         FeatureImportanceDto featureImportanceDto1 = saliencyDto.getFeatureImportance().get(0);\n-        assertEquals(FEATURE_IMPORTANCE_1.getFeature().getName(), featureImportanceDto1.getFeatureId());\n+        assertEquals(FEATURE_IMPORTANCE_1.getFeature().getName(), featureImportanceDto1.getFeatureName());\n         assertEquals(FEATURE_IMPORTANCE_1.getScore(), featureImportanceDto1.getScore(), 0.01);\n     }\n+\n+    @Test\n+    void testExplainAsyncFailed() {\n+        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock)))\n+                .thenThrow(RuntimeException.class);\n+\n+        ExplainabilityResultDto resultDto = assertDoesNotThrow(() ->\n+                explanationService.explainAsync(REQUEST, predictionProviderMock)\n+                        .toCompletableFuture()\n+                        .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n+        );\n+\n+        assertNotNull(resultDto);\n+        assertEquals(EXECUTION_ID, resultDto.getExecutionId());\n+        assertSame(ExplainabilityStatus.FAILED, resultDto.getStatus());\n+        assertNotNull(resultDto.getStatusDetails());", "originalCommit": "c4de24b95ac188e9ef3d653604c019edb5a8384a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgxOTUxMg==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482819512", "bodyText": "Done \ud83d\udc4d", "author": "kostola", "createdAt": "2020-09-03T08:58:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMzczMA=="}], "type": "inlineReview", "revised_code": {"commit": "ef114be0ed09b87b8fe3e93836736f904044bb3b", "changed_code": [{"header": "diff --git a/explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java b/explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java\nindex e95a427f2..2da264735 100644\n--- a/explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java\n+++ b/explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java\n", "chunk": "@@ -85,22 +80,4 @@ class ExplanationServiceImplTest {\n         assertEquals(FEATURE_IMPORTANCE_1.getFeature().getName(), featureImportanceDto1.getFeatureName());\n         assertEquals(FEATURE_IMPORTANCE_1.getScore(), featureImportanceDto1.getScore(), 0.01);\n     }\n-\n-    @Test\n-    void testExplainAsyncFailed() {\n-        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock)))\n-                .thenThrow(RuntimeException.class);\n-\n-        ExplainabilityResultDto resultDto = assertDoesNotThrow(() ->\n-                explanationService.explainAsync(REQUEST, predictionProviderMock)\n-                        .toCompletableFuture()\n-                        .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n-        );\n-\n-        assertNotNull(resultDto);\n-        assertEquals(EXECUTION_ID, resultDto.getExecutionId());\n-        assertSame(ExplainabilityStatus.FAILED, resultDto.getStatus());\n-        assertNotNull(resultDto.getStatusDetails());\n-        assertNull(resultDto.getSaliencies());\n-    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "d7a184c1bdcb33d367f48022bd4576266680da81", "changed_code": [{"header": "diff --git a/explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java b/explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java\nindex 2da264735..e95a427f2 100644\n--- a/explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java\n+++ b/explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java\n", "chunk": "@@ -80,4 +85,22 @@ class ExplanationServiceImplTest {\n         assertEquals(FEATURE_IMPORTANCE_1.getFeature().getName(), featureImportanceDto1.getFeatureName());\n         assertEquals(FEATURE_IMPORTANCE_1.getScore(), featureImportanceDto1.getScore(), 0.01);\n     }\n+\n+    @Test\n+    void testExplainAsyncFailed() {\n+        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock)))\n+                .thenThrow(RuntimeException.class);\n+\n+        ExplainabilityResultDto resultDto = assertDoesNotThrow(() ->\n+                explanationService.explainAsync(REQUEST, predictionProviderMock)\n+                        .toCompletableFuture()\n+                        .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n+        );\n+\n+        assertNotNull(resultDto);\n+        assertEquals(EXECUTION_ID, resultDto.getExecutionId());\n+        assertSame(ExplainabilityStatus.FAILED, resultDto.getStatus());\n+        assertNotNull(resultDto.getStatusDetails());\n+        assertNull(resultDto.getSaliencies());\n+    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "6b7e33f13be5d7946926001e9ffd5e53c0168650", "changed_code": [{"header": "diff --git a/explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java b/explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java\nindex e95a427f2..66999f222 100644\n--- a/explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java\n+++ b/explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java\n", "chunk": "@@ -100,7 +101,7 @@ class ExplanationServiceImplTest {\n         assertNotNull(resultDto);\n         assertEquals(EXECUTION_ID, resultDto.getExecutionId());\n         assertSame(ExplainabilityStatus.FAILED, resultDto.getStatus());\n-        assertNotNull(resultDto.getStatusDetails());\n+        assertEquals(FAILED_STATUS_DETAILS, resultDto.getStatusDetails());\n         assertNull(resultDto.getSaliencies());\n     }\n }\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MDkxMA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482170910", "body": "Wdym?\r\nBtw can you please create a ticket and link it here if you don't want to include these tests in the PR?", "bodyText": "Wdym?\nBtw can you please create a ticket and link it here if you don't want to include these tests in the PR?", "bodyHTML": "<p dir=\"auto\">Wdym?<br>\nBtw can you please create a ticket and link it here if you don't want to include these tests in the PR?</p>", "author": "danielezonca", "createdAt": "2020-09-02T15:39:45Z", "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java", "diffHunk": "@@ -43,16 +47,29 @@\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n+// TODO: improve this test with decision values", "originalCommit": "884822e982dead2623cdf7b4bba86435d7eb58f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg5NDY2Ng==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482894666", "bodyText": "Sorry that was a leftover. I implemented that part now.", "author": "kostola", "createdAt": "2020-09-03T11:05:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MDkxMA=="}], "type": "inlineReview", "revised_code": {"commit": "0ffd007e6042a45220a1b6bd46e6709fe8a5c57c", "changed_code": [{"header": "diff --git a/trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java b/trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java\nindex 6cdb010fb..7127f839a 100644\n--- a/trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java\n+++ b/trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java\n", "chunk": "@@ -47,26 +54,32 @@ import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n-// TODO: improve this test with decision values\n-public class ExplainabilityResultConsumerTest {\n+class ExplainabilityResultConsumerTest {\n \n     private static final String TEST_EXECUTION_ID = \"test\";\n+    private static final String TEST_FEATURE_1_ID = \"f1-id\";\n+    private static final String TEST_FEATURE_1_NAME = \"feature1\";\n+    private static final String TEST_FEATURE_2_ID = \"f2-id\";\n+    private static final String TEST_FEATURE_2_NAME = \"feature2\";\n+    private static final String TEST_OUTCOME_1_ID = \"o1-id\";\n+    private static final String TEST_OUTCOME_1_NAME = \"outcome1\";\n \n-    private static final FeatureImportanceDto TEST_FEATURE_IMPORTANCE_DTO_1 = new FeatureImportanceDto(\"feature1\", 1d);\n-    private static final FeatureImportanceDto TEST_FEATURE_IMPORTANCE_DTO_2 = new FeatureImportanceDto(\"feature2\", 1d);\n-    private static final SaliencyDto TEST_SALIENCY_DTO = new SaliencyDto(asList(TEST_FEATURE_IMPORTANCE_DTO_1, TEST_FEATURE_IMPORTANCE_DTO_2));\n-    private static final ExplainabilityResultDto TEST_RESULT_DTO = ExplainabilityResultDto.buildSucceeded(\"executionId\", singletonMap(\"saliency\", TEST_SALIENCY_DTO));\n     private static final Decision TEST_DECISION = new Decision(\n             TEST_EXECUTION_ID, null, null, true, null, null, null,\n             List.of(\n-                    new DecisionInput(\"F1-ID\", TEST_FEATURE_IMPORTANCE_DTO_1.getFeatureName(), null),\n-                    new DecisionInput(\"F2-ID\", TEST_FEATURE_IMPORTANCE_DTO_2.getFeatureName(), null)\n+                    new DecisionInput(TEST_FEATURE_1_ID, TEST_FEATURE_1_NAME, null),\n+                    new DecisionInput(TEST_FEATURE_2_ID, TEST_FEATURE_2_NAME, null)\n             ),\n             List.of(\n-                    new DecisionOutcome(\"O1-ID\", \"saliency\", null, null, null, null)\n+                    new DecisionOutcome(TEST_OUTCOME_1_ID, TEST_OUTCOME_1_NAME, null, null, null, null)\n             )\n     );\n \n+    private static final FeatureImportanceDto TEST_FEATURE_IMPORTANCE_DTO_1 = new FeatureImportanceDto(TEST_FEATURE_1_NAME, 1d);\n+    private static final FeatureImportanceDto TEST_FEATURE_IMPORTANCE_DTO_2 = new FeatureImportanceDto(TEST_FEATURE_2_NAME, -1d);\n+    private static final SaliencyDto TEST_SALIENCY_DTO = new SaliencyDto(asList(TEST_FEATURE_IMPORTANCE_DTO_1, TEST_FEATURE_IMPORTANCE_DTO_2));\n+    private static final ExplainabilityResultDto TEST_RESULT_DTO = ExplainabilityResultDto.buildSucceeded(TEST_EXECUTION_ID, singletonMap(TEST_OUTCOME_1_NAME, TEST_SALIENCY_DTO));\n+\n     private TrustyService trustyService;\n     private ExplainabilityResultConsumer consumer;\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTU2Ng==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482171566", "body": "Can you please update/re-enable these assertions?", "bodyText": "Can you please update/re-enable these assertions?", "bodyHTML": "<p dir=\"auto\">Can you please update/re-enable these assertions?</p>", "author": "danielezonca", "createdAt": "2020-09-02T15:40:38Z", "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java", "diffHunk": "@@ -75,48 +92,48 @@ void testInvalidPayload() {\n \n     @Test\n     void testExceptionsAreCatched() {\n-        Message<String> message = mockMessage(buildCloudEventJsonString(new ExplainabilityResultDto(\"test\", emptyMap())));\n+        Message<String> message = mockMessage(buildCloudEventJsonString(ExplainabilityResultDto.buildSucceeded(TEST_EXECUTION_ID, emptyMap())));\n \n         doThrow(new RuntimeException(\"Something really bad\")).when(trustyService).storeExplainabilityResult(any(String.class), any(ExplainabilityResult.class));\n         Assertions.assertDoesNotThrow(() -> consumer.handleMessage(message));\n     }\n \n     @Test\n     public void explainabilityResultFrom() {\n-        Assertions.assertNull(ExplainabilityResultConsumer.explainabilityResultFrom(null));\n+        Assertions.assertNull(ExplainabilityResultConsumer.explainabilityResultFrom(null, null));\n \n-        ExplainabilityResult explainabilityResult = ExplainabilityResultConsumer.explainabilityResultFrom(resultDto);\n+        ExplainabilityResult explainabilityResult = ExplainabilityResultConsumer.explainabilityResultFrom(TEST_RESULT_DTO, TEST_DECISION);\n \n         Assertions.assertNotNull(explainabilityResult);\n-        Assertions.assertEquals(resultDto.getExecutionId(), explainabilityResult.getExecutionId());\n-        Assertions.assertEquals(resultDto.getSaliencies().size(), explainabilityResult.getSaliencies().size());\n-        Assertions.assertTrue(resultDto.getSaliencies().containsKey(\"saliency\"));\n-        Assertions.assertEquals(resultDto.getSaliencies().get(\"saliency\").getFeatureImportance().size(),\n-                explainabilityResult.getSaliencies().get(\"saliency\").getFeatureImportance().size());\n+        Assertions.assertEquals(TEST_RESULT_DTO.getExecutionId(), explainabilityResult.getExecutionId());\n+        Assertions.assertEquals(TEST_RESULT_DTO.getSaliencies().size(), explainabilityResult.getSaliencies().size());\n+        Assertions.assertTrue(TEST_RESULT_DTO.getSaliencies().containsKey(\"saliency\"));\n+        // Assertions.assertEquals(TEST_RESULT_DTO.getSaliencies().get(\"saliency\").getFeatureImportance().size(),\n+        // explainabilityResult.getSaliencies().get(\"saliency\").getFeatureImportance().size());", "originalCommit": "884822e982dead2623cdf7b4bba86435d7eb58f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg5NDc3MQ==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482894771", "bodyText": "Done. It needed some refactoring but now it's ok.", "author": "kostola", "createdAt": "2020-09-03T11:05:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTU2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0ffd007e6042a45220a1b6bd46e6709fe8a5c57c", "changed_code": [{"header": "diff --git a/trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java b/trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java\nindex 6cdb010fb..7127f839a 100644\n--- a/trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java\n+++ b/trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java\n", "chunk": "@@ -98,45 +111,84 @@ public class ExplainabilityResultConsumerTest {\n         Assertions.assertDoesNotThrow(() -> consumer.handleMessage(message));\n     }\n \n-    @Test\n-    public void explainabilityResultFrom() {\n-        Assertions.assertNull(ExplainabilityResultConsumer.explainabilityResultFrom(null, null));\n+    private void testExplainabilityResultFromWith(Decision decision, String expectedOutcomeId) {\n+        ExplainabilityResult explainabilityResult = ExplainabilityResultConsumer.explainabilityResultFrom(TEST_RESULT_DTO, decision);\n+        assertNotNull(explainabilityResult);\n+        assertEquals(TEST_RESULT_DTO.getExecutionId(), explainabilityResult.getExecutionId());\n+        assertNotNull(TEST_RESULT_DTO.getSaliencies());\n+        assertEquals(TEST_RESULT_DTO.getSaliencies().size(), explainabilityResult.getSaliencies().size());\n+\n+        Optional<Saliency> optSaliency = explainabilityResult.getSaliencies().stream()\n+                .filter(s -> s.getOutcomeName().equals(TEST_OUTCOME_1_NAME))\n+                .findFirst();\n+\n+        assertFalse(optSaliency.isEmpty());\n+\n+        Saliency saliency = optSaliency.get();\n+        assertEquals(expectedOutcomeId, saliency.getOutcomeId());\n+        assertNotNull(saliency.getFeatureImportance());\n+        assertEquals(TEST_SALIENCY_DTO.getFeatureImportance().size(), saliency.getFeatureImportance().size());\n+\n+        List<FeatureImportance> featureImportances = saliency.getFeatureImportance().stream()\n+                .sorted(ExplainabilityResultConsumerTest::compareFeatureImportance)\n+                .collect(Collectors.toList());\n+\n+        FeatureImportanceDto expected0 = TEST_SALIENCY_DTO.getFeatureImportance().get(0);\n+        FeatureImportance actual0 = featureImportances.get(0);\n+        assertEquals(expected0.getFeatureName(), actual0.getFeatureName());\n+        assertEquals(expected0.getScore(), actual0.getScore());\n+\n+        FeatureImportanceDto expected1 = TEST_SALIENCY_DTO.getFeatureImportance().get(1);\n+        FeatureImportance actual1 = featureImportances.get(1);\n+        assertEquals(expected1.getFeatureName(), actual1.getFeatureName());\n+        assertEquals(expected1.getScore(), actual1.getScore());\n+    }\n \n-        ExplainabilityResult explainabilityResult = ExplainabilityResultConsumer.explainabilityResultFrom(TEST_RESULT_DTO, TEST_DECISION);\n+    @Test\n+    void testExplainabilityResultFromWithValidParams() {\n+        testExplainabilityResultFromWith(TEST_DECISION, TEST_OUTCOME_1_ID);\n+    }\n \n-        Assertions.assertNotNull(explainabilityResult);\n-        Assertions.assertEquals(TEST_RESULT_DTO.getExecutionId(), explainabilityResult.getExecutionId());\n-        Assertions.assertEquals(TEST_RESULT_DTO.getSaliencies().size(), explainabilityResult.getSaliencies().size());\n-        Assertions.assertTrue(TEST_RESULT_DTO.getSaliencies().containsKey(\"saliency\"));\n-        // Assertions.assertEquals(TEST_RESULT_DTO.getSaliencies().get(\"saliency\").getFeatureImportance().size(),\n-        // explainabilityResult.getSaliencies().get(\"saliency\").getFeatureImportance().size());\n+    @Test\n+    void testExplainabilityResultFromWithNullDecision() {\n+        testExplainabilityResultFromWith(null, null);\n     }\n \n     @Test\n-    public void featureImportanceFrom() {\n-        Assertions.assertNull(ExplainabilityResultConsumer.featureImportanceFrom(null));\n+    void testExplainabilityResultFromWithNullDto() {\n+        assertNull(ExplainabilityResultConsumer.explainabilityResultFrom(null, null));\n+    }\n \n+    @Test\n+    void testFeatureImportanceFromWithValidParams() {\n         FeatureImportance featureImportance = ExplainabilityResultConsumer.featureImportanceFrom(TEST_FEATURE_IMPORTANCE_DTO_1);\n-\n-        Assertions.assertNotNull(featureImportance);\n-        Assertions.assertEquals(TEST_FEATURE_IMPORTANCE_DTO_1.getFeatureName(), featureImportance.getFeatureName());\n-        Assertions.assertEquals(TEST_FEATURE_IMPORTANCE_DTO_1.getScore(), featureImportance.getScore());\n+        assertNotNull(featureImportance);\n+        assertEquals(TEST_FEATURE_IMPORTANCE_DTO_1.getFeatureName(), featureImportance.getFeatureName());\n+        assertEquals(TEST_FEATURE_IMPORTANCE_DTO_1.getScore(), featureImportance.getScore());\n     }\n \n     @Test\n-    public void saliencyFrom() {\n-        Assertions.assertNull(ExplainabilityResultConsumer.saliencyFrom(null, null, null));\n+    void testFeatureImportanceFromWithNullDto() {\n+        assertNull(ExplainabilityResultConsumer.featureImportanceFrom(null));\n+    }\n \n-        Saliency saliency = ExplainabilityResultConsumer.saliencyFrom(\"O1-ID\", \"saliency\", TEST_SALIENCY_DTO);\n+    @Test\n+    void testSaliencyFromWithValidParams() {\n+        Saliency saliency = ExplainabilityResultConsumer.saliencyFrom(TEST_OUTCOME_1_ID, TEST_OUTCOME_1_NAME, TEST_SALIENCY_DTO);\n \n-        Assertions.assertNotNull(saliency);\n-        Assertions.assertEquals(TEST_SALIENCY_DTO.getFeatureImportance().size(), saliency.getFeatureImportance().size());\n-        Assertions.assertEquals(TEST_SALIENCY_DTO.getFeatureImportance().get(0).getFeatureName(),\n+        assertNotNull(saliency);\n+        assertEquals(TEST_SALIENCY_DTO.getFeatureImportance().size(), saliency.getFeatureImportance().size());\n+        assertEquals(TEST_SALIENCY_DTO.getFeatureImportance().get(0).getFeatureName(),\n                 saliency.getFeatureImportance().get(0).getFeatureName());\n-        Assertions.assertEquals(TEST_SALIENCY_DTO.getFeatureImportance().get(0).getScore(),\n+        assertEquals(TEST_SALIENCY_DTO.getFeatureImportance().get(0).getScore(),\n                 saliency.getFeatureImportance().get(0).getScore(), 0.1);\n     }\n \n+    @Test\n+    void testSaliencyFromWithNullDto() {\n+        assertNull(ExplainabilityResultConsumer.saliencyFrom(null, null, null));\n+    }\n+\n     private Message<String> mockMessage(String payload) {\n         Message<String> message = mock(Message.class);\n         when(message.getPayload()).thenReturn(payload);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMzAwOQ==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482213009", "body": "Can you please add a log message if there are no `Decision` that match with `executionId`?\r\nCan you also add a test for it?", "bodyText": "Can you please add a log message if there are no Decision that match with executionId?\nCan you also add a test for it?", "bodyHTML": "<p dir=\"auto\">Can you please add a log message if there are no <code>Decision</code> that match with <code>executionId</code>?<br>\nCan you also add a test for it?</p>", "author": "danielezonca", "createdAt": "2020-09-02T16:43:48Z", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +85,43 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n+        Decision decision = service.getDecisionById(executionId);", "originalCommit": "884822e982dead2623cdf7b4bba86435d7eb58f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg5NDgyMQ==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482894821", "bodyText": "Done \ud83d\udc4d", "author": "kostola", "createdAt": "2020-09-03T11:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMzAwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "0ffd007e6042a45220a1b6bd46e6709fe8a5c57c", "changed_code": [{"header": "diff --git a/trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java b/trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java\nindex 5117088bf..a937b47f0 100644\n--- a/trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java\n+++ b/trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java\n", "chunk": "@@ -86,7 +87,11 @@ public class ExplainabilityResultConsumer extends BaseEventConsumer<Explainabili\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n         String executionId = explainabilityResult.getExecutionId();\n+\n         Decision decision = service.getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n \n         service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n", "next_change": {"commit": "6479a29d043ee911e695c46b44f9ae1060a22164", "changed_code": [{"header": "diff --git a/trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java b/trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java\nindex a937b47f0..911603eb1 100644\n--- a/trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java\n+++ b/trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java\n", "chunk": "@@ -88,7 +88,7 @@ public class ExplainabilityResultConsumer extends BaseEventConsumer<Explainabili\n         ExplainabilityResultDto explainabilityResult = optData.get();\n         String executionId = explainabilityResult.getExecutionId();\n \n-        Decision decision = service.getDecisionById(executionId);\n+        Decision decision = getDecisionById(executionId);\n         if (decision == null) {\n             LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n         }\n", "next_change": null}, {"header": "diff --git a/trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java b/trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java\nindex a937b47f0..911603eb1 100644\n--- a/trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java\n+++ b/trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java\n", "chunk": "@@ -96,6 +96,14 @@ public class ExplainabilityResultConsumer extends BaseEventConsumer<Explainabili\n         service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n     protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n", "next_change": null}]}}]}}, {"oid": "ef114be0ed09b87b8fe3e93836736f904044bb3b", "url": "https://github.com/kiegroup/kogito-apps/commit/ef114be0ed09b87b8fe3e93836736f904044bb3b", "message": "KOGITO-3228: add outcome ids to saliency model", "committedDate": "2020-09-03T07:32:23Z", "type": "commit"}, {"oid": "35b20c28fef8328844dc1c01f75db4c5c5349722", "url": "https://github.com/kiegroup/kogito-apps/commit/35b20c28fef8328844dc1c01f75db4c5c5349722", "message": "KOGITO-3228: add status directly to ExplainabilityResultDto instead of boolean attribute", "committedDate": "2020-09-03T07:32:23Z", "type": "commit"}, {"oid": "01c0deea104fb557702d054f9dc7435d5417c467", "url": "https://github.com/kiegroup/kogito-apps/commit/01c0deea104fb557702d054f9dc7435d5417c467", "message": "KOGITO-3228: fix test", "committedDate": "2020-09-03T07:32:23Z", "type": "commit"}, {"oid": "d7a184c1bdcb33d367f48022bd4576266680da81", "url": "https://github.com/kiegroup/kogito-apps/commit/d7a184c1bdcb33d367f48022bd4576266680da81", "message": "KOGITO-3228: add status details field to explainability result", "committedDate": "2020-09-03T07:32:23Z", "type": "commit"}, {"oid": "a5f7f0461e0f1ca2837c8ff48fd76e4770d6bec6", "url": "https://github.com/kiegroup/kogito-apps/commit/a5f7f0461e0f1ca2837c8ff48fd76e4770d6bec6", "message": "KOGITO-3228: add 'explanation' prefix to saliencies endpoint", "committedDate": "2020-09-03T07:32:23Z", "type": "commit"}, {"oid": "6b7e33f13be5d7946926001e9ffd5e53c0168650", "url": "https://github.com/kiegroup/kogito-apps/commit/6b7e33f13be5d7946926001e9ffd5e53c0168650", "message": "KOGITO-3228: remove extra CompletableFuture::supplyAsync call from ExplanationServiceImpl::explainAsync", "committedDate": "2020-09-03T08:57:37Z", "type": "commit"}, {"oid": "6b7e33f13be5d7946926001e9ffd5e53c0168650", "url": "https://github.com/kiegroup/kogito-apps/commit/6b7e33f13be5d7946926001e9ffd5e53c0168650", "message": "KOGITO-3228: remove extra CompletableFuture::supplyAsync call from ExplanationServiceImpl::explainAsync", "committedDate": "2020-09-03T08:57:37Z", "type": "forcePushed"}, {"oid": "c01963439757c1823b0abef8b6ac4c69c004e1bf", "url": "https://github.com/kiegroup/kogito-apps/commit/c01963439757c1823b0abef8b6ac4c69c004e1bf", "message": "KOGITO-3228: remove explainability-api dependency from trusty-storage-api", "committedDate": "2020-09-03T09:38:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg1MTkyNA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482851924", "body": "Is the try catch needed in this case? Is there a test for such scenario?", "bodyText": "Is the try catch needed in this case? Is there a test for such scenario?", "bodyHTML": "<p dir=\"auto\">Is the try catch needed in this case? Is there a test for such scenario?</p>", "author": "r00ta", "createdAt": "2020-09-03T09:47:12Z", "path": "explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java", "diffHunk": "@@ -61,17 +63,17 @@ public ExplanationServiceImpl(\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        Prediction prediction = getPrediction(request.getInputs(), request.getOutputs());\n-        return localExplainer.explainAsync(prediction, predictionProvider)\n-                .thenApply(input -> createResultDto(input, request.getExecutionId()))\n-                .exceptionally(throwable -> {\n-                    LOG.error(\"Exception thrown during explainAsync\", throwable);\n-                    return new ExplainabilityResultDto(request.getExecutionId(), Collections.emptyMap());\n-                });\n+        try {\n+            return localExplainer.explainAsync(getPrediction(request.getInputs(), request.getOutputs()), predictionProvider)\n+                    .thenApply(input -> createSucceededResultDto(request.getExecutionId(), input))\n+                    .exceptionally(e -> createFailedResultDto(request.getExecutionId(), e));\n+        } catch (Exception e) {", "originalCommit": "6b7e33f13be5d7946926001e9ffd5e53c0168650", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg2ODAyNw==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482868027", "bodyText": "Yes it is needed and there is a test. Please check this discussion.", "author": "kostola", "createdAt": "2020-09-03T10:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg1MTkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg5MTcyNw==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482891727", "bodyText": "This catch is to prevent explainAsync method to throw an unexpected exception instead of return the CompletableFuture", "author": "danielezonca", "createdAt": "2020-09-03T11:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg1MTkyNA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "0ffd007e6042a45220a1b6bd46e6709fe8a5c57c", "url": "https://github.com/kiegroup/kogito-apps/commit/0ffd007e6042a45220a1b6bd46e6709fe8a5c57c", "message": "KOGITO-3228: improve ExplainabilityResultConsumerTest", "committedDate": "2020-09-03T10:54:14Z", "type": "commit"}, {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164", "url": "https://github.com/kiegroup/kogito-apps/commit/6479a29d043ee911e695c46b44f9ae1060a22164", "message": "KOGITO-3228: handle IllegalArgumentException in ExplainabilityResultConsumer", "committedDate": "2020-09-03T11:04:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDI4MA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483460280", "body": "Shouldn't we rather throw or exception or return some error info here?", "bodyText": "Shouldn't we rather throw or exception or return some error info here?", "bodyHTML": "<p dir=\"auto\">Shouldn't we rather throw or exception or return some error info here?</p>", "author": "jiripetrlik", "createdAt": "2020-09-04T08:12:04Z", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;", "originalCommit": "6479a29d043ee911e695c46b44f9ae1060a22164", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMzY2Mw==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483513663", "bodyText": "Throwing a IllegalArgumentException is the current behavior of the TrustyServiceImpl when it doesn't find a decision with the associated ID.\nIn this case in my implementation I need to return null when this happens.\nFor me it's not an error and in fact it's logged as warning by the caller method because the computation can continue in a \"best effort\" way even without a Decision object.", "author": "kostola", "createdAt": "2020-09-04T09:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDI4MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDY2NA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483460664", "body": "Please consider to throw exception.", "bodyText": "Please consider to throw exception.", "bodyHTML": "<p dir=\"auto\">Please consider to throw exception.</p>", "author": "jiripetrlik", "createdAt": "2020-09-04T08:12:46Z", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n         }\n-        Map<String, Saliency> saliencies = dto.getSaliencies() == null ? null :\n+\n+        Map<String, String> outcomeNameToIdMap = decision == null\n+                ? Collections.emptyMap()\n+                : decision.getOutcomes().stream().collect(Collectors.toUnmodifiableMap(DecisionOutcome::getOutcomeName, DecisionOutcome::getOutcomeId));\n+\n+        List<Saliency> saliencies = dto.getSaliencies() == null ? null :\n                 dto.getSaliencies().entrySet().stream()\n-                        .collect(Collectors.toMap(Map.Entry::getKey, e -> saliencyFrom(e.getValue())));\n-        return new ExplainabilityResult(dto.getExecutionId(), saliencies);\n+                        .map(e -> saliencyFrom(outcomeNameToIdMap.get(e.getKey()), e.getKey(), e.getValue()))\n+                        .collect(Collectors.toList());\n+        return new ExplainabilityResult(dto.getExecutionId(), statusFrom(dto.getStatus()), dto.getStatusDetails(), saliencies);\n     }\n \n     protected static FeatureImportance featureImportanceFrom(FeatureImportanceDto dto) {\n         if (dto == null) {\n             return null;", "originalCommit": "6479a29d043ee911e695c46b44f9ae1060a22164", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNDc5NA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483514794", "bodyText": "It's not an error in my opinion: if the dto for some reason is null, then the model should be null.", "author": "kostola", "createdAt": "2020-09-04T09:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDY2NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MTA3Mg==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483461072", "body": "Please consider to throw exception.", "bodyText": "Please consider to throw exception.", "bodyHTML": "<p dir=\"auto\">Please consider to throw exception.</p>", "author": "jiripetrlik", "createdAt": "2020-09-04T08:13:31Z", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n         }\n-        Map<String, Saliency> saliencies = dto.getSaliencies() == null ? null :\n+\n+        Map<String, String> outcomeNameToIdMap = decision == null\n+                ? Collections.emptyMap()\n+                : decision.getOutcomes().stream().collect(Collectors.toUnmodifiableMap(DecisionOutcome::getOutcomeName, DecisionOutcome::getOutcomeId));\n+\n+        List<Saliency> saliencies = dto.getSaliencies() == null ? null :\n                 dto.getSaliencies().entrySet().stream()\n-                        .collect(Collectors.toMap(Map.Entry::getKey, e -> saliencyFrom(e.getValue())));\n-        return new ExplainabilityResult(dto.getExecutionId(), saliencies);\n+                        .map(e -> saliencyFrom(outcomeNameToIdMap.get(e.getKey()), e.getKey(), e.getValue()))\n+                        .collect(Collectors.toList());\n+        return new ExplainabilityResult(dto.getExecutionId(), statusFrom(dto.getStatus()), dto.getStatusDetails(), saliencies);\n     }\n \n     protected static FeatureImportance featureImportanceFrom(FeatureImportanceDto dto) {\n         if (dto == null) {\n             return null;\n         }\n-        return new FeatureImportance(dto.getFeatureId(), dto.getScore());\n+        return new FeatureImportance(dto.getFeatureName(), dto.getScore());\n     }\n \n-    protected static Saliency saliencyFrom(SaliencyDto dto) {\n+    protected static Saliency saliencyFrom(String outcomeId, String outcomeName, SaliencyDto dto) {\n         if (dto == null) {\n             return null;", "originalCommit": "6479a29d043ee911e695c46b44f9ae1060a22164", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNDg2NA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483514864", "bodyText": "It's not an error in my opinion: if the dto for some reason is null, then the model should be null.", "author": "kostola", "createdAt": "2020-09-04T09:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MTA3Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MTI4OQ==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483461289", "body": "Please consider to throw exception.", "bodyText": "Please consider to throw exception.", "bodyHTML": "<p dir=\"auto\">Please consider to throw exception.</p>", "author": "jiripetrlik", "createdAt": "2020-09-04T08:13:54Z", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n         }\n-        Map<String, Saliency> saliencies = dto.getSaliencies() == null ? null :\n+\n+        Map<String, String> outcomeNameToIdMap = decision == null\n+                ? Collections.emptyMap()\n+                : decision.getOutcomes().stream().collect(Collectors.toUnmodifiableMap(DecisionOutcome::getOutcomeName, DecisionOutcome::getOutcomeId));\n+\n+        List<Saliency> saliencies = dto.getSaliencies() == null ? null :\n                 dto.getSaliencies().entrySet().stream()\n-                        .collect(Collectors.toMap(Map.Entry::getKey, e -> saliencyFrom(e.getValue())));\n-        return new ExplainabilityResult(dto.getExecutionId(), saliencies);\n+                        .map(e -> saliencyFrom(outcomeNameToIdMap.get(e.getKey()), e.getKey(), e.getValue()))\n+                        .collect(Collectors.toList());\n+        return new ExplainabilityResult(dto.getExecutionId(), statusFrom(dto.getStatus()), dto.getStatusDetails(), saliencies);\n     }\n \n     protected static FeatureImportance featureImportanceFrom(FeatureImportanceDto dto) {\n         if (dto == null) {\n             return null;\n         }\n-        return new FeatureImportance(dto.getFeatureId(), dto.getScore());\n+        return new FeatureImportance(dto.getFeatureName(), dto.getScore());\n     }\n \n-    protected static Saliency saliencyFrom(SaliencyDto dto) {\n+    protected static Saliency saliencyFrom(String outcomeId, String outcomeName, SaliencyDto dto) {\n         if (dto == null) {\n             return null;\n         }\n         List<FeatureImportance> featureImportance = dto.getFeatureImportance() == null ? null :\n                 dto.getFeatureImportance().stream()\n                         .map(ExplainabilityResultConsumer::featureImportanceFrom)\n                         .collect(Collectors.toList());\n-        return new Saliency(featureImportance);\n+        return new Saliency(outcomeId, outcomeName, featureImportance);\n     }\n-}\n \n+    protected static ExplainabilityStatus statusFrom(org.kie.kogito.explainability.api.ExplainabilityStatus status) {\n+        switch (status) {\n+            case SUCCEEDED:\n+                return ExplainabilityStatus.SUCCEEDED;\n+            case FAILED:\n+                return ExplainabilityStatus.FAILED;\n+        }\n+        return null;", "originalCommit": "6479a29d043ee911e695c46b44f9ae1060a22164", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}