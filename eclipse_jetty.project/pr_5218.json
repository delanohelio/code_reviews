{"pr_number": 5218, "pr_title": "Alternative Pool Strategies", "pr_createdAt": "2020-09-01T10:16:27Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/5218", "merge_commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "timeline": [{"oid": "b63c59d511e274908808ac3b338c40149f074864", "url": "https://github.com/eclipse/jetty.project/commit/b63c59d511e274908808ac3b338c40149f074864", "message": "Speculative idea to make a pluggable Pool strategy\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-01T10:14:49Z", "type": "commit"}, {"oid": "410fe53ea19e7b0a66e010da66672936326cfc55", "url": "https://github.com/eclipse/jetty.project/commit/410fe53ea19e7b0a66e010da66672936326cfc55", "message": "Speculative idea to make a pluggable Pool strategy\n\n + javadoc\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-01T13:43:34Z", "type": "commit"}, {"oid": "27d31dedb26cd625b3919b31efd7043c78abf226", "url": "https://github.com/eclipse/jetty.project/commit/27d31dedb26cd625b3919b31efd7043c78abf226", "message": "Speculative idea to make a pluggable Pool strategy\n\n + Added a ThreadLocalStrategy for a single cached item\n + Tell strategies about newly reserved entries\n + Fixed multiplexing test that was dependent on the impl of the cache\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-01T14:13:17Z", "type": "commit"}, {"oid": "91df8dad0945b6951ff30629df4e86e739a02d85", "url": "https://github.com/eclipse/jetty.project/commit/91df8dad0945b6951ff30629df4e86e739a02d85", "message": "Speculative idea to make a pluggable Pool strategy\n\n + added tests\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-01T15:38:54Z", "type": "commit"}, {"oid": "db086a513502d36bde7d1d886eaea7dca3e53721", "url": "https://github.com/eclipse/jetty.project/commit/db086a513502d36bde7d1d886eaea7dca3e53721", "message": "Feedback from review\n\n + Don't have a fallback iteration, instead make a SearchStrategy and DualStrategy", "committedDate": "2020-09-02T11:53:56Z", "type": "commit"}, {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "url": "https://github.com/eclipse/jetty.project/commit/6ab7bd726b0e2412a5c1497348473dbac98d64a3", "message": "Feedback from review\n\n + split strategies into Cache and Strategies", "committedDate": "2020-09-02T12:34:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NDU0NA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482044544", "body": "Why a `release()` inside `reserve()`?", "bodyText": "Why a release() inside reserve()?", "bodyHTML": "<p dir=\"auto\">Why a <code>release()</code> inside <code>reserve()</code>?</p>", "author": "sbordet", "createdAt": "2020-09-02T12:53:16Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -165,7 +201,8 @@ public Entry reserve(int allotment)\n             pending.incrementAndGet();\n \n             Entry entry = new Entry();\n-            sharedList.add(entry);\n+            entries.add(entry);\n+            strategy.released(entries, entry, true);", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e250a4966d93eeb9117b93c6a9030ca7537a8443", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..4b45a8e656 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -201,8 +201,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             pending.incrementAndGet();\n \n             Entry entry = new Entry();\n-            entries.add(entry);\n-            strategy.released(entries, entry, true);\n+            strategy.reserve(entries, entry);\n             return entry;\n         }\n     }\n", "next_change": {"commit": "505321687c6ad3e7bcc6e64e6d1d0b183167b419", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 4b45a8e656..b088f5b4b0 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -201,7 +225,8 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             pending.incrementAndGet();\n \n             Entry entry = new Entry();\n-            strategy.reserve(entries, entry);\n+            entries.add(entry);\n+            strategy.reserved(entry);\n             return entry;\n         }\n     }\n", "next_change": {"commit": "0aa6bc92110ade8c4c96b26e8c074620447857ee", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex b088f5b4b0..03b9966fc2 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -226,7 +228,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n             Entry entry = new Entry();\n             entries.add(entry);\n-            strategy.reserved(entry);\n             return entry;\n         }\n     }\n", "next_change": {"commit": "feda65d15aa906a1c0689ea45b26e15a17906beb", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 03b9966fc2..0f18b89c08 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -226,7 +234,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n                 return null;\n             pending.incrementAndGet();\n \n-            Entry entry = new Entry();\n+            Entry entry = new Entry(entries.size());\n             entries.add(entry);\n             return entry;\n         }\n", "next_change": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0f18b89c08..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -234,7 +219,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n                 return null;\n             pending.incrementAndGet();\n \n-            Entry entry = new Entry(entries.size());\n+            Entry entry = new Entry();\n             entries.add(entry);\n             return entry;\n         }\n", "next_change": {"commit": "6c90442d5b368d3d6274acfd81893d37d6755951", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex f125cd8215..ab606c5588 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -227,7 +212,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n     /**\n      * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     *\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NzMzMw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482047333", "body": "Just `release()` and implementations have to call `entry.tryRelease()` so that we're symmetric with `acquire()` above?", "bodyText": "Just release() and implementations have to call entry.tryRelease() so that we're symmetric with acquire() above?", "bodyHTML": "<p dir=\"auto\">Just <code>release()</code> and implementations have to call <code>entry.tryRelease()</code> so that we're symmetric with <code>acquire()</code> above?</p>", "author": "sbordet", "createdAt": "2020-09-02T12:57:31Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NTkxNA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482055914", "bodyText": "I second @sbordet; and wouldn't the following signature be better?\nvoid release(Pool<T>.Entry entry);\nwithout a list of entries (I can't see why it would be needed) and no default impl?", "author": "lorban", "createdAt": "2020-09-02T13:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NzMzMw=="}], "type": "inlineReview", "revised_code": {"commit": "e250a4966d93eeb9117b93c6a9030ca7537a8443", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..4b45a8e656 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -590,43 +577,71 @@ public class Pool<T> implements AutoCloseable, Dumpable\n          * Notification an entry has been release.  The notification comes after the entry\n          * has been put back in the pool and it may already have been reacquired before or during this call.\n          * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @param entry The entry to be release\n-         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         * @param entry The entry to be released\n          */\n-        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        default boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n         {\n+            return entry.tryRelease();\n         }\n-    }\n \n-    public interface Strategy<T> extends Cache<T>\n-    {\n-    }\n+        default void reserve(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            entries.add(entry);\n+        }\n+\n+        default boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            if (!entry.tryRemove())\n+            {\n+                if (LOGGER.isDebugEnabled())\n+                    LOGGER.debug(\"Attempt to remove an object from the pool that is still in use: {}\", entry);\n+                return false;\n+            }\n \n-    public static class CacheStrategy<T> implements Strategy<T>\n+            boolean removed = entries.remove(entry);\n+            if (!removed)\n+            {\n+                if (LOGGER.isDebugEnabled())\n+                    LOGGER.debug(\"Attempt to remove an object from the pool that does not exist: {}\", entry);\n+            }\n+            return removed;\n+        }\n+    }\n+    \n+    public static class CompositeStrategy<T> implements Strategy<T>\n     {\n-        final Cache<T> cache;\n-        final Strategy<T> strategy;\n+        final Strategy<T> planA;\n+        final Strategy<T> planB;\n \n-        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n         {\n-            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planA);\n             Objects.requireNonNull(planB);\n-            this.cache = cache;\n-            this.strategy = planB;\n+            this.planA = planA;\n+            this.planB = planB;\n         }\n \n         @Override\n         public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n         {\n-            Pool<T>.Entry entry = cache.acquire(entries);\n-            return entry == null ? strategy.acquire(entries) : entry;\n+            Pool<T>.Entry entry = planA.acquire(entries);\n+            return entry == null ? planB.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            if (planA.release(entries, entry))\n+                return true;\n+            if (entry.isOverUsed())\n+                return false;\n+            return planB.release(entries, entry);\n         }\n \n         @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        public boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n         {\n-            cache.released(entries, entry, reusable);\n-            strategy.released(entries, entry, reusable);\n+            return planA.remove(entries, entry) || planB.remove(entries, entry);\n         }\n     }\n \n", "next_change": {"commit": "505321687c6ad3e7bcc6e64e6d1d0b183167b419", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 4b45a8e656..b088f5b4b0 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,33 +646,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n \n         @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n-            Pool<T>.Entry entry = planA.acquire(entries);\n-            return entry == null ? planB.acquire(entries) : entry;\n+            Pool<T>.Entry entry = planA.tryAcquire(entries);\n+            return entry != null ? entry : planB.tryAcquire(entries);\n         }\n \n         @Override\n-        public boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        public void released(Pool<T>.Entry entry)\n         {\n-            if (planA.release(entries, entry))\n-                return true;\n-            if (entry.isOverUsed())\n-                return false;\n-            return planB.release(entries, entry);\n+            planA.released(entry);\n+            planB.released(entry);\n         }\n \n         @Override\n-        public boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        public void removed(Pool<T>.Entry entry)\n         {\n-            return planA.remove(entries, entry) || planB.remove(entries, entry);\n+            planA.removed(entry);\n+            planB.removed(entry);\n         }\n     }\n \n-    public static class SearchStrategy<T> implements Strategy<T>\n+    public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n         @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n             for (Pool<T>.Entry e : entries)\n             {\n", "next_change": {"commit": "15ab22647b3e1bc8e791d9a4e6bd16a9d1ed61e8", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex b088f5b4b0..ce5092a04d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -658,15 +659,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             planA.released(entry);\n             planB.released(entry);\n         }\n-\n-        @Override\n-        public void removed(Pool<T>.Entry entry)\n-        {\n-            planA.removed(entry);\n-            planB.removed(entry);\n-        }\n     }\n \n+    /**\n+     * @param <T> The type of entry the strategy is for\n+     */\n     public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n         @Override\n", "next_change": {"commit": "c18a77e8135047393ba289ca3179693b5af4ffad", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex ce5092a04d..89dd157034 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -662,7 +662,9 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * @param <T> The type of entry the strategy is for\n+     * Linear search strategy uses a fresh iterator to scan the\n+     * entries, starting at 0, until it can acquire one.\n+     * @param <T> The type of entry the strategy is for.\n      */\n     public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n", "next_change": {"commit": "feda65d15aa906a1c0689ea45b26e15a17906beb", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 89dd157034..0f18b89c08 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -661,6 +671,42 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+\n+    /**\n+     * This strategy retries a wrapped strategy looking for\n+     * and Entry\n+     * @param <T> The type of entry the strategy is for.\n+     */\n+    public static class RetryStategy<T> implements Strategy<T>\n+    {\n+        final Strategy<T> strategy;\n+        final int retries;\n+\n+        public RetryStategy(Strategy<T> strategy)\n+        {\n+            this (strategy, -1);\n+        }\n+\n+        public RetryStategy(Strategy<T> strategy, int retries)\n+        {\n+            this.strategy = strategy;\n+            this.retries = retries;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        {\n+            int tries = retries < 0 ? entries.size() : retries;\n+            while (tries-- > 0)\n+            {\n+                Pool<T>.Entry entry = strategy.tryAcquire(entries);\n+                if (entry != null)\n+                    return entry;\n+            }\n+            return null;\n+        }\n+    }\n+\n     /**\n      * Linear search strategy uses a fresh iterator to scan the\n      * entries, starting at 0, until it can acquire one.\n", "next_change": {"commit": "bf520b4d8b559c5ed8551573d780dced775bcc06", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0f18b89c08..c311021e1a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -617,481 +571,86 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /** A pluggable strategy to for pool entry lookup\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Strategy<T>\n+    public static class Linear<T> extends Pool<T>\n     {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entry The entry to be released\n-         */\n-        default void released(Pool<T>.Entry entry)\n+        public Linear(int maxEntries)\n         {\n-        }\n-    }\n-\n-    /** A Composite strategy used to combine multiple other strategies.\n-     * Typically it is used to combine an optimistic strategy (eg {@link RandomStrategy})\n-     * with an exhaustive strategy (eg {@link LinearSearchStrategy}).\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class CompositeStrategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> planA;\n-        final Strategy<T> planB;\n-\n-        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(planA);\n-            Objects.requireNonNull(planB);\n-            this.planA = planA;\n-            this.planB = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = planA.tryAcquire(entries);\n-            return entry != null ? entry : planB.tryAcquire(entries);\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            planA.released(entry);\n-            planB.released(entry);\n-        }\n-    }\n-\n-\n-    /**\n-     * This strategy retries a wrapped strategy looking for\n-     * and Entry\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RetryStategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> strategy;\n-        final int retries;\n-\n-        public RetryStategy(Strategy<T> strategy)\n-        {\n-            this (strategy, -1);\n-        }\n-\n-        public RetryStategy(Strategy<T> strategy, int retries)\n-        {\n-            this.strategy = strategy;\n-            this.retries = retries;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = retries < 0 ? entries.size() : retries;\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = strategy.tryAcquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Linear search strategy uses a fresh iterator to scan the\n-     * entries, starting at 0, until it can acquire one.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LinearSearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores a {@link ListIterator} as a {@link ThreadLocal}\n-     * which is used to scan the list of entries for one that can be acquired.\n-     * Once an entry is acquired, if the strategy is in roundrobin mode, then\n-     * it is left on the next entry, otherwise it is moved back so the current\n-     * entry will be tried again on the next acquire.\n-     * If the iterator reaches the end, then a new one is created.\n-     * The strategy will only try as many times as there are entries.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalIteratorStrategy<T> implements Strategy<T>\n-    {\n-        private final boolean roundrobin;\n-        private final ThreadLocal<ListIterator<Pool<T>.Entry>> iterator = new ThreadLocal<>();\n-\n-        public ThreadLocalIteratorStrategy()\n-        {\n-            this(false);\n-        }\n-\n-        public ThreadLocalIteratorStrategy(boolean roundrobin)\n-        {\n-            this.roundrobin = roundrobin;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            ListIterator<Pool<T>.Entry> iter = iterator.get();\n-            if (iter == null)\n-                iter = entries.listIterator();\n-\n-            for (int tries = entries.size(); tries-- > 0; )\n-            {\n-                if (!iter.hasNext())\n-                {\n-                    iter = entries.listIterator();\n-                    if (!iter.hasNext())\n-                        return null;\n-                }\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry != null && entry.tryAcquire())\n-                {\n-                    if (!roundrobin)\n-                        iter.previous();\n-                    if (iter.hasNext())\n-                        iterator.set(iter);\n-                    return entry;\n-                }\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores the last entry released by a thread as in\n-     * {@link ThreadLocal} so it can be the first tried on the next\n-     * acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalStrategy<T> implements Strategy<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalStrategy()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n+            super(maxEntries);\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        protected int startIndex(int size)\n         {\n-            last.set(entry);\n+            return 0;\n         }\n     }\n \n-    /**\n-     * This strategy stores the entries released by a thread in a bounded list\n-     * stored in a {@link ThreadLocal},  so they can be the first tried on the\n-     * next acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalListStrategy<T> implements Strategy<T>\n+    public static class Random<T> extends Pool<T>\n     {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListStrategy(int size)\n+        public Random(int maxEntries)\n         {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+            super(maxEntries);\n         }\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            if (cachedList.size() < cacheSize)\n-                cachedList.add(entry);\n+            return ThreadLocalRandom.current().nextInt(size);\n         }\n     }\n \n-    private abstract static class IndexedStrategy<T> implements Strategy<T>\n+    public static class RoundRobin<T> extends Pool<T>\n     {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (IndexOutOfBoundsException e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n+        private final AtomicInteger next = new AtomicInteger();\n \n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    /**\n-     * This strategy tries to acquire a random entry.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class RandomStrategy<T> extends IndexedStrategy<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n+        public RoundRobin(int maxEntries)\n         {\n-            return ThreadLocalRandom.current().nextInt(size);\n+            super(maxEntries);\n         }\n-    }\n \n-    public static class ThreadIdStrategy<T> extends IndexedStrategy<T>\n-    {\n         @Override\n-        protected int nextIndex(int size)\n+        protected int startIndex(int size)\n         {\n-            return (int)Thread.currentThread().getId() % size;\n+            return next.getAndUpdate(c -> ++c < size ? c : 0);\n         }\n     }\n \n-    /**\n-     * This strategy uses an {@link AtomicInteger} to remember the index\n-     * of the last acquired entry. Calls to acquire will commence trying\n-     * to acquired from the next index.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinStrategy<T> extends IndexedStrategy<T>\n+    public static class Thread<T> extends Pool<T>\n     {\n-        AtomicInteger index = new AtomicInteger();\n+        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n \n-        @Override\n-        protected int nextIndex(int size)\n+        public Thread(int maxEntries)\n         {\n-            return index.getAndUpdate(c -> ++c < size ? c : 0);\n+            super(maxEntries);\n         }\n-    }\n \n-    /**\n-     * This strategy iterates over the entries, starting from a random location,\n-     * to try to acquire an entry.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RandomIterationStrategy<T> implements Strategy<T>\n-    {\n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int r = ThreadLocalRandom.current().nextInt(size);\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(r);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= r)\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            return null;\n+            return 0;\n         }\n-    }\n-\n-    /**\n-     * This strategy commences an iteration over the entries from the\n-     * position after the last successful acquire.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinIterationStrategy<T> implements Strategy<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        public Entry acquire()\n         {\n-            int i = index.get();\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(i);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n-                    return entry;\n-                }\n-            }\n \n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= i)\n+            Entry entry = last.get();\n+            if (entry != null)\n             {\n-                Pool<T>.Entry entry = iter.next();\n                 if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n                     return entry;\n-                }\n-            }\n-\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy keeps a queue of the least recently used entry. If that queue is\n-     * empty, then this strategy falls back to a linear search.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LeastRecentlyUsedStrategy<T> extends LinearSearchStrategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    entry = super.tryAcquire(entries);\n-                else if (!entry.tryAcquire())\n-                    continue;\n-\n-                if (entry != null)\n-                    lru.add(entry);\n-                return entry;\n-            }\n-        }\n-    }\n-\n-    public static class OneStrategyToRuleThemAll<T> implements Strategy<T>\n-    {\n-        private final Mode mode;\n-        private final ThreadLocal<Integer> last;\n-        private final AtomicInteger next;\n-\n-        enum Mode\n-        {\n-            LINEAR,\n-            RANDOM,\n-            THREAD_LOCAL,\n-            ROUND_ROBIN,\n-        }\n-\n-        public OneStrategyToRuleThemAll(Mode mode)\n-        {\n-            this.mode = mode;\n-            last = mode == Mode.THREAD_LOCAL ? ThreadLocal.withInitial(()->0) : null;\n-            next = mode == Mode.ROUND_ROBIN ? new AtomicInteger() : null;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-\n-            int index;\n-            switch (mode)\n-            {\n-                case LINEAR:\n-                    index = 0;\n-                    break;\n-                case RANDOM:\n-                    index = ThreadLocalRandom.current().nextInt(size);\n-                    break;\n-                case THREAD_LOCAL:\n-                    index = last.get();\n-                    break;\n-                case ROUND_ROBIN:\n-                    index = next.getAndUpdate(c -> ++c < size ? c : 0);\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-\n-            for (int tries = size; tries-- > 0;)\n-            {\n-                try\n-                {\n-                    Pool<T>.Entry entry = entries.get(index);\n-                    if (entry != null && entry.tryAcquire())\n-                        return entry;\n-                }\n-                catch (IndexOutOfBoundsException e)\n-                {\n-                    LOGGER.ignore(e);\n-                }\n-                index = (index + 1) % size;\n+                last.set(null);\n             }\n-            return null;\n+            return super.acquire();\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        public boolean release(Entry entry)\n         {\n-            if (last != null)\n-                last.set(entry.index);\n+            boolean released =  super.release(entry);\n+            if (released)\n+                last.set(entry);\n+            return released;\n         }\n     }\n }\n", "next_change": {"commit": "db00126abd11f5734e499bb8a7ab795bc769b879", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c311021e1a..723a79fbde 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -570,87 +618,4 @@ public abstract class Pool<T> implements AutoCloseable, Dumpable\n                 pooled);\n         }\n     }\n-\n-    public static class Linear<T> extends Pool<T>\n-    {\n-        public Linear(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-    }\n-\n-    public static class Random<T> extends Pool<T>\n-    {\n-        public Random(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobin<T> extends Pool<T>\n-    {\n-        private final AtomicInteger next = new AtomicInteger();\n-\n-        public RoundRobin(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return next.getAndUpdate(c -> ++c < size ? c : 0);\n-        }\n-    }\n-\n-    public static class Thread<T> extends Pool<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n-\n-        public Thread(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-\n-        @Override\n-        public Entry acquire()\n-        {\n-\n-            Entry entry = last.get();\n-            if (entry != null)\n-            {\n-                if (entry.tryAcquire())\n-                    return entry;\n-                last.set(null);\n-            }\n-            return super.acquire();\n-        }\n-\n-        @Override\n-        public boolean release(Entry entry)\n-        {\n-            boolean released =  super.release(entry);\n-            if (released)\n-                last.set(entry);\n-            return released;\n-        }\n-    }\n }\n", "next_change": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 723a79fbde..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -603,17 +629,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            int hi = AtomicBiInteger.getHi(encoded);\n-            int lo = AtomicBiInteger.getLo(encoded);\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = hi < 0 ? \"CLOSED\" : lo == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n \n             return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n-                Math.max(hi, 0),\n-                Math.max(lo, 0),\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NzcyMg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482047722", "body": "Is not this class missing a `remove()` method?", "bodyText": "Is not this class missing a remove() method?", "bodyHTML": "<p dir=\"auto\">Is not this class missing a <code>remove()</code> method?</p>", "author": "sbordet", "createdAt": "2020-09-02T12:58:08Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e250a4966d93eeb9117b93c6a9030ca7537a8443", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..4b45a8e656 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -590,43 +577,71 @@ public class Pool<T> implements AutoCloseable, Dumpable\n          * Notification an entry has been release.  The notification comes after the entry\n          * has been put back in the pool and it may already have been reacquired before or during this call.\n          * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @param entry The entry to be release\n-         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         * @param entry The entry to be released\n          */\n-        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        default boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n         {\n+            return entry.tryRelease();\n         }\n-    }\n \n-    public interface Strategy<T> extends Cache<T>\n-    {\n-    }\n+        default void reserve(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            entries.add(entry);\n+        }\n+\n+        default boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            if (!entry.tryRemove())\n+            {\n+                if (LOGGER.isDebugEnabled())\n+                    LOGGER.debug(\"Attempt to remove an object from the pool that is still in use: {}\", entry);\n+                return false;\n+            }\n \n-    public static class CacheStrategy<T> implements Strategy<T>\n+            boolean removed = entries.remove(entry);\n+            if (!removed)\n+            {\n+                if (LOGGER.isDebugEnabled())\n+                    LOGGER.debug(\"Attempt to remove an object from the pool that does not exist: {}\", entry);\n+            }\n+            return removed;\n+        }\n+    }\n+    \n+    public static class CompositeStrategy<T> implements Strategy<T>\n     {\n-        final Cache<T> cache;\n-        final Strategy<T> strategy;\n+        final Strategy<T> planA;\n+        final Strategy<T> planB;\n \n-        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n         {\n-            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planA);\n             Objects.requireNonNull(planB);\n-            this.cache = cache;\n-            this.strategy = planB;\n+            this.planA = planA;\n+            this.planB = planB;\n         }\n \n         @Override\n         public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n         {\n-            Pool<T>.Entry entry = cache.acquire(entries);\n-            return entry == null ? strategy.acquire(entries) : entry;\n+            Pool<T>.Entry entry = planA.acquire(entries);\n+            return entry == null ? planB.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            if (planA.release(entries, entry))\n+                return true;\n+            if (entry.isOverUsed())\n+                return false;\n+            return planB.release(entries, entry);\n         }\n \n         @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        public boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n         {\n-            cache.released(entries, entry, reusable);\n-            strategy.released(entries, entry, reusable);\n+            return planA.remove(entries, entry) || planB.remove(entries, entry);\n         }\n     }\n \n", "next_change": {"commit": "505321687c6ad3e7bcc6e64e6d1d0b183167b419", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 4b45a8e656..b088f5b4b0 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,33 +646,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n \n         @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n-            Pool<T>.Entry entry = planA.acquire(entries);\n-            return entry == null ? planB.acquire(entries) : entry;\n+            Pool<T>.Entry entry = planA.tryAcquire(entries);\n+            return entry != null ? entry : planB.tryAcquire(entries);\n         }\n \n         @Override\n-        public boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        public void released(Pool<T>.Entry entry)\n         {\n-            if (planA.release(entries, entry))\n-                return true;\n-            if (entry.isOverUsed())\n-                return false;\n-            return planB.release(entries, entry);\n+            planA.released(entry);\n+            planB.released(entry);\n         }\n \n         @Override\n-        public boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        public void removed(Pool<T>.Entry entry)\n         {\n-            return planA.remove(entries, entry) || planB.remove(entries, entry);\n+            planA.removed(entry);\n+            planB.removed(entry);\n         }\n     }\n \n-    public static class SearchStrategy<T> implements Strategy<T>\n+    public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n         @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n             for (Pool<T>.Entry e : entries)\n             {\n", "next_change": {"commit": "15ab22647b3e1bc8e791d9a4e6bd16a9d1ed61e8", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex b088f5b4b0..ce5092a04d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -658,15 +659,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             planA.released(entry);\n             planB.released(entry);\n         }\n-\n-        @Override\n-        public void removed(Pool<T>.Entry entry)\n-        {\n-            planA.removed(entry);\n-            planB.removed(entry);\n-        }\n     }\n \n+    /**\n+     * @param <T> The type of entry the strategy is for\n+     */\n     public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n         @Override\n", "next_change": {"commit": "c18a77e8135047393ba289ca3179693b5af4ffad", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex ce5092a04d..89dd157034 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -662,7 +662,9 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * @param <T> The type of entry the strategy is for\n+     * Linear search strategy uses a fresh iterator to scan the\n+     * entries, starting at 0, until it can acquire one.\n+     * @param <T> The type of entry the strategy is for.\n      */\n     public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n", "next_change": {"commit": "feda65d15aa906a1c0689ea45b26e15a17906beb", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 89dd157034..0f18b89c08 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -661,6 +671,42 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+\n+    /**\n+     * This strategy retries a wrapped strategy looking for\n+     * and Entry\n+     * @param <T> The type of entry the strategy is for.\n+     */\n+    public static class RetryStategy<T> implements Strategy<T>\n+    {\n+        final Strategy<T> strategy;\n+        final int retries;\n+\n+        public RetryStategy(Strategy<T> strategy)\n+        {\n+            this (strategy, -1);\n+        }\n+\n+        public RetryStategy(Strategy<T> strategy, int retries)\n+        {\n+            this.strategy = strategy;\n+            this.retries = retries;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        {\n+            int tries = retries < 0 ? entries.size() : retries;\n+            while (tries-- > 0)\n+            {\n+                Pool<T>.Entry entry = strategy.tryAcquire(entries);\n+                if (entry != null)\n+                    return entry;\n+            }\n+            return null;\n+        }\n+    }\n+\n     /**\n      * Linear search strategy uses a fresh iterator to scan the\n      * entries, starting at 0, until it can acquire one.\n", "next_change": {"commit": "bf520b4d8b559c5ed8551573d780dced775bcc06", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0f18b89c08..c311021e1a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -617,481 +571,86 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /** A pluggable strategy to for pool entry lookup\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Strategy<T>\n+    public static class Linear<T> extends Pool<T>\n     {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entry The entry to be released\n-         */\n-        default void released(Pool<T>.Entry entry)\n+        public Linear(int maxEntries)\n         {\n-        }\n-    }\n-\n-    /** A Composite strategy used to combine multiple other strategies.\n-     * Typically it is used to combine an optimistic strategy (eg {@link RandomStrategy})\n-     * with an exhaustive strategy (eg {@link LinearSearchStrategy}).\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class CompositeStrategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> planA;\n-        final Strategy<T> planB;\n-\n-        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(planA);\n-            Objects.requireNonNull(planB);\n-            this.planA = planA;\n-            this.planB = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = planA.tryAcquire(entries);\n-            return entry != null ? entry : planB.tryAcquire(entries);\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            planA.released(entry);\n-            planB.released(entry);\n-        }\n-    }\n-\n-\n-    /**\n-     * This strategy retries a wrapped strategy looking for\n-     * and Entry\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RetryStategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> strategy;\n-        final int retries;\n-\n-        public RetryStategy(Strategy<T> strategy)\n-        {\n-            this (strategy, -1);\n-        }\n-\n-        public RetryStategy(Strategy<T> strategy, int retries)\n-        {\n-            this.strategy = strategy;\n-            this.retries = retries;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = retries < 0 ? entries.size() : retries;\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = strategy.tryAcquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Linear search strategy uses a fresh iterator to scan the\n-     * entries, starting at 0, until it can acquire one.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LinearSearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores a {@link ListIterator} as a {@link ThreadLocal}\n-     * which is used to scan the list of entries for one that can be acquired.\n-     * Once an entry is acquired, if the strategy is in roundrobin mode, then\n-     * it is left on the next entry, otherwise it is moved back so the current\n-     * entry will be tried again on the next acquire.\n-     * If the iterator reaches the end, then a new one is created.\n-     * The strategy will only try as many times as there are entries.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalIteratorStrategy<T> implements Strategy<T>\n-    {\n-        private final boolean roundrobin;\n-        private final ThreadLocal<ListIterator<Pool<T>.Entry>> iterator = new ThreadLocal<>();\n-\n-        public ThreadLocalIteratorStrategy()\n-        {\n-            this(false);\n-        }\n-\n-        public ThreadLocalIteratorStrategy(boolean roundrobin)\n-        {\n-            this.roundrobin = roundrobin;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            ListIterator<Pool<T>.Entry> iter = iterator.get();\n-            if (iter == null)\n-                iter = entries.listIterator();\n-\n-            for (int tries = entries.size(); tries-- > 0; )\n-            {\n-                if (!iter.hasNext())\n-                {\n-                    iter = entries.listIterator();\n-                    if (!iter.hasNext())\n-                        return null;\n-                }\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry != null && entry.tryAcquire())\n-                {\n-                    if (!roundrobin)\n-                        iter.previous();\n-                    if (iter.hasNext())\n-                        iterator.set(iter);\n-                    return entry;\n-                }\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores the last entry released by a thread as in\n-     * {@link ThreadLocal} so it can be the first tried on the next\n-     * acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalStrategy<T> implements Strategy<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalStrategy()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n+            super(maxEntries);\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        protected int startIndex(int size)\n         {\n-            last.set(entry);\n+            return 0;\n         }\n     }\n \n-    /**\n-     * This strategy stores the entries released by a thread in a bounded list\n-     * stored in a {@link ThreadLocal},  so they can be the first tried on the\n-     * next acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalListStrategy<T> implements Strategy<T>\n+    public static class Random<T> extends Pool<T>\n     {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListStrategy(int size)\n+        public Random(int maxEntries)\n         {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+            super(maxEntries);\n         }\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            if (cachedList.size() < cacheSize)\n-                cachedList.add(entry);\n+            return ThreadLocalRandom.current().nextInt(size);\n         }\n     }\n \n-    private abstract static class IndexedStrategy<T> implements Strategy<T>\n+    public static class RoundRobin<T> extends Pool<T>\n     {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (IndexOutOfBoundsException e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n+        private final AtomicInteger next = new AtomicInteger();\n \n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    /**\n-     * This strategy tries to acquire a random entry.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class RandomStrategy<T> extends IndexedStrategy<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n+        public RoundRobin(int maxEntries)\n         {\n-            return ThreadLocalRandom.current().nextInt(size);\n+            super(maxEntries);\n         }\n-    }\n \n-    public static class ThreadIdStrategy<T> extends IndexedStrategy<T>\n-    {\n         @Override\n-        protected int nextIndex(int size)\n+        protected int startIndex(int size)\n         {\n-            return (int)Thread.currentThread().getId() % size;\n+            return next.getAndUpdate(c -> ++c < size ? c : 0);\n         }\n     }\n \n-    /**\n-     * This strategy uses an {@link AtomicInteger} to remember the index\n-     * of the last acquired entry. Calls to acquire will commence trying\n-     * to acquired from the next index.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinStrategy<T> extends IndexedStrategy<T>\n+    public static class Thread<T> extends Pool<T>\n     {\n-        AtomicInteger index = new AtomicInteger();\n+        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n \n-        @Override\n-        protected int nextIndex(int size)\n+        public Thread(int maxEntries)\n         {\n-            return index.getAndUpdate(c -> ++c < size ? c : 0);\n+            super(maxEntries);\n         }\n-    }\n \n-    /**\n-     * This strategy iterates over the entries, starting from a random location,\n-     * to try to acquire an entry.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RandomIterationStrategy<T> implements Strategy<T>\n-    {\n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int r = ThreadLocalRandom.current().nextInt(size);\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(r);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= r)\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            return null;\n+            return 0;\n         }\n-    }\n-\n-    /**\n-     * This strategy commences an iteration over the entries from the\n-     * position after the last successful acquire.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinIterationStrategy<T> implements Strategy<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        public Entry acquire()\n         {\n-            int i = index.get();\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(i);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n-                    return entry;\n-                }\n-            }\n \n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= i)\n+            Entry entry = last.get();\n+            if (entry != null)\n             {\n-                Pool<T>.Entry entry = iter.next();\n                 if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n                     return entry;\n-                }\n-            }\n-\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy keeps a queue of the least recently used entry. If that queue is\n-     * empty, then this strategy falls back to a linear search.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LeastRecentlyUsedStrategy<T> extends LinearSearchStrategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    entry = super.tryAcquire(entries);\n-                else if (!entry.tryAcquire())\n-                    continue;\n-\n-                if (entry != null)\n-                    lru.add(entry);\n-                return entry;\n-            }\n-        }\n-    }\n-\n-    public static class OneStrategyToRuleThemAll<T> implements Strategy<T>\n-    {\n-        private final Mode mode;\n-        private final ThreadLocal<Integer> last;\n-        private final AtomicInteger next;\n-\n-        enum Mode\n-        {\n-            LINEAR,\n-            RANDOM,\n-            THREAD_LOCAL,\n-            ROUND_ROBIN,\n-        }\n-\n-        public OneStrategyToRuleThemAll(Mode mode)\n-        {\n-            this.mode = mode;\n-            last = mode == Mode.THREAD_LOCAL ? ThreadLocal.withInitial(()->0) : null;\n-            next = mode == Mode.ROUND_ROBIN ? new AtomicInteger() : null;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-\n-            int index;\n-            switch (mode)\n-            {\n-                case LINEAR:\n-                    index = 0;\n-                    break;\n-                case RANDOM:\n-                    index = ThreadLocalRandom.current().nextInt(size);\n-                    break;\n-                case THREAD_LOCAL:\n-                    index = last.get();\n-                    break;\n-                case ROUND_ROBIN:\n-                    index = next.getAndUpdate(c -> ++c < size ? c : 0);\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-\n-            for (int tries = size; tries-- > 0;)\n-            {\n-                try\n-                {\n-                    Pool<T>.Entry entry = entries.get(index);\n-                    if (entry != null && entry.tryAcquire())\n-                        return entry;\n-                }\n-                catch (IndexOutOfBoundsException e)\n-                {\n-                    LOGGER.ignore(e);\n-                }\n-                index = (index + 1) % size;\n+                last.set(null);\n             }\n-            return null;\n+            return super.acquire();\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        public boolean release(Entry entry)\n         {\n-            if (last != null)\n-                last.set(entry.index);\n+            boolean released =  super.release(entry);\n+            if (released)\n+                last.set(entry);\n+            return released;\n         }\n     }\n }\n", "next_change": {"commit": "db00126abd11f5734e499bb8a7ab795bc769b879", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c311021e1a..723a79fbde 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -570,87 +618,4 @@ public abstract class Pool<T> implements AutoCloseable, Dumpable\n                 pooled);\n         }\n     }\n-\n-    public static class Linear<T> extends Pool<T>\n-    {\n-        public Linear(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-    }\n-\n-    public static class Random<T> extends Pool<T>\n-    {\n-        public Random(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobin<T> extends Pool<T>\n-    {\n-        private final AtomicInteger next = new AtomicInteger();\n-\n-        public RoundRobin(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return next.getAndUpdate(c -> ++c < size ? c : 0);\n-        }\n-    }\n-\n-    public static class Thread<T> extends Pool<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n-\n-        public Thread(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-\n-        @Override\n-        public Entry acquire()\n-        {\n-\n-            Entry entry = last.get();\n-            if (entry != null)\n-            {\n-                if (entry.tryAcquire())\n-                    return entry;\n-                last.set(null);\n-            }\n-            return super.acquire();\n-        }\n-\n-        @Override\n-        public boolean release(Entry entry)\n-        {\n-            boolean released =  super.release(entry);\n-            if (released)\n-                last.set(entry);\n-            return released;\n-        }\n-    }\n }\n", "next_change": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 723a79fbde..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -603,17 +629,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            int hi = AtomicBiInteger.getHi(encoded);\n-            int lo = AtomicBiInteger.getLo(encoded);\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = hi < 0 ? \"CLOSED\" : lo == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n \n             return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n-                Math.max(hi, 0),\n-                Math.max(lo, 0),\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1MjMwNg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482052306", "body": "`LinearSearchStrategy`?", "bodyText": "LinearSearchStrategy?", "bodyHTML": "<p dir=\"auto\"><code>LinearSearchStrategy</code>?</p>", "author": "lorban", "createdAt": "2020-09-02T13:05:07Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = cache.acquire(entries);\n+            return entry == null ? strategy.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            cache.released(entries, entry, reusable);\n+            strategy.released(entries, entry, reusable);\n+        }\n+    }\n+\n+    public static class SearchStrategy<T> implements Strategy<T>", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e250a4966d93eeb9117b93c6a9030ca7537a8443", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..4b45a8e656 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -590,43 +577,71 @@ public class Pool<T> implements AutoCloseable, Dumpable\n          * Notification an entry has been release.  The notification comes after the entry\n          * has been put back in the pool and it may already have been reacquired before or during this call.\n          * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @param entry The entry to be release\n-         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         * @param entry The entry to be released\n          */\n-        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        default boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n         {\n+            return entry.tryRelease();\n         }\n-    }\n \n-    public interface Strategy<T> extends Cache<T>\n-    {\n-    }\n+        default void reserve(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            entries.add(entry);\n+        }\n+\n+        default boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            if (!entry.tryRemove())\n+            {\n+                if (LOGGER.isDebugEnabled())\n+                    LOGGER.debug(\"Attempt to remove an object from the pool that is still in use: {}\", entry);\n+                return false;\n+            }\n \n-    public static class CacheStrategy<T> implements Strategy<T>\n+            boolean removed = entries.remove(entry);\n+            if (!removed)\n+            {\n+                if (LOGGER.isDebugEnabled())\n+                    LOGGER.debug(\"Attempt to remove an object from the pool that does not exist: {}\", entry);\n+            }\n+            return removed;\n+        }\n+    }\n+    \n+    public static class CompositeStrategy<T> implements Strategy<T>\n     {\n-        final Cache<T> cache;\n-        final Strategy<T> strategy;\n+        final Strategy<T> planA;\n+        final Strategy<T> planB;\n \n-        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n         {\n-            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planA);\n             Objects.requireNonNull(planB);\n-            this.cache = cache;\n-            this.strategy = planB;\n+            this.planA = planA;\n+            this.planB = planB;\n         }\n \n         @Override\n         public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n         {\n-            Pool<T>.Entry entry = cache.acquire(entries);\n-            return entry == null ? strategy.acquire(entries) : entry;\n+            Pool<T>.Entry entry = planA.acquire(entries);\n+            return entry == null ? planB.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            if (planA.release(entries, entry))\n+                return true;\n+            if (entry.isOverUsed())\n+                return false;\n+            return planB.release(entries, entry);\n         }\n \n         @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        public boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n         {\n-            cache.released(entries, entry, reusable);\n-            strategy.released(entries, entry, reusable);\n+            return planA.remove(entries, entry) || planB.remove(entries, entry);\n         }\n     }\n \n", "next_change": {"commit": "505321687c6ad3e7bcc6e64e6d1d0b183167b419", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 4b45a8e656..b088f5b4b0 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,33 +646,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n \n         @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n-            Pool<T>.Entry entry = planA.acquire(entries);\n-            return entry == null ? planB.acquire(entries) : entry;\n+            Pool<T>.Entry entry = planA.tryAcquire(entries);\n+            return entry != null ? entry : planB.tryAcquire(entries);\n         }\n \n         @Override\n-        public boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        public void released(Pool<T>.Entry entry)\n         {\n-            if (planA.release(entries, entry))\n-                return true;\n-            if (entry.isOverUsed())\n-                return false;\n-            return planB.release(entries, entry);\n+            planA.released(entry);\n+            planB.released(entry);\n         }\n \n         @Override\n-        public boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        public void removed(Pool<T>.Entry entry)\n         {\n-            return planA.remove(entries, entry) || planB.remove(entries, entry);\n+            planA.removed(entry);\n+            planB.removed(entry);\n         }\n     }\n \n-    public static class SearchStrategy<T> implements Strategy<T>\n+    public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n         @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n             for (Pool<T>.Entry e : entries)\n             {\n", "next_change": {"commit": "15ab22647b3e1bc8e791d9a4e6bd16a9d1ed61e8", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex b088f5b4b0..ce5092a04d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -658,15 +659,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             planA.released(entry);\n             planB.released(entry);\n         }\n-\n-        @Override\n-        public void removed(Pool<T>.Entry entry)\n-        {\n-            planA.removed(entry);\n-            planB.removed(entry);\n-        }\n     }\n \n+    /**\n+     * @param <T> The type of entry the strategy is for\n+     */\n     public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n         @Override\n", "next_change": {"commit": "c18a77e8135047393ba289ca3179693b5af4ffad", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex ce5092a04d..89dd157034 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -662,7 +662,9 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * @param <T> The type of entry the strategy is for\n+     * Linear search strategy uses a fresh iterator to scan the\n+     * entries, starting at 0, until it can acquire one.\n+     * @param <T> The type of entry the strategy is for.\n      */\n     public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n", "next_change": {"commit": "feda65d15aa906a1c0689ea45b26e15a17906beb", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 89dd157034..0f18b89c08 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -661,6 +671,42 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+\n+    /**\n+     * This strategy retries a wrapped strategy looking for\n+     * and Entry\n+     * @param <T> The type of entry the strategy is for.\n+     */\n+    public static class RetryStategy<T> implements Strategy<T>\n+    {\n+        final Strategy<T> strategy;\n+        final int retries;\n+\n+        public RetryStategy(Strategy<T> strategy)\n+        {\n+            this (strategy, -1);\n+        }\n+\n+        public RetryStategy(Strategy<T> strategy, int retries)\n+        {\n+            this.strategy = strategy;\n+            this.retries = retries;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        {\n+            int tries = retries < 0 ? entries.size() : retries;\n+            while (tries-- > 0)\n+            {\n+                Pool<T>.Entry entry = strategy.tryAcquire(entries);\n+                if (entry != null)\n+                    return entry;\n+            }\n+            return null;\n+        }\n+    }\n+\n     /**\n      * Linear search strategy uses a fresh iterator to scan the\n      * entries, starting at 0, until it can acquire one.\n", "next_change": {"commit": "bf520b4d8b559c5ed8551573d780dced775bcc06", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0f18b89c08..c311021e1a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -617,481 +571,86 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /** A pluggable strategy to for pool entry lookup\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Strategy<T>\n+    public static class Linear<T> extends Pool<T>\n     {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entry The entry to be released\n-         */\n-        default void released(Pool<T>.Entry entry)\n+        public Linear(int maxEntries)\n         {\n-        }\n-    }\n-\n-    /** A Composite strategy used to combine multiple other strategies.\n-     * Typically it is used to combine an optimistic strategy (eg {@link RandomStrategy})\n-     * with an exhaustive strategy (eg {@link LinearSearchStrategy}).\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class CompositeStrategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> planA;\n-        final Strategy<T> planB;\n-\n-        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(planA);\n-            Objects.requireNonNull(planB);\n-            this.planA = planA;\n-            this.planB = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = planA.tryAcquire(entries);\n-            return entry != null ? entry : planB.tryAcquire(entries);\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            planA.released(entry);\n-            planB.released(entry);\n-        }\n-    }\n-\n-\n-    /**\n-     * This strategy retries a wrapped strategy looking for\n-     * and Entry\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RetryStategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> strategy;\n-        final int retries;\n-\n-        public RetryStategy(Strategy<T> strategy)\n-        {\n-            this (strategy, -1);\n-        }\n-\n-        public RetryStategy(Strategy<T> strategy, int retries)\n-        {\n-            this.strategy = strategy;\n-            this.retries = retries;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = retries < 0 ? entries.size() : retries;\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = strategy.tryAcquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Linear search strategy uses a fresh iterator to scan the\n-     * entries, starting at 0, until it can acquire one.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LinearSearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores a {@link ListIterator} as a {@link ThreadLocal}\n-     * which is used to scan the list of entries for one that can be acquired.\n-     * Once an entry is acquired, if the strategy is in roundrobin mode, then\n-     * it is left on the next entry, otherwise it is moved back so the current\n-     * entry will be tried again on the next acquire.\n-     * If the iterator reaches the end, then a new one is created.\n-     * The strategy will only try as many times as there are entries.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalIteratorStrategy<T> implements Strategy<T>\n-    {\n-        private final boolean roundrobin;\n-        private final ThreadLocal<ListIterator<Pool<T>.Entry>> iterator = new ThreadLocal<>();\n-\n-        public ThreadLocalIteratorStrategy()\n-        {\n-            this(false);\n-        }\n-\n-        public ThreadLocalIteratorStrategy(boolean roundrobin)\n-        {\n-            this.roundrobin = roundrobin;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            ListIterator<Pool<T>.Entry> iter = iterator.get();\n-            if (iter == null)\n-                iter = entries.listIterator();\n-\n-            for (int tries = entries.size(); tries-- > 0; )\n-            {\n-                if (!iter.hasNext())\n-                {\n-                    iter = entries.listIterator();\n-                    if (!iter.hasNext())\n-                        return null;\n-                }\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry != null && entry.tryAcquire())\n-                {\n-                    if (!roundrobin)\n-                        iter.previous();\n-                    if (iter.hasNext())\n-                        iterator.set(iter);\n-                    return entry;\n-                }\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores the last entry released by a thread as in\n-     * {@link ThreadLocal} so it can be the first tried on the next\n-     * acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalStrategy<T> implements Strategy<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalStrategy()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n+            super(maxEntries);\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        protected int startIndex(int size)\n         {\n-            last.set(entry);\n+            return 0;\n         }\n     }\n \n-    /**\n-     * This strategy stores the entries released by a thread in a bounded list\n-     * stored in a {@link ThreadLocal},  so they can be the first tried on the\n-     * next acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalListStrategy<T> implements Strategy<T>\n+    public static class Random<T> extends Pool<T>\n     {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListStrategy(int size)\n+        public Random(int maxEntries)\n         {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+            super(maxEntries);\n         }\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            if (cachedList.size() < cacheSize)\n-                cachedList.add(entry);\n+            return ThreadLocalRandom.current().nextInt(size);\n         }\n     }\n \n-    private abstract static class IndexedStrategy<T> implements Strategy<T>\n+    public static class RoundRobin<T> extends Pool<T>\n     {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (IndexOutOfBoundsException e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n+        private final AtomicInteger next = new AtomicInteger();\n \n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    /**\n-     * This strategy tries to acquire a random entry.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class RandomStrategy<T> extends IndexedStrategy<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n+        public RoundRobin(int maxEntries)\n         {\n-            return ThreadLocalRandom.current().nextInt(size);\n+            super(maxEntries);\n         }\n-    }\n \n-    public static class ThreadIdStrategy<T> extends IndexedStrategy<T>\n-    {\n         @Override\n-        protected int nextIndex(int size)\n+        protected int startIndex(int size)\n         {\n-            return (int)Thread.currentThread().getId() % size;\n+            return next.getAndUpdate(c -> ++c < size ? c : 0);\n         }\n     }\n \n-    /**\n-     * This strategy uses an {@link AtomicInteger} to remember the index\n-     * of the last acquired entry. Calls to acquire will commence trying\n-     * to acquired from the next index.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinStrategy<T> extends IndexedStrategy<T>\n+    public static class Thread<T> extends Pool<T>\n     {\n-        AtomicInteger index = new AtomicInteger();\n+        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n \n-        @Override\n-        protected int nextIndex(int size)\n+        public Thread(int maxEntries)\n         {\n-            return index.getAndUpdate(c -> ++c < size ? c : 0);\n+            super(maxEntries);\n         }\n-    }\n \n-    /**\n-     * This strategy iterates over the entries, starting from a random location,\n-     * to try to acquire an entry.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RandomIterationStrategy<T> implements Strategy<T>\n-    {\n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int r = ThreadLocalRandom.current().nextInt(size);\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(r);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= r)\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            return null;\n+            return 0;\n         }\n-    }\n-\n-    /**\n-     * This strategy commences an iteration over the entries from the\n-     * position after the last successful acquire.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinIterationStrategy<T> implements Strategy<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        public Entry acquire()\n         {\n-            int i = index.get();\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(i);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n-                    return entry;\n-                }\n-            }\n \n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= i)\n+            Entry entry = last.get();\n+            if (entry != null)\n             {\n-                Pool<T>.Entry entry = iter.next();\n                 if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n                     return entry;\n-                }\n-            }\n-\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy keeps a queue of the least recently used entry. If that queue is\n-     * empty, then this strategy falls back to a linear search.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LeastRecentlyUsedStrategy<T> extends LinearSearchStrategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    entry = super.tryAcquire(entries);\n-                else if (!entry.tryAcquire())\n-                    continue;\n-\n-                if (entry != null)\n-                    lru.add(entry);\n-                return entry;\n-            }\n-        }\n-    }\n-\n-    public static class OneStrategyToRuleThemAll<T> implements Strategy<T>\n-    {\n-        private final Mode mode;\n-        private final ThreadLocal<Integer> last;\n-        private final AtomicInteger next;\n-\n-        enum Mode\n-        {\n-            LINEAR,\n-            RANDOM,\n-            THREAD_LOCAL,\n-            ROUND_ROBIN,\n-        }\n-\n-        public OneStrategyToRuleThemAll(Mode mode)\n-        {\n-            this.mode = mode;\n-            last = mode == Mode.THREAD_LOCAL ? ThreadLocal.withInitial(()->0) : null;\n-            next = mode == Mode.ROUND_ROBIN ? new AtomicInteger() : null;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-\n-            int index;\n-            switch (mode)\n-            {\n-                case LINEAR:\n-                    index = 0;\n-                    break;\n-                case RANDOM:\n-                    index = ThreadLocalRandom.current().nextInt(size);\n-                    break;\n-                case THREAD_LOCAL:\n-                    index = last.get();\n-                    break;\n-                case ROUND_ROBIN:\n-                    index = next.getAndUpdate(c -> ++c < size ? c : 0);\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-\n-            for (int tries = size; tries-- > 0;)\n-            {\n-                try\n-                {\n-                    Pool<T>.Entry entry = entries.get(index);\n-                    if (entry != null && entry.tryAcquire())\n-                        return entry;\n-                }\n-                catch (IndexOutOfBoundsException e)\n-                {\n-                    LOGGER.ignore(e);\n-                }\n-                index = (index + 1) % size;\n+                last.set(null);\n             }\n-            return null;\n+            return super.acquire();\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        public boolean release(Entry entry)\n         {\n-            if (last != null)\n-                last.set(entry.index);\n+            boolean released =  super.release(entry);\n+            if (released)\n+                last.set(entry);\n+            return released;\n         }\n     }\n }\n", "next_change": {"commit": "db00126abd11f5734e499bb8a7ab795bc769b879", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c311021e1a..723a79fbde 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -570,87 +618,4 @@ public abstract class Pool<T> implements AutoCloseable, Dumpable\n                 pooled);\n         }\n     }\n-\n-    public static class Linear<T> extends Pool<T>\n-    {\n-        public Linear(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-    }\n-\n-    public static class Random<T> extends Pool<T>\n-    {\n-        public Random(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobin<T> extends Pool<T>\n-    {\n-        private final AtomicInteger next = new AtomicInteger();\n-\n-        public RoundRobin(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return next.getAndUpdate(c -> ++c < size ? c : 0);\n-        }\n-    }\n-\n-    public static class Thread<T> extends Pool<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n-\n-        public Thread(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-\n-        @Override\n-        public Entry acquire()\n-        {\n-\n-            Entry entry = last.get();\n-            if (entry != null)\n-            {\n-                if (entry.tryAcquire())\n-                    return entry;\n-                last.set(null);\n-            }\n-            return super.acquire();\n-        }\n-\n-        @Override\n-        public boolean release(Entry entry)\n-        {\n-            boolean released =  super.release(entry);\n-            if (released)\n-                last.set(entry);\n-            return released;\n-        }\n-    }\n }\n", "next_change": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 723a79fbde..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -603,17 +629,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            int hi = AtomicBiInteger.getHi(encoded);\n-            int lo = AtomicBiInteger.getLo(encoded);\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = hi < 0 ? \"CLOSED\" : lo == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n \n             return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n-                Math.max(hi, 0),\n-                Math.max(lo, 0),\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1Mjc1MA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482052750", "body": "`private final`?", "bodyText": "private final?", "bodyHTML": "<p dir=\"auto\"><code>private final</code>?</p>", "author": "lorban", "createdAt": "2020-09-02T13:05:49Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = cache.acquire(entries);\n+            return entry == null ? strategy.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            cache.released(entries, entry, reusable);\n+            strategy.released(entries, entry, reusable);\n+        }\n+    }\n+\n+    public static class SearchStrategy<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            for (Pool<T>.Entry e : entries)\n+            {\n+                if (e.tryAcquire())\n+                    return e;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class ThreadLocalCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<Pool<T>.Entry> last;\n+\n+        ThreadLocalCache()\n+        {\n+            last = new ThreadLocal<>();\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = last.get();\n+            if (entry != null && entry.tryAcquire())\n+                return entry;\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+                last.set(entry);\n+        }\n+    }\n+\n+    public static class ThreadLocalListCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n+        private final int cacheSize;\n+\n+        ThreadLocalListCache(int size)\n+        {\n+            this.cacheSize = size;\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            List<Pool<T>.Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+            {\n+                List<Pool<T>.Entry> cachedList = cache.get();\n+                if (cachedList.size() < cacheSize)\n+                    cachedList.add(entry);\n+            }\n+        }\n+    }\n+\n+    private abstract static class IndexedCached<T> implements Cache<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            int size = entries.size();\n+            if (size == 0)\n+                return null;\n+            int i = nextIndex(size);\n+            try\n+            {\n+                Pool<T>.Entry entry = entries.get(i);\n+                if (entry != null && entry.tryAcquire())\n+                    return entry;\n+            }\n+            catch (Exception e)\n+            {\n+                // Could be out of bounds\n+                LOGGER.ignore(e);\n+            }\n+            return null;\n+        }\n+\n+        protected abstract int nextIndex(int size);\n+    }\n+\n+    public static class RandomCache<T> extends IndexedCached<T>\n+    {\n+        @Override\n+        protected int nextIndex(int size)\n+        {\n+            return ThreadLocalRandom.current().nextInt(size);\n+        }\n+    }\n+\n+    public static class RoundRobinCache<T> extends IndexedCached<T>\n+    {\n+        AtomicInteger index = new AtomicInteger();", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e250a4966d93eeb9117b93c6a9030ca7537a8443", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..4b45a8e656 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -741,7 +762,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    public static class RoundRobinCache<T> extends IndexedCached<T>\n+    public static class RoundRobinStrategy<T> extends IndexedCached<T>\n     {\n         AtomicInteger index = new AtomicInteger();\n \n", "next_change": {"commit": "505321687c6ad3e7bcc6e64e6d1d0b183167b419", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 4b45a8e656..b088f5b4b0 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -762,7 +820,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    public static class RoundRobinStrategy<T> extends IndexedCached<T>\n+    public static class RoundRobinStrategy<T> extends IndexedStrategy<T>\n     {\n         AtomicInteger index = new AtomicInteger();\n \n", "next_change": {"commit": "15ab22647b3e1bc8e791d9a4e6bd16a9d1ed61e8", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex b088f5b4b0..ce5092a04d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -820,6 +829,9 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * @param <T> The type of entry the strategy is for\n+     */\n     public static class RoundRobinStrategy<T> extends IndexedStrategy<T>\n     {\n         AtomicInteger index = new AtomicInteger();\n", "next_change": {"commit": "c18a77e8135047393ba289ca3179693b5af4ffad", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex ce5092a04d..89dd157034 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -830,7 +852,10 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * @param <T> The type of entry the strategy is for\n+     * This strategy uses an {@link AtomicInteger} to remember the index\n+     * of the last acquired entry. Calls to acquire will commence trying\n+     * to acquired from the next index.\n+     * @param <T> The type of entry the strategy is for.\n      */\n     public static class RoundRobinStrategy<T> extends IndexedStrategy<T>\n     {\n", "next_change": {"commit": "feda65d15aa906a1c0689ea45b26e15a17906beb", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 89dd157034..0f18b89c08 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -864,20 +917,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         @Override\n         protected int nextIndex(int size)\n         {\n-            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = entries.size();\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = super.tryAcquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n+            return index.getAndUpdate(c -> ++c < size ? c : 0);\n         }\n     }\n \n", "next_change": {"commit": "bf520b4d8b559c5ed8551573d780dced775bcc06", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0f18b89c08..c311021e1a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -617,481 +571,86 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /** A pluggable strategy to for pool entry lookup\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Strategy<T>\n+    public static class Linear<T> extends Pool<T>\n     {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entry The entry to be released\n-         */\n-        default void released(Pool<T>.Entry entry)\n+        public Linear(int maxEntries)\n         {\n-        }\n-    }\n-\n-    /** A Composite strategy used to combine multiple other strategies.\n-     * Typically it is used to combine an optimistic strategy (eg {@link RandomStrategy})\n-     * with an exhaustive strategy (eg {@link LinearSearchStrategy}).\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class CompositeStrategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> planA;\n-        final Strategy<T> planB;\n-\n-        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(planA);\n-            Objects.requireNonNull(planB);\n-            this.planA = planA;\n-            this.planB = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = planA.tryAcquire(entries);\n-            return entry != null ? entry : planB.tryAcquire(entries);\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            planA.released(entry);\n-            planB.released(entry);\n-        }\n-    }\n-\n-\n-    /**\n-     * This strategy retries a wrapped strategy looking for\n-     * and Entry\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RetryStategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> strategy;\n-        final int retries;\n-\n-        public RetryStategy(Strategy<T> strategy)\n-        {\n-            this (strategy, -1);\n-        }\n-\n-        public RetryStategy(Strategy<T> strategy, int retries)\n-        {\n-            this.strategy = strategy;\n-            this.retries = retries;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = retries < 0 ? entries.size() : retries;\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = strategy.tryAcquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Linear search strategy uses a fresh iterator to scan the\n-     * entries, starting at 0, until it can acquire one.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LinearSearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores a {@link ListIterator} as a {@link ThreadLocal}\n-     * which is used to scan the list of entries for one that can be acquired.\n-     * Once an entry is acquired, if the strategy is in roundrobin mode, then\n-     * it is left on the next entry, otherwise it is moved back so the current\n-     * entry will be tried again on the next acquire.\n-     * If the iterator reaches the end, then a new one is created.\n-     * The strategy will only try as many times as there are entries.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalIteratorStrategy<T> implements Strategy<T>\n-    {\n-        private final boolean roundrobin;\n-        private final ThreadLocal<ListIterator<Pool<T>.Entry>> iterator = new ThreadLocal<>();\n-\n-        public ThreadLocalIteratorStrategy()\n-        {\n-            this(false);\n-        }\n-\n-        public ThreadLocalIteratorStrategy(boolean roundrobin)\n-        {\n-            this.roundrobin = roundrobin;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            ListIterator<Pool<T>.Entry> iter = iterator.get();\n-            if (iter == null)\n-                iter = entries.listIterator();\n-\n-            for (int tries = entries.size(); tries-- > 0; )\n-            {\n-                if (!iter.hasNext())\n-                {\n-                    iter = entries.listIterator();\n-                    if (!iter.hasNext())\n-                        return null;\n-                }\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry != null && entry.tryAcquire())\n-                {\n-                    if (!roundrobin)\n-                        iter.previous();\n-                    if (iter.hasNext())\n-                        iterator.set(iter);\n-                    return entry;\n-                }\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores the last entry released by a thread as in\n-     * {@link ThreadLocal} so it can be the first tried on the next\n-     * acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalStrategy<T> implements Strategy<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalStrategy()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n+            super(maxEntries);\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        protected int startIndex(int size)\n         {\n-            last.set(entry);\n+            return 0;\n         }\n     }\n \n-    /**\n-     * This strategy stores the entries released by a thread in a bounded list\n-     * stored in a {@link ThreadLocal},  so they can be the first tried on the\n-     * next acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalListStrategy<T> implements Strategy<T>\n+    public static class Random<T> extends Pool<T>\n     {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListStrategy(int size)\n+        public Random(int maxEntries)\n         {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+            super(maxEntries);\n         }\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            if (cachedList.size() < cacheSize)\n-                cachedList.add(entry);\n+            return ThreadLocalRandom.current().nextInt(size);\n         }\n     }\n \n-    private abstract static class IndexedStrategy<T> implements Strategy<T>\n+    public static class RoundRobin<T> extends Pool<T>\n     {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (IndexOutOfBoundsException e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n+        private final AtomicInteger next = new AtomicInteger();\n \n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    /**\n-     * This strategy tries to acquire a random entry.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class RandomStrategy<T> extends IndexedStrategy<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n+        public RoundRobin(int maxEntries)\n         {\n-            return ThreadLocalRandom.current().nextInt(size);\n+            super(maxEntries);\n         }\n-    }\n \n-    public static class ThreadIdStrategy<T> extends IndexedStrategy<T>\n-    {\n         @Override\n-        protected int nextIndex(int size)\n+        protected int startIndex(int size)\n         {\n-            return (int)Thread.currentThread().getId() % size;\n+            return next.getAndUpdate(c -> ++c < size ? c : 0);\n         }\n     }\n \n-    /**\n-     * This strategy uses an {@link AtomicInteger} to remember the index\n-     * of the last acquired entry. Calls to acquire will commence trying\n-     * to acquired from the next index.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinStrategy<T> extends IndexedStrategy<T>\n+    public static class Thread<T> extends Pool<T>\n     {\n-        AtomicInteger index = new AtomicInteger();\n+        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n \n-        @Override\n-        protected int nextIndex(int size)\n+        public Thread(int maxEntries)\n         {\n-            return index.getAndUpdate(c -> ++c < size ? c : 0);\n+            super(maxEntries);\n         }\n-    }\n \n-    /**\n-     * This strategy iterates over the entries, starting from a random location,\n-     * to try to acquire an entry.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RandomIterationStrategy<T> implements Strategy<T>\n-    {\n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int r = ThreadLocalRandom.current().nextInt(size);\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(r);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= r)\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            return null;\n+            return 0;\n         }\n-    }\n-\n-    /**\n-     * This strategy commences an iteration over the entries from the\n-     * position after the last successful acquire.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinIterationStrategy<T> implements Strategy<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        public Entry acquire()\n         {\n-            int i = index.get();\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(i);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n-                    return entry;\n-                }\n-            }\n \n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= i)\n+            Entry entry = last.get();\n+            if (entry != null)\n             {\n-                Pool<T>.Entry entry = iter.next();\n                 if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n                     return entry;\n-                }\n-            }\n-\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy keeps a queue of the least recently used entry. If that queue is\n-     * empty, then this strategy falls back to a linear search.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LeastRecentlyUsedStrategy<T> extends LinearSearchStrategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    entry = super.tryAcquire(entries);\n-                else if (!entry.tryAcquire())\n-                    continue;\n-\n-                if (entry != null)\n-                    lru.add(entry);\n-                return entry;\n-            }\n-        }\n-    }\n-\n-    public static class OneStrategyToRuleThemAll<T> implements Strategy<T>\n-    {\n-        private final Mode mode;\n-        private final ThreadLocal<Integer> last;\n-        private final AtomicInteger next;\n-\n-        enum Mode\n-        {\n-            LINEAR,\n-            RANDOM,\n-            THREAD_LOCAL,\n-            ROUND_ROBIN,\n-        }\n-\n-        public OneStrategyToRuleThemAll(Mode mode)\n-        {\n-            this.mode = mode;\n-            last = mode == Mode.THREAD_LOCAL ? ThreadLocal.withInitial(()->0) : null;\n-            next = mode == Mode.ROUND_ROBIN ? new AtomicInteger() : null;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-\n-            int index;\n-            switch (mode)\n-            {\n-                case LINEAR:\n-                    index = 0;\n-                    break;\n-                case RANDOM:\n-                    index = ThreadLocalRandom.current().nextInt(size);\n-                    break;\n-                case THREAD_LOCAL:\n-                    index = last.get();\n-                    break;\n-                case ROUND_ROBIN:\n-                    index = next.getAndUpdate(c -> ++c < size ? c : 0);\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-\n-            for (int tries = size; tries-- > 0;)\n-            {\n-                try\n-                {\n-                    Pool<T>.Entry entry = entries.get(index);\n-                    if (entry != null && entry.tryAcquire())\n-                        return entry;\n-                }\n-                catch (IndexOutOfBoundsException e)\n-                {\n-                    LOGGER.ignore(e);\n-                }\n-                index = (index + 1) % size;\n+                last.set(null);\n             }\n-            return null;\n+            return super.acquire();\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        public boolean release(Entry entry)\n         {\n-            if (last != null)\n-                last.set(entry.index);\n+            boolean released =  super.release(entry);\n+            if (released)\n+                last.set(entry);\n+            return released;\n         }\n     }\n }\n", "next_change": {"commit": "db00126abd11f5734e499bb8a7ab795bc769b879", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c311021e1a..723a79fbde 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -570,87 +618,4 @@ public abstract class Pool<T> implements AutoCloseable, Dumpable\n                 pooled);\n         }\n     }\n-\n-    public static class Linear<T> extends Pool<T>\n-    {\n-        public Linear(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-    }\n-\n-    public static class Random<T> extends Pool<T>\n-    {\n-        public Random(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobin<T> extends Pool<T>\n-    {\n-        private final AtomicInteger next = new AtomicInteger();\n-\n-        public RoundRobin(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return next.getAndUpdate(c -> ++c < size ? c : 0);\n-        }\n-    }\n-\n-    public static class Thread<T> extends Pool<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n-\n-        public Thread(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-\n-        @Override\n-        public Entry acquire()\n-        {\n-\n-            Entry entry = last.get();\n-            if (entry != null)\n-            {\n-                if (entry.tryAcquire())\n-                    return entry;\n-                last.set(null);\n-            }\n-            return super.acquire();\n-        }\n-\n-        @Override\n-        public boolean release(Entry entry)\n-        {\n-            boolean released =  super.release(entry);\n-            if (released)\n-                last.set(entry);\n-            return released;\n-        }\n-    }\n }\n", "next_change": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 723a79fbde..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -603,17 +629,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            int hi = AtomicBiInteger.getHi(encoded);\n-            int lo = AtomicBiInteger.getLo(encoded);\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = hi < 0 ? \"CLOSED\" : lo == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n \n             return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n-                Math.max(hi, 0),\n-                Math.max(lo, 0),\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1MzAwOQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482053009", "body": "do we want to keep this strategy?", "bodyText": "do we want to keep this strategy?", "bodyHTML": "<p dir=\"auto\">do we want to keep this strategy?</p>", "author": "lorban", "createdAt": "2020-09-02T13:06:13Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = cache.acquire(entries);\n+            return entry == null ? strategy.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            cache.released(entries, entry, reusable);\n+            strategy.released(entries, entry, reusable);\n+        }\n+    }\n+\n+    public static class SearchStrategy<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            for (Pool<T>.Entry e : entries)\n+            {\n+                if (e.tryAcquire())\n+                    return e;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class ThreadLocalCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<Pool<T>.Entry> last;\n+\n+        ThreadLocalCache()\n+        {\n+            last = new ThreadLocal<>();\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = last.get();\n+            if (entry != null && entry.tryAcquire())\n+                return entry;\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+                last.set(entry);\n+        }\n+    }\n+\n+    public static class ThreadLocalListCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n+        private final int cacheSize;\n+\n+        ThreadLocalListCache(int size)\n+        {\n+            this.cacheSize = size;\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            List<Pool<T>.Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+            {\n+                List<Pool<T>.Entry> cachedList = cache.get();\n+                if (cachedList.size() < cacheSize)\n+                    cachedList.add(entry);\n+            }\n+        }\n+    }\n+\n+    private abstract static class IndexedCached<T> implements Cache<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            int size = entries.size();\n+            if (size == 0)\n+                return null;\n+            int i = nextIndex(size);\n+            try\n+            {\n+                Pool<T>.Entry entry = entries.get(i);\n+                if (entry != null && entry.tryAcquire())\n+                    return entry;\n+            }\n+            catch (Exception e)\n+            {\n+                // Could be out of bounds\n+                LOGGER.ignore(e);\n+            }\n+            return null;\n+        }\n+\n+        protected abstract int nextIndex(int size);\n+    }\n+\n+    public static class RandomCache<T> extends IndexedCached<T>\n+    {\n+        @Override\n+        protected int nextIndex(int size)\n+        {\n+            return ThreadLocalRandom.current().nextInt(size);\n+        }\n+    }\n+\n+    public static class RoundRobinCache<T> extends IndexedCached<T>\n+    {\n+        AtomicInteger index = new AtomicInteger();\n+\n+        @Override\n+        protected int nextIndex(int size)\n+        {\n+            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n+        }\n+    }\n+\n+    public static class RoundRobinStrategy<T> extends RoundRobinCache<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            int tries = entries.size();\n+            while (tries-- > 0)\n+            {\n+                Pool<T>.Entry entry = super.acquire(entries);\n+                if (entry != null)\n+                    return entry;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class LeastRecentlyUsedStrategy<T> implements Strategy<T>", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxMDA5NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482310095", "bodyText": "I'll keep for now to test API during dev... but don't think we should include it in final merge... actually I might move it to a test to check that an external strategy can be applied without access to protected methods", "author": "gregw", "createdAt": "2020-09-02T18:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1MzAwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "505321687c6ad3e7bcc6e64e6d1d0b183167b419", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..b088f5b4b0 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -750,17 +829,14 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         {\n             return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n         }\n-    }\n \n-    public static class RoundRobinStrategy<T> extends RoundRobinCache<T> implements Strategy<T>\n-    {\n         @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n             int tries = entries.size();\n             while (tries-- > 0)\n             {\n-                Pool<T>.Entry entry = super.acquire(entries);\n+                Pool<T>.Entry entry = super.tryAcquire(entries);\n                 if (entry != null)\n                     return entry;\n             }\n", "next_change": {"commit": "15ab22647b3e1bc8e791d9a4e6bd16a9d1ed61e8", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex b088f5b4b0..ce5092a04d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -844,12 +856,18 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * @param <T> The type of entry the strategy is for\n+     */\n     public static class RandomIterationStrategy<T> implements Strategy<T>\n     {\n         @Override\n         public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n-            int r = ThreadLocalRandom.current().nextInt(entries.size());\n+            int size = entries.size();\n+            if (size == 0)\n+                return null;\n+            int r = ThreadLocalRandom.current().nextInt(size);\n \n             ListIterator<Pool<T>.Entry> iter = entries.listIterator(r);\n             while (iter.hasNext())\n", "next_change": {"commit": "bf520b4d8b559c5ed8551573d780dced775bcc06", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex ce5092a04d..c311021e1a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -596,359 +555,102 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n+            int hi = AtomicBiInteger.getHi(encoded);\n+            int lo = AtomicBiInteger.getLo(encoded);\n+\n+            String state = hi < 0 ? \"CLOSED\" : lo == 0 ? \"IDLE\" : \"INUSE\";\n+\n+            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n+                state,\n+                Math.max(hi, 0),\n+                Math.max(lo, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n     }\n \n-    /** A pluggable strategy to for pool entry lookup\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Strategy<T>\n-    {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entry The entry to be released\n-         */\n-        default void released(Pool<T>.Entry entry)\n-        {\n-        }\n-    }\n-\n-    /** A Composite strategy used to combine multiple other strategies.\n-     * Typically it is used to combine an optimistic strategy (eg {@link RandomStrategy})\n-     * with an exhaustive strategy (eg {@link LinearSearchStrategy}).\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class CompositeStrategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> planA;\n-        final Strategy<T> planB;\n-\n-        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(planA);\n-            Objects.requireNonNull(planB);\n-            this.planA = planA;\n-            this.planB = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = planA.tryAcquire(entries);\n-            return entry != null ? entry : planB.tryAcquire(entries);\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            planA.released(entry);\n-            planB.released(entry);\n-        }\n-    }\n-\n-    /**\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class LinearSearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class ThreadLocalIteratorStrategy<T> implements Strategy<T>\n+    public static class Linear<T> extends Pool<T>\n     {\n-        private final boolean roundrobin;\n-        private final ThreadLocal<ListIterator<Pool<T>.Entry>> iterator = new ThreadLocal<>();\n-\n-        public ThreadLocalIteratorStrategy()\n-        {\n-            this(false);\n-        }\n-\n-        public ThreadLocalIteratorStrategy(boolean roundrobin)\n+        public Linear(int maxEntries)\n         {\n-            this.roundrobin = roundrobin;\n+            super(maxEntries);\n         }\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            ListIterator<Pool<T>.Entry> iter = iterator.get();\n-            if (iter == null)\n-                iter = entries.listIterator();\n-\n-            for (int tries = entries.size(); tries-- > 0; )\n-            {\n-                if (!iter.hasNext())\n-                {\n-                    iter = entries.listIterator();\n-                    if (!iter.hasNext())\n-                        return null;\n-                }\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry != null && entry.tryAcquire())\n-                {\n-                    if (iter.hasNext())\n-                    {\n-                        if (!roundrobin)\n-                            iter.previous();\n-                        iterator.set(iter);\n-                    }\n-                    return entry;\n-                }\n-            }\n-            return null;\n+            return 0;\n         }\n     }\n \n-    /**\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class ThreadLocalStrategy<T> implements Strategy<T>\n+    public static class Random<T> extends Pool<T>\n     {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalStrategy()\n+        public Random(int maxEntries)\n         {\n-            last = new ThreadLocal<>();\n+            super(maxEntries);\n         }\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            last.set(entry);\n+            return ThreadLocalRandom.current().nextInt(size);\n         }\n     }\n \n-    /**\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class ThreadLocalListStrategy<T> implements Strategy<T>\n+    public static class RoundRobin<T> extends Pool<T>\n     {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListStrategy(int size)\n-        {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n+        private final AtomicInteger next = new AtomicInteger();\n \n-        @Override\n-        public void released(Pool<T>.Entry entry)\n+        public RoundRobin(int maxEntries)\n         {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            if (cachedList.size() < cacheSize)\n-                cachedList.add(entry);\n-        }\n-    }\n-\n-    private abstract static class IndexedStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (Exception e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n+            super(maxEntries);\n         }\n \n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    /**\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class RandomStrategy<T> extends IndexedStrategy<T>\n-    {\n         @Override\n-        protected int nextIndex(int size)\n+        protected int startIndex(int size)\n         {\n-            return ThreadLocalRandom.current().nextInt(size);\n+            return next.getAndUpdate(c -> ++c < size ? c : 0);\n         }\n     }\n \n-    /**\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class RoundRobinStrategy<T> extends IndexedStrategy<T>\n+    public static class Thread<T> extends Pool<T>\n     {\n-        AtomicInteger index = new AtomicInteger();\n+        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n \n-        @Override\n-        protected int nextIndex(int size)\n+        public Thread(int maxEntries)\n         {\n-            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = entries.size();\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = super.tryAcquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n+            super(maxEntries);\n         }\n-    }\n \n-    /**\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class RandomIterationStrategy<T> implements Strategy<T>\n-    {\n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int r = ThreadLocalRandom.current().nextInt(size);\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(r);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() != r)\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            return null;\n+            return 0;\n         }\n-    }\n-\n-    /**\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class RoundRobinIterationStrategy<T> implements Strategy<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        public Entry acquire()\n         {\n-            int i = index.get();\n \n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(i);\n-            while (iter.hasNext())\n+            Entry entry = last.get();\n+            if (entry != null)\n             {\n-                Pool<T>.Entry entry = iter.next();\n                 if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n                     return entry;\n-                }\n-            }\n-\n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() != i)\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n-                    return entry;\n-                }\n+                last.set(null);\n             }\n-\n-            return null;\n+            return super.acquire();\n         }\n-    }\n-\n-    /**\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class LeastRecentlyUsedStrategy<T> extends LinearSearchStrategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        public boolean release(Entry entry)\n         {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    entry = super.tryAcquire(entries);\n-                else if (!entry.tryAcquire())\n-                    continue;\n-\n-                if (entry != null)\n-                    lru.add(entry);\n-                return entry;\n-            }\n+            boolean released =  super.release(entry);\n+            if (released)\n+                last.set(entry);\n+            return released;\n         }\n     }\n }\n", "next_change": {"commit": "db00126abd11f5734e499bb8a7ab795bc769b879", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c311021e1a..723a79fbde 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -570,87 +618,4 @@ public abstract class Pool<T> implements AutoCloseable, Dumpable\n                 pooled);\n         }\n     }\n-\n-    public static class Linear<T> extends Pool<T>\n-    {\n-        public Linear(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-    }\n-\n-    public static class Random<T> extends Pool<T>\n-    {\n-        public Random(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobin<T> extends Pool<T>\n-    {\n-        private final AtomicInteger next = new AtomicInteger();\n-\n-        public RoundRobin(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return next.getAndUpdate(c -> ++c < size ? c : 0);\n-        }\n-    }\n-\n-    public static class Thread<T> extends Pool<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n-\n-        public Thread(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-\n-        @Override\n-        public Entry acquire()\n-        {\n-\n-            Entry entry = last.get();\n-            if (entry != null)\n-            {\n-                if (entry.tryAcquire())\n-                    return entry;\n-                last.set(null);\n-            }\n-            return super.acquire();\n-        }\n-\n-        @Override\n-        public boolean release(Entry entry)\n-        {\n-            boolean released =  super.release(entry);\n-            if (released)\n-                last.set(entry);\n-            return released;\n-        }\n-    }\n }\n", "next_change": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 723a79fbde..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -603,17 +629,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            int hi = AtomicBiInteger.getHi(encoded);\n-            int lo = AtomicBiInteger.getLo(encoded);\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = hi < 0 ? \"CLOSED\" : lo == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n \n             return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n-                Math.max(hi, 0),\n-                Math.max(lo, 0),\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..b088f5b4b0 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -768,12 +844,74 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    public static class RandomIterationStrategy<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        {\n+            int r = ThreadLocalRandom.current().nextInt(entries.size());\n+\n+            ListIterator<Pool<T>.Entry> iter = entries.listIterator(r);\n+            while (iter.hasNext())\n+            {\n+                Pool<T>.Entry entry = iter.next();\n+                if (entry.tryAcquire())\n+                    return entry;\n+            }\n+\n+            iter = entries.listIterator();\n+            while (iter.hasNext() && iter.nextIndex() != r)\n+            {\n+                Pool<T>.Entry entry = iter.next();\n+                if (entry.tryAcquire())\n+                    return entry;\n+            }\n+\n+            return null;\n+        }\n+    }\n+\n+    public static class RoundRobinIterationStrategy<T> implements Strategy<T>\n+    {\n+        AtomicInteger index = new AtomicInteger();\n+\n+        @Override\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        {\n+            int i = index.get();\n+\n+            ListIterator<Pool<T>.Entry> iter = entries.listIterator(i);\n+            while (iter.hasNext())\n+            {\n+                Pool<T>.Entry entry = iter.next();\n+                if (entry.tryAcquire())\n+                {\n+                    index.set(iter.nextIndex());\n+                    return entry;\n+                }\n+            }\n+\n+            iter = entries.listIterator();\n+            while (iter.hasNext() && iter.nextIndex() != i)\n+            {\n+                Pool<T>.Entry entry = iter.next();\n+                if (entry.tryAcquire())\n+                {\n+                    index.set(iter.nextIndex());\n+                    return entry;\n+                }\n+            }\n+\n+            return null;\n+        }\n+    }\n+\n     public static class LeastRecentlyUsedStrategy<T> implements Strategy<T>\n     {\n         Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n \n         @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n             while (true)\n             {\n", "next_change": {"commit": "0aa6bc92110ade8c4c96b26e8c074620447857ee", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex b088f5b4b0..03b9966fc2 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -917,22 +903,14 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             {\n                 Pool<T>.Entry entry = lru.poll();\n                 if (entry == null)\n-                    return null;\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            lru.add(entry);\n-        }\n+                    entry = super.tryAcquire(entries);\n+                else if (!entry.tryAcquire())\n+                    continue;\n \n-        @Override\n-        public void reserved(Pool<T>.Entry entry)\n-        {\n-            lru.add(entry);\n+                if (entry != null)\n+                    lru.add(entry);\n+                return entry;\n+            }\n         }\n     }\n }\n", "next_change": {"commit": "feda65d15aa906a1c0689ea45b26e15a17906beb", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 03b9966fc2..0f18b89c08 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -913,4 +1022,76 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             }\n         }\n     }\n+\n+    public static class OneStrategyToRuleThemAll<T> implements Strategy<T>\n+    {\n+        private final Mode mode;\n+        private final ThreadLocal<Integer> last;\n+        private final AtomicInteger next;\n+\n+        enum Mode\n+        {\n+            LINEAR,\n+            RANDOM,\n+            THREAD_LOCAL,\n+            ROUND_ROBIN,\n+        }\n+\n+        public OneStrategyToRuleThemAll(Mode mode)\n+        {\n+            this.mode = mode;\n+            last = mode == Mode.THREAD_LOCAL ? ThreadLocal.withInitial(()->0) : null;\n+            next = mode == Mode.ROUND_ROBIN ? new AtomicInteger() : null;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        {\n+            int size = entries.size();\n+            if (size == 0)\n+                return null;\n+\n+            int index;\n+            switch (mode)\n+            {\n+                case LINEAR:\n+                    index = 0;\n+                    break;\n+                case RANDOM:\n+                    index = ThreadLocalRandom.current().nextInt(size);\n+                    break;\n+                case THREAD_LOCAL:\n+                    index = last.get();\n+                    break;\n+                case ROUND_ROBIN:\n+                    index = next.getAndUpdate(c -> ++c < size ? c : 0);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException();\n+            }\n+\n+            for (int tries = size; tries-- > 0;)\n+            {\n+                try\n+                {\n+                    Pool<T>.Entry entry = entries.get(index);\n+                    if (entry != null && entry.tryAcquire())\n+                        return entry;\n+                }\n+                catch (IndexOutOfBoundsException e)\n+                {\n+                    LOGGER.ignore(e);\n+                }\n+                index = (index + 1) % size;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(Pool<T>.Entry entry)\n+        {\n+            if (last != null)\n+                last.set(entry.index);\n+        }\n+    }\n }\n", "next_change": {"commit": "bf520b4d8b559c5ed8551573d780dced775bcc06", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0f18b89c08..c311021e1a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -617,481 +571,86 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /** A pluggable strategy to for pool entry lookup\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Strategy<T>\n+    public static class Linear<T> extends Pool<T>\n     {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entry The entry to be released\n-         */\n-        default void released(Pool<T>.Entry entry)\n+        public Linear(int maxEntries)\n         {\n-        }\n-    }\n-\n-    /** A Composite strategy used to combine multiple other strategies.\n-     * Typically it is used to combine an optimistic strategy (eg {@link RandomStrategy})\n-     * with an exhaustive strategy (eg {@link LinearSearchStrategy}).\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class CompositeStrategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> planA;\n-        final Strategy<T> planB;\n-\n-        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(planA);\n-            Objects.requireNonNull(planB);\n-            this.planA = planA;\n-            this.planB = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = planA.tryAcquire(entries);\n-            return entry != null ? entry : planB.tryAcquire(entries);\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            planA.released(entry);\n-            planB.released(entry);\n-        }\n-    }\n-\n-\n-    /**\n-     * This strategy retries a wrapped strategy looking for\n-     * and Entry\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RetryStategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> strategy;\n-        final int retries;\n-\n-        public RetryStategy(Strategy<T> strategy)\n-        {\n-            this (strategy, -1);\n-        }\n-\n-        public RetryStategy(Strategy<T> strategy, int retries)\n-        {\n-            this.strategy = strategy;\n-            this.retries = retries;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = retries < 0 ? entries.size() : retries;\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = strategy.tryAcquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Linear search strategy uses a fresh iterator to scan the\n-     * entries, starting at 0, until it can acquire one.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LinearSearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores a {@link ListIterator} as a {@link ThreadLocal}\n-     * which is used to scan the list of entries for one that can be acquired.\n-     * Once an entry is acquired, if the strategy is in roundrobin mode, then\n-     * it is left on the next entry, otherwise it is moved back so the current\n-     * entry will be tried again on the next acquire.\n-     * If the iterator reaches the end, then a new one is created.\n-     * The strategy will only try as many times as there are entries.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalIteratorStrategy<T> implements Strategy<T>\n-    {\n-        private final boolean roundrobin;\n-        private final ThreadLocal<ListIterator<Pool<T>.Entry>> iterator = new ThreadLocal<>();\n-\n-        public ThreadLocalIteratorStrategy()\n-        {\n-            this(false);\n-        }\n-\n-        public ThreadLocalIteratorStrategy(boolean roundrobin)\n-        {\n-            this.roundrobin = roundrobin;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            ListIterator<Pool<T>.Entry> iter = iterator.get();\n-            if (iter == null)\n-                iter = entries.listIterator();\n-\n-            for (int tries = entries.size(); tries-- > 0; )\n-            {\n-                if (!iter.hasNext())\n-                {\n-                    iter = entries.listIterator();\n-                    if (!iter.hasNext())\n-                        return null;\n-                }\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry != null && entry.tryAcquire())\n-                {\n-                    if (!roundrobin)\n-                        iter.previous();\n-                    if (iter.hasNext())\n-                        iterator.set(iter);\n-                    return entry;\n-                }\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores the last entry released by a thread as in\n-     * {@link ThreadLocal} so it can be the first tried on the next\n-     * acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalStrategy<T> implements Strategy<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalStrategy()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n+            super(maxEntries);\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        protected int startIndex(int size)\n         {\n-            last.set(entry);\n+            return 0;\n         }\n     }\n \n-    /**\n-     * This strategy stores the entries released by a thread in a bounded list\n-     * stored in a {@link ThreadLocal},  so they can be the first tried on the\n-     * next acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalListStrategy<T> implements Strategy<T>\n+    public static class Random<T> extends Pool<T>\n     {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListStrategy(int size)\n+        public Random(int maxEntries)\n         {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+            super(maxEntries);\n         }\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            if (cachedList.size() < cacheSize)\n-                cachedList.add(entry);\n+            return ThreadLocalRandom.current().nextInt(size);\n         }\n     }\n \n-    private abstract static class IndexedStrategy<T> implements Strategy<T>\n+    public static class RoundRobin<T> extends Pool<T>\n     {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (IndexOutOfBoundsException e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n+        private final AtomicInteger next = new AtomicInteger();\n \n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    /**\n-     * This strategy tries to acquire a random entry.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class RandomStrategy<T> extends IndexedStrategy<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n+        public RoundRobin(int maxEntries)\n         {\n-            return ThreadLocalRandom.current().nextInt(size);\n+            super(maxEntries);\n         }\n-    }\n \n-    public static class ThreadIdStrategy<T> extends IndexedStrategy<T>\n-    {\n         @Override\n-        protected int nextIndex(int size)\n+        protected int startIndex(int size)\n         {\n-            return (int)Thread.currentThread().getId() % size;\n+            return next.getAndUpdate(c -> ++c < size ? c : 0);\n         }\n     }\n \n-    /**\n-     * This strategy uses an {@link AtomicInteger} to remember the index\n-     * of the last acquired entry. Calls to acquire will commence trying\n-     * to acquired from the next index.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinStrategy<T> extends IndexedStrategy<T>\n+    public static class Thread<T> extends Pool<T>\n     {\n-        AtomicInteger index = new AtomicInteger();\n+        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n \n-        @Override\n-        protected int nextIndex(int size)\n+        public Thread(int maxEntries)\n         {\n-            return index.getAndUpdate(c -> ++c < size ? c : 0);\n+            super(maxEntries);\n         }\n-    }\n \n-    /**\n-     * This strategy iterates over the entries, starting from a random location,\n-     * to try to acquire an entry.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RandomIterationStrategy<T> implements Strategy<T>\n-    {\n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int r = ThreadLocalRandom.current().nextInt(size);\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(r);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= r)\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            return null;\n+            return 0;\n         }\n-    }\n-\n-    /**\n-     * This strategy commences an iteration over the entries from the\n-     * position after the last successful acquire.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinIterationStrategy<T> implements Strategy<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        public Entry acquire()\n         {\n-            int i = index.get();\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(i);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n-                    return entry;\n-                }\n-            }\n \n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= i)\n+            Entry entry = last.get();\n+            if (entry != null)\n             {\n-                Pool<T>.Entry entry = iter.next();\n                 if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n                     return entry;\n-                }\n-            }\n-\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy keeps a queue of the least recently used entry. If that queue is\n-     * empty, then this strategy falls back to a linear search.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LeastRecentlyUsedStrategy<T> extends LinearSearchStrategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    entry = super.tryAcquire(entries);\n-                else if (!entry.tryAcquire())\n-                    continue;\n-\n-                if (entry != null)\n-                    lru.add(entry);\n-                return entry;\n-            }\n-        }\n-    }\n-\n-    public static class OneStrategyToRuleThemAll<T> implements Strategy<T>\n-    {\n-        private final Mode mode;\n-        private final ThreadLocal<Integer> last;\n-        private final AtomicInteger next;\n-\n-        enum Mode\n-        {\n-            LINEAR,\n-            RANDOM,\n-            THREAD_LOCAL,\n-            ROUND_ROBIN,\n-        }\n-\n-        public OneStrategyToRuleThemAll(Mode mode)\n-        {\n-            this.mode = mode;\n-            last = mode == Mode.THREAD_LOCAL ? ThreadLocal.withInitial(()->0) : null;\n-            next = mode == Mode.ROUND_ROBIN ? new AtomicInteger() : null;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-\n-            int index;\n-            switch (mode)\n-            {\n-                case LINEAR:\n-                    index = 0;\n-                    break;\n-                case RANDOM:\n-                    index = ThreadLocalRandom.current().nextInt(size);\n-                    break;\n-                case THREAD_LOCAL:\n-                    index = last.get();\n-                    break;\n-                case ROUND_ROBIN:\n-                    index = next.getAndUpdate(c -> ++c < size ? c : 0);\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-\n-            for (int tries = size; tries-- > 0;)\n-            {\n-                try\n-                {\n-                    Pool<T>.Entry entry = entries.get(index);\n-                    if (entry != null && entry.tryAcquire())\n-                        return entry;\n-                }\n-                catch (IndexOutOfBoundsException e)\n-                {\n-                    LOGGER.ignore(e);\n-                }\n-                index = (index + 1) % size;\n+                last.set(null);\n             }\n-            return null;\n+            return super.acquire();\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        public boolean release(Entry entry)\n         {\n-            if (last != null)\n-                last.set(entry.index);\n+            boolean released =  super.release(entry);\n+            if (released)\n+                last.set(entry);\n+            return released;\n         }\n     }\n }\n", "next_change": {"commit": "db00126abd11f5734e499bb8a7ab795bc769b879", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c311021e1a..723a79fbde 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -570,87 +618,4 @@ public abstract class Pool<T> implements AutoCloseable, Dumpable\n                 pooled);\n         }\n     }\n-\n-    public static class Linear<T> extends Pool<T>\n-    {\n-        public Linear(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-    }\n-\n-    public static class Random<T> extends Pool<T>\n-    {\n-        public Random(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobin<T> extends Pool<T>\n-    {\n-        private final AtomicInteger next = new AtomicInteger();\n-\n-        public RoundRobin(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return next.getAndUpdate(c -> ++c < size ? c : 0);\n-        }\n-    }\n-\n-    public static class Thread<T> extends Pool<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n-\n-        public Thread(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-\n-        @Override\n-        public Entry acquire()\n-        {\n-\n-            Entry entry = last.get();\n-            if (entry != null)\n-            {\n-                if (entry.tryAcquire())\n-                    return entry;\n-                last.set(null);\n-            }\n-            return super.acquire();\n-        }\n-\n-        @Override\n-        public boolean release(Entry entry)\n-        {\n-            boolean released =  super.release(entry);\n-            if (released)\n-                last.set(entry);\n-            return released;\n-        }\n-    }\n }\n", "next_change": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 723a79fbde..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -603,17 +629,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            int hi = AtomicBiInteger.getHi(encoded);\n-            int lo = AtomicBiInteger.getLo(encoded);\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = hi < 0 ? \"CLOSED\" : lo == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n \n             return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n-                Math.max(hi, 0),\n-                Math.max(lo, 0),\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NjMzMg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482056332", "body": "Are both `Strategy` and `Cache` needed?", "bodyText": "Are both Strategy and Cache needed?", "bodyHTML": "<p dir=\"auto\">Are both <code>Strategy</code> and <code>Cache</code> needed?</p>", "author": "lorban", "createdAt": "2020-09-02T13:11:12Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMwODQzNg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482308436", "bodyText": "Strategy and Cache are needed if we want to make a distinction between impls that just try to find an entry and then give up (threadlocal, random) and those that do a search  ( linear, round-robin).\nHowever, I too am not convinced the distinction is necessary.", "author": "gregw", "createdAt": "2020-09-02T18:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NjMzMg=="}], "type": "inlineReview", "revised_code": {"commit": "e250a4966d93eeb9117b93c6a9030ca7537a8443", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..4b45a8e656 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -590,43 +577,71 @@ public class Pool<T> implements AutoCloseable, Dumpable\n          * Notification an entry has been release.  The notification comes after the entry\n          * has been put back in the pool and it may already have been reacquired before or during this call.\n          * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @param entry The entry to be release\n-         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         * @param entry The entry to be released\n          */\n-        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        default boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n         {\n+            return entry.tryRelease();\n         }\n-    }\n \n-    public interface Strategy<T> extends Cache<T>\n-    {\n-    }\n+        default void reserve(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            entries.add(entry);\n+        }\n+\n+        default boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            if (!entry.tryRemove())\n+            {\n+                if (LOGGER.isDebugEnabled())\n+                    LOGGER.debug(\"Attempt to remove an object from the pool that is still in use: {}\", entry);\n+                return false;\n+            }\n \n-    public static class CacheStrategy<T> implements Strategy<T>\n+            boolean removed = entries.remove(entry);\n+            if (!removed)\n+            {\n+                if (LOGGER.isDebugEnabled())\n+                    LOGGER.debug(\"Attempt to remove an object from the pool that does not exist: {}\", entry);\n+            }\n+            return removed;\n+        }\n+    }\n+    \n+    public static class CompositeStrategy<T> implements Strategy<T>\n     {\n-        final Cache<T> cache;\n-        final Strategy<T> strategy;\n+        final Strategy<T> planA;\n+        final Strategy<T> planB;\n \n-        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n         {\n-            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planA);\n             Objects.requireNonNull(planB);\n-            this.cache = cache;\n-            this.strategy = planB;\n+            this.planA = planA;\n+            this.planB = planB;\n         }\n \n         @Override\n         public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n         {\n-            Pool<T>.Entry entry = cache.acquire(entries);\n-            return entry == null ? strategy.acquire(entries) : entry;\n+            Pool<T>.Entry entry = planA.acquire(entries);\n+            return entry == null ? planB.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            if (planA.release(entries, entry))\n+                return true;\n+            if (entry.isOverUsed())\n+                return false;\n+            return planB.release(entries, entry);\n         }\n \n         @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        public boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n         {\n-            cache.released(entries, entry, reusable);\n-            strategy.released(entries, entry, reusable);\n+            return planA.remove(entries, entry) || planB.remove(entries, entry);\n         }\n     }\n \n", "next_change": {"commit": "505321687c6ad3e7bcc6e64e6d1d0b183167b419", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 4b45a8e656..b088f5b4b0 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,33 +646,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n \n         @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n-            Pool<T>.Entry entry = planA.acquire(entries);\n-            return entry == null ? planB.acquire(entries) : entry;\n+            Pool<T>.Entry entry = planA.tryAcquire(entries);\n+            return entry != null ? entry : planB.tryAcquire(entries);\n         }\n \n         @Override\n-        public boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        public void released(Pool<T>.Entry entry)\n         {\n-            if (planA.release(entries, entry))\n-                return true;\n-            if (entry.isOverUsed())\n-                return false;\n-            return planB.release(entries, entry);\n+            planA.released(entry);\n+            planB.released(entry);\n         }\n \n         @Override\n-        public boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        public void removed(Pool<T>.Entry entry)\n         {\n-            return planA.remove(entries, entry) || planB.remove(entries, entry);\n+            planA.removed(entry);\n+            planB.removed(entry);\n         }\n     }\n \n-    public static class SearchStrategy<T> implements Strategy<T>\n+    public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n         @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n             for (Pool<T>.Entry e : entries)\n             {\n", "next_change": {"commit": "15ab22647b3e1bc8e791d9a4e6bd16a9d1ed61e8", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex b088f5b4b0..ce5092a04d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -658,15 +659,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             planA.released(entry);\n             planB.released(entry);\n         }\n-\n-        @Override\n-        public void removed(Pool<T>.Entry entry)\n-        {\n-            planA.removed(entry);\n-            planB.removed(entry);\n-        }\n     }\n \n+    /**\n+     * @param <T> The type of entry the strategy is for\n+     */\n     public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n         @Override\n", "next_change": {"commit": "c18a77e8135047393ba289ca3179693b5af4ffad", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex ce5092a04d..89dd157034 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -662,7 +662,9 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * @param <T> The type of entry the strategy is for\n+     * Linear search strategy uses a fresh iterator to scan the\n+     * entries, starting at 0, until it can acquire one.\n+     * @param <T> The type of entry the strategy is for.\n      */\n     public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n", "next_change": {"commit": "feda65d15aa906a1c0689ea45b26e15a17906beb", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 89dd157034..0f18b89c08 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -661,6 +671,42 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+\n+    /**\n+     * This strategy retries a wrapped strategy looking for\n+     * and Entry\n+     * @param <T> The type of entry the strategy is for.\n+     */\n+    public static class RetryStategy<T> implements Strategy<T>\n+    {\n+        final Strategy<T> strategy;\n+        final int retries;\n+\n+        public RetryStategy(Strategy<T> strategy)\n+        {\n+            this (strategy, -1);\n+        }\n+\n+        public RetryStategy(Strategy<T> strategy, int retries)\n+        {\n+            this.strategy = strategy;\n+            this.retries = retries;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        {\n+            int tries = retries < 0 ? entries.size() : retries;\n+            while (tries-- > 0)\n+            {\n+                Pool<T>.Entry entry = strategy.tryAcquire(entries);\n+                if (entry != null)\n+                    return entry;\n+            }\n+            return null;\n+        }\n+    }\n+\n     /**\n      * Linear search strategy uses a fresh iterator to scan the\n      * entries, starting at 0, until it can acquire one.\n", "next_change": {"commit": "bf520b4d8b559c5ed8551573d780dced775bcc06", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0f18b89c08..c311021e1a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -617,481 +571,86 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /** A pluggable strategy to for pool entry lookup\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Strategy<T>\n+    public static class Linear<T> extends Pool<T>\n     {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entry The entry to be released\n-         */\n-        default void released(Pool<T>.Entry entry)\n+        public Linear(int maxEntries)\n         {\n-        }\n-    }\n-\n-    /** A Composite strategy used to combine multiple other strategies.\n-     * Typically it is used to combine an optimistic strategy (eg {@link RandomStrategy})\n-     * with an exhaustive strategy (eg {@link LinearSearchStrategy}).\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class CompositeStrategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> planA;\n-        final Strategy<T> planB;\n-\n-        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(planA);\n-            Objects.requireNonNull(planB);\n-            this.planA = planA;\n-            this.planB = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = planA.tryAcquire(entries);\n-            return entry != null ? entry : planB.tryAcquire(entries);\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            planA.released(entry);\n-            planB.released(entry);\n-        }\n-    }\n-\n-\n-    /**\n-     * This strategy retries a wrapped strategy looking for\n-     * and Entry\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RetryStategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> strategy;\n-        final int retries;\n-\n-        public RetryStategy(Strategy<T> strategy)\n-        {\n-            this (strategy, -1);\n-        }\n-\n-        public RetryStategy(Strategy<T> strategy, int retries)\n-        {\n-            this.strategy = strategy;\n-            this.retries = retries;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = retries < 0 ? entries.size() : retries;\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = strategy.tryAcquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Linear search strategy uses a fresh iterator to scan the\n-     * entries, starting at 0, until it can acquire one.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LinearSearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores a {@link ListIterator} as a {@link ThreadLocal}\n-     * which is used to scan the list of entries for one that can be acquired.\n-     * Once an entry is acquired, if the strategy is in roundrobin mode, then\n-     * it is left on the next entry, otherwise it is moved back so the current\n-     * entry will be tried again on the next acquire.\n-     * If the iterator reaches the end, then a new one is created.\n-     * The strategy will only try as many times as there are entries.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalIteratorStrategy<T> implements Strategy<T>\n-    {\n-        private final boolean roundrobin;\n-        private final ThreadLocal<ListIterator<Pool<T>.Entry>> iterator = new ThreadLocal<>();\n-\n-        public ThreadLocalIteratorStrategy()\n-        {\n-            this(false);\n-        }\n-\n-        public ThreadLocalIteratorStrategy(boolean roundrobin)\n-        {\n-            this.roundrobin = roundrobin;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            ListIterator<Pool<T>.Entry> iter = iterator.get();\n-            if (iter == null)\n-                iter = entries.listIterator();\n-\n-            for (int tries = entries.size(); tries-- > 0; )\n-            {\n-                if (!iter.hasNext())\n-                {\n-                    iter = entries.listIterator();\n-                    if (!iter.hasNext())\n-                        return null;\n-                }\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry != null && entry.tryAcquire())\n-                {\n-                    if (!roundrobin)\n-                        iter.previous();\n-                    if (iter.hasNext())\n-                        iterator.set(iter);\n-                    return entry;\n-                }\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores the last entry released by a thread as in\n-     * {@link ThreadLocal} so it can be the first tried on the next\n-     * acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalStrategy<T> implements Strategy<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalStrategy()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n+            super(maxEntries);\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        protected int startIndex(int size)\n         {\n-            last.set(entry);\n+            return 0;\n         }\n     }\n \n-    /**\n-     * This strategy stores the entries released by a thread in a bounded list\n-     * stored in a {@link ThreadLocal},  so they can be the first tried on the\n-     * next acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalListStrategy<T> implements Strategy<T>\n+    public static class Random<T> extends Pool<T>\n     {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListStrategy(int size)\n+        public Random(int maxEntries)\n         {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+            super(maxEntries);\n         }\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            if (cachedList.size() < cacheSize)\n-                cachedList.add(entry);\n+            return ThreadLocalRandom.current().nextInt(size);\n         }\n     }\n \n-    private abstract static class IndexedStrategy<T> implements Strategy<T>\n+    public static class RoundRobin<T> extends Pool<T>\n     {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (IndexOutOfBoundsException e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n+        private final AtomicInteger next = new AtomicInteger();\n \n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    /**\n-     * This strategy tries to acquire a random entry.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class RandomStrategy<T> extends IndexedStrategy<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n+        public RoundRobin(int maxEntries)\n         {\n-            return ThreadLocalRandom.current().nextInt(size);\n+            super(maxEntries);\n         }\n-    }\n \n-    public static class ThreadIdStrategy<T> extends IndexedStrategy<T>\n-    {\n         @Override\n-        protected int nextIndex(int size)\n+        protected int startIndex(int size)\n         {\n-            return (int)Thread.currentThread().getId() % size;\n+            return next.getAndUpdate(c -> ++c < size ? c : 0);\n         }\n     }\n \n-    /**\n-     * This strategy uses an {@link AtomicInteger} to remember the index\n-     * of the last acquired entry. Calls to acquire will commence trying\n-     * to acquired from the next index.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinStrategy<T> extends IndexedStrategy<T>\n+    public static class Thread<T> extends Pool<T>\n     {\n-        AtomicInteger index = new AtomicInteger();\n+        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n \n-        @Override\n-        protected int nextIndex(int size)\n+        public Thread(int maxEntries)\n         {\n-            return index.getAndUpdate(c -> ++c < size ? c : 0);\n+            super(maxEntries);\n         }\n-    }\n \n-    /**\n-     * This strategy iterates over the entries, starting from a random location,\n-     * to try to acquire an entry.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RandomIterationStrategy<T> implements Strategy<T>\n-    {\n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int r = ThreadLocalRandom.current().nextInt(size);\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(r);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= r)\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            return null;\n+            return 0;\n         }\n-    }\n-\n-    /**\n-     * This strategy commences an iteration over the entries from the\n-     * position after the last successful acquire.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinIterationStrategy<T> implements Strategy<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        public Entry acquire()\n         {\n-            int i = index.get();\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(i);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n-                    return entry;\n-                }\n-            }\n \n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= i)\n+            Entry entry = last.get();\n+            if (entry != null)\n             {\n-                Pool<T>.Entry entry = iter.next();\n                 if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n                     return entry;\n-                }\n-            }\n-\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy keeps a queue of the least recently used entry. If that queue is\n-     * empty, then this strategy falls back to a linear search.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LeastRecentlyUsedStrategy<T> extends LinearSearchStrategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    entry = super.tryAcquire(entries);\n-                else if (!entry.tryAcquire())\n-                    continue;\n-\n-                if (entry != null)\n-                    lru.add(entry);\n-                return entry;\n-            }\n-        }\n-    }\n-\n-    public static class OneStrategyToRuleThemAll<T> implements Strategy<T>\n-    {\n-        private final Mode mode;\n-        private final ThreadLocal<Integer> last;\n-        private final AtomicInteger next;\n-\n-        enum Mode\n-        {\n-            LINEAR,\n-            RANDOM,\n-            THREAD_LOCAL,\n-            ROUND_ROBIN,\n-        }\n-\n-        public OneStrategyToRuleThemAll(Mode mode)\n-        {\n-            this.mode = mode;\n-            last = mode == Mode.THREAD_LOCAL ? ThreadLocal.withInitial(()->0) : null;\n-            next = mode == Mode.ROUND_ROBIN ? new AtomicInteger() : null;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-\n-            int index;\n-            switch (mode)\n-            {\n-                case LINEAR:\n-                    index = 0;\n-                    break;\n-                case RANDOM:\n-                    index = ThreadLocalRandom.current().nextInt(size);\n-                    break;\n-                case THREAD_LOCAL:\n-                    index = last.get();\n-                    break;\n-                case ROUND_ROBIN:\n-                    index = next.getAndUpdate(c -> ++c < size ? c : 0);\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-\n-            for (int tries = size; tries-- > 0;)\n-            {\n-                try\n-                {\n-                    Pool<T>.Entry entry = entries.get(index);\n-                    if (entry != null && entry.tryAcquire())\n-                        return entry;\n-                }\n-                catch (IndexOutOfBoundsException e)\n-                {\n-                    LOGGER.ignore(e);\n-                }\n-                index = (index + 1) % size;\n+                last.set(null);\n             }\n-            return null;\n+            return super.acquire();\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        public boolean release(Entry entry)\n         {\n-            if (last != null)\n-                last.set(entry.index);\n+            boolean released =  super.release(entry);\n+            if (released)\n+                last.set(entry);\n+            return released;\n         }\n     }\n }\n", "next_change": {"commit": "db00126abd11f5734e499bb8a7ab795bc769b879", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c311021e1a..723a79fbde 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -570,87 +618,4 @@ public abstract class Pool<T> implements AutoCloseable, Dumpable\n                 pooled);\n         }\n     }\n-\n-    public static class Linear<T> extends Pool<T>\n-    {\n-        public Linear(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-    }\n-\n-    public static class Random<T> extends Pool<T>\n-    {\n-        public Random(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobin<T> extends Pool<T>\n-    {\n-        private final AtomicInteger next = new AtomicInteger();\n-\n-        public RoundRobin(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return next.getAndUpdate(c -> ++c < size ? c : 0);\n-        }\n-    }\n-\n-    public static class Thread<T> extends Pool<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n-\n-        public Thread(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-\n-        @Override\n-        public Entry acquire()\n-        {\n-\n-            Entry entry = last.get();\n-            if (entry != null)\n-            {\n-                if (entry.tryAcquire())\n-                    return entry;\n-                last.set(null);\n-            }\n-            return super.acquire();\n-        }\n-\n-        @Override\n-        public boolean release(Entry entry)\n-        {\n-            boolean released =  super.release(entry);\n-            if (released)\n-                last.set(entry);\n-            return released;\n-        }\n-    }\n }\n", "next_change": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 723a79fbde..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -603,17 +629,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            int hi = AtomicBiInteger.getHi(encoded);\n-            int lo = AtomicBiInteger.getLo(encoded);\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = hi < 0 ? \"CLOSED\" : lo == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n \n             return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n-                Math.max(hi, 0),\n-                Math.max(lo, 0),\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NzEyOA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482057128", "body": "If we go with this design, the RR connection pool should be rewritten to use the RR strategy and this method should be removed.", "bodyText": "If we go with this design, the RR connection pool should be rewritten to use the RR strategy and this method should be removed.", "bodyHTML": "<p dir=\"auto\">If we go with this design, the RR connection pool should be rewritten to use the RR strategy and this method should be removed.</p>", "author": "lorban", "createdAt": "2020-09-02T13:12:22Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -176,14 +213,15 @@ public Entry reserve(int allotment)\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c90442d5b368d3d6274acfd81893d37d6755951", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..ab606c5588 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -202,14 +206,13 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n             Entry entry = new Entry();\n             entries.add(entry);\n-            strategy.released(entries, entry, true);\n             return entry;\n         }\n     }\n \n     /**\n      * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     *\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1Nzg1OA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482057858", "body": "`this.cache = Objects.requireNonNull(cache);`", "bodyText": "this.cache = Objects.requireNonNull(cache);", "bodyHTML": "<p dir=\"auto\"><code>this.cache = Objects.requireNonNull(cache);</code></p>", "author": "lorban", "createdAt": "2020-09-02T13:13:32Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e250a4966d93eeb9117b93c6a9030ca7537a8443", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..4b45a8e656 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -590,43 +577,71 @@ public class Pool<T> implements AutoCloseable, Dumpable\n          * Notification an entry has been release.  The notification comes after the entry\n          * has been put back in the pool and it may already have been reacquired before or during this call.\n          * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @param entry The entry to be release\n-         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         * @param entry The entry to be released\n          */\n-        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        default boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n         {\n+            return entry.tryRelease();\n         }\n-    }\n \n-    public interface Strategy<T> extends Cache<T>\n-    {\n-    }\n+        default void reserve(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            entries.add(entry);\n+        }\n+\n+        default boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            if (!entry.tryRemove())\n+            {\n+                if (LOGGER.isDebugEnabled())\n+                    LOGGER.debug(\"Attempt to remove an object from the pool that is still in use: {}\", entry);\n+                return false;\n+            }\n \n-    public static class CacheStrategy<T> implements Strategy<T>\n+            boolean removed = entries.remove(entry);\n+            if (!removed)\n+            {\n+                if (LOGGER.isDebugEnabled())\n+                    LOGGER.debug(\"Attempt to remove an object from the pool that does not exist: {}\", entry);\n+            }\n+            return removed;\n+        }\n+    }\n+    \n+    public static class CompositeStrategy<T> implements Strategy<T>\n     {\n-        final Cache<T> cache;\n-        final Strategy<T> strategy;\n+        final Strategy<T> planA;\n+        final Strategy<T> planB;\n \n-        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n         {\n-            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planA);\n             Objects.requireNonNull(planB);\n-            this.cache = cache;\n-            this.strategy = planB;\n+            this.planA = planA;\n+            this.planB = planB;\n         }\n \n         @Override\n         public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n         {\n-            Pool<T>.Entry entry = cache.acquire(entries);\n-            return entry == null ? strategy.acquire(entries) : entry;\n+            Pool<T>.Entry entry = planA.acquire(entries);\n+            return entry == null ? planB.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            if (planA.release(entries, entry))\n+                return true;\n+            if (entry.isOverUsed())\n+                return false;\n+            return planB.release(entries, entry);\n         }\n \n         @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        public boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n         {\n-            cache.released(entries, entry, reusable);\n-            strategy.released(entries, entry, reusable);\n+            return planA.remove(entries, entry) || planB.remove(entries, entry);\n         }\n     }\n \n", "next_change": {"commit": "505321687c6ad3e7bcc6e64e6d1d0b183167b419", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 4b45a8e656..b088f5b4b0 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,33 +646,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n \n         @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n-            Pool<T>.Entry entry = planA.acquire(entries);\n-            return entry == null ? planB.acquire(entries) : entry;\n+            Pool<T>.Entry entry = planA.tryAcquire(entries);\n+            return entry != null ? entry : planB.tryAcquire(entries);\n         }\n \n         @Override\n-        public boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        public void released(Pool<T>.Entry entry)\n         {\n-            if (planA.release(entries, entry))\n-                return true;\n-            if (entry.isOverUsed())\n-                return false;\n-            return planB.release(entries, entry);\n+            planA.released(entry);\n+            planB.released(entry);\n         }\n \n         @Override\n-        public boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        public void removed(Pool<T>.Entry entry)\n         {\n-            return planA.remove(entries, entry) || planB.remove(entries, entry);\n+            planA.removed(entry);\n+            planB.removed(entry);\n         }\n     }\n \n-    public static class SearchStrategy<T> implements Strategy<T>\n+    public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n         @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n             for (Pool<T>.Entry e : entries)\n             {\n", "next_change": {"commit": "15ab22647b3e1bc8e791d9a4e6bd16a9d1ed61e8", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex b088f5b4b0..ce5092a04d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -658,15 +659,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             planA.released(entry);\n             planB.released(entry);\n         }\n-\n-        @Override\n-        public void removed(Pool<T>.Entry entry)\n-        {\n-            planA.removed(entry);\n-            planB.removed(entry);\n-        }\n     }\n \n+    /**\n+     * @param <T> The type of entry the strategy is for\n+     */\n     public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n         @Override\n", "next_change": {"commit": "c18a77e8135047393ba289ca3179693b5af4ffad", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex ce5092a04d..89dd157034 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -662,7 +662,9 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * @param <T> The type of entry the strategy is for\n+     * Linear search strategy uses a fresh iterator to scan the\n+     * entries, starting at 0, until it can acquire one.\n+     * @param <T> The type of entry the strategy is for.\n      */\n     public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n", "next_change": {"commit": "feda65d15aa906a1c0689ea45b26e15a17906beb", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 89dd157034..0f18b89c08 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -661,6 +671,42 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+\n+    /**\n+     * This strategy retries a wrapped strategy looking for\n+     * and Entry\n+     * @param <T> The type of entry the strategy is for.\n+     */\n+    public static class RetryStategy<T> implements Strategy<T>\n+    {\n+        final Strategy<T> strategy;\n+        final int retries;\n+\n+        public RetryStategy(Strategy<T> strategy)\n+        {\n+            this (strategy, -1);\n+        }\n+\n+        public RetryStategy(Strategy<T> strategy, int retries)\n+        {\n+            this.strategy = strategy;\n+            this.retries = retries;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        {\n+            int tries = retries < 0 ? entries.size() : retries;\n+            while (tries-- > 0)\n+            {\n+                Pool<T>.Entry entry = strategy.tryAcquire(entries);\n+                if (entry != null)\n+                    return entry;\n+            }\n+            return null;\n+        }\n+    }\n+\n     /**\n      * Linear search strategy uses a fresh iterator to scan the\n      * entries, starting at 0, until it can acquire one.\n", "next_change": {"commit": "bf520b4d8b559c5ed8551573d780dced775bcc06", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0f18b89c08..c311021e1a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -617,481 +571,86 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /** A pluggable strategy to for pool entry lookup\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Strategy<T>\n+    public static class Linear<T> extends Pool<T>\n     {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entry The entry to be released\n-         */\n-        default void released(Pool<T>.Entry entry)\n+        public Linear(int maxEntries)\n         {\n-        }\n-    }\n-\n-    /** A Composite strategy used to combine multiple other strategies.\n-     * Typically it is used to combine an optimistic strategy (eg {@link RandomStrategy})\n-     * with an exhaustive strategy (eg {@link LinearSearchStrategy}).\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class CompositeStrategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> planA;\n-        final Strategy<T> planB;\n-\n-        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(planA);\n-            Objects.requireNonNull(planB);\n-            this.planA = planA;\n-            this.planB = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = planA.tryAcquire(entries);\n-            return entry != null ? entry : planB.tryAcquire(entries);\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            planA.released(entry);\n-            planB.released(entry);\n-        }\n-    }\n-\n-\n-    /**\n-     * This strategy retries a wrapped strategy looking for\n-     * and Entry\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RetryStategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> strategy;\n-        final int retries;\n-\n-        public RetryStategy(Strategy<T> strategy)\n-        {\n-            this (strategy, -1);\n-        }\n-\n-        public RetryStategy(Strategy<T> strategy, int retries)\n-        {\n-            this.strategy = strategy;\n-            this.retries = retries;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = retries < 0 ? entries.size() : retries;\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = strategy.tryAcquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Linear search strategy uses a fresh iterator to scan the\n-     * entries, starting at 0, until it can acquire one.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LinearSearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores a {@link ListIterator} as a {@link ThreadLocal}\n-     * which is used to scan the list of entries for one that can be acquired.\n-     * Once an entry is acquired, if the strategy is in roundrobin mode, then\n-     * it is left on the next entry, otherwise it is moved back so the current\n-     * entry will be tried again on the next acquire.\n-     * If the iterator reaches the end, then a new one is created.\n-     * The strategy will only try as many times as there are entries.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalIteratorStrategy<T> implements Strategy<T>\n-    {\n-        private final boolean roundrobin;\n-        private final ThreadLocal<ListIterator<Pool<T>.Entry>> iterator = new ThreadLocal<>();\n-\n-        public ThreadLocalIteratorStrategy()\n-        {\n-            this(false);\n-        }\n-\n-        public ThreadLocalIteratorStrategy(boolean roundrobin)\n-        {\n-            this.roundrobin = roundrobin;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            ListIterator<Pool<T>.Entry> iter = iterator.get();\n-            if (iter == null)\n-                iter = entries.listIterator();\n-\n-            for (int tries = entries.size(); tries-- > 0; )\n-            {\n-                if (!iter.hasNext())\n-                {\n-                    iter = entries.listIterator();\n-                    if (!iter.hasNext())\n-                        return null;\n-                }\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry != null && entry.tryAcquire())\n-                {\n-                    if (!roundrobin)\n-                        iter.previous();\n-                    if (iter.hasNext())\n-                        iterator.set(iter);\n-                    return entry;\n-                }\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores the last entry released by a thread as in\n-     * {@link ThreadLocal} so it can be the first tried on the next\n-     * acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalStrategy<T> implements Strategy<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalStrategy()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n+            super(maxEntries);\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        protected int startIndex(int size)\n         {\n-            last.set(entry);\n+            return 0;\n         }\n     }\n \n-    /**\n-     * This strategy stores the entries released by a thread in a bounded list\n-     * stored in a {@link ThreadLocal},  so they can be the first tried on the\n-     * next acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalListStrategy<T> implements Strategy<T>\n+    public static class Random<T> extends Pool<T>\n     {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListStrategy(int size)\n+        public Random(int maxEntries)\n         {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+            super(maxEntries);\n         }\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            if (cachedList.size() < cacheSize)\n-                cachedList.add(entry);\n+            return ThreadLocalRandom.current().nextInt(size);\n         }\n     }\n \n-    private abstract static class IndexedStrategy<T> implements Strategy<T>\n+    public static class RoundRobin<T> extends Pool<T>\n     {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (IndexOutOfBoundsException e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n+        private final AtomicInteger next = new AtomicInteger();\n \n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    /**\n-     * This strategy tries to acquire a random entry.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class RandomStrategy<T> extends IndexedStrategy<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n+        public RoundRobin(int maxEntries)\n         {\n-            return ThreadLocalRandom.current().nextInt(size);\n+            super(maxEntries);\n         }\n-    }\n \n-    public static class ThreadIdStrategy<T> extends IndexedStrategy<T>\n-    {\n         @Override\n-        protected int nextIndex(int size)\n+        protected int startIndex(int size)\n         {\n-            return (int)Thread.currentThread().getId() % size;\n+            return next.getAndUpdate(c -> ++c < size ? c : 0);\n         }\n     }\n \n-    /**\n-     * This strategy uses an {@link AtomicInteger} to remember the index\n-     * of the last acquired entry. Calls to acquire will commence trying\n-     * to acquired from the next index.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinStrategy<T> extends IndexedStrategy<T>\n+    public static class Thread<T> extends Pool<T>\n     {\n-        AtomicInteger index = new AtomicInteger();\n+        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n \n-        @Override\n-        protected int nextIndex(int size)\n+        public Thread(int maxEntries)\n         {\n-            return index.getAndUpdate(c -> ++c < size ? c : 0);\n+            super(maxEntries);\n         }\n-    }\n \n-    /**\n-     * This strategy iterates over the entries, starting from a random location,\n-     * to try to acquire an entry.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RandomIterationStrategy<T> implements Strategy<T>\n-    {\n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int r = ThreadLocalRandom.current().nextInt(size);\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(r);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= r)\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            return null;\n+            return 0;\n         }\n-    }\n-\n-    /**\n-     * This strategy commences an iteration over the entries from the\n-     * position after the last successful acquire.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinIterationStrategy<T> implements Strategy<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        public Entry acquire()\n         {\n-            int i = index.get();\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(i);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n-                    return entry;\n-                }\n-            }\n \n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= i)\n+            Entry entry = last.get();\n+            if (entry != null)\n             {\n-                Pool<T>.Entry entry = iter.next();\n                 if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n                     return entry;\n-                }\n-            }\n-\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy keeps a queue of the least recently used entry. If that queue is\n-     * empty, then this strategy falls back to a linear search.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LeastRecentlyUsedStrategy<T> extends LinearSearchStrategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    entry = super.tryAcquire(entries);\n-                else if (!entry.tryAcquire())\n-                    continue;\n-\n-                if (entry != null)\n-                    lru.add(entry);\n-                return entry;\n-            }\n-        }\n-    }\n-\n-    public static class OneStrategyToRuleThemAll<T> implements Strategy<T>\n-    {\n-        private final Mode mode;\n-        private final ThreadLocal<Integer> last;\n-        private final AtomicInteger next;\n-\n-        enum Mode\n-        {\n-            LINEAR,\n-            RANDOM,\n-            THREAD_LOCAL,\n-            ROUND_ROBIN,\n-        }\n-\n-        public OneStrategyToRuleThemAll(Mode mode)\n-        {\n-            this.mode = mode;\n-            last = mode == Mode.THREAD_LOCAL ? ThreadLocal.withInitial(()->0) : null;\n-            next = mode == Mode.ROUND_ROBIN ? new AtomicInteger() : null;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-\n-            int index;\n-            switch (mode)\n-            {\n-                case LINEAR:\n-                    index = 0;\n-                    break;\n-                case RANDOM:\n-                    index = ThreadLocalRandom.current().nextInt(size);\n-                    break;\n-                case THREAD_LOCAL:\n-                    index = last.get();\n-                    break;\n-                case ROUND_ROBIN:\n-                    index = next.getAndUpdate(c -> ++c < size ? c : 0);\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-\n-            for (int tries = size; tries-- > 0;)\n-            {\n-                try\n-                {\n-                    Pool<T>.Entry entry = entries.get(index);\n-                    if (entry != null && entry.tryAcquire())\n-                        return entry;\n-                }\n-                catch (IndexOutOfBoundsException e)\n-                {\n-                    LOGGER.ignore(e);\n-                }\n-                index = (index + 1) % size;\n+                last.set(null);\n             }\n-            return null;\n+            return super.acquire();\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        public boolean release(Entry entry)\n         {\n-            if (last != null)\n-                last.set(entry.index);\n+            boolean released =  super.release(entry);\n+            if (released)\n+                last.set(entry);\n+            return released;\n         }\n     }\n }\n", "next_change": {"commit": "db00126abd11f5734e499bb8a7ab795bc769b879", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c311021e1a..723a79fbde 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -570,87 +618,4 @@ public abstract class Pool<T> implements AutoCloseable, Dumpable\n                 pooled);\n         }\n     }\n-\n-    public static class Linear<T> extends Pool<T>\n-    {\n-        public Linear(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-    }\n-\n-    public static class Random<T> extends Pool<T>\n-    {\n-        public Random(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobin<T> extends Pool<T>\n-    {\n-        private final AtomicInteger next = new AtomicInteger();\n-\n-        public RoundRobin(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return next.getAndUpdate(c -> ++c < size ? c : 0);\n-        }\n-    }\n-\n-    public static class Thread<T> extends Pool<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n-\n-        public Thread(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-\n-        @Override\n-        public Entry acquire()\n-        {\n-\n-            Entry entry = last.get();\n-            if (entry != null)\n-            {\n-                if (entry.tryAcquire())\n-                    return entry;\n-                last.set(null);\n-            }\n-            return super.acquire();\n-        }\n-\n-        @Override\n-        public boolean release(Entry entry)\n-        {\n-            boolean released =  super.release(entry);\n-            if (released)\n-                last.set(entry);\n-            return released;\n-        }\n-    }\n }\n", "next_change": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 723a79fbde..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -603,17 +629,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            int hi = AtomicBiInteger.getHi(encoded);\n-            int lo = AtomicBiInteger.getLo(encoded);\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = hi < 0 ? \"CLOSED\" : lo == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n \n             return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n-                Math.max(hi, 0),\n-                Math.max(lo, 0),\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1ODAyNw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482058027", "body": "`this.strategy = Objects.requireNonNull(planB);`", "bodyText": "this.strategy = Objects.requireNonNull(planB);", "bodyHTML": "<p dir=\"auto\"><code>this.strategy = Objects.requireNonNull(planB);</code></p>", "author": "lorban", "createdAt": "2020-09-02T13:13:49Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e250a4966d93eeb9117b93c6a9030ca7537a8443", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..4b45a8e656 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -590,43 +577,71 @@ public class Pool<T> implements AutoCloseable, Dumpable\n          * Notification an entry has been release.  The notification comes after the entry\n          * has been put back in the pool and it may already have been reacquired before or during this call.\n          * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @param entry The entry to be release\n-         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         * @param entry The entry to be released\n          */\n-        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        default boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n         {\n+            return entry.tryRelease();\n         }\n-    }\n \n-    public interface Strategy<T> extends Cache<T>\n-    {\n-    }\n+        default void reserve(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            entries.add(entry);\n+        }\n+\n+        default boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            if (!entry.tryRemove())\n+            {\n+                if (LOGGER.isDebugEnabled())\n+                    LOGGER.debug(\"Attempt to remove an object from the pool that is still in use: {}\", entry);\n+                return false;\n+            }\n \n-    public static class CacheStrategy<T> implements Strategy<T>\n+            boolean removed = entries.remove(entry);\n+            if (!removed)\n+            {\n+                if (LOGGER.isDebugEnabled())\n+                    LOGGER.debug(\"Attempt to remove an object from the pool that does not exist: {}\", entry);\n+            }\n+            return removed;\n+        }\n+    }\n+    \n+    public static class CompositeStrategy<T> implements Strategy<T>\n     {\n-        final Cache<T> cache;\n-        final Strategy<T> strategy;\n+        final Strategy<T> planA;\n+        final Strategy<T> planB;\n \n-        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n         {\n-            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planA);\n             Objects.requireNonNull(planB);\n-            this.cache = cache;\n-            this.strategy = planB;\n+            this.planA = planA;\n+            this.planB = planB;\n         }\n \n         @Override\n         public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n         {\n-            Pool<T>.Entry entry = cache.acquire(entries);\n-            return entry == null ? strategy.acquire(entries) : entry;\n+            Pool<T>.Entry entry = planA.acquire(entries);\n+            return entry == null ? planB.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        {\n+            if (planA.release(entries, entry))\n+                return true;\n+            if (entry.isOverUsed())\n+                return false;\n+            return planB.release(entries, entry);\n         }\n \n         @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        public boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n         {\n-            cache.released(entries, entry, reusable);\n-            strategy.released(entries, entry, reusable);\n+            return planA.remove(entries, entry) || planB.remove(entries, entry);\n         }\n     }\n \n", "next_change": {"commit": "505321687c6ad3e7bcc6e64e6d1d0b183167b419", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 4b45a8e656..b088f5b4b0 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,33 +646,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n \n         @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n-            Pool<T>.Entry entry = planA.acquire(entries);\n-            return entry == null ? planB.acquire(entries) : entry;\n+            Pool<T>.Entry entry = planA.tryAcquire(entries);\n+            return entry != null ? entry : planB.tryAcquire(entries);\n         }\n \n         @Override\n-        public boolean release(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        public void released(Pool<T>.Entry entry)\n         {\n-            if (planA.release(entries, entry))\n-                return true;\n-            if (entry.isOverUsed())\n-                return false;\n-            return planB.release(entries, entry);\n+            planA.released(entry);\n+            planB.released(entry);\n         }\n \n         @Override\n-        public boolean remove(List<Pool<T>.Entry> entries, Pool<T>.Entry entry)\n+        public void removed(Pool<T>.Entry entry)\n         {\n-            return planA.remove(entries, entry) || planB.remove(entries, entry);\n+            planA.removed(entry);\n+            planB.removed(entry);\n         }\n     }\n \n-    public static class SearchStrategy<T> implements Strategy<T>\n+    public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n         @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n         {\n             for (Pool<T>.Entry e : entries)\n             {\n", "next_change": {"commit": "15ab22647b3e1bc8e791d9a4e6bd16a9d1ed61e8", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex b088f5b4b0..ce5092a04d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -658,15 +659,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             planA.released(entry);\n             planB.released(entry);\n         }\n-\n-        @Override\n-        public void removed(Pool<T>.Entry entry)\n-        {\n-            planA.removed(entry);\n-            planB.removed(entry);\n-        }\n     }\n \n+    /**\n+     * @param <T> The type of entry the strategy is for\n+     */\n     public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n         @Override\n", "next_change": {"commit": "c18a77e8135047393ba289ca3179693b5af4ffad", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex ce5092a04d..89dd157034 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -662,7 +662,9 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * @param <T> The type of entry the strategy is for\n+     * Linear search strategy uses a fresh iterator to scan the\n+     * entries, starting at 0, until it can acquire one.\n+     * @param <T> The type of entry the strategy is for.\n      */\n     public static class LinearSearchStrategy<T> implements Strategy<T>\n     {\n", "next_change": {"commit": "feda65d15aa906a1c0689ea45b26e15a17906beb", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 89dd157034..0f18b89c08 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -661,6 +671,42 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+\n+    /**\n+     * This strategy retries a wrapped strategy looking for\n+     * and Entry\n+     * @param <T> The type of entry the strategy is for.\n+     */\n+    public static class RetryStategy<T> implements Strategy<T>\n+    {\n+        final Strategy<T> strategy;\n+        final int retries;\n+\n+        public RetryStategy(Strategy<T> strategy)\n+        {\n+            this (strategy, -1);\n+        }\n+\n+        public RetryStategy(Strategy<T> strategy, int retries)\n+        {\n+            this.strategy = strategy;\n+            this.retries = retries;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        {\n+            int tries = retries < 0 ? entries.size() : retries;\n+            while (tries-- > 0)\n+            {\n+                Pool<T>.Entry entry = strategy.tryAcquire(entries);\n+                if (entry != null)\n+                    return entry;\n+            }\n+            return null;\n+        }\n+    }\n+\n     /**\n      * Linear search strategy uses a fresh iterator to scan the\n      * entries, starting at 0, until it can acquire one.\n", "next_change": {"commit": "bf520b4d8b559c5ed8551573d780dced775bcc06", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0f18b89c08..c311021e1a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -617,481 +571,86 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /** A pluggable strategy to for pool entry lookup\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Strategy<T>\n+    public static class Linear<T> extends Pool<T>\n     {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entry The entry to be released\n-         */\n-        default void released(Pool<T>.Entry entry)\n+        public Linear(int maxEntries)\n         {\n-        }\n-    }\n-\n-    /** A Composite strategy used to combine multiple other strategies.\n-     * Typically it is used to combine an optimistic strategy (eg {@link RandomStrategy})\n-     * with an exhaustive strategy (eg {@link LinearSearchStrategy}).\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class CompositeStrategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> planA;\n-        final Strategy<T> planB;\n-\n-        public CompositeStrategy(Strategy<T> planA, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(planA);\n-            Objects.requireNonNull(planB);\n-            this.planA = planA;\n-            this.planB = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = planA.tryAcquire(entries);\n-            return entry != null ? entry : planB.tryAcquire(entries);\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            planA.released(entry);\n-            planB.released(entry);\n-        }\n-    }\n-\n-\n-    /**\n-     * This strategy retries a wrapped strategy looking for\n-     * and Entry\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RetryStategy<T> implements Strategy<T>\n-    {\n-        final Strategy<T> strategy;\n-        final int retries;\n-\n-        public RetryStategy(Strategy<T> strategy)\n-        {\n-            this (strategy, -1);\n-        }\n-\n-        public RetryStategy(Strategy<T> strategy, int retries)\n-        {\n-            this.strategy = strategy;\n-            this.retries = retries;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = retries < 0 ? entries.size() : retries;\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = strategy.tryAcquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Linear search strategy uses a fresh iterator to scan the\n-     * entries, starting at 0, until it can acquire one.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LinearSearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores a {@link ListIterator} as a {@link ThreadLocal}\n-     * which is used to scan the list of entries for one that can be acquired.\n-     * Once an entry is acquired, if the strategy is in roundrobin mode, then\n-     * it is left on the next entry, otherwise it is moved back so the current\n-     * entry will be tried again on the next acquire.\n-     * If the iterator reaches the end, then a new one is created.\n-     * The strategy will only try as many times as there are entries.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalIteratorStrategy<T> implements Strategy<T>\n-    {\n-        private final boolean roundrobin;\n-        private final ThreadLocal<ListIterator<Pool<T>.Entry>> iterator = new ThreadLocal<>();\n-\n-        public ThreadLocalIteratorStrategy()\n-        {\n-            this(false);\n-        }\n-\n-        public ThreadLocalIteratorStrategy(boolean roundrobin)\n-        {\n-            this.roundrobin = roundrobin;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            ListIterator<Pool<T>.Entry> iter = iterator.get();\n-            if (iter == null)\n-                iter = entries.listIterator();\n-\n-            for (int tries = entries.size(); tries-- > 0; )\n-            {\n-                if (!iter.hasNext())\n-                {\n-                    iter = entries.listIterator();\n-                    if (!iter.hasNext())\n-                        return null;\n-                }\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry != null && entry.tryAcquire())\n-                {\n-                    if (!roundrobin)\n-                        iter.previous();\n-                    if (iter.hasNext())\n-                        iterator.set(iter);\n-                    return entry;\n-                }\n-            }\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy stores the last entry released by a thread as in\n-     * {@link ThreadLocal} so it can be the first tried on the next\n-     * acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalStrategy<T> implements Strategy<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalStrategy()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n+            super(maxEntries);\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        protected int startIndex(int size)\n         {\n-            last.set(entry);\n+            return 0;\n         }\n     }\n \n-    /**\n-     * This strategy stores the entries released by a thread in a bounded list\n-     * stored in a {@link ThreadLocal},  so they can be the first tried on the\n-     * next acquire.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class ThreadLocalListStrategy<T> implements Strategy<T>\n+    public static class Random<T> extends Pool<T>\n     {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListStrategy(int size)\n+        public Random(int maxEntries)\n         {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+            super(maxEntries);\n         }\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(Pool<T>.Entry entry)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            if (cachedList.size() < cacheSize)\n-                cachedList.add(entry);\n+            return ThreadLocalRandom.current().nextInt(size);\n         }\n     }\n \n-    private abstract static class IndexedStrategy<T> implements Strategy<T>\n+    public static class RoundRobin<T> extends Pool<T>\n     {\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (IndexOutOfBoundsException e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n+        private final AtomicInteger next = new AtomicInteger();\n \n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    /**\n-     * This strategy tries to acquire a random entry.\n-     * This strategy should be combined with an exhaustive strategy such\n-     * as {@link LinearSearchStrategy}.\n-     * @param <T> The type of entry the strategy is for\n-     */\n-    public static class RandomStrategy<T> extends IndexedStrategy<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n+        public RoundRobin(int maxEntries)\n         {\n-            return ThreadLocalRandom.current().nextInt(size);\n+            super(maxEntries);\n         }\n-    }\n \n-    public static class ThreadIdStrategy<T> extends IndexedStrategy<T>\n-    {\n         @Override\n-        protected int nextIndex(int size)\n+        protected int startIndex(int size)\n         {\n-            return (int)Thread.currentThread().getId() % size;\n+            return next.getAndUpdate(c -> ++c < size ? c : 0);\n         }\n     }\n \n-    /**\n-     * This strategy uses an {@link AtomicInteger} to remember the index\n-     * of the last acquired entry. Calls to acquire will commence trying\n-     * to acquired from the next index.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinStrategy<T> extends IndexedStrategy<T>\n+    public static class Thread<T> extends Pool<T>\n     {\n-        AtomicInteger index = new AtomicInteger();\n+        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n \n-        @Override\n-        protected int nextIndex(int size)\n+        public Thread(int maxEntries)\n         {\n-            return index.getAndUpdate(c -> ++c < size ? c : 0);\n+            super(maxEntries);\n         }\n-    }\n \n-    /**\n-     * This strategy iterates over the entries, starting from a random location,\n-     * to try to acquire an entry.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RandomIterationStrategy<T> implements Strategy<T>\n-    {\n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        protected int startIndex(int size)\n         {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int r = ThreadLocalRandom.current().nextInt(size);\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(r);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= r)\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-\n-            return null;\n+            return 0;\n         }\n-    }\n-\n-    /**\n-     * This strategy commences an iteration over the entries from the\n-     * position after the last successful acquire.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class RoundRobinIterationStrategy<T> implements Strategy<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n \n         @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n+        public Entry acquire()\n         {\n-            int i = index.get();\n-\n-            ListIterator<Pool<T>.Entry> iter = entries.listIterator(i);\n-            while (iter.hasNext())\n-            {\n-                Pool<T>.Entry entry = iter.next();\n-                if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n-                    return entry;\n-                }\n-            }\n \n-            iter = entries.listIterator();\n-            while (iter.hasNext() && iter.nextIndex() <= i)\n+            Entry entry = last.get();\n+            if (entry != null)\n             {\n-                Pool<T>.Entry entry = iter.next();\n                 if (entry.tryAcquire())\n-                {\n-                    index.set(iter.nextIndex());\n                     return entry;\n-                }\n-            }\n-\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * This strategy keeps a queue of the least recently used entry. If that queue is\n-     * empty, then this strategy falls back to a linear search.\n-     * @param <T> The type of entry the strategy is for.\n-     */\n-    public static class LeastRecentlyUsedStrategy<T> extends LinearSearchStrategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    entry = super.tryAcquire(entries);\n-                else if (!entry.tryAcquire())\n-                    continue;\n-\n-                if (entry != null)\n-                    lru.add(entry);\n-                return entry;\n-            }\n-        }\n-    }\n-\n-    public static class OneStrategyToRuleThemAll<T> implements Strategy<T>\n-    {\n-        private final Mode mode;\n-        private final ThreadLocal<Integer> last;\n-        private final AtomicInteger next;\n-\n-        enum Mode\n-        {\n-            LINEAR,\n-            RANDOM,\n-            THREAD_LOCAL,\n-            ROUND_ROBIN,\n-        }\n-\n-        public OneStrategyToRuleThemAll(Mode mode)\n-        {\n-            this.mode = mode;\n-            last = mode == Mode.THREAD_LOCAL ? ThreadLocal.withInitial(()->0) : null;\n-            next = mode == Mode.ROUND_ROBIN ? new AtomicInteger() : null;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry tryAcquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-\n-            int index;\n-            switch (mode)\n-            {\n-                case LINEAR:\n-                    index = 0;\n-                    break;\n-                case RANDOM:\n-                    index = ThreadLocalRandom.current().nextInt(size);\n-                    break;\n-                case THREAD_LOCAL:\n-                    index = last.get();\n-                    break;\n-                case ROUND_ROBIN:\n-                    index = next.getAndUpdate(c -> ++c < size ? c : 0);\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-\n-            for (int tries = size; tries-- > 0;)\n-            {\n-                try\n-                {\n-                    Pool<T>.Entry entry = entries.get(index);\n-                    if (entry != null && entry.tryAcquire())\n-                        return entry;\n-                }\n-                catch (IndexOutOfBoundsException e)\n-                {\n-                    LOGGER.ignore(e);\n-                }\n-                index = (index + 1) % size;\n+                last.set(null);\n             }\n-            return null;\n+            return super.acquire();\n         }\n \n         @Override\n-        public void released(Pool<T>.Entry entry)\n+        public boolean release(Entry entry)\n         {\n-            if (last != null)\n-                last.set(entry.index);\n+            boolean released =  super.release(entry);\n+            if (released)\n+                last.set(entry);\n+            return released;\n         }\n     }\n }\n", "next_change": {"commit": "db00126abd11f5734e499bb8a7ab795bc769b879", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c311021e1a..723a79fbde 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -570,87 +618,4 @@ public abstract class Pool<T> implements AutoCloseable, Dumpable\n                 pooled);\n         }\n     }\n-\n-    public static class Linear<T> extends Pool<T>\n-    {\n-        public Linear(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-    }\n-\n-    public static class Random<T> extends Pool<T>\n-    {\n-        public Random(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobin<T> extends Pool<T>\n-    {\n-        private final AtomicInteger next = new AtomicInteger();\n-\n-        public RoundRobin(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return next.getAndUpdate(c -> ++c < size ? c : 0);\n-        }\n-    }\n-\n-    public static class Thread<T> extends Pool<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last = new ThreadLocal<>();\n-\n-        public Thread(int maxEntries)\n-        {\n-            super(maxEntries);\n-        }\n-\n-        @Override\n-        protected int startIndex(int size)\n-        {\n-            return 0;\n-        }\n-\n-        @Override\n-        public Entry acquire()\n-        {\n-\n-            Entry entry = last.get();\n-            if (entry != null)\n-            {\n-                if (entry.tryAcquire())\n-                    return entry;\n-                last.set(null);\n-            }\n-            return super.acquire();\n-        }\n-\n-        @Override\n-        public boolean release(Entry entry)\n-        {\n-            boolean released =  super.release(entry);\n-            if (released)\n-                last.set(entry);\n-            return released;\n-        }\n-    }\n }\n", "next_change": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 723a79fbde..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -603,17 +629,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            int hi = AtomicBiInteger.getHi(encoded);\n-            int lo = AtomicBiInteger.getLo(encoded);\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = hi < 0 ? \"CLOSED\" : lo == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n \n             return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n-                Math.max(hi, 0),\n-                Math.max(lo, 0),\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1ODY1OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482058659", "body": "This comment isn't accurate anymore as the iteration is also part of the strategy.", "bodyText": "This comment isn't accurate anymore as the iteration is also part of the strategy.", "bodyHTML": "<p dir=\"auto\">This comment isn't accurate anymore as the iteration is also part of the strategy.</p>", "author": "lorban", "createdAt": "2020-09-02T13:14:43Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -197,32 +235,14 @@ public Entry acquireAt(int idx)\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n+     * The implementation first tries the pool strategy and then a brute force iteration over entries.", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "505321687c6ad3e7bcc6e64e6d1d0b183167b419", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..b088f5b4b0 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -235,14 +259,13 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n-     * The implementation first tries the pool strategy and then a brute force iteration over entries.\n      * @return an entry from the pool or null if none is available.\n      */\n     public Entry acquire()\n     {\n         if (closed)\n             return null;\n-        return strategy.acquire(entries);\n+        return strategy.tryAcquire(entries);\n     }\n \n     /**\n", "next_change": {"commit": "bf520b4d8b559c5ed8551573d780dced775bcc06", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex b088f5b4b0..c311021e1a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -265,9 +207,33 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     {\n         if (closed)\n             return null;\n-        return strategy.tryAcquire(entries);\n+\n+\n+        int size = entries.size();\n+        if (size == 0)\n+            return null;\n+\n+        int index = startIndex(size);\n+\n+        for (int tries = size; tries-- > 0;)\n+        {\n+            try\n+            {\n+                Pool<T>.Entry entry = entries.get(index);\n+                if (entry != null && entry.tryAcquire())\n+                    return entry;\n+            }\n+            catch (IndexOutOfBoundsException e)\n+            {\n+                LOGGER.ignore(e);\n+            }\n+            index = (index + 1) % size;\n+        }\n+        return null;\n     }\n \n+    protected abstract int startIndex(int size);\n+\n     /**\n      * Utility method to acquire an entry from the pool,\n      * reserving and creating a new entry if necessary.\n", "next_change": {"commit": "db00126abd11f5734e499bb8a7ab795bc769b879", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c311021e1a..723a79fbde 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -232,7 +262,22 @@ public abstract class Pool<T> implements AutoCloseable, Dumpable\n         return null;\n     }\n \n-    protected abstract int startIndex(int size);\n+    protected int startIndex(int size)\n+    {\n+        switch (mode)\n+        {\n+            case LINEAR:\n+                return 0;\n+            case RANDOM:\n+                return ThreadLocalRandom.current().nextInt(size);\n+            case ROUND_ROBIN:\n+                return next.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n+            case THREAD_ID:\n+                return (int)(Thread.currentThread().getId() % size);\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n+    }\n \n     /**\n      * Utility method to acquire an entry from the pool,\n", "next_change": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 723a79fbde..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -262,20 +290,20 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         return null;\n     }\n \n-    protected int startIndex(int size)\n+    private int startIndex(int size)\n     {\n-        switch (mode)\n+        switch (strategy)\n         {\n-            case LINEAR:\n+            case FIRST:\n                 return 0;\n             case RANDOM:\n                 return ThreadLocalRandom.current().nextInt(size);\n             case ROUND_ROBIN:\n-                return next.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n+                return nextIndex.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n             case THREAD_ID:\n                 return (int)(Thread.currentThread().getId() % size);\n             default:\n-                throw new IllegalArgumentException();\n+                throw new IllegalArgumentException(\"Unknown strategy: \" + strategy);\n         }\n     }\n \n", "next_change": {"commit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex f125cd8215..3b70245478 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -303,7 +304,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             case THREAD_ID:\n                 return (int)(Thread.currentThread().getId() % size);\n             default:\n-                throw new IllegalArgumentException(\"Unknown strategy: \" + strategy);\n+                throw new IllegalArgumentException(\"Unknown strategy type: \" + strategyType);\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"oid": "e250a4966d93eeb9117b93c6a9030ca7537a8443", "url": "https://github.com/eclipse/jetty.project/commit/e250a4966d93eeb9117b93c6a9030ca7537a8443", "message": "Feedback from review\n\n + Added reserve and release", "committedDate": "2020-09-02T13:57:26Z", "type": "commit"}, {"oid": "505321687c6ad3e7bcc6e64e6d1d0b183167b419", "url": "https://github.com/eclipse/jetty.project/commit/505321687c6ad3e7bcc6e64e6d1d0b183167b419", "message": "Improved Pool Strategies:\n\n+ reverted to post notifications for removed, reserved and released.\n+ Added a few more strategies that need to be benchmarked, that use the list iterator.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-07T17:30:07Z", "type": "commit"}, {"oid": "d9abdeb3cd71f0405b9b95f8d288baccb2edbf8c", "url": "https://github.com/eclipse/jetty.project/commit/d9abdeb3cd71f0405b9b95f8d288baccb2edbf8c", "message": "Testing all the different strategies\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-08T10:39:07Z", "type": "commit"}, {"oid": "0aa6bc92110ade8c4c96b26e8c074620447857ee", "url": "https://github.com/eclipse/jetty.project/commit/0aa6bc92110ade8c4c96b26e8c074620447857ee", "message": "More simplifications and made LRU work (ish)\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-08T10:51:13Z", "type": "commit"}, {"oid": "15ab22647b3e1bc8e791d9a4e6bd16a9d1ed61e8", "url": "https://github.com/eclipse/jetty.project/commit/15ab22647b3e1bc8e791d9a4e6bd16a9d1ed61e8", "message": "javadoc", "committedDate": "2020-09-08T12:38:01Z", "type": "commit"}, {"oid": "c18a77e8135047393ba289ca3179693b5af4ffad", "url": "https://github.com/eclipse/jetty.project/commit/c18a77e8135047393ba289ca3179693b5af4ffad", "message": "More javadoc\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-08T12:54:40Z", "type": "commit"}, {"oid": "8906678227cc6ab9bc6feadbd0e0bb3533f9781c", "url": "https://github.com/eclipse/jetty.project/commit/8906678227cc6ab9bc6feadbd0e0bb3533f9781c", "message": "JMH Test\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-09T10:01:25Z", "type": "commit"}, {"oid": "feda65d15aa906a1c0689ea45b26e15a17906beb", "url": "https://github.com/eclipse/jetty.project/commit/feda65d15aa906a1c0689ea45b26e15a17906beb", "message": "one strategy\n\nSigned-off-by: gregw <gregw@webtide.com>", "committedDate": "2020-09-10T06:10:02Z", "type": "commit"}, {"oid": "0b0030d9897ce8d95e3167e35b72855cd57db0fd", "url": "https://github.com/eclipse/jetty.project/commit/0b0030d9897ce8d95e3167e35b72855cd57db0fd", "message": "test\n\nSigned-off-by: gregw <gregw@webtide.com>", "committedDate": "2020-09-10T07:18:36Z", "type": "commit"}, {"oid": "bf520b4d8b559c5ed8551573d780dced775bcc06", "url": "https://github.com/eclipse/jetty.project/commit/bf520b4d8b559c5ed8551573d780dced775bcc06", "message": "Split implementations:\n\n + pluggable strategies\n + hard coded\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-10T07:35:11Z", "type": "commit"}, {"oid": "e91578457bbc36b8db01006b3a821d5185ecac1c", "url": "https://github.com/eclipse/jetty.project/commit/e91578457bbc36b8db01006b3a821d5185ecac1c", "message": "More benchmarks", "committedDate": "2020-09-10T09:40:03Z", "type": "commit"}, {"oid": "db00126abd11f5734e499bb8a7ab795bc769b879", "url": "https://github.com/eclipse/jetty.project/commit/db00126abd11f5734e499bb8a7ab795bc769b879", "message": "Built in strategy", "committedDate": "2020-09-10T12:41:48Z", "type": "commit"}, {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "url": "https://github.com/eclipse/jetty.project/commit/69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "message": "removed strategies version and simplified to single configurable solution.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-10T13:40:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3NTQxNA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486475414", "body": "You should move this comment around since you also moved the ThreadLocal variable it speaks about.", "bodyText": "You should move this comment around since you also moved the ThreadLocal variable it speaks about.", "bodyHTML": "<p dir=\"auto\">You should move this comment around since you also moved the ThreadLocal variable it speaks about.</p>", "author": "lorban", "createdAt": "2020-09-10T16:25:47Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -67,21 +67,21 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     };\n \n+    private final int maxEntries;\n+    private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * normally so the cache has no visible effect besides performance.\n+     * with the normal strategy so the cache has no visible effect besides performance.\n      */\n-\n     private final Locker locker = new Locker();\n-    private final int maxEntries;\n-    private final AtomicInteger pending = new AtomicInteger();\n-    private final Strategy strategy;\n     private final ThreadLocal<Entry> cache;\n-    private final AtomicInteger next;\n+    private final AtomicInteger nextIndex;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n", "next_change": {"commit": "225b096122977e3a0c8576559288aa1ba34839b1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex f125cd8215..49b8c89fd7 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -89,19 +89,19 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     public enum Strategy\n     {\n         /**\n-         * The Zero strategy looks for an entry always starting from the firstOth entry.\n+         * A strategy that looks for an entry always starting from the first entry.\n          * It will favour the early entries in the pool, but may contend on them more.\n          */\n         FIRST,\n \n         /**\n-         * The Random strategy looks for an entry by iterating from a random starting\n+         * A strategy that looks for an entry by iterating from a random starting\n          * index.  No entries are favoured and contention is reduced.\n          */\n         RANDOM,\n \n         /**\n-         * The Thread ID strategy uses the {@link Thread#getId()} of the current thread\n+         * A strategy that uses the {@link Thread#getId()} of the current thread\n          * to select a starting point for an entry search.  Whilst not as performant as\n          * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n          * than the number of available threads.\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3Nzk2NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486477965", "body": "This method should go and any caller should be replaced with a Pool using the RR strategy.", "bodyText": "This method should go and any caller should be replaced with a Pool using the RR strategy.", "bodyHTML": "<p dir=\"auto\">This method should go and any caller should be replaced with a Pool using the RR strategy.</p>", "author": "lorban", "createdAt": "2020-09-10T16:29:46Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -176,14 +231,15 @@ public Entry reserve(int allotment)\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated\n     public Entry acquireAt(int idx)", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNDE3NA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486504174", "bodyText": "Yep - waiting for @sbordet to help rework connection pool.", "author": "gregw", "createdAt": "2020-09-10T17:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3Nzk2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c90442d5b368d3d6274acfd81893d37d6755951", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..ab606c5588 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -227,7 +212,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n     /**\n      * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     *\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3ODY3OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486478679", "body": "I'd add a message to the exception, something like\r\n```\r\nthrow new IllegalArgumentException(\"Invalid strategy : \" + strategy);\r\n```", "bodyText": "I'd add a message to the exception, something like\nthrow new IllegalArgumentException(\"Invalid strategy : \" + strategy);", "bodyHTML": "<p dir=\"auto\">I'd add a message to the exception, something like</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"throw new IllegalArgumentException(&quot;Invalid strategy : &quot; + strategy);\"><pre><code>throw new IllegalArgumentException(\"Invalid strategy : \" + strategy);\n</code></pre></div>", "author": "lorban", "createdAt": "2020-09-10T16:30:54Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -204,25 +260,51 @@ public Entry acquire()\n         if (closed)\n             return null;\n \n-        // first check the thread-local cache\n+        int size = entries.size();\n+        if (size == 0)\n+            return null;\n+\n         if (cache != null)\n         {\n-            List<Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n+            Pool<T>.Entry entry = cache.get();\n+            if (entry != null && entry.tryAcquire())\n+                return entry;\n+        }\n+\n+        int index = startIndex(size);\n+\n+        for (int tries = size; tries-- > 0;)\n+        {\n+            try\n+            {\n+                Pool<T>.Entry entry = entries.get(index);\n+                if (entry != null && entry.tryAcquire())\n+                    return entry;\n+            }\n+            catch (IndexOutOfBoundsException e)\n             {\n-                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n+                LOGGER.ignore(e);\n             }\n+            index = (index + 1) % size;\n         }\n+        return null;\n+    }\n \n-        // then iterate the shared list\n-        for (Entry entry : sharedList)\n+    private int startIndex(int size)\n+    {\n+        switch (strategy)\n         {\n-            if (entry.tryAcquire())\n-                return entry;\n+            case LINEAR:\n+                return 0;\n+            case RANDOM:\n+                return ThreadLocalRandom.current().nextInt(size);\n+            case ROUND_ROBIN:\n+                return next.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n+            case THREAD_ID:\n+                return (int)(Thread.currentThread().getId() % size);\n+            default:\n+                throw new IllegalArgumentException();", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -294,16 +294,16 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     {\n         switch (strategy)\n         {\n-            case LINEAR:\n+            case FIRST:\n                 return 0;\n             case RANDOM:\n                 return ThreadLocalRandom.current().nextInt(size);\n             case ROUND_ROBIN:\n-                return next.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n+                return nextIndex.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n             case THREAD_ID:\n                 return (int)(Thread.currentThread().getId() % size);\n             default:\n-                throw new IllegalArgumentException();\n+                throw new IllegalArgumentException(\"Unknown strategy: \" + strategy);\n         }\n     }\n \n", "next_change": {"commit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex f125cd8215..3b70245478 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -303,7 +304,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             case THREAD_ID:\n                 return (int)(Thread.currentThread().getId() % size);\n             default:\n-                throw new IllegalArgumentException(\"Unknown strategy: \" + strategy);\n+                throw new IllegalArgumentException(\"Unknown strategy type: \" + strategyType);\n         }\n     }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTY1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486479656", "body": "This doesn't seem to be used.", "bodyText": "This doesn't seem to be used.", "bodyHTML": "<p dir=\"auto\">This doesn't seem to be used.</p>", "author": "lorban", "createdAt": "2020-09-10T16:32:25Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -500,6 +575,13 @@ boolean tryRelease()\n             return !(overUsed && newMultiplexingCount == 0);\n         }\n \n+        public boolean isOverUsed()", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNTI2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486505269", "bodyText": "I did have a use for it.... but can't remember now... was probably some esoteric strategy or perhaps a unit test.\nI still think it is a nice to have along with the isIdle type methods.", "author": "gregw", "createdAt": "2020-09-10T17:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNDYwMg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489224602", "bodyText": "+1 for keeping the method for JMX and such.", "author": "sbordet", "createdAt": "2020-09-16T07:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTY1Ng=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -575,18 +412,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             return !(overUsed && newMultiplexingCount == 0);\n         }\n \n-        public boolean isOverUsed()\n-        {\n-            int currentMaxUsageCount = maxUsageCount;\n-            int usageCount = state.getHi();\n-            return currentMaxUsageCount > 0 && usageCount >= currentMaxUsageCount;\n-        }\n-\n         /**\n          * Try to mark the entry as removed.\n          * @return true if the entry has to be removed from the containing pool, false otherwise.\n          */\n-        boolean tryRemove()\n+        public boolean tryRemove()\n         {\n             while (true)\n             {\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -416,7 +500,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n          * Try to mark the entry as removed.\n          * @return true if the entry has to be removed from the containing pool, false otherwise.\n          */\n-        public boolean tryRemove()\n+        boolean tryRemove()\n         {\n             while (true)\n             {\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -497,8 +632,9 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n \n         /**\n-         * Try to mark the entry as removed.\n-         * @return true if the entry has to be removed from the containing pool, false otherwise.\n+         * Try to remove the entry by marking it as closed and decrementing the multiplexing counter.\n+         * The multiplexing counter will never go below zero and if it reaches zero, the entry is considered removed.\n+         * @return true if the entry can be removed from the containing pool, false otherwise.\n          */\n         boolean tryRemove()\n         {\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -618,24 +903,26 @@ public class Pool<T> implements AutoCloseable, Dumpable\n                 if (closed)\n                     return false;\n \n-                newMultiplexingCount = AtomicBiInteger.getLo(encoded) - 1;\n-                if (newMultiplexingCount < 0)\n+                newMultiplexCount = AtomicBiInteger.getLo(encoded) - 1;\n+                if (newMultiplexCount < 0)\n                     throw new IllegalStateException(\"Cannot release an already released entry\");\n \n-                if (state.compareAndSet(encoded, usageCount, newMultiplexingCount))\n+                if (state.compareAndSet(encoded, usageCount, newMultiplexCount))\n                     break;\n             }\n \n-            int currentMaxUsageCount = maxUsageCount;\n+            int currentMaxUsageCount = maxUsage;\n             boolean overUsed = currentMaxUsageCount > 0 && usageCount >= currentMaxUsageCount;\n-            return !(overUsed && newMultiplexingCount == 0);\n+            return !(overUsed && newMultiplexCount == 0);\n         }\n \n         /**\n-         * Try to remove the entry by marking it as closed and decrementing the multiplexing counter.\n-         * The multiplexing counter will never go below zero and if it reaches zero, the entry is considered removed.\n+         * <p>Tries to remove the entry by marking it as closed and decrementing the multiplex counter.</p>\n+         * <p>The multiplex counter will never go below zero and if it reaches zero, the entry is considered removed.</p>\n+         *\n          * @return true if the entry can be removed from the containing pool, false otherwise.\n          */\n+        @Override\n         boolean tryRemove()\n         {\n             while (true)\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "message": "Merge commit", "committedDate": null}, {"oid": "2fe01626a5a54583c844b92ae96aa32664366fb1", "committedDate": "2020-07-31 17:47:37 +0200", "message": "Merged branch 'jetty-9.4.x' into 'jetty-10.0.x'."}, {"oid": "d2df0fc2e9eff2ba40fb75a594b11aa98470f06c", "committedDate": "2020-07-31 17:59:55 +0200", "message": "Fixes after review of #4975."}, {"oid": "55f51fa0b5fe96623526ac8ad6d0017389eb0c57", "committedDate": "2020-07-31 19:01:59 +0200", "message": "Fixed copyright headers."}, {"oid": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "committedDate": "2020-08-12 11:42:36 +0200", "message": "Merge remote-tracking branch 'origin/jetty-9.4.x' into jetty-10.0.x"}, {"oid": "ae713d65d945c1c09796e73befc0d59801be85ec", "committedDate": "2020-08-12 16:17:06 +0200", "message": "Merged branch 'jetty-9.4.x' into 'jetty-10.0.x'."}, {"oid": "ac4ea4550eb2e7b29a4a98fe34be7f8cd7e3f11e", "committedDate": "2020-08-13 16:52:35 +0200", "message": "Merged branch 'jetty-9.4.x' into 'jetty-10.0.x'."}, {"oid": "823e713ee4926659045fcd038abfe1970a256d78", "committedDate": "2020-08-22 17:35:25 +0200", "message": "Merged branch 'jetty-9.4.x' into 'jetty-10.0.x'."}, {"oid": "b7a4c36286efb9dcd16b6fe90e10ccfa37727941", "committedDate": "2020-09-16 18:31:51 +0200", "message": "Merge remote-tracking branch 'origin/jetty-9.4.x' into jetty-10.0.x"}, {"oid": "f3f918ade2245524f8b6046ae7629645f4f05a7d", "committedDate": "2020-09-16 23:34:38 +0200", "message": "fix merge"}, {"oid": "b4483d3b2a42e858bf783eb92a602711f26e192c", "committedDate": "2020-11-26 08:59:44 +0100", "message": "fix ArithmeticException \"/ by zero\""}, {"oid": "0ff1bfdd5e4d6db6b6dd78279b6317fe3bbf9c57", "committedDate": "2020-12-01 10:02:31 +0100", "message": "fix bug that messes up the max usage count when the entries' max usage counter overflows"}, {"oid": "44e6f4aeb8bdbcb140ba99ba6480c9127844758b", "committedDate": "2020-12-01 15:18:06 +0100", "message": "sweep the entries list when the max usage count is changed"}, {"oid": "a26731c5eaaf1ec50d5e6beec1f07543913e88b6", "committedDate": "2020-12-01 15:25:25 +0100", "message": "merge jetty-9.4.x into jetty-10.0.x"}, {"oid": "845c6b457a3820e3e9a9d1e1f64a1f7799a47bef", "committedDate": "2020-12-01 15:26:25 +0100", "message": "merge jetty-9.4.x into jetty-10.0.x"}, {"oid": "f0badc5c5ec6ceb8a5d45eccfb0bc284f65471f5", "committedDate": "2020-12-10 16:04:50 -0600", "message": "Issue #5784 - Fixing source header text: EPL-2.0 OR Apache-2.0"}, {"oid": "447823316da54172b50d11396b1cbfb6bd432965", "committedDate": "2020-12-17 14:16:42 +0100", "message": "backport fix for ArithmeticException"}, {"oid": "403d5ec318ffaa20f1f2c0b62df217cfc99ebbe0", "committedDate": "2021-01-07 16:05:24 +0100", "message": "Fixes #5855 - HttpClient may not send queued requests. (#5856)"}, {"oid": "f836f87754bd73c575be7e894da49dade0a6ac45", "committedDate": "2021-01-11 11:23:12 +0100", "message": "Merged branch 'jetty-9.4.x' into 'jetty-10.0.x'."}, {"oid": "0dec883fdad0951b212545ce76deda748c0c4957", "committedDate": "2021-01-12 15:41:56 +0100", "message": "implement connection pool max duration"}, {"oid": "058a488c3079d18e418a367944dd86aed5743e86", "committedDate": "2021-01-12 16:22:11 +0100", "message": "Merge remote-tracking branch origin/jetty-9.4.x into jetty-10.0.x"}, {"oid": "e81c847998fd99fd9a46e2bc15f191e38c2cc33d", "committedDate": "2021-01-21 15:05:57 -0600", "message": "Happy New Year 2021 (Jetty 10 edition)"}, {"oid": "0b97b8415ba9ec7653b514350bd753abe3019daf", "committedDate": "2021-05-19 09:38:28 +0200", "message": "only release connection when channel got released to avoid double connection release race condition"}, {"oid": "61f4dbecdc02be48a2b3c840085220a5703d3754", "committedDate": "2021-05-19 09:38:28 +0200", "message": "review comment: improve readability"}, {"oid": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "committedDate": "2021-09-01 10:27:40 +0200", "message": "Fixes #6603 - HTTP/2 max local stream count exceeded (#6639) (#6682)"}, {"oid": "cb25a83667bde04ba738ccb087baea108ecff992", "committedDate": "2021-12-01 09:39:51 +0100", "message": "Issue #6728 - Prepare for QUIC and HTTP/3 (#7100)"}, {"oid": "cb127793e5d8b5c5730b964392a9a905ba49191d", "committedDate": "2022-01-27 10:42:30 -0600", "message": "Happy New Year 2022 (#7459)"}, {"oid": "2b817f06c64a26003cdbaa25a3769c1c8b9178cf", "committedDate": "2022-07-04 10:38:30 +1000", "message": "Combined ByteBufferPool (#8171)"}, {"oid": "de13ceff3619777dc1213a4dddc40d79ceedb3dd", "committedDate": "2022-09-01 14:45:41 +0200", "message": "Fixes #8493: RemoveIdleDestinations's race condition and improve logging."}, {"oid": "7a7d69a69f4f51772e20813332291189a24e91b1", "committedDate": "2023-02-15 15:22:32 +1100", "message": "Happy no year"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTgyOQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486479829", "body": "This doesn't have to be `public`.", "bodyText": "This doesn't have to be public.", "bodyHTML": "<p dir=\"auto\">This doesn't have to be <code>public</code>.</p>", "author": "lorban", "createdAt": "2020-09-10T16:32:40Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -452,7 +527,7 @@ public boolean remove()\n          * the multiplex count is maxMultiplex and the entry is not closed,\n          * false otherwise.\n          */\n-        boolean tryAcquire()\n+        public boolean tryAcquire()", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNTU2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486505563", "bodyText": "Ah yes! It needed to be public for strategies... but not now!", "author": "gregw", "createdAt": "2020-09-10T17:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTgyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -527,7 +525,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n          * the multiplex count is maxMultiplex and the entry is not closed,\n          * false otherwise.\n          */\n-        public boolean tryAcquire()\n+        boolean tryAcquire()\n         {\n             while (true)\n             {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MDAzOA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486480038", "body": "This index doesn't seem to be used.", "bodyText": "This index doesn't seem to be used.", "bodyHTML": "<p dir=\"auto\">This index doesn't seem to be used.</p>", "author": "lorban", "createdAt": "2020-09-10T16:33:00Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -345,45 +417,48 @@ public void close()\n \n     public int size()\n     {\n-        return sharedList.size();\n+        return entries.size();\n     }\n \n     public Collection<Entry> values()\n     {\n-        return Collections.unmodifiableCollection(sharedList);\n+        return Collections.unmodifiableCollection(entries);\n     }\n \n     @Override\n     public void dump(Appendable out, String indent) throws IOException\n     {\n-        Dumpable.dumpObjects(out, indent, this);\n+        Dumpable.dumpObjects(out, indent, this,\n+            new DumpableCollection(\"entries\", entries));\n     }\n \n     @Override\n     public String toString()\n     {\n-        return String.format(\"%s@%x[size=%d closed=%s entries=%s]\",\n+        return String.format(\"%s@%x[size=%d closed=%s pending=%d]\",\n             getClass().getSimpleName(),\n             hashCode(),\n-            sharedList.size(),\n+            entries.size(),\n             closed,\n-            sharedList);\n+            pending.get());\n     }\n \n     public class Entry\n     {\n         // hi: positive=open/maxUsage counter; negative=closed; MIN_VALUE pending\n         // lo: multiplexing counter\n         private final AtomicBiInteger state;\n+        private final int index;", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNTk3MQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486505971", "bodyText": "oops yes - that was a broken hack for another esoteric round robin", "author": "gregw", "createdAt": "2020-09-10T17:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MDAzOA=="}], "type": "inlineReview", "revised_code": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -448,17 +448,15 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         // hi: positive=open/maxUsage counter; negative=closed; MIN_VALUE pending\n         // lo: multiplexing counter\n         private final AtomicBiInteger state;\n-        private final int index;\n \n         // The pooled item.  This is not volatile as it is set once and then never changed.\n         // Other threads accessing must check the state field above first, so a good before/after\n         // relationship exists to make a memory barrier.\n         private T pooled;\n \n-        Entry(int index)\n+        Entry()\n         {\n             this.state = new AtomicBiInteger(Integer.MIN_VALUE, 0);\n-            this.index = index;\n         }\n \n         /** Enable a reserved entry {@link Entry}.\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MTA1MA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486481050", "body": "I would rename these variables to the actual name of their value: `usageCount` and `multiplexingCount`.", "bodyText": "I would rename these variables to the actual name of their value: usageCount and multiplexingCount.", "bodyHTML": "<p dir=\"auto\">I would rename these variables to the actual name of their value: <code>usageCount</code> and <code>multiplexingCount</code>.</p>", "author": "lorban", "createdAt": "2020-09-10T16:34:37Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -549,12 +631,17 @@ public int getUsageCount()\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n+            int hi = AtomicBiInteger.getHi(encoded);\n+            int lo = AtomicBiInteger.getLo(encoded);", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -631,17 +629,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            int hi = AtomicBiInteger.getHi(encoded);\n-            int lo = AtomicBiInteger.getLo(encoded);\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = hi < 0 ? \"CLOSED\" : lo == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n \n             return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n-                Math.max(hi, 0),\n-                Math.max(lo, 0),\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MzQ3MA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486483470", "body": "Since all the other names of this enum describe the starting index, I'd rename this one to something like `INDEX_ZERO`.", "bodyText": "Since all the other names of this enum describe the starting index, I'd rename this one to something like INDEX_ZERO.", "bodyHTML": "<p dir=\"auto\">Since all the other names of this enum describe the starting index, I'd rename this one to something like <code>INDEX_ZERO</code>.</p>", "author": "lorban", "createdAt": "2020-09-10T16:38:37Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n+\n     private final Locker locker = new Locker();\n     private final int maxEntries;\n-    private final int cacheSize;\n     private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger next;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    public enum Strategy\n+    {\n+        /**\n+         * The Linear strategy looks for an entry always starting from the first entry.\n+         * It will favour the early entries in the pool, but may contend on them more.\n+         */\n+        LINEAR,", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMTI1OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486511259", "bodyText": "How about FIRST?", "author": "gregw", "createdAt": "2020-09-10T17:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MzQ3MA=="}], "type": "inlineReview", "revised_code": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -89,10 +89,10 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     public enum Strategy\n     {\n         /**\n-         * The Linear strategy looks for an entry always starting from the first entry.\n+         * The Zero strategy looks for an entry always starting from the firstOth entry.\n          * It will favour the early entries in the pool, but may contend on them more.\n          */\n-        LINEAR,\n+        FIRST,\n \n         /**\n          * The Random strategy looks for an entry by iterating from a random starting\n", "next_change": {"commit": "225b096122977e3a0c8576559288aa1ba34839b1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex f125cd8215..49b8c89fd7 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -89,19 +89,19 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     public enum Strategy\n     {\n         /**\n-         * The Zero strategy looks for an entry always starting from the firstOth entry.\n+         * A strategy that looks for an entry always starting from the first entry.\n          * It will favour the early entries in the pool, but may contend on them more.\n          */\n         FIRST,\n \n         /**\n-         * The Random strategy looks for an entry by iterating from a random starting\n+         * A strategy that looks for an entry by iterating from a random starting\n          * index.  No entries are favoured and contention is reduced.\n          */\n         RANDOM,\n \n         /**\n-         * The Thread ID strategy uses the {@link Thread#getId()} of the current thread\n+         * A strategy that uses the {@link Thread#getId()} of the current thread\n          * to select a starting point for an entry search.  Whilst not as performant as\n          * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n          * than the number of available threads.\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4Mzk4OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486483989", "body": "`AtomicInteger nextIndex`?", "bodyText": "AtomicInteger nextIndex?", "bodyHTML": "<p dir=\"auto\"><code>AtomicInteger nextIndex</code>?</p>", "author": "lorban", "createdAt": "2020-09-10T16:39:21Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n+\n     private final Locker locker = new Locker();\n     private final int maxEntries;\n-    private final int cacheSize;\n     private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger next;", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -67,21 +67,21 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     };\n \n+    private final int maxEntries;\n+    private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * normally so the cache has no visible effect besides performance.\n+     * with the normal strategy so the cache has no visible effect besides performance.\n      */\n-\n     private final Locker locker = new Locker();\n-    private final int maxEntries;\n-    private final AtomicInteger pending = new AtomicInteger();\n-    private final Strategy strategy;\n     private final ThreadLocal<Entry> cache;\n-    private final AtomicInteger next;\n+    private final AtomicInteger nextIndex;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n", "next_change": {"commit": "225b096122977e3a0c8576559288aa1ba34839b1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex f125cd8215..49b8c89fd7 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -89,19 +89,19 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     public enum Strategy\n     {\n         /**\n-         * The Zero strategy looks for an entry always starting from the firstOth entry.\n+         * A strategy that looks for an entry always starting from the first entry.\n          * It will favour the early entries in the pool, but may contend on them more.\n          */\n         FIRST,\n \n         /**\n-         * The Random strategy looks for an entry by iterating from a random starting\n+         * A strategy that looks for an entry by iterating from a random starting\n          * index.  No entries are favoured and contention is reduced.\n          */\n         RANDOM,\n \n         /**\n-         * The Thread ID strategy uses the {@link Thread#getId()} of the current thread\n+         * A strategy that uses the {@link Thread#getId()} of the current thread\n          * to select a starting point for an entry search.  Whilst not as performant as\n          * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n          * than the number of available threads.\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NDQ4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486484485", "body": "`new ThreadLocal<>()`?", "bodyText": "new ThreadLocal<>()?", "bodyHTML": "<p dir=\"auto\"><code>new ThreadLocal&lt;&gt;()</code>?</p>", "author": "lorban", "createdAt": "2020-09-10T16:40:06Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n+\n     private final Locker locker = new Locker();\n     private final int maxEntries;\n-    private final int cacheSize;\n     private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger next;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    public enum Strategy\n+    {\n+        /**\n+         * The Linear strategy looks for an entry always starting from the first entry.\n+         * It will favour the early entries in the pool, but may contend on them more.\n+         */\n+        LINEAR,\n+\n+        /**\n+         * The Random strategy looks for an entry by iterating from a random starting\n+         * index.  No entries are favoured and contention is reduced.\n+         */\n+        RANDOM,\n+\n+        /**\n+         * The Thread ID strategy uses the {@link Thread#getId()} of the current thread\n+         * to select a starting point for an entry search.  Whilst not as performant as\n+         * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n+         * than the number of available threads.\n+         * No entries are favoured and contention is reduced.\n+         */\n+        THREAD_ID,\n+\n+        /**\n+         * The Round Robin strategy looks for an entry by iterating from a starting point\n+         * that is incremented on every search. This gives similar results to the\n+         * random strategy but with more predictable behaviour.\n+         * No entries are favoured and contention is reduced.\n+         */\n+        ROUND_ROBIN,\n+    }\n+\n     /**\n-     * Construct a Pool with the specified thread-local cache size.\n+     * Construct a Pool with a specified lookup strategy and no\n+     * {@link ThreadLocal} cache.\n      *\n+     * @param strategy The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n-     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n      */\n-    public Pool(int maxEntries, int cacheSize)\n+    public Pool(Strategy strategy, int maxEntries)\n+    {\n+        this(strategy, maxEntries, false);\n+    }\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size and\n+     * an optional {@link ThreadLocal} cache.\n+     * @param strategy The strategy to used for looking up entries.\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cache True if a {@link ThreadLocal} cache should be used to try the most recently released entry.\n+     */\n+    public Pool(Strategy strategy, int maxEntries, boolean cache)\n     {\n         this.maxEntries = maxEntries;\n-        this.cacheSize = cacheSize;\n-        if (cacheSize > 0)\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n-        else\n-            this.cache = null;\n+        this.strategy = strategy;\n+        this.cache = cache ? new ThreadLocal() : null;", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwOTAwNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486509005", "bodyText": "Don't need the threadlocal if not caching", "author": "gregw", "createdAt": "2020-09-10T17:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NDQ4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "68bf2b508004b214483b598314490b0c000c2f8a", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..f125cd8215 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -142,7 +142,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         this.maxEntries = maxEntries;\n         this.strategy = strategy;\n         this.cache = cache ? new ThreadLocal() : null;\n-        next = strategy == Strategy.ROUND_ROBIN ? new AtomicInteger() : null;\n+        nextIndex = strategy == Strategy.ROUND_ROBIN ? new AtomicInteger() : null;\n     }\n \n     public int getReservedCount()\n", "next_change": {"commit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex f125cd8215..3b70245478 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -122,27 +122,27 @@ public class Pool<T> implements AutoCloseable, Dumpable\n      * Construct a Pool with a specified lookup strategy and no\n      * {@link ThreadLocal} cache.\n      *\n-     * @param strategy The strategy to used for looking up entries.\n+     * @param strategyType The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n      */\n-    public Pool(Strategy strategy, int maxEntries)\n+    public Pool(StrategyType strategyType, int maxEntries)\n     {\n-        this(strategy, maxEntries, false);\n+        this(strategyType, maxEntries, false);\n     }\n \n     /**\n      * Construct a Pool with the specified thread-local cache size and\n      * an optional {@link ThreadLocal} cache.\n-     * @param strategy The strategy to used for looking up entries.\n+     * @param strategyType The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n      * @param cache True if a {@link ThreadLocal} cache should be used to try the most recently released entry.\n      */\n-    public Pool(Strategy strategy, int maxEntries, boolean cache)\n+    public Pool(StrategyType strategyType, int maxEntries, boolean cache)\n     {\n         this.maxEntries = maxEntries;\n-        this.strategy = strategy;\n-        this.cache = cache ? new ThreadLocal() : null;\n-        nextIndex = strategy == Strategy.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.strategyType = strategyType;\n+        this.cache = cache ? new ThreadLocal<>() : null;\n+        nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n     }\n \n     public int getReservedCount()\n", "next_change": null}]}}]}}, {"oid": "68bf2b508004b214483b598314490b0c000c2f8a", "url": "https://github.com/eclipse/jetty.project/commit/68bf2b508004b214483b598314490b0c000c2f8a", "message": "updates from review\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-10T17:24:16Z", "type": "commit"}, {"oid": "225b096122977e3a0c8576559288aa1ba34839b1", "url": "https://github.com/eclipse/jetty.project/commit/225b096122977e3a0c8576559288aa1ba34839b1", "message": "better javadoc\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-10T17:26:14Z", "type": "commit"}, {"oid": "46d18190d1acff0fe13e727d7ce219cc4b19aaa8", "url": "https://github.com/eclipse/jetty.project/commit/46d18190d1acff0fe13e727d7ce219cc4b19aaa8", "message": "Merge branch 'jetty-9.4.x' into jetty-9.4.x-PoolStrategy", "committedDate": "2020-09-15T09:55:33Z", "type": "commit"}, {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "url": "https://github.com/eclipse/jetty.project/commit/1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "message": "Updated ConnectionPool classes to use Pool strategies", "committedDate": "2020-09-15T10:57:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMjE3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489222177", "body": "Overriding `listIterator(int)` is not necessary anymore, since we never use it, and we don't leak the `entries` field.", "bodyText": "Overriding listIterator(int) is not necessary anymore, since we never use it, and we don't leak the entries field.", "bodyHTML": "<p dir=\"auto\">Overriding <code>listIterator(int)</code> is not necessary anymore, since we never use it, and we don't leak the <code>entries</code> field.</p>", "author": "sbordet", "createdAt": "2020-09-16T07:29:02Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -56,38 +51,98 @@\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n+    {\n+        @Override\n+        public ListIterator<Entry> listIterator(int index)\n+        {\n+            try\n+            {\n+                return super.listIterator(index);\n+            }\n+            catch (IndexOutOfBoundsException e)\n+            {\n+                return listIterator();\n+            }\n+        }\n+    };", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c90442d5b368d3d6274acfd81893d37d6755951", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 3b70245478..ab606c5588 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -51,21 +50,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n-    {\n-        @Override\n-        public ListIterator<Entry> listIterator(int index)\n-        {\n-            try\n-            {\n-                return super.listIterator(index);\n-            }\n-            catch (IndexOutOfBoundsException e)\n-            {\n-                return listIterator();\n-            }\n-        }\n-    };\n+    private final List<Entry> entries = new CopyOnWriteArrayList<>();\n \n     private final int maxEntries;\n     private final AtomicInteger pending = new AtomicInteger();\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzE0OA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489223148", "body": "There is no \"normal\" strategy, I would rephrase: \"is iterated with the configured StrategyType\".", "bodyText": "There is no \"normal\" strategy, I would rephrase: \"is iterated with the configured StrategyType\".", "bodyHTML": "<p dir=\"auto\">There is no \"normal\" strategy, I would rephrase: \"is iterated with the configured StrategyType\".</p>", "author": "sbordet", "createdAt": "2020-09-16T07:30:37Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -56,38 +51,98 @@\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n+    {\n+        @Override\n+        public ListIterator<Entry> listIterator(int index)\n+        {\n+            try\n+            {\n+                return super.listIterator(index);\n+            }\n+            catch (IndexOutOfBoundsException e)\n+            {\n+                return listIterator();\n+            }\n+        }\n+    };\n+\n+    private final int maxEntries;\n+    private final AtomicInteger pending = new AtomicInteger();\n+    private final StrategyType strategyType;\n+\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * normally so the cache has no visible effect besides performance.\n+     * with the normal strategy so the cache has no visible effect besides performance.", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c90442d5b368d3d6274acfd81893d37d6755951", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 3b70245478..ab606c5588 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -77,7 +62,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * with the normal strategy so the cache has no visible effect besides performance.\n+     * with the configured strategy so the cache has no visible effect besides performance.\n      */\n     private final Locker locker = new Locker();\n     private final ThreadLocal<Entry> cache;\n", "next_change": {"commit": "21f93c6df1faf2612fa510fa8df28de25877ac8e", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex ab606c5588..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -71,6 +71,10 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    /**\n+     * The type of the strategy to use for the pool.\n+     * The strategy primarily determines where iteration over the pool entries begins.\n+     */\n     public enum StrategyType\n     {\n         /**\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzMzMw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489223333", "body": "Javadocs.", "bodyText": "Javadocs.", "bodyHTML": "<p dir=\"auto\">Javadocs.</p>", "author": "sbordet", "createdAt": "2020-09-16T07:30:59Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -56,38 +51,98 @@\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n+    {\n+        @Override\n+        public ListIterator<Entry> listIterator(int index)\n+        {\n+            try\n+            {\n+                return super.listIterator(index);\n+            }\n+            catch (IndexOutOfBoundsException e)\n+            {\n+                return listIterator();\n+            }\n+        }\n+    };\n+\n+    private final int maxEntries;\n+    private final AtomicInteger pending = new AtomicInteger();\n+    private final StrategyType strategyType;\n+\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * normally so the cache has no visible effect besides performance.\n+     * with the normal strategy so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n     private final Locker locker = new Locker();\n-    private final int maxEntries;\n-    private final int cacheSize;\n-    private final AtomicInteger pending = new AtomicInteger();\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger nextIndex;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    public enum StrategyType", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21f93c6df1faf2612fa510fa8df28de25877ac8e", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 3b70245478..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -86,6 +71,10 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    /**\n+     * The type of the strategy to use for the pool.\n+     * The strategy primarily determines where iteration over the pool entries begins.\n+     */\n     public enum StrategyType\n     {\n         /**\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzkwNg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489223906", "body": "Add `@deprecated` javadoc too.", "bodyText": "Add @deprecated javadoc too.", "bodyHTML": "<p dir=\"auto\">Add <code>@deprecated</code> javadoc too.</p>", "author": "sbordet", "createdAt": "2020-09-16T07:31:56Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -176,14 +231,15 @@ public Entry reserve(int allotment)\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyMDE3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489320173", "bodyText": "I guess we can't just remove it... will do in 10", "author": "gregw", "createdAt": "2020-09-16T10:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzkwNg=="}], "type": "inlineReview", "revised_code": {"commit": "6c90442d5b368d3d6274acfd81893d37d6755951", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 3b70245478..ab606c5588 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -227,7 +212,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n     /**\n      * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     *\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNTM3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489225373", "body": "new Pool<>(...) is enough, remove type parameter.", "bodyText": "new Pool<>(...) is enough, remove type parameter.", "bodyHTML": "<p dir=\"auto\">new Pool&lt;&gt;(...) is enough, remove type parameter.</p>", "author": "sbordet", "createdAt": "2020-09-16T07:34:39Z", "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "diffHunk": "@@ -40,20 +50,27 @@\n \n public class PoolTest\n {\n-    public static Stream<Object[]> cacheSize()\n+\n+    interface Factory\n+    {\n+        Pool<String> getPool(int maxSize);\n+    }\n+\n+    public static Stream<Object[]> strategy()\n     {\n         List<Object[]> data = new ArrayList<>();\n-        data.add(new Object[]{0});\n-        data.add(new Object[]{1});\n-        data.add(new Object[]{2});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(FIRST, s)});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(RANDOM, s)});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(FIRST, s, true)});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(ROUND_ROBIN, s)});", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c90442d5b368d3d6274acfd81893d37d6755951", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 78d94fd337..00071f247a 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -59,10 +59,10 @@ public class PoolTest\n     public static Stream<Object[]> strategy()\n     {\n         List<Object[]> data = new ArrayList<>();\n-        data.add(new Object[]{(Factory)s -> new Pool<String>(FIRST, s)});\n-        data.add(new Object[]{(Factory)s -> new Pool<String>(RANDOM, s)});\n-        data.add(new Object[]{(Factory)s -> new Pool<String>(FIRST, s, true)});\n-        data.add(new Object[]{(Factory)s -> new Pool<String>(ROUND_ROBIN, s)});\n+        data.add(new Object[]{(Factory)s -> new Pool<>(FIRST, s)});\n+        data.add(new Object[]{(Factory)s -> new Pool<>(RANDOM, s)});\n+        data.add(new Object[]{(Factory)s -> new Pool<>(FIRST, s, true)});\n+        data.add(new Object[]{(Factory)s -> new Pool<>(ROUND_ROBIN, s)});\n         return data.stream();\n     }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNjQxNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489226415", "body": "This test contains an unused `e2` variable that I would instead add to the asserts, for example, to confirm that it is in use even after removing `e1`, or that `e2 == e1`, etc.", "bodyText": "This test contains an unused e2 variable that I would instead add to the asserts, for example, to confirm that it is in use even after removing e1, or that e2 == e1, etc.", "bodyHTML": "<p dir=\"auto\">This test contains an unused <code>e2</code> variable that I would instead add to the asserts, for example, to confirm that it is in use even after removing <code>e1</code>, or that <code>e2 == e1</code>, etc.</p>", "author": "sbordet", "createdAt": "2020-09-16T07:36:34Z", "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "diffHunk": "@@ -331,34 +347,44 @@ public void testMaxUsageCount(int cacheSize)\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testMaxMultiplex(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testMaxMultiplex(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(2, cacheSize);\n+        Pool<String> pool = factory.getPool(2);\n         pool.setMaxMultiplex(3);\n-        pool.reserve(-1).enable(\"aaa\", false);\n-        pool.reserve(-1).enable(\"bbb\", false);\n \n-        Pool<String>.Entry e1 = pool.acquire();\n-        Pool<String>.Entry e2 = pool.acquire();\n-        Pool<String>.Entry e3 = pool.acquire();\n-        Pool<String>.Entry e4 = pool.acquire();\n-        assertThat(e1.getPooled(), equalTo(\"aaa\"));\n-        assertThat(e1, sameInstance(e2));\n-        assertThat(e1, sameInstance(e3));\n-        assertThat(e4.getPooled(), equalTo(\"bbb\"));\n-        assertThat(pool.release(e1), is(true));\n-        Pool<String>.Entry e5 = pool.acquire();\n-        assertThat(e2, sameInstance(e5));\n-        Pool<String>.Entry e6 = pool.acquire();\n-        assertThat(e4, sameInstance(e6));\n+        Map<String, AtomicInteger> counts = new HashMap<>();\n+        AtomicInteger a = new AtomicInteger();\n+        AtomicInteger b = new AtomicInteger();\n+        counts.put(\"a\", a);\n+        counts.put(\"b\", b);\n+        pool.reserve(-1).enable(\"a\", false);\n+        pool.reserve(-1).enable(\"b\", false);\n+\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+\n+        assertThat(a.get(), greaterThan(0));\n+        assertThat(a.get(), lessThanOrEqualTo(3));\n+        assertThat(b.get(), greaterThan(0));\n+        assertThat(b.get(), lessThanOrEqualTo(3));\n+\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+\n+        assertThat(a.get(), is(3));\n+        assertThat(b.get(), is(3));\n+\n+        assertNull(pool.acquire());\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testRemoveMultiplexed(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testRemoveMultiplexed(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(1, cacheSize);\n+        Pool<String> pool = factory.getPool(1);\n         pool.setMaxMultiplex(2);\n         pool.reserve(-1).enable(\"aaa\", false);", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c90442d5b368d3d6274acfd81893d37d6755951", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 78d94fd337..00071f247a 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -389,7 +389,12 @@ public class PoolTest\n         pool.reserve(-1).enable(\"aaa\", false);\n \n         Pool<String>.Entry e1 = pool.acquire();\n+        assertThat(e1, notNullValue());\n         Pool<String>.Entry e2 = pool.acquire();\n+        assertThat(e2, notNullValue());\n+        assertThat(e2, sameInstance(e1));\n+        assertThat(e2.getUsageCount(), is(2));\n+\n         assertThat(pool.values().stream().findFirst().get().isIdle(), is(false));\n \n         assertThat(pool.remove(e1), is(false));\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNzM1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489227356", "body": "This test contains an unused variable `e2` that I would use in asserts, at least to verify that `e2 == e1`.", "bodyText": "This test contains an unused variable e2 that I would use in asserts, at least to verify that e2 == e1.", "bodyHTML": "<p dir=\"auto\">This test contains an unused variable <code>e2</code> that I would use in asserts, at least to verify that <code>e2 == e1</code>.</p>", "author": "sbordet", "createdAt": "2020-09-16T07:38:19Z", "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "diffHunk": "@@ -506,10 +532,10 @@ public void testMultiplexMaxUsageReachedAcquireThenReleaseThenRemove(int cacheSi\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testUsageCountAfterReachingMaxMultiplexLimit(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testUsageCountAfterReachingMaxMultiplexLimit(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(1, cacheSize);\n+        Pool<String> pool = factory.getPool(1);\n         pool.setMaxMultiplex(2);\n         pool.setMaxUsageCount(10);\n         pool.reserve(-1).enable(\"aaa\", false);", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c90442d5b368d3d6274acfd81893d37d6755951", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 78d94fd337..00071f247a 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -543,6 +548,7 @@ public class PoolTest\n         Pool<String>.Entry e1 = pool.acquire();\n         assertThat(e1.getUsageCount(), is(1));\n         Pool<String>.Entry e2 = pool.acquire();\n+        assertThat(e2, sameInstance(e1));\n         assertThat(e1.getUsageCount(), is(2));\n         assertThat(pool.acquire(), nullValue());\n         assertThat(e1.getUsageCount(), is(2));\n", "next_change": null}]}}, {"oid": "f9773d5ae3ab72c189fae474bd138951b5b5e73a", "url": "https://github.com/eclipse/jetty.project/commit/f9773d5ae3ab72c189fae474bd138951b5b5e73a", "message": "Small javadocs fixes.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-09-16T07:40:14Z", "type": "commit"}, {"oid": "4504fee50b8ebd30becb0e402a7d831bded3e1ea", "url": "https://github.com/eclipse/jetty.project/commit/4504fee50b8ebd30becb0e402a7d831bded3e1ea", "message": "Merge branch 'jetty-9.4.x' into jetty-9.4.x-PoolStrategy", "committedDate": "2020-09-16T10:00:27Z", "type": "commit"}, {"oid": "6c90442d5b368d3d6274acfd81893d37d6755951", "url": "https://github.com/eclipse/jetty.project/commit/6c90442d5b368d3d6274acfd81893d37d6755951", "message": "Updates from review", "committedDate": "2020-09-16T10:13:12Z", "type": "commit"}, {"oid": "21f93c6df1faf2612fa510fa8df28de25877ac8e", "url": "https://github.com/eclipse/jetty.project/commit/21f93c6df1faf2612fa510fa8df28de25877ac8e", "message": "javadoc", "committedDate": "2020-09-16T16:24:44Z", "type": "commit"}]}