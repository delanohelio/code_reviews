{"pr_number": 11877, "pr_title": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "pr_author": "wsry", "pr_createdAt": "2020-04-23T08:37:09Z", "pr_url": "https://github.com/apache/flink/pull/11877", "merge_commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "timeline": [{"oid": "929403a9ae1b734c4e72a4585862f994d8c1f5e9", "url": "https://github.com/apache/flink/commit/929403a9ae1b734c4e72a4585862f994d8c1f5e9", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-04-23T10:40:36Z", "type": "forcePushed"}, {"oid": "ca6f75c37da358874cc38d7998bce5c4445feff5", "url": "https://github.com/apache/flink/commit/ca6f75c37da358874cc38d7998bce5c4445feff5", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-04-27T06:28:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NjE4OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422466188", "body": "Make the following condition out of `synchronized` part, then we do not need to touch the lock for most of the cases.\r\n```\r\nCheckpointOptions options = barrier.getCheckpointOptions();\r\nif (!(initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()))  {\r\n     return;\r\n}\r\n```", "bodyText": "Make the following condition out of synchronized part, then we do not need to touch the lock for most of the cases.\nCheckpointOptions options = barrier.getCheckpointOptions();\nif (!(initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()))  {\n     return;\n}", "bodyHTML": "<p dir=\"auto\">Make the following condition out of <code>synchronized</code> part, then we do not need to touch the lock for most of the cases.</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"CheckpointOptions options = barrier.getCheckpointOptions();\nif (!(initialCredit == 0 &amp;&amp; options.isExactlyOnceMode() &amp;&amp; !options.isUnalignedCheckpoint()))  {\n     return;\n}\n\"><pre><code>CheckpointOptions options = barrier.getCheckpointOptions();\nif (!(initialCredit == 0 &amp;&amp; options.isExactlyOnceMode() &amp;&amp; !options.isUnalignedCheckpoint()))  {\n     return;\n}\n</code></pre></div>", "author": "zhijiangW", "createdAt": "2020-05-09T07:54:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -428,6 +423,23 @@ public void notifyBufferDestroyed() {\n \t\t// Nothing to do actually.\n \t}\n \n+\t@Override\n+\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3MDcyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422970729", "bodyText": "It might be better to trigger this action by netty thread when received this barrier immediately. Otherwise the task processing might delay much time to better reuse the floating buffers for other channels.", "author": "zhijiangW", "createdAt": "2020-05-11T11:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NjE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3MjYyMA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422972620", "bodyText": "Considering the race condition between this operation and canceler task, it might involve in potential conflicts and deadlock case if removeBufferListener and adjust isWaitingForFloatingBuffers here. Let me think whether we can lazy remove the listener and adjust isWaitingForFloatingBuffers by reusing the existing process RemoteInputChannel#notifyBufferAvailable.", "author": "zhijiangW", "createdAt": "2020-05-11T11:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NjE4OA=="}], "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex ff2103389d6..86a8977f8ee 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -369,75 +299,30 @@ public class RemoteInputChannel extends InputChannel implements BufferRecycler,\n \t\treturn receivedBuffers.poll();\n \t}\n \n-\t/**\n-\t * The Buffer pool notifies this channel of an available floating buffer. If the channel is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased\n-\t * by one.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t *  \tmore floating buffers.\n-\t */\n-\t@Override\n-\tpublic NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tNotificationResult notificationResult = NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tcheckState(isWaitingForFloatingBuffers,\n-\t\t\t\t\t\"This channel should be waiting for floating buffers.\");\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllResources() already released buffers inside bufferQueue\n-\t\t\t\t// -> then isReleased is set correctly\n-\t\t\t\t// 2) releaseAllResources() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (isReleased.get() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n+\t@VisibleForTesting\n+\tBufferManager getBufferManager() {\n+\t\treturn bufferManager;\n+\t}\n \n-\t\t\tif (unannouncedCredit.getAndAdd(1) == 0) {\n-\t\t\t\tnotifyCreditAvailable();\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tsetError(t);\n-\t\t}\n-\t\treturn notificationResult;\n+\t@VisibleForTesting\n+\tPartitionRequestClient getPartitionRequestClient() {\n+\t\treturn partitionRequestClient;\n \t}\n \n+\t/**\n+\t * The unannounced credit is increased by the given amount and might notify\n+\t * increased credit to the producer.\n+\t */\n \t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n+\tpublic void notifyBufferAvailable(int numAvailableBuffers) {\n+\t\tif (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+\t\t\tnotifyCreditAvailable();\n+\t\t}\n \t}\n \n \t@Override\n \tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\t\tboolean removed = inputGate.getBufferProvider().removeBufferListener(this);\n-\t\t\t\t\tcheckState(removed, \"Listener should be removed.\");\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t}\n-\n-\t\t\t\tint bufferReleased = bufferQueue.releaseAllFloatingBuffers();\n-\t\t\t\tnumRequiredBuffers += bufferReleased;\n-\t\t\t}\n-\t\t}\n+\t\tbufferManager.onCheckpointBarrier(barrier, initialCredit);\n \t}\n \n \t@Override\n", "next_change": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 86a8977f8ee..861d407262c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -322,7 +326,10 @@ public class RemoteInputChannel extends InputChannel {\n \n \t@Override\n \tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tbufferManager.onCheckpointBarrier(barrier, initialCredit);\n+\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n+\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n+\t\t\tbufferManager.unregisterBufferListenerAndReleaseFloatingBuffers();\n+\t\t}\n \t}\n \n \t@Override\n", "next_change": {"commit": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 861d407262c..5e125aef0d0 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -328,7 +326,7 @@ public class RemoteInputChannel extends InputChannel {\n \tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n \t\tCheckpointOptions options = barrier.getCheckpointOptions();\n \t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tbufferManager.unregisterBufferListenerAndReleaseFloatingBuffers();\n+\t\t\tbufferManager.releaseFloatingBuffers(true);\n \t\t}\n \t}\n \n", "next_change": {"commit": "a933d700d53457d7743252c2a3c735a04fbd87f8", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 5e125aef0d0..82a1243aa5c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -322,8 +322,7 @@ public class RemoteInputChannel extends InputChannel {\n \t\t}\n \t}\n \n-\t@Override\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n+\tprivate void onCheckpointBarrier(CheckpointBarrier barrier) {\n \t\tCheckpointOptions options = barrier.getCheckpointOptions();\n \t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n \t\t\tbufferManager.releaseFloatingBuffers(true);\n", "next_change": {"commit": "fb4c607a5c4780729143d458b1c7633adcba59bf", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 82a1243aa5c..23d440c00b5 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -322,11 +323,8 @@ public class RemoteInputChannel extends InputChannel {\n \t\t}\n \t}\n \n-\tprivate void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tbufferManager.releaseFloatingBuffers(true);\n-\t\t}\n+\tprivate void onExactlyOnceAlignedCheckpointBarrier() {\n+\t\tbufferManager.releaseFloatingBuffers(true);\n \t}\n \n \t@Override\n", "next_change": {"commit": "a51d7760c34c0652321427daa153070874c54a61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 23d440c00b5..22630fed197 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -323,7 +323,7 @@ public class RemoteInputChannel extends InputChannel {\n \t\t}\n \t}\n \n-\tprivate void onExactlyOnceAlignedCheckpointBarrier() {\n+\tprivate void onCheckpointBarrier() {\n \t\tbufferManager.releaseFloatingBuffers(true);\n \t}\n \n", "next_change": {"commit": "7dfdb8bfa05b783479697bd3aa3de3fac2628482", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 22630fed197..28ed2c1b156 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -328,9 +334,9 @@ public class RemoteInputChannel extends InputChannel {\n \t}\n \n \t@Override\n-\tpublic void resumeConsumption() {\n+\tpublic void resumeConsumption() throws IOException {\n \t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n+\t\tcheckPartitionRequestQueueInitialized();\n \n \t\t// notifies the producer that this channel is ready to\n \t\t// unblock from checkpoint and resume data consumption\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 28ed2c1b156..3e976686f91 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -41,521 +51,750 @@ import javax.annotation.concurrent.GuardedBy;\n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n-/**\n- * An input channel, which requests a remote partition queue.\n- */\n+/** An input channel, which requests a remote partition queue. */\n public class RemoteInputChannel extends InputChannel {\n-\n-\t/** ID to distinguish this channel from other channels sharing the same TCP connection. */\n-\tprivate final InputChannelID id = new InputChannelID();\n-\n-\t/** The connection to use to request the remote partition. */\n-\tprivate final ConnectionID connectionId;\n-\n-\t/** The connection manager to use connect to the remote partition provider. */\n-\tprivate final ConnectionManager connectionManager;\n-\n-\t/**\n-\t * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n-\t * is consumed by the receiving task thread.\n-\t */\n-\tprivate final ArrayDeque<Buffer> receivedBuffers = new ArrayDeque<>();\n-\n-\t/**\n-\t * Flag indicating whether this channel has been released. Either called by the receiving task\n-\t * thread or the task manager actor.\n-\t */\n-\tprivate final AtomicBoolean isReleased = new AtomicBoolean();\n-\n-\t/** Client to establish a (possibly shared) TCP connection and request the partition. */\n-\tprivate volatile PartitionRequestClient partitionRequestClient;\n-\n-\t/**\n-\t * The next expected sequence number for the next buffer. This is modified by the network\n-\t * I/O thread only.\n-\t */\n-\tprivate int expectedSequenceNumber = 0;\n-\n-\t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate final int initialCredit;\n-\n-\t/** The number of available buffers that have not been announced to the producer yet. */\n-\tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n-\n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n-\n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n-\n-\tprivate final BufferManager bufferManager;\n-\n-\tpublic RemoteInputChannel(\n-\t\tSingleInputGate inputGate,\n-\t\tint channelIndex,\n-\t\tResultPartitionID partitionId,\n-\t\tConnectionID connectionId,\n-\t\tConnectionManager connectionManager,\n-\t\tint initialBackOff,\n-\t\tint maxBackoff,\n-\t\tint networkBuffersPerChannel,\n-\t\tCounter numBytesIn,\n-\t\tCounter numBuffersIn) {\n-\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, numBytesIn, numBuffersIn);\n-\n-\t\tthis.initialCredit = networkBuffersPerChannel;\n-\t\tthis.connectionId = checkNotNull(connectionId);\n-\t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n-\t}\n-\n-\t/**\n-\t * Assigns exclusive buffers to this input channel, and this method should be called only once\n-\t * after this input channel is created.\n-\t */\n-\tvoid assignExclusiveSegments() throws IOException {\n-\t\tcheckState(bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n-\t\t\t\"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n-\n-\t\tif (initialCredit > 0) {\n-\t\t\tbufferManager.requestExclusiveBuffers();\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests a remote subpartition.\n-\t */\n-\t@VisibleForTesting\n-\t@Override\n-\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n-\t\tif (partitionRequestClient == null) {\n-\t\t\t// Create a client and request the partition\n-\t\t\ttry {\n-\t\t\t\tpartitionRequestClient = connectionManager.createPartitionRequestClient(connectionId);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\t// IOExceptions indicate that we could not open a connection to the remote TaskExecutor\n-\t\t\t\tthrow new PartitionConnectionException(partitionId, e);\n-\t\t\t}\n-\n-\t\t\tpartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Retriggers a remote subpartition request.\n-\t */\n-\tvoid retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n-\t\tcheckPartitionRequestQueueInitialized();\n-\n-\t\tif (increaseBackoff()) {\n-\t\t\tpartitionRequestClient.requestSubpartition(\n-\t\t\t\tpartitionId, subpartitionIndex, this, getCurrentBackoff());\n-\t\t} else {\n-\t\t\tfailPartitionRequest();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tOptional<BufferAndAvailability> getNextBuffer() throws IOException {\n-\t\tcheckPartitionRequestQueueInitialized();\n-\n-\t\tfinal Buffer next;\n-\t\tfinal boolean moreAvailable;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tnext = receivedBuffers.poll();\n-\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n-\t\t}\n-\n-\t\tif (next == null) {\n-\t\t\tif (isReleased.get()) {\n-\t\t\t\tthrow new CancelTaskException(\"Queried for a buffer after channel has been released.\");\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalStateException(\"There should always have queued buffers for unreleased channel.\");\n-\t\t\t}\n-\t\t}\n-\n-\t\tnumBytesIn.inc(next.getSize());\n-\t\tnumBuffersIn.inc();\n-\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable));\n-\t}\n-\n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlastRequestedCheckpointId = checkpointId;\n-\n-\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\tcheckpointId,\n-\t\t\t\tchannelInfo,\n-\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\tCloseableIterator.fromList(inflightBuffers, Buffer::recycleBuffer));\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tvoid sendTaskEvent(TaskEvent event) throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Tried to send task event to producer after channel has been released.\");\n-\t\tcheckPartitionRequestQueueInitialized();\n-\n-\t\tpartitionRequestClient.sendTaskEvent(partitionId, event, this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n-\t}\n-\n-\t/**\n-\t * Releases all exclusive and floating buffers, closes the partition request client.\n-\t */\n-\t@Override\n-\tvoid releaseAllResources() throws IOException {\n-\t\tif (isReleased.compareAndSet(false, true)) {\n-\n-\t\t\tfinal ArrayDeque<Buffer> releasedBuffers;\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\treleasedBuffers = new ArrayDeque<>(receivedBuffers);\n-\t\t\t\treceivedBuffers.clear();\n-\t\t\t}\n-\t\t\tbufferManager.releaseAllBuffers(releasedBuffers);\n-\n-\t\t\t// The released flag has to be set before closing the connection to ensure that\n-\t\t\t// buffers received concurrently with closing are properly recycled.\n-\t\t\tif (partitionRequestClient != null) {\n-\t\t\t\tpartitionRequestClient.close(this);\n-\t\t\t} else {\n-\t\t\t\tconnectionManager.closeOpenChannelConnections(connectionId);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void failPartitionRequest() {\n-\t\tsetError(new PartitionNotFoundException(partitionId));\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Credit-based\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n-\t */\n-\tprivate void notifyCreditAvailable() throws IOException {\n-\t\tcheckPartitionRequestQueueInitialized();\n-\n-\t\tpartitionRequestClient.notifyCreditAvailable(this);\n-\t}\n-\n-\tpublic int getNumberOfAvailableBuffers() {\n-\t\treturn bufferManager.getNumberOfAvailableBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn bufferManager.getNumberOfRequiredBuffers();\n-\t}\n-\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\treturn bufferManager.isWaitingForFloatingBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n-\t}\n-\n-\t@VisibleForTesting\n-\tBufferManager getBufferManager() {\n-\t\treturn bufferManager;\n-\t}\n-\n-\t@VisibleForTesting\n-\tPartitionRequestClient getPartitionRequestClient() {\n-\t\treturn partitionRequestClient;\n-\t}\n-\n-\t/**\n-\t * The unannounced credit is increased by the given amount and might notify\n-\t * increased credit to the producer.\n-\t */\n-\t@Override\n-\tpublic void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n-\t\tif (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\tprivate void onCheckpointBarrier() {\n-\t\tbufferManager.releaseFloatingBuffers(true);\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption() throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckPartitionRequestQueueInitialized();\n-\n-\t\t// notifies the producer that this channel is ready to\n-\t\t// unblock from checkpoint and resume data consumption\n-\t\tpartitionRequestClient.resumeConsumption(this);\n-\t}\n-\n-\t/**\n-\t * Called by netty thread to request buffers and generate {@link ResumeConsumption} message.\n-\t */\n-\tpublic ResumeConsumption getResumeConsumptionMessage() throws IOException {\n-\t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n-\t\tcheckState(getNumberOfAvailableBuffers() == initialCredit, \"Illegal number of available buffers.\");\n-\t\tcheckState(!isWaitingForFloatingBuffers(), \"Should not be waiting for floating buffers.\");\n-\n-\t\tif (initialCredit > 0) {\n-\t\t\treturn new ResumeConsumption(id, initialCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t\t}\n-\n-\t\tint availableCredit = bufferManager.requestFloatingBuffers(0);\n-\t\treturn new ResumeConsumption(id, availableCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network I/O notifications (called by network I/O thread)\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Gets the currently unannounced credit.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getUnannouncedCredit() {\n-\t\treturn unannouncedCredit.get();\n-\t}\n-\n-\t/**\n-\t * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n-\t}\n-\n-\t/**\n-\t * Gets the current number of received buffers which have not been processed yet.\n-\t *\n-\t * @return Buffers queued for processing.\n-\t */\n-\tpublic int getNumberOfQueuedBuffers() {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treturn receivedBuffers.size();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn Math.max(0, receivedBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n-\t}\n-\n-\tpublic int unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n-\t}\n-\n-\tpublic InputChannelID getInputChannelId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic int getInitialCredit() {\n-\t\treturn initialCredit;\n-\t}\n-\n-\tpublic BufferProvider getBufferProvider() throws IOException {\n-\t\tif (isReleased.get()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn inputGate.getBufferProvider();\n-\t}\n-\n-\t/**\n-\t * Requests buffer from input channel directly for receiving network data.\n-\t * It should always return an available buffer in credit-based mode unless\n-\t * the channel has been released.\n-\t *\n-\t * @return The available buffer.\n-\t */\n-\t@Nullable\n-\tpublic Buffer requestBuffer() {\n-\t\treturn bufferManager.requestBuffer();\n-\t}\n-\n-\t/**\n-\t * Receives the backlog from the producer's buffer response. Floating buffers will\n-\t * be requested from the {@link BufferManager} according to the announced backlog,\n-\t * and then it will notify unannounced credits to the producer.\n-\t *\n-\t * @param backlog Number of the announced backlog from producer.\n-\t */\n-\tpublic void onSenderBacklog(int backlog) throws IOException {\n-\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));\n-\t}\n-\n-\tpublic void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean recycleBuffer = true;\n-\n-\t\ttry {\n-\t\t\tif (expectedSequenceNumber != sequenceNumber) {\n-\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tfinal boolean wasEmpty;\n-\t\t\tfinal CheckpointBarrier notifyReceivedBarrier;\n-\t\t\tfinal Buffer notifyReceivedBuffer;\n-\t\t\tfinal BufferReceivedListener listener = inputGate.getBufferReceivedListener();\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after releaseAllResources() released all buffers from receivedBuffers\n-\t\t\t\t// (see above for details).\n-\t\t\t\tif (isReleased.get()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n-\n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n-\t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n-\t\t\t}\n-\t\t\trecycleBuffer = false;\n-\n-\t\t\t++expectedSequenceNumber;\n-\n-\t\t\tif (wasEmpty) {\n-\t\t\t\tnotifyChannelNonEmpty();\n-\t\t\t}\n-\n-\t\t\tif (backlog >= 0) {\n-\t\t\t\tonSenderBacklog(backlog);\n-\t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tif (notifyReceivedBarrier.isCheckpoint()) {\n-\t\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t\t}\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n-\n-\t\t\tif (buffer.getDataType().isBlockingUpstream()) {\n-\t\t\t\tonCheckpointBarrier();\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tif (recycleBuffer) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean success = false;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tif (!isReleased.get()) {\n-\t\t\t\tif (expectedSequenceNumber == sequenceNumber) {\n-\t\t\t\t\texpectedSequenceNumber++;\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t} else {\n-\t\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (success && backlog >= 0) {\n-\t\t\tonSenderBacklog(backlog);\n-\t\t}\n-\t}\n-\n-\tpublic void onFailedPartitionRequest() {\n-\t\tinputGate.triggerPartitionStateCheck(partitionId);\n-\t}\n-\n-\tpublic void onError(Throwable cause) {\n-\t\tsetError(cause);\n-\t}\n-\n-\tprivate void checkPartitionRequestQueueInitialized() throws IOException {\n-\t\tcheckError();\n-\t\tcheckState(partitionRequestClient != null,\n-\t\t\t\t\"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n-\t}\n-\n-\tprivate static class BufferReorderingException extends IOException {\n-\n-\t\tprivate static final long serialVersionUID = -888282210356266816L;\n-\n-\t\tprivate final int expectedSequenceNumber;\n-\n-\t\tprivate final int actualSequenceNumber;\n-\n-\t\tBufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n-\t\t\tthis.expectedSequenceNumber = expectedSequenceNumber;\n-\t\t\tthis.actualSequenceNumber = actualSequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String getMessage() {\n-\t\t\treturn String.format(\"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n-\t\t\t\texpectedSequenceNumber, actualSequenceNumber);\n-\t\t}\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(RemoteInputChannel.class);\n+\n+    private static final int NONE = -1;\n+\n+    /** ID to distinguish this channel from other channels sharing the same TCP connection. */\n+    private final InputChannelID id = new InputChannelID();\n+\n+    /** The connection to use to request the remote partition. */\n+    private final ConnectionID connectionId;\n+\n+    /** The connection manager to use connect to the remote partition provider. */\n+    private final ConnectionManager connectionManager;\n+\n+    /**\n+     * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n+     * is consumed by the receiving task thread.\n+     */\n+    private final PrioritizedDeque<SequenceBuffer> receivedBuffers = new PrioritizedDeque<>();\n+\n+    /**\n+     * Flag indicating whether this channel has been released. Either called by the receiving task\n+     * thread or the task manager actor.\n+     */\n+    private final AtomicBoolean isReleased = new AtomicBoolean();\n+\n+    /** Client to establish a (possibly shared) TCP connection and request the partition. */\n+    private volatile PartitionRequestClient partitionRequestClient;\n+\n+    /** The next expected sequence number for the next buffer. */\n+    private int expectedSequenceNumber = 0;\n+\n+    /** The initial number of exclusive buffers assigned to this channel. */\n+    private final int initialCredit;\n+\n+    /** The number of available buffers that have not been announced to the producer yet. */\n+    private final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n+\n+    private final BufferManager bufferManager;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private int lastBarrierSequenceNumber = NONE;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private long lastBarrierId = NONE;\n+\n+    private final ChannelStatePersister channelStatePersister;\n+\n+    private boolean isUpstreamBlocked;\n+\n+    public RemoteInputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            ConnectionID connectionId,\n+            ConnectionManager connectionManager,\n+            int initialBackOff,\n+            int maxBackoff,\n+            int networkBuffersPerChannel,\n+            Counter numBytesIn,\n+            Counter numBuffersIn,\n+            ChannelStateWriter stateWriter) {\n+\n+        super(\n+                inputGate,\n+                channelIndex,\n+                partitionId,\n+                initialBackOff,\n+                maxBackoff,\n+                numBytesIn,\n+                numBuffersIn);\n+        checkArgument(networkBuffersPerChannel >= 0, \"Must be non-negative.\");\n+\n+        this.initialCredit = networkBuffersPerChannel;\n+        this.connectionId = checkNotNull(connectionId);\n+        this.connectionManager = checkNotNull(connectionManager);\n+        this.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n+        this.channelStatePersister = new ChannelStatePersister(stateWriter, getChannelInfo());\n+    }\n+\n+    @VisibleForTesting\n+    void setExpectedSequenceNumber(int expectedSequenceNumber) {\n+        this.expectedSequenceNumber = expectedSequenceNumber;\n+    }\n+\n+    /**\n+     * Setup includes assigning exclusive buffers to this input channel, and this method should be\n+     * called only once after this input channel is created.\n+     */\n+    @Override\n+    void setup() throws IOException {\n+        checkState(\n+                bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+                \"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n+\n+        bufferManager.requestExclusiveBuffers(initialCredit);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /** Requests a remote subpartition. */\n+    @VisibleForTesting\n+    @Override\n+    public void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException {\n+        if (partitionRequestClient == null) {\n+            LOG.debug(\n+                    \"{}: Requesting REMOTE subpartition {} of partition {}. {}\",\n+                    this,\n+                    subpartitionIndex,\n+                    partitionId,\n+                    channelStatePersister);\n+            // Create a client and request the partition\n+            try {\n+                partitionRequestClient =\n+                        connectionManager.createPartitionRequestClient(connectionId);\n+            } catch (IOException e) {\n+                // IOExceptions indicate that we could not open a connection to the remote\n+                // TaskExecutor\n+                throw new PartitionConnectionException(partitionId, e);\n+            }\n+\n+            partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n+        }\n+    }\n+\n+    /** Retriggers a remote subpartition request. */\n+    void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (increaseBackoff()) {\n+            partitionRequestClient.requestSubpartition(\n+                    partitionId, subpartitionIndex, this, getCurrentBackoff());\n+        } else {\n+            failPartitionRequest();\n+        }\n+    }\n+\n+    @Override\n+    Optional<BufferAndAvailability> getNextBuffer() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        final SequenceBuffer next;\n+        final DataType nextDataType;\n+\n+        synchronized (receivedBuffers) {\n+            next = receivedBuffers.poll();\n+            nextDataType =\n+                    receivedBuffers.peek() != null\n+                            ? receivedBuffers.peek().buffer.getDataType()\n+                            : DataType.NONE;\n+        }\n+\n+        if (next == null) {\n+            if (isReleased.get()) {\n+                throw new CancelTaskException(\n+                        \"Queried for a buffer after channel has been released.\");\n+            }\n+            return Optional.empty();\n+        }\n+\n+        numBytesIn.inc(next.buffer.getSize());\n+        numBuffersIn.inc();\n+        return Optional.of(\n+                new BufferAndAvailability(next.buffer, nextDataType, 0, next.sequenceNumber));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    void sendTaskEvent(TaskEvent event) throws IOException {\n+        checkState(\n+                !isReleased.get(),\n+                \"Tried to send task event to producer after channel has been released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.sendTaskEvent(partitionId, event, this);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased.get();\n+    }\n+\n+    /** Releases all exclusive and floating buffers, closes the partition request client. */\n+    @Override\n+    void releaseAllResources() throws IOException {\n+        if (isReleased.compareAndSet(false, true)) {\n+\n+            final ArrayDeque<Buffer> releasedBuffers;\n+            synchronized (receivedBuffers) {\n+                releasedBuffers =\n+                        receivedBuffers.stream()\n+                                .map(sb -> sb.buffer)\n+                                .collect(Collectors.toCollection(ArrayDeque::new));\n+                receivedBuffers.clear();\n+            }\n+            bufferManager.releaseAllBuffers(releasedBuffers);\n+\n+            // The released flag has to be set before closing the connection to ensure that\n+            // buffers received concurrently with closing are properly recycled.\n+            if (partitionRequestClient != null) {\n+                partitionRequestClient.close(this);\n+            } else {\n+                connectionManager.closeOpenChannelConnections(connectionId);\n+            }\n+        }\n+    }\n+\n+    private void failPartitionRequest() {\n+        setError(new PartitionNotFoundException(partitionId));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Credit-based\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n+     */\n+    private void notifyCreditAvailable() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.notifyCreditAvailable(this);\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfAvailableBuffers() {\n+        return bufferManager.getNumberOfAvailableBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfRequiredBuffers() {\n+        return bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getSenderBacklog() {\n+        return getNumberOfRequiredBuffers() - initialCredit;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isWaitingForFloatingBuffers() {\n+        return bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public Buffer getNextReceivedBuffer() {\n+        final SequenceBuffer sequenceBuffer = receivedBuffers.poll();\n+        return sequenceBuffer != null ? sequenceBuffer.buffer : null;\n+    }\n+\n+    @VisibleForTesting\n+    BufferManager getBufferManager() {\n+        return bufferManager;\n+    }\n+\n+    @VisibleForTesting\n+    PartitionRequestClient getPartitionRequestClient() {\n+        return partitionRequestClient;\n+    }\n+\n+    /**\n+     * The unannounced credit is increased by the given amount and might notify increased credit to\n+     * the producer.\n+     */\n+    @Override\n+    public void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n+        if (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+            notifyCreditAvailable();\n+        }\n+    }\n+\n+    @Override\n+    public void resumeConsumption() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        // notifies the producer that this channel is ready to\n+        // unblock from checkpoint and resume data consumption\n+        partitionRequestClient.resumeConsumption(this);\n+    }\n+\n+    private void onBlockingUpstream() {\n+        isUpstreamBlocked = true;\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    public void onConsumptionResumed() {\n+        isUpstreamBlocked = false;\n+        if (initialCredit == 0) {\n+            unannouncedCredit.set(0);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network I/O notifications (called by network I/O thread)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the currently unannounced credit.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getUnannouncedCredit() {\n+        return unannouncedCredit.get();\n+    }\n+\n+    /**\n+     * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getAndResetUnannouncedCredit() {\n+        return unannouncedCredit.getAndSet(0);\n+    }\n+\n+    /**\n+     * Gets the current number of received buffers which have not been processed yet.\n+     *\n+     * @return Buffers queued for processing.\n+     */\n+    public int getNumberOfQueuedBuffers() {\n+        synchronized (receivedBuffers) {\n+            return receivedBuffers.size();\n+        }\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return Math.max(0, receivedBuffers.size());\n+    }\n+\n+    public int unsynchronizedGetExclusiveBuffersUsed() {\n+        return Math.max(\n+                0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n+    }\n+\n+    public int unsynchronizedGetFloatingBuffersAvailable() {\n+        return Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n+    }\n+\n+    public InputChannelID getInputChannelId() {\n+        return id;\n+    }\n+\n+    public int getInitialCredit() {\n+        return initialCredit;\n+    }\n+\n+    public BufferProvider getBufferProvider() throws IOException {\n+        if (isReleased.get()) {\n+            return null;\n+        }\n+\n+        return inputGate.getBufferProvider();\n+    }\n+\n+    /**\n+     * Requests buffer from input channel directly for receiving network data. It should always\n+     * return an available buffer in credit-based mode unless the channel has been released.\n+     *\n+     * @return The available buffer.\n+     */\n+    @Nullable\n+    public Buffer requestBuffer() {\n+        return bufferManager.requestBuffer(initialCredit);\n+    }\n+\n+    /**\n+     * Receives the backlog from the producer's buffer response. If the number of available buffers\n+     * is less than backlog + initialCredit, it will request floating buffers from the buffer\n+     * manager, and then notify unannounced credits to the producer.\n+     *\n+     * @param backlog The number of unsent buffers in the producer's sub partition.\n+     */\n+    public void onSenderBacklog(int backlog) throws IOException {\n+        // never allocate any new buffers if upstream has been blocked\n+        if (!isUpstreamBlocked) {\n+            notifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+        }\n+    }\n+\n+    public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n+        boolean recycleBuffer = true;\n+\n+        try {\n+            if (expectedSequenceNumber != sequenceNumber) {\n+                onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                return;\n+            }\n+\n+            final boolean wasEmpty;\n+            boolean firstPriorityEvent = false;\n+            synchronized (receivedBuffers) {\n+                NetworkActionsLogger.traceInput(\n+                        \"RemoteInputChannel#onBuffer\",\n+                        buffer,\n+                        inputGate.getOwningTaskName(),\n+                        channelInfo,\n+                        channelStatePersister,\n+                        sequenceNumber);\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after releaseAllResources() released all buffers from receivedBuffers\n+                // (see above for details).\n+                if (isReleased.get()) {\n+                    return;\n+                }\n+\n+                wasEmpty = receivedBuffers.isEmpty();\n+\n+                SequenceBuffer sequenceBuffer = new SequenceBuffer(buffer, sequenceNumber);\n+                DataType dataType = buffer.getDataType();\n+                if (dataType.hasPriority()) {\n+                    firstPriorityEvent = addPriorityBuffer(sequenceBuffer);\n+                } else {\n+                    receivedBuffers.add(sequenceBuffer);\n+                    if (dataType.requiresAnnouncement()) {\n+                        firstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n+                    }\n+                }\n+                channelStatePersister\n+                        .checkForBarrier(sequenceBuffer.buffer)\n+                        .filter(id -> id > lastBarrierId)\n+                        .ifPresent(\n+                                id -> {\n+                                    // checkpoint was not yet started by task thread,\n+                                    // so remember the numbers of buffers to spill for the time when\n+                                    // it will be started\n+                                    lastBarrierId = id;\n+                                    lastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+                                });\n+                channelStatePersister.maybePersist(buffer);\n+                ++expectedSequenceNumber;\n+            }\n+            recycleBuffer = false;\n+\n+            if (firstPriorityEvent) {\n+                notifyPriorityEvent(sequenceNumber);\n+            }\n+            if (wasEmpty) {\n+                notifyChannelNonEmpty();\n+            }\n+\n+            if (backlog >= 0) {\n+                onSenderBacklog(backlog);\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+            }\n+        } finally {\n+            if (recycleBuffer) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+    }\n+\n+    /** @return {@code true} if this was first priority buffer added. */\n+    private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) {\n+        receivedBuffers.addPriorityElement(sequenceBuffer);\n+        return receivedBuffers.getNumPriorityElements() == 1;\n+    }\n+\n+    private SequenceBuffer announce(SequenceBuffer sequenceBuffer) throws IOException {\n+        checkState(\n+                !sequenceBuffer.buffer.isBuffer(),\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        checkAnnouncedOnlyOnce(sequenceBuffer);\n+        AbstractEvent event =\n+                EventSerializer.fromBuffer(sequenceBuffer.buffer, getClass().getClassLoader());\n+        checkState(\n+                event instanceof CheckpointBarrier,\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        CheckpointBarrier barrier = (CheckpointBarrier) event;\n+        return new SequenceBuffer(\n+                EventSerializer.toBuffer(\n+                        new EventAnnouncement(barrier, sequenceBuffer.sequenceNumber), true),\n+                sequenceBuffer.sequenceNumber);\n+    }\n+\n+    private void checkAnnouncedOnlyOnce(SequenceBuffer sequenceBuffer) {\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        int count = 0;\n+        while (iterator.hasNext()) {\n+            if (iterator.next().sequenceNumber == sequenceBuffer.sequenceNumber) {\n+                count++;\n+            }\n+        }\n+        checkState(\n+                count == 1,\n+                \"Before enqueuing the announcement there should be exactly single occurrence of the buffer, but found [%d]\",\n+                count);\n+    }\n+\n+    /**\n+     * Spills all queued buffers on checkpoint start. If barrier has already been received (and\n+     * reordered), spill only the overtaken buffers.\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {\n+        synchronized (receivedBuffers) {\n+            if (barrier.getId() < lastBarrierId) {\n+                throw new CheckpointException(\n+                        String.format(\n+                                \"Sequence number for checkpoint %d is not known (it was likely been overwritten by a newer checkpoint %d)\",\n+                                barrier.getId(), lastBarrierId),\n+                        CheckpointFailureReason\n+                                .CHECKPOINT_SUBSUMED); // currently, at most one active unaligned\n+                // checkpoint is possible\n+            } else if (barrier.getId() > lastBarrierId) {\n+                // This channel has received some obsolete barrier, older compared to the\n+                // checkpointId\n+                // which we are processing right now, and we should ignore that obsoleted checkpoint\n+                // barrier sequence number.\n+                resetLastBarrier();\n+            }\n+\n+            channelStatePersister.startPersisting(\n+                    barrier.getId(), getInflightBuffersUnsafe(barrier.getId()));\n+        }\n+    }\n+\n+    public void checkpointStopped(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            channelStatePersister.stopPersisting(checkpointId);\n+            if (lastBarrierId == checkpointId) {\n+                resetLastBarrier();\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    List<Buffer> getInflightBuffers(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            return getInflightBuffersUnsafe(checkpointId);\n+        }\n+    }\n+\n+    @Override\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n+        boolean firstPriorityEvent;\n+        synchronized (receivedBuffers) {\n+            checkState(channelStatePersister.hasBarrierReceived());\n+            int numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n+            SequenceBuffer toPrioritize =\n+                    receivedBuffers.getAndRemove(\n+                            sequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n+            checkState(lastBarrierSequenceNumber == sequenceNumber);\n+            checkState(!toPrioritize.buffer.isBuffer());\n+            checkState(\n+                    numPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n+                    \"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n+                    toPrioritize,\n+                    numPriorityElementsBeforeRemoval);\n+            // set the priority flag (checked on poll)\n+            // don't convert the barrier itself (barrier controller might not have been switched\n+            // yet)\n+            AbstractEvent e =\n+                    EventSerializer.fromBuffer(\n+                            toPrioritize.buffer, this.getClass().getClassLoader());\n+            toPrioritize.buffer.setReaderIndex(0);\n+            toPrioritize =\n+                    new SequenceBuffer(\n+                            EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n+            firstPriorityEvent =\n+                    addPriorityBuffer(\n+                            toPrioritize); // note that only position of the element is changed\n+            // converting the event itself would require switching the controller sooner\n+        }\n+        if (firstPriorityEvent) {\n+            notifyPriorityEventForce(); // forcibly notify about the priority event\n+            // instead of passing barrier SQN to be checked\n+            // because this SQN might have be seen by the input gate during the announcement\n+        }\n+    }\n+\n+    private void notifyPriorityEventForce() {\n+        inputGate.notifyPriorityEventForce(this);\n+    }\n+\n+    /**\n+     * Returns a list of buffers, checking the first n non-priority buffers, and skipping all\n+     * events.\n+     */\n+    private List<Buffer> getInflightBuffersUnsafe(long checkpointId) {\n+        assert Thread.holdsLock(receivedBuffers);\n+\n+        checkState(checkpointId == lastBarrierId || lastBarrierId == NONE);\n+\n+        final List<Buffer> inflightBuffers = new ArrayList<>();\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        // skip all priority events (only buffers are stored anyways)\n+        Iterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n+\n+        while (iterator.hasNext()) {\n+            SequenceBuffer sequenceBuffer = iterator.next();\n+            if (sequenceBuffer.buffer.isBuffer()) {\n+                if (shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+                    inflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return inflightBuffers;\n+    }\n+\n+    private void resetLastBarrier() {\n+        lastBarrierId = NONE;\n+        lastBarrierSequenceNumber = NONE;\n+    }\n+\n+    /**\n+     * @return if given {@param sequenceNumber} should be spilled given {@link\n+     *     #lastBarrierSequenceNumber}. We might not have yet received {@link CheckpointBarrier} and\n+     *     we might need to spill everything. If we have already received it, there is a bit nasty\n+     *     corner case of {@link SequenceBuffer#sequenceNumber} overflowing that needs to be handled\n+     *     as well.\n+     */\n+    private boolean shouldBeSpilled(int sequenceNumber) {\n+        if (lastBarrierSequenceNumber == NONE) {\n+            return true;\n+        }\n+        checkState(\n+                receivedBuffers.size() < Integer.MAX_VALUE / 2,\n+                \"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+        boolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastBarrierSequenceNumber;\n+        boolean possibleOverflowBeforeOvertaking =\n+                lastBarrierSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+        if (possibleOverflowAfterOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber && sequenceNumber > 0;\n+        } else if (possibleOverflowBeforeOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber || sequenceNumber > 0;\n+        } else {\n+            return sequenceNumber < lastBarrierSequenceNumber;\n+        }\n+    }\n+\n+    public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n+        boolean success = false;\n+\n+        synchronized (receivedBuffers) {\n+            if (!isReleased.get()) {\n+                if (expectedSequenceNumber == sequenceNumber) {\n+                    expectedSequenceNumber++;\n+                    success = true;\n+                } else {\n+                    onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                }\n+            }\n+        }\n+\n+        if (success && backlog >= 0) {\n+            onSenderBacklog(backlog);\n+        }\n+    }\n+\n+    public void onFailedPartitionRequest() {\n+        inputGate.triggerPartitionStateCheck(partitionId);\n+    }\n+\n+    public void onError(Throwable cause) {\n+        setError(cause);\n+    }\n+\n+    private void checkPartitionRequestQueueInitialized() throws IOException {\n+        checkError();\n+        checkState(\n+                partitionRequestClient != null,\n+                \"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n+    }\n+\n+    private static class BufferReorderingException extends IOException {\n+\n+        private static final long serialVersionUID = -888282210356266816L;\n+\n+        private final int expectedSequenceNumber;\n+\n+        private final int actualSequenceNumber;\n+\n+        BufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n+            this.expectedSequenceNumber = expectedSequenceNumber;\n+            this.actualSequenceNumber = actualSequenceNumber;\n+        }\n+\n+        @Override\n+        public String getMessage() {\n+            return String.format(\n+                    \"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n+                    expectedSequenceNumber, actualSequenceNumber);\n+        }\n+    }\n+\n+    private static final class SequenceBuffer {\n+        final Buffer buffer;\n+        final int sequenceNumber;\n+\n+        private SequenceBuffer(Buffer buffer, int sequenceNumber) {\n+            this.buffer = buffer;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\n+                    \"SequenceBuffer(isEvent = %s, dataType = %s, sequenceNumber = %s)\",\n+                    !buffer.isBuffer(), buffer.getDataType(), sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex ff2103389d6..f9cedf71105 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -19,763 +19,799 @@\n package org.apache.flink.runtime.io.network.partition.consumer;\n \n import org.apache.flink.annotation.VisibleForTesting;\n-import org.apache.flink.core.memory.MemorySegment;\n-import org.apache.flink.core.memory.MemorySegmentProvider;\n-import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.checkpoint.CheckpointException;\n+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;\n+import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;\n+import org.apache.flink.runtime.event.AbstractEvent;\n import org.apache.flink.runtime.event.TaskEvent;\n+import org.apache.flink.runtime.execution.CancelTaskException;\n import org.apache.flink.runtime.io.network.ConnectionID;\n import org.apache.flink.runtime.io.network.ConnectionManager;\n import org.apache.flink.runtime.io.network.PartitionRequestClient;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+import org.apache.flink.runtime.io.network.api.EventAnnouncement;\n+import org.apache.flink.runtime.io.network.api.serialization.EventSerializer;\n import org.apache.flink.runtime.io.network.buffer.Buffer;\n-import org.apache.flink.runtime.io.network.buffer.BufferListener;\n+import org.apache.flink.runtime.io.network.buffer.Buffer.DataType;\n import org.apache.flink.runtime.io.network.buffer.BufferProvider;\n-import org.apache.flink.runtime.io.network.buffer.BufferReceivedListener;\n-import org.apache.flink.runtime.io.network.buffer.BufferRecycler;\n-import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n-import org.apache.flink.runtime.io.network.metrics.InputChannelMetrics;\n-import org.apache.flink.runtime.io.network.netty.NettyMessage;\n+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;\n import org.apache.flink.runtime.io.network.partition.PartitionNotFoundException;\n+import org.apache.flink.runtime.io.network.partition.PrioritizedDeque;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n-import org.apache.flink.util.ExceptionUtils;\n \n-import javax.annotation.Nonnull;\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterators;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n-/**\n- * An input channel, which requests a remote partition queue.\n- */\n-public class RemoteInputChannel extends InputChannel implements BufferRecycler, BufferListener {\n-\n-\t/** ID to distinguish this channel from other channels sharing the same TCP connection. */\n-\tprivate final InputChannelID id = new InputChannelID();\n-\n-\t/** The connection to use to request the remote partition. */\n-\tprivate final ConnectionID connectionId;\n-\n-\t/** The connection manager to use connect to the remote partition provider. */\n-\tprivate final ConnectionManager connectionManager;\n-\n-\t/**\n-\t * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n-\t * is consumed by the receiving task thread.\n-\t */\n-\tprivate final ArrayDeque<Buffer> receivedBuffers = new ArrayDeque<>();\n-\n-\t/**\n-\t * Flag indicating whether this channel has been released. Either called by the receiving task\n-\t * thread or the task manager actor.\n-\t */\n-\tprivate final AtomicBoolean isReleased = new AtomicBoolean();\n-\n-\t/** Client to establish a (possibly shared) TCP connection and request the partition. */\n-\tprivate volatile PartitionRequestClient partitionRequestClient;\n-\n-\t/**\n-\t * The next expected sequence number for the next buffer. This is modified by the network\n-\t * I/O thread only.\n-\t */\n-\tprivate int expectedSequenceNumber = 0;\n-\n-\t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate int initialCredit;\n-\n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The number of available buffers that have not been announced to the producer yet. */\n-\tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n-\n-\t/** The number of buffers to requested that equals to unfulfilled sender's backlog. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\t/** The tag indicates whether this channel is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** Global memory segment provider to request and recycle exclusive buffers (only for credit-based). */\n-\t@Nonnull\n-\tprivate final MemorySegmentProvider memorySegmentProvider;\n-\n-\t/** The latest already triggered checkpoint id which would be updated during {@link #requestInflightBuffers(long)}.*/\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n-\n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n-\n-\tpublic RemoteInputChannel(\n-\t\tSingleInputGate inputGate,\n-\t\tint channelIndex,\n-\t\tResultPartitionID partitionId,\n-\t\tConnectionID connectionId,\n-\t\tConnectionManager connectionManager,\n-\t\tint initialBackOff,\n-\t\tint maxBackoff,\n-\t\tInputChannelMetrics metrics,\n-\t\t@Nonnull MemorySegmentProvider memorySegmentProvider) {\n-\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff,\n-\t\t\tmetrics.getNumBytesInRemoteCounter(), metrics.getNumBuffersInRemoteCounter());\n-\n-\t\tthis.connectionId = checkNotNull(connectionId);\n-\t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.memorySegmentProvider = memorySegmentProvider;\n-\t}\n-\n-\t/**\n-\t * Assigns exclusive buffers to this input channel, and this method should be called only once\n-\t * after this input channel is created.\n-\t */\n-\tvoid assignExclusiveSegments() throws IOException {\n-\t\tcheckState(initialCredit == 0, \"Bug in input channel setup logic: exclusive buffers have \" +\n-\t\t\t\"already been set for this input channel.\");\n-\n-\t\tCollection<MemorySegment> segments = checkNotNull(memorySegmentProvider.requestMemorySegments());\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tinitialCredit = segments.size();\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), initialCredit);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests a remote subpartition.\n-\t */\n-\t@VisibleForTesting\n-\t@Override\n-\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n-\t\tif (partitionRequestClient == null) {\n-\t\t\t// Create a client and request the partition\n-\t\t\ttry {\n-\t\t\t\tpartitionRequestClient = connectionManager.createPartitionRequestClient(connectionId);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\t// IOExceptions indicate that we could not open a connection to the remote TaskExecutor\n-\t\t\t\tthrow new PartitionConnectionException(partitionId, e);\n-\t\t\t}\n-\n-\t\t\tpartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Retriggers a remote subpartition request.\n-\t */\n-\tvoid retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n-\t\tcheckState(partitionRequestClient != null, \"Missing initial subpartition request.\");\n-\n-\t\tif (increaseBackoff()) {\n-\t\t\tpartitionRequestClient.requestSubpartition(\n-\t\t\t\tpartitionId, subpartitionIndex, this, getCurrentBackoff());\n-\t\t} else {\n-\t\t\tfailPartitionRequest();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tOptional<BufferAndAvailability> getNextBuffer() throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Queried for a buffer after channel has been closed.\");\n-\t\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tfinal Buffer next;\n-\t\tfinal boolean moreAvailable;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tnext = receivedBuffers.poll();\n-\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n-\t\t}\n-\n-\t\tnumBytesIn.inc(next.getSize());\n-\t\tnumBuffersIn.inc();\n-\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable, numRequiredBuffers));\n-\t}\n-\n-\t@Override\n-\tpublic List<Buffer> requestInflightBuffers(long checkpointId) throws IOException {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlastRequestedCheckpointId = checkpointId;\n-\n-\t\t\treturn inflightBuffers;\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tvoid sendTaskEvent(TaskEvent event) throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Tried to send task event to producer after channel has been released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tpartitionRequestClient.sendTaskEvent(partitionId, event, this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n-\t}\n-\n-\t/**\n-\t * Releases all exclusive and floating buffers, closes the partition request client.\n-\t */\n-\t@Override\n-\tvoid releaseAllResources() throws IOException {\n-\t\tif (isReleased.compareAndSet(false, true)) {\n-\n-\t\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\tBuffer buffer;\n-\t\t\t\twhile ((buffer = receivedBuffers.poll()) != null) {\n-\t\t\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\t}\n-\n-\t\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\t\tmemorySegmentProvider.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t\t}\n-\n-\t\t\t// The released flag has to be set before closing the connection to ensure that\n-\t\t\t// buffers received concurrently with closing are properly recycled.\n-\t\t\tif (partitionRequestClient != null) {\n-\t\t\t\tpartitionRequestClient.close(this);\n-\t\t\t} else {\n-\t\t\t\tconnectionManager.closeOpenChannelConnections(connectionId);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void failPartitionRequest() {\n-\t\tsetError(new PartitionNotFoundException(partitionId));\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Credit-based\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n-\t */\n-\tprivate void notifyCreditAvailable() {\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tpartitionRequestClient.notifyCreditAvailable(this);\n-\t}\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this input channel directly and it may trigger return extra\n-\t * floating buffer and notify increased credit to the producer.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers;\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t// after releaseAllResources() released all buffers (see below for details).\n-\t\t\tif (isReleased.get()) {\n-\t\t\t\ttry {\n-\t\t\t\t\tmemorySegmentProvider.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t\treturn;\n-\t\t\t\t} catch (Throwable t) {\n-\t\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t}\n-\n-\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\tpublic int getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn numRequiredBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\treturn isWaitingForFloatingBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n-\t}\n-\n-\t/**\n-\t * The Buffer pool notifies this channel of an available floating buffer. If the channel is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased\n-\t * by one.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t *  \tmore floating buffers.\n-\t */\n-\t@Override\n-\tpublic NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tNotificationResult notificationResult = NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tcheckState(isWaitingForFloatingBuffers,\n-\t\t\t\t\t\"This channel should be waiting for floating buffers.\");\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllResources() already released buffers inside bufferQueue\n-\t\t\t\t// -> then isReleased is set correctly\n-\t\t\t\t// 2) releaseAllResources() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (isReleased.get() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (unannouncedCredit.getAndAdd(1) == 0) {\n-\t\t\t\tnotifyCreditAvailable();\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tsetError(t);\n-\t\t}\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t@Override\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\t\tboolean removed = inputGate.getBufferProvider().removeBufferListener(this);\n-\t\t\t\t\tcheckState(removed, \"Listener should be removed.\");\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t}\n-\n-\t\t\t\tint bufferReleased = bufferQueue.releaseAllFloatingBuffers();\n-\t\t\t\tnumRequiredBuffers += bufferReleased;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption() {\n-\t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n-\n-\t\t// notifies the producer that this channel is ready to\n-\t\t// unblock from checkpoint and resume data consumption\n-\t\tpartitionRequestClient.resumeConsumption(this);\n-\t}\n-\n-\t/**\n-\t * Called by netty thread to request buffers and generate {@link NettyMessage.ResumeConsumption} message.\n-\t */\n-\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage() throws IOException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n-\t\t\tcheckState(numRequiredBuffers >= 0, \"Number of required buffers should be non-negative.\");\n-\n-\t\t\tif (initialCredit > 0) {\n-\t\t\t\treturn new NettyMessage.ResumeConsumption(id, bufferQueue.getAvailableBufferSize(), numRequiredBuffers);\n-\t\t\t}\n-\n-\t\t\tint numCredit = requestBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numCredit;\n-\t\t\treturn new NettyMessage.ResumeConsumption(id, numCredit, numRequiredBuffers);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network I/O notifications (called by network I/O thread)\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Gets the currently unannounced credit.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getUnannouncedCredit() {\n-\t\treturn unannouncedCredit.get();\n-\t}\n-\n-\t/**\n-\t * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n-\t}\n-\n-\t/**\n-\t * Gets the current number of received buffers which have not been processed yet.\n-\t *\n-\t * @return Buffers queued for processing.\n-\t */\n-\tpublic int getNumberOfQueuedBuffers() {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treturn receivedBuffers.size();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn Math.max(0, receivedBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferQueue.exclusiveBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn Math.max(0, bufferQueue.floatingBuffers.size());\n-\t}\n-\n-\tpublic InputChannelID getInputChannelId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic int getInitialCredit() {\n-\t\treturn initialCredit;\n-\t}\n-\n-\tpublic BufferProvider getBufferProvider() throws IOException {\n-\t\tif (isReleased.get()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn inputGate.getBufferProvider();\n-\t}\n-\n-\t/**\n-\t * Requests buffer from input channel directly for receiving network data.\n-\t * It should always return an available buffer in credit-based mode unless\n-\t * the channel has been released.\n-\t *\n-\t * @return The available buffer.\n-\t */\n-\t@Nullable\n-\tpublic Buffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Receives the backlog from the producer's buffer response. If the number of available\n-\t * buffers is less than backlog + initialCredit, it will request floating buffers from the buffer\n-\t * pool, and then notify unannounced credits to the producer.\n-\t *\n-\t * @param backlog The number of unsent buffers in the producer's sub partition.\n-\t */\n-\tpublic void onSenderBacklog(int backlog) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t// after releaseAllResources() released all buffers (see above for details).\n-\t\t\tif (isReleased.get()) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += backlog;\n-\t\t\tnumRequestedBuffers = requestBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\n-\t\tif (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\tprivate int requestBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBuffer buffer = inputGate.getBufferPool().requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (inputGate.getBufferProvider().addBufferListener(this)) {\n-\t\t\t\t// If the channel has not got enough buffers, register it as listener to wait for more floating buffers.\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tpublic void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean recycleBuffer = true;\n-\n-\t\ttry {\n-\t\t\tif (expectedSequenceNumber != sequenceNumber) {\n-\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tfinal boolean wasEmpty;\n-\t\t\tfinal CheckpointBarrier notifyReceivedBarrier;\n-\t\t\tfinal Buffer notifyReceivedBuffer;\n-\t\t\tfinal BufferReceivedListener listener = inputGate.getBufferReceivedListener();\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after releaseAllResources() released all buffers from receivedBuffers\n-\t\t\t\t// (see above for details).\n-\t\t\t\tif (isReleased.get()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n-\n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n-\t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n-\t\t\t}\n-\t\t\trecycleBuffer = false;\n-\n-\t\t\t++expectedSequenceNumber;\n-\n-\t\t\tif (wasEmpty) {\n-\t\t\t\tnotifyChannelNonEmpty();\n-\t\t\t}\n-\n-\t\t\tif (backlog >= 0) {\n-\t\t\t\tonSenderBacklog(backlog);\n-\t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tif (recycleBuffer) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean success = false;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tif (!isReleased.get()) {\n-\t\t\t\tif (expectedSequenceNumber == sequenceNumber) {\n-\t\t\t\t\texpectedSequenceNumber++;\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t} else {\n-\t\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (success && backlog >= 0) {\n-\t\t\tonSenderBacklog(backlog);\n-\t\t}\n-\t}\n-\n-\tpublic void onFailedPartitionRequest() {\n-\t\tinputGate.triggerPartitionStateCheck(partitionId);\n-\t}\n-\n-\tpublic void onError(Throwable cause) {\n-\t\tsetError(cause);\n-\t}\n-\n-\tprivate static class BufferReorderingException extends IOException {\n-\n-\t\tprivate static final long serialVersionUID = -888282210356266816L;\n-\n-\t\tprivate final int expectedSequenceNumber;\n-\n-\t\tprivate final int actualSequenceNumber;\n-\n-\t\tBufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n-\t\t\tthis.expectedSequenceNumber = expectedSequenceNumber;\n-\t\t\tthis.actualSequenceNumber = actualSequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String getMessage() {\n-\t\t\treturn String.format(\"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n-\t\t\t\texpectedSequenceNumber, actualSequenceNumber);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tprivate static class AvailableBufferQueue {\n-\n-\t\t/** The current available floating buffers from the fixed buffer pool. */\n-\t\tprivate final ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/** The current available exclusive buffers from the global buffer pool. */\n-\t\tprivate final ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t *\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\treturn 0;\n-\t\t\t} else {\n-\t\t\t\treturn 1;\n-\t\t\t}\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseAllFloatingBuffers() {\n-\t\t\tint bufferReleased = floatingBuffers.size();\n-\t\t\tfor (Buffer buffer: floatingBuffers) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\tfloatingBuffers.clear();\n-\t\t\treturn bufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+/** An input channel, which requests a remote partition queue. */\n+public class RemoteInputChannel extends InputChannel {\n+    private static final Logger LOG = LoggerFactory.getLogger(RemoteInputChannel.class);\n+\n+    private static final int NONE = -1;\n+\n+    /** ID to distinguish this channel from other channels sharing the same TCP connection. */\n+    private final InputChannelID id = new InputChannelID();\n+\n+    /** The connection to use to request the remote partition. */\n+    private final ConnectionID connectionId;\n+\n+    /** The connection manager to use connect to the remote partition provider. */\n+    private final ConnectionManager connectionManager;\n+\n+    /**\n+     * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n+     * is consumed by the receiving task thread.\n+     */\n+    private final PrioritizedDeque<SequenceBuffer> receivedBuffers = new PrioritizedDeque<>();\n+\n+    /**\n+     * Flag indicating whether this channel has been released. Either called by the receiving task\n+     * thread or the task manager actor.\n+     */\n+    private final AtomicBoolean isReleased = new AtomicBoolean();\n+\n+    /** Client to establish a (possibly shared) TCP connection and request the partition. */\n+    private volatile PartitionRequestClient partitionRequestClient;\n+\n+    /** The next expected sequence number for the next buffer. */\n+    private int expectedSequenceNumber = 0;\n+\n+    /** The initial number of exclusive buffers assigned to this channel. */\n+    private final int initialCredit;\n+\n+    /** The number of available buffers that have not been announced to the producer yet. */\n+    private final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n+\n+    private final BufferManager bufferManager;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private int lastBarrierSequenceNumber = NONE;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private long lastBarrierId = NONE;\n+\n+    private final ChannelStatePersister channelStatePersister;\n+\n+    public RemoteInputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            ConnectionID connectionId,\n+            ConnectionManager connectionManager,\n+            int initialBackOff,\n+            int maxBackoff,\n+            int networkBuffersPerChannel,\n+            Counter numBytesIn,\n+            Counter numBuffersIn,\n+            ChannelStateWriter stateWriter) {\n+\n+        super(\n+                inputGate,\n+                channelIndex,\n+                partitionId,\n+                initialBackOff,\n+                maxBackoff,\n+                numBytesIn,\n+                numBuffersIn);\n+        checkArgument(networkBuffersPerChannel >= 0, \"Must be non-negative.\");\n+\n+        this.initialCredit = networkBuffersPerChannel;\n+        this.connectionId = checkNotNull(connectionId);\n+        this.connectionManager = checkNotNull(connectionManager);\n+        this.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n+        this.channelStatePersister = new ChannelStatePersister(stateWriter, getChannelInfo());\n+    }\n+\n+    @VisibleForTesting\n+    void setExpectedSequenceNumber(int expectedSequenceNumber) {\n+        this.expectedSequenceNumber = expectedSequenceNumber;\n+    }\n+\n+    /**\n+     * Setup includes assigning exclusive buffers to this input channel, and this method should be\n+     * called only once after this input channel is created.\n+     */\n+    @Override\n+    void setup() throws IOException {\n+        checkState(\n+                bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+                \"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n+\n+        bufferManager.requestExclusiveBuffers(initialCredit);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /** Requests a remote subpartition. */\n+    @VisibleForTesting\n+    @Override\n+    public void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException {\n+        if (partitionRequestClient == null) {\n+            LOG.debug(\n+                    \"{}: Requesting REMOTE subpartition {} of partition {}. {}\",\n+                    this,\n+                    subpartitionIndex,\n+                    partitionId,\n+                    channelStatePersister);\n+            // Create a client and request the partition\n+            try {\n+                partitionRequestClient =\n+                        connectionManager.createPartitionRequestClient(connectionId);\n+            } catch (IOException e) {\n+                // IOExceptions indicate that we could not open a connection to the remote\n+                // TaskExecutor\n+                throw new PartitionConnectionException(partitionId, e);\n+            }\n+\n+            partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n+        }\n+    }\n+\n+    /** Retriggers a remote subpartition request. */\n+    void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (increaseBackoff()) {\n+            partitionRequestClient.requestSubpartition(\n+                    partitionId, subpartitionIndex, this, getCurrentBackoff());\n+        } else {\n+            failPartitionRequest();\n+        }\n+    }\n+\n+    @Override\n+    Optional<BufferAndAvailability> getNextBuffer() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        final SequenceBuffer next;\n+        final DataType nextDataType;\n+\n+        synchronized (receivedBuffers) {\n+            next = receivedBuffers.poll();\n+            nextDataType =\n+                    receivedBuffers.peek() != null\n+                            ? receivedBuffers.peek().buffer.getDataType()\n+                            : DataType.NONE;\n+        }\n+\n+        if (next == null) {\n+            if (isReleased.get()) {\n+                throw new CancelTaskException(\n+                        \"Queried for a buffer after channel has been released.\");\n+            }\n+            return Optional.empty();\n+        }\n+\n+        NetworkActionsLogger.traceInput(\n+                \"RemoteInputChannel#getNextBuffer\",\n+                next.buffer,\n+                inputGate.getOwningTaskName(),\n+                channelInfo,\n+                channelStatePersister,\n+                next.sequenceNumber);\n+        numBytesIn.inc(next.buffer.getSize());\n+        numBuffersIn.inc();\n+        return Optional.of(\n+                new BufferAndAvailability(next.buffer, nextDataType, 0, next.sequenceNumber));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    void sendTaskEvent(TaskEvent event) throws IOException {\n+        checkState(\n+                !isReleased.get(),\n+                \"Tried to send task event to producer after channel has been released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.sendTaskEvent(partitionId, event, this);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased.get();\n+    }\n+\n+    /** Releases all exclusive and floating buffers, closes the partition request client. */\n+    @Override\n+    void releaseAllResources() throws IOException {\n+        if (isReleased.compareAndSet(false, true)) {\n+\n+            final ArrayDeque<Buffer> releasedBuffers;\n+            synchronized (receivedBuffers) {\n+                releasedBuffers =\n+                        receivedBuffers.stream()\n+                                .map(sb -> sb.buffer)\n+                                .collect(Collectors.toCollection(ArrayDeque::new));\n+                receivedBuffers.clear();\n+            }\n+            bufferManager.releaseAllBuffers(releasedBuffers);\n+\n+            // The released flag has to be set before closing the connection to ensure that\n+            // buffers received concurrently with closing are properly recycled.\n+            if (partitionRequestClient != null) {\n+                partitionRequestClient.close(this);\n+            } else {\n+                connectionManager.closeOpenChannelConnections(connectionId);\n+            }\n+        }\n+    }\n+\n+    private void failPartitionRequest() {\n+        setError(new PartitionNotFoundException(partitionId));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Credit-based\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n+     */\n+    private void notifyCreditAvailable() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.notifyCreditAvailable(this);\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfAvailableBuffers() {\n+        return bufferManager.getNumberOfAvailableBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfRequiredBuffers() {\n+        return bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getSenderBacklog() {\n+        return getNumberOfRequiredBuffers() - initialCredit;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isWaitingForFloatingBuffers() {\n+        return bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public Buffer getNextReceivedBuffer() {\n+        final SequenceBuffer sequenceBuffer = receivedBuffers.poll();\n+        return sequenceBuffer != null ? sequenceBuffer.buffer : null;\n+    }\n+\n+    @VisibleForTesting\n+    BufferManager getBufferManager() {\n+        return bufferManager;\n+    }\n+\n+    @VisibleForTesting\n+    PartitionRequestClient getPartitionRequestClient() {\n+        return partitionRequestClient;\n+    }\n+\n+    /**\n+     * The unannounced credit is increased by the given amount and might notify increased credit to\n+     * the producer.\n+     */\n+    @Override\n+    public void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n+        if (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+            notifyCreditAvailable();\n+        }\n+    }\n+\n+    @Override\n+    public void resumeConsumption() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (initialCredit == 0) {\n+            // this unannounced credit can be a positive value because credit assignment and the\n+            // increase of this value is not an atomic operation and as a result, this unannounced\n+            // credit value can be get increased even after this channel has been blocked and all\n+            // floating credits are released, it is important to clear this unannounced credit and\n+            // at the same time reset the sender's available credits to keep consistency\n+            unannouncedCredit.set(0);\n+        }\n+\n+        // notifies the producer that this channel is ready to\n+        // unblock from checkpoint and resume data consumption\n+        partitionRequestClient.resumeConsumption(this);\n+    }\n+\n+    @Override\n+    public void acknowledgeAllRecordsProcessed() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.acknowledgeAllRecordsProcessed(this);\n+    }\n+\n+    private void onBlockingUpstream() {\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network I/O notifications (called by network I/O thread)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the currently unannounced credit.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getUnannouncedCredit() {\n+        return unannouncedCredit.get();\n+    }\n+\n+    /**\n+     * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getAndResetUnannouncedCredit() {\n+        return unannouncedCredit.getAndSet(0);\n+    }\n+\n+    /**\n+     * Gets the current number of received buffers which have not been processed yet.\n+     *\n+     * @return Buffers queued for processing.\n+     */\n+    public int getNumberOfQueuedBuffers() {\n+        synchronized (receivedBuffers) {\n+            return receivedBuffers.size();\n+        }\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return Math.max(0, receivedBuffers.size());\n+    }\n+\n+    public int unsynchronizedGetExclusiveBuffersUsed() {\n+        return Math.max(\n+                0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n+    }\n+\n+    public int unsynchronizedGetFloatingBuffersAvailable() {\n+        return Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n+    }\n+\n+    public InputChannelID getInputChannelId() {\n+        return id;\n+    }\n+\n+    public int getInitialCredit() {\n+        return initialCredit;\n+    }\n+\n+    public BufferProvider getBufferProvider() throws IOException {\n+        if (isReleased.get()) {\n+            return null;\n+        }\n+\n+        return inputGate.getBufferProvider();\n+    }\n+\n+    /**\n+     * Requests buffer from input channel directly for receiving network data. It should always\n+     * return an available buffer in credit-based mode unless the channel has been released.\n+     *\n+     * @return The available buffer.\n+     */\n+    @Nullable\n+    public Buffer requestBuffer() {\n+        return bufferManager.requestBuffer();\n+    }\n+\n+    /**\n+     * Receives the backlog from the producer's buffer response. If the number of available buffers\n+     * is less than backlog + initialCredit, it will request floating buffers from the buffer\n+     * manager, and then notify unannounced credits to the producer.\n+     *\n+     * @param backlog The number of unsent buffers in the producer's sub partition.\n+     */\n+    public void onSenderBacklog(int backlog) throws IOException {\n+        notifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+    }\n+\n+    /**\n+     * Handles the input buffer. This method is taking over the ownership of the buffer and is fully\n+     * responsible for cleaning it up both on the happy path and in case of an error.\n+     */\n+    public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n+        boolean recycleBuffer = true;\n+\n+        try {\n+            if (expectedSequenceNumber != sequenceNumber) {\n+                onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                return;\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+                checkArgument(backlog == 0, \"Illegal number of backlog: %s, should be 0.\", backlog);\n+            }\n+\n+            final boolean wasEmpty;\n+            boolean firstPriorityEvent = false;\n+            synchronized (receivedBuffers) {\n+                NetworkActionsLogger.traceInput(\n+                        \"RemoteInputChannel#onBuffer\",\n+                        buffer,\n+                        inputGate.getOwningTaskName(),\n+                        channelInfo,\n+                        channelStatePersister,\n+                        sequenceNumber);\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after releaseAllResources() released all buffers from receivedBuffers\n+                // (see above for details).\n+                if (isReleased.get()) {\n+                    return;\n+                }\n+\n+                wasEmpty = receivedBuffers.isEmpty();\n+\n+                SequenceBuffer sequenceBuffer = new SequenceBuffer(buffer, sequenceNumber);\n+                DataType dataType = buffer.getDataType();\n+                if (dataType.hasPriority()) {\n+                    firstPriorityEvent = addPriorityBuffer(sequenceBuffer);\n+                    recycleBuffer = false;\n+                } else {\n+                    receivedBuffers.add(sequenceBuffer);\n+                    recycleBuffer = false;\n+                    if (dataType.requiresAnnouncement()) {\n+                        firstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n+                    }\n+                }\n+                channelStatePersister\n+                        .checkForBarrier(sequenceBuffer.buffer)\n+                        .filter(id -> id > lastBarrierId)\n+                        .ifPresent(\n+                                id -> {\n+                                    // checkpoint was not yet started by task thread,\n+                                    // so remember the numbers of buffers to spill for the time when\n+                                    // it will be started\n+                                    lastBarrierId = id;\n+                                    lastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+                                });\n+                channelStatePersister.maybePersist(buffer);\n+                ++expectedSequenceNumber;\n+            }\n+\n+            if (firstPriorityEvent) {\n+                notifyPriorityEvent(sequenceNumber);\n+            }\n+            if (wasEmpty) {\n+                notifyChannelNonEmpty();\n+            }\n+\n+            if (backlog >= 0) {\n+                onSenderBacklog(backlog);\n+            }\n+        } finally {\n+            if (recycleBuffer) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+    }\n+\n+    /** @return {@code true} if this was first priority buffer added. */\n+    private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) {\n+        receivedBuffers.addPriorityElement(sequenceBuffer);\n+        return receivedBuffers.getNumPriorityElements() == 1;\n+    }\n+\n+    private SequenceBuffer announce(SequenceBuffer sequenceBuffer) throws IOException {\n+        checkState(\n+                !sequenceBuffer.buffer.isBuffer(),\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        checkAnnouncedOnlyOnce(sequenceBuffer);\n+        AbstractEvent event =\n+                EventSerializer.fromBuffer(sequenceBuffer.buffer, getClass().getClassLoader());\n+        checkState(\n+                event instanceof CheckpointBarrier,\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        CheckpointBarrier barrier = (CheckpointBarrier) event;\n+        return new SequenceBuffer(\n+                EventSerializer.toBuffer(\n+                        new EventAnnouncement(barrier, sequenceBuffer.sequenceNumber), true),\n+                sequenceBuffer.sequenceNumber);\n+    }\n+\n+    private void checkAnnouncedOnlyOnce(SequenceBuffer sequenceBuffer) {\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        int count = 0;\n+        while (iterator.hasNext()) {\n+            if (iterator.next().sequenceNumber == sequenceBuffer.sequenceNumber) {\n+                count++;\n+            }\n+        }\n+        checkState(\n+                count == 1,\n+                \"Before enqueuing the announcement there should be exactly single occurrence of the buffer, but found [%d]\",\n+                count);\n+    }\n+\n+    /**\n+     * Spills all queued buffers on checkpoint start. If barrier has already been received (and\n+     * reordered), spill only the overtaken buffers.\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {\n+        synchronized (receivedBuffers) {\n+            if (barrier.getId() < lastBarrierId) {\n+                throw new CheckpointException(\n+                        String.format(\n+                                \"Sequence number for checkpoint %d is not known (it was likely been overwritten by a newer checkpoint %d)\",\n+                                barrier.getId(), lastBarrierId),\n+                        CheckpointFailureReason\n+                                .CHECKPOINT_SUBSUMED); // currently, at most one active unaligned\n+                // checkpoint is possible\n+            } else if (barrier.getId() > lastBarrierId) {\n+                // This channel has received some obsolete barrier, older compared to the\n+                // checkpointId\n+                // which we are processing right now, and we should ignore that obsoleted checkpoint\n+                // barrier sequence number.\n+                resetLastBarrier();\n+            }\n+\n+            channelStatePersister.startPersisting(\n+                    barrier.getId(), getInflightBuffersUnsafe(barrier.getId()));\n+        }\n+    }\n+\n+    public void checkpointStopped(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            channelStatePersister.stopPersisting(checkpointId);\n+            if (lastBarrierId == checkpointId) {\n+                resetLastBarrier();\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    List<Buffer> getInflightBuffers(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            return getInflightBuffersUnsafe(checkpointId);\n+        }\n+    }\n+\n+    @Override\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n+        boolean firstPriorityEvent;\n+        synchronized (receivedBuffers) {\n+            checkState(channelStatePersister.hasBarrierReceived());\n+            int numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n+            SequenceBuffer toPrioritize =\n+                    receivedBuffers.getAndRemove(\n+                            sequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n+            checkState(lastBarrierSequenceNumber == sequenceNumber);\n+            checkState(!toPrioritize.buffer.isBuffer());\n+            checkState(\n+                    numPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n+                    \"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n+                    toPrioritize,\n+                    numPriorityElementsBeforeRemoval);\n+            // set the priority flag (checked on poll)\n+            // don't convert the barrier itself (barrier controller might not have been switched\n+            // yet)\n+            AbstractEvent e =\n+                    EventSerializer.fromBuffer(\n+                            toPrioritize.buffer, this.getClass().getClassLoader());\n+            toPrioritize.buffer.setReaderIndex(0);\n+            toPrioritize =\n+                    new SequenceBuffer(\n+                            EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n+            firstPriorityEvent =\n+                    addPriorityBuffer(\n+                            toPrioritize); // note that only position of the element is changed\n+            // converting the event itself would require switching the controller sooner\n+        }\n+        if (firstPriorityEvent) {\n+            notifyPriorityEventForce(); // forcibly notify about the priority event\n+            // instead of passing barrier SQN to be checked\n+            // because this SQN might have be seen by the input gate during the announcement\n+        }\n+    }\n+\n+    private void notifyPriorityEventForce() {\n+        inputGate.notifyPriorityEventForce(this);\n+    }\n+\n+    /**\n+     * Returns a list of buffers, checking the first n non-priority buffers, and skipping all\n+     * events.\n+     */\n+    private List<Buffer> getInflightBuffersUnsafe(long checkpointId) {\n+        assert Thread.holdsLock(receivedBuffers);\n+\n+        checkState(checkpointId == lastBarrierId || lastBarrierId == NONE);\n+\n+        final List<Buffer> inflightBuffers = new ArrayList<>();\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        // skip all priority events (only buffers are stored anyways)\n+        Iterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n+\n+        while (iterator.hasNext()) {\n+            SequenceBuffer sequenceBuffer = iterator.next();\n+            if (sequenceBuffer.buffer.isBuffer()) {\n+                if (shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+                    inflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return inflightBuffers;\n+    }\n+\n+    private void resetLastBarrier() {\n+        lastBarrierId = NONE;\n+        lastBarrierSequenceNumber = NONE;\n+    }\n+\n+    /**\n+     * @return if given {@param sequenceNumber} should be spilled given {@link\n+     *     #lastBarrierSequenceNumber}. We might not have yet received {@link CheckpointBarrier} and\n+     *     we might need to spill everything. If we have already received it, there is a bit nasty\n+     *     corner case of {@link SequenceBuffer#sequenceNumber} overflowing that needs to be handled\n+     *     as well.\n+     */\n+    private boolean shouldBeSpilled(int sequenceNumber) {\n+        if (lastBarrierSequenceNumber == NONE) {\n+            return true;\n+        }\n+        checkState(\n+                receivedBuffers.size() < Integer.MAX_VALUE / 2,\n+                \"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+        boolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastBarrierSequenceNumber;\n+        boolean possibleOverflowBeforeOvertaking =\n+                lastBarrierSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+        if (possibleOverflowAfterOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber && sequenceNumber > 0;\n+        } else if (possibleOverflowBeforeOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber || sequenceNumber > 0;\n+        } else {\n+            return sequenceNumber < lastBarrierSequenceNumber;\n+        }\n+    }\n+\n+    public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n+        boolean success = false;\n+\n+        synchronized (receivedBuffers) {\n+            if (!isReleased.get()) {\n+                if (expectedSequenceNumber == sequenceNumber) {\n+                    expectedSequenceNumber++;\n+                    success = true;\n+                } else {\n+                    onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                }\n+            }\n+        }\n+\n+        if (success && backlog >= 0) {\n+            onSenderBacklog(backlog);\n+        }\n+    }\n+\n+    public void onFailedPartitionRequest() {\n+        inputGate.triggerPartitionStateCheck(partitionId);\n+    }\n+\n+    public void onError(Throwable cause) {\n+        setError(cause);\n+    }\n+\n+    private void checkPartitionRequestQueueInitialized() throws IOException {\n+        checkError();\n+        checkState(\n+                partitionRequestClient != null,\n+                \"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n+    }\n+\n+    private static class BufferReorderingException extends IOException {\n+\n+        private static final long serialVersionUID = -888282210356266816L;\n+\n+        private final int expectedSequenceNumber;\n+\n+        private final int actualSequenceNumber;\n+\n+        BufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n+            this.expectedSequenceNumber = expectedSequenceNumber;\n+            this.actualSequenceNumber = actualSequenceNumber;\n+        }\n+\n+        @Override\n+        public String getMessage() {\n+            return String.format(\n+                    \"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n+                    expectedSequenceNumber, actualSequenceNumber);\n+        }\n+    }\n+\n+    private static final class SequenceBuffer {\n+        final Buffer buffer;\n+        final int sequenceNumber;\n+\n+        private SequenceBuffer(Buffer buffer, int sequenceNumber) {\n+            this.buffer = buffer;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\n+                    \"SequenceBuffer(isEvent = %s, dataType = %s, sequenceNumber = %s)\",\n+                    !buffer.isBuffer(), buffer.getDataType(), sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "0ee049db1ffe8a4a68bcd97608774ee488d02a21", "committedDate": "2021-09-03 08:19:32 +0200", "message": "[FLINK-23907] Use primitive functional interfaces"}, {"oid": "138e83e2bc6feb59ecd839b03491cd8f23ee1c66", "committedDate": "2021-11-08 08:56:34 +0100", "message": "[FLINK-24738][runtime] Ignoring buffer size announcement if the channel is released already"}, {"oid": "4eea7bc9352134a06d2b207c9a94dd46a01c6132", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[FLINK-24657][runtime] Added metric of the total real size of input/output buffers queue"}, {"oid": "f4fd4f8bb66867821cb0f171218d85f8386b0897", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] Move consumedSubpartitionIndex from SingleInputGate to InputChannel"}, {"oid": "5c2ec72982128fc1a30014677916e0dd21f9c1d2", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] SingleInputGate supports consuming subpartition range"}, {"oid": "6398abcbff06b3e488a273144680f4838b4f1c92", "committedDate": "2023-06-09 22:48:37 +0800", "message": "[FLINK-31636][network] Introduce the NettyService framework"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg0NzQyMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422847423", "body": "The different message path is distinguished in both `PartitionRequestQueue` and `CreditBasedSequenceNumberingViewReader` now. We can improve it to judge only in one place instead.\r\n\r\n1. Introduce `ServerOutboundMessage` class to extend `NettyMessage` and make `AddBacklog` and `BufferResponse` both extend `ServerOutboundMessage`.\r\n2. Introduce `NetworkSequenceViewReader#getNextMessage` instead of existing `NetworkSequenceViewReader#getNextBuffer`. And inside `CreditBasedSequenceNumberingViewReader` implementation, we can judge the condition for distinguish.\r\n\r\n```\r\npublic NettyMessage.ServerOutboundMessage getNextMessage() throws IOException {\r\n\t\tif (numCreditsAvailable == 0 && initialCredit == 0 && !subpartitionView.isAvailable(numCreditsAvailable)) {\r\n\t\t\treturn getBacklogMessage();\r\n\t\t} else {\r\n\t\t\treturn getNextBufferResponse();\r\n\t\t}\r\n\t}\r\n```\r\n\r\nTo do so we can also reduce the necessary transformation between `BufferAndAvailability` and `BufferResponse`.", "bodyText": "The different message path is distinguished in both PartitionRequestQueue and CreditBasedSequenceNumberingViewReader now. We can improve it to judge only in one place instead.\n\nIntroduce ServerOutboundMessage class to extend NettyMessage and make AddBacklog and BufferResponse both extend ServerOutboundMessage.\nIntroduce NetworkSequenceViewReader#getNextMessage instead of existing NetworkSequenceViewReader#getNextBuffer. And inside CreditBasedSequenceNumberingViewReader implementation, we can judge the condition for distinguish.\n\npublic NettyMessage.ServerOutboundMessage getNextMessage() throws IOException {\n\t\tif (numCreditsAvailable == 0 && initialCredit == 0 && !subpartitionView.isAvailable(numCreditsAvailable)) {\n\t\t\treturn getBacklogMessage();\n\t\t} else {\n\t\t\treturn getNextBufferResponse();\n\t\t}\n\t}\n\nTo do so we can also reduce the necessary transformation between BufferAndAvailability and BufferResponse.", "bodyHTML": "<p dir=\"auto\">The different message path is distinguished in both <code>PartitionRequestQueue</code> and <code>CreditBasedSequenceNumberingViewReader</code> now. We can improve it to judge only in one place instead.</p>\n<ol dir=\"auto\">\n<li>Introduce <code>ServerOutboundMessage</code> class to extend <code>NettyMessage</code> and make <code>AddBacklog</code> and <code>BufferResponse</code> both extend <code>ServerOutboundMessage</code>.</li>\n<li>Introduce <code>NetworkSequenceViewReader#getNextMessage</code> instead of existing <code>NetworkSequenceViewReader#getNextBuffer</code>. And inside <code>CreditBasedSequenceNumberingViewReader</code> implementation, we can judge the condition for distinguish.</li>\n</ol>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public NettyMessage.ServerOutboundMessage getNextMessage() throws IOException {\n\t\tif (numCreditsAvailable == 0 &amp;&amp; initialCredit == 0 &amp;&amp; !subpartitionView.isAvailable(numCreditsAvailable)) {\n\t\t\treturn getBacklogMessage();\n\t\t} else {\n\t\t\treturn getNextBufferResponse();\n\t\t}\n\t}\n\"><pre><code>public NettyMessage.ServerOutboundMessage getNextMessage() throws IOException {\n\t\tif (numCreditsAvailable == 0 &amp;&amp; initialCredit == 0 &amp;&amp; !subpartitionView.isAvailable(numCreditsAvailable)) {\n\t\t\treturn getBacklogMessage();\n\t\t} else {\n\t\t\treturn getNextBufferResponse();\n\t\t}\n\t}\n</code></pre></div>\n<p dir=\"auto\">To do so we can also reduce the necessary transformation between <code>BufferAndAvailability</code> and <code>BufferResponse</code>.</p>", "author": "zhijiangW", "createdAt": "2020-05-11T07:47:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -234,11 +236,16 @@ private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IO\n \t\t\t\t\t\tregisterAvailableReader(reader);\n \t\t\t\t\t}\n \n-\t\t\t\t\tBufferResponse msg = new BufferResponse(\n-\t\t\t\t\t\tnext.buffer(),\n-\t\t\t\t\t\treader.getSequenceNumber(),\n-\t\t\t\t\t\treader.getReceiverId(),\n-\t\t\t\t\t\tnext.buffersInBacklog());\n+\t\t\t\t\tObject msg;\n+\t\t\t\t\tif (next.buffer() != null) {", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 3d3da181b2b..41faef88125 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -232,31 +234,20 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n \t\t\t\t} else {\n \t\t\t\t\t// This channel was now removed from the available reader queue.\n \t\t\t\t\t// We re-add it into the queue if it is still available\n-\t\t\t\t\tif (next.moreAvailable()) {\n+\t\t\t\t\tif (next.isMoreAvailable()) {\n \t\t\t\t\t\tregisterAvailableReader(reader);\n \t\t\t\t\t}\n \n-\t\t\t\t\tObject msg;\n-\t\t\t\t\tif (next.buffer() != null) {\n-\t\t\t\t\t\tmsg = new BufferResponse(\n-\t\t\t\t\t\t\tnext.buffer(),\n-\t\t\t\t\t\t\treader.getSequenceNumber(),\n-\t\t\t\t\t\t\treader.getReceiverId(),\n-\t\t\t\t\t\t\tnext.backlog());\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tmsg = new NettyMessage.AddBacklog(next.backlog(), reader.getReceiverId());\n-\t\t\t\t\t}\n-\n \t\t\t\t\t// Write and flush and wait until this is done before\n \t\t\t\t\t// trying to continue with the next buffer.\n-\t\t\t\t\tchannel.writeAndFlush(msg).addListener(writeListener);\n+\t\t\t\t\tchannel.writeAndFlush(next.build()).addListener(writeListener);\n \n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (Throwable t) {\n \t\t\tif (next != null) {\n-\t\t\t\tnext.buffer().recycleBuffer();\n+\t\t\t\tnext.recycleBufferIfNeeded();\n \t\t\t}\n \n \t\t\tthrow new IOException(t.getMessage(), t);\n", "next_change": {"commit": "a51d7760c34c0652321427daa153070874c54a61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 41faef88125..a34ba438049 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -247,7 +241,7 @@ public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n \t\t\t}\n \t\t} catch (Throwable t) {\n \t\t\tif (next != null) {\n-\t\t\t\tnext.recycleBufferIfNeeded();\n+\t\t\t\tnext.recycle();\n \t\t\t}\n \n \t\t\tthrow new IOException(t.getMessage(), t);\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex a34ba438049..df17ef3877c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -41,283 +41,321 @@ import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n+\n+import static org.apache.flink.runtime.io.network.netty.NettyMessage.BufferResponse;\n \n /**\n- * A nonEmptyReader of partition queues, which listens for channel writability changed\n- * events before writing and flushing {@link Buffer} instances.\n+ * A nonEmptyReader of partition queues, which listens for channel writability changed events before\n+ * writing and flushing {@link Buffer} instances.\n  */\n-public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n-\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n-\n-\tprivate final ChannelFutureListener writeListener = new WriteAndFlushNextMessageIfPossibleListener();\n-\n-\t/** The readers which are already enqueued available for transferring data or announcing backlog. */\n-\tprivate final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n-\n-\t/** All the readers created for the consumers' partition requests. */\n-\tprivate final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders = new ConcurrentHashMap<>();\n-\n-\tprivate boolean fatalError;\n-\n-\tprivate ChannelHandlerContext ctx;\n-\n-\t@Override\n-\tpublic void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n-\t\tif (this.ctx == null) {\n-\t\t\tthis.ctx = ctx;\n-\t\t}\n-\n-\t\tsuper.channelRegistered(ctx);\n-\t}\n-\n-\tvoid notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n-\t\t// The notification might come from the same thread. For the initial writes this\n-\t\t// might happen before the reader has set its reference to the view, because\n-\t\t// creating the queue and the initial notification happen in the same method call.\n-\t\t// This can be resolved by separating the creation of the view and allowing\n-\t\t// notifications.\n-\n-\t\t// TODO This could potentially have a bad performance impact as in the\n-\t\t// worst case (network consumes faster than the producer) each buffer\n-\t\t// will trigger a separate event loop task being scheduled.\n-\t\tctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n-\t}\n-\n-\t/**\n-\t * Try to enqueue the reader once receiving credit or resume consumption notification from\n-\t * the consumer or receiving non-empty reader notification from the producer.\n-\t *\n-\t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n-\t * availability, so there is no race condition here.\n-\t */\n-\tvoid enqueueAvailableReader(final NetworkSequenceViewReader reader, BooleanSupplier condition) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || !condition.getAsBoolean()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Queue an available reader for consumption. If the queue is empty,\n-\t\t// we try trigger the actual write. Otherwise this will be handled by\n-\t\t// the writeAndFlushNextMessageIfPossible calls.\n-\t\tboolean triggerWrite = availableReaders.isEmpty();\n-\t\tregisterAvailableReader(reader);\n-\n-\t\tif (triggerWrite) {\n-\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Accesses internal state to verify reader registration in the unit tests.\n-\t *\n-\t * <p><strong>Do not use anywhere else!</strong>\n-\t *\n-\t * @return readers which are enqueued available for transferring data or announcing backlog\n-\t */\n-\t@VisibleForTesting\n-\tArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n-\t\treturn availableReaders;\n-\t}\n-\n-\tpublic void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n-\t\tallReaders.put(reader.getReceiverId(), reader);\n-\t}\n-\n-\tpublic void cancel(InputChannelID receiverId) {\n-\t\tctx.pipeline().fireUserEventTriggered(receiverId);\n-\t}\n-\n-\tpublic void close() throws IOException {\n-\t\tif (ctx != null) {\n-\t\t\tctx.channel().close();\n-\t\t}\n-\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\t\tallReaders.clear();\n-\t}\n-\n-\t/**\n-\t * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n-\t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n-\t *\n-\t * @param receiverId The input channel id to identify the consumer.\n-\t * @param operation The operation to be performed (add credit or resume data consumption).\n-\t */\n-\tvoid addCreditOrResumeConsumption(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tFutureConsumerWithException<NetworkSequenceViewReader, Exception> operation) throws Exception {\n-\t\tif (fatalError) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n-\t\tif (reader != null) {\n-\t\t\toperation.acceptWithException(reader);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"No reader for receiverId = \" + receiverId + \" exists.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\t// The user event triggered event loop callback is used for thread-safe\n-\t\t// hand over of reader queues and cancelled producers.\n-\n-\t\tif (msg instanceof NetworkSequenceViewReader) {\n-\t\t\tNetworkSequenceViewReader reader = (NetworkSequenceViewReader) msg;\n-\t\t\tenqueueAvailableReader(reader, () -> (reader.isAvailable() || reader.shouldAnnounceBacklog(false)));\n-\t\t} else if (msg.getClass() == InputChannelID.class) {\n-\t\t\t// Release partition view that get a cancel request.\n-\t\t\tInputChannelID toCancel = (InputChannelID) msg;\n-\n-\t\t\t// remove reader from queue of available readers\n-\t\t\tavailableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n-\n-\t\t\t// remove reader from queue of all readers and release its resource\n-\t\t\tfinal NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n-\t\t\tif (toRelease != null) {\n-\t\t\t\treleaseViewReader(toRelease);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tctx.fireUserEventTriggered(msg);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t}\n-\n-\tprivate void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n-\t\tif (fatalError || !channel.isWritable()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// The logic here is very similar to the combined input gate and local\n-\t\t// input channel logic. You can think of this class acting as the input\n-\t\t// gate and the consumed views as the local input channels.\n-\n-\t\tServerOutboundMessage next = null;\n-\t\ttry {\n-\t\t\twhile (true) {\n-\t\t\t\tNetworkSequenceViewReader reader = pollAvailableReader();\n-\n-\t\t\t\t// No queue with available data. We allow this here, because\n-\t\t\t\t// of the write callbacks that are executed after each write.\n-\t\t\t\tif (reader == null) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\tnext = reader.getNextMessage();\n-\t\t\t\tif (next == null) {\n-\t\t\t\t\tif (!reader.isReleased()) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tThrowable cause = reader.getFailureCause();\n-\t\t\t\t\tif (cause != null) {\n-\t\t\t\t\t\tErrorResponse msg = new ErrorResponse(\n-\t\t\t\t\t\t\tnew ProducerFailedException(cause),\n-\t\t\t\t\t\t\treader.getReceiverId());\n-\n-\t\t\t\t\t\tctx.writeAndFlush(msg);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// This channel was now removed from the available reader queue.\n-\t\t\t\t\t// We re-add it into the queue if it is still available\n-\t\t\t\t\tif (next.isMoreAvailable()) {\n-\t\t\t\t\t\tregisterAvailableReader(reader);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Write and flush and wait until this is done before\n-\t\t\t\t\t// trying to continue with the next buffer.\n-\t\t\t\t\tchannel.writeAndFlush(next.build()).addListener(writeListener);\n-\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tif (next != null) {\n-\t\t\t\tnext.recycle();\n-\t\t\t}\n-\n-\t\t\tthrow new IOException(t.getMessage(), t);\n-\t\t}\n-\t}\n-\n-\tprivate void registerAvailableReader(NetworkSequenceViewReader reader) {\n-\t\tavailableReaders.add(reader);\n-\t\treader.setRegisteredAsAvailable(true);\n-\t}\n-\n-\t@Nullable\n-\tprivate NetworkSequenceViewReader pollAvailableReader() {\n-\t\tNetworkSequenceViewReader reader = availableReaders.poll();\n-\t\tif (reader != null) {\n-\t\t\treader.setRegisteredAsAvailable(false);\n-\t\t}\n-\t\treturn reader;\n-\t}\n-\n-\t@Override\n-\tpublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-\t\treleaseAllResources();\n-\n-\t\tctx.fireChannelInactive();\n-\t}\n-\n-\t@Override\n-\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-\t\thandleException(ctx.channel(), cause);\n-\t}\n-\n-\tprivate void handleException(Channel channel, Throwable cause) throws IOException {\n-\t\tLOG.error(\"Encountered error while consuming partitions\", cause);\n-\n-\t\tfatalError = true;\n-\t\treleaseAllResources();\n-\n-\t\tif (channel.isActive()) {\n-\t\t\tchannel.writeAndFlush(new ErrorResponse(cause)).addListener(ChannelFutureListener.CLOSE);\n-\t\t}\n-\t}\n-\n-\tprivate void releaseAllResources() throws IOException {\n-\t\t// note: this is only ever executed by one thread: the Netty IO thread!\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\n-\t\tavailableReaders.clear();\n-\t\tallReaders.clear();\n-\t}\n-\n-\tprivate void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n-\t\treader.setRegisteredAsAvailable(false);\n-\t\treader.releaseAllResources();\n-\t}\n-\n-\t// This listener is called after an element of the current nonEmptyReader has been\n-\t// flushed. If successful, the listener triggers further processing of the\n-\t// queues.\n-\tprivate class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n-\n-\t\t@Override\n-\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n-\t\t\ttry {\n-\t\t\t\tif (future.isSuccess()) {\n-\t\t\t\t\twriteAndFlushNextMessageIfPossible(future.channel());\n-\t\t\t\t} else if (future.cause() != null) {\n-\t\t\t\t\thandleException(future.channel(), future.cause());\n-\t\t\t\t} else {\n-\t\t\t\t\thandleException(future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\thandleException(future.channel(), t);\n-\t\t\t}\n-\t\t}\n-\t}\n+class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n+\n+    private final ChannelFutureListener writeListener =\n+            new WriteAndFlushNextMessageIfPossibleListener();\n+\n+    /** The readers which are already enqueued available for transferring data. */\n+    private final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n+\n+    /** All the readers created for the consumers' partition requests. */\n+    private final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders =\n+            new ConcurrentHashMap<>();\n+\n+    private boolean fatalError;\n+\n+    private ChannelHandlerContext ctx;\n+\n+    @Override\n+    public void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n+        if (this.ctx == null) {\n+            this.ctx = ctx;\n+        }\n+\n+        super.channelRegistered(ctx);\n+    }\n+\n+    void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n+        // The notification might come from the same thread. For the initial writes this\n+        // might happen before the reader has set its reference to the view, because\n+        // creating the queue and the initial notification happen in the same method call.\n+        // This can be resolved by separating the creation of the view and allowing\n+        // notifications.\n+\n+        // TODO This could potentially have a bad performance impact as in the\n+        // worst case (network consumes faster than the producer) each buffer\n+        // will trigger a separate event loop task being scheduled.\n+        ctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n+    }\n+\n+    /**\n+     * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n+     * non-empty reader notification from the producer.\n+     *\n+     * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n+     * availability, so there is no race condition here.\n+     */\n+    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n+        announceBacklogIfNeeded(reader, reader.getRemainingBacklog());\n+        if (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {\n+            return;\n+        }\n+        // Queue an available reader for consumption. If the queue is empty,\n+        // we try trigger the actual write. Otherwise this will be handled by\n+        // the writeAndFlushNextMessageIfPossible calls.\n+        boolean triggerWrite = availableReaders.isEmpty();\n+        registerAvailableReader(reader);\n+\n+        if (triggerWrite) {\n+            writeAndFlushNextMessageIfPossible(ctx.channel());\n+        }\n+    }\n+\n+    /**\n+     * Accesses internal state to verify reader registration in the unit tests.\n+     *\n+     * <p><strong>Do not use anywhere else!</strong>\n+     *\n+     * @return readers which are enqueued available for transferring data\n+     */\n+    @VisibleForTesting\n+    ArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n+        return availableReaders;\n+    }\n+\n+    public void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n+        allReaders.put(reader.getReceiverId(), reader);\n+    }\n+\n+    public void cancel(InputChannelID receiverId) {\n+        ctx.pipeline().fireUserEventTriggered(receiverId);\n+    }\n+\n+    public void close() throws IOException {\n+        if (ctx != null) {\n+            ctx.channel().close();\n+        }\n+\n+        releaseAllResources();\n+    }\n+\n+    /**\n+     * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n+     * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n+     *\n+     * @param receiverId The input channel id to identify the consumer.\n+     * @param operation The operation to be performed (add credit or resume data consumption).\n+     */\n+    void addCreditOrResumeConsumption(\n+            InputChannelID receiverId, Consumer<NetworkSequenceViewReader> operation)\n+            throws Exception {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            operation.accept(reader);\n+\n+            enqueueAvailableReader(reader);\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    /**\n+     * Announces remaining backlog to the consumer after the available data notification or data\n+     * consumption resumption.\n+     */\n+    private void announceBacklogIfNeeded(NetworkSequenceViewReader reader, int backlog) {\n+        if (backlog > 0 && reader.needAnnounceBacklog()) {\n+            NettyMessage.BacklogAnnouncement announcement =\n+                    new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n+            ctx.channel()\n+                    .writeAndFlush(announcement)\n+                    .addListener(\n+                            (ChannelFutureListener)\n+                                    future -> {\n+                                        if (!future.isSuccess()) {\n+                                            onChannelFutureFailure(future);\n+                                        }\n+                                    });\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        // The user event triggered event loop callback is used for thread-safe\n+        // hand over of reader queues and cancelled producers.\n+\n+        if (msg instanceof NetworkSequenceViewReader) {\n+            enqueueAvailableReader((NetworkSequenceViewReader) msg);\n+        } else if (msg.getClass() == InputChannelID.class) {\n+            // Release partition view that get a cancel request.\n+            InputChannelID toCancel = (InputChannelID) msg;\n+\n+            // remove reader from queue of available readers\n+            availableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n+\n+            // remove reader from queue of all readers and release its resource\n+            final NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n+            if (toRelease != null) {\n+                releaseViewReader(toRelease);\n+            }\n+        } else {\n+            ctx.fireUserEventTriggered(msg);\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        writeAndFlushNextMessageIfPossible(ctx.channel());\n+    }\n+\n+    private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n+        if (fatalError || !channel.isWritable()) {\n+            return;\n+        }\n+\n+        // The logic here is very similar to the combined input gate and local\n+        // input channel logic. You can think of this class acting as the input\n+        // gate and the consumed views as the local input channels.\n+\n+        BufferAndAvailability next = null;\n+        try {\n+            while (true) {\n+                NetworkSequenceViewReader reader = pollAvailableReader();\n+\n+                // No queue with available data. We allow this here, because\n+                // of the write callbacks that are executed after each write.\n+                if (reader == null) {\n+                    return;\n+                }\n+\n+                next = reader.getNextBuffer();\n+                if (next == null) {\n+                    if (!reader.isReleased()) {\n+                        continue;\n+                    }\n+\n+                    Throwable cause = reader.getFailureCause();\n+                    if (cause != null) {\n+                        ErrorResponse msg =\n+                                new ErrorResponse(\n+                                        new ProducerFailedException(cause), reader.getReceiverId());\n+\n+                        ctx.writeAndFlush(msg);\n+                    }\n+                } else {\n+                    // This channel was now removed from the available reader queue.\n+                    // We re-add it into the queue if it is still available\n+                    if (next.moreAvailable()) {\n+                        registerAvailableReader(reader);\n+                    }\n+\n+                    BufferResponse msg =\n+                            new BufferResponse(\n+                                    next.buffer(),\n+                                    next.getSequenceNumber(),\n+                                    reader.getReceiverId(),\n+                                    next.buffersInBacklog());\n+\n+                    // Write and flush and wait until this is done before\n+                    // trying to continue with the next buffer.\n+                    channel.writeAndFlush(msg).addListener(writeListener);\n+\n+                    return;\n+                }\n+            }\n+        } catch (Throwable t) {\n+            if (next != null) {\n+                next.buffer().recycleBuffer();\n+            }\n+\n+            throw new IOException(t.getMessage(), t);\n+        }\n+    }\n+\n+    private void registerAvailableReader(NetworkSequenceViewReader reader) {\n+        availableReaders.add(reader);\n+        reader.setRegisteredAsAvailable(true);\n+    }\n+\n+    @Nullable\n+    private NetworkSequenceViewReader pollAvailableReader() {\n+        NetworkSequenceViewReader reader = availableReaders.poll();\n+        if (reader != null) {\n+            reader.setRegisteredAsAvailable(false);\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        releaseAllResources();\n+\n+        ctx.fireChannelInactive();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        handleException(ctx.channel(), cause);\n+    }\n+\n+    private void handleException(Channel channel, Throwable cause) throws IOException {\n+        LOG.error(\"Encountered error while consuming partitions\", cause);\n+\n+        fatalError = true;\n+        releaseAllResources();\n+\n+        if (channel.isActive()) {\n+            channel.writeAndFlush(new ErrorResponse(cause))\n+                    .addListener(ChannelFutureListener.CLOSE);\n+        }\n+    }\n+\n+    private void releaseAllResources() throws IOException {\n+        // note: this is only ever executed by one thread: the Netty IO thread!\n+        for (NetworkSequenceViewReader reader : allReaders.values()) {\n+            releaseViewReader(reader);\n+        }\n+\n+        availableReaders.clear();\n+        allReaders.clear();\n+    }\n+\n+    private void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n+        reader.setRegisteredAsAvailable(false);\n+        reader.releaseAllResources();\n+    }\n+\n+    private void onChannelFutureFailure(ChannelFuture future) throws Exception {\n+        if (future.cause() != null) {\n+            handleException(future.channel(), future.cause());\n+        } else {\n+            handleException(\n+                    future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n+        }\n+    }\n+\n+    // This listener is called after an element of the current nonEmptyReader has been\n+    // flushed. If successful, the listener triggers further processing of the\n+    // queues.\n+    private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            try {\n+                if (future.isSuccess()) {\n+                    writeAndFlushNextMessageIfPossible(future.channel());\n+                } else {\n+                    onChannelFutureFailure(future);\n+                }\n+            } catch (Throwable t) {\n+                handleException(future.channel(), t);\n+            }\n+        }\n+    }\n }\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex df17ef3877c..0e3b6ddc57c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -350,8 +334,12 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n             try {\n                 if (future.isSuccess()) {\n                     writeAndFlushNextMessageIfPossible(future.channel());\n+                } else if (future.cause() != null) {\n+                    handleException(future.channel(), future.cause());\n                 } else {\n-                    onChannelFutureFailure(future);\n+                    handleException(\n+                            future.channel(),\n+                            new IllegalStateException(\"Sending cancelled by user.\"));\n                 }\n             } catch (Throwable t) {\n                 handleException(future.channel(), t);\n", "next_change": {"commit": "639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 0e3b6ddc57c..72ede48bda2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -334,12 +376,8 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n             try {\n                 if (future.isSuccess()) {\n                     writeAndFlushNextMessageIfPossible(future.channel());\n-                } else if (future.cause() != null) {\n-                    handleException(future.channel(), future.cause());\n                 } else {\n-                    handleException(\n-                            future.channel(),\n-                            new IllegalStateException(\"Sending cancelled by user.\"));\n+                    onChannelFutureFailure(future);\n                 }\n             } catch (Throwable t) {\n                 handleException(future.channel(), t);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 3d3da181b2b..72ede48bda2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -41,298 +42,346 @@ import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.function.Function;\n+import java.util.function.Consumer;\n \n import static org.apache.flink.runtime.io.network.netty.NettyMessage.BufferResponse;\n+import static org.apache.flink.util.Preconditions.checkArgument;\n \n /**\n- * A nonEmptyReader of partition queues, which listens for channel writability changed\n- * events before writing and flushing {@link Buffer} instances.\n+ * A nonEmptyReader of partition queues, which listens for channel writability changed events before\n+ * writing and flushing {@link Buffer} instances.\n  */\n class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n \n-\tprivate static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n-\n-\tprivate final ChannelFutureListener writeListener = new WriteAndFlushNextMessageIfPossibleListener();\n-\n-\t/** The readers which are already enqueued available for transferring data or announcing backlog. */\n-\tprivate final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n-\n-\t/** All the readers created for the consumers' partition requests. */\n-\tprivate final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders = new ConcurrentHashMap<>();\n-\n-\tprivate boolean fatalError;\n-\n-\tprivate ChannelHandlerContext ctx;\n-\n-\t@Override\n-\tpublic void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n-\t\tif (this.ctx == null) {\n-\t\t\tthis.ctx = ctx;\n-\t\t}\n-\n-\t\tsuper.channelRegistered(ctx);\n-\t}\n-\n-\tvoid notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n-\t\t// The notification might come from the same thread. For the initial writes this\n-\t\t// might happen before the reader has set its reference to the view, because\n-\t\t// creating the queue and the initial notification happen in the same method call.\n-\t\t// This can be resolved by separating the creation of the view and allowing\n-\t\t// notifications.\n-\n-\t\t// TODO This could potentially have a bad performance impact as in the\n-\t\t// worst case (network consumes faster than the producer) each buffer\n-\t\t// will trigger a separate event loop task being scheduled.\n-\t\tctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n-\t}\n-\n-\t/**\n-\t * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n-\t * non-empty reader notification from the producer.\n-\t *\n-\t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n-\t * availability, so there is no race condition here.\n-\t */\n-\tprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader, boolean announceBacklog) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || (!reader.isAvailable() && !announceBacklog)) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Queue an available reader for consumption. If the queue is empty,\n-\t\t// we try trigger the actual write. Otherwise this will be handled by\n-\t\t// the writeAndFlushNextMessageIfPossible calls.\n-\t\tboolean triggerWrite = availableReaders.isEmpty();\n-\t\tregisterAvailableReader(reader);\n-\n-\t\tif (triggerWrite) {\n-\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Accesses internal state to verify reader registration in the unit tests.\n-\t *\n-\t * <p><strong>Do not use anywhere else!</strong>\n-\t *\n-\t * @return readers which are enqueued available for transferring data or announcing backlog\n-\t */\n-\t@VisibleForTesting\n-\tArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n-\t\treturn availableReaders;\n-\t}\n-\n-\tpublic void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n-\t\tallReaders.put(reader.getReceiverId(), reader);\n-\t}\n-\n-\tpublic void cancel(InputChannelID receiverId) {\n-\t\tctx.pipeline().fireUserEventTriggered(receiverId);\n-\t}\n-\n-\tpublic void close() throws IOException {\n-\t\tif (ctx != null) {\n-\t\t\tctx.channel().close();\n-\t\t}\n-\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\t\tallReaders.clear();\n-\t}\n-\n-\t/**\n-\t * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n-\t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n-\t *\n-\t * @param receiverId The input channel id to identify the consumer.\n-\t * @param function The operation to be performed (add credit or resume data consumption).\n-\t */\n-\tvoid addCreditOrResumeConsumption(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tFunction<NetworkSequenceViewReader, Boolean> function) throws Exception {\n-\t\tif (fatalError) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n-\t\tif (reader != null) {\n-\t\t\tboolean needAnnounceBacklog = function.apply(reader);\n-\n-\t\t\tenqueueAvailableReader(reader, needAnnounceBacklog);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"No reader for receiverId = \" + receiverId + \" exists.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\t// The user event triggered event loop callback is used for thread-safe\n-\t\t// hand over of reader queues and cancelled producers.\n-\n-\t\tif (msg instanceof NetworkSequenceViewReader) {\n-\t\t\tNetworkSequenceViewReader reader = (NetworkSequenceViewReader) msg;\n-\t\t\tenqueueAvailableReader(reader, reader.shouldAnnounceBacklog());\n-\t\t} else if (msg.getClass() == InputChannelID.class) {\n-\t\t\t// Release partition view that get a cancel request.\n-\t\t\tInputChannelID toCancel = (InputChannelID) msg;\n-\n-\t\t\t// remove reader from queue of available readers\n-\t\t\tavailableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n-\n-\t\t\t// remove reader from queue of all readers and release its resource\n-\t\t\tfinal NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n-\t\t\tif (toRelease != null) {\n-\t\t\t\treleaseViewReader(toRelease);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tctx.fireUserEventTriggered(msg);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t}\n-\n-\tprivate void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n-\t\tif (fatalError || !channel.isWritable()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// The logic here is very similar to the combined input gate and local\n-\t\t// input channel logic. You can think of this class acting as the input\n-\t\t// gate and the consumed views as the local input channels.\n-\n-\t\tBufferAndAvailability next = null;\n-\t\ttry {\n-\t\t\twhile (true) {\n-\t\t\t\tNetworkSequenceViewReader reader = pollAvailableReader();\n-\n-\t\t\t\t// No queue with available data. We allow this here, because\n-\t\t\t\t// of the write callbacks that are executed after each write.\n-\t\t\t\tif (reader == null) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\tnext = reader.getNextBuffer();\n-\t\t\t\tif (next == null) {\n-\t\t\t\t\tif (!reader.isReleased()) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tThrowable cause = reader.getFailureCause();\n-\t\t\t\t\tif (cause != null) {\n-\t\t\t\t\t\tErrorResponse msg = new ErrorResponse(\n-\t\t\t\t\t\t\tnew ProducerFailedException(cause),\n-\t\t\t\t\t\t\treader.getReceiverId());\n-\n-\t\t\t\t\t\tctx.writeAndFlush(msg);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// This channel was now removed from the available reader queue.\n-\t\t\t\t\t// We re-add it into the queue if it is still available\n-\t\t\t\t\tif (next.moreAvailable()) {\n-\t\t\t\t\t\tregisterAvailableReader(reader);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tObject msg;\n-\t\t\t\t\tif (next.buffer() != null) {\n-\t\t\t\t\t\tmsg = new BufferResponse(\n-\t\t\t\t\t\t\tnext.buffer(),\n-\t\t\t\t\t\t\treader.getSequenceNumber(),\n-\t\t\t\t\t\t\treader.getReceiverId(),\n-\t\t\t\t\t\t\tnext.backlog());\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tmsg = new NettyMessage.AddBacklog(next.backlog(), reader.getReceiverId());\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Write and flush and wait until this is done before\n-\t\t\t\t\t// trying to continue with the next buffer.\n-\t\t\t\t\tchannel.writeAndFlush(msg).addListener(writeListener);\n-\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tif (next != null) {\n-\t\t\t\tnext.buffer().recycleBuffer();\n-\t\t\t}\n-\n-\t\t\tthrow new IOException(t.getMessage(), t);\n-\t\t}\n-\t}\n-\n-\tprivate void registerAvailableReader(NetworkSequenceViewReader reader) {\n-\t\tavailableReaders.add(reader);\n-\t\treader.setRegisteredAsAvailable(true);\n-\t}\n-\n-\t@Nullable\n-\tprivate NetworkSequenceViewReader pollAvailableReader() {\n-\t\tNetworkSequenceViewReader reader = availableReaders.poll();\n-\t\tif (reader != null) {\n-\t\t\treader.setRegisteredAsAvailable(false);\n-\t\t}\n-\t\treturn reader;\n-\t}\n-\n-\t@Override\n-\tpublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-\t\treleaseAllResources();\n-\n-\t\tctx.fireChannelInactive();\n-\t}\n-\n-\t@Override\n-\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-\t\thandleException(ctx.channel(), cause);\n-\t}\n-\n-\tprivate void handleException(Channel channel, Throwable cause) throws IOException {\n-\t\tLOG.error(\"Encountered error while consuming partitions\", cause);\n-\n-\t\tfatalError = true;\n-\t\treleaseAllResources();\n-\n-\t\tif (channel.isActive()) {\n-\t\t\tchannel.writeAndFlush(new ErrorResponse(cause)).addListener(ChannelFutureListener.CLOSE);\n-\t\t}\n-\t}\n-\n-\tprivate void releaseAllResources() throws IOException {\n-\t\t// note: this is only ever executed by one thread: the Netty IO thread!\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\n-\t\tavailableReaders.clear();\n-\t\tallReaders.clear();\n-\t}\n-\n-\tprivate void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n-\t\treader.setRegisteredAsAvailable(false);\n-\t\treader.releaseAllResources();\n-\t}\n-\n-\t// This listener is called after an element of the current nonEmptyReader has been\n-\t// flushed. If successful, the listener triggers further processing of the\n-\t// queues.\n-\tprivate class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n-\n-\t\t@Override\n-\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n-\t\t\ttry {\n-\t\t\t\tif (future.isSuccess()) {\n-\t\t\t\t\twriteAndFlushNextMessageIfPossible(future.channel());\n-\t\t\t\t} else if (future.cause() != null) {\n-\t\t\t\t\thandleException(future.channel(), future.cause());\n-\t\t\t\t} else {\n-\t\t\t\t\thandleException(future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\thandleException(future.channel(), t);\n-\t\t\t}\n-\t\t}\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n+\n+    private final ChannelFutureListener writeListener =\n+            new WriteAndFlushNextMessageIfPossibleListener();\n+\n+    /** The readers which are already enqueued available for transferring data. */\n+    private final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n+\n+    /** All the readers created for the consumers' partition requests. */\n+    private final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders =\n+            new ConcurrentHashMap<>();\n+\n+    private boolean fatalError;\n+\n+    private ChannelHandlerContext ctx;\n+\n+    @Override\n+    public void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n+        if (this.ctx == null) {\n+            this.ctx = ctx;\n+        }\n+\n+        super.channelRegistered(ctx);\n+    }\n+\n+    void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n+        // The notification might come from the same thread. For the initial writes this\n+        // might happen before the reader has set its reference to the view, because\n+        // creating the queue and the initial notification happen in the same method call.\n+        // This can be resolved by separating the creation of the view and allowing\n+        // notifications.\n+\n+        // TODO This could potentially have a bad performance impact as in the\n+        // worst case (network consumes faster than the producer) each buffer\n+        // will trigger a separate event loop task being scheduled.\n+        ctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n+    }\n+\n+    /**\n+     * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n+     * non-empty reader notification from the producer.\n+     *\n+     * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n+     * availability, so there is no race condition here.\n+     */\n+    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n+        if (reader.isRegisteredAsAvailable()) {\n+            return;\n+        }\n+\n+        ResultSubpartitionView.AvailabilityWithBacklog availabilityWithBacklog =\n+                reader.getAvailabilityAndBacklog();\n+        if (!availabilityWithBacklog.isAvailable()) {\n+            int backlog = availabilityWithBacklog.getBacklog();\n+            if (backlog > 0 && reader.needAnnounceBacklog()) {\n+                announceBacklog(reader, backlog);\n+            }\n+            return;\n+        }\n+\n+        // Queue an available reader for consumption. If the queue is empty,\n+        // we try trigger the actual write. Otherwise this will be handled by\n+        // the writeAndFlushNextMessageIfPossible calls.\n+        boolean triggerWrite = availableReaders.isEmpty();\n+        registerAvailableReader(reader);\n+\n+        if (triggerWrite) {\n+            writeAndFlushNextMessageIfPossible(ctx.channel());\n+        }\n+    }\n+\n+    /**\n+     * Accesses internal state to verify reader registration in the unit tests.\n+     *\n+     * <p><strong>Do not use anywhere else!</strong>\n+     *\n+     * @return readers which are enqueued available for transferring data\n+     */\n+    @VisibleForTesting\n+    ArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n+        return availableReaders;\n+    }\n+\n+    public void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n+        allReaders.put(reader.getReceiverId(), reader);\n+    }\n+\n+    public void cancel(InputChannelID receiverId) {\n+        ctx.pipeline().fireUserEventTriggered(receiverId);\n+    }\n+\n+    public void close() throws IOException {\n+        if (ctx != null) {\n+            ctx.channel().close();\n+        }\n+\n+        releaseAllResources();\n+    }\n+\n+    /**\n+     * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n+     * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n+     *\n+     * @param receiverId The input channel id to identify the consumer.\n+     * @param operation The operation to be performed (add credit or resume data consumption).\n+     */\n+    void addCreditOrResumeConsumption(\n+            InputChannelID receiverId, Consumer<NetworkSequenceViewReader> operation)\n+            throws Exception {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            operation.accept(reader);\n+\n+            enqueueAvailableReader(reader);\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    void acknowledgeAllRecordsProcessed(InputChannelID receiverId) {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            reader.acknowledgeAllRecordsProcessed();\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    /**\n+     * Announces remaining backlog to the consumer after the available data notification or data\n+     * consumption resumption.\n+     */\n+    private void announceBacklog(NetworkSequenceViewReader reader, int backlog) {\n+        checkArgument(backlog > 0, \"Backlog must be positive.\");\n+\n+        NettyMessage.BacklogAnnouncement announcement =\n+                new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n+        ctx.channel()\n+                .writeAndFlush(announcement)\n+                .addListener(\n+                        (ChannelFutureListener)\n+                                future -> {\n+                                    if (!future.isSuccess()) {\n+                                        onChannelFutureFailure(future);\n+                                    }\n+                                });\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        // The user event triggered event loop callback is used for thread-safe\n+        // hand over of reader queues and cancelled producers.\n+\n+        if (msg instanceof NetworkSequenceViewReader) {\n+            enqueueAvailableReader((NetworkSequenceViewReader) msg);\n+        } else if (msg.getClass() == InputChannelID.class) {\n+            // Release partition view that get a cancel request.\n+            InputChannelID toCancel = (InputChannelID) msg;\n+\n+            // remove reader from queue of available readers\n+            availableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n+\n+            // remove reader from queue of all readers and release its resource\n+            final NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n+            if (toRelease != null) {\n+                releaseViewReader(toRelease);\n+            }\n+        } else {\n+            ctx.fireUserEventTriggered(msg);\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        writeAndFlushNextMessageIfPossible(ctx.channel());\n+    }\n+\n+    private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n+        if (fatalError || !channel.isWritable()) {\n+            return;\n+        }\n+\n+        // The logic here is very similar to the combined input gate and local\n+        // input channel logic. You can think of this class acting as the input\n+        // gate and the consumed views as the local input channels.\n+\n+        BufferAndAvailability next = null;\n+        try {\n+            while (true) {\n+                NetworkSequenceViewReader reader = pollAvailableReader();\n+\n+                // No queue with available data. We allow this here, because\n+                // of the write callbacks that are executed after each write.\n+                if (reader == null) {\n+                    return;\n+                }\n+\n+                next = reader.getNextBuffer();\n+                if (next == null) {\n+                    if (!reader.isReleased()) {\n+                        continue;\n+                    }\n+\n+                    Throwable cause = reader.getFailureCause();\n+                    if (cause != null) {\n+                        ErrorResponse msg =\n+                                new ErrorResponse(\n+                                        new ProducerFailedException(cause), reader.getReceiverId());\n+\n+                        ctx.writeAndFlush(msg);\n+                    }\n+                } else {\n+                    // This channel was now removed from the available reader queue.\n+                    // We re-add it into the queue if it is still available\n+                    if (next.moreAvailable()) {\n+                        registerAvailableReader(reader);\n+                    }\n+\n+                    BufferResponse msg =\n+                            new BufferResponse(\n+                                    next.buffer(),\n+                                    next.getSequenceNumber(),\n+                                    reader.getReceiverId(),\n+                                    next.buffersInBacklog());\n+\n+                    // Write and flush and wait until this is done before\n+                    // trying to continue with the next buffer.\n+                    channel.writeAndFlush(msg).addListener(writeListener);\n+\n+                    return;\n+                }\n+            }\n+        } catch (Throwable t) {\n+            if (next != null) {\n+                next.buffer().recycleBuffer();\n+            }\n+\n+            throw new IOException(t.getMessage(), t);\n+        }\n+    }\n+\n+    private void registerAvailableReader(NetworkSequenceViewReader reader) {\n+        availableReaders.add(reader);\n+        reader.setRegisteredAsAvailable(true);\n+    }\n+\n+    @Nullable\n+    private NetworkSequenceViewReader pollAvailableReader() {\n+        NetworkSequenceViewReader reader = availableReaders.poll();\n+        if (reader != null) {\n+            reader.setRegisteredAsAvailable(false);\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        releaseAllResources();\n+\n+        ctx.fireChannelInactive();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        handleException(ctx.channel(), cause);\n+    }\n+\n+    private void handleException(Channel channel, Throwable cause) throws IOException {\n+        LOG.error(\"Encountered error while consuming partitions\", cause);\n+\n+        fatalError = true;\n+        releaseAllResources();\n+\n+        if (channel.isActive()) {\n+            channel.writeAndFlush(new ErrorResponse(cause))\n+                    .addListener(ChannelFutureListener.CLOSE);\n+        }\n+    }\n+\n+    private void releaseAllResources() throws IOException {\n+        // note: this is only ever executed by one thread: the Netty IO thread!\n+        for (NetworkSequenceViewReader reader : allReaders.values()) {\n+            releaseViewReader(reader);\n+        }\n+\n+        availableReaders.clear();\n+        allReaders.clear();\n+    }\n+\n+    private void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n+        reader.setRegisteredAsAvailable(false);\n+        reader.releaseAllResources();\n+    }\n+\n+    private void onChannelFutureFailure(ChannelFuture future) throws Exception {\n+        if (future.cause() != null) {\n+            handleException(future.channel(), future.cause());\n+        } else {\n+            handleException(\n+                    future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n+        }\n+    }\n+\n+    // This listener is called after an element of the current nonEmptyReader has been\n+    // flushed. If successful, the listener triggers further processing of the\n+    // queues.\n+    private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            try {\n+                if (future.isSuccess()) {\n+                    writeAndFlushNextMessageIfPossible(future.channel());\n+                } else {\n+                    onChannelFutureFailure(future);\n+                }\n+            } catch (Throwable t) {\n+                handleException(future.channel(), t);\n+            }\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "7478445aa30cd28b7b6402565ca304c916024475", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[refactor][runtime] Unification of obtaining reader in PartitionRequestQueue"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}, {"oid": "7bacef09622d43c01ca9a749bbcd259d5cd3e0fe", "committedDate": "2021-09-17 20:16:25 +0200", "message": "[FLINK-24233][runtime] Ignore message about new buffer size if the reader doesn't ready yet"}, {"oid": "f957e3fee50e734dd6b2cbf0cbbef00fe810cd32", "committedDate": "2022-01-13 15:07:28 +0100", "message": "[FLINK-25441][network] Wrap failure cuase with ProducerFailedException only for PipelinedSubpartitionView."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2MzY5NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422863695", "body": "The previous `buffersInBacklog` variable should be replaced by this new variable, to avoid maintaining two variables.", "bodyText": "The previous buffersInBacklog variable should be replaced by this new variable, to avoid maintaining two variables.", "bodyHTML": "<p dir=\"auto\">The previous <code>buffersInBacklog</code> variable should be replaced by this new variable, to avoid maintaining two variables.</p>", "author": "zhijiangW", "createdAt": "2020-05-11T08:16:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -70,6 +70,10 @@\n \t@GuardedBy(\"buffers\")\n \tprivate int buffersInBacklog;\n \n+\t/** The number of non-event buffers to be announced to the downstream. */\n+\t@GuardedBy(\"buffers\")\n+\tprivate int unannouncedBacklog;", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 840cfb80b5a..6d24a58afc5 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -66,10 +65,6 @@ public class PipelinedSubpartition extends ResultSubpartition {\n \t/** All buffers of this subpartition. Access to the buffers is synchronized on this object. */\n \tprivate final ArrayDeque<BufferConsumer> buffers = new ArrayDeque<>();\n \n-\t/** The number of non-event buffers currently in this subpartition. */\n-\t@GuardedBy(\"buffers\")\n-\tprivate int buffersInBacklog;\n-\n \t/** The number of non-event buffers to be announced to the downstream. */\n \t@GuardedBy(\"buffers\")\n \tprivate int unannouncedBacklog;\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 6d24a58afc5..50ffb456543 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -33,460 +40,535 @@ import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n import java.io.IOException;\n-import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n \n+import static java.util.Objects.requireNonNull;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n  * A pipelined in-memory only subpartition, which can be consumed once.\n  *\n- * <p>Whenever {@link ResultSubpartition#add(BufferConsumer, boolean)} adds a finished {@link BufferConsumer} or a second\n- * {@link BufferConsumer} (in which case we will assume the first one finished), we will\n- * {@link PipelinedSubpartitionView#notifyDataAvailable() notify} a read view created via\n- * {@link ResultSubpartition#createReadView(BufferAvailabilityListener)} of new data availability. Except by calling\n- * {@link #flush()} explicitly, we always only notify when the first finished buffer turns up and\n- * then, the reader has to drain the buffers via {@link #pollBuffer()} until its return value shows\n- * no more buffers being available. This results in a buffer queue which is either empty or has an\n- * unfinished {@link BufferConsumer} left from which the notifications will eventually start again.\n+ * <p>Whenever {@link ResultSubpartition#add(BufferConsumer)} adds a finished {@link BufferConsumer}\n+ * or a second {@link BufferConsumer} (in which case we will assume the first one finished), we will\n+ * {@link PipelinedSubpartitionView#notifyDataAvailable() notify} a read view created via {@link\n+ * ResultSubpartition#createReadView(BufferAvailabilityListener)} of new data availability. Except\n+ * by calling {@link #flush()} explicitly, we always only notify when the first finished buffer\n+ * turns up and then, the reader has to drain the buffers via {@link #pollBuffer()} until its return\n+ * value shows no more buffers being available. This results in a buffer queue which is either empty\n+ * or has an unfinished {@link BufferConsumer} left from which the notifications will eventually\n+ * start again.\n  *\n- * <p>Explicit calls to {@link #flush()} will force this\n- * {@link PipelinedSubpartitionView#notifyDataAvailable() notification} for any\n- * {@link BufferConsumer} present in the queue.\n+ * <p>Explicit calls to {@link #flush()} will force this {@link\n+ * PipelinedSubpartitionView#notifyDataAvailable() notification} for any {@link BufferConsumer}\n+ * present in the queue.\n  */\n-public class PipelinedSubpartition extends ResultSubpartition {\n-\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(PipelinedSubpartition.class);\n-\n-\t// ------------------------------------------------------------------------\n-\n-\t/** All buffers of this subpartition. Access to the buffers is synchronized on this object. */\n-\tprivate final ArrayDeque<BufferConsumer> buffers = new ArrayDeque<>();\n-\n-\t/** The number of non-event buffers to be announced to the downstream. */\n-\t@GuardedBy(\"buffers\")\n-\tprivate int unannouncedBacklog;\n-\n-\t/** The read view to consume this subpartition. */\n-\tprivate PipelinedSubpartitionView readView;\n-\n-\t/** Flag indicating whether the subpartition has been finished. */\n-\tprivate boolean isFinished;\n-\n-\t@GuardedBy(\"buffers\")\n-\tprivate boolean flushRequested;\n-\n-\t/** Flag indicating whether the subpartition has been released. */\n-\tprivate volatile boolean isReleased;\n-\n-\t/** The total number of buffers (both data and event buffers). */\n-\tprivate long totalNumberOfBuffers;\n-\n-\t/** The total number of bytes (both data and event buffers). */\n-\tprivate long totalNumberOfBytes;\n-\n-\t/** The collection of buffers which are spanned over by checkpoint barrier and needs to be persisted for snapshot. */\n-\tprivate final List<Buffer> inflightBufferSnapshot = new ArrayList<>();\n-\n-\t/** Whether this subpartition is blocked by exactly once checkpoint and is waiting for resumption. */\n-\t@GuardedBy(\"buffers\")\n-\tprivate boolean isBlockedByCheckpoint = false;\n-\n-\t// ------------------------------------------------------------------------\n-\n-\tPipelinedSubpartition(int index, ResultPartition parent) {\n-\t\tsuper(index, parent);\n-\t}\n-\n-\t@Override\n-\tpublic void readRecoveredState(ChannelStateReader stateReader) throws IOException, InterruptedException {\n-\t\tboolean recycleBuffer = true;\n-\t\tfor (ReadResult readResult = ReadResult.HAS_MORE_DATA; readResult == ReadResult.HAS_MORE_DATA;) {\n-\t\t\tBufferBuilder bufferBuilder = parent.getBufferPool().requestBufferBuilderBlocking(subpartitionInfo.getSubPartitionIdx());\n-\t\t\tBufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer();\n-\t\t\ttry {\n-\t\t\t\treadResult = stateReader.readOutputData(subpartitionInfo, bufferBuilder);\n-\n-\t\t\t\t// check whether there are some states data filled in this time\n-\t\t\t\tif (bufferConsumer.isDataAvailable()) {\n-\t\t\t\t\tadd(bufferConsumer, false, false);\n-\t\t\t\t\trecycleBuffer = false;\n-\t\t\t\t\tbufferBuilder.finish();\n-\t\t\t\t}\n-\t\t\t} finally {\n-\t\t\t\tif (recycleBuffer) {\n-\t\t\t\t\tbufferConsumer.close();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic boolean add(BufferConsumer bufferConsumer, boolean isPriorityEvent) throws IOException {\n-\t\tif (isPriorityEvent) {\n-\t\t\tif (readView != null && readView.notifyPriorityEvent(bufferConsumer)) {\n-\t\t\t\tbufferConsumer.close();\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\treturn add(bufferConsumer, false, true);\n-\t\t}\n-\t\treturn add(bufferConsumer, false, false);\n-\t}\n-\n-\t@Override\n-\tpublic void finish() throws IOException {\n-\t\tadd(EventSerializer.toBufferConsumer(EndOfPartitionEvent.INSTANCE), true, false);\n-\t\tLOG.debug(\"{}: Finished {}.\", parent.getOwningTaskName(), this);\n-\t}\n-\n-\tprivate boolean add(BufferConsumer bufferConsumer, boolean finish, boolean insertAsHead) {\n-\t\tcheckNotNull(bufferConsumer);\n-\n-\t\tfinal boolean notifyDataAvailable;\n-\t\tsynchronized (buffers) {\n-\t\t\tif (isFinished || isReleased) {\n-\t\t\t\tbufferConsumer.close();\n-\t\t\t\treturn false;\n-\t\t\t}\n-\n-\t\t\t// Add the bufferConsumer and update the stats\n-\t\t\thandleAddingBarrier(bufferConsumer, insertAsHead);\n-\t\t\tupdateStatistics(bufferConsumer);\n-\t\t\tincreaseUnannouncedBacklog(bufferConsumer);\n-\t\t\tnotifyDataAvailable = insertAsHead || finish || shouldNotifyDataAvailable();\n-\t\t\tincreaseUnannouncedBacklogIfNeeded(notifyDataAvailable);\n-\n-\t\t\tisFinished |= finish;\n-\t\t}\n-\n-\t\tif (notifyDataAvailable) {\n-\t\t\tnotifyDataAvailable();\n-\t\t}\n-\n-\t\treturn true;\n-\t}\n-\n-\tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n-\t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n-\n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tbuffers.addFirst(bufferConsumer);\n-\t\t} else {\n-\t\t\tbuffers.add(bufferConsumer);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic List<Buffer> requestInflightBufferSnapshot() {\n-\t\tList<Buffer> snapshot = new ArrayList<>(inflightBufferSnapshot);\n-\t\tinflightBufferSnapshot.clear();\n-\t\treturn snapshot;\n-\t}\n-\n-\t@Override\n-\tpublic void release() {\n-\t\t// view reference accessible outside the lock, but assigned inside the locked scope\n-\t\tfinal PipelinedSubpartitionView view;\n-\n-\t\tsynchronized (buffers) {\n-\t\t\tif (isReleased) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// Release all available buffers\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\tbuffer.close();\n-\t\t\t}\n-\t\t\tbuffers.clear();\n-\n-\t\t\tview = readView;\n-\t\t\treadView = null;\n-\n-\t\t\t// Make sure that no further buffers are added to the subpartition\n-\t\t\tisReleased = true;\n-\t\t}\n-\n-\t\tLOG.debug(\"{}: Released {}.\", parent.getOwningTaskName(), this);\n-\n-\t\tif (view != null) {\n-\t\t\tview.releaseAllResources();\n-\t\t}\n-\t}\n-\n-\t@Nullable\n-\tBufferAndBacklog pollBuffer() {\n-\t\tsynchronized (buffers) {\n-\t\t\tif (isBlockedByCheckpoint) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n-\t\t\tBuffer buffer = null;\n-\n-\t\t\tif (buffers.isEmpty()) {\n-\t\t\t\tflushRequested = false;\n-\t\t\t}\n-\n-\t\t\twhile (!buffers.isEmpty()) {\n-\t\t\t\tBufferConsumer bufferConsumer = buffers.peek();\n-\n-\t\t\t\tbuffer = bufferConsumer.build();\n-\n-\t\t\t\tcheckState(bufferConsumer.isFinished() || buffers.size() == 1,\n-\t\t\t\t\t\"When there are multiple buffers, an unfinished bufferConsumer can not be at the head of the buffers queue.\");\n-\n-\t\t\t\tif (buffers.size() == 1) {\n-\t\t\t\t\t// turn off flushRequested flag if we drained all of the available data\n-\t\t\t\t\tflushRequested = false;\n-\t\t\t\t}\n-\n-\t\t\t\tif (bufferConsumer.isFinished()) {\n-\t\t\t\t\tbuffers.pop().close();\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer.readableBytes() > 0) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t\tbuffer = null;\n-\t\t\t\tif (!bufferConsumer.isFinished()) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (buffer == null) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n-\t\t\tif (Buffer.DataType.isAlignedExactlyOnceCheckpointBarrier(buffer)) {\n-\t\t\t\tisBlockedByCheckpoint = true;\n-\t\t\t}\n-\n-\t\t\tupdateStatistics(buffer);\n-\t\t\t// Do not report last remaining buffer on buffers as available to read (assuming it's unfinished).\n-\t\t\t// It will be reported for reading either on flush or when the number of buffers in the queue\n-\t\t\t// will be 2 or more.\n-\t\t\treturn new BufferAndBacklog(\n-\t\t\t\tbuffer,\n-\t\t\t\tisDataAvailableUnsafe(),\n-\t\t\t\tgetAndResetUnannouncedBacklogUnsafe(),\n-\t\t\t\tisEventAvailableUnsafe());\n-\t\t}\n-\t}\n-\n-\tvoid resumeConsumption() {\n-\t\tsynchronized (buffers) {\n-\t\t\tcheckState(isBlockedByCheckpoint, \"Should be blocked by checkpoint.\");\n-\n-\t\t\tisBlockedByCheckpoint = false;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int releaseMemory() {\n-\t\t// The pipelined subpartition does not react to memory release requests.\n-\t\t// The buffers will be recycled by the consuming task.\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased;\n-\t}\n-\n-\t@Override\n-\tpublic PipelinedSubpartitionView createReadView(BufferAvailabilityListener availabilityListener) throws IOException {\n-\t\tfinal boolean notifyDataAvailable;\n-\t\tsynchronized (buffers) {\n-\t\t\tcheckState(!isReleased);\n-\t\t\tcheckState(readView == null,\n-\t\t\t\t\"Subpartition %s of is being (or already has been) consumed, \" +\n-\t\t\t\t\"but pipelined subpartitions can only be consumed once.\",\n-\t\t\t\tgetSubPartitionIndex(),\n-\t\t\t\tparent.getPartitionId());\n-\n-\t\t\tLOG.debug(\"{}: Creating read view for subpartition {} of partition {}.\",\n-\t\t\t\tparent.getOwningTaskName(), getSubPartitionIndex(), parent.getPartitionId());\n-\n-\t\t\treadView = new PipelinedSubpartitionView(this, availabilityListener);\n-\t\t\tnotifyDataAvailable = !buffers.isEmpty();\n-\t\t}\n-\t\tif (notifyDataAvailable) {\n-\t\t\tnotifyDataAvailable();\n-\t\t}\n-\n-\t\treturn readView;\n-\t}\n-\n-\tpublic boolean isAvailable(int numCreditsAvailable) {\n-\t\tsynchronized (buffers) {\n-\t\t\tif (numCreditsAvailable > 0) {\n-\t\t\t\treturn isDataAvailableUnsafe();\n-\t\t\t}\n-\n-\t\t\treturn isEventAvailableUnsafe();\n-\t\t}\n-\t}\n-\n-\tprivate boolean isDataAvailableUnsafe() {\n-\t\tassert Thread.holdsLock(buffers);\n-\n-\t\treturn !isBlockedByCheckpoint && (flushRequested || getNumberOfFinishedBuffers() > 0);\n-\t}\n-\n-\tprivate boolean isEventAvailableUnsafe() {\n-\t\tassert Thread.holdsLock(buffers);\n-\n-\t\treturn !isBlockedByCheckpoint && !buffers.isEmpty() && !buffers.peekFirst().isBuffer();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\n-\tint getCurrentNumberOfBuffers() {\n-\t\treturn buffers.size();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\tfinal long numBuffers;\n-\t\tfinal long numBytes;\n-\t\tfinal boolean finished;\n-\t\tfinal boolean hasReadView;\n-\n-\t\tsynchronized (buffers) {\n-\t\t\tnumBuffers = getTotalNumberOfBuffers();\n-\t\t\tnumBytes = getTotalNumberOfBytes();\n-\t\t\tfinished = isFinished;\n-\t\t\thasReadView = readView != null;\n-\t\t}\n-\n-\t\treturn String.format(\n-\t\t\t\"PipelinedSubpartition#%d [number of buffers: %d (%d bytes), unannounced backlog: %d, finished? %s, read view? %s]\",\n-\t\t\tgetSubPartitionIndex(), numBuffers, numBytes, unannouncedBacklog, finished, hasReadView);\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\t// since we do not synchronize, the size may actually be lower than 0!\n-\t\treturn Math.max(buffers.size(), 0);\n-\t}\n-\n-\t@Override\n-\tpublic void flush() {\n-\t\tfinal boolean notifyDataAvailable;\n-\t\tsynchronized (buffers) {\n-\t\t\tif (buffers.isEmpty() || flushRequested) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\t// if there is more then 1 buffer, we already notified the reader\n-\t\t\t// (at the latest when adding the second buffer)\n-\t\t\tnotifyDataAvailable = !isBlockedByCheckpoint && buffers.size() == 1 && buffers.peek().isDataAvailable();\n-\t\t\tflushRequested = buffers.size() > 1 || notifyDataAvailable;\n-\t\t\tincreaseUnannouncedBacklogIfNeeded(notifyDataAvailable);\n-\t\t}\n-\t\tif (notifyDataAvailable) {\n-\t\t\tnotifyDataAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected long getTotalNumberOfBuffers() {\n-\t\treturn totalNumberOfBuffers;\n-\t}\n-\n-\t@Override\n-\tprotected long getTotalNumberOfBytes() {\n-\t\treturn totalNumberOfBytes;\n-\t}\n-\n-\tThrowable getFailureCause() {\n-\t\treturn parent.getFailureCause();\n-\t}\n-\n-\tprivate void updateStatistics(BufferConsumer buffer) {\n-\t\ttotalNumberOfBuffers++;\n-\t}\n-\n-\tprivate void updateStatistics(Buffer buffer) {\n-\t\ttotalNumberOfBytes += buffer.getSize();\n-\t}\n-\n-\t/**\n-\t * Increases the number of unannounced backlog by one after adding a non-event buffer into this subpartition.\n-\t */\n-\t@GuardedBy(\"buffers\")\n-\tprivate void increaseUnannouncedBacklog(BufferConsumer buffer) {\n-\t\tassert Thread.holdsLock(buffers);\n-\n-\t\tif (buffer != null && buffer.isBuffer()) {\n-\t\t\tunannouncedBacklog++;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Increases the unannounced backlog by one if we have a new sliced buffer to be read.\n-\t */\n-\t@GuardedBy(\"buffers\")\n-\tprivate void increaseUnannouncedBacklogIfNeeded(boolean notifyDataAvailable) {\n-\t\tassert Thread.holdsLock(buffers);\n-\n-\t\tBufferConsumer buffer = buffers.peekFirst();\n-\t\tif (notifyDataAvailable && !buffers.isEmpty() && buffer.isSliced() && buffer.isDataAvailable()) {\n-\t\t\t++unannouncedBacklog;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int getUnannouncedBacklog() {\n-\t\treturn unannouncedBacklog;\n-\t}\n-\n-\tint getAndResetUnannouncedBacklog() {\n-\t\tsynchronized (buffers) {\n-\t\t\treturn getAndResetUnannouncedBacklogUnsafe();\n-\t\t}\n-\t}\n-\n-\tprivate int getAndResetUnannouncedBacklogUnsafe() {\n-\t\tint numBacklog = unannouncedBacklog;\n-\t\tunannouncedBacklog = 0;\n-\t\treturn numBacklog;\n-\t}\n-\n-\tprivate boolean shouldNotifyDataAvailable() {\n-\t\t// Notify only when we added first finished buffer.\n-\t\treturn readView != null && !flushRequested && !isBlockedByCheckpoint && getNumberOfFinishedBuffers() == 1;\n-\t}\n-\n-\tprivate void notifyDataAvailable() {\n-\t\tif (readView != null) {\n-\t\t\treadView.notifyDataAvailable();\n-\t\t}\n-\t}\n-\n-\tprivate int getNumberOfFinishedBuffers() {\n-\t\tassert Thread.holdsLock(buffers);\n-\n-\t\t// NOTE: isFinished() is not guaranteed to provide the most up-to-date state here\n-\t\t// worst-case: a single finished buffer sits around until the next flush() call\n-\t\t// (but we do not offer stronger guarantees anyway)\n-\t\tif (buffers.size() == 1 && buffers.peekLast().isFinished()) {\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\t// We assume that only last buffer is not finished.\n-\t\treturn Math.max(0, buffers.size() - 1);\n-\t}\n+public class PipelinedSubpartition extends ResultSubpartition\n+        implements CheckpointedResultSubpartition, ChannelStateHolder {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PipelinedSubpartition.class);\n+\n+    // ------------------------------------------------------------------------\n+\n+    /** All buffers of this subpartition. Access to the buffers is synchronized on this object. */\n+    final PrioritizedDeque<BufferConsumerWithPartialRecordLength> buffers =\n+            new PrioritizedDeque<>();\n+\n+    /** The number of non-event buffers currently in this subpartition. */\n+    @GuardedBy(\"buffers\")\n+    private int buffersInBacklog;\n+\n+    /** The read view to consume this subpartition. */\n+    PipelinedSubpartitionView readView;\n+\n+    /** Flag indicating whether the subpartition has been finished. */\n+    private boolean isFinished;\n+\n+    @GuardedBy(\"buffers\")\n+    private boolean flushRequested;\n+\n+    /** Flag indicating whether the subpartition has been released. */\n+    volatile boolean isReleased;\n+\n+    /** The total number of buffers (both data and event buffers). */\n+    private long totalNumberOfBuffers;\n+\n+    /** The total number of bytes (both data and event buffers). */\n+    private long totalNumberOfBytes;\n+\n+    /** Writes in-flight data. */\n+    private ChannelStateWriter channelStateWriter;\n+\n+    /**\n+     * Whether this subpartition is blocked (e.g. by exactly once checkpoint) and is waiting for\n+     * resumption.\n+     */\n+    @GuardedBy(\"buffers\")\n+    boolean isBlocked = false;\n+\n+    int sequenceNumber = 0;\n+\n+    // ------------------------------------------------------------------------\n+\n+    PipelinedSubpartition(int index, ResultPartition parent) {\n+        super(index, parent);\n+    }\n+\n+    @Override\n+    public void setChannelStateWriter(ChannelStateWriter channelStateWriter) {\n+        checkState(this.channelStateWriter == null, \"Already initialized\");\n+        this.channelStateWriter = checkNotNull(channelStateWriter);\n+    }\n+\n+    @Override\n+    public boolean add(BufferConsumer bufferConsumer, int partialRecordLength) {\n+        return add(bufferConsumer, partialRecordLength, false);\n+    }\n+\n+    @Override\n+    public void finishReadRecoveredState(boolean notifyAndBlockOnCompletion) throws IOException {\n+        if (notifyAndBlockOnCompletion) {\n+            add(EventSerializer.toBufferConsumer(EndOfChannelStateEvent.INSTANCE, false), 0, false);\n+        }\n+    }\n+\n+    @Override\n+    public void finish() throws IOException {\n+        add(EventSerializer.toBufferConsumer(EndOfPartitionEvent.INSTANCE, false), 0, true);\n+        LOG.debug(\"{}: Finished {}.\", parent.getOwningTaskName(), this);\n+    }\n+\n+    private boolean add(BufferConsumer bufferConsumer, int partialRecordLength, boolean finish) {\n+        checkNotNull(bufferConsumer);\n+\n+        final boolean notifyDataAvailable;\n+        int prioritySequenceNumber = -1;\n+        synchronized (buffers) {\n+            if (isFinished || isReleased) {\n+                bufferConsumer.close();\n+                return false;\n+            }\n+\n+            // Add the bufferConsumer and update the stats\n+            if (addBuffer(bufferConsumer, partialRecordLength)) {\n+                prioritySequenceNumber = sequenceNumber;\n+            }\n+            updateStatistics(bufferConsumer);\n+            increaseBuffersInBacklog(bufferConsumer);\n+            notifyDataAvailable = finish || shouldNotifyDataAvailable();\n+\n+            isFinished |= finish;\n+        }\n+\n+        if (prioritySequenceNumber != -1) {\n+            notifyPriorityEvent(prioritySequenceNumber);\n+        }\n+        if (notifyDataAvailable) {\n+            notifyDataAvailable();\n+        }\n+\n+        return true;\n+    }\n+\n+    private boolean addBuffer(BufferConsumer bufferConsumer, int partialRecordLength) {\n+        assert Thread.holdsLock(buffers);\n+        if (bufferConsumer.getDataType().hasPriority()) {\n+            return processPriorityBuffer(bufferConsumer, partialRecordLength);\n+        }\n+        buffers.add(new BufferConsumerWithPartialRecordLength(bufferConsumer, partialRecordLength));\n+        return false;\n+    }\n+\n+    private boolean processPriorityBuffer(BufferConsumer bufferConsumer, int partialRecordLength) {\n+        buffers.addPriorityElement(\n+                new BufferConsumerWithPartialRecordLength(bufferConsumer, partialRecordLength));\n+        final int numPriorityElements = buffers.getNumPriorityElements();\n+\n+        CheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+        if (barrier != null) {\n+            checkState(\n+                    barrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+                    \"Only unaligned checkpoints should be priority events\");\n+            final Iterator<BufferConsumerWithPartialRecordLength> iterator = buffers.iterator();\n+            Iterators.advance(iterator, numPriorityElements);\n+            List<Buffer> inflightBuffers = new ArrayList<>();\n+            while (iterator.hasNext()) {\n+                BufferConsumer buffer = iterator.next().getBufferConsumer();\n+\n+                if (buffer.isBuffer()) {\n+                    try (BufferConsumer bc = buffer.copy()) {\n+                        inflightBuffers.add(bc.build());\n+                    }\n+                }\n+            }\n+            if (!inflightBuffers.isEmpty()) {\n+                channelStateWriter.addOutputData(\n+                        barrier.getId(),\n+                        subpartitionInfo,\n+                        ChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+                        inflightBuffers.toArray(new Buffer[0]));\n+            }\n+        }\n+        return numPriorityElements == 1\n+                && !isBlocked; // if subpartition is blocked then downstream doesn't expect any\n+        // notifications\n+    }\n+\n+    @Nullable\n+    private CheckpointBarrier parseCheckpointBarrier(BufferConsumer bufferConsumer) {\n+        CheckpointBarrier barrier;\n+        try (BufferConsumer bc = bufferConsumer.copy()) {\n+            Buffer buffer = bc.build();\n+            try {\n+                final AbstractEvent event =\n+                        EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n+                barrier = event instanceof CheckpointBarrier ? (CheckpointBarrier) event : null;\n+            } catch (IOException e) {\n+                throw new IllegalStateException(\n+                        \"Should always be able to deserialize in-memory event\", e);\n+            } finally {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+        return barrier;\n+    }\n+\n+    @Override\n+    public void release() {\n+        // view reference accessible outside the lock, but assigned inside the locked scope\n+        final PipelinedSubpartitionView view;\n+\n+        synchronized (buffers) {\n+            if (isReleased) {\n+                return;\n+            }\n+\n+            // Release all available buffers\n+            for (BufferConsumerWithPartialRecordLength buffer : buffers) {\n+                buffer.getBufferConsumer().close();\n+            }\n+            buffers.clear();\n+\n+            view = readView;\n+            readView = null;\n+\n+            // Make sure that no further buffers are added to the subpartition\n+            isReleased = true;\n+        }\n+\n+        LOG.debug(\"{}: Released {}.\", parent.getOwningTaskName(), this);\n+\n+        if (view != null) {\n+            view.releaseAllResources();\n+        }\n+    }\n+\n+    @Nullable\n+    BufferAndBacklog pollBuffer() {\n+        synchronized (buffers) {\n+            if (isBlocked) {\n+                return null;\n+            }\n+\n+            Buffer buffer = null;\n+\n+            if (buffers.isEmpty()) {\n+                flushRequested = false;\n+            } else {\n+                BufferConsumerWithPartialRecordLength bufferConsumerWithPartialRecordLength =\n+                        buffers.peek();\n+                BufferConsumer bufferConsumer =\n+                        bufferConsumerWithPartialRecordLength.getBufferConsumer();\n+\n+                buffer = buildSliceBuffer(bufferConsumerWithPartialRecordLength);\n+\n+                checkState(\n+                        bufferConsumer.isFinished() || buffers.size() == 1,\n+                        \"When there are multiple buffers, an unfinished bufferConsumer can not be at the head of the buffers queue.\");\n+\n+                if (buffers.size() == 1) {\n+                    // turn off flushRequested flag if we drained all of the available data\n+                    flushRequested = false;\n+                }\n+\n+                if (bufferConsumer.isFinished()) {\n+                    requireNonNull(buffers.poll()).getBufferConsumer().close();\n+                    decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer());\n+                }\n+\n+                if (buffer.readableBytes() == 0 && !bufferConsumer.isFinished()) {\n+                    buffer.recycleBuffer();\n+                    buffer = null;\n+                }\n+\n+                // if the buffer is empty and the buffer builder is finished, we just return the\n+                // empty buffer so that the downstream task can release the allocated credit for\n+                // this empty buffer, this happens in two main scenarios currently:\n+                // 1. all data of a buffer builder has been read and after that the buffer builder\n+                // is finished\n+                // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n+            }\n+\n+            if (buffer == null) {\n+                return null;\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                isBlocked = true;\n+            }\n+\n+            updateStatistics(buffer);\n+            // Do not report last remaining buffer on buffers as available to read (assuming it's\n+            // unfinished).\n+            // It will be reported for reading either on flush or when the number of buffers in the\n+            // queue\n+            // will be 2 or more.\n+            NetworkActionsLogger.traceOutput(\n+                    \"PipelinedSubpartition#pollBuffer\",\n+                    buffer,\n+                    parent.getOwningTaskName(),\n+                    subpartitionInfo);\n+            return new BufferAndBacklog(\n+                    buffer,\n+                    getBuffersInBacklog(),\n+                    isDataAvailableUnsafe() ? getNextBufferTypeUnsafe() : Buffer.DataType.NONE,\n+                    sequenceNumber++);\n+        }\n+    }\n+\n+    void resumeConsumption() {\n+        synchronized (buffers) {\n+            checkState(isBlocked, \"Should be blocked by checkpoint.\");\n+\n+            isBlocked = false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased;\n+    }\n+\n+    @Override\n+    public PipelinedSubpartitionView createReadView(\n+            BufferAvailabilityListener availabilityListener) {\n+        synchronized (buffers) {\n+            checkState(!isReleased);\n+            checkState(\n+                    readView == null,\n+                    \"Subpartition %s of is being (or already has been) consumed, \"\n+                            + \"but pipelined subpartitions can only be consumed once.\",\n+                    getSubPartitionIndex(),\n+                    parent.getPartitionId());\n+\n+            LOG.debug(\n+                    \"{}: Creating read view for subpartition {} of partition {}.\",\n+                    parent.getOwningTaskName(),\n+                    getSubPartitionIndex(),\n+                    parent.getPartitionId());\n+\n+            readView = new PipelinedSubpartitionView(this, availabilityListener);\n+        }\n+\n+        return readView;\n+    }\n+\n+    public boolean isAvailable(int numCreditsAvailable) {\n+        synchronized (buffers) {\n+            if (numCreditsAvailable > 0) {\n+                return isDataAvailableUnsafe();\n+            }\n+\n+            final Buffer.DataType dataType = getNextBufferTypeUnsafe();\n+            return dataType.isEvent();\n+        }\n+    }\n+\n+    @GuardedBy(\"buffers\")\n+    private boolean isDataAvailableUnsafe() {\n+        assert Thread.holdsLock(buffers);\n+\n+        return !isBlocked && (flushRequested || getNumberOfFinishedBuffers() > 0);\n+    }\n+\n+    private Buffer.DataType getNextBufferTypeUnsafe() {\n+        assert Thread.holdsLock(buffers);\n+\n+        final BufferConsumerWithPartialRecordLength first = buffers.peek();\n+        return first != null ? first.getBufferConsumer().getDataType() : Buffer.DataType.NONE;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+\n+    int getCurrentNumberOfBuffers() {\n+        return buffers.size();\n+    }\n+\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public String toString() {\n+        final long numBuffers;\n+        final long numBytes;\n+        final boolean finished;\n+        final boolean hasReadView;\n+\n+        synchronized (buffers) {\n+            numBuffers = getTotalNumberOfBuffers();\n+            numBytes = getTotalNumberOfBytes();\n+            finished = isFinished;\n+            hasReadView = readView != null;\n+        }\n+\n+        return String.format(\n+                \"%s#%d [number of buffers: %d (%d bytes), number of buffers in backlog: %d, finished? %s, read view? %s]\",\n+                this.getClass().getSimpleName(),\n+                getSubPartitionIndex(),\n+                numBuffers,\n+                numBytes,\n+                getBuffersInBacklog(),\n+                finished,\n+                hasReadView);\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        // since we do not synchronize, the size may actually be lower than 0!\n+        return Math.max(buffers.size(), 0);\n+    }\n+\n+    @Override\n+    public void flush() {\n+        final boolean notifyDataAvailable;\n+        synchronized (buffers) {\n+            if (buffers.isEmpty() || flushRequested) {\n+                return;\n+            }\n+            // if there is more then 1 buffer, we already notified the reader\n+            // (at the latest when adding the second buffer)\n+            notifyDataAvailable =\n+                    !isBlocked\n+                            && buffers.size() == 1\n+                            && buffers.peek().getBufferConsumer().isDataAvailable();\n+            flushRequested = buffers.size() > 1 || notifyDataAvailable;\n+        }\n+        if (notifyDataAvailable) {\n+            notifyDataAvailable();\n+        }\n+    }\n+\n+    @Override\n+    protected long getTotalNumberOfBuffers() {\n+        return totalNumberOfBuffers;\n+    }\n+\n+    @Override\n+    protected long getTotalNumberOfBytes() {\n+        return totalNumberOfBytes;\n+    }\n+\n+    Throwable getFailureCause() {\n+        return parent.getFailureCause();\n+    }\n+\n+    private void updateStatistics(BufferConsumer buffer) {\n+        totalNumberOfBuffers++;\n+    }\n+\n+    private void updateStatistics(Buffer buffer) {\n+        totalNumberOfBytes += buffer.getSize();\n+    }\n+\n+    @GuardedBy(\"buffers\")\n+    private void decreaseBuffersInBacklogUnsafe(boolean isBuffer) {\n+        assert Thread.holdsLock(buffers);\n+        if (isBuffer) {\n+            buffersInBacklog--;\n+        }\n+    }\n+\n+    /**\n+     * Increases the number of non-event buffers by one after adding a non-event buffer into this\n+     * subpartition.\n+     */\n+    @GuardedBy(\"buffers\")\n+    private void increaseBuffersInBacklog(BufferConsumer buffer) {\n+        assert Thread.holdsLock(buffers);\n+\n+        if (buffer != null && buffer.isBuffer()) {\n+            buffersInBacklog++;\n+        }\n+    }\n+\n+    /** Gets the number of non-event buffers in this subpartition. */\n+    public int getBuffersInBacklog() {\n+        synchronized (buffers) {\n+            if (isBlocked || buffers.isEmpty()) {\n+                return 0;\n+            }\n+\n+            if (flushRequested\n+                    || isFinished\n+                    || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+                return buffersInBacklog;\n+            } else {\n+                return Math.max(buffersInBacklog - 1, 0);\n+            }\n+        }\n+    }\n+\n+    @GuardedBy(\"buffers\")\n+    private boolean shouldNotifyDataAvailable() {\n+        // Notify only when we added first finished buffer.\n+        return readView != null\n+                && !flushRequested\n+                && !isBlocked\n+                && getNumberOfFinishedBuffers() == 1;\n+    }\n+\n+    private void notifyDataAvailable() {\n+        final PipelinedSubpartitionView readView = this.readView;\n+        if (readView != null) {\n+            readView.notifyDataAvailable();\n+        }\n+    }\n+\n+    private void notifyPriorityEvent(int prioritySequenceNumber) {\n+        final PipelinedSubpartitionView readView = this.readView;\n+        if (readView != null) {\n+            readView.notifyPriorityEvent(prioritySequenceNumber);\n+        }\n+    }\n+\n+    private int getNumberOfFinishedBuffers() {\n+        assert Thread.holdsLock(buffers);\n+\n+        // NOTE: isFinished() is not guaranteed to provide the most up-to-date state here\n+        // worst-case: a single finished buffer sits around until the next flush() call\n+        // (but we do not offer stronger guarantees anyway)\n+        final int numBuffers = buffers.size();\n+        if (numBuffers == 1 && buffers.peekLast().getBufferConsumer().isFinished()) {\n+            return 1;\n+        }\n+\n+        // We assume that only last buffer is not finished.\n+        return Math.max(0, numBuffers - 1);\n+    }\n+\n+    @Override\n+    public BufferBuilder requestBufferBuilderBlocking() throws InterruptedException {\n+        return parent.getBufferPool().requestBufferBuilderBlocking();\n+    }\n+\n+    Buffer buildSliceBuffer(BufferConsumerWithPartialRecordLength buffer) {\n+        return buffer.build();\n+    }\n+\n+    /** for testing only. */\n+    @VisibleForTesting\n+    BufferConsumerWithPartialRecordLength getNextBuffer() {\n+        return buffers.poll();\n+    }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 840cfb80b5a..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -34,482 +40,574 @@ import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n import java.io.IOException;\n-import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n \n+import static java.util.Objects.requireNonNull;\n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n  * A pipelined in-memory only subpartition, which can be consumed once.\n  *\n- * <p>Whenever {@link ResultSubpartition#add(BufferConsumer, boolean)} adds a finished {@link BufferConsumer} or a second\n- * {@link BufferConsumer} (in which case we will assume the first one finished), we will\n- * {@link PipelinedSubpartitionView#notifyDataAvailable() notify} a read view created via\n- * {@link ResultSubpartition#createReadView(BufferAvailabilityListener)} of new data availability. Except by calling\n- * {@link #flush()} explicitly, we always only notify when the first finished buffer turns up and\n- * then, the reader has to drain the buffers via {@link #pollBuffer()} until its return value shows\n- * no more buffers being available. This results in a buffer queue which is either empty or has an\n- * unfinished {@link BufferConsumer} left from which the notifications will eventually start again.\n+ * <p>Whenever {@link ResultSubpartition#add(BufferConsumer)} adds a finished {@link BufferConsumer}\n+ * or a second {@link BufferConsumer} (in which case we will assume the first one finished), we will\n+ * {@link PipelinedSubpartitionView#notifyDataAvailable() notify} a read view created via {@link\n+ * ResultSubpartition#createReadView(BufferAvailabilityListener)} of new data availability. Except\n+ * by calling {@link #flush()} explicitly, we always only notify when the first finished buffer\n+ * turns up and then, the reader has to drain the buffers via {@link #pollBuffer()} until its return\n+ * value shows no more buffers being available. This results in a buffer queue which is either empty\n+ * or has an unfinished {@link BufferConsumer} left from which the notifications will eventually\n+ * start again.\n  *\n- * <p>Explicit calls to {@link #flush()} will force this\n- * {@link PipelinedSubpartitionView#notifyDataAvailable() notification} for any\n- * {@link BufferConsumer} present in the queue.\n+ * <p>Explicit calls to {@link #flush()} will force this {@link\n+ * PipelinedSubpartitionView#notifyDataAvailable() notification} for any {@link BufferConsumer}\n+ * present in the queue.\n  */\n-public class PipelinedSubpartition extends ResultSubpartition {\n-\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(PipelinedSubpartition.class);\n-\n-\t// ------------------------------------------------------------------------\n-\n-\t/** All buffers of this subpartition. Access to the buffers is synchronized on this object. */\n-\tprivate final ArrayDeque<BufferConsumer> buffers = new ArrayDeque<>();\n-\n-\t/** The number of non-event buffers currently in this subpartition. */\n-\t@GuardedBy(\"buffers\")\n-\tprivate int buffersInBacklog;\n-\n-\t/** The number of non-event buffers to be announced to the downstream. */\n-\t@GuardedBy(\"buffers\")\n-\tprivate int unannouncedBacklog;\n-\n-\t/** The read view to consume this subpartition. */\n-\tprivate PipelinedSubpartitionView readView;\n-\n-\t/** Flag indicating whether the subpartition has been finished. */\n-\tprivate boolean isFinished;\n-\n-\t@GuardedBy(\"buffers\")\n-\tprivate boolean flushRequested;\n-\n-\t/** Flag indicating whether the subpartition has been released. */\n-\tprivate volatile boolean isReleased;\n-\n-\t/** The total number of buffers (both data and event buffers). */\n-\tprivate long totalNumberOfBuffers;\n-\n-\t/** The total number of bytes (both data and event buffers). */\n-\tprivate long totalNumberOfBytes;\n-\n-\t/** The collection of buffers which are spanned over by checkpoint barrier and needs to be persisted for snapshot. */\n-\tprivate final List<Buffer> inflightBufferSnapshot = new ArrayList<>();\n-\n-\t/** Whether this subpartition is blocked by exactly once checkpoint and is waiting for resumption. */\n-\t@GuardedBy(\"buffers\")\n-\tprivate boolean isBlockedByCheckpoint = false;\n-\n-\t// ------------------------------------------------------------------------\n-\n-\tPipelinedSubpartition(int index, ResultPartition parent) {\n-\t\tsuper(index, parent);\n-\t}\n-\n-\t@Override\n-\tpublic void initializeState(ChannelStateReader stateReader) throws IOException, InterruptedException {\n-\t\tfor (ReadResult readResult = ReadResult.HAS_MORE_DATA; readResult == ReadResult.HAS_MORE_DATA;) {\n-\t\t\tBufferBuilder bufferBuilder = parent.getBufferPool().requestBufferBuilderBlocking();\n-\t\t\tBufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer();\n-\t\t\treadResult = stateReader.readOutputData(subpartitionInfo, bufferBuilder);\n-\n-\t\t\t// check whether there are some states data filled in this time\n-\t\t\tif (bufferConsumer.isDataAvailable()) {\n-\t\t\t\tadd(bufferConsumer, false, false);\n-\t\t\t\tbufferBuilder.finish();\n-\t\t\t} else {\n-\t\t\t\tbufferConsumer.close();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic boolean add(BufferConsumer bufferConsumer, boolean isPriorityEvent) throws IOException {\n-\t\tif (isPriorityEvent) {\n-\t\t\tif (readView != null && readView.notifyPriorityEvent(bufferConsumer)) {\n-\t\t\t\tbufferConsumer.close();\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\treturn add(bufferConsumer, false, true);\n-\t\t}\n-\t\treturn add(bufferConsumer, false, false);\n-\t}\n-\n-\t@Override\n-\tpublic void finish() throws IOException {\n-\t\tadd(EventSerializer.toBufferConsumer(EndOfPartitionEvent.INSTANCE), true, false);\n-\t\tLOG.debug(\"{}: Finished {}.\", parent.getOwningTaskName(), this);\n-\t}\n-\n-\tprivate boolean add(BufferConsumer bufferConsumer, boolean finish, boolean insertAsHead) {\n-\t\tcheckNotNull(bufferConsumer);\n-\n-\t\tfinal boolean notifyDataAvailable;\n-\t\tsynchronized (buffers) {\n-\t\t\tif (isFinished || isReleased) {\n-\t\t\t\tbufferConsumer.close();\n-\t\t\t\treturn false;\n-\t\t\t}\n-\n-\t\t\t// Add the bufferConsumer and update the stats\n-\t\t\thandleAddingBarrier(bufferConsumer, insertAsHead);\n-\t\t\tupdateStatistics(bufferConsumer);\n-\t\t\tincreaseBuffersInBacklogAndUnannouncedBacklog(bufferConsumer);\n-\t\t\tnotifyDataAvailable = insertAsHead || finish || shouldNotifyDataAvailable();\n-\t\t\tincreaseUnannouncedBacklogIfNeeded(notifyDataAvailable);\n-\n-\t\t\tisFinished |= finish;\n-\t\t}\n-\n-\t\tif (notifyDataAvailable) {\n-\t\t\tnotifyDataAvailable();\n-\t\t}\n-\n-\t\treturn true;\n-\t}\n-\n-\tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n-\t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n-\n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tbuffers.addFirst(bufferConsumer);\n-\t\t} else {\n-\t\t\tbuffers.add(bufferConsumer);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic List<Buffer> requestInflightBufferSnapshot() {\n-\t\tList<Buffer> snapshot = new ArrayList<>(inflightBufferSnapshot);\n-\t\tinflightBufferSnapshot.clear();\n-\t\treturn snapshot;\n-\t}\n-\n-\t@Override\n-\tpublic void release() {\n-\t\t// view reference accessible outside the lock, but assigned inside the locked scope\n-\t\tfinal PipelinedSubpartitionView view;\n-\n-\t\tsynchronized (buffers) {\n-\t\t\tif (isReleased) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// Release all available buffers\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\tbuffer.close();\n-\t\t\t}\n-\t\t\tbuffers.clear();\n-\n-\t\t\tview = readView;\n-\t\t\treadView = null;\n-\n-\t\t\t// Make sure that no further buffers are added to the subpartition\n-\t\t\tisReleased = true;\n-\t\t}\n-\n-\t\tLOG.debug(\"{}: Released {}.\", parent.getOwningTaskName(), this);\n-\n-\t\tif (view != null) {\n-\t\t\tview.releaseAllResources();\n-\t\t}\n-\t}\n-\n-\t@Nullable\n-\tBufferAndBacklog pollBuffer() {\n-\t\tsynchronized (buffers) {\n-\t\t\tif (isBlockedByCheckpoint) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n-\t\t\tBuffer buffer = null;\n-\n-\t\t\tif (buffers.isEmpty()) {\n-\t\t\t\tflushRequested = false;\n-\t\t\t}\n-\n-\t\t\twhile (!buffers.isEmpty()) {\n-\t\t\t\tBufferConsumer bufferConsumer = buffers.peek();\n-\n-\t\t\t\tbuffer = bufferConsumer.build();\n-\n-\t\t\t\tcheckState(bufferConsumer.isFinished() || buffers.size() == 1,\n-\t\t\t\t\t\"When there are multiple buffers, an unfinished bufferConsumer can not be at the head of the buffers queue.\");\n-\n-\t\t\t\tif (buffers.size() == 1) {\n-\t\t\t\t\t// turn off flushRequested flag if we drained all of the available data\n-\t\t\t\t\tflushRequested = false;\n-\t\t\t\t}\n-\n-\t\t\t\tif (bufferConsumer.isFinished()) {\n-\t\t\t\t\tbuffers.pop().close();\n-\t\t\t\t\tdecreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer());\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer.readableBytes() > 0) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t\tbuffer = null;\n-\t\t\t\tif (!bufferConsumer.isFinished()) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (buffer == null) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n-\t\t\tif (Buffer.DataType.isAlignedExactlyOnceCheckpointBarrier(buffer)) {\n-\t\t\t\tisBlockedByCheckpoint = true;\n-\t\t\t}\n-\n-\t\t\tupdateStatistics(buffer);\n-\t\t\t// Do not report last remaining buffer on buffers as available to read (assuming it's unfinished).\n-\t\t\t// It will be reported for reading either on flush or when the number of buffers in the queue\n-\t\t\t// will be 2 or more.\n-\t\t\treturn new BufferAndBacklog(\n-\t\t\t\tbuffer,\n-\t\t\t\tisDataAvailableUnsafe(),\n-\t\t\t\tgetBuffersInBacklog(),\n-\t\t\t\tgetAndResetUnannouncedBacklogUnsafe(),\n-\t\t\t\tisEventAvailableUnsafe());\n-\t\t}\n-\t}\n-\n-\tvoid resumeConsumption() {\n-\t\tsynchronized (buffers) {\n-\t\t\tcheckState(isBlockedByCheckpoint, \"Should be blocked by checkpoint.\");\n-\n-\t\t\tisBlockedByCheckpoint = false;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int releaseMemory() {\n-\t\t// The pipelined subpartition does not react to memory release requests.\n-\t\t// The buffers will be recycled by the consuming task.\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased;\n-\t}\n-\n-\t@Override\n-\tpublic PipelinedSubpartitionView createReadView(BufferAvailabilityListener availabilityListener) throws IOException {\n-\t\tfinal boolean notifyDataAvailable;\n-\t\tsynchronized (buffers) {\n-\t\t\tcheckState(!isReleased);\n-\t\t\tcheckState(readView == null,\n-\t\t\t\t\"Subpartition %s of is being (or already has been) consumed, \" +\n-\t\t\t\t\"but pipelined subpartitions can only be consumed once.\",\n-\t\t\t\tgetSubPartitionIndex(),\n-\t\t\t\tparent.getPartitionId());\n-\n-\t\t\tLOG.debug(\"{}: Creating read view for subpartition {} of partition {}.\",\n-\t\t\t\tparent.getOwningTaskName(), getSubPartitionIndex(), parent.getPartitionId());\n-\n-\t\t\treadView = new PipelinedSubpartitionView(this, availabilityListener);\n-\t\t\tnotifyDataAvailable = !buffers.isEmpty();\n-\t\t}\n-\t\tif (notifyDataAvailable) {\n-\t\t\tnotifyDataAvailable();\n-\t\t}\n-\n-\t\treturn readView;\n-\t}\n-\n-\tpublic boolean isAvailable(int numCreditsAvailable) {\n-\t\tsynchronized (buffers) {\n-\t\t\tif (numCreditsAvailable > 0) {\n-\t\t\t\treturn isDataAvailableUnsafe();\n-\t\t\t}\n-\n-\t\t\treturn isEventAvailableUnsafe();\n-\t\t}\n-\t}\n-\n-\tprivate boolean isDataAvailableUnsafe() {\n-\t\tassert Thread.holdsLock(buffers);\n-\n-\t\treturn !isBlockedByCheckpoint && (flushRequested || getNumberOfFinishedBuffers() > 0);\n-\t}\n-\n-\tprivate boolean isEventAvailableUnsafe() {\n-\t\tassert Thread.holdsLock(buffers);\n-\n-\t\treturn !isBlockedByCheckpoint && !buffers.isEmpty() && !buffers.peekFirst().isBuffer();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\n-\tint getCurrentNumberOfBuffers() {\n-\t\treturn buffers.size();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\tfinal long numBuffers;\n-\t\tfinal long numBytes;\n-\t\tfinal boolean finished;\n-\t\tfinal boolean hasReadView;\n-\n-\t\tsynchronized (buffers) {\n-\t\t\tnumBuffers = getTotalNumberOfBuffers();\n-\t\t\tnumBytes = getTotalNumberOfBytes();\n-\t\t\tfinished = isFinished;\n-\t\t\thasReadView = readView != null;\n-\t\t}\n-\n-\t\treturn String.format(\n-\t\t\t\"PipelinedSubpartition#%d [number of buffers: %d (%d bytes), \" +\n-\t\t\t\t\"number of buffers in backlog: %d, unannounced backlog: %d, finished? %s, read view? %s]\",\n-\t\t\tgetSubPartitionIndex(), numBuffers, numBytes, getBuffersInBacklog(), unannouncedBacklog, finished, hasReadView);\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\t// since we do not synchronize, the size may actually be lower than 0!\n-\t\treturn Math.max(buffers.size(), 0);\n-\t}\n-\n-\t@Override\n-\tpublic void flush() {\n-\t\tfinal boolean notifyDataAvailable;\n-\t\tsynchronized (buffers) {\n-\t\t\tif (buffers.isEmpty() || flushRequested) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\t// if there is more then 1 buffer, we already notified the reader\n-\t\t\t// (at the latest when adding the second buffer)\n-\t\t\tnotifyDataAvailable = !isBlockedByCheckpoint && buffers.size() == 1 && buffers.peek().isDataAvailable();\n-\t\t\tflushRequested = buffers.size() > 1 || notifyDataAvailable;\n-\t\t\tincreaseUnannouncedBacklogIfNeeded(notifyDataAvailable);\n-\t\t}\n-\t\tif (notifyDataAvailable) {\n-\t\t\tnotifyDataAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected long getTotalNumberOfBuffers() {\n-\t\treturn totalNumberOfBuffers;\n-\t}\n-\n-\t@Override\n-\tprotected long getTotalNumberOfBytes() {\n-\t\treturn totalNumberOfBytes;\n-\t}\n-\n-\tThrowable getFailureCause() {\n-\t\treturn parent.getFailureCause();\n-\t}\n-\n-\tprivate void updateStatistics(BufferConsumer buffer) {\n-\t\ttotalNumberOfBuffers++;\n-\t}\n-\n-\tprivate void updateStatistics(Buffer buffer) {\n-\t\ttotalNumberOfBytes += buffer.getSize();\n-\t}\n-\n-\t@GuardedBy(\"buffers\")\n-\tprivate void decreaseBuffersInBacklogUnsafe(boolean isBuffer) {\n-\t\tassert Thread.holdsLock(buffers);\n-\t\tif (isBuffer) {\n-\t\t\tbuffersInBacklog--;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Increases the number of non-event buffers and unannounced backlog by one after\n-\t * adding a non-event buffer into this subpartition.\n-\t */\n-\t@GuardedBy(\"buffers\")\n-\tprivate void increaseBuffersInBacklogAndUnannouncedBacklog(BufferConsumer buffer) {\n-\t\tassert Thread.holdsLock(buffers);\n-\n-\t\tif (buffer != null && buffer.isBuffer()) {\n-\t\t\tbuffersInBacklog++;\n-\t\t\tunannouncedBacklog++;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Increases the unannounced backlog by one if we have a new sliced buffer to be read.\n-\t */\n-\t@GuardedBy(\"buffers\")\n-\tprivate void increaseUnannouncedBacklogIfNeeded(boolean notifyDataAvailable) {\n-\t\tassert Thread.holdsLock(buffers);\n-\n-\t\tBufferConsumer buffer = buffers.peekFirst();\n-\t\tif (notifyDataAvailable && !buffers.isEmpty() && buffer.isSliced() && buffer.isDataAvailable()) {\n-\t\t\t++unannouncedBacklog;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Gets the number of non-event buffers in this subpartition.\n-\t *\n-\t * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-\t * scenarios since it does not make any concurrency guarantees.\n-\t */\n-\t@SuppressWarnings(\"FieldAccessNotGuarded\")\n-\t@VisibleForTesting\n-\tpublic int getBuffersInBacklog() {\n-\t\tif (flushRequested || isFinished) {\n-\t\t\treturn buffersInBacklog;\n-\t\t} else {\n-\t\t\treturn Math.max(buffersInBacklog - 1, 0);\n-\t\t}\n-\t}\n-\n-\tint getAndResetUnannouncedBacklog() {\n-\t\tsynchronized (buffers) {\n-\t\t\treturn getAndResetUnannouncedBacklogUnsafe();\n-\t\t}\n-\t}\n-\n-\tprivate int getAndResetUnannouncedBacklogUnsafe() {\n-\t\tint numBacklog = unannouncedBacklog;\n-\t\tunannouncedBacklog = 0;\n-\t\treturn numBacklog;\n-\t}\n-\n-\tprivate boolean shouldNotifyDataAvailable() {\n-\t\t// Notify only when we added first finished buffer.\n-\t\treturn readView != null && !flushRequested && !isBlockedByCheckpoint && getNumberOfFinishedBuffers() == 1;\n-\t}\n-\n-\tprivate void notifyDataAvailable() {\n-\t\tif (readView != null) {\n-\t\t\treadView.notifyDataAvailable();\n-\t\t}\n-\t}\n-\n-\tprivate int getNumberOfFinishedBuffers() {\n-\t\tassert Thread.holdsLock(buffers);\n-\n-\t\t// NOTE: isFinished() is not guaranteed to provide the most up-to-date state here\n-\t\t// worst-case: a single finished buffer sits around until the next flush() call\n-\t\t// (but we do not offer stronger guarantees anyway)\n-\t\tif (buffers.size() == 1 && buffers.peekLast().isFinished()) {\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\t// We assume that only last buffer is not finished.\n-\t\treturn Math.max(0, buffers.size() - 1);\n-\t}\n+public class PipelinedSubpartition extends ResultSubpartition\n+        implements CheckpointedResultSubpartition, ChannelStateHolder {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PipelinedSubpartition.class);\n+\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Number of exclusive credits per input channel at the downstream tasks configured by {@link\n+     * org.apache.flink.configuration.NettyShuffleEnvironmentOptions#NETWORK_BUFFERS_PER_CHANNEL}.\n+     */\n+    private final int receiverExclusiveBuffersPerChannel;\n+\n+    /** All buffers of this subpartition. Access to the buffers is synchronized on this object. */\n+    final PrioritizedDeque<BufferConsumerWithPartialRecordLength> buffers =\n+            new PrioritizedDeque<>();\n+\n+    /** The number of non-event buffers currently in this subpartition. */\n+    @GuardedBy(\"buffers\")\n+    private int buffersInBacklog;\n+\n+    /** The read view to consume this subpartition. */\n+    PipelinedSubpartitionView readView;\n+\n+    /** Flag indicating whether the subpartition has been finished. */\n+    private boolean isFinished;\n+\n+    @GuardedBy(\"buffers\")\n+    private boolean flushRequested;\n+\n+    /** Flag indicating whether the subpartition has been released. */\n+    volatile boolean isReleased;\n+\n+    /** The total number of buffers (both data and event buffers). */\n+    private long totalNumberOfBuffers;\n+\n+    /** The total number of bytes (both data and event buffers). */\n+    private long totalNumberOfBytes;\n+\n+    /** Writes in-flight data. */\n+    private ChannelStateWriter channelStateWriter;\n+\n+    /**\n+     * Whether this subpartition is blocked (e.g. by exactly once checkpoint) and is waiting for\n+     * resumption.\n+     */\n+    @GuardedBy(\"buffers\")\n+    boolean isBlocked = false;\n+\n+    int sequenceNumber = 0;\n+\n+    // ------------------------------------------------------------------------\n+\n+    PipelinedSubpartition(\n+            int index, int receiverExclusiveBuffersPerChannel, ResultPartition parent) {\n+        super(index, parent);\n+\n+        checkArgument(\n+                receiverExclusiveBuffersPerChannel >= 0,\n+                \"Buffers per channel must be non-negative.\");\n+        this.receiverExclusiveBuffersPerChannel = receiverExclusiveBuffersPerChannel;\n+    }\n+\n+    @Override\n+    public void setChannelStateWriter(ChannelStateWriter channelStateWriter) {\n+        checkState(this.channelStateWriter == null, \"Already initialized\");\n+        this.channelStateWriter = checkNotNull(channelStateWriter);\n+    }\n+\n+    @Override\n+    public boolean add(BufferConsumer bufferConsumer, int partialRecordLength) {\n+        return add(bufferConsumer, partialRecordLength, false);\n+    }\n+\n+    @Override\n+    public void addRecovered(BufferConsumer bufferConsumer) throws IOException {\n+        NetworkActionsLogger.traceRecover(\n+                \"PipelinedSubpartition#addRecovered\",\n+                bufferConsumer,\n+                parent.getOwningTaskName(),\n+                subpartitionInfo);\n+        if (!add(bufferConsumer, Integer.MIN_VALUE)) {\n+            throw new IOException(\"Buffer consumer couldn't be added to ResultSubpartition\");\n+        }\n+    }\n+\n+    @Override\n+    public void finishReadRecoveredState(boolean notifyAndBlockOnCompletion) throws IOException {\n+        if (notifyAndBlockOnCompletion) {\n+            add(EventSerializer.toBufferConsumer(EndOfChannelStateEvent.INSTANCE, false), 0, false);\n+        }\n+    }\n+\n+    @Override\n+    public void finish() throws IOException {\n+        add(EventSerializer.toBufferConsumer(EndOfPartitionEvent.INSTANCE, false), 0, true);\n+        LOG.debug(\"{}: Finished {}.\", parent.getOwningTaskName(), this);\n+    }\n+\n+    private boolean add(BufferConsumer bufferConsumer, int partialRecordLength, boolean finish) {\n+        checkNotNull(bufferConsumer);\n+\n+        final boolean notifyDataAvailable;\n+        int prioritySequenceNumber = -1;\n+        synchronized (buffers) {\n+            if (isFinished || isReleased) {\n+                bufferConsumer.close();\n+                return false;\n+            }\n+\n+            // Add the bufferConsumer and update the stats\n+            if (addBuffer(bufferConsumer, partialRecordLength)) {\n+                prioritySequenceNumber = sequenceNumber;\n+            }\n+            updateStatistics(bufferConsumer);\n+            increaseBuffersInBacklog(bufferConsumer);\n+            notifyDataAvailable = finish || shouldNotifyDataAvailable();\n+\n+            isFinished |= finish;\n+        }\n+\n+        if (prioritySequenceNumber != -1) {\n+            notifyPriorityEvent(prioritySequenceNumber);\n+        }\n+        if (notifyDataAvailable) {\n+            notifyDataAvailable();\n+        }\n+\n+        return true;\n+    }\n+\n+    private boolean addBuffer(BufferConsumer bufferConsumer, int partialRecordLength) {\n+        assert Thread.holdsLock(buffers);\n+        if (bufferConsumer.getDataType().hasPriority()) {\n+            return processPriorityBuffer(bufferConsumer, partialRecordLength);\n+        }\n+        buffers.add(new BufferConsumerWithPartialRecordLength(bufferConsumer, partialRecordLength));\n+        return false;\n+    }\n+\n+    private boolean processPriorityBuffer(BufferConsumer bufferConsumer, int partialRecordLength) {\n+        buffers.addPriorityElement(\n+                new BufferConsumerWithPartialRecordLength(bufferConsumer, partialRecordLength));\n+        final int numPriorityElements = buffers.getNumPriorityElements();\n+\n+        CheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+        if (barrier != null) {\n+            checkState(\n+                    barrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+                    \"Only unaligned checkpoints should be priority events\");\n+            final Iterator<BufferConsumerWithPartialRecordLength> iterator = buffers.iterator();\n+            Iterators.advance(iterator, numPriorityElements);\n+            List<Buffer> inflightBuffers = new ArrayList<>();\n+            while (iterator.hasNext()) {\n+                BufferConsumer buffer = iterator.next().getBufferConsumer();\n+\n+                if (buffer.isBuffer()) {\n+                    try (BufferConsumer bc = buffer.copy()) {\n+                        inflightBuffers.add(bc.build());\n+                    }\n+                }\n+            }\n+            if (!inflightBuffers.isEmpty()) {\n+                channelStateWriter.addOutputData(\n+                        barrier.getId(),\n+                        subpartitionInfo,\n+                        ChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+                        inflightBuffers.toArray(new Buffer[0]));\n+            }\n+        }\n+        return numPriorityElements == 1\n+                && !isBlocked; // if subpartition is blocked then downstream doesn't expect any\n+        // notifications\n+    }\n+\n+    @Nullable\n+    private CheckpointBarrier parseCheckpointBarrier(BufferConsumer bufferConsumer) {\n+        CheckpointBarrier barrier;\n+        try (BufferConsumer bc = bufferConsumer.copy()) {\n+            Buffer buffer = bc.build();\n+            try {\n+                final AbstractEvent event =\n+                        EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n+                barrier = event instanceof CheckpointBarrier ? (CheckpointBarrier) event : null;\n+            } catch (IOException e) {\n+                throw new IllegalStateException(\n+                        \"Should always be able to deserialize in-memory event\", e);\n+            } finally {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+        return barrier;\n+    }\n+\n+    @Override\n+    public void release() {\n+        // view reference accessible outside the lock, but assigned inside the locked scope\n+        final PipelinedSubpartitionView view;\n+\n+        synchronized (buffers) {\n+            if (isReleased) {\n+                return;\n+            }\n+\n+            // Release all available buffers\n+            for (BufferConsumerWithPartialRecordLength buffer : buffers) {\n+                buffer.getBufferConsumer().close();\n+            }\n+            buffers.clear();\n+\n+            view = readView;\n+            readView = null;\n+\n+            // Make sure that no further buffers are added to the subpartition\n+            isReleased = true;\n+        }\n+\n+        LOG.debug(\"{}: Released {}.\", parent.getOwningTaskName(), this);\n+\n+        if (view != null) {\n+            view.releaseAllResources();\n+        }\n+    }\n+\n+    @Nullable\n+    BufferAndBacklog pollBuffer() {\n+        synchronized (buffers) {\n+            if (isBlocked) {\n+                return null;\n+            }\n+\n+            Buffer buffer = null;\n+\n+            if (buffers.isEmpty()) {\n+                flushRequested = false;\n+            }\n+\n+            while (!buffers.isEmpty()) {\n+                BufferConsumerWithPartialRecordLength bufferConsumerWithPartialRecordLength =\n+                        buffers.peek();\n+                BufferConsumer bufferConsumer =\n+                        bufferConsumerWithPartialRecordLength.getBufferConsumer();\n+\n+                buffer = buildSliceBuffer(bufferConsumerWithPartialRecordLength);\n+\n+                checkState(\n+                        bufferConsumer.isFinished() || buffers.size() == 1,\n+                        \"When there are multiple buffers, an unfinished bufferConsumer can not be at the head of the buffers queue.\");\n+\n+                if (buffers.size() == 1) {\n+                    // turn off flushRequested flag if we drained all of the available data\n+                    flushRequested = false;\n+                }\n+\n+                if (bufferConsumer.isFinished()) {\n+                    requireNonNull(buffers.poll()).getBufferConsumer().close();\n+                    decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer());\n+                }\n+\n+                // if we have an empty finished buffer and the exclusive credit is 0, we just return\n+                // the empty buffer so that the downstream task can release the allocated credit for\n+                // this empty buffer, this happens in two main scenarios currently:\n+                // 1. all data of a buffer builder has been read and after that the buffer builder\n+                // is finished\n+                // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n+                if (receiverExclusiveBuffersPerChannel == 0 && bufferConsumer.isFinished()) {\n+                    break;\n+                }\n+\n+                if (buffer.readableBytes() > 0) {\n+                    break;\n+                }\n+                buffer.recycleBuffer();\n+                buffer = null;\n+                if (!bufferConsumer.isFinished()) {\n+                    break;\n+                }\n+            }\n+\n+            if (buffer == null) {\n+                return null;\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                isBlocked = true;\n+            }\n+\n+            updateStatistics(buffer);\n+            // Do not report last remaining buffer on buffers as available to read (assuming it's\n+            // unfinished).\n+            // It will be reported for reading either on flush or when the number of buffers in the\n+            // queue\n+            // will be 2 or more.\n+            NetworkActionsLogger.traceOutput(\n+                    \"PipelinedSubpartition#pollBuffer\",\n+                    buffer,\n+                    parent.getOwningTaskName(),\n+                    subpartitionInfo);\n+            return new BufferAndBacklog(\n+                    buffer,\n+                    getBuffersInBacklogUnsafe(),\n+                    isDataAvailableUnsafe() ? getNextBufferTypeUnsafe() : Buffer.DataType.NONE,\n+                    sequenceNumber++);\n+        }\n+    }\n+\n+    void resumeConsumption() {\n+        synchronized (buffers) {\n+            checkState(isBlocked, \"Should be blocked by checkpoint.\");\n+\n+            isBlocked = false;\n+        }\n+    }\n+\n+    public void acknowledgeAllRecordsProcessed() {\n+        parent.onSubpartitionAllRecordsProcessed(subpartitionInfo.getSubPartitionIdx());\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased;\n+    }\n+\n+    @Override\n+    public PipelinedSubpartitionView createReadView(\n+            BufferAvailabilityListener availabilityListener) {\n+        synchronized (buffers) {\n+            checkState(!isReleased);\n+            checkState(\n+                    readView == null,\n+                    \"Subpartition %s of is being (or already has been) consumed, \"\n+                            + \"but pipelined subpartitions can only be consumed once.\",\n+                    getSubPartitionIndex(),\n+                    parent.getPartitionId());\n+\n+            LOG.debug(\n+                    \"{}: Creating read view for subpartition {} of partition {}.\",\n+                    parent.getOwningTaskName(),\n+                    getSubPartitionIndex(),\n+                    parent.getPartitionId());\n+\n+            readView = new PipelinedSubpartitionView(this, availabilityListener);\n+        }\n+\n+        return readView;\n+    }\n+\n+    public ResultSubpartitionView.AvailabilityWithBacklog getAvailabilityAndBacklog(\n+            int numCreditsAvailable) {\n+        synchronized (buffers) {\n+            boolean isAvailable;\n+            if (numCreditsAvailable > 0) {\n+                isAvailable = isDataAvailableUnsafe();\n+            } else {\n+                isAvailable = getNextBufferTypeUnsafe().isEvent();\n+            }\n+            return new ResultSubpartitionView.AvailabilityWithBacklog(\n+                    isAvailable, getBuffersInBacklogUnsafe());\n+        }\n+    }\n+\n+    @GuardedBy(\"buffers\")\n+    private boolean isDataAvailableUnsafe() {\n+        assert Thread.holdsLock(buffers);\n+\n+        return !isBlocked && (flushRequested || getNumberOfFinishedBuffers() > 0);\n+    }\n+\n+    private Buffer.DataType getNextBufferTypeUnsafe() {\n+        assert Thread.holdsLock(buffers);\n+\n+        final BufferConsumerWithPartialRecordLength first = buffers.peek();\n+        return first != null ? first.getBufferConsumer().getDataType() : Buffer.DataType.NONE;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+\n+    int getCurrentNumberOfBuffers() {\n+        return buffers.size();\n+    }\n+\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public String toString() {\n+        final long numBuffers;\n+        final long numBytes;\n+        final boolean finished;\n+        final boolean hasReadView;\n+\n+        synchronized (buffers) {\n+            numBuffers = getTotalNumberOfBuffers();\n+            numBytes = getTotalNumberOfBytes();\n+            finished = isFinished;\n+            hasReadView = readView != null;\n+        }\n+\n+        return String.format(\n+                \"%s#%d [number of buffers: %d (%d bytes), number of buffers in backlog: %d, finished? %s, read view? %s]\",\n+                this.getClass().getSimpleName(),\n+                getSubPartitionIndex(),\n+                numBuffers,\n+                numBytes,\n+                getBuffersInBacklogUnsafe(),\n+                finished,\n+                hasReadView);\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        // since we do not synchronize, the size may actually be lower than 0!\n+        return Math.max(buffers.size(), 0);\n+    }\n+\n+    @Override\n+    public void flush() {\n+        final boolean notifyDataAvailable;\n+        synchronized (buffers) {\n+            if (buffers.isEmpty() || flushRequested) {\n+                return;\n+            }\n+            // if there is more then 1 buffer, we already notified the reader\n+            // (at the latest when adding the second buffer)\n+            boolean isDataAvailableInUnfinishedBuffer =\n+                    buffers.size() == 1 && buffers.peek().getBufferConsumer().isDataAvailable();\n+            notifyDataAvailable = !isBlocked && isDataAvailableInUnfinishedBuffer;\n+            flushRequested = buffers.size() > 1 || isDataAvailableInUnfinishedBuffer;\n+        }\n+        if (notifyDataAvailable) {\n+            notifyDataAvailable();\n+        }\n+    }\n+\n+    @Override\n+    protected long getTotalNumberOfBuffers() {\n+        return totalNumberOfBuffers;\n+    }\n+\n+    @Override\n+    protected long getTotalNumberOfBytes() {\n+        return totalNumberOfBytes;\n+    }\n+\n+    Throwable getFailureCause() {\n+        return parent.getFailureCause();\n+    }\n+\n+    private void updateStatistics(BufferConsumer buffer) {\n+        totalNumberOfBuffers++;\n+    }\n+\n+    private void updateStatistics(Buffer buffer) {\n+        totalNumberOfBytes += buffer.getSize();\n+    }\n+\n+    @GuardedBy(\"buffers\")\n+    private void decreaseBuffersInBacklogUnsafe(boolean isBuffer) {\n+        assert Thread.holdsLock(buffers);\n+        if (isBuffer) {\n+            buffersInBacklog--;\n+        }\n+    }\n+\n+    /**\n+     * Increases the number of non-event buffers by one after adding a non-event buffer into this\n+     * subpartition.\n+     */\n+    @GuardedBy(\"buffers\")\n+    private void increaseBuffersInBacklog(BufferConsumer buffer) {\n+        assert Thread.holdsLock(buffers);\n+\n+        if (buffer != null && buffer.isBuffer()) {\n+            buffersInBacklog++;\n+        }\n+    }\n+\n+    /** Gets the number of non-event buffers in this subpartition. */\n+    @Override\n+    public int getBuffersInBacklogUnsafe() {\n+        if (isBlocked || buffers.isEmpty()) {\n+            return 0;\n+        }\n+\n+        if (flushRequested\n+                || isFinished\n+                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+            return buffersInBacklog;\n+        } else {\n+            return Math.max(buffersInBacklog - 1, 0);\n+        }\n+    }\n+\n+    @GuardedBy(\"buffers\")\n+    private boolean shouldNotifyDataAvailable() {\n+        // Notify only when we added first finished buffer.\n+        return readView != null\n+                && !flushRequested\n+                && !isBlocked\n+                && getNumberOfFinishedBuffers() == 1;\n+    }\n+\n+    private void notifyDataAvailable() {\n+        final PipelinedSubpartitionView readView = this.readView;\n+        if (readView != null) {\n+            readView.notifyDataAvailable();\n+        }\n+    }\n+\n+    private void notifyPriorityEvent(int prioritySequenceNumber) {\n+        final PipelinedSubpartitionView readView = this.readView;\n+        if (readView != null) {\n+            readView.notifyPriorityEvent(prioritySequenceNumber);\n+        }\n+    }\n+\n+    private int getNumberOfFinishedBuffers() {\n+        assert Thread.holdsLock(buffers);\n+\n+        // NOTE: isFinished() is not guaranteed to provide the most up-to-date state here\n+        // worst-case: a single finished buffer sits around until the next flush() call\n+        // (but we do not offer stronger guarantees anyway)\n+        final int numBuffers = buffers.size();\n+        if (numBuffers == 1 && buffers.peekLast().getBufferConsumer().isFinished()) {\n+            return 1;\n+        }\n+\n+        // We assume that only last buffer is not finished.\n+        return Math.max(0, numBuffers - 1);\n+    }\n+\n+    @Override\n+    public BufferBuilder requestBufferBuilderBlocking() throws InterruptedException {\n+        return parent.getBufferPool().requestBufferBuilderBlocking();\n+    }\n+\n+    Buffer buildSliceBuffer(BufferConsumerWithPartialRecordLength buffer) {\n+        return buffer.build();\n+    }\n+\n+    /** for testing only. */\n+    @VisibleForTesting\n+    BufferConsumerWithPartialRecordLength getNextBuffer() {\n+        return buffers.poll();\n+    }\n }\n", "next_change": {"commit": "dd8f4e2603309493300099396568ffc681e76e80", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 38d8cf93158..8be8a287836 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -610,4 +804,15 @@ public class PipelinedSubpartition extends ResultSubpartition\n     BufferConsumerWithPartialRecordLength getNextBuffer() {\n         return buffers.poll();\n     }\n+\n+    /** for testing only. */\n+    @VisibleForTesting\n+    CompletableFuture<List<Buffer>> getChannelStateFuture() {\n+        return channelStateFuture;\n+    }\n+\n+    @VisibleForTesting\n+    public long getChannelStateCheckpointId() {\n+        return channelStateCheckpointId;\n+    }\n }\n", "next_change": {"commit": "5c5cc9dbcc1ce9e041ea3aee9ba32ad6a3e19689", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 8be8a287836..28dca791ba4 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -806,11 +816,15 @@ public class PipelinedSubpartition extends ResultSubpartition\n     }\n \n     /** for testing only. */\n+    // suppress this warning as it is only for testing.\n+    @SuppressWarnings(\"FieldAccessNotGuarded\")\n     @VisibleForTesting\n     CompletableFuture<List<Buffer>> getChannelStateFuture() {\n         return channelStateFuture;\n     }\n \n+    // suppress this warning as it is only for testing.\n+    @SuppressWarnings(\"FieldAccessNotGuarded\")\n     @VisibleForTesting\n     public long getChannelStateCheckpointId() {\n         return channelStateCheckpointId;\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "088d16517126d7128e1f072d588b9ce0f4787ae6", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][refactor] Made a safe method for getting the number of buffers in the queue visible in the interface."}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "703662aa61a8f82d4df6de7e0518a568822f71db", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Subpartition is able to notify the desirable buffer size for input buffer consumer."}, {"oid": "60aa2ac29797df576fe14f5c888f09626351b774", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[refactor][runtime] Added postfix `unsafe` for methods ResultSubpartition#getTotalNumberOfBuffers and ResultSubpartition#getTotalNumberOfBytes"}, {"oid": "10b7afae7423d75f94f397699b09deb9fbbdaca5", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Refactor the barrier alignment timer and default priority sequence number"}, {"oid": "dd8f4e2603309493300099396568ffc681e76e80", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Timeout aligned to unaligned checkpoint barrier in the output buffers"}, {"oid": "5c5cc9dbcc1ce9e041ea3aee9ba32ad6a3e19689", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Add missing @GuardedBy annotation for SortMergeResultPartitionReadScheduler and PipelinedSubpartition."}, {"oid": "3b6816e0a6c578dbcbdcf3061ce6205ddb0f5e48", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Fix some typo and syntax mistakes."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2NDk4MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422864980", "body": "`buffersInBacklog` and `unannouncedBacklog` should be retained only one finally.", "bodyText": "buffersInBacklog and unannouncedBacklog should be retained only one finally.", "bodyHTML": "<p dir=\"auto\"><code>buffersInBacklog</code> and <code>unannouncedBacklog</code> should be retained only one finally.</p>", "author": "zhijiangW", "createdAt": "2020-05-11T08:18:44Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java", "diffHunk": "@@ -158,11 +158,18 @@ public boolean add(BufferConsumer bufferConsumer) throws IOException {\n \t\tprivate final Buffer buffer;\n \t\tprivate final boolean isDataAvailable;\n \t\tprivate final int buffersInBacklog;\n+\t\tprivate final int unannouncedBacklog;", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\nindex 95eaee362d3..8d9a66e67b3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\n", "chunk": "@@ -150,25 +144,18 @@ public abstract class ResultSubpartition {\n \t// ------------------------------------------------------------------------\n \n \t/**\n-\t * A combination of a {@link Buffer} and the backlog length indicating\n-\t * how many non-event buffers are available in the subpartition.\n+\t * A combination of a {@link Buffer} and the unannounced backlog in the subpartition to\n+\t * be announced to the consumer.\n \t */\n \tpublic static final class BufferAndBacklog {\n \n \t\tprivate final Buffer buffer;\n \t\tprivate final boolean isDataAvailable;\n-\t\tprivate final int buffersInBacklog;\n \t\tprivate final int unannouncedBacklog;\n \t\tprivate final boolean isEventAvailable;\n \n-\t\tpublic BufferAndBacklog(\n-\t\t\t\tBuffer buffer,\n-\t\t\t\tboolean isDataAvailable,\n-\t\t\t\tint buffersInBacklog,\n-\t\t\t\tint unannouncedBacklog,\n-\t\t\t\tboolean isEventAvailable) {\n+\t\tpublic BufferAndBacklog(Buffer buffer, boolean isDataAvailable, int unannouncedBacklog, boolean isEventAvailable) {\n \t\t\tthis.buffer = checkNotNull(buffer);\n-\t\t\tthis.buffersInBacklog = buffersInBacklog;\n \t\t\tthis.unannouncedBacklog = unannouncedBacklog;\n \t\t\tthis.isDataAvailable = isDataAvailable;\n \t\t\tthis.isEventAvailable = isEventAvailable;\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\nindex 8d9a66e67b3..4fbffbf7284 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\n", "chunk": "@@ -19,171 +19,143 @@\n package org.apache.flink.runtime.io.network.partition;\n \n import org.apache.flink.annotation.VisibleForTesting;\n-import org.apache.flink.runtime.checkpoint.channel.ChannelStateReader;\n import org.apache.flink.runtime.checkpoint.channel.ResultSubpartitionInfo;\n import org.apache.flink.runtime.io.network.buffer.Buffer;\n import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n \n import java.io.IOException;\n-import java.util.List;\n \n import static org.apache.flink.util.Preconditions.checkNotNull;\n \n-/**\n- * A single subpartition of a {@link ResultPartition} instance.\n- */\n+/** A single subpartition of a {@link ResultPartition} instance. */\n public abstract class ResultSubpartition {\n \n-\t/** The info of the subpartition to identify it globally within a task. */\n-\tprotected final ResultSubpartitionInfo subpartitionInfo;\n-\n-\t/** The parent partition this subpartition belongs to. */\n-\tprotected final ResultPartition parent;\n-\n-\t// - Statistics ----------------------------------------------------------\n-\n-\tpublic ResultSubpartition(int index, ResultPartition parent) {\n-\t\tthis.parent = parent;\n-\t\tthis.subpartitionInfo = new ResultSubpartitionInfo(parent.getPartitionIndex(), index);\n-\t}\n-\n-\t/**\n-\t * Whether the buffer can be compressed or not. Note that event is not compressed because it\n-\t * is usually small and the size can become even larger after compression.\n-\t */\n-\tprotected boolean canBeCompressed(Buffer buffer) {\n-\t\treturn parent.bufferCompressor != null && buffer.isBuffer() && buffer.readableBytes() > 0;\n-\t}\n-\n-\tpublic ResultSubpartitionInfo getSubpartitionInfo() {\n-\t\treturn subpartitionInfo;\n-\t}\n-\n-\t/**\n-\t * Gets the total numbers of buffers (data buffers plus events).\n-\t */\n-\tprotected abstract long getTotalNumberOfBuffers();\n-\n-\tprotected abstract long getTotalNumberOfBytes();\n-\n-\tpublic int getSubPartitionIndex() {\n-\t\treturn subpartitionInfo.getSubPartitionIdx();\n-\t}\n-\n-\t/**\n-\t * Notifies the parent partition about a consumed {@link ResultSubpartitionView}.\n-\t */\n-\tprotected void onConsumedSubpartition() {\n-\t\tparent.onConsumedSubpartition(getSubPartitionIndex());\n-\t}\n-\n-\tpublic void readRecoveredState(ChannelStateReader stateReader) throws IOException, InterruptedException {\n-\t}\n-\n-\t/**\n-\t * Adds the given buffer.\n-\t *\n-\t * <p>The request may be executed synchronously, or asynchronously, depending on the\n-\t * implementation.\n-\t *\n-\t * <p><strong>IMPORTANT:</strong> Before adding new {@link BufferConsumer} previously added must be in finished\n-\t * state. Because of the performance reasons, this is only enforced during the data reading.\n-\t *\n-\t * @param bufferConsumer\n-\t * \t\tthe buffer to add (transferring ownership to this writer)\n-\t * @param isPriorityEvent\n-\t * @return true if operation succeeded and bufferConsumer was enqueued for consumption.\n-\t * @throws IOException\n-\t * \t\tthrown in case of errors while adding the buffer\n-\t */\n-\tpublic abstract boolean add(BufferConsumer bufferConsumer, boolean isPriorityEvent) throws IOException;\n-\n-\t/**\n-\t * Adds the given buffer.\n-\t *\n-\t * <p>The request may be executed synchronously, or asynchronously, depending on the\n-\t * implementation.\n-\t *\n-\t * <p><strong>IMPORTANT:</strong> Before adding new {@link BufferConsumer} previously added must be in finished\n-\t * state. Because of the performance reasons, this is only enforced during the data reading.\n-\t *\n-\t * @param bufferConsumer\n-\t * \t\tthe buffer to add (transferring ownership to this writer)\n-\t * @return true if operation succeeded and bufferConsumer was enqueued for consumption.\n-\t * @throws IOException\n-\t * \t\tthrown in case of errors while adding the buffer\n-\t */\n-\tpublic boolean add(BufferConsumer bufferConsumer) throws IOException {\n-\t\treturn add(bufferConsumer, false);\n-\t}\n-\n-\tpublic abstract List<Buffer> requestInflightBufferSnapshot();\n-\n-\tpublic abstract void flush();\n-\n-\tpublic abstract void finish() throws IOException;\n-\n-\tpublic abstract void release() throws IOException;\n-\n-\tpublic abstract ResultSubpartitionView createReadView(BufferAvailabilityListener availabilityListener) throws IOException;\n-\n-\tabstract int releaseMemory() throws IOException;\n-\n-\tpublic abstract boolean isReleased();\n-\n-\t@VisibleForTesting\n-\tabstract int getUnannouncedBacklog();\n-\n-\t/**\n-\t * Makes a best effort to get the current size of the queue.\n-\t * This method must not acquire locks or interfere with the task and network threads in\n-\t * any way.\n-\t */\n-\tpublic abstract int unsynchronizedGetNumberOfQueuedBuffers();\n-\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * A combination of a {@link Buffer} and the unannounced backlog in the subpartition to\n-\t * be announced to the consumer.\n-\t */\n-\tpublic static final class BufferAndBacklog {\n-\n-\t\tprivate final Buffer buffer;\n-\t\tprivate final boolean isDataAvailable;\n-\t\tprivate final int unannouncedBacklog;\n-\t\tprivate final boolean isEventAvailable;\n-\n-\t\tpublic BufferAndBacklog(Buffer buffer, boolean isDataAvailable, int unannouncedBacklog, boolean isEventAvailable) {\n-\t\t\tthis.buffer = checkNotNull(buffer);\n-\t\t\tthis.unannouncedBacklog = unannouncedBacklog;\n-\t\t\tthis.isDataAvailable = isDataAvailable;\n-\t\t\tthis.isEventAvailable = isEventAvailable;\n-\t\t}\n-\n-\t\tpublic Buffer buffer() {\n-\t\t\treturn buffer;\n-\t\t}\n-\n-\t\tpublic boolean isDataAvailable() {\n-\t\t\treturn isDataAvailable;\n-\t\t}\n-\n-\t\tpublic int unannouncedBacklog() {\n-\t\t\treturn unannouncedBacklog;\n-\t\t}\n-\n-\t\tpublic boolean isEventAvailable() {\n-\t\t\treturn isEventAvailable;\n-\t\t}\n-\n-\t\tpublic static BufferAndBacklog fromBufferAndLookahead(Buffer current, Buffer lookahead, int unannouncedBacklog) {\n-\t\t\treturn new BufferAndBacklog(\n-\t\t\t\t\tcurrent,\n-\t\t\t\t\tlookahead != null,\n-\t\t\t\t\tunannouncedBacklog,\n-\t\t\t\t\tlookahead != null && !lookahead.isBuffer());\n-\t\t}\n-\t}\n-\n+    /** The info of the subpartition to identify it globally within a task. */\n+    protected final ResultSubpartitionInfo subpartitionInfo;\n+\n+    /** The parent partition this subpartition belongs to. */\n+    protected final ResultPartition parent;\n+\n+    // - Statistics ----------------------------------------------------------\n+\n+    public ResultSubpartition(int index, ResultPartition parent) {\n+        this.parent = parent;\n+        this.subpartitionInfo = new ResultSubpartitionInfo(parent.getPartitionIndex(), index);\n+    }\n+\n+    public ResultSubpartitionInfo getSubpartitionInfo() {\n+        return subpartitionInfo;\n+    }\n+\n+    /** Gets the total numbers of buffers (data buffers plus events). */\n+    protected abstract long getTotalNumberOfBuffers();\n+\n+    protected abstract long getTotalNumberOfBytes();\n+\n+    public int getSubPartitionIndex() {\n+        return subpartitionInfo.getSubPartitionIdx();\n+    }\n+\n+    /** Notifies the parent partition about a consumed {@link ResultSubpartitionView}. */\n+    protected void onConsumedSubpartition() {\n+        parent.onConsumedSubpartition(getSubPartitionIndex());\n+    }\n+\n+    @VisibleForTesting\n+    public final boolean add(BufferConsumer bufferConsumer) throws IOException {\n+        return add(bufferConsumer, 0);\n+    }\n+\n+    /**\n+     * Adds the given buffer.\n+     *\n+     * <p>The request may be executed synchronously, or asynchronously, depending on the\n+     * implementation.\n+     *\n+     * <p><strong>IMPORTANT:</strong> Before adding new {@link BufferConsumer} previously added must\n+     * be in finished state. Because of the performance reasons, this is only enforced during the\n+     * data reading. Priority events can be added while the previous buffer consumer is still open,\n+     * in which case the open buffer consumer is overtaken.\n+     *\n+     * @param bufferConsumer the buffer to add (transferring ownership to this writer)\n+     * @param partialRecordLength the length of bytes to skip in order to start with a complete\n+     *     record, from position index 0 of the underlying {@cite MemorySegment}.\n+     * @return true if operation succeeded and bufferConsumer was enqueued for consumption.\n+     * @throws IOException thrown in case of errors while adding the buffer\n+     */\n+    public abstract boolean add(BufferConsumer bufferConsumer, int partialRecordLength)\n+            throws IOException;\n+\n+    public abstract void flush();\n+\n+    public abstract void finish() throws IOException;\n+\n+    public abstract void release() throws IOException;\n+\n+    public abstract ResultSubpartitionView createReadView(\n+            BufferAvailabilityListener availabilityListener) throws IOException;\n+\n+    public abstract boolean isReleased();\n+\n+    /** Gets the number of non-event buffers in this subpartition. */\n+    abstract int getBuffersInBacklog();\n+\n+    /**\n+     * Makes a best effort to get the current size of the queue. This method must not acquire locks\n+     * or interfere with the task and network threads in any way.\n+     */\n+    public abstract int unsynchronizedGetNumberOfQueuedBuffers();\n+\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * A combination of a {@link Buffer} and the backlog length indicating how many non-event\n+     * buffers are available in the subpartition.\n+     */\n+    public static final class BufferAndBacklog {\n+        private final Buffer buffer;\n+        private final int buffersInBacklog;\n+        private final Buffer.DataType nextDataType;\n+        private final int sequenceNumber;\n+\n+        public BufferAndBacklog(\n+                Buffer buffer,\n+                int buffersInBacklog,\n+                Buffer.DataType nextDataType,\n+                int sequenceNumber) {\n+            this.buffer = checkNotNull(buffer);\n+            this.buffersInBacklog = buffersInBacklog;\n+            this.nextDataType = checkNotNull(nextDataType);\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        public Buffer buffer() {\n+            return buffer;\n+        }\n+\n+        public boolean isDataAvailable() {\n+            return nextDataType != Buffer.DataType.NONE;\n+        }\n+\n+        public int buffersInBacklog() {\n+            return buffersInBacklog;\n+        }\n+\n+        public boolean isEventAvailable() {\n+            return nextDataType.isEvent();\n+        }\n+\n+        public Buffer.DataType getNextDataType() {\n+            return nextDataType;\n+        }\n+\n+        public int getSequenceNumber() {\n+            return sequenceNumber;\n+        }\n+\n+        public static BufferAndBacklog fromBufferAndLookahead(\n+                Buffer current, Buffer.DataType nextDataType, int backlog, int sequenceNumber) {\n+            return new BufferAndBacklog(current, backlog, nextDataType, sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\nindex 95eaee362d3..b06dbef2e0f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\n", "chunk": "@@ -19,193 +19,143 @@\n package org.apache.flink.runtime.io.network.partition;\n \n import org.apache.flink.annotation.VisibleForTesting;\n-import org.apache.flink.runtime.checkpoint.channel.ChannelStateReader;\n import org.apache.flink.runtime.checkpoint.channel.ResultSubpartitionInfo;\n import org.apache.flink.runtime.io.network.buffer.Buffer;\n import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n \n import java.io.IOException;\n-import java.util.List;\n \n import static org.apache.flink.util.Preconditions.checkNotNull;\n \n-/**\n- * A single subpartition of a {@link ResultPartition} instance.\n- */\n+/** A single subpartition of a {@link ResultPartition} instance. */\n public abstract class ResultSubpartition {\n \n-\t/** The info of the subpartition to identify it globally within a task. */\n-\tprotected final ResultSubpartitionInfo subpartitionInfo;\n-\n-\t/** The parent partition this subpartition belongs to. */\n-\tprotected final ResultPartition parent;\n-\n-\t// - Statistics ----------------------------------------------------------\n-\n-\tpublic ResultSubpartition(int index, ResultPartition parent) {\n-\t\tthis.parent = parent;\n-\t\tthis.subpartitionInfo = new ResultSubpartitionInfo(parent.getPartitionIndex(), index);\n-\t}\n-\n-\t/**\n-\t * Whether the buffer can be compressed or not. Note that event is not compressed because it\n-\t * is usually small and the size can become even larger after compression.\n-\t */\n-\tprotected boolean canBeCompressed(Buffer buffer) {\n-\t\treturn parent.bufferCompressor != null && buffer.isBuffer() && buffer.readableBytes() > 0;\n-\t}\n-\n-\tpublic ResultSubpartitionInfo getSubpartitionInfo() {\n-\t\treturn subpartitionInfo;\n-\t}\n-\n-\t/**\n-\t * Gets the total numbers of buffers (data buffers plus events).\n-\t */\n-\tprotected abstract long getTotalNumberOfBuffers();\n-\n-\tprotected abstract long getTotalNumberOfBytes();\n-\n-\tpublic int getSubPartitionIndex() {\n-\t\treturn subpartitionInfo.getSubPartitionIdx();\n-\t}\n-\n-\t/**\n-\t * Notifies the parent partition about a consumed {@link ResultSubpartitionView}.\n-\t */\n-\tprotected void onConsumedSubpartition() {\n-\t\tparent.onConsumedSubpartition(getSubPartitionIndex());\n-\t}\n-\n-\tpublic void initializeState(ChannelStateReader stateReader) throws IOException, InterruptedException {\n-\t}\n-\n-\t/**\n-\t * Adds the given buffer.\n-\t *\n-\t * <p>The request may be executed synchronously, or asynchronously, depending on the\n-\t * implementation.\n-\t *\n-\t * <p><strong>IMPORTANT:</strong> Before adding new {@link BufferConsumer} previously added must be in finished\n-\t * state. Because of the performance reasons, this is only enforced during the data reading.\n-\t *\n-\t * @param bufferConsumer\n-\t * \t\tthe buffer to add (transferring ownership to this writer)\n-\t * @param isPriorityEvent\n-\t * @return true if operation succeeded and bufferConsumer was enqueued for consumption.\n-\t * @throws IOException\n-\t * \t\tthrown in case of errors while adding the buffer\n-\t */\n-\tpublic abstract boolean add(BufferConsumer bufferConsumer, boolean isPriorityEvent) throws IOException;\n-\n-\t/**\n-\t * Adds the given buffer.\n-\t *\n-\t * <p>The request may be executed synchronously, or asynchronously, depending on the\n-\t * implementation.\n-\t *\n-\t * <p><strong>IMPORTANT:</strong> Before adding new {@link BufferConsumer} previously added must be in finished\n-\t * state. Because of the performance reasons, this is only enforced during the data reading.\n-\t *\n-\t * @param bufferConsumer\n-\t * \t\tthe buffer to add (transferring ownership to this writer)\n-\t * @return true if operation succeeded and bufferConsumer was enqueued for consumption.\n-\t * @throws IOException\n-\t * \t\tthrown in case of errors while adding the buffer\n-\t */\n-\tpublic boolean add(BufferConsumer bufferConsumer) throws IOException {\n-\t\treturn add(bufferConsumer, false);\n-\t}\n-\n-\tpublic abstract List<Buffer> requestInflightBufferSnapshot();\n-\n-\tpublic abstract void flush();\n-\n-\tpublic abstract void finish() throws IOException;\n-\n-\tpublic abstract void release() throws IOException;\n-\n-\tpublic abstract ResultSubpartitionView createReadView(BufferAvailabilityListener availabilityListener) throws IOException;\n-\n-\tabstract int releaseMemory() throws IOException;\n-\n-\tpublic abstract boolean isReleased();\n-\n-\t/**\n-\t * Gets the number of non-event buffers in this subpartition.\n-\t *\n-\t * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-\t * scenarios since it does not make any concurrency guarantees.\n-\t */\n-\t@VisibleForTesting\n-\tabstract int getBuffersInBacklog();\n-\n-\t/**\n-\t * Makes a best effort to get the current size of the queue.\n-\t * This method must not acquire locks or interfere with the task and network threads in\n-\t * any way.\n-\t */\n-\tpublic abstract int unsynchronizedGetNumberOfQueuedBuffers();\n-\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * A combination of a {@link Buffer} and the backlog length indicating\n-\t * how many non-event buffers are available in the subpartition.\n-\t */\n-\tpublic static final class BufferAndBacklog {\n-\n-\t\tprivate final Buffer buffer;\n-\t\tprivate final boolean isDataAvailable;\n-\t\tprivate final int buffersInBacklog;\n-\t\tprivate final int unannouncedBacklog;\n-\t\tprivate final boolean isEventAvailable;\n-\n-\t\tpublic BufferAndBacklog(\n-\t\t\t\tBuffer buffer,\n-\t\t\t\tboolean isDataAvailable,\n-\t\t\t\tint buffersInBacklog,\n-\t\t\t\tint unannouncedBacklog,\n-\t\t\t\tboolean isEventAvailable) {\n-\t\t\tthis.buffer = checkNotNull(buffer);\n-\t\t\tthis.buffersInBacklog = buffersInBacklog;\n-\t\t\tthis.unannouncedBacklog = unannouncedBacklog;\n-\t\t\tthis.isDataAvailable = isDataAvailable;\n-\t\t\tthis.isEventAvailable = isEventAvailable;\n-\t\t}\n-\n-\t\tpublic Buffer buffer() {\n-\t\t\treturn buffer;\n-\t\t}\n-\n-\t\tpublic boolean isDataAvailable() {\n-\t\t\treturn isDataAvailable;\n-\t\t}\n-\n-\t\tpublic int buffersInBacklog() {\n-\t\t\treturn buffersInBacklog;\n-\t\t}\n-\n-\t\tpublic int unannouncedBacklog() {\n-\t\t\treturn unannouncedBacklog;\n-\t\t}\n-\n-\t\tpublic boolean isEventAvailable() {\n-\t\t\treturn isEventAvailable;\n-\t\t}\n-\n-\t\tpublic static BufferAndBacklog fromBufferAndLookahead(\n-\t\t\t\tBuffer current,\n-\t\t\t\tBuffer lookahead,\n-\t\t\t\tint buffersInBacklog,\n-\t\t\t\tint unannouncedBacklog) {\n-\t\t\treturn new BufferAndBacklog(\n-\t\t\t\t\tcurrent,\n-\t\t\t\t\tlookahead != null,\n-\t\t\t\t\tbuffersInBacklog,\n-\t\t\t\t\tunannouncedBacklog,\n-\t\t\t\t\tlookahead != null && !lookahead.isBuffer());\n-\t\t}\n-\t}\n-\n+    /** The info of the subpartition to identify it globally within a task. */\n+    protected final ResultSubpartitionInfo subpartitionInfo;\n+\n+    /** The parent partition this subpartition belongs to. */\n+    protected final ResultPartition parent;\n+\n+    // - Statistics ----------------------------------------------------------\n+\n+    public ResultSubpartition(int index, ResultPartition parent) {\n+        this.parent = parent;\n+        this.subpartitionInfo = new ResultSubpartitionInfo(parent.getPartitionIndex(), index);\n+    }\n+\n+    public ResultSubpartitionInfo getSubpartitionInfo() {\n+        return subpartitionInfo;\n+    }\n+\n+    /** Gets the total numbers of buffers (data buffers plus events). */\n+    protected abstract long getTotalNumberOfBuffers();\n+\n+    protected abstract long getTotalNumberOfBytes();\n+\n+    public int getSubPartitionIndex() {\n+        return subpartitionInfo.getSubPartitionIdx();\n+    }\n+\n+    /** Notifies the parent partition about a consumed {@link ResultSubpartitionView}. */\n+    protected void onConsumedSubpartition() {\n+        parent.onConsumedSubpartition(getSubPartitionIndex());\n+    }\n+\n+    @VisibleForTesting\n+    public final boolean add(BufferConsumer bufferConsumer) throws IOException {\n+        return add(bufferConsumer, 0);\n+    }\n+\n+    /**\n+     * Adds the given buffer.\n+     *\n+     * <p>The request may be executed synchronously, or asynchronously, depending on the\n+     * implementation.\n+     *\n+     * <p><strong>IMPORTANT:</strong> Before adding new {@link BufferConsumer} previously added must\n+     * be in finished state. Because of the performance reasons, this is only enforced during the\n+     * data reading. Priority events can be added while the previous buffer consumer is still open,\n+     * in which case the open buffer consumer is overtaken.\n+     *\n+     * @param bufferConsumer the buffer to add (transferring ownership to this writer)\n+     * @param partialRecordLength the length of bytes to skip in order to start with a complete\n+     *     record, from position index 0 of the underlying {@cite MemorySegment}.\n+     * @return true if operation succeeded and bufferConsumer was enqueued for consumption.\n+     * @throws IOException thrown in case of errors while adding the buffer\n+     */\n+    public abstract boolean add(BufferConsumer bufferConsumer, int partialRecordLength)\n+            throws IOException;\n+\n+    public abstract void flush();\n+\n+    public abstract void finish() throws IOException;\n+\n+    public abstract void release() throws IOException;\n+\n+    public abstract ResultSubpartitionView createReadView(\n+            BufferAvailabilityListener availabilityListener) throws IOException;\n+\n+    public abstract boolean isReleased();\n+\n+    /** Gets the number of non-event buffers in this subpartition. */\n+    abstract int getBuffersInBacklogUnsafe();\n+\n+    /**\n+     * Makes a best effort to get the current size of the queue. This method must not acquire locks\n+     * or interfere with the task and network threads in any way.\n+     */\n+    public abstract int unsynchronizedGetNumberOfQueuedBuffers();\n+\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * A combination of a {@link Buffer} and the backlog length indicating how many non-event\n+     * buffers are available in the subpartition.\n+     */\n+    public static final class BufferAndBacklog {\n+        private final Buffer buffer;\n+        private final int buffersInBacklog;\n+        private final Buffer.DataType nextDataType;\n+        private final int sequenceNumber;\n+\n+        public BufferAndBacklog(\n+                Buffer buffer,\n+                int buffersInBacklog,\n+                Buffer.DataType nextDataType,\n+                int sequenceNumber) {\n+            this.buffer = checkNotNull(buffer);\n+            this.buffersInBacklog = buffersInBacklog;\n+            this.nextDataType = checkNotNull(nextDataType);\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        public Buffer buffer() {\n+            return buffer;\n+        }\n+\n+        public boolean isDataAvailable() {\n+            return nextDataType != Buffer.DataType.NONE;\n+        }\n+\n+        public int buffersInBacklog() {\n+            return buffersInBacklog;\n+        }\n+\n+        public boolean isEventAvailable() {\n+            return nextDataType.isEvent();\n+        }\n+\n+        public Buffer.DataType getNextDataType() {\n+            return nextDataType;\n+        }\n+\n+        public int getSequenceNumber() {\n+            return sequenceNumber;\n+        }\n+\n+        public static BufferAndBacklog fromBufferAndLookahead(\n+                Buffer current, Buffer.DataType nextDataType, int backlog, int sequenceNumber) {\n+            return new BufferAndBacklog(current, backlog, nextDataType, sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "088d16517126d7128e1f072d588b9ce0f4787ae6", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][refactor] Made a safe method for getting the number of buffers in the queue visible in the interface."}, {"oid": "703662aa61a8f82d4df6de7e0518a568822f71db", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Subpartition is able to notify the desirable buffer size for input buffer consumer."}, {"oid": "60aa2ac29797df576fe14f5c888f09626351b774", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[refactor][runtime] Added postfix `unsafe` for methods ResultSubpartition#getTotalNumberOfBuffers and ResultSubpartition#getTotalNumberOfBytes"}, {"oid": "dd8f4e2603309493300099396568ffc681e76e80", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Timeout aligned to unaligned checkpoint barrier in the output buffers"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2ODk4Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422868983", "body": "why we need to trigger announce backlog while adding credit?\r\nI assume since the added `creditDeltas` is always more than zero, then we have the chance to announce the backlog later via sending `BufferResponse`.", "bodyText": "why we need to trigger announce backlog while adding credit?\nI assume since the added creditDeltas is always more than zero, then we have the chance to announce the backlog later via sending BufferResponse.", "bodyHTML": "<p dir=\"auto\">why we need to trigger announce backlog while adding credit?<br>\nI assume since the added <code>creditDeltas</code> is always more than zero, then we have the chance to announce the backlog later via sending <code>BufferResponse</code>.</p>", "author": "zhijiangW", "createdAt": "2020-05-11T08:25:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -94,13 +99,27 @@ public void requestSubpartitionView(\n \t}\n \n \t@Override\n-\tpublic void addCredit(int creditDeltas) {\n+\tpublic boolean addCredit(int creditDeltas) {\n \t\tnumCreditsAvailable += creditDeltas;\n+\t\treturn shouldAnnounceBacklog();", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMDQyNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r423500427", "bodyText": "You are right shouldAnnounceBacklog always return false, I will replace the function call with return false. The reason why we need to change return type of addCredit is that we can't identify whether we are calling addCredit or resumeConsumption in PartitionRequestQueue.", "author": "wsry", "createdAt": "2020-05-12T06:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2ODk4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 191e5471df4..cc9cadaa37a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -101,7 +102,7 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t@Override\n \tpublic boolean addCredit(int creditDeltas) {\n \t\tnumCreditsAvailable += creditDeltas;\n-\t\treturn shouldAnnounceBacklog();\n+\t\treturn false;\n \t}\n \n \t@Override\n", "next_change": {"commit": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex cc9cadaa37a..09ce436d1ec 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -100,23 +99,22 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t}\n \n \t@Override\n-\tpublic boolean addCredit(int creditDeltas) {\n+\tpublic void addCredit(int creditDeltas) throws Exception {\n \t\tnumCreditsAvailable += creditDeltas;\n-\t\treturn false;\n+\t\trequestQueue.enqueueAvailableReader(this, this::isAvailable);\n \t}\n \n \t@Override\n \tpublic boolean shouldAnnounceBacklog() {\n-\t\treturn initialCredit == 0 && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n+\t\treturn !withoutExclusiveCredits && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n \t}\n \n \t@Override\n-\tpublic boolean resumeConsumption(int availableCredit, int unfulfilledBacklog) {\n+\tpublic void resumeConsumption(int availableCredit, boolean hasUnfulfilledBacklog) throws Exception {\n \t\t// reset the available credit\n \t\tnumCreditsAvailable = availableCredit;\n \t\tsubpartitionView.resumeConsumption();\n-\n-\t\treturn shouldAnnounceBacklog() && unfulfilledBacklog == 0;\n+\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || !hasUnfulfilledBacklog && shouldAnnounceBacklog()));\n \t}\n \n \t@Override\n", "next_change": {"commit": "fb4c607a5c4780729143d458b1c7633adcba59bf", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 09ce436d1ec..0c03c332422 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -105,16 +105,16 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t}\n \n \t@Override\n-\tpublic boolean shouldAnnounceBacklog() {\n-\t\treturn !withoutExclusiveCredits && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n+\tpublic boolean shouldAnnounceBacklog(boolean hasUnfulfilledBacklog) {\n+\t\treturn !hasUnfulfilledBacklog && withoutExclusiveCredits && numCreditsAvailable == 0;\n \t}\n \n \t@Override\n-\tpublic void resumeConsumption(int availableCredit, boolean hasUnfulfilledBacklog) throws Exception {\n+\tpublic void resumeConsumption(int availableCredits, boolean hasUnfulfilledBacklog) throws Exception {\n \t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredit;\n+\t\tnumCreditsAvailable = availableCredits;\n \t\tsubpartitionView.resumeConsumption();\n-\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || !hasUnfulfilledBacklog && shouldAnnounceBacklog()));\n+\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || shouldAnnounceBacklog(hasUnfulfilledBacklog)));\n \t}\n \n \t@Override\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 0c03c332422..b1a8400b7a1 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -20,227 +20,225 @@ package org.apache.flink.runtime.io.network.netty;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.runtime.io.network.NetworkSequenceViewReader;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.AddBacklogMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.BufferResponseMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.ServerOutboundMessage;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n import org.apache.flink.runtime.io.network.partition.BufferAvailabilityListener;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionProvider;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputChannel.BufferAndAvailability;\n import org.apache.flink.runtime.io.network.partition.consumer.InputChannelID;\n import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n \n+import javax.annotation.Nullable;\n+\n import java.io.IOException;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n+\n /**\n  * Simple wrapper for the subpartition view used in the new network credit-based mode.\n  *\n- * <p>It also keeps track of available buffers and notifies the outbound\n- * handler about non-emptiness, similar to the {@link LocalInputChannel}.\n+ * <p>It also keeps track of available buffers and notifies the outbound handler about\n+ * non-emptiness, similar to the {@link LocalInputChannel}.\n  */\n-class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListener, NetworkSequenceViewReader {\n-\n-\tprivate final Object requestLock = new Object();\n-\n-\tprivate final InputChannelID receiverId;\n-\n-\tprivate final PartitionRequestQueue requestQueue;\n-\n-\tprivate final boolean withoutExclusiveCredits;\n-\n-\tprivate volatile ResultSubpartitionView subpartitionView;\n-\n-\t/**\n-\t * The status indicating whether this reader is already enqueued in the pipeline for transferring\n-\t * data or not.\n-\t *\n-\t * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n-\t * thread only since there is no synchronisation.\n-\t */\n-\tprivate boolean isRegisteredAsAvailable = false;\n-\n-\t/** The number of available buffers for holding data on the consumer side. */\n-\tprivate int numCreditsAvailable;\n-\n-\tprivate int sequenceNumber = -1;\n-\n-\tCreditBasedSequenceNumberingViewReader(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tint initialCredit,\n-\t\t\tPartitionRequestQueue requestQueue) {\n-\n-\t\tthis.receiverId = receiverId;\n-\t\tthis.numCreditsAvailable = initialCredit;\n-\t\tthis.requestQueue = requestQueue;\n-\t\tthis.withoutExclusiveCredits = initialCredit == 0;\n-\t}\n-\n-\t@Override\n-\tpublic void requestSubpartitionView(\n-\t\tResultPartitionProvider partitionProvider,\n-\t\tResultPartitionID resultPartitionId,\n-\t\tint subPartitionIndex) throws IOException {\n-\n-\t\tsynchronized (requestLock) {\n-\t\t\tif (subpartitionView == null) {\n-\t\t\t\t// This this call can trigger a notification we have to\n-\t\t\t\t// schedule a separate task at the event loop that will\n-\t\t\t\t// start consuming this. Otherwise the reference to the\n-\t\t\t\t// view cannot be available in getNextBuffer().\n-\t\t\t\tthis.subpartitionView = partitionProvider.createSubpartitionView(\n-\t\t\t\t\tresultPartitionId,\n-\t\t\t\t\tsubPartitionIndex,\n-\t\t\t\t\tthis);\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalStateException(\"Subpartition already requested\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void addCredit(int creditDeltas) throws Exception {\n-\t\tnumCreditsAvailable += creditDeltas;\n-\t\trequestQueue.enqueueAvailableReader(this, this::isAvailable);\n-\t}\n-\n-\t@Override\n-\tpublic boolean shouldAnnounceBacklog(boolean hasUnfulfilledBacklog) {\n-\t\treturn !hasUnfulfilledBacklog && withoutExclusiveCredits && numCreditsAvailable == 0;\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption(int availableCredits, boolean hasUnfulfilledBacklog) throws Exception {\n-\t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredits;\n-\t\tsubpartitionView.resumeConsumption();\n-\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || shouldAnnounceBacklog(hasUnfulfilledBacklog)));\n-\t}\n-\n-\t@Override\n-\tpublic void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n-\t\tthis.isRegisteredAsAvailable = isRegisteredAvailable;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRegisteredAsAvailable() {\n-\t\treturn isRegisteredAsAvailable;\n-\t}\n-\n-\t/**\n-\t * Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t */\n-\t@Override\n-\tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n-\t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n-\t}\n-\n-\t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n-\t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t *\n-\t * @param bufferAndBacklog\n-\t * \t\tcurrent buffer and backlog including information about the next buffer\n-\t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n-\t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic InputChannelID getReceiverId() {\n-\t\treturn receiverId;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumCreditsAvailable() {\n-\t\treturn numCreditsAvailable;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean hasBuffersAvailable() {\n-\t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\tprivate AddBacklogMessage getAddBacklogMessage() {\n-\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n-\t\tif (backlog > 0) {\n-\t\t\treturn new AddBacklogMessage(receiverId, backlog);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate BufferResponseMessage getBufferResponseMessage() throws IOException {\n-\t\tBufferAndBacklog next = subpartitionView.getNextBuffer();\n-\t\tif (next != null) {\n-\t\t\tsequenceNumber++;\n-\n-\t\t\tif (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n-\t\t\t\tthrow new IllegalStateException(\"no credit available\");\n-\t\t\t}\n-\n-\t\t\treturn new BufferResponseMessage(\n-\t\t\t\tnext.buffer(), receiverId, sequenceNumber, next.unannouncedBacklog(), isAvailable(next));\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic ServerOutboundMessage getNextMessage() throws IOException {\n-\t\t// BufferResponse is processed with higher priority compared with AddBacklog. There are three scenarios\n-\t\t// that we never announce backlog to the consumer through AddBacklog message:\n-\t\t// 1. We have exclusive credits which means unannounced backlog can be always carried by BufferResponse.\n-\t\t//    So AddBacklog message is never needed.\n-\t\t// 2. We already have available credits so we do not need to announce backlog to the consumer to request\n-\t\t//    new ones.\n-\t\t// 3. Next Buffer is an event which does not consume any credit. So we can just send the event and bring\n-\t\t//    the unannounced backlog with it.\n-\t\tif (!withoutExclusiveCredits || numCreditsAvailable > 0 || subpartitionView.isAvailable(0)) {\n-\t\t\treturn getBufferResponseMessage();\n-\t\t}\n-\t\treturn getAddBacklogMessage();\n-\t}\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn subpartitionView.isReleased();\n-\t}\n-\n-\t@Override\n-\tpublic Throwable getFailureCause() {\n-\t\treturn subpartitionView.getFailureCause();\n-\t}\n-\n-\t@Override\n-\tpublic void releaseAllResources() throws IOException {\n-\t\tsubpartitionView.releaseAllResources();\n-\t}\n-\n-\t@Override\n-\tpublic void notifyDataAvailable() {\n-\t\trequestQueue.notifyReaderNonEmpty(this);\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"CreditBasedSequenceNumberingViewReader{\" +\n-\t\t\t\"requestLock=\" + requestLock +\n-\t\t\t\", receiverId=\" + receiverId +\n-\t\t\t\", withoutExclusiveCredits=\" + withoutExclusiveCredits +\n-\t\t\t\", sequenceNumber=\" + sequenceNumber +\n-\t\t\t\", numCreditsAvailable=\" + numCreditsAvailable +\n-\t\t\t\", isRegisteredAsAvailable=\" + isRegisteredAsAvailable +\n-\t\t\t'}';\n-\t}\n+class CreditBasedSequenceNumberingViewReader\n+        implements BufferAvailabilityListener, NetworkSequenceViewReader {\n+\n+    private final Object requestLock = new Object();\n+\n+    private final InputChannelID receiverId;\n+\n+    private final PartitionRequestQueue requestQueue;\n+\n+    private final int initialCredit;\n+\n+    private volatile ResultSubpartitionView subpartitionView;\n+\n+    /**\n+     * The status indicating whether this reader is already enqueued in the pipeline for\n+     * transferring data or not.\n+     *\n+     * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n+     * thread only since there is no synchronisation.\n+     */\n+    private boolean isRegisteredAsAvailable = false;\n+\n+    /** The number of available buffers for holding data on the consumer side. */\n+    private int numCreditsAvailable;\n+\n+    CreditBasedSequenceNumberingViewReader(\n+            InputChannelID receiverId, int initialCredit, PartitionRequestQueue requestQueue) {\n+        checkArgument(initialCredit >= 0, \"Must be non-negative.\");\n+\n+        this.receiverId = receiverId;\n+        this.initialCredit = initialCredit;\n+        this.numCreditsAvailable = initialCredit;\n+        this.requestQueue = requestQueue;\n+    }\n+\n+    @Override\n+    public void requestSubpartitionView(\n+            ResultPartitionProvider partitionProvider,\n+            ResultPartitionID resultPartitionId,\n+            int subPartitionIndex)\n+            throws IOException {\n+\n+        synchronized (requestLock) {\n+            if (subpartitionView == null) {\n+                // This this call can trigger a notification we have to\n+                // schedule a separate task at the event loop that will\n+                // start consuming this. Otherwise the reference to the\n+                // view cannot be available in getNextBuffer().\n+                this.subpartitionView =\n+                        partitionProvider.createSubpartitionView(\n+                                resultPartitionId, subPartitionIndex, this);\n+            } else {\n+                throw new IllegalStateException(\"Subpartition already requested\");\n+            }\n+        }\n+\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public void addCredit(int creditDeltas) {\n+        numCreditsAvailable += creditDeltas;\n+    }\n+\n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n+    @Override\n+    public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;\n+        }\n+\n+        subpartitionView.resumeConsumption();\n+    }\n+\n+    @Override\n+    public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n+        this.isRegisteredAsAvailable = isRegisteredAvailable;\n+    }\n+\n+    @Override\n+    public boolean isRegisteredAsAvailable() {\n+        return isRegisteredAsAvailable;\n+    }\n+\n+    /**\n+     * Returns true only if the next buffer is an event or the reader has both available credits and\n+     * buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such\n+     *     that {@code getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n+     */\n+    @Override\n+    public boolean isAvailable() {\n+        return subpartitionView.isAvailable(numCreditsAvailable);\n+    }\n+\n+    /**\n+     * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next\n+     * buffer in line.\n+     *\n+     * <p>Returns the next data type only if the next buffer is an event or the reader has both\n+     * available credits and buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #isAvailable()}, such that {@code\n+     *     getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n+     * @param bufferAndBacklog current buffer and backlog including information about the next\n+     *     buffer\n+     * @return the next data type if the next buffer can be pulled immediately or {@link\n+     *     Buffer.DataType#NONE}\n+     */\n+    private Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n+        final Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+        if (numCreditsAvailable > 0 || nextDataType.isEvent()) {\n+            return nextDataType;\n+        }\n+        return Buffer.DataType.NONE;\n+    }\n+\n+    @Override\n+    public InputChannelID getReceiverId() {\n+        return receiverId;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumCreditsAvailable() {\n+        return numCreditsAvailable;\n+    }\n+\n+    @VisibleForTesting\n+    boolean hasBuffersAvailable() {\n+        return subpartitionView.isAvailable(Integer.MAX_VALUE);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BufferAndAvailability getNextBuffer() throws IOException {\n+        BufferAndBacklog next = subpartitionView.getNextBuffer();\n+        if (next != null) {\n+            if (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n+                throw new IllegalStateException(\"no credit available\");\n+            }\n+\n+            final Buffer.DataType nextDataType = getNextDataType(next);\n+            return new BufferAndAvailability(\n+                    next.buffer(), nextDataType, next.buffersInBacklog(), next.getSequenceNumber());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public int getRemainingBacklog() {\n+        return subpartitionView.getRemainingBacklog();\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        return subpartitionView.isReleased();\n+    }\n+\n+    @Override\n+    public Throwable getFailureCause() {\n+        return subpartitionView.getFailureCause();\n+    }\n+\n+    @Override\n+    public void releaseAllResources() throws IOException {\n+        subpartitionView.releaseAllResources();\n+    }\n+\n+    @Override\n+    public void notifyDataAvailable() {\n+        requestQueue.notifyReaderNonEmpty(this);\n+    }\n+\n+    @Override\n+    public void notifyPriorityEvent(int prioritySequenceNumber) {\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CreditBasedSequenceNumberingViewReader{\"\n+                + \"requestLock=\"\n+                + requestLock\n+                + \", receiverId=\"\n+                + receiverId\n+                + \", numCreditsAvailable=\"\n+                + numCreditsAvailable\n+                + \", isRegisteredAsAvailable=\"\n+                + isRegisteredAsAvailable\n+                + '}';\n+    }\n }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 191e5471df4..01d08d5f53c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -29,213 +30,216 @@ import org.apache.flink.runtime.io.network.partition.consumer.InputChannel.Buffe\n import org.apache.flink.runtime.io.network.partition.consumer.InputChannelID;\n import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n \n+import javax.annotation.Nullable;\n+\n import java.io.IOException;\n \n-import static org.apache.flink.util.Preconditions.checkState;\n+import static org.apache.flink.util.Preconditions.checkArgument;\n \n /**\n  * Simple wrapper for the subpartition view used in the new network credit-based mode.\n  *\n- * <p>It also keeps track of available buffers and notifies the outbound\n- * handler about non-emptiness, similar to the {@link LocalInputChannel}.\n+ * <p>It also keeps track of available buffers and notifies the outbound handler about\n+ * non-emptiness, similar to the {@link LocalInputChannel}.\n  */\n-class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListener, NetworkSequenceViewReader {\n-\n-\tprivate final Object requestLock = new Object();\n-\n-\tprivate final InputChannelID receiverId;\n-\n-\tprivate final PartitionRequestQueue requestQueue;\n-\n-\tprivate final int initialCredit;\n-\n-\tprivate volatile ResultSubpartitionView subpartitionView;\n-\n-\t/**\n-\t * The status indicating whether this reader is already enqueued in the pipeline for transferring\n-\t * data or not.\n-\t *\n-\t * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n-\t * thread only since there is no synchronisation.\n-\t */\n-\tprivate boolean isRegisteredAsAvailable = false;\n-\n-\t/** The number of available buffers for holding data on the consumer side. */\n-\tprivate int numCreditsAvailable;\n-\n-\tprivate int sequenceNumber = -1;\n-\n-\tCreditBasedSequenceNumberingViewReader(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tint initialCredit,\n-\t\t\tPartitionRequestQueue requestQueue) {\n-\n-\t\tthis.receiverId = receiverId;\n-\t\tthis.numCreditsAvailable = initialCredit;\n-\t\tthis.requestQueue = requestQueue;\n-\t\tthis.initialCredit = initialCredit;\n-\t}\n-\n-\t@Override\n-\tpublic void requestSubpartitionView(\n-\t\tResultPartitionProvider partitionProvider,\n-\t\tResultPartitionID resultPartitionId,\n-\t\tint subPartitionIndex) throws IOException {\n-\n-\t\tsynchronized (requestLock) {\n-\t\t\tif (subpartitionView == null) {\n-\t\t\t\t// This this call can trigger a notification we have to\n-\t\t\t\t// schedule a separate task at the event loop that will\n-\t\t\t\t// start consuming this. Otherwise the reference to the\n-\t\t\t\t// view cannot be available in getNextBuffer().\n-\t\t\t\tthis.subpartitionView = partitionProvider.createSubpartitionView(\n-\t\t\t\t\tresultPartitionId,\n-\t\t\t\t\tsubPartitionIndex,\n-\t\t\t\t\tthis);\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalStateException(\"Subpartition already requested\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic boolean addCredit(int creditDeltas) {\n-\t\tnumCreditsAvailable += creditDeltas;\n-\t\treturn shouldAnnounceBacklog();\n-\t}\n-\n-\t@Override\n-\tpublic boolean shouldAnnounceBacklog() {\n-\t\treturn initialCredit == 0 && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\t@Override\n-\tpublic boolean resumeConsumption(int availableCredit, int unfulfilledBacklog) {\n-\t\tif (initialCredit > 0) {\n-\t\t\tcheckState(numCreditsAvailable == availableCredit, \"Illegal number of available credit.\");\n-\t\t}\n-\n-\t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredit;\n-\t\tsubpartitionView.resumeConsumption();\n-\n-\t\treturn shouldAnnounceBacklog() && unfulfilledBacklog == 0;\n-\t}\n-\n-\t@Override\n-\tpublic void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n-\t\tthis.isRegisteredAsAvailable = isRegisteredAvailable;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRegisteredAsAvailable() {\n-\t\treturn isRegisteredAsAvailable;\n-\t}\n-\n-\t/**\n-\t * Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t */\n-\t@Override\n-\tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n-\t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n-\t}\n-\n-\t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n-\t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t *\n-\t * @param bufferAndBacklog\n-\t * \t\tcurrent buffer and backlog including information about the next buffer\n-\t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n-\t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic InputChannelID getReceiverId() {\n-\t\treturn receiverId;\n-\t}\n-\n-\t@Override\n-\tpublic int getSequenceNumber() {\n-\t\treturn sequenceNumber;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumCreditsAvailable() {\n-\t\treturn numCreditsAvailable;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean hasBuffersAvailable() {\n-\t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\t@Override\n-\tpublic BufferAndAvailability getNextBuffer() throws IOException {\n-\t\tif (numCreditsAvailable == 0 && initialCredit == 0 && !subpartitionView.isAvailable(0)) {\n-\t\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n-\t\t\tif (backlog > 0) {\n-\t\t\t\treturn new BufferAndAvailability(null, false, backlog);\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tBufferAndBacklog next = subpartitionView.getNextBuffer();\n-\t\tif (next != null) {\n-\t\t\tsequenceNumber++;\n-\n-\t\t\tif (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n-\t\t\t\tthrow new IllegalStateException(\"no credit available\");\n-\t\t\t}\n-\n-\t\t\treturn new BufferAndAvailability(\n-\t\t\t\tnext.buffer(), isAvailable(next), next.unannouncedBacklog());\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn subpartitionView.isReleased();\n-\t}\n-\n-\t@Override\n-\tpublic Throwable getFailureCause() {\n-\t\treturn subpartitionView.getFailureCause();\n-\t}\n-\n-\t@Override\n-\tpublic void releaseAllResources() throws IOException {\n-\t\tsubpartitionView.releaseAllResources();\n-\t}\n-\n-\t@Override\n-\tpublic void notifyDataAvailable() {\n-\t\trequestQueue.notifyReaderNonEmpty(this);\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"CreditBasedSequenceNumberingViewReader{\" +\n-\t\t\t\"requestLock=\" + requestLock +\n-\t\t\t\", receiverId=\" + receiverId +\n-\t\t\t\", initialCredit=\" + initialCredit +\n-\t\t\t\", sequenceNumber=\" + sequenceNumber +\n-\t\t\t\", numCreditsAvailable=\" + numCreditsAvailable +\n-\t\t\t\", isRegisteredAsAvailable=\" + isRegisteredAsAvailable +\n-\t\t\t'}';\n-\t}\n+class CreditBasedSequenceNumberingViewReader\n+        implements BufferAvailabilityListener, NetworkSequenceViewReader {\n+\n+    private final Object requestLock = new Object();\n+\n+    private final InputChannelID receiverId;\n+\n+    private final PartitionRequestQueue requestQueue;\n+\n+    private final int initialCredit;\n+\n+    private volatile ResultSubpartitionView subpartitionView;\n+\n+    /**\n+     * The status indicating whether this reader is already enqueued in the pipeline for\n+     * transferring data or not.\n+     *\n+     * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n+     * thread only since there is no synchronisation.\n+     */\n+    private boolean isRegisteredAsAvailable = false;\n+\n+    /** The number of available buffers for holding data on the consumer side. */\n+    private int numCreditsAvailable;\n+\n+    CreditBasedSequenceNumberingViewReader(\n+            InputChannelID receiverId, int initialCredit, PartitionRequestQueue requestQueue) {\n+        checkArgument(initialCredit >= 0, \"Must be non-negative.\");\n+\n+        this.receiverId = receiverId;\n+        this.initialCredit = initialCredit;\n+        this.numCreditsAvailable = initialCredit;\n+        this.requestQueue = requestQueue;\n+    }\n+\n+    @Override\n+    public void requestSubpartitionView(\n+            ResultPartitionProvider partitionProvider,\n+            ResultPartitionID resultPartitionId,\n+            int subPartitionIndex)\n+            throws IOException {\n+\n+        synchronized (requestLock) {\n+            if (subpartitionView == null) {\n+                // This call can trigger a notification we have to\n+                // schedule a separate task at the event loop that will\n+                // start consuming this. Otherwise the reference to the\n+                // view cannot be available in getNextBuffer().\n+                this.subpartitionView =\n+                        partitionProvider.createSubpartitionView(\n+                                resultPartitionId, subPartitionIndex, this);\n+            } else {\n+                throw new IllegalStateException(\"Subpartition already requested\");\n+            }\n+        }\n+\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public void addCredit(int creditDeltas) {\n+        numCreditsAvailable += creditDeltas;\n+    }\n+\n+    @Override\n+    public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;\n+        }\n+        subpartitionView.resumeConsumption();\n+    }\n+\n+    @Override\n+    public void acknowledgeAllRecordsProcessed() {\n+        subpartitionView.acknowledgeAllRecordsProcessed();\n+    }\n+\n+    @Override\n+    public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n+        this.isRegisteredAsAvailable = isRegisteredAvailable;\n+    }\n+\n+    @Override\n+    public boolean isRegisteredAsAvailable() {\n+        return isRegisteredAsAvailable;\n+    }\n+\n+    /**\n+     * Returns true only if the next buffer is an event or the reader has both available credits and\n+     * buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such\n+     *     that {@code getNextDataType(bufferAndBacklog) != NONE <=>\n+     *     AvailabilityWithBacklog#isAvailable()}!\n+     */\n+    @Override\n+    public ResultSubpartitionView.AvailabilityWithBacklog getAvailabilityAndBacklog() {\n+        return subpartitionView.getAvailabilityAndBacklog(numCreditsAvailable);\n+    }\n+\n+    /**\n+     * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next\n+     * buffer in line.\n+     *\n+     * <p>Returns the next data type only if the next buffer is an event or the reader has both\n+     * available credits and buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getAvailabilityAndBacklog()}, such that\n+     *     {@code getNextDataType(bufferAndBacklog) != NONE <=>\n+     *     AvailabilityWithBacklog#isAvailable()}!\n+     * @param bufferAndBacklog current buffer and backlog including information about the next\n+     *     buffer\n+     * @return the next data type if the next buffer can be pulled immediately or {@link\n+     *     Buffer.DataType#NONE}\n+     */\n+    private Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n+        final Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+        if (numCreditsAvailable > 0 || nextDataType.isEvent()) {\n+            return nextDataType;\n+        }\n+        return Buffer.DataType.NONE;\n+    }\n+\n+    @Override\n+    public InputChannelID getReceiverId() {\n+        return receiverId;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumCreditsAvailable() {\n+        return numCreditsAvailable;\n+    }\n+\n+    @VisibleForTesting\n+    ResultSubpartitionView.AvailabilityWithBacklog hasBuffersAvailable() {\n+        return subpartitionView.getAvailabilityAndBacklog(Integer.MAX_VALUE);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BufferAndAvailability getNextBuffer() throws IOException {\n+        BufferAndBacklog next = subpartitionView.getNextBuffer();\n+        if (next != null) {\n+            if (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n+                throw new IllegalStateException(\"no credit available\");\n+            }\n+\n+            final Buffer.DataType nextDataType = getNextDataType(next);\n+            return new BufferAndAvailability(\n+                    next.buffer(), nextDataType, next.buffersInBacklog(), next.getSequenceNumber());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        return subpartitionView.isReleased();\n+    }\n+\n+    @Override\n+    public Throwable getFailureCause() {\n+        return subpartitionView.getFailureCause();\n+    }\n+\n+    @Override\n+    public void releaseAllResources() throws IOException {\n+        subpartitionView.releaseAllResources();\n+    }\n+\n+    @Override\n+    public void notifyDataAvailable() {\n+        requestQueue.notifyReaderNonEmpty(this);\n+    }\n+\n+    @Override\n+    public void notifyPriorityEvent(int prioritySequenceNumber) {\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CreditBasedSequenceNumberingViewReader{\"\n+                + \"requestLock=\"\n+                + requestLock\n+                + \", receiverId=\"\n+                + receiverId\n+                + \", numCreditsAvailable=\"\n+                + numCreditsAvailable\n+                + \", isRegisteredAsAvailable=\"\n+                + isRegisteredAsAvailable\n+                + '}';\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg4NDU1MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422884550", "body": "We can also avoid introducing `nullable` buffer by this comment https://github.com/apache/flink/pull/11877/files#r422847423", "bodyText": "We can also avoid introducing nullable buffer by this comment https://github.com/apache/flink/pull/11877/files#r422847423", "bodyHTML": "<p dir=\"auto\">We can also avoid introducing <code>nullable</code> buffer by this comment <a href=\"https://github.com/apache/flink/pull/11877/files#r422847423\">https://github.com/apache/flink/pull/11877/files#r422847423</a></p>", "author": "zhijiangW", "createdAt": "2020-05-11T08:51:01Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java", "diffHunk": "@@ -305,19 +311,18 @@ protected CheckpointBarrier parseCheckpointBarrierOrNull(Buffer buffer) throws I\n \n \t/**\n \t * A combination of a {@link Buffer} and a flag indicating availability of further buffers,\n-\t * and the backlog length indicating how many non-event buffers are available in the\n-\t * subpartition.\n+\t * and the backlog length indicating how many credits the subpartition.\n \t */\n \tpublic static final class BufferAndAvailability {\n \n \t\tprivate final Buffer buffer;\n \t\tprivate final boolean moreAvailable;\n-\t\tprivate final int buffersInBacklog;\n+\t\tprivate final int backlog;\n \n-\t\tpublic BufferAndAvailability(Buffer buffer, boolean moreAvailable, int buffersInBacklog) {\n-\t\t\tthis.buffer = checkNotNull(buffer);\n+\t\tpublic BufferAndAvailability(@Nullable Buffer buffer, boolean moreAvailable, int backlog) {", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\nindex 05d2f546f4e..ef701809bd8 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\n", "chunk": "@@ -310,19 +311,16 @@ public abstract class InputChannel {\n \t}\n \n \t/**\n-\t * A combination of a {@link Buffer} and a flag indicating availability of further buffers,\n-\t * and the backlog length indicating how many credits the subpartition.\n+\t * A combination of a {@link Buffer} and a flag indicating availability of further buffers.\n \t */\n \tpublic static final class BufferAndAvailability {\n \n \t\tprivate final Buffer buffer;\n \t\tprivate final boolean moreAvailable;\n-\t\tprivate final int backlog;\n \n-\t\tpublic BufferAndAvailability(@Nullable Buffer buffer, boolean moreAvailable, int backlog) {\n-\t\t\tthis.buffer = buffer;\n+\t\tpublic BufferAndAvailability(Buffer buffer, boolean moreAvailable) {\n+\t\t\tthis.buffer = checkNotNull(buffer);\n \t\t\tthis.moreAvailable = moreAvailable;\n-\t\t\tthis.backlog = backlog;\n \t\t}\n \n \t\tpublic Buffer buffer() {\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\nindex ef701809bd8..9fb2604c500 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\n", "chunk": "@@ -44,291 +40,315 @@ import static org.apache.flink.util.Preconditions.checkNotNull;\n  * An input channel consumes a single {@link ResultSubpartitionView}.\n  *\n  * <p>For each channel, the consumption life cycle is as follows:\n+ *\n  * <ol>\n- * <li>{@link #requestSubpartition(int)}</li>\n- * <li>{@link #getNextBuffer()}</li>\n- * <li>{@link #releaseAllResources()}</li>\n+ *   <li>{@link #requestSubpartition(int)}\n+ *   <li>{@link #getNextBuffer()}\n+ *   <li>{@link #releaseAllResources()}\n  * </ol>\n  */\n public abstract class InputChannel {\n+    /** The info of the input channel to identify it globally within a task. */\n+    protected final InputChannelInfo channelInfo;\n \n-\t/** The info of the input channel to identify it globally within a task. */\n-\tprotected final InputChannelInfo channelInfo;\n-\n-\tprotected final ResultPartitionID partitionId;\n-\n-\tprotected final SingleInputGate inputGate;\n-\n-\t// - Asynchronous error notification --------------------------------------\n+    protected final ResultPartitionID partitionId;\n \n-\tprivate final AtomicReference<Throwable> cause = new AtomicReference<Throwable>();\n+    protected final SingleInputGate inputGate;\n \n-\t// - Partition request backoff --------------------------------------------\n+    // - Asynchronous error notification --------------------------------------\n \n-\t/** The initial backoff (in ms). */\n-\tprotected final int initialBackoff;\n+    private final AtomicReference<Throwable> cause = new AtomicReference<Throwable>();\n \n-\t/** The maximum backoff (in ms). */\n-\tprotected final int maxBackoff;\n-\n-\tprotected final Counter numBytesIn;\n-\n-\tprotected final Counter numBuffersIn;\n-\n-\t/** The current backoff (in ms). */\n-\tprivate int currentBackoff;\n-\n-\tprotected InputChannel(\n-\t\t\tSingleInputGate inputGate,\n-\t\t\tint channelIndex,\n-\t\t\tResultPartitionID partitionId,\n-\t\t\tint initialBackoff,\n-\t\t\tint maxBackoff,\n-\t\t\tCounter numBytesIn,\n-\t\t\tCounter numBuffersIn) {\n-\n-\t\tcheckArgument(channelIndex >= 0);\n-\n-\t\tint initial = initialBackoff;\n-\t\tint max = maxBackoff;\n-\n-\t\tcheckArgument(initial >= 0 && initial <= max);\n-\n-\t\tthis.inputGate = checkNotNull(inputGate);\n-\t\tthis.channelInfo = new InputChannelInfo(inputGate.getGateIndex(), channelIndex);\n-\t\tthis.partitionId = checkNotNull(partitionId);\n-\n-\t\tthis.initialBackoff = initial;\n-\t\tthis.maxBackoff = max;\n-\t\tthis.currentBackoff = initial == 0 ? -1 : 0;\n-\n-\t\tthis.numBytesIn = numBytesIn;\n-\t\tthis.numBuffersIn = numBuffersIn;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Properties\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Returns the index of this channel within its {@link SingleInputGate}.\n-\t */\n-\tpublic int getChannelIndex() {\n-\t\treturn channelInfo.getInputChannelIdx();\n-\t}\n-\n-\t/**\n-\t * Returns the info of this channel, which uniquely identifies the channel in respect to its operator instance.\n-\t */\n-\tpublic InputChannelInfo getChannelInfo() {\n-\t\treturn channelInfo;\n-\t}\n-\n-\tpublic ResultPartitionID getPartitionId() {\n-\t\treturn partitionId;\n-\t}\n-\n-\t/**\n-\t * Notifies that a checkpoint barrier event is received.\n-\t */\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t}\n-\n-\t/**\n-\t * After sending a {@link org.apache.flink.runtime.io.network.api.CheckpointBarrier} of\n-\t * exactly-once mode, the upstream will be blocked and become unavailable. This method\n-\t * tries to unblock the corresponding upstream and resume data consumption.\n-\t */\n-\tpublic abstract void resumeConsumption();\n-\n-\t/**\n-\t * Notifies the owning {@link SingleInputGate} that this channel became non-empty.\n-\t *\n-\t * <p>This is guaranteed to be called only when a Buffer was added to a previously\n-\t * empty input channel. The notion of empty is atomically consistent with the flag\n-\t * {@link BufferAndAvailability#moreAvailable()} when polling the next buffer\n-\t * from this channel.\n-\t *\n-\t * <p><b>Note:</b> When the input channel observes an exception, this\n-\t * method is called regardless of whether the channel was empty before. That ensures\n-\t * that the parent InputGate will always be notified about the exception.\n-\t */\n-\tprotected void notifyChannelNonEmpty() {\n-\t\tinputGate.notifyChannelNonEmpty(this);\n-\t}\n-\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n-\t}\n-\n-\tprotected void notifyBufferAvailable(int numAvailableBuffers) {\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests the queue with the specified index of the source intermediate\n-\t * result partition.\n-\t *\n-\t * <p>The queue index to request depends on which sub task the channel belongs\n-\t * to and is specified by the consumer of this channel.\n-\t */\n-\tabstract void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;\n-\n-\t/**\n-\t * Returns the next buffer from the consumed subpartition or {@code Optional.empty()} if there is no data to return.\n-\t */\n-\tabstract Optional<BufferAndAvailability> getNextBuffer() throws IOException, InterruptedException;\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Sends a {@link TaskEvent} back to the task producing the consumed result partition.\n-\t *\n-\t * <p><strong>Important</strong>: The producing task has to be running to receive backwards events.\n-\t * This means that the result type needs to be pipelined and the task logic has to ensure that\n-\t * the producer will wait for all backwards events. Otherwise, this will lead to an Exception\n-\t * at runtime.\n-\t */\n-\tabstract void sendTaskEvent(TaskEvent event) throws IOException;\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\tabstract boolean isReleased();\n-\n-\t/**\n-\t * Releases all resources of the channel.\n-\t */\n-\tabstract void releaseAllResources() throws IOException;\n-\n-\t// ------------------------------------------------------------------------\n-\t// Error notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Checks for an error and rethrows it if one was reported.\n-\t *\n-\t * <p>Note: Any {@link PartitionException} instances should not be transformed\n-\t * and make sure they are always visible in task failure cause.\n-\t */\n-\tprotected void checkError() throws IOException {\n-\t\tfinal Throwable t = cause.get();\n-\n-\t\tif (t != null) {\n-\t\t\tif (t instanceof CancelTaskException) {\n-\t\t\t\tthrow (CancelTaskException) t;\n-\t\t\t}\n-\t\t\tif (t instanceof IOException) {\n-\t\t\t\tthrow (IOException) t;\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tthrow new IOException(t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Atomically sets an error for this channel and notifies the input gate about available data to\n-\t * trigger querying this channel by the task thread.\n-\t */\n-\tprotected void setError(Throwable cause) {\n-\t\tif (this.cause.compareAndSet(null, checkNotNull(cause))) {\n-\t\t\t// Notify the input gate.\n-\t\t\tnotifyChannelNonEmpty();\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Partition request exponential backoff\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Returns the current backoff in ms.\n-\t */\n-\tprotected int getCurrentBackoff() {\n-\t\treturn currentBackoff <= 0 ? 0 : currentBackoff;\n-\t}\n-\n-\t/**\n-\t * Increases the current backoff and returns whether the operation was successful.\n-\t *\n-\t * @return <code>true</code>, iff the operation was successful. Otherwise, <code>false</code>.\n-\t */\n-\tprotected boolean increaseBackoff() {\n-\t\t// Backoff is disabled\n-\t\tif (currentBackoff < 0) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\t// This is the first time backing off\n-\t\tif (currentBackoff == 0) {\n-\t\t\tcurrentBackoff = initialBackoff;\n-\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\t// Continue backing off\n-\t\telse if (currentBackoff < maxBackoff) {\n-\t\t\tcurrentBackoff = Math.min(currentBackoff * 2, maxBackoff);\n-\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\t// Reached maximum backoff\n-\t\treturn false;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Metric related method\n-\t// ------------------------------------------------------------------------\n-\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn 0;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Parses the buffer as an event and returns the {@link CheckpointBarrier} if the event is indeed a barrier or\n-\t * returns null in all other cases.\n-\t */\n-\t@Nullable\n-\tprotected CheckpointBarrier parseCheckpointBarrierOrNull(Buffer buffer) throws IOException {\n-\t\tif (buffer.isBuffer()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tAbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n-\t\t// reset the buffer because it would be deserialized again in SingleInputGate while getting next buffer.\n-\t\t// we can further improve to avoid double deserialization in the future.\n-\t\tbuffer.setReaderIndex(0);\n-\t\treturn event.getClass() == CheckpointBarrier.class ? (CheckpointBarrier) event : null;\n-\t}\n-\n-\t/**\n-\t * A combination of a {@link Buffer} and a flag indicating availability of further buffers.\n-\t */\n-\tpublic static final class BufferAndAvailability {\n-\n-\t\tprivate final Buffer buffer;\n-\t\tprivate final boolean moreAvailable;\n-\n-\t\tpublic BufferAndAvailability(Buffer buffer, boolean moreAvailable) {\n-\t\t\tthis.buffer = checkNotNull(buffer);\n-\t\t\tthis.moreAvailable = moreAvailable;\n-\t\t}\n-\n-\t\tpublic Buffer buffer() {\n-\t\t\treturn buffer;\n-\t\t}\n-\n-\t\tpublic boolean moreAvailable() {\n-\t\t\treturn moreAvailable;\n-\t\t}\n-\t}\n+    // - Partition request backoff --------------------------------------------\n+\n+    /** The initial backoff (in ms). */\n+    protected final int initialBackoff;\n+\n+    /** The maximum backoff (in ms). */\n+    protected final int maxBackoff;\n+\n+    protected final Counter numBytesIn;\n+\n+    protected final Counter numBuffersIn;\n+\n+    /** The current backoff (in ms). */\n+    private int currentBackoff;\n+\n+    protected InputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            int initialBackoff,\n+            int maxBackoff,\n+            Counter numBytesIn,\n+            Counter numBuffersIn) {\n+\n+        checkArgument(channelIndex >= 0);\n+\n+        int initial = initialBackoff;\n+        int max = maxBackoff;\n+\n+        checkArgument(initial >= 0 && initial <= max);\n+\n+        this.inputGate = checkNotNull(inputGate);\n+        this.channelInfo = new InputChannelInfo(inputGate.getGateIndex(), channelIndex);\n+        this.partitionId = checkNotNull(partitionId);\n+\n+        this.initialBackoff = initial;\n+        this.maxBackoff = max;\n+        this.currentBackoff = initial == 0 ? -1 : 0;\n+\n+        this.numBytesIn = numBytesIn;\n+        this.numBuffersIn = numBuffersIn;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Properties\n+    // ------------------------------------------------------------------------\n+\n+    /** Returns the index of this channel within its {@link SingleInputGate}. */\n+    public int getChannelIndex() {\n+        return channelInfo.getInputChannelIdx();\n+    }\n+\n+    /**\n+     * Returns the info of this channel, which uniquely identifies the channel in respect to its\n+     * operator instance.\n+     */\n+    public InputChannelInfo getChannelInfo() {\n+        return channelInfo;\n+    }\n+\n+    public ResultPartitionID getPartitionId() {\n+        return partitionId;\n+    }\n+\n+    /**\n+     * After sending a {@link org.apache.flink.runtime.io.network.api.CheckpointBarrier} of\n+     * exactly-once mode, the upstream will be blocked and become unavailable. This method tries to\n+     * unblock the corresponding upstream and resume data consumption.\n+     */\n+    public abstract void resumeConsumption() throws IOException;\n+\n+    /**\n+     * Notifies the owning {@link SingleInputGate} that this channel became non-empty.\n+     *\n+     * <p>This is guaranteed to be called only when a Buffer was added to a previously empty input\n+     * channel. The notion of empty is atomically consistent with the flag {@link\n+     * BufferAndAvailability#moreAvailable()} when polling the next buffer from this channel.\n+     *\n+     * <p><b>Note:</b> When the input channel observes an exception, this method is called\n+     * regardless of whether the channel was empty before. That ensures that the parent InputGate\n+     * will always be notified about the exception.\n+     */\n+    protected void notifyChannelNonEmpty() {\n+        inputGate.notifyChannelNonEmpty(this);\n+    }\n+\n+    public void notifyPriorityEvent(int priorityBufferNumber) {\n+        inputGate.notifyPriorityEvent(this, priorityBufferNumber);\n+    }\n+\n+    protected void notifyBufferAvailable(int numAvailableBuffers) throws IOException {}\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Requests the queue with the specified index of the source intermediate result partition.\n+     *\n+     * <p>The queue index to request depends on which sub task the channel belongs to and is\n+     * specified by the consumer of this channel.\n+     */\n+    abstract void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException;\n+\n+    /**\n+     * Returns the next buffer from the consumed subpartition or {@code Optional.empty()} if there\n+     * is no data to return.\n+     */\n+    abstract Optional<BufferAndAvailability> getNextBuffer()\n+            throws IOException, InterruptedException;\n+\n+    /**\n+     * Called by task thread when checkpointing is started (e.g., any input channel received\n+     * barrier).\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {}\n+\n+    /** Called by task thread on cancel/complete to clean-up temporary data. */\n+    public void checkpointStopped(long checkpointId) {}\n+\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {}\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Sends a {@link TaskEvent} back to the task producing the consumed result partition.\n+     *\n+     * <p><strong>Important</strong>: The producing task has to be running to receive backwards\n+     * events. This means that the result type needs to be pipelined and the task logic has to\n+     * ensure that the producer will wait for all backwards events. Otherwise, this will lead to an\n+     * Exception at runtime.\n+     */\n+    abstract void sendTaskEvent(TaskEvent event) throws IOException;\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    abstract boolean isReleased();\n+\n+    /** Releases all resources of the channel. */\n+    abstract void releaseAllResources() throws IOException;\n+\n+    // ------------------------------------------------------------------------\n+    // Error notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Checks for an error and rethrows it if one was reported.\n+     *\n+     * <p>Note: Any {@link PartitionException} instances should not be transformed and make sure\n+     * they are always visible in task failure cause.\n+     */\n+    protected void checkError() throws IOException {\n+        final Throwable t = cause.get();\n+\n+        if (t != null) {\n+            if (t instanceof CancelTaskException) {\n+                throw (CancelTaskException) t;\n+            }\n+            if (t instanceof IOException) {\n+                throw (IOException) t;\n+            } else {\n+                throw new IOException(t);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Atomically sets an error for this channel and notifies the input gate about available data to\n+     * trigger querying this channel by the task thread.\n+     */\n+    protected void setError(Throwable cause) {\n+        if (this.cause.compareAndSet(null, checkNotNull(cause))) {\n+            // Notify the input gate.\n+            notifyChannelNonEmpty();\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Partition request exponential backoff\n+    // ------------------------------------------------------------------------\n+\n+    /** Returns the current backoff in ms. */\n+    protected int getCurrentBackoff() {\n+        return currentBackoff <= 0 ? 0 : currentBackoff;\n+    }\n+\n+    /**\n+     * Increases the current backoff and returns whether the operation was successful.\n+     *\n+     * @return <code>true</code>, iff the operation was successful. Otherwise, <code>false</code>.\n+     */\n+    protected boolean increaseBackoff() {\n+        // Backoff is disabled\n+        if (currentBackoff < 0) {\n+            return false;\n+        }\n+\n+        // This is the first time backing off\n+        if (currentBackoff == 0) {\n+            currentBackoff = initialBackoff;\n+\n+            return true;\n+        }\n+\n+        // Continue backing off\n+        else if (currentBackoff < maxBackoff) {\n+            currentBackoff = Math.min(currentBackoff * 2, maxBackoff);\n+\n+            return true;\n+        }\n+\n+        // Reached maximum backoff\n+        return false;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Metric related method\n+    // ------------------------------------------------------------------------\n+\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return 0;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * A combination of a {@link Buffer} and a flag indicating availability of further buffers, and\n+     * the backlog length indicating how many non-event buffers are available in the subpartition.\n+     */\n+    public static final class BufferAndAvailability {\n+\n+        private final Buffer buffer;\n+        private final Buffer.DataType nextDataType;\n+        private final int buffersInBacklog;\n+        private final int sequenceNumber;\n+\n+        public BufferAndAvailability(\n+                Buffer buffer,\n+                Buffer.DataType nextDataType,\n+                int buffersInBacklog,\n+                int sequenceNumber) {\n+            this.buffer = checkNotNull(buffer);\n+            this.nextDataType = checkNotNull(nextDataType);\n+            this.buffersInBacklog = buffersInBacklog;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        public Buffer buffer() {\n+            return buffer;\n+        }\n+\n+        public boolean moreAvailable() {\n+            return nextDataType != Buffer.DataType.NONE;\n+        }\n+\n+        public boolean morePriorityEvents() {\n+            return nextDataType.hasPriority();\n+        }\n+\n+        public int buffersInBacklog() {\n+            return buffersInBacklog;\n+        }\n+\n+        public boolean hasPriority() {\n+            return buffer.getDataType().hasPriority();\n+        }\n+\n+        public int getSequenceNumber() {\n+            return sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"BufferAndAvailability{\"\n+                    + \"buffer=\"\n+                    + buffer\n+                    + \", nextDataType=\"\n+                    + nextDataType\n+                    + \", buffersInBacklog=\"\n+                    + buffersInBacklog\n+                    + \", sequenceNumber=\"\n+                    + sequenceNumber\n+                    + '}';\n+        }\n+    }\n+\n+    void setup() throws IOException {}\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\nindex 05d2f546f4e..474d1924fcf 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\n", "chunk": "@@ -45,296 +40,321 @@ import static org.apache.flink.util.Preconditions.checkNotNull;\n  * An input channel consumes a single {@link ResultSubpartitionView}.\n  *\n  * <p>For each channel, the consumption life cycle is as follows:\n+ *\n  * <ol>\n- * <li>{@link #requestSubpartition(int)}</li>\n- * <li>{@link #getNextBuffer()}</li>\n- * <li>{@link #releaseAllResources()}</li>\n+ *   <li>{@link #requestSubpartition(int)}\n+ *   <li>{@link #getNextBuffer()}\n+ *   <li>{@link #releaseAllResources()}\n  * </ol>\n  */\n public abstract class InputChannel {\n+    /** The info of the input channel to identify it globally within a task. */\n+    protected final InputChannelInfo channelInfo;\n+\n+    protected final ResultPartitionID partitionId;\n+\n+    protected final SingleInputGate inputGate;\n \n-\t/** The info of the input channel to identify it globally within a task. */\n-\tprotected final InputChannelInfo channelInfo;\n-\n-\tprotected final ResultPartitionID partitionId;\n+    // - Asynchronous error notification --------------------------------------\n \n-\tprotected final SingleInputGate inputGate;\n-\n-\t// - Asynchronous error notification --------------------------------------\n+    private final AtomicReference<Throwable> cause = new AtomicReference<Throwable>();\n \n-\tprivate final AtomicReference<Throwable> cause = new AtomicReference<Throwable>();\n-\n-\t// - Partition request backoff --------------------------------------------\n+    // - Partition request backoff --------------------------------------------\n \n-\t/** The initial backoff (in ms). */\n-\tprivate final int initialBackoff;\n-\n-\t/** The maximum backoff (in ms). */\n-\tprivate final int maxBackoff;\n-\n-\tprotected final Counter numBytesIn;\n-\n-\tprotected final Counter numBuffersIn;\n-\n-\t/** The current backoff (in ms). */\n-\tprivate int currentBackoff;\n-\n-\tprotected InputChannel(\n-\t\t\tSingleInputGate inputGate,\n-\t\t\tint channelIndex,\n-\t\t\tResultPartitionID partitionId,\n-\t\t\tint initialBackoff,\n-\t\t\tint maxBackoff,\n-\t\t\tCounter numBytesIn,\n-\t\t\tCounter numBuffersIn) {\n-\n-\t\tcheckArgument(channelIndex >= 0);\n-\n-\t\tint initial = initialBackoff;\n-\t\tint max = maxBackoff;\n-\n-\t\tcheckArgument(initial >= 0 && initial <= max);\n-\n-\t\tthis.inputGate = checkNotNull(inputGate);\n-\t\tthis.channelInfo = new InputChannelInfo(inputGate.getGateIndex(), channelIndex);\n-\t\tthis.partitionId = checkNotNull(partitionId);\n-\n-\t\tthis.initialBackoff = initial;\n-\t\tthis.maxBackoff = max;\n-\t\tthis.currentBackoff = initial == 0 ? -1 : 0;\n-\n-\t\tthis.numBytesIn = numBytesIn;\n-\t\tthis.numBuffersIn = numBuffersIn;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Properties\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Returns the index of this channel within its {@link SingleInputGate}.\n-\t */\n-\tpublic int getChannelIndex() {\n-\t\treturn channelInfo.getInputChannelIdx();\n-\t}\n-\n-\t/**\n-\t * Returns the info of this channel, which uniquely identifies the channel in respect to its operator instance.\n-\t */\n-\tpublic InputChannelInfo getChannelInfo() {\n-\t\treturn channelInfo;\n-\t}\n-\n-\tpublic ResultPartitionID getPartitionId() {\n-\t\treturn partitionId;\n-\t}\n-\n-\t/**\n-\t * Notifies that a checkpoint barrier event is received.\n-\t */\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t}\n-\n-\t/**\n-\t * After sending a {@link org.apache.flink.runtime.io.network.api.CheckpointBarrier} of\n-\t * exactly-once mode, the upstream will be blocked and become unavailable. This method\n-\t * tries to unblock the corresponding upstream and resume data consumption.\n-\t */\n-\tpublic abstract void resumeConsumption();\n-\n-\t/**\n-\t * Notifies the owning {@link SingleInputGate} that this channel became non-empty.\n-\t *\n-\t * <p>This is guaranteed to be called only when a Buffer was added to a previously\n-\t * empty input channel. The notion of empty is atomically consistent with the flag\n-\t * {@link BufferAndAvailability#moreAvailable()} when polling the next buffer\n-\t * from this channel.\n-\t *\n-\t * <p><b>Note:</b> When the input channel observes an exception, this\n-\t * method is called regardless of whether the channel was empty before. That ensures\n-\t * that the parent InputGate will always be notified about the exception.\n-\t */\n-\tprotected void notifyChannelNonEmpty() {\n-\t\tinputGate.notifyChannelNonEmpty(this);\n-\t}\n-\n-\tpublic List<Buffer> requestInflightBuffers(long checkpointId) throws IOException {\n-\t\treturn Collections.emptyList();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests the queue with the specified index of the source intermediate\n-\t * result partition.\n-\t *\n-\t * <p>The queue index to request depends on which sub task the channel belongs\n-\t * to and is specified by the consumer of this channel.\n-\t */\n-\tabstract void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;\n-\n-\t/**\n-\t * Returns the next buffer from the consumed subpartition or {@code Optional.empty()} if there is no data to return.\n-\t */\n-\tabstract Optional<BufferAndAvailability> getNextBuffer() throws IOException, InterruptedException;\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Sends a {@link TaskEvent} back to the task producing the consumed result partition.\n-\t *\n-\t * <p><strong>Important</strong>: The producing task has to be running to receive backwards events.\n-\t * This means that the result type needs to be pipelined and the task logic has to ensure that\n-\t * the producer will wait for all backwards events. Otherwise, this will lead to an Exception\n-\t * at runtime.\n-\t */\n-\tabstract void sendTaskEvent(TaskEvent event) throws IOException;\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\tabstract boolean isReleased();\n-\n-\t/**\n-\t * Releases all resources of the channel.\n-\t */\n-\tabstract void releaseAllResources() throws IOException;\n-\n-\t// ------------------------------------------------------------------------\n-\t// Error notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Checks for an error and rethrows it if one was reported.\n-\t *\n-\t * <p>Note: Any {@link PartitionException} instances should not be transformed\n-\t * and make sure they are always visible in task failure cause.\n-\t */\n-\tprotected void checkError() throws IOException {\n-\t\tfinal Throwable t = cause.get();\n-\n-\t\tif (t != null) {\n-\t\t\tif (t instanceof CancelTaskException) {\n-\t\t\t\tthrow (CancelTaskException) t;\n-\t\t\t}\n-\t\t\tif (t instanceof IOException) {\n-\t\t\t\tthrow (IOException) t;\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tthrow new IOException(t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Atomically sets an error for this channel and notifies the input gate about available data to\n-\t * trigger querying this channel by the task thread.\n-\t */\n-\tprotected void setError(Throwable cause) {\n-\t\tif (this.cause.compareAndSet(null, checkNotNull(cause))) {\n-\t\t\t// Notify the input gate.\n-\t\t\tnotifyChannelNonEmpty();\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Partition request exponential backoff\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Returns the current backoff in ms.\n-\t */\n-\tprotected int getCurrentBackoff() {\n-\t\treturn currentBackoff <= 0 ? 0 : currentBackoff;\n-\t}\n-\n-\t/**\n-\t * Increases the current backoff and returns whether the operation was successful.\n-\t *\n-\t * @return <code>true</code>, iff the operation was successful. Otherwise, <code>false</code>.\n-\t */\n-\tprotected boolean increaseBackoff() {\n-\t\t// Backoff is disabled\n-\t\tif (currentBackoff < 0) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\t// This is the first time backing off\n-\t\tif (currentBackoff == 0) {\n-\t\t\tcurrentBackoff = initialBackoff;\n-\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\t// Continue backing off\n-\t\telse if (currentBackoff < maxBackoff) {\n-\t\t\tcurrentBackoff = Math.min(currentBackoff * 2, maxBackoff);\n-\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\t// Reached maximum backoff\n-\t\treturn false;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Metric related method\n-\t// ------------------------------------------------------------------------\n-\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn 0;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Parses the buffer as an event and returns the {@link CheckpointBarrier} if the event is indeed a barrier or\n-\t * returns null in all other cases.\n-\t */\n-\t@Nullable\n-\tprotected CheckpointBarrier parseCheckpointBarrierOrNull(Buffer buffer) throws IOException {\n-\t\tif (buffer.isBuffer()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tAbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n-\t\t// reset the buffer because it would be deserialized again in SingleInputGate while getting next buffer.\n-\t\t// we can further improve to avoid double deserialization in the future.\n-\t\tbuffer.setReaderIndex(0);\n-\t\treturn event.getClass() == CheckpointBarrier.class ? (CheckpointBarrier) event : null;\n-\t}\n-\n-\t/**\n-\t * A combination of a {@link Buffer} and a flag indicating availability of further buffers,\n-\t * and the backlog length indicating how many credits the subpartition.\n-\t */\n-\tpublic static final class BufferAndAvailability {\n-\n-\t\tprivate final Buffer buffer;\n-\t\tprivate final boolean moreAvailable;\n-\t\tprivate final int backlog;\n-\n-\t\tpublic BufferAndAvailability(@Nullable Buffer buffer, boolean moreAvailable, int backlog) {\n-\t\t\tthis.buffer = buffer;\n-\t\t\tthis.moreAvailable = moreAvailable;\n-\t\t\tthis.backlog = backlog;\n-\t\t}\n-\n-\t\tpublic Buffer buffer() {\n-\t\t\treturn buffer;\n-\t\t}\n-\n-\t\tpublic boolean moreAvailable() {\n-\t\t\treturn moreAvailable;\n-\t\t}\n-\n-\t\tpublic int backlog() {\n-\t\t\treturn backlog;\n-\t\t}\n-\t}\n+    /** The initial backoff (in ms). */\n+    protected final int initialBackoff;\n+\n+    /** The maximum backoff (in ms). */\n+    protected final int maxBackoff;\n+\n+    protected final Counter numBytesIn;\n+\n+    protected final Counter numBuffersIn;\n+\n+    /** The current backoff (in ms). */\n+    private int currentBackoff;\n+\n+    protected InputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            int initialBackoff,\n+            int maxBackoff,\n+            Counter numBytesIn,\n+            Counter numBuffersIn) {\n+\n+        checkArgument(channelIndex >= 0);\n+\n+        int initial = initialBackoff;\n+        int max = maxBackoff;\n+\n+        checkArgument(initial >= 0 && initial <= max);\n+\n+        this.inputGate = checkNotNull(inputGate);\n+        this.channelInfo = new InputChannelInfo(inputGate.getGateIndex(), channelIndex);\n+        this.partitionId = checkNotNull(partitionId);\n+\n+        this.initialBackoff = initial;\n+        this.maxBackoff = max;\n+        this.currentBackoff = initial == 0 ? -1 : 0;\n+\n+        this.numBytesIn = numBytesIn;\n+        this.numBuffersIn = numBuffersIn;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Properties\n+    // ------------------------------------------------------------------------\n+\n+    /** Returns the index of this channel within its {@link SingleInputGate}. */\n+    public int getChannelIndex() {\n+        return channelInfo.getInputChannelIdx();\n+    }\n+\n+    /**\n+     * Returns the info of this channel, which uniquely identifies the channel in respect to its\n+     * operator instance.\n+     */\n+    public InputChannelInfo getChannelInfo() {\n+        return channelInfo;\n+    }\n+\n+    public ResultPartitionID getPartitionId() {\n+        return partitionId;\n+    }\n+\n+    /**\n+     * After sending a {@link org.apache.flink.runtime.io.network.api.CheckpointBarrier} of\n+     * exactly-once mode, the upstream will be blocked and become unavailable. This method tries to\n+     * unblock the corresponding upstream and resume data consumption.\n+     */\n+    public abstract void resumeConsumption() throws IOException;\n+\n+    /**\n+     * When received {@link org.apache.flink.runtime.io.network.api.EndOfUserRecordsEvent} from one\n+     * channel, it need to acknowledge after this event get processed.\n+     */\n+    public abstract void acknowledgeAllRecordsProcessed() throws IOException;\n+\n+    /**\n+     * Notifies the owning {@link SingleInputGate} that this channel became non-empty.\n+     *\n+     * <p>This is guaranteed to be called only when a Buffer was added to a previously empty input\n+     * channel. The notion of empty is atomically consistent with the flag {@link\n+     * BufferAndAvailability#moreAvailable()} when polling the next buffer from this channel.\n+     *\n+     * <p><b>Note:</b> When the input channel observes an exception, this method is called\n+     * regardless of whether the channel was empty before. That ensures that the parent InputGate\n+     * will always be notified about the exception.\n+     */\n+    protected void notifyChannelNonEmpty() {\n+        inputGate.notifyChannelNonEmpty(this);\n+    }\n+\n+    public void notifyPriorityEvent(int priorityBufferNumber) {\n+        inputGate.notifyPriorityEvent(this, priorityBufferNumber);\n+    }\n+\n+    protected void notifyBufferAvailable(int numAvailableBuffers) throws IOException {}\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Requests the queue with the specified index of the source intermediate result partition.\n+     *\n+     * <p>The queue index to request depends on which sub task the channel belongs to and is\n+     * specified by the consumer of this channel.\n+     */\n+    abstract void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException;\n+\n+    /**\n+     * Returns the next buffer from the consumed subpartition or {@code Optional.empty()} if there\n+     * is no data to return.\n+     */\n+    abstract Optional<BufferAndAvailability> getNextBuffer()\n+            throws IOException, InterruptedException;\n+\n+    /**\n+     * Called by task thread when checkpointing is started (e.g., any input channel received\n+     * barrier).\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {}\n+\n+    /** Called by task thread on cancel/complete to clean-up temporary data. */\n+    public void checkpointStopped(long checkpointId) {}\n+\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {}\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Sends a {@link TaskEvent} back to the task producing the consumed result partition.\n+     *\n+     * <p><strong>Important</strong>: The producing task has to be running to receive backwards\n+     * events. This means that the result type needs to be pipelined and the task logic has to\n+     * ensure that the producer will wait for all backwards events. Otherwise, this will lead to an\n+     * Exception at runtime.\n+     */\n+    abstract void sendTaskEvent(TaskEvent event) throws IOException;\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    abstract boolean isReleased();\n+\n+    /** Releases all resources of the channel. */\n+    abstract void releaseAllResources() throws IOException;\n+\n+    // ------------------------------------------------------------------------\n+    // Error notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Checks for an error and rethrows it if one was reported.\n+     *\n+     * <p>Note: Any {@link PartitionException} instances should not be transformed and make sure\n+     * they are always visible in task failure cause.\n+     */\n+    protected void checkError() throws IOException {\n+        final Throwable t = cause.get();\n+\n+        if (t != null) {\n+            if (t instanceof CancelTaskException) {\n+                throw (CancelTaskException) t;\n+            }\n+            if (t instanceof IOException) {\n+                throw (IOException) t;\n+            } else {\n+                throw new IOException(t);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Atomically sets an error for this channel and notifies the input gate about available data to\n+     * trigger querying this channel by the task thread.\n+     */\n+    protected void setError(Throwable cause) {\n+        if (this.cause.compareAndSet(null, checkNotNull(cause))) {\n+            // Notify the input gate.\n+            notifyChannelNonEmpty();\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Partition request exponential backoff\n+    // ------------------------------------------------------------------------\n+\n+    /** Returns the current backoff in ms. */\n+    protected int getCurrentBackoff() {\n+        return currentBackoff <= 0 ? 0 : currentBackoff;\n+    }\n+\n+    /**\n+     * Increases the current backoff and returns whether the operation was successful.\n+     *\n+     * @return <code>true</code>, iff the operation was successful. Otherwise, <code>false</code>.\n+     */\n+    protected boolean increaseBackoff() {\n+        // Backoff is disabled\n+        if (currentBackoff < 0) {\n+            return false;\n+        }\n+\n+        // This is the first time backing off\n+        if (currentBackoff == 0) {\n+            currentBackoff = initialBackoff;\n+\n+            return true;\n+        }\n+\n+        // Continue backing off\n+        else if (currentBackoff < maxBackoff) {\n+            currentBackoff = Math.min(currentBackoff * 2, maxBackoff);\n+\n+            return true;\n+        }\n+\n+        // Reached maximum backoff\n+        return false;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Metric related method\n+    // ------------------------------------------------------------------------\n+\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return 0;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * A combination of a {@link Buffer} and a flag indicating availability of further buffers, and\n+     * the backlog length indicating how many non-event buffers are available in the subpartition.\n+     */\n+    public static final class BufferAndAvailability {\n+\n+        private final Buffer buffer;\n+        private final Buffer.DataType nextDataType;\n+        private final int buffersInBacklog;\n+        private final int sequenceNumber;\n+\n+        public BufferAndAvailability(\n+                Buffer buffer,\n+                Buffer.DataType nextDataType,\n+                int buffersInBacklog,\n+                int sequenceNumber) {\n+            this.buffer = checkNotNull(buffer);\n+            this.nextDataType = checkNotNull(nextDataType);\n+            this.buffersInBacklog = buffersInBacklog;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        public Buffer buffer() {\n+            return buffer;\n+        }\n+\n+        public boolean moreAvailable() {\n+            return nextDataType != Buffer.DataType.NONE;\n+        }\n+\n+        public boolean morePriorityEvents() {\n+            return nextDataType.hasPriority();\n+        }\n+\n+        public int buffersInBacklog() {\n+            return buffersInBacklog;\n+        }\n+\n+        public boolean hasPriority() {\n+            return buffer.getDataType().hasPriority();\n+        }\n+\n+        public int getSequenceNumber() {\n+            return sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"BufferAndAvailability{\"\n+                    + \"buffer=\"\n+                    + buffer\n+                    + \", nextDataType=\"\n+                    + nextDataType\n+                    + \", buffersInBacklog=\"\n+                    + buffersInBacklog\n+                    + \", sequenceNumber=\"\n+                    + sequenceNumber\n+                    + '}';\n+        }\n+    }\n+\n+    void setup() throws IOException {}\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "4eea7bc9352134a06d2b207c9a94dd46a01c6132", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[FLINK-24657][runtime] Added metric of the total real size of input/output buffers queue"}, {"oid": "f4fd4f8bb66867821cb0f171218d85f8386b0897", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] Move consumedSubpartitionIndex from SingleInputGate to InputChannel"}, {"oid": "6398abcbff06b3e488a273144680f4838b4f1c92", "committedDate": "2023-06-09 22:48:37 +0800", "message": "[FLINK-31636][network] Introduce the NettyService framework"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg4OTAyMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422889022", "body": "I guess this check is not necessary or invalid.", "bodyText": "I guess this check is not necessary or invalid.", "bodyHTML": "<p dir=\"auto\">I guess this check is not necessary or invalid.</p>", "author": "zhijiangW", "createdAt": "2020-05-11T08:57:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -94,13 +99,27 @@ public void requestSubpartitionView(\n \t}\n \n \t@Override\n-\tpublic void addCredit(int creditDeltas) {\n+\tpublic boolean addCredit(int creditDeltas) {\n \t\tnumCreditsAvailable += creditDeltas;\n+\t\treturn shouldAnnounceBacklog();\n+\t}\n+\n+\t@Override\n+\tpublic boolean shouldAnnounceBacklog() {\n+\t\treturn initialCredit == 0 && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n \t}\n \n \t@Override\n-\tpublic void resumeConsumption() {\n+\tpublic boolean resumeConsumption(int availableCredit, int unfulfilledBacklog) {\n+\t\tif (initialCredit > 0) {\n+\t\t\tcheckState(numCreditsAvailable == availableCredit, \"Illegal number of available credit.\");", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 191e5471df4..cc9cadaa37a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -111,10 +112,6 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \n \t@Override\n \tpublic boolean resumeConsumption(int availableCredit, int unfulfilledBacklog) {\n-\t\tif (initialCredit > 0) {\n-\t\t\tcheckState(numCreditsAvailable == availableCredit, \"Illegal number of available credit.\");\n-\t\t}\n-\n \t\t// reset the available credit\n \t\tnumCreditsAvailable = availableCredit;\n \t\tsubpartitionView.resumeConsumption();\n", "next_change": {"commit": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex cc9cadaa37a..09ce436d1ec 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -100,23 +99,22 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t}\n \n \t@Override\n-\tpublic boolean addCredit(int creditDeltas) {\n+\tpublic void addCredit(int creditDeltas) throws Exception {\n \t\tnumCreditsAvailable += creditDeltas;\n-\t\treturn false;\n+\t\trequestQueue.enqueueAvailableReader(this, this::isAvailable);\n \t}\n \n \t@Override\n \tpublic boolean shouldAnnounceBacklog() {\n-\t\treturn initialCredit == 0 && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n+\t\treturn !withoutExclusiveCredits && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n \t}\n \n \t@Override\n-\tpublic boolean resumeConsumption(int availableCredit, int unfulfilledBacklog) {\n+\tpublic void resumeConsumption(int availableCredit, boolean hasUnfulfilledBacklog) throws Exception {\n \t\t// reset the available credit\n \t\tnumCreditsAvailable = availableCredit;\n \t\tsubpartitionView.resumeConsumption();\n-\n-\t\treturn shouldAnnounceBacklog() && unfulfilledBacklog == 0;\n+\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || !hasUnfulfilledBacklog && shouldAnnounceBacklog()));\n \t}\n \n \t@Override\n", "next_change": {"commit": "fb4c607a5c4780729143d458b1c7633adcba59bf", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 09ce436d1ec..0c03c332422 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -105,16 +105,16 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t}\n \n \t@Override\n-\tpublic boolean shouldAnnounceBacklog() {\n-\t\treturn !withoutExclusiveCredits && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n+\tpublic boolean shouldAnnounceBacklog(boolean hasUnfulfilledBacklog) {\n+\t\treturn !hasUnfulfilledBacklog && withoutExclusiveCredits && numCreditsAvailable == 0;\n \t}\n \n \t@Override\n-\tpublic void resumeConsumption(int availableCredit, boolean hasUnfulfilledBacklog) throws Exception {\n+\tpublic void resumeConsumption(int availableCredits, boolean hasUnfulfilledBacklog) throws Exception {\n \t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredit;\n+\t\tnumCreditsAvailable = availableCredits;\n \t\tsubpartitionView.resumeConsumption();\n-\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || !hasUnfulfilledBacklog && shouldAnnounceBacklog()));\n+\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || shouldAnnounceBacklog(hasUnfulfilledBacklog)));\n \t}\n \n \t@Override\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 0c03c332422..b1a8400b7a1 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -20,227 +20,225 @@ package org.apache.flink.runtime.io.network.netty;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.runtime.io.network.NetworkSequenceViewReader;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.AddBacklogMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.BufferResponseMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.ServerOutboundMessage;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n import org.apache.flink.runtime.io.network.partition.BufferAvailabilityListener;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionProvider;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputChannel.BufferAndAvailability;\n import org.apache.flink.runtime.io.network.partition.consumer.InputChannelID;\n import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n \n+import javax.annotation.Nullable;\n+\n import java.io.IOException;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n+\n /**\n  * Simple wrapper for the subpartition view used in the new network credit-based mode.\n  *\n- * <p>It also keeps track of available buffers and notifies the outbound\n- * handler about non-emptiness, similar to the {@link LocalInputChannel}.\n+ * <p>It also keeps track of available buffers and notifies the outbound handler about\n+ * non-emptiness, similar to the {@link LocalInputChannel}.\n  */\n-class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListener, NetworkSequenceViewReader {\n-\n-\tprivate final Object requestLock = new Object();\n-\n-\tprivate final InputChannelID receiverId;\n-\n-\tprivate final PartitionRequestQueue requestQueue;\n-\n-\tprivate final boolean withoutExclusiveCredits;\n-\n-\tprivate volatile ResultSubpartitionView subpartitionView;\n-\n-\t/**\n-\t * The status indicating whether this reader is already enqueued in the pipeline for transferring\n-\t * data or not.\n-\t *\n-\t * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n-\t * thread only since there is no synchronisation.\n-\t */\n-\tprivate boolean isRegisteredAsAvailable = false;\n-\n-\t/** The number of available buffers for holding data on the consumer side. */\n-\tprivate int numCreditsAvailable;\n-\n-\tprivate int sequenceNumber = -1;\n-\n-\tCreditBasedSequenceNumberingViewReader(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tint initialCredit,\n-\t\t\tPartitionRequestQueue requestQueue) {\n-\n-\t\tthis.receiverId = receiverId;\n-\t\tthis.numCreditsAvailable = initialCredit;\n-\t\tthis.requestQueue = requestQueue;\n-\t\tthis.withoutExclusiveCredits = initialCredit == 0;\n-\t}\n-\n-\t@Override\n-\tpublic void requestSubpartitionView(\n-\t\tResultPartitionProvider partitionProvider,\n-\t\tResultPartitionID resultPartitionId,\n-\t\tint subPartitionIndex) throws IOException {\n-\n-\t\tsynchronized (requestLock) {\n-\t\t\tif (subpartitionView == null) {\n-\t\t\t\t// This this call can trigger a notification we have to\n-\t\t\t\t// schedule a separate task at the event loop that will\n-\t\t\t\t// start consuming this. Otherwise the reference to the\n-\t\t\t\t// view cannot be available in getNextBuffer().\n-\t\t\t\tthis.subpartitionView = partitionProvider.createSubpartitionView(\n-\t\t\t\t\tresultPartitionId,\n-\t\t\t\t\tsubPartitionIndex,\n-\t\t\t\t\tthis);\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalStateException(\"Subpartition already requested\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void addCredit(int creditDeltas) throws Exception {\n-\t\tnumCreditsAvailable += creditDeltas;\n-\t\trequestQueue.enqueueAvailableReader(this, this::isAvailable);\n-\t}\n-\n-\t@Override\n-\tpublic boolean shouldAnnounceBacklog(boolean hasUnfulfilledBacklog) {\n-\t\treturn !hasUnfulfilledBacklog && withoutExclusiveCredits && numCreditsAvailable == 0;\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption(int availableCredits, boolean hasUnfulfilledBacklog) throws Exception {\n-\t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredits;\n-\t\tsubpartitionView.resumeConsumption();\n-\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || shouldAnnounceBacklog(hasUnfulfilledBacklog)));\n-\t}\n-\n-\t@Override\n-\tpublic void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n-\t\tthis.isRegisteredAsAvailable = isRegisteredAvailable;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRegisteredAsAvailable() {\n-\t\treturn isRegisteredAsAvailable;\n-\t}\n-\n-\t/**\n-\t * Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t */\n-\t@Override\n-\tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n-\t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n-\t}\n-\n-\t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n-\t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t *\n-\t * @param bufferAndBacklog\n-\t * \t\tcurrent buffer and backlog including information about the next buffer\n-\t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n-\t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic InputChannelID getReceiverId() {\n-\t\treturn receiverId;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumCreditsAvailable() {\n-\t\treturn numCreditsAvailable;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean hasBuffersAvailable() {\n-\t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\tprivate AddBacklogMessage getAddBacklogMessage() {\n-\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n-\t\tif (backlog > 0) {\n-\t\t\treturn new AddBacklogMessage(receiverId, backlog);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate BufferResponseMessage getBufferResponseMessage() throws IOException {\n-\t\tBufferAndBacklog next = subpartitionView.getNextBuffer();\n-\t\tif (next != null) {\n-\t\t\tsequenceNumber++;\n-\n-\t\t\tif (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n-\t\t\t\tthrow new IllegalStateException(\"no credit available\");\n-\t\t\t}\n-\n-\t\t\treturn new BufferResponseMessage(\n-\t\t\t\tnext.buffer(), receiverId, sequenceNumber, next.unannouncedBacklog(), isAvailable(next));\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic ServerOutboundMessage getNextMessage() throws IOException {\n-\t\t// BufferResponse is processed with higher priority compared with AddBacklog. There are three scenarios\n-\t\t// that we never announce backlog to the consumer through AddBacklog message:\n-\t\t// 1. We have exclusive credits which means unannounced backlog can be always carried by BufferResponse.\n-\t\t//    So AddBacklog message is never needed.\n-\t\t// 2. We already have available credits so we do not need to announce backlog to the consumer to request\n-\t\t//    new ones.\n-\t\t// 3. Next Buffer is an event which does not consume any credit. So we can just send the event and bring\n-\t\t//    the unannounced backlog with it.\n-\t\tif (!withoutExclusiveCredits || numCreditsAvailable > 0 || subpartitionView.isAvailable(0)) {\n-\t\t\treturn getBufferResponseMessage();\n-\t\t}\n-\t\treturn getAddBacklogMessage();\n-\t}\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn subpartitionView.isReleased();\n-\t}\n-\n-\t@Override\n-\tpublic Throwable getFailureCause() {\n-\t\treturn subpartitionView.getFailureCause();\n-\t}\n-\n-\t@Override\n-\tpublic void releaseAllResources() throws IOException {\n-\t\tsubpartitionView.releaseAllResources();\n-\t}\n-\n-\t@Override\n-\tpublic void notifyDataAvailable() {\n-\t\trequestQueue.notifyReaderNonEmpty(this);\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"CreditBasedSequenceNumberingViewReader{\" +\n-\t\t\t\"requestLock=\" + requestLock +\n-\t\t\t\", receiverId=\" + receiverId +\n-\t\t\t\", withoutExclusiveCredits=\" + withoutExclusiveCredits +\n-\t\t\t\", sequenceNumber=\" + sequenceNumber +\n-\t\t\t\", numCreditsAvailable=\" + numCreditsAvailable +\n-\t\t\t\", isRegisteredAsAvailable=\" + isRegisteredAsAvailable +\n-\t\t\t'}';\n-\t}\n+class CreditBasedSequenceNumberingViewReader\n+        implements BufferAvailabilityListener, NetworkSequenceViewReader {\n+\n+    private final Object requestLock = new Object();\n+\n+    private final InputChannelID receiverId;\n+\n+    private final PartitionRequestQueue requestQueue;\n+\n+    private final int initialCredit;\n+\n+    private volatile ResultSubpartitionView subpartitionView;\n+\n+    /**\n+     * The status indicating whether this reader is already enqueued in the pipeline for\n+     * transferring data or not.\n+     *\n+     * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n+     * thread only since there is no synchronisation.\n+     */\n+    private boolean isRegisteredAsAvailable = false;\n+\n+    /** The number of available buffers for holding data on the consumer side. */\n+    private int numCreditsAvailable;\n+\n+    CreditBasedSequenceNumberingViewReader(\n+            InputChannelID receiverId, int initialCredit, PartitionRequestQueue requestQueue) {\n+        checkArgument(initialCredit >= 0, \"Must be non-negative.\");\n+\n+        this.receiverId = receiverId;\n+        this.initialCredit = initialCredit;\n+        this.numCreditsAvailable = initialCredit;\n+        this.requestQueue = requestQueue;\n+    }\n+\n+    @Override\n+    public void requestSubpartitionView(\n+            ResultPartitionProvider partitionProvider,\n+            ResultPartitionID resultPartitionId,\n+            int subPartitionIndex)\n+            throws IOException {\n+\n+        synchronized (requestLock) {\n+            if (subpartitionView == null) {\n+                // This this call can trigger a notification we have to\n+                // schedule a separate task at the event loop that will\n+                // start consuming this. Otherwise the reference to the\n+                // view cannot be available in getNextBuffer().\n+                this.subpartitionView =\n+                        partitionProvider.createSubpartitionView(\n+                                resultPartitionId, subPartitionIndex, this);\n+            } else {\n+                throw new IllegalStateException(\"Subpartition already requested\");\n+            }\n+        }\n+\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public void addCredit(int creditDeltas) {\n+        numCreditsAvailable += creditDeltas;\n+    }\n+\n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n+    @Override\n+    public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;\n+        }\n+\n+        subpartitionView.resumeConsumption();\n+    }\n+\n+    @Override\n+    public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n+        this.isRegisteredAsAvailable = isRegisteredAvailable;\n+    }\n+\n+    @Override\n+    public boolean isRegisteredAsAvailable() {\n+        return isRegisteredAsAvailable;\n+    }\n+\n+    /**\n+     * Returns true only if the next buffer is an event or the reader has both available credits and\n+     * buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such\n+     *     that {@code getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n+     */\n+    @Override\n+    public boolean isAvailable() {\n+        return subpartitionView.isAvailable(numCreditsAvailable);\n+    }\n+\n+    /**\n+     * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next\n+     * buffer in line.\n+     *\n+     * <p>Returns the next data type only if the next buffer is an event or the reader has both\n+     * available credits and buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #isAvailable()}, such that {@code\n+     *     getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n+     * @param bufferAndBacklog current buffer and backlog including information about the next\n+     *     buffer\n+     * @return the next data type if the next buffer can be pulled immediately or {@link\n+     *     Buffer.DataType#NONE}\n+     */\n+    private Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n+        final Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+        if (numCreditsAvailable > 0 || nextDataType.isEvent()) {\n+            return nextDataType;\n+        }\n+        return Buffer.DataType.NONE;\n+    }\n+\n+    @Override\n+    public InputChannelID getReceiverId() {\n+        return receiverId;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumCreditsAvailable() {\n+        return numCreditsAvailable;\n+    }\n+\n+    @VisibleForTesting\n+    boolean hasBuffersAvailable() {\n+        return subpartitionView.isAvailable(Integer.MAX_VALUE);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BufferAndAvailability getNextBuffer() throws IOException {\n+        BufferAndBacklog next = subpartitionView.getNextBuffer();\n+        if (next != null) {\n+            if (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n+                throw new IllegalStateException(\"no credit available\");\n+            }\n+\n+            final Buffer.DataType nextDataType = getNextDataType(next);\n+            return new BufferAndAvailability(\n+                    next.buffer(), nextDataType, next.buffersInBacklog(), next.getSequenceNumber());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public int getRemainingBacklog() {\n+        return subpartitionView.getRemainingBacklog();\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        return subpartitionView.isReleased();\n+    }\n+\n+    @Override\n+    public Throwable getFailureCause() {\n+        return subpartitionView.getFailureCause();\n+    }\n+\n+    @Override\n+    public void releaseAllResources() throws IOException {\n+        subpartitionView.releaseAllResources();\n+    }\n+\n+    @Override\n+    public void notifyDataAvailable() {\n+        requestQueue.notifyReaderNonEmpty(this);\n+    }\n+\n+    @Override\n+    public void notifyPriorityEvent(int prioritySequenceNumber) {\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CreditBasedSequenceNumberingViewReader{\"\n+                + \"requestLock=\"\n+                + requestLock\n+                + \", receiverId=\"\n+                + receiverId\n+                + \", numCreditsAvailable=\"\n+                + numCreditsAvailable\n+                + \", isRegisteredAsAvailable=\"\n+                + isRegisteredAsAvailable\n+                + '}';\n+    }\n }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 191e5471df4..01d08d5f53c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -29,213 +30,216 @@ import org.apache.flink.runtime.io.network.partition.consumer.InputChannel.Buffe\n import org.apache.flink.runtime.io.network.partition.consumer.InputChannelID;\n import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n \n+import javax.annotation.Nullable;\n+\n import java.io.IOException;\n \n-import static org.apache.flink.util.Preconditions.checkState;\n+import static org.apache.flink.util.Preconditions.checkArgument;\n \n /**\n  * Simple wrapper for the subpartition view used in the new network credit-based mode.\n  *\n- * <p>It also keeps track of available buffers and notifies the outbound\n- * handler about non-emptiness, similar to the {@link LocalInputChannel}.\n+ * <p>It also keeps track of available buffers and notifies the outbound handler about\n+ * non-emptiness, similar to the {@link LocalInputChannel}.\n  */\n-class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListener, NetworkSequenceViewReader {\n-\n-\tprivate final Object requestLock = new Object();\n-\n-\tprivate final InputChannelID receiverId;\n-\n-\tprivate final PartitionRequestQueue requestQueue;\n-\n-\tprivate final int initialCredit;\n-\n-\tprivate volatile ResultSubpartitionView subpartitionView;\n-\n-\t/**\n-\t * The status indicating whether this reader is already enqueued in the pipeline for transferring\n-\t * data or not.\n-\t *\n-\t * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n-\t * thread only since there is no synchronisation.\n-\t */\n-\tprivate boolean isRegisteredAsAvailable = false;\n-\n-\t/** The number of available buffers for holding data on the consumer side. */\n-\tprivate int numCreditsAvailable;\n-\n-\tprivate int sequenceNumber = -1;\n-\n-\tCreditBasedSequenceNumberingViewReader(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tint initialCredit,\n-\t\t\tPartitionRequestQueue requestQueue) {\n-\n-\t\tthis.receiverId = receiverId;\n-\t\tthis.numCreditsAvailable = initialCredit;\n-\t\tthis.requestQueue = requestQueue;\n-\t\tthis.initialCredit = initialCredit;\n-\t}\n-\n-\t@Override\n-\tpublic void requestSubpartitionView(\n-\t\tResultPartitionProvider partitionProvider,\n-\t\tResultPartitionID resultPartitionId,\n-\t\tint subPartitionIndex) throws IOException {\n-\n-\t\tsynchronized (requestLock) {\n-\t\t\tif (subpartitionView == null) {\n-\t\t\t\t// This this call can trigger a notification we have to\n-\t\t\t\t// schedule a separate task at the event loop that will\n-\t\t\t\t// start consuming this. Otherwise the reference to the\n-\t\t\t\t// view cannot be available in getNextBuffer().\n-\t\t\t\tthis.subpartitionView = partitionProvider.createSubpartitionView(\n-\t\t\t\t\tresultPartitionId,\n-\t\t\t\t\tsubPartitionIndex,\n-\t\t\t\t\tthis);\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalStateException(\"Subpartition already requested\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic boolean addCredit(int creditDeltas) {\n-\t\tnumCreditsAvailable += creditDeltas;\n-\t\treturn shouldAnnounceBacklog();\n-\t}\n-\n-\t@Override\n-\tpublic boolean shouldAnnounceBacklog() {\n-\t\treturn initialCredit == 0 && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\t@Override\n-\tpublic boolean resumeConsumption(int availableCredit, int unfulfilledBacklog) {\n-\t\tif (initialCredit > 0) {\n-\t\t\tcheckState(numCreditsAvailable == availableCredit, \"Illegal number of available credit.\");\n-\t\t}\n-\n-\t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredit;\n-\t\tsubpartitionView.resumeConsumption();\n-\n-\t\treturn shouldAnnounceBacklog() && unfulfilledBacklog == 0;\n-\t}\n-\n-\t@Override\n-\tpublic void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n-\t\tthis.isRegisteredAsAvailable = isRegisteredAvailable;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRegisteredAsAvailable() {\n-\t\treturn isRegisteredAsAvailable;\n-\t}\n-\n-\t/**\n-\t * Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t */\n-\t@Override\n-\tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n-\t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n-\t}\n-\n-\t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n-\t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t *\n-\t * @param bufferAndBacklog\n-\t * \t\tcurrent buffer and backlog including information about the next buffer\n-\t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n-\t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic InputChannelID getReceiverId() {\n-\t\treturn receiverId;\n-\t}\n-\n-\t@Override\n-\tpublic int getSequenceNumber() {\n-\t\treturn sequenceNumber;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumCreditsAvailable() {\n-\t\treturn numCreditsAvailable;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean hasBuffersAvailable() {\n-\t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\t@Override\n-\tpublic BufferAndAvailability getNextBuffer() throws IOException {\n-\t\tif (numCreditsAvailable == 0 && initialCredit == 0 && !subpartitionView.isAvailable(0)) {\n-\t\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n-\t\t\tif (backlog > 0) {\n-\t\t\t\treturn new BufferAndAvailability(null, false, backlog);\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tBufferAndBacklog next = subpartitionView.getNextBuffer();\n-\t\tif (next != null) {\n-\t\t\tsequenceNumber++;\n-\n-\t\t\tif (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n-\t\t\t\tthrow new IllegalStateException(\"no credit available\");\n-\t\t\t}\n-\n-\t\t\treturn new BufferAndAvailability(\n-\t\t\t\tnext.buffer(), isAvailable(next), next.unannouncedBacklog());\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn subpartitionView.isReleased();\n-\t}\n-\n-\t@Override\n-\tpublic Throwable getFailureCause() {\n-\t\treturn subpartitionView.getFailureCause();\n-\t}\n-\n-\t@Override\n-\tpublic void releaseAllResources() throws IOException {\n-\t\tsubpartitionView.releaseAllResources();\n-\t}\n-\n-\t@Override\n-\tpublic void notifyDataAvailable() {\n-\t\trequestQueue.notifyReaderNonEmpty(this);\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"CreditBasedSequenceNumberingViewReader{\" +\n-\t\t\t\"requestLock=\" + requestLock +\n-\t\t\t\", receiverId=\" + receiverId +\n-\t\t\t\", initialCredit=\" + initialCredit +\n-\t\t\t\", sequenceNumber=\" + sequenceNumber +\n-\t\t\t\", numCreditsAvailable=\" + numCreditsAvailable +\n-\t\t\t\", isRegisteredAsAvailable=\" + isRegisteredAsAvailable +\n-\t\t\t'}';\n-\t}\n+class CreditBasedSequenceNumberingViewReader\n+        implements BufferAvailabilityListener, NetworkSequenceViewReader {\n+\n+    private final Object requestLock = new Object();\n+\n+    private final InputChannelID receiverId;\n+\n+    private final PartitionRequestQueue requestQueue;\n+\n+    private final int initialCredit;\n+\n+    private volatile ResultSubpartitionView subpartitionView;\n+\n+    /**\n+     * The status indicating whether this reader is already enqueued in the pipeline for\n+     * transferring data or not.\n+     *\n+     * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n+     * thread only since there is no synchronisation.\n+     */\n+    private boolean isRegisteredAsAvailable = false;\n+\n+    /** The number of available buffers for holding data on the consumer side. */\n+    private int numCreditsAvailable;\n+\n+    CreditBasedSequenceNumberingViewReader(\n+            InputChannelID receiverId, int initialCredit, PartitionRequestQueue requestQueue) {\n+        checkArgument(initialCredit >= 0, \"Must be non-negative.\");\n+\n+        this.receiverId = receiverId;\n+        this.initialCredit = initialCredit;\n+        this.numCreditsAvailable = initialCredit;\n+        this.requestQueue = requestQueue;\n+    }\n+\n+    @Override\n+    public void requestSubpartitionView(\n+            ResultPartitionProvider partitionProvider,\n+            ResultPartitionID resultPartitionId,\n+            int subPartitionIndex)\n+            throws IOException {\n+\n+        synchronized (requestLock) {\n+            if (subpartitionView == null) {\n+                // This call can trigger a notification we have to\n+                // schedule a separate task at the event loop that will\n+                // start consuming this. Otherwise the reference to the\n+                // view cannot be available in getNextBuffer().\n+                this.subpartitionView =\n+                        partitionProvider.createSubpartitionView(\n+                                resultPartitionId, subPartitionIndex, this);\n+            } else {\n+                throw new IllegalStateException(\"Subpartition already requested\");\n+            }\n+        }\n+\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public void addCredit(int creditDeltas) {\n+        numCreditsAvailable += creditDeltas;\n+    }\n+\n+    @Override\n+    public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;\n+        }\n+        subpartitionView.resumeConsumption();\n+    }\n+\n+    @Override\n+    public void acknowledgeAllRecordsProcessed() {\n+        subpartitionView.acknowledgeAllRecordsProcessed();\n+    }\n+\n+    @Override\n+    public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n+        this.isRegisteredAsAvailable = isRegisteredAvailable;\n+    }\n+\n+    @Override\n+    public boolean isRegisteredAsAvailable() {\n+        return isRegisteredAsAvailable;\n+    }\n+\n+    /**\n+     * Returns true only if the next buffer is an event or the reader has both available credits and\n+     * buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such\n+     *     that {@code getNextDataType(bufferAndBacklog) != NONE <=>\n+     *     AvailabilityWithBacklog#isAvailable()}!\n+     */\n+    @Override\n+    public ResultSubpartitionView.AvailabilityWithBacklog getAvailabilityAndBacklog() {\n+        return subpartitionView.getAvailabilityAndBacklog(numCreditsAvailable);\n+    }\n+\n+    /**\n+     * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next\n+     * buffer in line.\n+     *\n+     * <p>Returns the next data type only if the next buffer is an event or the reader has both\n+     * available credits and buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getAvailabilityAndBacklog()}, such that\n+     *     {@code getNextDataType(bufferAndBacklog) != NONE <=>\n+     *     AvailabilityWithBacklog#isAvailable()}!\n+     * @param bufferAndBacklog current buffer and backlog including information about the next\n+     *     buffer\n+     * @return the next data type if the next buffer can be pulled immediately or {@link\n+     *     Buffer.DataType#NONE}\n+     */\n+    private Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n+        final Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+        if (numCreditsAvailable > 0 || nextDataType.isEvent()) {\n+            return nextDataType;\n+        }\n+        return Buffer.DataType.NONE;\n+    }\n+\n+    @Override\n+    public InputChannelID getReceiverId() {\n+        return receiverId;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumCreditsAvailable() {\n+        return numCreditsAvailable;\n+    }\n+\n+    @VisibleForTesting\n+    ResultSubpartitionView.AvailabilityWithBacklog hasBuffersAvailable() {\n+        return subpartitionView.getAvailabilityAndBacklog(Integer.MAX_VALUE);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BufferAndAvailability getNextBuffer() throws IOException {\n+        BufferAndBacklog next = subpartitionView.getNextBuffer();\n+        if (next != null) {\n+            if (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n+                throw new IllegalStateException(\"no credit available\");\n+            }\n+\n+            final Buffer.DataType nextDataType = getNextDataType(next);\n+            return new BufferAndAvailability(\n+                    next.buffer(), nextDataType, next.buffersInBacklog(), next.getSequenceNumber());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        return subpartitionView.isReleased();\n+    }\n+\n+    @Override\n+    public Throwable getFailureCause() {\n+        return subpartitionView.getFailureCause();\n+    }\n+\n+    @Override\n+    public void releaseAllResources() throws IOException {\n+        subpartitionView.releaseAllResources();\n+    }\n+\n+    @Override\n+    public void notifyDataAvailable() {\n+        requestQueue.notifyReaderNonEmpty(this);\n+    }\n+\n+    @Override\n+    public void notifyPriorityEvent(int prioritySequenceNumber) {\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CreditBasedSequenceNumberingViewReader{\"\n+                + \"requestLock=\"\n+                + requestLock\n+                + \", receiverId=\"\n+                + receiverId\n+                + \", numCreditsAvailable=\"\n+                + numCreditsAvailable\n+                + \", isRegisteredAsAvailable=\"\n+                + isRegisteredAsAvailable\n+                + '}';\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk1MDcxMA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422950710", "body": "nit: might rename to `numRequiredFloatingBuffers` for better reflecting the current semantic.", "bodyText": "nit: might rename to numRequiredFloatingBuffers for better reflecting the current semantic.", "bodyHTML": "<p dir=\"auto\">nit: might rename to <code>numRequiredFloatingBuffers</code> for better reflecting the current semantic.</p>", "author": "zhijiangW", "createdAt": "2020-05-11T10:44:35Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -99,7 +100,7 @@\n \t/** The number of available buffers that have not been announced to the producer yet. */\n \tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n \n-\t/** The number of required buffers that equals to sender's backlog plus initial credit. */\n+\t/** The number of buffers to requested that equals to unfulfilled sender's backlog. */\n \t@GuardedBy(\"bufferQueue\")\n \tprivate int numRequiredBuffers;", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex ff2103389d6..86a8977f8ee 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -92,33 +83,23 @@ public class RemoteInputChannel extends InputChannel implements BufferRecycler,\n \tprivate int expectedSequenceNumber = 0;\n \n \t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate int initialCredit;\n-\n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\tprivate final int initialCredit;\n \n \t/** The number of available buffers that have not been announced to the producer yet. */\n \tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n \n-\t/** The number of buffers to requested that equals to unfulfilled sender's backlog. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\t/** The tag indicates whether this channel is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** Global memory segment provider to request and recycle exclusive buffers (only for credit-based). */\n-\t@Nonnull\n-\tprivate final MemorySegmentProvider memorySegmentProvider;\n-\n-\t/** The latest already triggered checkpoint id which would be updated during {@link #requestInflightBuffers(long)}.*/\n+\t/**\n+\t * The latest already triggered checkpoint id which would be updated during\n+\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n+\t */\n \t@GuardedBy(\"receivedBuffers\")\n \tprivate long lastRequestedCheckpointId = -1;\n \n \t/** The current received checkpoint id from the network. */\n \tprivate long receivedCheckpointId = -1;\n \n+\tprivate final BufferManager bufferManager;\n+\n \tpublic RemoteInputChannel(\n \t\tSingleInputGate inputGate,\n \t\tint channelIndex,\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 86a8977f8ee..3e976686f91 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -20,523 +20,781 @@ package org.apache.flink.runtime.io.network.partition.consumer;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.checkpoint.CheckpointException;\n+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;\n import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;\n+import org.apache.flink.runtime.event.AbstractEvent;\n import org.apache.flink.runtime.event.TaskEvent;\n+import org.apache.flink.runtime.execution.CancelTaskException;\n import org.apache.flink.runtime.io.network.ConnectionID;\n import org.apache.flink.runtime.io.network.ConnectionManager;\n import org.apache.flink.runtime.io.network.PartitionRequestClient;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+import org.apache.flink.runtime.io.network.api.EventAnnouncement;\n+import org.apache.flink.runtime.io.network.api.serialization.EventSerializer;\n import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.Buffer.DataType;\n import org.apache.flink.runtime.io.network.buffer.BufferProvider;\n-import org.apache.flink.runtime.io.network.buffer.BufferReceivedListener;\n-import org.apache.flink.runtime.io.network.netty.NettyMessage;\n+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;\n import org.apache.flink.runtime.io.network.partition.PartitionNotFoundException;\n+import org.apache.flink.runtime.io.network.partition.PrioritizedDeque;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n \n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterators;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n-/**\n- * An input channel, which requests a remote partition queue.\n- */\n+/** An input channel, which requests a remote partition queue. */\n public class RemoteInputChannel extends InputChannel {\n-\n-\t/** ID to distinguish this channel from other channels sharing the same TCP connection. */\n-\tprivate final InputChannelID id = new InputChannelID();\n-\n-\t/** The connection to use to request the remote partition. */\n-\tprivate final ConnectionID connectionId;\n-\n-\t/** The connection manager to use connect to the remote partition provider. */\n-\tprivate final ConnectionManager connectionManager;\n-\n-\t/**\n-\t * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n-\t * is consumed by the receiving task thread.\n-\t */\n-\tprivate final ArrayDeque<Buffer> receivedBuffers = new ArrayDeque<>();\n-\n-\t/**\n-\t * Flag indicating whether this channel has been released. Either called by the receiving task\n-\t * thread or the task manager actor.\n-\t */\n-\tprivate final AtomicBoolean isReleased = new AtomicBoolean();\n-\n-\t/** Client to establish a (possibly shared) TCP connection and request the partition. */\n-\tprivate volatile PartitionRequestClient partitionRequestClient;\n-\n-\t/**\n-\t * The next expected sequence number for the next buffer. This is modified by the network\n-\t * I/O thread only.\n-\t */\n-\tprivate int expectedSequenceNumber = 0;\n-\n-\t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate final int initialCredit;\n-\n-\t/** The number of available buffers that have not been announced to the producer yet. */\n-\tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n-\n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n-\n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n-\n-\tprivate final BufferManager bufferManager;\n-\n-\tpublic RemoteInputChannel(\n-\t\tSingleInputGate inputGate,\n-\t\tint channelIndex,\n-\t\tResultPartitionID partitionId,\n-\t\tConnectionID connectionId,\n-\t\tConnectionManager connectionManager,\n-\t\tint initialBackOff,\n-\t\tint maxBackoff,\n-\t\tint networkBuffersPerChannel,\n-\t\tCounter numBytesIn,\n-\t\tCounter numBuffersIn) {\n-\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, numBytesIn, numBuffersIn);\n-\n-\t\tthis.initialCredit = networkBuffersPerChannel;\n-\t\tthis.connectionId = checkNotNull(connectionId);\n-\t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n-\t}\n-\n-\t/**\n-\t * Assigns exclusive buffers to this input channel, and this method should be called only once\n-\t * after this input channel is created.\n-\t */\n-\tvoid assignExclusiveSegments() throws IOException {\n-\t\tbufferManager.requestExclusiveBuffers();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests a remote subpartition.\n-\t */\n-\t@VisibleForTesting\n-\t@Override\n-\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n-\t\tif (partitionRequestClient == null) {\n-\t\t\t// Create a client and request the partition\n-\t\t\ttry {\n-\t\t\t\tpartitionRequestClient = connectionManager.createPartitionRequestClient(connectionId);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\t// IOExceptions indicate that we could not open a connection to the remote TaskExecutor\n-\t\t\t\tthrow new PartitionConnectionException(partitionId, e);\n-\t\t\t}\n-\n-\t\t\tpartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Retriggers a remote subpartition request.\n-\t */\n-\tvoid retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n-\t\tcheckState(partitionRequestClient != null, \"Missing initial subpartition request.\");\n-\n-\t\tif (increaseBackoff()) {\n-\t\t\tpartitionRequestClient.requestSubpartition(\n-\t\t\t\tpartitionId, subpartitionIndex, this, getCurrentBackoff());\n-\t\t} else {\n-\t\t\tfailPartitionRequest();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tOptional<BufferAndAvailability> getNextBuffer() throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Queried for a buffer after channel has been closed.\");\n-\t\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tfinal Buffer next;\n-\t\tfinal boolean moreAvailable;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tnext = receivedBuffers.poll();\n-\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n-\t\t}\n-\n-\t\tnumBytesIn.inc(next.getSize());\n-\t\tnumBuffersIn.inc();\n-\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable));\n-\t}\n-\n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlastRequestedCheckpointId = checkpointId;\n-\n-\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\tcheckpointId,\n-\t\t\t\tchannelInfo,\n-\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tvoid sendTaskEvent(TaskEvent event) throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Tried to send task event to producer after channel has been released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tpartitionRequestClient.sendTaskEvent(partitionId, event, this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n-\t}\n-\n-\t/**\n-\t * Releases all exclusive and floating buffers, closes the partition request client.\n-\t */\n-\t@Override\n-\tvoid releaseAllResources() throws IOException {\n-\t\tif (isReleased.compareAndSet(false, true)) {\n-\n-\t\t\tArrayDeque<Buffer> releasedBuffers;\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\treleasedBuffers = receivedBuffers;\n-\t\t\t}\n-\t\t\tbufferManager.releaseAllBuffers(releasedBuffers);\n-\n-\t\t\t// The released flag has to be set before closing the connection to ensure that\n-\t\t\t// buffers received concurrently with closing are properly recycled.\n-\t\t\tif (partitionRequestClient != null) {\n-\t\t\t\tpartitionRequestClient.close(this);\n-\t\t\t} else {\n-\t\t\t\tconnectionManager.closeOpenChannelConnections(connectionId);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void failPartitionRequest() {\n-\t\tsetError(new PartitionNotFoundException(partitionId));\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Credit-based\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n-\t */\n-\tprivate void notifyCreditAvailable() {\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tpartitionRequestClient.notifyCreditAvailable(this);\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfAvailableBuffers() {\n-\t\treturn bufferManager.getNumberOfAvailableBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\treturn bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n-\t}\n-\n-\t@VisibleForTesting\n-\tBufferManager getBufferManager() {\n-\t\treturn bufferManager;\n-\t}\n-\n-\t@VisibleForTesting\n-\tPartitionRequestClient getPartitionRequestClient() {\n-\t\treturn partitionRequestClient;\n-\t}\n-\n-\t/**\n-\t * The unannounced credit is increased by the given amount and might notify\n-\t * increased credit to the producer.\n-\t */\n-\t@Override\n-\tpublic void notifyBufferAvailable(int numAvailableBuffers) {\n-\t\tif (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tbufferManager.onCheckpointBarrier(barrier, initialCredit);\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption() {\n-\t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n-\n-\t\t// notifies the producer that this channel is ready to\n-\t\t// unblock from checkpoint and resume data consumption\n-\t\tpartitionRequestClient.resumeConsumption(this);\n-\t}\n-\n-\t/**\n-\t * Called by netty thread to request buffers and generate {@link NettyMessage.ResumeConsumption} message.\n-\t */\n-\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage() throws IOException {\n-\t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n-\n-\t\treturn bufferManager.resumeAndGetResumptionMessage(id, initialCredit);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network I/O notifications (called by network I/O thread)\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Gets the currently unannounced credit.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getUnannouncedCredit() {\n-\t\treturn unannouncedCredit.get();\n-\t}\n-\n-\t/**\n-\t * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n-\t}\n-\n-\t/**\n-\t * Gets the current number of received buffers which have not been processed yet.\n-\t *\n-\t * @return Buffers queued for processing.\n-\t */\n-\tpublic int getNumberOfQueuedBuffers() {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treturn receivedBuffers.size();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn Math.max(0, receivedBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferManager.unsynchronizedGetExclusiveBuffersUsed());\n-\t}\n-\n-\tpublic int unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n-\t}\n-\n-\tpublic InputChannelID getInputChannelId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic int getInitialCredit() {\n-\t\treturn initialCredit;\n-\t}\n-\n-\tpublic BufferProvider getBufferProvider() throws IOException {\n-\t\tif (isReleased.get()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn inputGate.getBufferProvider();\n-\t}\n-\n-\t/**\n-\t * Requests buffer from input channel directly for receiving network data.\n-\t * It should always return an available buffer in credit-based mode unless\n-\t * the channel has been released.\n-\t *\n-\t * @return The available buffer.\n-\t */\n-\t@Nullable\n-\tpublic Buffer requestBuffer() {\n-\t\treturn bufferManager.requestBuffer();\n-\t}\n-\n-\t/**\n-\t * Receives the backlog from the producer's buffer response. If the number of available\n-\t * buffers is less than backlog + initialCredit, it will request floating buffers from\n-\t * the buffer manager, and then notify unannounced credits to the producer.\n-\t *\n-\t * @param backlog The number of unsent buffers in the producer's sub partition.\n-\t */\n-\tpublic void onSenderBacklog(int backlog) throws IOException {\n-\t\tint numRequestedBuffers = bufferManager.requestFloatingBuffers(backlog);\n-\t\tif (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\tpublic void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean recycleBuffer = true;\n-\n-\t\ttry {\n-\t\t\tif (expectedSequenceNumber != sequenceNumber) {\n-\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tfinal boolean wasEmpty;\n-\t\t\tfinal CheckpointBarrier notifyReceivedBarrier;\n-\t\t\tfinal Buffer notifyReceivedBuffer;\n-\t\t\tfinal BufferReceivedListener listener = inputGate.getBufferReceivedListener();\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after releaseAllResources() released all buffers from receivedBuffers\n-\t\t\t\t// (see above for details).\n-\t\t\t\tif (isReleased.get()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n-\n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n-\t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n-\t\t\t}\n-\t\t\trecycleBuffer = false;\n-\n-\t\t\t++expectedSequenceNumber;\n-\n-\t\t\tif (wasEmpty) {\n-\t\t\t\tnotifyChannelNonEmpty();\n-\t\t\t}\n-\n-\t\t\tif (backlog >= 0) {\n-\t\t\t\tonSenderBacklog(backlog);\n-\t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n-\n-\t\t\tCheckpointBarrier barrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\tif (barrier != null) {\n-\t\t\t\tonCheckpointBarrier(barrier);\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tif (recycleBuffer) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean success = false;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tif (!isReleased.get()) {\n-\t\t\t\tif (expectedSequenceNumber == sequenceNumber) {\n-\t\t\t\t\texpectedSequenceNumber++;\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t} else {\n-\t\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (success && backlog >= 0) {\n-\t\t\tonSenderBacklog(backlog);\n-\t\t}\n-\t}\n-\n-\tpublic void onFailedPartitionRequest() {\n-\t\tinputGate.triggerPartitionStateCheck(partitionId);\n-\t}\n-\n-\tpublic void onError(Throwable cause) {\n-\t\tsetError(cause);\n-\t}\n-\n-\tprivate static class BufferReorderingException extends IOException {\n-\n-\t\tprivate static final long serialVersionUID = -888282210356266816L;\n-\n-\t\tprivate final int expectedSequenceNumber;\n-\n-\t\tprivate final int actualSequenceNumber;\n-\n-\t\tBufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n-\t\t\tthis.expectedSequenceNumber = expectedSequenceNumber;\n-\t\t\tthis.actualSequenceNumber = actualSequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String getMessage() {\n-\t\t\treturn String.format(\"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n-\t\t\t\texpectedSequenceNumber, actualSequenceNumber);\n-\t\t}\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(RemoteInputChannel.class);\n+\n+    private static final int NONE = -1;\n+\n+    /** ID to distinguish this channel from other channels sharing the same TCP connection. */\n+    private final InputChannelID id = new InputChannelID();\n+\n+    /** The connection to use to request the remote partition. */\n+    private final ConnectionID connectionId;\n+\n+    /** The connection manager to use connect to the remote partition provider. */\n+    private final ConnectionManager connectionManager;\n+\n+    /**\n+     * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n+     * is consumed by the receiving task thread.\n+     */\n+    private final PrioritizedDeque<SequenceBuffer> receivedBuffers = new PrioritizedDeque<>();\n+\n+    /**\n+     * Flag indicating whether this channel has been released. Either called by the receiving task\n+     * thread or the task manager actor.\n+     */\n+    private final AtomicBoolean isReleased = new AtomicBoolean();\n+\n+    /** Client to establish a (possibly shared) TCP connection and request the partition. */\n+    private volatile PartitionRequestClient partitionRequestClient;\n+\n+    /** The next expected sequence number for the next buffer. */\n+    private int expectedSequenceNumber = 0;\n+\n+    /** The initial number of exclusive buffers assigned to this channel. */\n+    private final int initialCredit;\n+\n+    /** The number of available buffers that have not been announced to the producer yet. */\n+    private final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n+\n+    private final BufferManager bufferManager;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private int lastBarrierSequenceNumber = NONE;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private long lastBarrierId = NONE;\n+\n+    private final ChannelStatePersister channelStatePersister;\n+\n+    private boolean isUpstreamBlocked;\n+\n+    public RemoteInputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            ConnectionID connectionId,\n+            ConnectionManager connectionManager,\n+            int initialBackOff,\n+            int maxBackoff,\n+            int networkBuffersPerChannel,\n+            Counter numBytesIn,\n+            Counter numBuffersIn,\n+            ChannelStateWriter stateWriter) {\n+\n+        super(\n+                inputGate,\n+                channelIndex,\n+                partitionId,\n+                initialBackOff,\n+                maxBackoff,\n+                numBytesIn,\n+                numBuffersIn);\n+        checkArgument(networkBuffersPerChannel >= 0, \"Must be non-negative.\");\n+\n+        this.initialCredit = networkBuffersPerChannel;\n+        this.connectionId = checkNotNull(connectionId);\n+        this.connectionManager = checkNotNull(connectionManager);\n+        this.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n+        this.channelStatePersister = new ChannelStatePersister(stateWriter, getChannelInfo());\n+    }\n+\n+    @VisibleForTesting\n+    void setExpectedSequenceNumber(int expectedSequenceNumber) {\n+        this.expectedSequenceNumber = expectedSequenceNumber;\n+    }\n+\n+    /**\n+     * Setup includes assigning exclusive buffers to this input channel, and this method should be\n+     * called only once after this input channel is created.\n+     */\n+    @Override\n+    void setup() throws IOException {\n+        checkState(\n+                bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+                \"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n+\n+        bufferManager.requestExclusiveBuffers(initialCredit);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /** Requests a remote subpartition. */\n+    @VisibleForTesting\n+    @Override\n+    public void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException {\n+        if (partitionRequestClient == null) {\n+            LOG.debug(\n+                    \"{}: Requesting REMOTE subpartition {} of partition {}. {}\",\n+                    this,\n+                    subpartitionIndex,\n+                    partitionId,\n+                    channelStatePersister);\n+            // Create a client and request the partition\n+            try {\n+                partitionRequestClient =\n+                        connectionManager.createPartitionRequestClient(connectionId);\n+            } catch (IOException e) {\n+                // IOExceptions indicate that we could not open a connection to the remote\n+                // TaskExecutor\n+                throw new PartitionConnectionException(partitionId, e);\n+            }\n+\n+            partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n+        }\n+    }\n+\n+    /** Retriggers a remote subpartition request. */\n+    void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (increaseBackoff()) {\n+            partitionRequestClient.requestSubpartition(\n+                    partitionId, subpartitionIndex, this, getCurrentBackoff());\n+        } else {\n+            failPartitionRequest();\n+        }\n+    }\n+\n+    @Override\n+    Optional<BufferAndAvailability> getNextBuffer() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        final SequenceBuffer next;\n+        final DataType nextDataType;\n+\n+        synchronized (receivedBuffers) {\n+            next = receivedBuffers.poll();\n+            nextDataType =\n+                    receivedBuffers.peek() != null\n+                            ? receivedBuffers.peek().buffer.getDataType()\n+                            : DataType.NONE;\n+        }\n+\n+        if (next == null) {\n+            if (isReleased.get()) {\n+                throw new CancelTaskException(\n+                        \"Queried for a buffer after channel has been released.\");\n+            }\n+            return Optional.empty();\n+        }\n+\n+        numBytesIn.inc(next.buffer.getSize());\n+        numBuffersIn.inc();\n+        return Optional.of(\n+                new BufferAndAvailability(next.buffer, nextDataType, 0, next.sequenceNumber));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    void sendTaskEvent(TaskEvent event) throws IOException {\n+        checkState(\n+                !isReleased.get(),\n+                \"Tried to send task event to producer after channel has been released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.sendTaskEvent(partitionId, event, this);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased.get();\n+    }\n+\n+    /** Releases all exclusive and floating buffers, closes the partition request client. */\n+    @Override\n+    void releaseAllResources() throws IOException {\n+        if (isReleased.compareAndSet(false, true)) {\n+\n+            final ArrayDeque<Buffer> releasedBuffers;\n+            synchronized (receivedBuffers) {\n+                releasedBuffers =\n+                        receivedBuffers.stream()\n+                                .map(sb -> sb.buffer)\n+                                .collect(Collectors.toCollection(ArrayDeque::new));\n+                receivedBuffers.clear();\n+            }\n+            bufferManager.releaseAllBuffers(releasedBuffers);\n+\n+            // The released flag has to be set before closing the connection to ensure that\n+            // buffers received concurrently with closing are properly recycled.\n+            if (partitionRequestClient != null) {\n+                partitionRequestClient.close(this);\n+            } else {\n+                connectionManager.closeOpenChannelConnections(connectionId);\n+            }\n+        }\n+    }\n+\n+    private void failPartitionRequest() {\n+        setError(new PartitionNotFoundException(partitionId));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Credit-based\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n+     */\n+    private void notifyCreditAvailable() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.notifyCreditAvailable(this);\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfAvailableBuffers() {\n+        return bufferManager.getNumberOfAvailableBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfRequiredBuffers() {\n+        return bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getSenderBacklog() {\n+        return getNumberOfRequiredBuffers() - initialCredit;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isWaitingForFloatingBuffers() {\n+        return bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public Buffer getNextReceivedBuffer() {\n+        final SequenceBuffer sequenceBuffer = receivedBuffers.poll();\n+        return sequenceBuffer != null ? sequenceBuffer.buffer : null;\n+    }\n+\n+    @VisibleForTesting\n+    BufferManager getBufferManager() {\n+        return bufferManager;\n+    }\n+\n+    @VisibleForTesting\n+    PartitionRequestClient getPartitionRequestClient() {\n+        return partitionRequestClient;\n+    }\n+\n+    /**\n+     * The unannounced credit is increased by the given amount and might notify increased credit to\n+     * the producer.\n+     */\n+    @Override\n+    public void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n+        if (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+            notifyCreditAvailable();\n+        }\n+    }\n+\n+    @Override\n+    public void resumeConsumption() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        // notifies the producer that this channel is ready to\n+        // unblock from checkpoint and resume data consumption\n+        partitionRequestClient.resumeConsumption(this);\n+    }\n+\n+    private void onBlockingUpstream() {\n+        isUpstreamBlocked = true;\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    public void onConsumptionResumed() {\n+        isUpstreamBlocked = false;\n+        if (initialCredit == 0) {\n+            unannouncedCredit.set(0);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network I/O notifications (called by network I/O thread)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the currently unannounced credit.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getUnannouncedCredit() {\n+        return unannouncedCredit.get();\n+    }\n+\n+    /**\n+     * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getAndResetUnannouncedCredit() {\n+        return unannouncedCredit.getAndSet(0);\n+    }\n+\n+    /**\n+     * Gets the current number of received buffers which have not been processed yet.\n+     *\n+     * @return Buffers queued for processing.\n+     */\n+    public int getNumberOfQueuedBuffers() {\n+        synchronized (receivedBuffers) {\n+            return receivedBuffers.size();\n+        }\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return Math.max(0, receivedBuffers.size());\n+    }\n+\n+    public int unsynchronizedGetExclusiveBuffersUsed() {\n+        return Math.max(\n+                0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n+    }\n+\n+    public int unsynchronizedGetFloatingBuffersAvailable() {\n+        return Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n+    }\n+\n+    public InputChannelID getInputChannelId() {\n+        return id;\n+    }\n+\n+    public int getInitialCredit() {\n+        return initialCredit;\n+    }\n+\n+    public BufferProvider getBufferProvider() throws IOException {\n+        if (isReleased.get()) {\n+            return null;\n+        }\n+\n+        return inputGate.getBufferProvider();\n+    }\n+\n+    /**\n+     * Requests buffer from input channel directly for receiving network data. It should always\n+     * return an available buffer in credit-based mode unless the channel has been released.\n+     *\n+     * @return The available buffer.\n+     */\n+    @Nullable\n+    public Buffer requestBuffer() {\n+        return bufferManager.requestBuffer(initialCredit);\n+    }\n+\n+    /**\n+     * Receives the backlog from the producer's buffer response. If the number of available buffers\n+     * is less than backlog + initialCredit, it will request floating buffers from the buffer\n+     * manager, and then notify unannounced credits to the producer.\n+     *\n+     * @param backlog The number of unsent buffers in the producer's sub partition.\n+     */\n+    public void onSenderBacklog(int backlog) throws IOException {\n+        // never allocate any new buffers if upstream has been blocked\n+        if (!isUpstreamBlocked) {\n+            notifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+        }\n+    }\n+\n+    public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n+        boolean recycleBuffer = true;\n+\n+        try {\n+            if (expectedSequenceNumber != sequenceNumber) {\n+                onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                return;\n+            }\n+\n+            final boolean wasEmpty;\n+            boolean firstPriorityEvent = false;\n+            synchronized (receivedBuffers) {\n+                NetworkActionsLogger.traceInput(\n+                        \"RemoteInputChannel#onBuffer\",\n+                        buffer,\n+                        inputGate.getOwningTaskName(),\n+                        channelInfo,\n+                        channelStatePersister,\n+                        sequenceNumber);\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after releaseAllResources() released all buffers from receivedBuffers\n+                // (see above for details).\n+                if (isReleased.get()) {\n+                    return;\n+                }\n+\n+                wasEmpty = receivedBuffers.isEmpty();\n+\n+                SequenceBuffer sequenceBuffer = new SequenceBuffer(buffer, sequenceNumber);\n+                DataType dataType = buffer.getDataType();\n+                if (dataType.hasPriority()) {\n+                    firstPriorityEvent = addPriorityBuffer(sequenceBuffer);\n+                } else {\n+                    receivedBuffers.add(sequenceBuffer);\n+                    if (dataType.requiresAnnouncement()) {\n+                        firstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n+                    }\n+                }\n+                channelStatePersister\n+                        .checkForBarrier(sequenceBuffer.buffer)\n+                        .filter(id -> id > lastBarrierId)\n+                        .ifPresent(\n+                                id -> {\n+                                    // checkpoint was not yet started by task thread,\n+                                    // so remember the numbers of buffers to spill for the time when\n+                                    // it will be started\n+                                    lastBarrierId = id;\n+                                    lastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+                                });\n+                channelStatePersister.maybePersist(buffer);\n+                ++expectedSequenceNumber;\n+            }\n+            recycleBuffer = false;\n+\n+            if (firstPriorityEvent) {\n+                notifyPriorityEvent(sequenceNumber);\n+            }\n+            if (wasEmpty) {\n+                notifyChannelNonEmpty();\n+            }\n+\n+            if (backlog >= 0) {\n+                onSenderBacklog(backlog);\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+            }\n+        } finally {\n+            if (recycleBuffer) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+    }\n+\n+    /** @return {@code true} if this was first priority buffer added. */\n+    private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) {\n+        receivedBuffers.addPriorityElement(sequenceBuffer);\n+        return receivedBuffers.getNumPriorityElements() == 1;\n+    }\n+\n+    private SequenceBuffer announce(SequenceBuffer sequenceBuffer) throws IOException {\n+        checkState(\n+                !sequenceBuffer.buffer.isBuffer(),\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        checkAnnouncedOnlyOnce(sequenceBuffer);\n+        AbstractEvent event =\n+                EventSerializer.fromBuffer(sequenceBuffer.buffer, getClass().getClassLoader());\n+        checkState(\n+                event instanceof CheckpointBarrier,\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        CheckpointBarrier barrier = (CheckpointBarrier) event;\n+        return new SequenceBuffer(\n+                EventSerializer.toBuffer(\n+                        new EventAnnouncement(barrier, sequenceBuffer.sequenceNumber), true),\n+                sequenceBuffer.sequenceNumber);\n+    }\n+\n+    private void checkAnnouncedOnlyOnce(SequenceBuffer sequenceBuffer) {\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        int count = 0;\n+        while (iterator.hasNext()) {\n+            if (iterator.next().sequenceNumber == sequenceBuffer.sequenceNumber) {\n+                count++;\n+            }\n+        }\n+        checkState(\n+                count == 1,\n+                \"Before enqueuing the announcement there should be exactly single occurrence of the buffer, but found [%d]\",\n+                count);\n+    }\n+\n+    /**\n+     * Spills all queued buffers on checkpoint start. If barrier has already been received (and\n+     * reordered), spill only the overtaken buffers.\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {\n+        synchronized (receivedBuffers) {\n+            if (barrier.getId() < lastBarrierId) {\n+                throw new CheckpointException(\n+                        String.format(\n+                                \"Sequence number for checkpoint %d is not known (it was likely been overwritten by a newer checkpoint %d)\",\n+                                barrier.getId(), lastBarrierId),\n+                        CheckpointFailureReason\n+                                .CHECKPOINT_SUBSUMED); // currently, at most one active unaligned\n+                // checkpoint is possible\n+            } else if (barrier.getId() > lastBarrierId) {\n+                // This channel has received some obsolete barrier, older compared to the\n+                // checkpointId\n+                // which we are processing right now, and we should ignore that obsoleted checkpoint\n+                // barrier sequence number.\n+                resetLastBarrier();\n+            }\n+\n+            channelStatePersister.startPersisting(\n+                    barrier.getId(), getInflightBuffersUnsafe(barrier.getId()));\n+        }\n+    }\n+\n+    public void checkpointStopped(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            channelStatePersister.stopPersisting(checkpointId);\n+            if (lastBarrierId == checkpointId) {\n+                resetLastBarrier();\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    List<Buffer> getInflightBuffers(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            return getInflightBuffersUnsafe(checkpointId);\n+        }\n+    }\n+\n+    @Override\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n+        boolean firstPriorityEvent;\n+        synchronized (receivedBuffers) {\n+            checkState(channelStatePersister.hasBarrierReceived());\n+            int numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n+            SequenceBuffer toPrioritize =\n+                    receivedBuffers.getAndRemove(\n+                            sequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n+            checkState(lastBarrierSequenceNumber == sequenceNumber);\n+            checkState(!toPrioritize.buffer.isBuffer());\n+            checkState(\n+                    numPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n+                    \"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n+                    toPrioritize,\n+                    numPriorityElementsBeforeRemoval);\n+            // set the priority flag (checked on poll)\n+            // don't convert the barrier itself (barrier controller might not have been switched\n+            // yet)\n+            AbstractEvent e =\n+                    EventSerializer.fromBuffer(\n+                            toPrioritize.buffer, this.getClass().getClassLoader());\n+            toPrioritize.buffer.setReaderIndex(0);\n+            toPrioritize =\n+                    new SequenceBuffer(\n+                            EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n+            firstPriorityEvent =\n+                    addPriorityBuffer(\n+                            toPrioritize); // note that only position of the element is changed\n+            // converting the event itself would require switching the controller sooner\n+        }\n+        if (firstPriorityEvent) {\n+            notifyPriorityEventForce(); // forcibly notify about the priority event\n+            // instead of passing barrier SQN to be checked\n+            // because this SQN might have be seen by the input gate during the announcement\n+        }\n+    }\n+\n+    private void notifyPriorityEventForce() {\n+        inputGate.notifyPriorityEventForce(this);\n+    }\n+\n+    /**\n+     * Returns a list of buffers, checking the first n non-priority buffers, and skipping all\n+     * events.\n+     */\n+    private List<Buffer> getInflightBuffersUnsafe(long checkpointId) {\n+        assert Thread.holdsLock(receivedBuffers);\n+\n+        checkState(checkpointId == lastBarrierId || lastBarrierId == NONE);\n+\n+        final List<Buffer> inflightBuffers = new ArrayList<>();\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        // skip all priority events (only buffers are stored anyways)\n+        Iterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n+\n+        while (iterator.hasNext()) {\n+            SequenceBuffer sequenceBuffer = iterator.next();\n+            if (sequenceBuffer.buffer.isBuffer()) {\n+                if (shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+                    inflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return inflightBuffers;\n+    }\n+\n+    private void resetLastBarrier() {\n+        lastBarrierId = NONE;\n+        lastBarrierSequenceNumber = NONE;\n+    }\n+\n+    /**\n+     * @return if given {@param sequenceNumber} should be spilled given {@link\n+     *     #lastBarrierSequenceNumber}. We might not have yet received {@link CheckpointBarrier} and\n+     *     we might need to spill everything. If we have already received it, there is a bit nasty\n+     *     corner case of {@link SequenceBuffer#sequenceNumber} overflowing that needs to be handled\n+     *     as well.\n+     */\n+    private boolean shouldBeSpilled(int sequenceNumber) {\n+        if (lastBarrierSequenceNumber == NONE) {\n+            return true;\n+        }\n+        checkState(\n+                receivedBuffers.size() < Integer.MAX_VALUE / 2,\n+                \"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+        boolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastBarrierSequenceNumber;\n+        boolean possibleOverflowBeforeOvertaking =\n+                lastBarrierSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+        if (possibleOverflowAfterOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber && sequenceNumber > 0;\n+        } else if (possibleOverflowBeforeOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber || sequenceNumber > 0;\n+        } else {\n+            return sequenceNumber < lastBarrierSequenceNumber;\n+        }\n+    }\n+\n+    public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n+        boolean success = false;\n+\n+        synchronized (receivedBuffers) {\n+            if (!isReleased.get()) {\n+                if (expectedSequenceNumber == sequenceNumber) {\n+                    expectedSequenceNumber++;\n+                    success = true;\n+                } else {\n+                    onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                }\n+            }\n+        }\n+\n+        if (success && backlog >= 0) {\n+            onSenderBacklog(backlog);\n+        }\n+    }\n+\n+    public void onFailedPartitionRequest() {\n+        inputGate.triggerPartitionStateCheck(partitionId);\n+    }\n+\n+    public void onError(Throwable cause) {\n+        setError(cause);\n+    }\n+\n+    private void checkPartitionRequestQueueInitialized() throws IOException {\n+        checkError();\n+        checkState(\n+                partitionRequestClient != null,\n+                \"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n+    }\n+\n+    private static class BufferReorderingException extends IOException {\n+\n+        private static final long serialVersionUID = -888282210356266816L;\n+\n+        private final int expectedSequenceNumber;\n+\n+        private final int actualSequenceNumber;\n+\n+        BufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n+            this.expectedSequenceNumber = expectedSequenceNumber;\n+            this.actualSequenceNumber = actualSequenceNumber;\n+        }\n+\n+        @Override\n+        public String getMessage() {\n+            return String.format(\n+                    \"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n+                    expectedSequenceNumber, actualSequenceNumber);\n+        }\n+    }\n+\n+    private static final class SequenceBuffer {\n+        final Buffer buffer;\n+        final int sequenceNumber;\n+\n+        private SequenceBuffer(Buffer buffer, int sequenceNumber) {\n+            this.buffer = buffer;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\n+                    \"SequenceBuffer(isEvent = %s, dataType = %s, sequenceNumber = %s)\",\n+                    !buffer.isBuffer(), buffer.getDataType(), sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex ff2103389d6..f9cedf71105 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -19,763 +19,799 @@\n package org.apache.flink.runtime.io.network.partition.consumer;\n \n import org.apache.flink.annotation.VisibleForTesting;\n-import org.apache.flink.core.memory.MemorySegment;\n-import org.apache.flink.core.memory.MemorySegmentProvider;\n-import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.checkpoint.CheckpointException;\n+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;\n+import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;\n+import org.apache.flink.runtime.event.AbstractEvent;\n import org.apache.flink.runtime.event.TaskEvent;\n+import org.apache.flink.runtime.execution.CancelTaskException;\n import org.apache.flink.runtime.io.network.ConnectionID;\n import org.apache.flink.runtime.io.network.ConnectionManager;\n import org.apache.flink.runtime.io.network.PartitionRequestClient;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+import org.apache.flink.runtime.io.network.api.EventAnnouncement;\n+import org.apache.flink.runtime.io.network.api.serialization.EventSerializer;\n import org.apache.flink.runtime.io.network.buffer.Buffer;\n-import org.apache.flink.runtime.io.network.buffer.BufferListener;\n+import org.apache.flink.runtime.io.network.buffer.Buffer.DataType;\n import org.apache.flink.runtime.io.network.buffer.BufferProvider;\n-import org.apache.flink.runtime.io.network.buffer.BufferReceivedListener;\n-import org.apache.flink.runtime.io.network.buffer.BufferRecycler;\n-import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n-import org.apache.flink.runtime.io.network.metrics.InputChannelMetrics;\n-import org.apache.flink.runtime.io.network.netty.NettyMessage;\n+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;\n import org.apache.flink.runtime.io.network.partition.PartitionNotFoundException;\n+import org.apache.flink.runtime.io.network.partition.PrioritizedDeque;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n-import org.apache.flink.util.ExceptionUtils;\n \n-import javax.annotation.Nonnull;\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterators;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n-/**\n- * An input channel, which requests a remote partition queue.\n- */\n-public class RemoteInputChannel extends InputChannel implements BufferRecycler, BufferListener {\n-\n-\t/** ID to distinguish this channel from other channels sharing the same TCP connection. */\n-\tprivate final InputChannelID id = new InputChannelID();\n-\n-\t/** The connection to use to request the remote partition. */\n-\tprivate final ConnectionID connectionId;\n-\n-\t/** The connection manager to use connect to the remote partition provider. */\n-\tprivate final ConnectionManager connectionManager;\n-\n-\t/**\n-\t * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n-\t * is consumed by the receiving task thread.\n-\t */\n-\tprivate final ArrayDeque<Buffer> receivedBuffers = new ArrayDeque<>();\n-\n-\t/**\n-\t * Flag indicating whether this channel has been released. Either called by the receiving task\n-\t * thread or the task manager actor.\n-\t */\n-\tprivate final AtomicBoolean isReleased = new AtomicBoolean();\n-\n-\t/** Client to establish a (possibly shared) TCP connection and request the partition. */\n-\tprivate volatile PartitionRequestClient partitionRequestClient;\n-\n-\t/**\n-\t * The next expected sequence number for the next buffer. This is modified by the network\n-\t * I/O thread only.\n-\t */\n-\tprivate int expectedSequenceNumber = 0;\n-\n-\t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate int initialCredit;\n-\n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The number of available buffers that have not been announced to the producer yet. */\n-\tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n-\n-\t/** The number of buffers to requested that equals to unfulfilled sender's backlog. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\t/** The tag indicates whether this channel is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** Global memory segment provider to request and recycle exclusive buffers (only for credit-based). */\n-\t@Nonnull\n-\tprivate final MemorySegmentProvider memorySegmentProvider;\n-\n-\t/** The latest already triggered checkpoint id which would be updated during {@link #requestInflightBuffers(long)}.*/\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n-\n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n-\n-\tpublic RemoteInputChannel(\n-\t\tSingleInputGate inputGate,\n-\t\tint channelIndex,\n-\t\tResultPartitionID partitionId,\n-\t\tConnectionID connectionId,\n-\t\tConnectionManager connectionManager,\n-\t\tint initialBackOff,\n-\t\tint maxBackoff,\n-\t\tInputChannelMetrics metrics,\n-\t\t@Nonnull MemorySegmentProvider memorySegmentProvider) {\n-\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff,\n-\t\t\tmetrics.getNumBytesInRemoteCounter(), metrics.getNumBuffersInRemoteCounter());\n-\n-\t\tthis.connectionId = checkNotNull(connectionId);\n-\t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.memorySegmentProvider = memorySegmentProvider;\n-\t}\n-\n-\t/**\n-\t * Assigns exclusive buffers to this input channel, and this method should be called only once\n-\t * after this input channel is created.\n-\t */\n-\tvoid assignExclusiveSegments() throws IOException {\n-\t\tcheckState(initialCredit == 0, \"Bug in input channel setup logic: exclusive buffers have \" +\n-\t\t\t\"already been set for this input channel.\");\n-\n-\t\tCollection<MemorySegment> segments = checkNotNull(memorySegmentProvider.requestMemorySegments());\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tinitialCredit = segments.size();\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), initialCredit);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests a remote subpartition.\n-\t */\n-\t@VisibleForTesting\n-\t@Override\n-\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n-\t\tif (partitionRequestClient == null) {\n-\t\t\t// Create a client and request the partition\n-\t\t\ttry {\n-\t\t\t\tpartitionRequestClient = connectionManager.createPartitionRequestClient(connectionId);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\t// IOExceptions indicate that we could not open a connection to the remote TaskExecutor\n-\t\t\t\tthrow new PartitionConnectionException(partitionId, e);\n-\t\t\t}\n-\n-\t\t\tpartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Retriggers a remote subpartition request.\n-\t */\n-\tvoid retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n-\t\tcheckState(partitionRequestClient != null, \"Missing initial subpartition request.\");\n-\n-\t\tif (increaseBackoff()) {\n-\t\t\tpartitionRequestClient.requestSubpartition(\n-\t\t\t\tpartitionId, subpartitionIndex, this, getCurrentBackoff());\n-\t\t} else {\n-\t\t\tfailPartitionRequest();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tOptional<BufferAndAvailability> getNextBuffer() throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Queried for a buffer after channel has been closed.\");\n-\t\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tfinal Buffer next;\n-\t\tfinal boolean moreAvailable;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tnext = receivedBuffers.poll();\n-\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n-\t\t}\n-\n-\t\tnumBytesIn.inc(next.getSize());\n-\t\tnumBuffersIn.inc();\n-\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable, numRequiredBuffers));\n-\t}\n-\n-\t@Override\n-\tpublic List<Buffer> requestInflightBuffers(long checkpointId) throws IOException {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlastRequestedCheckpointId = checkpointId;\n-\n-\t\t\treturn inflightBuffers;\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tvoid sendTaskEvent(TaskEvent event) throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Tried to send task event to producer after channel has been released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tpartitionRequestClient.sendTaskEvent(partitionId, event, this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n-\t}\n-\n-\t/**\n-\t * Releases all exclusive and floating buffers, closes the partition request client.\n-\t */\n-\t@Override\n-\tvoid releaseAllResources() throws IOException {\n-\t\tif (isReleased.compareAndSet(false, true)) {\n-\n-\t\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\tBuffer buffer;\n-\t\t\t\twhile ((buffer = receivedBuffers.poll()) != null) {\n-\t\t\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\t}\n-\n-\t\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\t\tmemorySegmentProvider.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t\t}\n-\n-\t\t\t// The released flag has to be set before closing the connection to ensure that\n-\t\t\t// buffers received concurrently with closing are properly recycled.\n-\t\t\tif (partitionRequestClient != null) {\n-\t\t\t\tpartitionRequestClient.close(this);\n-\t\t\t} else {\n-\t\t\t\tconnectionManager.closeOpenChannelConnections(connectionId);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void failPartitionRequest() {\n-\t\tsetError(new PartitionNotFoundException(partitionId));\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Credit-based\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n-\t */\n-\tprivate void notifyCreditAvailable() {\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tpartitionRequestClient.notifyCreditAvailable(this);\n-\t}\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this input channel directly and it may trigger return extra\n-\t * floating buffer and notify increased credit to the producer.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers;\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t// after releaseAllResources() released all buffers (see below for details).\n-\t\t\tif (isReleased.get()) {\n-\t\t\t\ttry {\n-\t\t\t\t\tmemorySegmentProvider.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t\treturn;\n-\t\t\t\t} catch (Throwable t) {\n-\t\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t}\n-\n-\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\tpublic int getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn numRequiredBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\treturn isWaitingForFloatingBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n-\t}\n-\n-\t/**\n-\t * The Buffer pool notifies this channel of an available floating buffer. If the channel is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased\n-\t * by one.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t *  \tmore floating buffers.\n-\t */\n-\t@Override\n-\tpublic NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tNotificationResult notificationResult = NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tcheckState(isWaitingForFloatingBuffers,\n-\t\t\t\t\t\"This channel should be waiting for floating buffers.\");\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllResources() already released buffers inside bufferQueue\n-\t\t\t\t// -> then isReleased is set correctly\n-\t\t\t\t// 2) releaseAllResources() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (isReleased.get() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (unannouncedCredit.getAndAdd(1) == 0) {\n-\t\t\t\tnotifyCreditAvailable();\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tsetError(t);\n-\t\t}\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t@Override\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\t\tboolean removed = inputGate.getBufferProvider().removeBufferListener(this);\n-\t\t\t\t\tcheckState(removed, \"Listener should be removed.\");\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t}\n-\n-\t\t\t\tint bufferReleased = bufferQueue.releaseAllFloatingBuffers();\n-\t\t\t\tnumRequiredBuffers += bufferReleased;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption() {\n-\t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n-\n-\t\t// notifies the producer that this channel is ready to\n-\t\t// unblock from checkpoint and resume data consumption\n-\t\tpartitionRequestClient.resumeConsumption(this);\n-\t}\n-\n-\t/**\n-\t * Called by netty thread to request buffers and generate {@link NettyMessage.ResumeConsumption} message.\n-\t */\n-\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage() throws IOException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n-\t\t\tcheckState(numRequiredBuffers >= 0, \"Number of required buffers should be non-negative.\");\n-\n-\t\t\tif (initialCredit > 0) {\n-\t\t\t\treturn new NettyMessage.ResumeConsumption(id, bufferQueue.getAvailableBufferSize(), numRequiredBuffers);\n-\t\t\t}\n-\n-\t\t\tint numCredit = requestBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numCredit;\n-\t\t\treturn new NettyMessage.ResumeConsumption(id, numCredit, numRequiredBuffers);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network I/O notifications (called by network I/O thread)\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Gets the currently unannounced credit.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getUnannouncedCredit() {\n-\t\treturn unannouncedCredit.get();\n-\t}\n-\n-\t/**\n-\t * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n-\t}\n-\n-\t/**\n-\t * Gets the current number of received buffers which have not been processed yet.\n-\t *\n-\t * @return Buffers queued for processing.\n-\t */\n-\tpublic int getNumberOfQueuedBuffers() {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treturn receivedBuffers.size();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn Math.max(0, receivedBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferQueue.exclusiveBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn Math.max(0, bufferQueue.floatingBuffers.size());\n-\t}\n-\n-\tpublic InputChannelID getInputChannelId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic int getInitialCredit() {\n-\t\treturn initialCredit;\n-\t}\n-\n-\tpublic BufferProvider getBufferProvider() throws IOException {\n-\t\tif (isReleased.get()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn inputGate.getBufferProvider();\n-\t}\n-\n-\t/**\n-\t * Requests buffer from input channel directly for receiving network data.\n-\t * It should always return an available buffer in credit-based mode unless\n-\t * the channel has been released.\n-\t *\n-\t * @return The available buffer.\n-\t */\n-\t@Nullable\n-\tpublic Buffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Receives the backlog from the producer's buffer response. If the number of available\n-\t * buffers is less than backlog + initialCredit, it will request floating buffers from the buffer\n-\t * pool, and then notify unannounced credits to the producer.\n-\t *\n-\t * @param backlog The number of unsent buffers in the producer's sub partition.\n-\t */\n-\tpublic void onSenderBacklog(int backlog) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t// after releaseAllResources() released all buffers (see above for details).\n-\t\t\tif (isReleased.get()) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += backlog;\n-\t\t\tnumRequestedBuffers = requestBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\n-\t\tif (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\tprivate int requestBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBuffer buffer = inputGate.getBufferPool().requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (inputGate.getBufferProvider().addBufferListener(this)) {\n-\t\t\t\t// If the channel has not got enough buffers, register it as listener to wait for more floating buffers.\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tpublic void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean recycleBuffer = true;\n-\n-\t\ttry {\n-\t\t\tif (expectedSequenceNumber != sequenceNumber) {\n-\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tfinal boolean wasEmpty;\n-\t\t\tfinal CheckpointBarrier notifyReceivedBarrier;\n-\t\t\tfinal Buffer notifyReceivedBuffer;\n-\t\t\tfinal BufferReceivedListener listener = inputGate.getBufferReceivedListener();\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after releaseAllResources() released all buffers from receivedBuffers\n-\t\t\t\t// (see above for details).\n-\t\t\t\tif (isReleased.get()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n-\n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n-\t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n-\t\t\t}\n-\t\t\trecycleBuffer = false;\n-\n-\t\t\t++expectedSequenceNumber;\n-\n-\t\t\tif (wasEmpty) {\n-\t\t\t\tnotifyChannelNonEmpty();\n-\t\t\t}\n-\n-\t\t\tif (backlog >= 0) {\n-\t\t\t\tonSenderBacklog(backlog);\n-\t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tif (recycleBuffer) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean success = false;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tif (!isReleased.get()) {\n-\t\t\t\tif (expectedSequenceNumber == sequenceNumber) {\n-\t\t\t\t\texpectedSequenceNumber++;\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t} else {\n-\t\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (success && backlog >= 0) {\n-\t\t\tonSenderBacklog(backlog);\n-\t\t}\n-\t}\n-\n-\tpublic void onFailedPartitionRequest() {\n-\t\tinputGate.triggerPartitionStateCheck(partitionId);\n-\t}\n-\n-\tpublic void onError(Throwable cause) {\n-\t\tsetError(cause);\n-\t}\n-\n-\tprivate static class BufferReorderingException extends IOException {\n-\n-\t\tprivate static final long serialVersionUID = -888282210356266816L;\n-\n-\t\tprivate final int expectedSequenceNumber;\n-\n-\t\tprivate final int actualSequenceNumber;\n-\n-\t\tBufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n-\t\t\tthis.expectedSequenceNumber = expectedSequenceNumber;\n-\t\t\tthis.actualSequenceNumber = actualSequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String getMessage() {\n-\t\t\treturn String.format(\"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n-\t\t\t\texpectedSequenceNumber, actualSequenceNumber);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tprivate static class AvailableBufferQueue {\n-\n-\t\t/** The current available floating buffers from the fixed buffer pool. */\n-\t\tprivate final ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/** The current available exclusive buffers from the global buffer pool. */\n-\t\tprivate final ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t *\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\treturn 0;\n-\t\t\t} else {\n-\t\t\t\treturn 1;\n-\t\t\t}\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseAllFloatingBuffers() {\n-\t\t\tint bufferReleased = floatingBuffers.size();\n-\t\t\tfor (Buffer buffer: floatingBuffers) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\tfloatingBuffers.clear();\n-\t\t\treturn bufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+/** An input channel, which requests a remote partition queue. */\n+public class RemoteInputChannel extends InputChannel {\n+    private static final Logger LOG = LoggerFactory.getLogger(RemoteInputChannel.class);\n+\n+    private static final int NONE = -1;\n+\n+    /** ID to distinguish this channel from other channels sharing the same TCP connection. */\n+    private final InputChannelID id = new InputChannelID();\n+\n+    /** The connection to use to request the remote partition. */\n+    private final ConnectionID connectionId;\n+\n+    /** The connection manager to use connect to the remote partition provider. */\n+    private final ConnectionManager connectionManager;\n+\n+    /**\n+     * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n+     * is consumed by the receiving task thread.\n+     */\n+    private final PrioritizedDeque<SequenceBuffer> receivedBuffers = new PrioritizedDeque<>();\n+\n+    /**\n+     * Flag indicating whether this channel has been released. Either called by the receiving task\n+     * thread or the task manager actor.\n+     */\n+    private final AtomicBoolean isReleased = new AtomicBoolean();\n+\n+    /** Client to establish a (possibly shared) TCP connection and request the partition. */\n+    private volatile PartitionRequestClient partitionRequestClient;\n+\n+    /** The next expected sequence number for the next buffer. */\n+    private int expectedSequenceNumber = 0;\n+\n+    /** The initial number of exclusive buffers assigned to this channel. */\n+    private final int initialCredit;\n+\n+    /** The number of available buffers that have not been announced to the producer yet. */\n+    private final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n+\n+    private final BufferManager bufferManager;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private int lastBarrierSequenceNumber = NONE;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private long lastBarrierId = NONE;\n+\n+    private final ChannelStatePersister channelStatePersister;\n+\n+    public RemoteInputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            ConnectionID connectionId,\n+            ConnectionManager connectionManager,\n+            int initialBackOff,\n+            int maxBackoff,\n+            int networkBuffersPerChannel,\n+            Counter numBytesIn,\n+            Counter numBuffersIn,\n+            ChannelStateWriter stateWriter) {\n+\n+        super(\n+                inputGate,\n+                channelIndex,\n+                partitionId,\n+                initialBackOff,\n+                maxBackoff,\n+                numBytesIn,\n+                numBuffersIn);\n+        checkArgument(networkBuffersPerChannel >= 0, \"Must be non-negative.\");\n+\n+        this.initialCredit = networkBuffersPerChannel;\n+        this.connectionId = checkNotNull(connectionId);\n+        this.connectionManager = checkNotNull(connectionManager);\n+        this.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n+        this.channelStatePersister = new ChannelStatePersister(stateWriter, getChannelInfo());\n+    }\n+\n+    @VisibleForTesting\n+    void setExpectedSequenceNumber(int expectedSequenceNumber) {\n+        this.expectedSequenceNumber = expectedSequenceNumber;\n+    }\n+\n+    /**\n+     * Setup includes assigning exclusive buffers to this input channel, and this method should be\n+     * called only once after this input channel is created.\n+     */\n+    @Override\n+    void setup() throws IOException {\n+        checkState(\n+                bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+                \"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n+\n+        bufferManager.requestExclusiveBuffers(initialCredit);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /** Requests a remote subpartition. */\n+    @VisibleForTesting\n+    @Override\n+    public void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException {\n+        if (partitionRequestClient == null) {\n+            LOG.debug(\n+                    \"{}: Requesting REMOTE subpartition {} of partition {}. {}\",\n+                    this,\n+                    subpartitionIndex,\n+                    partitionId,\n+                    channelStatePersister);\n+            // Create a client and request the partition\n+            try {\n+                partitionRequestClient =\n+                        connectionManager.createPartitionRequestClient(connectionId);\n+            } catch (IOException e) {\n+                // IOExceptions indicate that we could not open a connection to the remote\n+                // TaskExecutor\n+                throw new PartitionConnectionException(partitionId, e);\n+            }\n+\n+            partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n+        }\n+    }\n+\n+    /** Retriggers a remote subpartition request. */\n+    void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (increaseBackoff()) {\n+            partitionRequestClient.requestSubpartition(\n+                    partitionId, subpartitionIndex, this, getCurrentBackoff());\n+        } else {\n+            failPartitionRequest();\n+        }\n+    }\n+\n+    @Override\n+    Optional<BufferAndAvailability> getNextBuffer() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        final SequenceBuffer next;\n+        final DataType nextDataType;\n+\n+        synchronized (receivedBuffers) {\n+            next = receivedBuffers.poll();\n+            nextDataType =\n+                    receivedBuffers.peek() != null\n+                            ? receivedBuffers.peek().buffer.getDataType()\n+                            : DataType.NONE;\n+        }\n+\n+        if (next == null) {\n+            if (isReleased.get()) {\n+                throw new CancelTaskException(\n+                        \"Queried for a buffer after channel has been released.\");\n+            }\n+            return Optional.empty();\n+        }\n+\n+        NetworkActionsLogger.traceInput(\n+                \"RemoteInputChannel#getNextBuffer\",\n+                next.buffer,\n+                inputGate.getOwningTaskName(),\n+                channelInfo,\n+                channelStatePersister,\n+                next.sequenceNumber);\n+        numBytesIn.inc(next.buffer.getSize());\n+        numBuffersIn.inc();\n+        return Optional.of(\n+                new BufferAndAvailability(next.buffer, nextDataType, 0, next.sequenceNumber));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    void sendTaskEvent(TaskEvent event) throws IOException {\n+        checkState(\n+                !isReleased.get(),\n+                \"Tried to send task event to producer after channel has been released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.sendTaskEvent(partitionId, event, this);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased.get();\n+    }\n+\n+    /** Releases all exclusive and floating buffers, closes the partition request client. */\n+    @Override\n+    void releaseAllResources() throws IOException {\n+        if (isReleased.compareAndSet(false, true)) {\n+\n+            final ArrayDeque<Buffer> releasedBuffers;\n+            synchronized (receivedBuffers) {\n+                releasedBuffers =\n+                        receivedBuffers.stream()\n+                                .map(sb -> sb.buffer)\n+                                .collect(Collectors.toCollection(ArrayDeque::new));\n+                receivedBuffers.clear();\n+            }\n+            bufferManager.releaseAllBuffers(releasedBuffers);\n+\n+            // The released flag has to be set before closing the connection to ensure that\n+            // buffers received concurrently with closing are properly recycled.\n+            if (partitionRequestClient != null) {\n+                partitionRequestClient.close(this);\n+            } else {\n+                connectionManager.closeOpenChannelConnections(connectionId);\n+            }\n+        }\n+    }\n+\n+    private void failPartitionRequest() {\n+        setError(new PartitionNotFoundException(partitionId));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Credit-based\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n+     */\n+    private void notifyCreditAvailable() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.notifyCreditAvailable(this);\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfAvailableBuffers() {\n+        return bufferManager.getNumberOfAvailableBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfRequiredBuffers() {\n+        return bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getSenderBacklog() {\n+        return getNumberOfRequiredBuffers() - initialCredit;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isWaitingForFloatingBuffers() {\n+        return bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public Buffer getNextReceivedBuffer() {\n+        final SequenceBuffer sequenceBuffer = receivedBuffers.poll();\n+        return sequenceBuffer != null ? sequenceBuffer.buffer : null;\n+    }\n+\n+    @VisibleForTesting\n+    BufferManager getBufferManager() {\n+        return bufferManager;\n+    }\n+\n+    @VisibleForTesting\n+    PartitionRequestClient getPartitionRequestClient() {\n+        return partitionRequestClient;\n+    }\n+\n+    /**\n+     * The unannounced credit is increased by the given amount and might notify increased credit to\n+     * the producer.\n+     */\n+    @Override\n+    public void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n+        if (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+            notifyCreditAvailable();\n+        }\n+    }\n+\n+    @Override\n+    public void resumeConsumption() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (initialCredit == 0) {\n+            // this unannounced credit can be a positive value because credit assignment and the\n+            // increase of this value is not an atomic operation and as a result, this unannounced\n+            // credit value can be get increased even after this channel has been blocked and all\n+            // floating credits are released, it is important to clear this unannounced credit and\n+            // at the same time reset the sender's available credits to keep consistency\n+            unannouncedCredit.set(0);\n+        }\n+\n+        // notifies the producer that this channel is ready to\n+        // unblock from checkpoint and resume data consumption\n+        partitionRequestClient.resumeConsumption(this);\n+    }\n+\n+    @Override\n+    public void acknowledgeAllRecordsProcessed() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.acknowledgeAllRecordsProcessed(this);\n+    }\n+\n+    private void onBlockingUpstream() {\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network I/O notifications (called by network I/O thread)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the currently unannounced credit.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getUnannouncedCredit() {\n+        return unannouncedCredit.get();\n+    }\n+\n+    /**\n+     * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getAndResetUnannouncedCredit() {\n+        return unannouncedCredit.getAndSet(0);\n+    }\n+\n+    /**\n+     * Gets the current number of received buffers which have not been processed yet.\n+     *\n+     * @return Buffers queued for processing.\n+     */\n+    public int getNumberOfQueuedBuffers() {\n+        synchronized (receivedBuffers) {\n+            return receivedBuffers.size();\n+        }\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return Math.max(0, receivedBuffers.size());\n+    }\n+\n+    public int unsynchronizedGetExclusiveBuffersUsed() {\n+        return Math.max(\n+                0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n+    }\n+\n+    public int unsynchronizedGetFloatingBuffersAvailable() {\n+        return Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n+    }\n+\n+    public InputChannelID getInputChannelId() {\n+        return id;\n+    }\n+\n+    public int getInitialCredit() {\n+        return initialCredit;\n+    }\n+\n+    public BufferProvider getBufferProvider() throws IOException {\n+        if (isReleased.get()) {\n+            return null;\n+        }\n+\n+        return inputGate.getBufferProvider();\n+    }\n+\n+    /**\n+     * Requests buffer from input channel directly for receiving network data. It should always\n+     * return an available buffer in credit-based mode unless the channel has been released.\n+     *\n+     * @return The available buffer.\n+     */\n+    @Nullable\n+    public Buffer requestBuffer() {\n+        return bufferManager.requestBuffer();\n+    }\n+\n+    /**\n+     * Receives the backlog from the producer's buffer response. If the number of available buffers\n+     * is less than backlog + initialCredit, it will request floating buffers from the buffer\n+     * manager, and then notify unannounced credits to the producer.\n+     *\n+     * @param backlog The number of unsent buffers in the producer's sub partition.\n+     */\n+    public void onSenderBacklog(int backlog) throws IOException {\n+        notifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+    }\n+\n+    /**\n+     * Handles the input buffer. This method is taking over the ownership of the buffer and is fully\n+     * responsible for cleaning it up both on the happy path and in case of an error.\n+     */\n+    public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n+        boolean recycleBuffer = true;\n+\n+        try {\n+            if (expectedSequenceNumber != sequenceNumber) {\n+                onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                return;\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+                checkArgument(backlog == 0, \"Illegal number of backlog: %s, should be 0.\", backlog);\n+            }\n+\n+            final boolean wasEmpty;\n+            boolean firstPriorityEvent = false;\n+            synchronized (receivedBuffers) {\n+                NetworkActionsLogger.traceInput(\n+                        \"RemoteInputChannel#onBuffer\",\n+                        buffer,\n+                        inputGate.getOwningTaskName(),\n+                        channelInfo,\n+                        channelStatePersister,\n+                        sequenceNumber);\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after releaseAllResources() released all buffers from receivedBuffers\n+                // (see above for details).\n+                if (isReleased.get()) {\n+                    return;\n+                }\n+\n+                wasEmpty = receivedBuffers.isEmpty();\n+\n+                SequenceBuffer sequenceBuffer = new SequenceBuffer(buffer, sequenceNumber);\n+                DataType dataType = buffer.getDataType();\n+                if (dataType.hasPriority()) {\n+                    firstPriorityEvent = addPriorityBuffer(sequenceBuffer);\n+                    recycleBuffer = false;\n+                } else {\n+                    receivedBuffers.add(sequenceBuffer);\n+                    recycleBuffer = false;\n+                    if (dataType.requiresAnnouncement()) {\n+                        firstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n+                    }\n+                }\n+                channelStatePersister\n+                        .checkForBarrier(sequenceBuffer.buffer)\n+                        .filter(id -> id > lastBarrierId)\n+                        .ifPresent(\n+                                id -> {\n+                                    // checkpoint was not yet started by task thread,\n+                                    // so remember the numbers of buffers to spill for the time when\n+                                    // it will be started\n+                                    lastBarrierId = id;\n+                                    lastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+                                });\n+                channelStatePersister.maybePersist(buffer);\n+                ++expectedSequenceNumber;\n+            }\n+\n+            if (firstPriorityEvent) {\n+                notifyPriorityEvent(sequenceNumber);\n+            }\n+            if (wasEmpty) {\n+                notifyChannelNonEmpty();\n+            }\n+\n+            if (backlog >= 0) {\n+                onSenderBacklog(backlog);\n+            }\n+        } finally {\n+            if (recycleBuffer) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+    }\n+\n+    /** @return {@code true} if this was first priority buffer added. */\n+    private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) {\n+        receivedBuffers.addPriorityElement(sequenceBuffer);\n+        return receivedBuffers.getNumPriorityElements() == 1;\n+    }\n+\n+    private SequenceBuffer announce(SequenceBuffer sequenceBuffer) throws IOException {\n+        checkState(\n+                !sequenceBuffer.buffer.isBuffer(),\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        checkAnnouncedOnlyOnce(sequenceBuffer);\n+        AbstractEvent event =\n+                EventSerializer.fromBuffer(sequenceBuffer.buffer, getClass().getClassLoader());\n+        checkState(\n+                event instanceof CheckpointBarrier,\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        CheckpointBarrier barrier = (CheckpointBarrier) event;\n+        return new SequenceBuffer(\n+                EventSerializer.toBuffer(\n+                        new EventAnnouncement(barrier, sequenceBuffer.sequenceNumber), true),\n+                sequenceBuffer.sequenceNumber);\n+    }\n+\n+    private void checkAnnouncedOnlyOnce(SequenceBuffer sequenceBuffer) {\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        int count = 0;\n+        while (iterator.hasNext()) {\n+            if (iterator.next().sequenceNumber == sequenceBuffer.sequenceNumber) {\n+                count++;\n+            }\n+        }\n+        checkState(\n+                count == 1,\n+                \"Before enqueuing the announcement there should be exactly single occurrence of the buffer, but found [%d]\",\n+                count);\n+    }\n+\n+    /**\n+     * Spills all queued buffers on checkpoint start. If barrier has already been received (and\n+     * reordered), spill only the overtaken buffers.\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {\n+        synchronized (receivedBuffers) {\n+            if (barrier.getId() < lastBarrierId) {\n+                throw new CheckpointException(\n+                        String.format(\n+                                \"Sequence number for checkpoint %d is not known (it was likely been overwritten by a newer checkpoint %d)\",\n+                                barrier.getId(), lastBarrierId),\n+                        CheckpointFailureReason\n+                                .CHECKPOINT_SUBSUMED); // currently, at most one active unaligned\n+                // checkpoint is possible\n+            } else if (barrier.getId() > lastBarrierId) {\n+                // This channel has received some obsolete barrier, older compared to the\n+                // checkpointId\n+                // which we are processing right now, and we should ignore that obsoleted checkpoint\n+                // barrier sequence number.\n+                resetLastBarrier();\n+            }\n+\n+            channelStatePersister.startPersisting(\n+                    barrier.getId(), getInflightBuffersUnsafe(barrier.getId()));\n+        }\n+    }\n+\n+    public void checkpointStopped(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            channelStatePersister.stopPersisting(checkpointId);\n+            if (lastBarrierId == checkpointId) {\n+                resetLastBarrier();\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    List<Buffer> getInflightBuffers(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            return getInflightBuffersUnsafe(checkpointId);\n+        }\n+    }\n+\n+    @Override\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n+        boolean firstPriorityEvent;\n+        synchronized (receivedBuffers) {\n+            checkState(channelStatePersister.hasBarrierReceived());\n+            int numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n+            SequenceBuffer toPrioritize =\n+                    receivedBuffers.getAndRemove(\n+                            sequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n+            checkState(lastBarrierSequenceNumber == sequenceNumber);\n+            checkState(!toPrioritize.buffer.isBuffer());\n+            checkState(\n+                    numPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n+                    \"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n+                    toPrioritize,\n+                    numPriorityElementsBeforeRemoval);\n+            // set the priority flag (checked on poll)\n+            // don't convert the barrier itself (barrier controller might not have been switched\n+            // yet)\n+            AbstractEvent e =\n+                    EventSerializer.fromBuffer(\n+                            toPrioritize.buffer, this.getClass().getClassLoader());\n+            toPrioritize.buffer.setReaderIndex(0);\n+            toPrioritize =\n+                    new SequenceBuffer(\n+                            EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n+            firstPriorityEvent =\n+                    addPriorityBuffer(\n+                            toPrioritize); // note that only position of the element is changed\n+            // converting the event itself would require switching the controller sooner\n+        }\n+        if (firstPriorityEvent) {\n+            notifyPriorityEventForce(); // forcibly notify about the priority event\n+            // instead of passing barrier SQN to be checked\n+            // because this SQN might have be seen by the input gate during the announcement\n+        }\n+    }\n+\n+    private void notifyPriorityEventForce() {\n+        inputGate.notifyPriorityEventForce(this);\n+    }\n+\n+    /**\n+     * Returns a list of buffers, checking the first n non-priority buffers, and skipping all\n+     * events.\n+     */\n+    private List<Buffer> getInflightBuffersUnsafe(long checkpointId) {\n+        assert Thread.holdsLock(receivedBuffers);\n+\n+        checkState(checkpointId == lastBarrierId || lastBarrierId == NONE);\n+\n+        final List<Buffer> inflightBuffers = new ArrayList<>();\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        // skip all priority events (only buffers are stored anyways)\n+        Iterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n+\n+        while (iterator.hasNext()) {\n+            SequenceBuffer sequenceBuffer = iterator.next();\n+            if (sequenceBuffer.buffer.isBuffer()) {\n+                if (shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+                    inflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return inflightBuffers;\n+    }\n+\n+    private void resetLastBarrier() {\n+        lastBarrierId = NONE;\n+        lastBarrierSequenceNumber = NONE;\n+    }\n+\n+    /**\n+     * @return if given {@param sequenceNumber} should be spilled given {@link\n+     *     #lastBarrierSequenceNumber}. We might not have yet received {@link CheckpointBarrier} and\n+     *     we might need to spill everything. If we have already received it, there is a bit nasty\n+     *     corner case of {@link SequenceBuffer#sequenceNumber} overflowing that needs to be handled\n+     *     as well.\n+     */\n+    private boolean shouldBeSpilled(int sequenceNumber) {\n+        if (lastBarrierSequenceNumber == NONE) {\n+            return true;\n+        }\n+        checkState(\n+                receivedBuffers.size() < Integer.MAX_VALUE / 2,\n+                \"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+        boolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastBarrierSequenceNumber;\n+        boolean possibleOverflowBeforeOvertaking =\n+                lastBarrierSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+        if (possibleOverflowAfterOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber && sequenceNumber > 0;\n+        } else if (possibleOverflowBeforeOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber || sequenceNumber > 0;\n+        } else {\n+            return sequenceNumber < lastBarrierSequenceNumber;\n+        }\n+    }\n+\n+    public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n+        boolean success = false;\n+\n+        synchronized (receivedBuffers) {\n+            if (!isReleased.get()) {\n+                if (expectedSequenceNumber == sequenceNumber) {\n+                    expectedSequenceNumber++;\n+                    success = true;\n+                } else {\n+                    onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                }\n+            }\n+        }\n+\n+        if (success && backlog >= 0) {\n+            onSenderBacklog(backlog);\n+        }\n+    }\n+\n+    public void onFailedPartitionRequest() {\n+        inputGate.triggerPartitionStateCheck(partitionId);\n+    }\n+\n+    public void onError(Throwable cause) {\n+        setError(cause);\n+    }\n+\n+    private void checkPartitionRequestQueueInitialized() throws IOException {\n+        checkError();\n+        checkState(\n+                partitionRequestClient != null,\n+                \"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n+    }\n+\n+    private static class BufferReorderingException extends IOException {\n+\n+        private static final long serialVersionUID = -888282210356266816L;\n+\n+        private final int expectedSequenceNumber;\n+\n+        private final int actualSequenceNumber;\n+\n+        BufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n+            this.expectedSequenceNumber = expectedSequenceNumber;\n+            this.actualSequenceNumber = actualSequenceNumber;\n+        }\n+\n+        @Override\n+        public String getMessage() {\n+            return String.format(\n+                    \"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n+                    expectedSequenceNumber, actualSequenceNumber);\n+        }\n+    }\n+\n+    private static final class SequenceBuffer {\n+        final Buffer buffer;\n+        final int sequenceNumber;\n+\n+        private SequenceBuffer(Buffer buffer, int sequenceNumber) {\n+            this.buffer = buffer;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\n+                    \"SequenceBuffer(isEvent = %s, dataType = %s, sequenceNumber = %s)\",\n+                    !buffer.isBuffer(), buffer.getDataType(), sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "0ee049db1ffe8a4a68bcd97608774ee488d02a21", "committedDate": "2021-09-03 08:19:32 +0200", "message": "[FLINK-23907] Use primitive functional interfaces"}, {"oid": "138e83e2bc6feb59ecd839b03491cd8f23ee1c66", "committedDate": "2021-11-08 08:56:34 +0100", "message": "[FLINK-24738][runtime] Ignoring buffer size announcement if the channel is released already"}, {"oid": "4eea7bc9352134a06d2b207c9a94dd46a01c6132", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[FLINK-24657][runtime] Added metric of the total real size of input/output buffers queue"}, {"oid": "f4fd4f8bb66867821cb0f171218d85f8386b0897", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] Move consumedSubpartitionIndex from SingleInputGate to InputChannel"}, {"oid": "5c2ec72982128fc1a30014677916e0dd21f9c1d2", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] SingleInputGate supports consuming subpartition range"}, {"oid": "6398abcbff06b3e488a273144680f4838b4f1c92", "committedDate": "2023-06-09 22:48:37 +0800", "message": "[FLINK-31636][network] Introduce the NettyService framework"}]}, {"oid": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "url": "https://github.com/apache/flink/commit/3046802f6bfcf476af447fffbc9af3f20a96ed61", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-12T13:04:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1NjQyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424156429", "body": "fix the javadoc accordingly.", "bodyText": "fix the javadoc accordingly.", "bodyHTML": "<p dir=\"auto\">fix the javadoc accordingly.</p>", "author": "zhijiangW", "createdAt": "2020-05-13T03:46:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -127,7 +127,7 @@ private boolean shouldContinueRequest(BufferPool bufferPool) {\n \t/**\n \t * Requests exclusive buffers from the provider and returns the number of requested amount.", "originalCommit": "8a9dba521dd41e70cb5c4be10669372b1c674d22", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fc3e9f5b7933d0b74b53946e6f506916f73aba14", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 7207cad4bcf..37e357b2ea0 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -129,7 +132,6 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t */\n \tvoid requestExclusiveBuffers() throws IOException {\n \t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");\n \n \t\tsynchronized (bufferQueue) {\n \t\t\tfor (MemorySegment segment : segments) {\n", "next_change": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 37e357b2ea0..7fb7cf9358b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -128,7 +125,7 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t}\n \n \t/**\n-\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n+\t * Requests exclusive buffers from the provider.\n \t */\n \tvoid requestExclusiveBuffers() throws IOException {\n \t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 7fb7cf9358b..ba6e75d3a43 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -44,394 +44,399 @@ import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += numRequired;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n-\t\t\tnumRequiredBuffers += bufferReleased;\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tnumRequiredBuffers = 0;\n-\t\t\tbufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint getNumberOfRequiredBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn numRequiredBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn isWaitingForFloatingBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffers() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer(int initialCredit) {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            if (initialCredit == 0) {\n+                checkState(\n+                        bufferQueue.getAvailableBufferSize() <= numRequiredBuffers,\n+                        \"Too many buffers allocated.\");\n+                --numRequiredBuffers;\n+            }\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        if (numExclusiveBuffers <= 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        int numAddedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                } else {\n+                    numAddedBuffers =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        try {\n+            inputChannel.notifyBufferAvailable(numAddedBuffers);\n+        } catch (Throwable t) {\n+            ExceptionUtils.rethrow(t);\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            bufferQueue.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            if (buffer.getRecycler() == this) {\n+                exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+            } else {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+        synchronized (bufferQueue) {\n+            bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+            bufferQueue.notifyAll();\n+        }\n+\n+        if (exclusiveRecyclingSegments.size() > 0) {\n+            globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n+         * number of available buffers in queue is more than the required amount.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return How many buffers were added to the queue\n+         */\n+        int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                Buffer floatingBuffer = floatingBuffers.poll();\n+                if (floatingBuffer != null) {\n+                    floatingBuffer.recycleBuffer();\n+                    return 0;\n+                }\n+            }\n+            return 1;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": {"commit": "8550965d808fe7b4d6ff2d48034612878937a579", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex ba6e75d3a43..8031f6b5d3c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -428,11 +448,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..82162f51ae3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,10 +448,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        Queue<Buffer> clearFloatingBuffers() {\n-            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n-            floatingBuffers.clear();\n-            return buffers;\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 82162f51ae3..0867fbba828 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,11 +458,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 7207cad4bcf..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -38,374 +38,435 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Queue;\n \n+import static org.apache.flink.util.ExceptionUtils.firstOrSuppressed;\n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of required buffers for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers = 1;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers = numRequired;\n-\n-\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n-\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\t\tnumRequestedBuffers++;\n-\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tnumRequiredBuffers = 0;\n-\t\t\tbufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tcheckState(isWaitingForFloatingBuffers, \"This channel should be waiting for floating buffers.\");\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (notificationResult != NotificationResult.BUFFER_NOT_USED) {\n-\t\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint unsynchronizedGetNumberOfRequiredBuffers() {\n-\t\treturn numRequiredBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean unsynchronizedIsWaitingForFloatingBuffers() {\n-\t\treturn isWaitingForFloatingBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (getAvailableBufferSize() > numRequiredBuffers) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tvoid releaseFloatingBuffers() {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer() {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            --numRequiredBuffers;\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        checkArgument(numExclusiveBuffers >= 0, \"Num exclusive buffers must be non-negative.\");\n+        if (numExclusiveBuffers == 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            // AvailableBufferQueue::addExclusiveBuffer may release the previously allocated\n+            // floating buffer, which requires the caller to recycle these released floating\n+            // buffers. There should be no floating buffers that have been allocated before the\n+            // exclusive buffers are initialized, so here only a simple assertion is required\n+            checkState(\n+                    unsynchronizedGetFloatingBuffersAvailable() == 0,\n+                    \"Bug in buffer allocation logic: floating buffer is allocated before exclusive buffers are initialized.\");\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        @Nullable Buffer releasedFloatingBuffer = null;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                    return;\n+                } else {\n+                    releasedFloatingBuffer =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        if (releasedFloatingBuffer != null) {\n+            releasedFloatingBuffer.recycleBuffer();\n+        } else {\n+            try {\n+                inputChannel.notifyBufferAvailable(1);\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            }\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        Queue<Buffer> buffers;\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            buffers = bufferQueue.clearFloatingBuffers();\n+        }\n+\n+        // recycle all buffers out of the synchronization block to avoid dead lock\n+        while (!buffers.isEmpty()) {\n+            buffers.poll().recycleBuffer();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Exception err = null;\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            try {\n+                if (buffer.getRecycler() == BufferManager.this) {\n+                    exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+                } else {\n+                    buffer.recycleBuffer();\n+                }\n+            } catch (Exception e) {\n+                err = firstOrSuppressed(e, err);\n+            }\n+        }\n+        try {\n+            synchronized (bufferQueue) {\n+                bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+                bufferQueue.notifyAll();\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        try {\n+            if (exclusiveRecyclingSegments.size() > 0) {\n+                globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        if (err != null) {\n+            throw err instanceof IOException ? (IOException) err : new IOException(err);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and releases one floating buffer if the\n+         * number of available buffers in queue is more than the required amount. If floating buffer\n+         * is released, the total amount of available buffers after adding this exclusive buffer has\n+         * not changed, and no new buffers are available. The caller is responsible for recycling\n+         * the release/returned floating buffer.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return An released floating buffer, may be null if the numRequiredBuffers is not met.\n+         */\n+        @Nullable\n+        Buffer addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                return floatingBuffers.poll();\n+            }\n+            return null;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "48a384dffc770289a38df816a38bd336ea992ed7", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[FLINK-23466][network] Fix the bug that buffer listeners may not be notified when recycling buffers"}, {"oid": "c91837edb782c67eab799a569077053695a29fc3", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[hotfix][refactor] Remove BufferListener#NotificationResult to simplify the code"}, {"oid": "38f7c593538d78e67ed75f006826b9fc3e97826e", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[hotfix] Rename some methods of NetworkBufferPool and add more comments for better readability"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1NzE1Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424157153", "body": "It is better to supplement the similar check to avoid this action is called multiple times in practice.\r\nMaybe we can check the available exclusive buffers should be 0 in `BufferManager` instead?", "bodyText": "It is better to supplement the similar check to avoid this action is called multiple times in practice.\nMaybe we can check the available exclusive buffers should be 0 in BufferManager instead?", "bodyHTML": "<p dir=\"auto\">It is better to supplement the similar check to avoid this action is called multiple times in practice.<br>\nMaybe we can check the available exclusive buffers should be 0 in <code>BufferManager</code> instead?</p>", "author": "zhijiangW", "createdAt": "2020-05-13T03:49:36Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -122,10 +124,7 @@ public RemoteInputChannel(\n \t * after this input channel is created.\n \t */\n \tvoid assignExclusiveSegments() throws IOException {\n-\t\tcheckState(initialCredit == 0, \"Bug in input channel setup logic: exclusive buffers have \" +", "originalCommit": "8a9dba521dd41e70cb5c4be10669372b1c674d22", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex c58fdffa5fc..861d407262c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -124,6 +126,9 @@ public class RemoteInputChannel extends InputChannel {\n \t * after this input channel is created.\n \t */\n \tvoid assignExclusiveSegments() throws IOException {\n+\t\tcheckState(bufferManager.unsynchronizedGetExclusiveBuffers() == 0, \"Bug in input channel setup logic: \" +\n+\t\t\t\"exclusive buffers have already been set for this input channel.\");\n+\n \t\tbufferManager.requestExclusiveBuffers();\n \t}\n \n", "next_change": {"commit": "2cb05ba959c5ac264eb8fa85d711f499301ed767", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 861d407262c..0c4f32d2f89 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -126,8 +126,8 @@ public class RemoteInputChannel extends InputChannel {\n \t * after this input channel is created.\n \t */\n \tvoid assignExclusiveSegments() throws IOException {\n-\t\tcheckState(bufferManager.unsynchronizedGetExclusiveBuffers() == 0, \"Bug in input channel setup logic: \" +\n-\t\t\t\"exclusive buffers have already been set for this input channel.\");\n+\t\tcheckState(bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+\t\t\t\"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n \n \t\tbufferManager.requestExclusiveBuffers();\n \t}\n", "next_change": {"commit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 0c4f32d2f89..6c34cce7152 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -129,7 +129,9 @@ public class RemoteInputChannel extends InputChannel {\n \t\tcheckState(bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n \t\t\t\"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n \n-\t\tbufferManager.requestExclusiveBuffers();\n+\t\tif (initialCredit > 0) {\n+\t\t\tbufferManager.requestExclusiveBuffers();\n+\t\t}\n \t}\n \n \t// ------------------------------------------------------------------------\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 6c34cce7152..3e976686f91 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -20,534 +20,781 @@ package org.apache.flink.runtime.io.network.partition.consumer;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.metrics.Counter;\n-import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.runtime.checkpoint.CheckpointException;\n+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;\n import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;\n+import org.apache.flink.runtime.event.AbstractEvent;\n import org.apache.flink.runtime.event.TaskEvent;\n+import org.apache.flink.runtime.execution.CancelTaskException;\n import org.apache.flink.runtime.io.network.ConnectionID;\n import org.apache.flink.runtime.io.network.ConnectionManager;\n import org.apache.flink.runtime.io.network.PartitionRequestClient;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+import org.apache.flink.runtime.io.network.api.EventAnnouncement;\n+import org.apache.flink.runtime.io.network.api.serialization.EventSerializer;\n import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.Buffer.DataType;\n import org.apache.flink.runtime.io.network.buffer.BufferProvider;\n-import org.apache.flink.runtime.io.network.buffer.BufferReceivedListener;\n-import org.apache.flink.runtime.io.network.netty.NettyMessage.ResumeConsumption;\n+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;\n import org.apache.flink.runtime.io.network.partition.PartitionNotFoundException;\n+import org.apache.flink.runtime.io.network.partition.PrioritizedDeque;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n \n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterators;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n-/**\n- * An input channel, which requests a remote partition queue.\n- */\n+/** An input channel, which requests a remote partition queue. */\n public class RemoteInputChannel extends InputChannel {\n-\n-\t/** ID to distinguish this channel from other channels sharing the same TCP connection. */\n-\tprivate final InputChannelID id = new InputChannelID();\n-\n-\t/** The connection to use to request the remote partition. */\n-\tprivate final ConnectionID connectionId;\n-\n-\t/** The connection manager to use connect to the remote partition provider. */\n-\tprivate final ConnectionManager connectionManager;\n-\n-\t/**\n-\t * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n-\t * is consumed by the receiving task thread.\n-\t */\n-\tprivate final ArrayDeque<Buffer> receivedBuffers = new ArrayDeque<>();\n-\n-\t/**\n-\t * Flag indicating whether this channel has been released. Either called by the receiving task\n-\t * thread or the task manager actor.\n-\t */\n-\tprivate final AtomicBoolean isReleased = new AtomicBoolean();\n-\n-\t/** Client to establish a (possibly shared) TCP connection and request the partition. */\n-\tprivate volatile PartitionRequestClient partitionRequestClient;\n-\n-\t/**\n-\t * The next expected sequence number for the next buffer. This is modified by the network\n-\t * I/O thread only.\n-\t */\n-\tprivate int expectedSequenceNumber = 0;\n-\n-\t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate final int initialCredit;\n-\n-\t/** The number of available buffers that have not been announced to the producer yet. */\n-\tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n-\n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n-\n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n-\n-\tprivate final BufferManager bufferManager;\n-\n-\tpublic RemoteInputChannel(\n-\t\tSingleInputGate inputGate,\n-\t\tint channelIndex,\n-\t\tResultPartitionID partitionId,\n-\t\tConnectionID connectionId,\n-\t\tConnectionManager connectionManager,\n-\t\tint initialBackOff,\n-\t\tint maxBackoff,\n-\t\tint networkBuffersPerChannel,\n-\t\tCounter numBytesIn,\n-\t\tCounter numBuffersIn) {\n-\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, numBytesIn, numBuffersIn);\n-\n-\t\tthis.initialCredit = networkBuffersPerChannel;\n-\t\tthis.connectionId = checkNotNull(connectionId);\n-\t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n-\t}\n-\n-\t/**\n-\t * Assigns exclusive buffers to this input channel, and this method should be called only once\n-\t * after this input channel is created.\n-\t */\n-\tvoid assignExclusiveSegments() throws IOException {\n-\t\tcheckState(bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n-\t\t\t\"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n-\n-\t\tif (initialCredit > 0) {\n-\t\t\tbufferManager.requestExclusiveBuffers();\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests a remote subpartition.\n-\t */\n-\t@VisibleForTesting\n-\t@Override\n-\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n-\t\tif (partitionRequestClient == null) {\n-\t\t\t// Create a client and request the partition\n-\t\t\ttry {\n-\t\t\t\tpartitionRequestClient = connectionManager.createPartitionRequestClient(connectionId);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\t// IOExceptions indicate that we could not open a connection to the remote TaskExecutor\n-\t\t\t\tthrow new PartitionConnectionException(partitionId, e);\n-\t\t\t}\n-\n-\t\t\tpartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Retriggers a remote subpartition request.\n-\t */\n-\tvoid retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n-\t\tcheckState(partitionRequestClient != null, \"Missing initial subpartition request.\");\n-\n-\t\tif (increaseBackoff()) {\n-\t\t\tpartitionRequestClient.requestSubpartition(\n-\t\t\t\tpartitionId, subpartitionIndex, this, getCurrentBackoff());\n-\t\t} else {\n-\t\t\tfailPartitionRequest();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tOptional<BufferAndAvailability> getNextBuffer() throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Queried for a buffer after channel has been closed.\");\n-\t\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tfinal Buffer next;\n-\t\tfinal boolean moreAvailable;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tnext = receivedBuffers.poll();\n-\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n-\t\t}\n-\n-\t\tnumBytesIn.inc(next.getSize());\n-\t\tnumBuffersIn.inc();\n-\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable));\n-\t}\n-\n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlastRequestedCheckpointId = checkpointId;\n-\n-\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\tcheckpointId,\n-\t\t\t\tchannelInfo,\n-\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tvoid sendTaskEvent(TaskEvent event) throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Tried to send task event to producer after channel has been released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tpartitionRequestClient.sendTaskEvent(partitionId, event, this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n-\t}\n-\n-\t/**\n-\t * Releases all exclusive and floating buffers, closes the partition request client.\n-\t */\n-\t@Override\n-\tvoid releaseAllResources() throws IOException {\n-\t\tif (isReleased.compareAndSet(false, true)) {\n-\n-\t\t\tArrayDeque<Buffer> releasedBuffers;\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\treleasedBuffers = receivedBuffers;\n-\t\t\t}\n-\t\t\tbufferManager.releaseAllBuffers(releasedBuffers);\n-\n-\t\t\t// The released flag has to be set before closing the connection to ensure that\n-\t\t\t// buffers received concurrently with closing are properly recycled.\n-\t\t\tif (partitionRequestClient != null) {\n-\t\t\t\tpartitionRequestClient.close(this);\n-\t\t\t} else {\n-\t\t\t\tconnectionManager.closeOpenChannelConnections(connectionId);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void failPartitionRequest() {\n-\t\tsetError(new PartitionNotFoundException(partitionId));\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Credit-based\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n-\t */\n-\tprivate void notifyCreditAvailable() {\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tpartitionRequestClient.notifyCreditAvailable(this);\n-\t}\n-\n-\tpublic int getNumberOfAvailableBuffers() {\n-\t\treturn bufferManager.getNumberOfAvailableBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn bufferManager.getNumberOfRequiredBuffers();\n-\t}\n-\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\treturn bufferManager.isWaitingForFloatingBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n-\t}\n-\n-\t@VisibleForTesting\n-\tBufferManager getBufferManager() {\n-\t\treturn bufferManager;\n-\t}\n-\n-\t@VisibleForTesting\n-\tPartitionRequestClient getPartitionRequestClient() {\n-\t\treturn partitionRequestClient;\n-\t}\n-\n-\t/**\n-\t * The unannounced credit is increased by the given amount and might notify\n-\t * increased credit to the producer.\n-\t */\n-\t@Override\n-\tpublic void notifyBufferAvailable(int numAvailableBuffers) {\n-\t\tif (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\tprivate void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tbufferManager.releaseFloatingBuffers(true);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption() {\n-\t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n-\n-\t\t// notifies the producer that this channel is ready to\n-\t\t// unblock from checkpoint and resume data consumption\n-\t\tpartitionRequestClient.resumeConsumption(this);\n-\t}\n-\n-\t/**\n-\t * Called by netty thread to request buffers and generate {@link ResumeConsumption} message.\n-\t */\n-\tpublic ResumeConsumption getResumeConsumptionMessage() throws IOException {\n-\t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n-\t\tcheckState(getNumberOfAvailableBuffers() == initialCredit, \"Illegal number of available buffers.\");\n-\t\tcheckState(!isWaitingForFloatingBuffers(), \"Should not be waiting for floating buffers.\");\n-\n-\t\tif (initialCredit > 0) {\n-\t\t\treturn new ResumeConsumption(id, initialCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t\t}\n-\n-\t\tint availableCredit = bufferManager.requestFloatingBuffers(0);\n-\t\treturn new ResumeConsumption(id, availableCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network I/O notifications (called by network I/O thread)\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Gets the currently unannounced credit.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getUnannouncedCredit() {\n-\t\treturn unannouncedCredit.get();\n-\t}\n-\n-\t/**\n-\t * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n-\t}\n-\n-\t/**\n-\t * Gets the current number of received buffers which have not been processed yet.\n-\t *\n-\t * @return Buffers queued for processing.\n-\t */\n-\tpublic int getNumberOfQueuedBuffers() {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treturn receivedBuffers.size();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn Math.max(0, receivedBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n-\t}\n-\n-\tpublic int unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n-\t}\n-\n-\tpublic InputChannelID getInputChannelId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic int getInitialCredit() {\n-\t\treturn initialCredit;\n-\t}\n-\n-\tpublic BufferProvider getBufferProvider() throws IOException {\n-\t\tif (isReleased.get()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn inputGate.getBufferProvider();\n-\t}\n-\n-\t/**\n-\t * Requests buffer from input channel directly for receiving network data.\n-\t * It should always return an available buffer in credit-based mode unless\n-\t * the channel has been released.\n-\t *\n-\t * @return The available buffer.\n-\t */\n-\t@Nullable\n-\tpublic Buffer requestBuffer() {\n-\t\treturn bufferManager.requestBuffer();\n-\t}\n-\n-\t/**\n-\t * Receives the backlog from the producer's buffer response. Floating buffers will\n-\t * be requested from the {@link BufferManager} according to the announced backlog,\n-\t * and then it will notify unannounced credits to the producer.\n-\t *\n-\t * @param backlog Number of the announced backlog from producer.\n-\t */\n-\tpublic void onSenderBacklog(int backlog) throws IOException {\n-\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));\n-\t}\n-\n-\tpublic void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean recycleBuffer = true;\n-\n-\t\ttry {\n-\t\t\tif (expectedSequenceNumber != sequenceNumber) {\n-\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tfinal boolean wasEmpty;\n-\t\t\tfinal CheckpointBarrier notifyReceivedBarrier;\n-\t\t\tfinal Buffer notifyReceivedBuffer;\n-\t\t\tfinal CheckpointBarrier barrier;\n-\t\t\tfinal BufferReceivedListener listener = inputGate.getBufferReceivedListener();\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after releaseAllResources() released all buffers from receivedBuffers\n-\t\t\t\t// (see above for details).\n-\t\t\t\tif (isReleased.get()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n-\n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n-\t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n-\t\t\t\tbarrier = listener != null ? notifyReceivedBarrier : parseCheckpointBarrierOrNull(buffer);\n-\t\t\t}\n-\t\t\trecycleBuffer = false;\n-\n-\t\t\t++expectedSequenceNumber;\n-\n-\t\t\tif (wasEmpty) {\n-\t\t\t\tnotifyChannelNonEmpty();\n-\t\t\t}\n-\n-\t\t\tif (backlog >= 0) {\n-\t\t\t\tonSenderBacklog(backlog);\n-\t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n-\n-\t\t\tif (barrier != null) {\n-\t\t\t\tonCheckpointBarrier(barrier);\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tif (recycleBuffer) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean success = false;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tif (!isReleased.get()) {\n-\t\t\t\tif (expectedSequenceNumber == sequenceNumber) {\n-\t\t\t\t\texpectedSequenceNumber++;\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t} else {\n-\t\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (success && backlog >= 0) {\n-\t\t\tonSenderBacklog(backlog);\n-\t\t}\n-\t}\n-\n-\tpublic void onFailedPartitionRequest() {\n-\t\tinputGate.triggerPartitionStateCheck(partitionId);\n-\t}\n-\n-\tpublic void onError(Throwable cause) {\n-\t\tsetError(cause);\n-\t}\n-\n-\tprivate static class BufferReorderingException extends IOException {\n-\n-\t\tprivate static final long serialVersionUID = -888282210356266816L;\n-\n-\t\tprivate final int expectedSequenceNumber;\n-\n-\t\tprivate final int actualSequenceNumber;\n-\n-\t\tBufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n-\t\t\tthis.expectedSequenceNumber = expectedSequenceNumber;\n-\t\t\tthis.actualSequenceNumber = actualSequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String getMessage() {\n-\t\t\treturn String.format(\"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n-\t\t\t\texpectedSequenceNumber, actualSequenceNumber);\n-\t\t}\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(RemoteInputChannel.class);\n+\n+    private static final int NONE = -1;\n+\n+    /** ID to distinguish this channel from other channels sharing the same TCP connection. */\n+    private final InputChannelID id = new InputChannelID();\n+\n+    /** The connection to use to request the remote partition. */\n+    private final ConnectionID connectionId;\n+\n+    /** The connection manager to use connect to the remote partition provider. */\n+    private final ConnectionManager connectionManager;\n+\n+    /**\n+     * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n+     * is consumed by the receiving task thread.\n+     */\n+    private final PrioritizedDeque<SequenceBuffer> receivedBuffers = new PrioritizedDeque<>();\n+\n+    /**\n+     * Flag indicating whether this channel has been released. Either called by the receiving task\n+     * thread or the task manager actor.\n+     */\n+    private final AtomicBoolean isReleased = new AtomicBoolean();\n+\n+    /** Client to establish a (possibly shared) TCP connection and request the partition. */\n+    private volatile PartitionRequestClient partitionRequestClient;\n+\n+    /** The next expected sequence number for the next buffer. */\n+    private int expectedSequenceNumber = 0;\n+\n+    /** The initial number of exclusive buffers assigned to this channel. */\n+    private final int initialCredit;\n+\n+    /** The number of available buffers that have not been announced to the producer yet. */\n+    private final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n+\n+    private final BufferManager bufferManager;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private int lastBarrierSequenceNumber = NONE;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private long lastBarrierId = NONE;\n+\n+    private final ChannelStatePersister channelStatePersister;\n+\n+    private boolean isUpstreamBlocked;\n+\n+    public RemoteInputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            ConnectionID connectionId,\n+            ConnectionManager connectionManager,\n+            int initialBackOff,\n+            int maxBackoff,\n+            int networkBuffersPerChannel,\n+            Counter numBytesIn,\n+            Counter numBuffersIn,\n+            ChannelStateWriter stateWriter) {\n+\n+        super(\n+                inputGate,\n+                channelIndex,\n+                partitionId,\n+                initialBackOff,\n+                maxBackoff,\n+                numBytesIn,\n+                numBuffersIn);\n+        checkArgument(networkBuffersPerChannel >= 0, \"Must be non-negative.\");\n+\n+        this.initialCredit = networkBuffersPerChannel;\n+        this.connectionId = checkNotNull(connectionId);\n+        this.connectionManager = checkNotNull(connectionManager);\n+        this.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n+        this.channelStatePersister = new ChannelStatePersister(stateWriter, getChannelInfo());\n+    }\n+\n+    @VisibleForTesting\n+    void setExpectedSequenceNumber(int expectedSequenceNumber) {\n+        this.expectedSequenceNumber = expectedSequenceNumber;\n+    }\n+\n+    /**\n+     * Setup includes assigning exclusive buffers to this input channel, and this method should be\n+     * called only once after this input channel is created.\n+     */\n+    @Override\n+    void setup() throws IOException {\n+        checkState(\n+                bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+                \"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n+\n+        bufferManager.requestExclusiveBuffers(initialCredit);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /** Requests a remote subpartition. */\n+    @VisibleForTesting\n+    @Override\n+    public void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException {\n+        if (partitionRequestClient == null) {\n+            LOG.debug(\n+                    \"{}: Requesting REMOTE subpartition {} of partition {}. {}\",\n+                    this,\n+                    subpartitionIndex,\n+                    partitionId,\n+                    channelStatePersister);\n+            // Create a client and request the partition\n+            try {\n+                partitionRequestClient =\n+                        connectionManager.createPartitionRequestClient(connectionId);\n+            } catch (IOException e) {\n+                // IOExceptions indicate that we could not open a connection to the remote\n+                // TaskExecutor\n+                throw new PartitionConnectionException(partitionId, e);\n+            }\n+\n+            partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n+        }\n+    }\n+\n+    /** Retriggers a remote subpartition request. */\n+    void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (increaseBackoff()) {\n+            partitionRequestClient.requestSubpartition(\n+                    partitionId, subpartitionIndex, this, getCurrentBackoff());\n+        } else {\n+            failPartitionRequest();\n+        }\n+    }\n+\n+    @Override\n+    Optional<BufferAndAvailability> getNextBuffer() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        final SequenceBuffer next;\n+        final DataType nextDataType;\n+\n+        synchronized (receivedBuffers) {\n+            next = receivedBuffers.poll();\n+            nextDataType =\n+                    receivedBuffers.peek() != null\n+                            ? receivedBuffers.peek().buffer.getDataType()\n+                            : DataType.NONE;\n+        }\n+\n+        if (next == null) {\n+            if (isReleased.get()) {\n+                throw new CancelTaskException(\n+                        \"Queried for a buffer after channel has been released.\");\n+            }\n+            return Optional.empty();\n+        }\n+\n+        numBytesIn.inc(next.buffer.getSize());\n+        numBuffersIn.inc();\n+        return Optional.of(\n+                new BufferAndAvailability(next.buffer, nextDataType, 0, next.sequenceNumber));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    void sendTaskEvent(TaskEvent event) throws IOException {\n+        checkState(\n+                !isReleased.get(),\n+                \"Tried to send task event to producer after channel has been released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.sendTaskEvent(partitionId, event, this);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased.get();\n+    }\n+\n+    /** Releases all exclusive and floating buffers, closes the partition request client. */\n+    @Override\n+    void releaseAllResources() throws IOException {\n+        if (isReleased.compareAndSet(false, true)) {\n+\n+            final ArrayDeque<Buffer> releasedBuffers;\n+            synchronized (receivedBuffers) {\n+                releasedBuffers =\n+                        receivedBuffers.stream()\n+                                .map(sb -> sb.buffer)\n+                                .collect(Collectors.toCollection(ArrayDeque::new));\n+                receivedBuffers.clear();\n+            }\n+            bufferManager.releaseAllBuffers(releasedBuffers);\n+\n+            // The released flag has to be set before closing the connection to ensure that\n+            // buffers received concurrently with closing are properly recycled.\n+            if (partitionRequestClient != null) {\n+                partitionRequestClient.close(this);\n+            } else {\n+                connectionManager.closeOpenChannelConnections(connectionId);\n+            }\n+        }\n+    }\n+\n+    private void failPartitionRequest() {\n+        setError(new PartitionNotFoundException(partitionId));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Credit-based\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n+     */\n+    private void notifyCreditAvailable() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.notifyCreditAvailable(this);\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfAvailableBuffers() {\n+        return bufferManager.getNumberOfAvailableBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfRequiredBuffers() {\n+        return bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getSenderBacklog() {\n+        return getNumberOfRequiredBuffers() - initialCredit;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isWaitingForFloatingBuffers() {\n+        return bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public Buffer getNextReceivedBuffer() {\n+        final SequenceBuffer sequenceBuffer = receivedBuffers.poll();\n+        return sequenceBuffer != null ? sequenceBuffer.buffer : null;\n+    }\n+\n+    @VisibleForTesting\n+    BufferManager getBufferManager() {\n+        return bufferManager;\n+    }\n+\n+    @VisibleForTesting\n+    PartitionRequestClient getPartitionRequestClient() {\n+        return partitionRequestClient;\n+    }\n+\n+    /**\n+     * The unannounced credit is increased by the given amount and might notify increased credit to\n+     * the producer.\n+     */\n+    @Override\n+    public void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n+        if (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+            notifyCreditAvailable();\n+        }\n+    }\n+\n+    @Override\n+    public void resumeConsumption() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        // notifies the producer that this channel is ready to\n+        // unblock from checkpoint and resume data consumption\n+        partitionRequestClient.resumeConsumption(this);\n+    }\n+\n+    private void onBlockingUpstream() {\n+        isUpstreamBlocked = true;\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    public void onConsumptionResumed() {\n+        isUpstreamBlocked = false;\n+        if (initialCredit == 0) {\n+            unannouncedCredit.set(0);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network I/O notifications (called by network I/O thread)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the currently unannounced credit.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getUnannouncedCredit() {\n+        return unannouncedCredit.get();\n+    }\n+\n+    /**\n+     * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getAndResetUnannouncedCredit() {\n+        return unannouncedCredit.getAndSet(0);\n+    }\n+\n+    /**\n+     * Gets the current number of received buffers which have not been processed yet.\n+     *\n+     * @return Buffers queued for processing.\n+     */\n+    public int getNumberOfQueuedBuffers() {\n+        synchronized (receivedBuffers) {\n+            return receivedBuffers.size();\n+        }\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return Math.max(0, receivedBuffers.size());\n+    }\n+\n+    public int unsynchronizedGetExclusiveBuffersUsed() {\n+        return Math.max(\n+                0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n+    }\n+\n+    public int unsynchronizedGetFloatingBuffersAvailable() {\n+        return Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n+    }\n+\n+    public InputChannelID getInputChannelId() {\n+        return id;\n+    }\n+\n+    public int getInitialCredit() {\n+        return initialCredit;\n+    }\n+\n+    public BufferProvider getBufferProvider() throws IOException {\n+        if (isReleased.get()) {\n+            return null;\n+        }\n+\n+        return inputGate.getBufferProvider();\n+    }\n+\n+    /**\n+     * Requests buffer from input channel directly for receiving network data. It should always\n+     * return an available buffer in credit-based mode unless the channel has been released.\n+     *\n+     * @return The available buffer.\n+     */\n+    @Nullable\n+    public Buffer requestBuffer() {\n+        return bufferManager.requestBuffer(initialCredit);\n+    }\n+\n+    /**\n+     * Receives the backlog from the producer's buffer response. If the number of available buffers\n+     * is less than backlog + initialCredit, it will request floating buffers from the buffer\n+     * manager, and then notify unannounced credits to the producer.\n+     *\n+     * @param backlog The number of unsent buffers in the producer's sub partition.\n+     */\n+    public void onSenderBacklog(int backlog) throws IOException {\n+        // never allocate any new buffers if upstream has been blocked\n+        if (!isUpstreamBlocked) {\n+            notifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+        }\n+    }\n+\n+    public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n+        boolean recycleBuffer = true;\n+\n+        try {\n+            if (expectedSequenceNumber != sequenceNumber) {\n+                onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                return;\n+            }\n+\n+            final boolean wasEmpty;\n+            boolean firstPriorityEvent = false;\n+            synchronized (receivedBuffers) {\n+                NetworkActionsLogger.traceInput(\n+                        \"RemoteInputChannel#onBuffer\",\n+                        buffer,\n+                        inputGate.getOwningTaskName(),\n+                        channelInfo,\n+                        channelStatePersister,\n+                        sequenceNumber);\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after releaseAllResources() released all buffers from receivedBuffers\n+                // (see above for details).\n+                if (isReleased.get()) {\n+                    return;\n+                }\n+\n+                wasEmpty = receivedBuffers.isEmpty();\n+\n+                SequenceBuffer sequenceBuffer = new SequenceBuffer(buffer, sequenceNumber);\n+                DataType dataType = buffer.getDataType();\n+                if (dataType.hasPriority()) {\n+                    firstPriorityEvent = addPriorityBuffer(sequenceBuffer);\n+                } else {\n+                    receivedBuffers.add(sequenceBuffer);\n+                    if (dataType.requiresAnnouncement()) {\n+                        firstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n+                    }\n+                }\n+                channelStatePersister\n+                        .checkForBarrier(sequenceBuffer.buffer)\n+                        .filter(id -> id > lastBarrierId)\n+                        .ifPresent(\n+                                id -> {\n+                                    // checkpoint was not yet started by task thread,\n+                                    // so remember the numbers of buffers to spill for the time when\n+                                    // it will be started\n+                                    lastBarrierId = id;\n+                                    lastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+                                });\n+                channelStatePersister.maybePersist(buffer);\n+                ++expectedSequenceNumber;\n+            }\n+            recycleBuffer = false;\n+\n+            if (firstPriorityEvent) {\n+                notifyPriorityEvent(sequenceNumber);\n+            }\n+            if (wasEmpty) {\n+                notifyChannelNonEmpty();\n+            }\n+\n+            if (backlog >= 0) {\n+                onSenderBacklog(backlog);\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+            }\n+        } finally {\n+            if (recycleBuffer) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+    }\n+\n+    /** @return {@code true} if this was first priority buffer added. */\n+    private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) {\n+        receivedBuffers.addPriorityElement(sequenceBuffer);\n+        return receivedBuffers.getNumPriorityElements() == 1;\n+    }\n+\n+    private SequenceBuffer announce(SequenceBuffer sequenceBuffer) throws IOException {\n+        checkState(\n+                !sequenceBuffer.buffer.isBuffer(),\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        checkAnnouncedOnlyOnce(sequenceBuffer);\n+        AbstractEvent event =\n+                EventSerializer.fromBuffer(sequenceBuffer.buffer, getClass().getClassLoader());\n+        checkState(\n+                event instanceof CheckpointBarrier,\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        CheckpointBarrier barrier = (CheckpointBarrier) event;\n+        return new SequenceBuffer(\n+                EventSerializer.toBuffer(\n+                        new EventAnnouncement(barrier, sequenceBuffer.sequenceNumber), true),\n+                sequenceBuffer.sequenceNumber);\n+    }\n+\n+    private void checkAnnouncedOnlyOnce(SequenceBuffer sequenceBuffer) {\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        int count = 0;\n+        while (iterator.hasNext()) {\n+            if (iterator.next().sequenceNumber == sequenceBuffer.sequenceNumber) {\n+                count++;\n+            }\n+        }\n+        checkState(\n+                count == 1,\n+                \"Before enqueuing the announcement there should be exactly single occurrence of the buffer, but found [%d]\",\n+                count);\n+    }\n+\n+    /**\n+     * Spills all queued buffers on checkpoint start. If barrier has already been received (and\n+     * reordered), spill only the overtaken buffers.\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {\n+        synchronized (receivedBuffers) {\n+            if (barrier.getId() < lastBarrierId) {\n+                throw new CheckpointException(\n+                        String.format(\n+                                \"Sequence number for checkpoint %d is not known (it was likely been overwritten by a newer checkpoint %d)\",\n+                                barrier.getId(), lastBarrierId),\n+                        CheckpointFailureReason\n+                                .CHECKPOINT_SUBSUMED); // currently, at most one active unaligned\n+                // checkpoint is possible\n+            } else if (barrier.getId() > lastBarrierId) {\n+                // This channel has received some obsolete barrier, older compared to the\n+                // checkpointId\n+                // which we are processing right now, and we should ignore that obsoleted checkpoint\n+                // barrier sequence number.\n+                resetLastBarrier();\n+            }\n+\n+            channelStatePersister.startPersisting(\n+                    barrier.getId(), getInflightBuffersUnsafe(barrier.getId()));\n+        }\n+    }\n+\n+    public void checkpointStopped(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            channelStatePersister.stopPersisting(checkpointId);\n+            if (lastBarrierId == checkpointId) {\n+                resetLastBarrier();\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    List<Buffer> getInflightBuffers(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            return getInflightBuffersUnsafe(checkpointId);\n+        }\n+    }\n+\n+    @Override\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n+        boolean firstPriorityEvent;\n+        synchronized (receivedBuffers) {\n+            checkState(channelStatePersister.hasBarrierReceived());\n+            int numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n+            SequenceBuffer toPrioritize =\n+                    receivedBuffers.getAndRemove(\n+                            sequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n+            checkState(lastBarrierSequenceNumber == sequenceNumber);\n+            checkState(!toPrioritize.buffer.isBuffer());\n+            checkState(\n+                    numPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n+                    \"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n+                    toPrioritize,\n+                    numPriorityElementsBeforeRemoval);\n+            // set the priority flag (checked on poll)\n+            // don't convert the barrier itself (barrier controller might not have been switched\n+            // yet)\n+            AbstractEvent e =\n+                    EventSerializer.fromBuffer(\n+                            toPrioritize.buffer, this.getClass().getClassLoader());\n+            toPrioritize.buffer.setReaderIndex(0);\n+            toPrioritize =\n+                    new SequenceBuffer(\n+                            EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n+            firstPriorityEvent =\n+                    addPriorityBuffer(\n+                            toPrioritize); // note that only position of the element is changed\n+            // converting the event itself would require switching the controller sooner\n+        }\n+        if (firstPriorityEvent) {\n+            notifyPriorityEventForce(); // forcibly notify about the priority event\n+            // instead of passing barrier SQN to be checked\n+            // because this SQN might have be seen by the input gate during the announcement\n+        }\n+    }\n+\n+    private void notifyPriorityEventForce() {\n+        inputGate.notifyPriorityEventForce(this);\n+    }\n+\n+    /**\n+     * Returns a list of buffers, checking the first n non-priority buffers, and skipping all\n+     * events.\n+     */\n+    private List<Buffer> getInflightBuffersUnsafe(long checkpointId) {\n+        assert Thread.holdsLock(receivedBuffers);\n+\n+        checkState(checkpointId == lastBarrierId || lastBarrierId == NONE);\n+\n+        final List<Buffer> inflightBuffers = new ArrayList<>();\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        // skip all priority events (only buffers are stored anyways)\n+        Iterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n+\n+        while (iterator.hasNext()) {\n+            SequenceBuffer sequenceBuffer = iterator.next();\n+            if (sequenceBuffer.buffer.isBuffer()) {\n+                if (shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+                    inflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return inflightBuffers;\n+    }\n+\n+    private void resetLastBarrier() {\n+        lastBarrierId = NONE;\n+        lastBarrierSequenceNumber = NONE;\n+    }\n+\n+    /**\n+     * @return if given {@param sequenceNumber} should be spilled given {@link\n+     *     #lastBarrierSequenceNumber}. We might not have yet received {@link CheckpointBarrier} and\n+     *     we might need to spill everything. If we have already received it, there is a bit nasty\n+     *     corner case of {@link SequenceBuffer#sequenceNumber} overflowing that needs to be handled\n+     *     as well.\n+     */\n+    private boolean shouldBeSpilled(int sequenceNumber) {\n+        if (lastBarrierSequenceNumber == NONE) {\n+            return true;\n+        }\n+        checkState(\n+                receivedBuffers.size() < Integer.MAX_VALUE / 2,\n+                \"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+        boolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastBarrierSequenceNumber;\n+        boolean possibleOverflowBeforeOvertaking =\n+                lastBarrierSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+        if (possibleOverflowAfterOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber && sequenceNumber > 0;\n+        } else if (possibleOverflowBeforeOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber || sequenceNumber > 0;\n+        } else {\n+            return sequenceNumber < lastBarrierSequenceNumber;\n+        }\n+    }\n+\n+    public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n+        boolean success = false;\n+\n+        synchronized (receivedBuffers) {\n+            if (!isReleased.get()) {\n+                if (expectedSequenceNumber == sequenceNumber) {\n+                    expectedSequenceNumber++;\n+                    success = true;\n+                } else {\n+                    onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                }\n+            }\n+        }\n+\n+        if (success && backlog >= 0) {\n+            onSenderBacklog(backlog);\n+        }\n+    }\n+\n+    public void onFailedPartitionRequest() {\n+        inputGate.triggerPartitionStateCheck(partitionId);\n+    }\n+\n+    public void onError(Throwable cause) {\n+        setError(cause);\n+    }\n+\n+    private void checkPartitionRequestQueueInitialized() throws IOException {\n+        checkError();\n+        checkState(\n+                partitionRequestClient != null,\n+                \"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n+    }\n+\n+    private static class BufferReorderingException extends IOException {\n+\n+        private static final long serialVersionUID = -888282210356266816L;\n+\n+        private final int expectedSequenceNumber;\n+\n+        private final int actualSequenceNumber;\n+\n+        BufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n+            this.expectedSequenceNumber = expectedSequenceNumber;\n+            this.actualSequenceNumber = actualSequenceNumber;\n+        }\n+\n+        @Override\n+        public String getMessage() {\n+            return String.format(\n+                    \"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n+                    expectedSequenceNumber, actualSequenceNumber);\n+        }\n+    }\n+\n+    private static final class SequenceBuffer {\n+        final Buffer buffer;\n+        final int sequenceNumber;\n+\n+        private SequenceBuffer(Buffer buffer, int sequenceNumber) {\n+            this.buffer = buffer;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\n+                    \"SequenceBuffer(isEvent = %s, dataType = %s, sequenceNumber = %s)\",\n+                    !buffer.isBuffer(), buffer.getDataType(), sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex c58fdffa5fc..f9cedf71105 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -20,508 +20,798 @@ package org.apache.flink.runtime.io.network.partition.consumer;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.checkpoint.CheckpointException;\n+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;\n import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;\n+import org.apache.flink.runtime.event.AbstractEvent;\n import org.apache.flink.runtime.event.TaskEvent;\n+import org.apache.flink.runtime.execution.CancelTaskException;\n import org.apache.flink.runtime.io.network.ConnectionID;\n import org.apache.flink.runtime.io.network.ConnectionManager;\n import org.apache.flink.runtime.io.network.PartitionRequestClient;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+import org.apache.flink.runtime.io.network.api.EventAnnouncement;\n+import org.apache.flink.runtime.io.network.api.serialization.EventSerializer;\n import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.Buffer.DataType;\n import org.apache.flink.runtime.io.network.buffer.BufferProvider;\n-import org.apache.flink.runtime.io.network.buffer.BufferReceivedListener;\n+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;\n import org.apache.flink.runtime.io.network.partition.PartitionNotFoundException;\n+import org.apache.flink.runtime.io.network.partition.PrioritizedDeque;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n \n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterators;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n-/**\n- * An input channel, which requests a remote partition queue.\n- */\n+/** An input channel, which requests a remote partition queue. */\n public class RemoteInputChannel extends InputChannel {\n-\n-\t/** ID to distinguish this channel from other channels sharing the same TCP connection. */\n-\tprivate final InputChannelID id = new InputChannelID();\n-\n-\t/** The connection to use to request the remote partition. */\n-\tprivate final ConnectionID connectionId;\n-\n-\t/** The connection manager to use connect to the remote partition provider. */\n-\tprivate final ConnectionManager connectionManager;\n-\n-\t/**\n-\t * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n-\t * is consumed by the receiving task thread.\n-\t */\n-\tprivate final ArrayDeque<Buffer> receivedBuffers = new ArrayDeque<>();\n-\n-\t/**\n-\t * Flag indicating whether this channel has been released. Either called by the receiving task\n-\t * thread or the task manager actor.\n-\t */\n-\tprivate final AtomicBoolean isReleased = new AtomicBoolean();\n-\n-\t/** Client to establish a (possibly shared) TCP connection and request the partition. */\n-\tprivate volatile PartitionRequestClient partitionRequestClient;\n-\n-\t/**\n-\t * The next expected sequence number for the next buffer. This is modified by the network\n-\t * I/O thread only.\n-\t */\n-\tprivate int expectedSequenceNumber = 0;\n-\n-\t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate final int initialCredit;\n-\n-\t/** The number of available buffers that have not been announced to the producer yet. */\n-\tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n-\n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n-\n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n-\n-\tprivate final BufferManager bufferManager;\n-\n-\tpublic RemoteInputChannel(\n-\t\tSingleInputGate inputGate,\n-\t\tint channelIndex,\n-\t\tResultPartitionID partitionId,\n-\t\tConnectionID connectionId,\n-\t\tConnectionManager connectionManager,\n-\t\tint initialBackOff,\n-\t\tint maxBackoff,\n-\t\tint networkBuffersPerChannel,\n-\t\tCounter numBytesIn,\n-\t\tCounter numBuffersIn) {\n-\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, numBytesIn, numBuffersIn);\n-\n-\t\tthis.initialCredit = networkBuffersPerChannel;\n-\t\tthis.connectionId = checkNotNull(connectionId);\n-\t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n-\t}\n-\n-\t/**\n-\t * Assigns exclusive buffers to this input channel, and this method should be called only once\n-\t * after this input channel is created.\n-\t */\n-\tvoid assignExclusiveSegments() throws IOException {\n-\t\tbufferManager.requestExclusiveBuffers();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests a remote subpartition.\n-\t */\n-\t@VisibleForTesting\n-\t@Override\n-\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n-\t\tif (partitionRequestClient == null) {\n-\t\t\t// Create a client and request the partition\n-\t\t\ttry {\n-\t\t\t\tpartitionRequestClient = connectionManager.createPartitionRequestClient(connectionId);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\t// IOExceptions indicate that we could not open a connection to the remote TaskExecutor\n-\t\t\t\tthrow new PartitionConnectionException(partitionId, e);\n-\t\t\t}\n-\n-\t\t\tpartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Retriggers a remote subpartition request.\n-\t */\n-\tvoid retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n-\t\tcheckState(partitionRequestClient != null, \"Missing initial subpartition request.\");\n-\n-\t\tif (increaseBackoff()) {\n-\t\t\tpartitionRequestClient.requestSubpartition(\n-\t\t\t\tpartitionId, subpartitionIndex, this, getCurrentBackoff());\n-\t\t} else {\n-\t\t\tfailPartitionRequest();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tOptional<BufferAndAvailability> getNextBuffer() throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Queried for a buffer after channel has been closed.\");\n-\t\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tfinal Buffer next;\n-\t\tfinal boolean moreAvailable;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tnext = receivedBuffers.poll();\n-\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n-\t\t}\n-\n-\t\tnumBytesIn.inc(next.getSize());\n-\t\tnumBuffersIn.inc();\n-\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable, 0));\n-\t}\n-\n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlastRequestedCheckpointId = checkpointId;\n-\n-\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\tcheckpointId,\n-\t\t\t\tchannelInfo,\n-\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tvoid sendTaskEvent(TaskEvent event) throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Tried to send task event to producer after channel has been released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tpartitionRequestClient.sendTaskEvent(partitionId, event, this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n-\t}\n-\n-\t/**\n-\t * Releases all exclusive and floating buffers, closes the partition request client.\n-\t */\n-\t@Override\n-\tvoid releaseAllResources() throws IOException {\n-\t\tif (isReleased.compareAndSet(false, true)) {\n-\n-\t\t\tArrayDeque<Buffer> releasedBuffers;\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\treleasedBuffers = receivedBuffers;\n-\t\t\t}\n-\t\t\tbufferManager.releaseAllBuffers(releasedBuffers);\n-\n-\t\t\t// The released flag has to be set before closing the connection to ensure that\n-\t\t\t// buffers received concurrently with closing are properly recycled.\n-\t\t\tif (partitionRequestClient != null) {\n-\t\t\t\tpartitionRequestClient.close(this);\n-\t\t\t} else {\n-\t\t\t\tconnectionManager.closeOpenChannelConnections(connectionId);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void failPartitionRequest() {\n-\t\tsetError(new PartitionNotFoundException(partitionId));\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Credit-based\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n-\t */\n-\tprivate void notifyCreditAvailable() {\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tpartitionRequestClient.notifyCreditAvailable(this);\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfAvailableBuffers() {\n-\t\treturn bufferManager.getNumberOfAvailableBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getSenderBacklog() {\n-\t\treturn getNumberOfRequiredBuffers() - initialCredit;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\treturn bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n-\t}\n-\n-\t@VisibleForTesting\n-\tBufferManager getBufferManager() {\n-\t\treturn bufferManager;\n-\t}\n-\n-\t@VisibleForTesting\n-\tPartitionRequestClient getPartitionRequestClient() {\n-\t\treturn partitionRequestClient;\n-\t}\n-\n-\t/**\n-\t * The unannounced credit is increased by the given amount and might notify\n-\t * increased credit to the producer.\n-\t */\n-\t@Override\n-\tpublic void notifyBufferAvailable(int numAvailableBuffers) {\n-\t\tif (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption() {\n-\t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n-\n-\t\t// notifies the producer that this channel is ready to\n-\t\t// unblock from checkpoint and resume data consumption\n-\t\tpartitionRequestClient.resumeConsumption(this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network I/O notifications (called by network I/O thread)\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Gets the currently unannounced credit.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getUnannouncedCredit() {\n-\t\treturn unannouncedCredit.get();\n-\t}\n-\n-\t/**\n-\t * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n-\t}\n-\n-\t/**\n-\t * Gets the current number of received buffers which have not been processed yet.\n-\t *\n-\t * @return Buffers queued for processing.\n-\t */\n-\tpublic int getNumberOfQueuedBuffers() {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treturn receivedBuffers.size();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn Math.max(0, receivedBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferManager.unsynchronizedGetExclusiveBuffersUsed());\n-\t}\n-\n-\tpublic int unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n-\t}\n-\n-\tpublic InputChannelID getInputChannelId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic int getInitialCredit() {\n-\t\treturn initialCredit;\n-\t}\n-\n-\tpublic BufferProvider getBufferProvider() throws IOException {\n-\t\tif (isReleased.get()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn inputGate.getBufferProvider();\n-\t}\n-\n-\t/**\n-\t * Requests buffer from input channel directly for receiving network data.\n-\t * It should always return an available buffer in credit-based mode unless\n-\t * the channel has been released.\n-\t *\n-\t * @return The available buffer.\n-\t */\n-\t@Nullable\n-\tpublic Buffer requestBuffer() {\n-\t\treturn bufferManager.requestBuffer();\n-\t}\n-\n-\t/**\n-\t * Receives the backlog from the producer's buffer response. If the number of available\n-\t * buffers is less than backlog + initialCredit, it will request floating buffers from\n-\t * the buffer manager, and then notify unannounced credits to the producer.\n-\t *\n-\t * @param backlog The number of unsent buffers in the producer's sub partition.\n-\t */\n-\tvoid onSenderBacklog(int backlog) throws IOException {\n-\t\tint numRequestedBuffers = bufferManager.requestFloatingBuffers(backlog + initialCredit);\n-\t\tif (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\tpublic void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean recycleBuffer = true;\n-\n-\t\ttry {\n-\t\t\tif (expectedSequenceNumber != sequenceNumber) {\n-\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tfinal boolean wasEmpty;\n-\t\t\tfinal CheckpointBarrier notifyReceivedBarrier;\n-\t\t\tfinal Buffer notifyReceivedBuffer;\n-\t\t\tfinal BufferReceivedListener listener = inputGate.getBufferReceivedListener();\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after releaseAllResources() released all buffers from receivedBuffers\n-\t\t\t\t// (see above for details).\n-\t\t\t\tif (isReleased.get()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n-\n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n-\t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n-\t\t\t}\n-\t\t\trecycleBuffer = false;\n-\n-\t\t\t++expectedSequenceNumber;\n-\n-\t\t\tif (wasEmpty) {\n-\t\t\t\tnotifyChannelNonEmpty();\n-\t\t\t}\n-\n-\t\t\tif (backlog >= 0) {\n-\t\t\t\tonSenderBacklog(backlog);\n-\t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tif (recycleBuffer) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean success = false;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tif (!isReleased.get()) {\n-\t\t\t\tif (expectedSequenceNumber == sequenceNumber) {\n-\t\t\t\t\texpectedSequenceNumber++;\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t} else {\n-\t\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (success && backlog >= 0) {\n-\t\t\tonSenderBacklog(backlog);\n-\t\t}\n-\t}\n-\n-\tpublic void onFailedPartitionRequest() {\n-\t\tinputGate.triggerPartitionStateCheck(partitionId);\n-\t}\n-\n-\tpublic void onError(Throwable cause) {\n-\t\tsetError(cause);\n-\t}\n-\n-\tprivate static class BufferReorderingException extends IOException {\n-\n-\t\tprivate static final long serialVersionUID = -888282210356266816L;\n-\n-\t\tprivate final int expectedSequenceNumber;\n-\n-\t\tprivate final int actualSequenceNumber;\n-\n-\t\tBufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n-\t\t\tthis.expectedSequenceNumber = expectedSequenceNumber;\n-\t\t\tthis.actualSequenceNumber = actualSequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String getMessage() {\n-\t\t\treturn String.format(\"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n-\t\t\t\texpectedSequenceNumber, actualSequenceNumber);\n-\t\t}\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(RemoteInputChannel.class);\n+\n+    private static final int NONE = -1;\n+\n+    /** ID to distinguish this channel from other channels sharing the same TCP connection. */\n+    private final InputChannelID id = new InputChannelID();\n+\n+    /** The connection to use to request the remote partition. */\n+    private final ConnectionID connectionId;\n+\n+    /** The connection manager to use connect to the remote partition provider. */\n+    private final ConnectionManager connectionManager;\n+\n+    /**\n+     * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n+     * is consumed by the receiving task thread.\n+     */\n+    private final PrioritizedDeque<SequenceBuffer> receivedBuffers = new PrioritizedDeque<>();\n+\n+    /**\n+     * Flag indicating whether this channel has been released. Either called by the receiving task\n+     * thread or the task manager actor.\n+     */\n+    private final AtomicBoolean isReleased = new AtomicBoolean();\n+\n+    /** Client to establish a (possibly shared) TCP connection and request the partition. */\n+    private volatile PartitionRequestClient partitionRequestClient;\n+\n+    /** The next expected sequence number for the next buffer. */\n+    private int expectedSequenceNumber = 0;\n+\n+    /** The initial number of exclusive buffers assigned to this channel. */\n+    private final int initialCredit;\n+\n+    /** The number of available buffers that have not been announced to the producer yet. */\n+    private final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n+\n+    private final BufferManager bufferManager;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private int lastBarrierSequenceNumber = NONE;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private long lastBarrierId = NONE;\n+\n+    private final ChannelStatePersister channelStatePersister;\n+\n+    public RemoteInputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            ConnectionID connectionId,\n+            ConnectionManager connectionManager,\n+            int initialBackOff,\n+            int maxBackoff,\n+            int networkBuffersPerChannel,\n+            Counter numBytesIn,\n+            Counter numBuffersIn,\n+            ChannelStateWriter stateWriter) {\n+\n+        super(\n+                inputGate,\n+                channelIndex,\n+                partitionId,\n+                initialBackOff,\n+                maxBackoff,\n+                numBytesIn,\n+                numBuffersIn);\n+        checkArgument(networkBuffersPerChannel >= 0, \"Must be non-negative.\");\n+\n+        this.initialCredit = networkBuffersPerChannel;\n+        this.connectionId = checkNotNull(connectionId);\n+        this.connectionManager = checkNotNull(connectionManager);\n+        this.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n+        this.channelStatePersister = new ChannelStatePersister(stateWriter, getChannelInfo());\n+    }\n+\n+    @VisibleForTesting\n+    void setExpectedSequenceNumber(int expectedSequenceNumber) {\n+        this.expectedSequenceNumber = expectedSequenceNumber;\n+    }\n+\n+    /**\n+     * Setup includes assigning exclusive buffers to this input channel, and this method should be\n+     * called only once after this input channel is created.\n+     */\n+    @Override\n+    void setup() throws IOException {\n+        checkState(\n+                bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+                \"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n+\n+        bufferManager.requestExclusiveBuffers(initialCredit);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /** Requests a remote subpartition. */\n+    @VisibleForTesting\n+    @Override\n+    public void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException {\n+        if (partitionRequestClient == null) {\n+            LOG.debug(\n+                    \"{}: Requesting REMOTE subpartition {} of partition {}. {}\",\n+                    this,\n+                    subpartitionIndex,\n+                    partitionId,\n+                    channelStatePersister);\n+            // Create a client and request the partition\n+            try {\n+                partitionRequestClient =\n+                        connectionManager.createPartitionRequestClient(connectionId);\n+            } catch (IOException e) {\n+                // IOExceptions indicate that we could not open a connection to the remote\n+                // TaskExecutor\n+                throw new PartitionConnectionException(partitionId, e);\n+            }\n+\n+            partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n+        }\n+    }\n+\n+    /** Retriggers a remote subpartition request. */\n+    void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (increaseBackoff()) {\n+            partitionRequestClient.requestSubpartition(\n+                    partitionId, subpartitionIndex, this, getCurrentBackoff());\n+        } else {\n+            failPartitionRequest();\n+        }\n+    }\n+\n+    @Override\n+    Optional<BufferAndAvailability> getNextBuffer() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        final SequenceBuffer next;\n+        final DataType nextDataType;\n+\n+        synchronized (receivedBuffers) {\n+            next = receivedBuffers.poll();\n+            nextDataType =\n+                    receivedBuffers.peek() != null\n+                            ? receivedBuffers.peek().buffer.getDataType()\n+                            : DataType.NONE;\n+        }\n+\n+        if (next == null) {\n+            if (isReleased.get()) {\n+                throw new CancelTaskException(\n+                        \"Queried for a buffer after channel has been released.\");\n+            }\n+            return Optional.empty();\n+        }\n+\n+        NetworkActionsLogger.traceInput(\n+                \"RemoteInputChannel#getNextBuffer\",\n+                next.buffer,\n+                inputGate.getOwningTaskName(),\n+                channelInfo,\n+                channelStatePersister,\n+                next.sequenceNumber);\n+        numBytesIn.inc(next.buffer.getSize());\n+        numBuffersIn.inc();\n+        return Optional.of(\n+                new BufferAndAvailability(next.buffer, nextDataType, 0, next.sequenceNumber));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    void sendTaskEvent(TaskEvent event) throws IOException {\n+        checkState(\n+                !isReleased.get(),\n+                \"Tried to send task event to producer after channel has been released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.sendTaskEvent(partitionId, event, this);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased.get();\n+    }\n+\n+    /** Releases all exclusive and floating buffers, closes the partition request client. */\n+    @Override\n+    void releaseAllResources() throws IOException {\n+        if (isReleased.compareAndSet(false, true)) {\n+\n+            final ArrayDeque<Buffer> releasedBuffers;\n+            synchronized (receivedBuffers) {\n+                releasedBuffers =\n+                        receivedBuffers.stream()\n+                                .map(sb -> sb.buffer)\n+                                .collect(Collectors.toCollection(ArrayDeque::new));\n+                receivedBuffers.clear();\n+            }\n+            bufferManager.releaseAllBuffers(releasedBuffers);\n+\n+            // The released flag has to be set before closing the connection to ensure that\n+            // buffers received concurrently with closing are properly recycled.\n+            if (partitionRequestClient != null) {\n+                partitionRequestClient.close(this);\n+            } else {\n+                connectionManager.closeOpenChannelConnections(connectionId);\n+            }\n+        }\n+    }\n+\n+    private void failPartitionRequest() {\n+        setError(new PartitionNotFoundException(partitionId));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Credit-based\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n+     */\n+    private void notifyCreditAvailable() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.notifyCreditAvailable(this);\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfAvailableBuffers() {\n+        return bufferManager.getNumberOfAvailableBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfRequiredBuffers() {\n+        return bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getSenderBacklog() {\n+        return getNumberOfRequiredBuffers() - initialCredit;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isWaitingForFloatingBuffers() {\n+        return bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public Buffer getNextReceivedBuffer() {\n+        final SequenceBuffer sequenceBuffer = receivedBuffers.poll();\n+        return sequenceBuffer != null ? sequenceBuffer.buffer : null;\n+    }\n+\n+    @VisibleForTesting\n+    BufferManager getBufferManager() {\n+        return bufferManager;\n+    }\n+\n+    @VisibleForTesting\n+    PartitionRequestClient getPartitionRequestClient() {\n+        return partitionRequestClient;\n+    }\n+\n+    /**\n+     * The unannounced credit is increased by the given amount and might notify increased credit to\n+     * the producer.\n+     */\n+    @Override\n+    public void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n+        if (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+            notifyCreditAvailable();\n+        }\n+    }\n+\n+    @Override\n+    public void resumeConsumption() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (initialCredit == 0) {\n+            // this unannounced credit can be a positive value because credit assignment and the\n+            // increase of this value is not an atomic operation and as a result, this unannounced\n+            // credit value can be get increased even after this channel has been blocked and all\n+            // floating credits are released, it is important to clear this unannounced credit and\n+            // at the same time reset the sender's available credits to keep consistency\n+            unannouncedCredit.set(0);\n+        }\n+\n+        // notifies the producer that this channel is ready to\n+        // unblock from checkpoint and resume data consumption\n+        partitionRequestClient.resumeConsumption(this);\n+    }\n+\n+    @Override\n+    public void acknowledgeAllRecordsProcessed() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.acknowledgeAllRecordsProcessed(this);\n+    }\n+\n+    private void onBlockingUpstream() {\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network I/O notifications (called by network I/O thread)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the currently unannounced credit.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getUnannouncedCredit() {\n+        return unannouncedCredit.get();\n+    }\n+\n+    /**\n+     * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getAndResetUnannouncedCredit() {\n+        return unannouncedCredit.getAndSet(0);\n+    }\n+\n+    /**\n+     * Gets the current number of received buffers which have not been processed yet.\n+     *\n+     * @return Buffers queued for processing.\n+     */\n+    public int getNumberOfQueuedBuffers() {\n+        synchronized (receivedBuffers) {\n+            return receivedBuffers.size();\n+        }\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return Math.max(0, receivedBuffers.size());\n+    }\n+\n+    public int unsynchronizedGetExclusiveBuffersUsed() {\n+        return Math.max(\n+                0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n+    }\n+\n+    public int unsynchronizedGetFloatingBuffersAvailable() {\n+        return Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n+    }\n+\n+    public InputChannelID getInputChannelId() {\n+        return id;\n+    }\n+\n+    public int getInitialCredit() {\n+        return initialCredit;\n+    }\n+\n+    public BufferProvider getBufferProvider() throws IOException {\n+        if (isReleased.get()) {\n+            return null;\n+        }\n+\n+        return inputGate.getBufferProvider();\n+    }\n+\n+    /**\n+     * Requests buffer from input channel directly for receiving network data. It should always\n+     * return an available buffer in credit-based mode unless the channel has been released.\n+     *\n+     * @return The available buffer.\n+     */\n+    @Nullable\n+    public Buffer requestBuffer() {\n+        return bufferManager.requestBuffer();\n+    }\n+\n+    /**\n+     * Receives the backlog from the producer's buffer response. If the number of available buffers\n+     * is less than backlog + initialCredit, it will request floating buffers from the buffer\n+     * manager, and then notify unannounced credits to the producer.\n+     *\n+     * @param backlog The number of unsent buffers in the producer's sub partition.\n+     */\n+    public void onSenderBacklog(int backlog) throws IOException {\n+        notifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+    }\n+\n+    /**\n+     * Handles the input buffer. This method is taking over the ownership of the buffer and is fully\n+     * responsible for cleaning it up both on the happy path and in case of an error.\n+     */\n+    public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n+        boolean recycleBuffer = true;\n+\n+        try {\n+            if (expectedSequenceNumber != sequenceNumber) {\n+                onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                return;\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+                checkArgument(backlog == 0, \"Illegal number of backlog: %s, should be 0.\", backlog);\n+            }\n+\n+            final boolean wasEmpty;\n+            boolean firstPriorityEvent = false;\n+            synchronized (receivedBuffers) {\n+                NetworkActionsLogger.traceInput(\n+                        \"RemoteInputChannel#onBuffer\",\n+                        buffer,\n+                        inputGate.getOwningTaskName(),\n+                        channelInfo,\n+                        channelStatePersister,\n+                        sequenceNumber);\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after releaseAllResources() released all buffers from receivedBuffers\n+                // (see above for details).\n+                if (isReleased.get()) {\n+                    return;\n+                }\n+\n+                wasEmpty = receivedBuffers.isEmpty();\n+\n+                SequenceBuffer sequenceBuffer = new SequenceBuffer(buffer, sequenceNumber);\n+                DataType dataType = buffer.getDataType();\n+                if (dataType.hasPriority()) {\n+                    firstPriorityEvent = addPriorityBuffer(sequenceBuffer);\n+                    recycleBuffer = false;\n+                } else {\n+                    receivedBuffers.add(sequenceBuffer);\n+                    recycleBuffer = false;\n+                    if (dataType.requiresAnnouncement()) {\n+                        firstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n+                    }\n+                }\n+                channelStatePersister\n+                        .checkForBarrier(sequenceBuffer.buffer)\n+                        .filter(id -> id > lastBarrierId)\n+                        .ifPresent(\n+                                id -> {\n+                                    // checkpoint was not yet started by task thread,\n+                                    // so remember the numbers of buffers to spill for the time when\n+                                    // it will be started\n+                                    lastBarrierId = id;\n+                                    lastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+                                });\n+                channelStatePersister.maybePersist(buffer);\n+                ++expectedSequenceNumber;\n+            }\n+\n+            if (firstPriorityEvent) {\n+                notifyPriorityEvent(sequenceNumber);\n+            }\n+            if (wasEmpty) {\n+                notifyChannelNonEmpty();\n+            }\n+\n+            if (backlog >= 0) {\n+                onSenderBacklog(backlog);\n+            }\n+        } finally {\n+            if (recycleBuffer) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+    }\n+\n+    /** @return {@code true} if this was first priority buffer added. */\n+    private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) {\n+        receivedBuffers.addPriorityElement(sequenceBuffer);\n+        return receivedBuffers.getNumPriorityElements() == 1;\n+    }\n+\n+    private SequenceBuffer announce(SequenceBuffer sequenceBuffer) throws IOException {\n+        checkState(\n+                !sequenceBuffer.buffer.isBuffer(),\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        checkAnnouncedOnlyOnce(sequenceBuffer);\n+        AbstractEvent event =\n+                EventSerializer.fromBuffer(sequenceBuffer.buffer, getClass().getClassLoader());\n+        checkState(\n+                event instanceof CheckpointBarrier,\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        CheckpointBarrier barrier = (CheckpointBarrier) event;\n+        return new SequenceBuffer(\n+                EventSerializer.toBuffer(\n+                        new EventAnnouncement(barrier, sequenceBuffer.sequenceNumber), true),\n+                sequenceBuffer.sequenceNumber);\n+    }\n+\n+    private void checkAnnouncedOnlyOnce(SequenceBuffer sequenceBuffer) {\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        int count = 0;\n+        while (iterator.hasNext()) {\n+            if (iterator.next().sequenceNumber == sequenceBuffer.sequenceNumber) {\n+                count++;\n+            }\n+        }\n+        checkState(\n+                count == 1,\n+                \"Before enqueuing the announcement there should be exactly single occurrence of the buffer, but found [%d]\",\n+                count);\n+    }\n+\n+    /**\n+     * Spills all queued buffers on checkpoint start. If barrier has already been received (and\n+     * reordered), spill only the overtaken buffers.\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {\n+        synchronized (receivedBuffers) {\n+            if (barrier.getId() < lastBarrierId) {\n+                throw new CheckpointException(\n+                        String.format(\n+                                \"Sequence number for checkpoint %d is not known (it was likely been overwritten by a newer checkpoint %d)\",\n+                                barrier.getId(), lastBarrierId),\n+                        CheckpointFailureReason\n+                                .CHECKPOINT_SUBSUMED); // currently, at most one active unaligned\n+                // checkpoint is possible\n+            } else if (barrier.getId() > lastBarrierId) {\n+                // This channel has received some obsolete barrier, older compared to the\n+                // checkpointId\n+                // which we are processing right now, and we should ignore that obsoleted checkpoint\n+                // barrier sequence number.\n+                resetLastBarrier();\n+            }\n+\n+            channelStatePersister.startPersisting(\n+                    barrier.getId(), getInflightBuffersUnsafe(barrier.getId()));\n+        }\n+    }\n+\n+    public void checkpointStopped(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            channelStatePersister.stopPersisting(checkpointId);\n+            if (lastBarrierId == checkpointId) {\n+                resetLastBarrier();\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    List<Buffer> getInflightBuffers(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            return getInflightBuffersUnsafe(checkpointId);\n+        }\n+    }\n+\n+    @Override\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n+        boolean firstPriorityEvent;\n+        synchronized (receivedBuffers) {\n+            checkState(channelStatePersister.hasBarrierReceived());\n+            int numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n+            SequenceBuffer toPrioritize =\n+                    receivedBuffers.getAndRemove(\n+                            sequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n+            checkState(lastBarrierSequenceNumber == sequenceNumber);\n+            checkState(!toPrioritize.buffer.isBuffer());\n+            checkState(\n+                    numPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n+                    \"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n+                    toPrioritize,\n+                    numPriorityElementsBeforeRemoval);\n+            // set the priority flag (checked on poll)\n+            // don't convert the barrier itself (barrier controller might not have been switched\n+            // yet)\n+            AbstractEvent e =\n+                    EventSerializer.fromBuffer(\n+                            toPrioritize.buffer, this.getClass().getClassLoader());\n+            toPrioritize.buffer.setReaderIndex(0);\n+            toPrioritize =\n+                    new SequenceBuffer(\n+                            EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n+            firstPriorityEvent =\n+                    addPriorityBuffer(\n+                            toPrioritize); // note that only position of the element is changed\n+            // converting the event itself would require switching the controller sooner\n+        }\n+        if (firstPriorityEvent) {\n+            notifyPriorityEventForce(); // forcibly notify about the priority event\n+            // instead of passing barrier SQN to be checked\n+            // because this SQN might have be seen by the input gate during the announcement\n+        }\n+    }\n+\n+    private void notifyPriorityEventForce() {\n+        inputGate.notifyPriorityEventForce(this);\n+    }\n+\n+    /**\n+     * Returns a list of buffers, checking the first n non-priority buffers, and skipping all\n+     * events.\n+     */\n+    private List<Buffer> getInflightBuffersUnsafe(long checkpointId) {\n+        assert Thread.holdsLock(receivedBuffers);\n+\n+        checkState(checkpointId == lastBarrierId || lastBarrierId == NONE);\n+\n+        final List<Buffer> inflightBuffers = new ArrayList<>();\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        // skip all priority events (only buffers are stored anyways)\n+        Iterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n+\n+        while (iterator.hasNext()) {\n+            SequenceBuffer sequenceBuffer = iterator.next();\n+            if (sequenceBuffer.buffer.isBuffer()) {\n+                if (shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+                    inflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return inflightBuffers;\n+    }\n+\n+    private void resetLastBarrier() {\n+        lastBarrierId = NONE;\n+        lastBarrierSequenceNumber = NONE;\n+    }\n+\n+    /**\n+     * @return if given {@param sequenceNumber} should be spilled given {@link\n+     *     #lastBarrierSequenceNumber}. We might not have yet received {@link CheckpointBarrier} and\n+     *     we might need to spill everything. If we have already received it, there is a bit nasty\n+     *     corner case of {@link SequenceBuffer#sequenceNumber} overflowing that needs to be handled\n+     *     as well.\n+     */\n+    private boolean shouldBeSpilled(int sequenceNumber) {\n+        if (lastBarrierSequenceNumber == NONE) {\n+            return true;\n+        }\n+        checkState(\n+                receivedBuffers.size() < Integer.MAX_VALUE / 2,\n+                \"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+        boolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastBarrierSequenceNumber;\n+        boolean possibleOverflowBeforeOvertaking =\n+                lastBarrierSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+        if (possibleOverflowAfterOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber && sequenceNumber > 0;\n+        } else if (possibleOverflowBeforeOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber || sequenceNumber > 0;\n+        } else {\n+            return sequenceNumber < lastBarrierSequenceNumber;\n+        }\n+    }\n+\n+    public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n+        boolean success = false;\n+\n+        synchronized (receivedBuffers) {\n+            if (!isReleased.get()) {\n+                if (expectedSequenceNumber == sequenceNumber) {\n+                    expectedSequenceNumber++;\n+                    success = true;\n+                } else {\n+                    onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                }\n+            }\n+        }\n+\n+        if (success && backlog >= 0) {\n+            onSenderBacklog(backlog);\n+        }\n+    }\n+\n+    public void onFailedPartitionRequest() {\n+        inputGate.triggerPartitionStateCheck(partitionId);\n+    }\n+\n+    public void onError(Throwable cause) {\n+        setError(cause);\n+    }\n+\n+    private void checkPartitionRequestQueueInitialized() throws IOException {\n+        checkError();\n+        checkState(\n+                partitionRequestClient != null,\n+                \"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n+    }\n+\n+    private static class BufferReorderingException extends IOException {\n+\n+        private static final long serialVersionUID = -888282210356266816L;\n+\n+        private final int expectedSequenceNumber;\n+\n+        private final int actualSequenceNumber;\n+\n+        BufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n+            this.expectedSequenceNumber = expectedSequenceNumber;\n+            this.actualSequenceNumber = actualSequenceNumber;\n+        }\n+\n+        @Override\n+        public String getMessage() {\n+            return String.format(\n+                    \"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n+                    expectedSequenceNumber, actualSequenceNumber);\n+        }\n+    }\n+\n+    private static final class SequenceBuffer {\n+        final Buffer buffer;\n+        final int sequenceNumber;\n+\n+        private SequenceBuffer(Buffer buffer, int sequenceNumber) {\n+            this.buffer = buffer;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\n+                    \"SequenceBuffer(isEvent = %s, dataType = %s, sequenceNumber = %s)\",\n+                    !buffer.isBuffer(), buffer.getDataType(), sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "0ee049db1ffe8a4a68bcd97608774ee488d02a21", "committedDate": "2021-09-03 08:19:32 +0200", "message": "[FLINK-23907] Use primitive functional interfaces"}, {"oid": "138e83e2bc6feb59ecd839b03491cd8f23ee1c66", "committedDate": "2021-11-08 08:56:34 +0100", "message": "[FLINK-24738][runtime] Ignoring buffer size announcement if the channel is released already"}, {"oid": "4eea7bc9352134a06d2b207c9a94dd46a01c6132", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[FLINK-24657][runtime] Added metric of the total real size of input/output buffers queue"}, {"oid": "f4fd4f8bb66867821cb0f171218d85f8386b0897", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] Move consumedSubpartitionIndex from SingleInputGate to InputChannel"}, {"oid": "5c2ec72982128fc1a30014677916e0dd21f9c1d2", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] SingleInputGate supports consuming subpartition range"}, {"oid": "6398abcbff06b3e488a273144680f4838b4f1c92", "committedDate": "2023-06-09 22:48:37 +0800", "message": "[FLINK-31636][network] Introduce the NettyService framework"}]}, {"oid": "fc3e9f5b7933d0b74b53946e6f506916f73aba14", "url": "https://github.com/apache/flink/commit/fc3e9f5b7933d0b74b53946e6f506916f73aba14", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-13T03:57:50Z", "type": "forcePushed"}, {"oid": "708b2ceb97564084900c555d6f38e6ba1174d735", "url": "https://github.com/apache/flink/commit/708b2ceb97564084900c555d6f38e6ba1174d735", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-13T04:00:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2MzEyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424163129", "body": "`numberOfSegmentsToRequest`  should never be negative because we already check this argument in constructor.\r\n`if (numberOfSegmentsToRequest == 0)` instead?", "bodyText": "numberOfSegmentsToRequest  should never be negative because we already check this argument in constructor.\nif (numberOfSegmentsToRequest == 0) instead?", "bodyHTML": "<p dir=\"auto\"><code>numberOfSegmentsToRequest</code>  should never be negative because we already check this argument in constructor.<br>\n<code>if (numberOfSegmentsToRequest == 0)</code> instead?</p>", "author": "zhijiangW", "createdAt": "2020-05-13T04:16:28Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java", "diffHunk": "@@ -162,6 +162,10 @@ public void recycle(MemorySegment segment) {\n \n \t@Override\n \tpublic List<MemorySegment> requestMemorySegments() throws IOException {\n+\t\tif (numberOfSegmentsToRequest <= 0) {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\nindex 102d16381fa..4b187db7a96 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\n", "chunk": "@@ -162,7 +162,7 @@ public class NetworkBufferPool implements BufferPoolFactory, MemorySegmentProvid\n \n \t@Override\n \tpublic List<MemorySegment> requestMemorySegments() throws IOException {\n-\t\tif (numberOfSegmentsToRequest <= 0) {\n+\t\tif (numberOfSegmentsToRequest == 0) {\n \t\t\treturn Collections.emptyList();\n \t\t}\n \n", "next_change": {"commit": "66de3ded5740c19aab5984c8650b5d6a355ed6e8", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\nindex 4b187db7a96..1643ca06529 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\n", "chunk": "@@ -162,15 +162,15 @@ public class NetworkBufferPool implements BufferPoolFactory, MemorySegmentProvid\n \n \t@Override\n \tpublic List<MemorySegment> requestMemorySegments() throws IOException {\n-\t\tif (numberOfSegmentsToRequest == 0) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\n \t\tsynchronized (factoryLock) {\n \t\t\tif (isDestroyed) {\n \t\t\t\tthrow new IllegalStateException(\"Network buffer pool has already been destroyed.\");\n \t\t\t}\n \n+\t\t\tif (numberOfSegmentsToRequest == 0) {\n+\t\t\t\treturn Collections.emptyList();\n+\t\t\t}\n+\n \t\t\ttryRedistributeBuffers();\n \t\t}\n \n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\nindex 1643ca06529..e7d74cadc0c 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\n", "chunk": "@@ -50,490 +50,502 @@ import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n- * The NetworkBufferPool is a fixed size pool of {@link MemorySegment} instances\n- * for the network stack.\n+ * The NetworkBufferPool is a fixed size pool of {@link MemorySegment} instances for the network\n+ * stack.\n  *\n  * <p>The NetworkBufferPool creates {@link LocalBufferPool}s from which the individual tasks draw\n  * the buffers for the network data transfer. When new local buffer pools are created, the\n  * NetworkBufferPool dynamically redistributes the buffers between the pools.\n  */\n-public class NetworkBufferPool implements BufferPoolFactory, MemorySegmentProvider, AvailabilityProvider {\n+public class NetworkBufferPool\n+        implements BufferPoolFactory, MemorySegmentProvider, AvailabilityProvider {\n \n-\tprivate static final Logger LOG = LoggerFactory.getLogger(NetworkBufferPool.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(NetworkBufferPool.class);\n+\n+    private final int totalNumberOfMemorySegments;\n \n-\tprivate final int totalNumberOfMemorySegments;\n-\n-\tprivate final int memorySegmentSize;\n-\n-\tprivate final ArrayDeque<MemorySegment> availableMemorySegments;\n-\n-\tprivate volatile boolean isDestroyed;\n-\n-\t// ---- Managed buffer pools ----------------------------------------------\n-\n-\tprivate final Object factoryLock = new Object();\n-\n-\tprivate final Set<LocalBufferPool> allBufferPools = new HashSet<>();\n-\n-\tprivate int numTotalRequiredBuffers;\n-\n-\tprivate final int numberOfSegmentsToRequest;\n-\n-\tprivate final Duration requestSegmentsTimeout;\n-\n-\tprivate final AvailabilityHelper availabilityHelper = new AvailabilityHelper();\n-\n-\t@VisibleForTesting\n-\tpublic NetworkBufferPool(int numberOfSegmentsToAllocate, int segmentSize, int numberOfSegmentsToRequest) {\n-\t\tthis(numberOfSegmentsToAllocate, segmentSize, numberOfSegmentsToRequest, Duration.ofMillis(Integer.MAX_VALUE));\n-\t}\n-\n-\t/**\n-\t * Allocates all {@link MemorySegment} instances managed by this pool.\n-\t */\n-\tpublic NetworkBufferPool(\n-\t\t\tint numberOfSegmentsToAllocate,\n-\t\t\tint segmentSize,\n-\t\t\tint numberOfSegmentsToRequest,\n-\t\t\tDuration requestSegmentsTimeout) {\n-\t\tthis.totalNumberOfMemorySegments = numberOfSegmentsToAllocate;\n-\t\tthis.memorySegmentSize = segmentSize;\n-\n-\t\tcheckArgument(numberOfSegmentsToRequest >= 0, \"The number of required buffers should be non-negative.\");\n-\t\tthis.numberOfSegmentsToRequest = numberOfSegmentsToRequest;\n-\n-\t\tPreconditions.checkNotNull(requestSegmentsTimeout);\n-\t\tcheckArgument(requestSegmentsTimeout.toMillis() > 0,\n-\t\t\t\t\"The timeout for requesting exclusive buffers should be positive.\");\n-\t\tthis.requestSegmentsTimeout = requestSegmentsTimeout;\n-\n-\t\tfinal long sizeInLong = (long) segmentSize;\n-\n-\t\ttry {\n-\t\t\tthis.availableMemorySegments = new ArrayDeque<>(numberOfSegmentsToAllocate);\n-\t\t}\n-\t\tcatch (OutOfMemoryError err) {\n-\t\t\tthrow new OutOfMemoryError(\"Could not allocate buffer queue of length \"\n-\t\t\t\t\t+ numberOfSegmentsToAllocate + \" - \" + err.getMessage());\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tfor (int i = 0; i < numberOfSegmentsToAllocate; i++) {\n-\t\t\t\tavailableMemorySegments.add(MemorySegmentFactory.allocateUnpooledOffHeapMemory(segmentSize, null));\n-\t\t\t}\n-\t\t}\n-\t\tcatch (OutOfMemoryError err) {\n-\t\t\tint allocated = availableMemorySegments.size();\n-\n-\t\t\t// free some memory\n-\t\t\tavailableMemorySegments.clear();\n-\n-\t\t\tlong requiredMb = (sizeInLong * numberOfSegmentsToAllocate) >> 20;\n-\t\t\tlong allocatedMb = (sizeInLong * allocated) >> 20;\n-\t\t\tlong missingMb = requiredMb - allocatedMb;\n-\n-\t\t\tthrow new OutOfMemoryError(\"Could not allocate enough memory segments for NetworkBufferPool \" +\n-\t\t\t\t\t\"(required (Mb): \" + requiredMb +\n-\t\t\t\t\t\", allocated (Mb): \" + allocatedMb +\n-\t\t\t\t\t\", missing (Mb): \" + missingMb + \"). Cause: \" + err.getMessage());\n-\t\t}\n-\n-\t\tavailabilityHelper.resetAvailable();\n-\n-\t\tlong allocatedMb = (sizeInLong * availableMemorySegments.size()) >> 20;\n-\n-\t\tLOG.info(\"Allocated {} MB for network buffer pool (number of memory segments: {}, bytes per segment: {}).\",\n-\t\t\t\tallocatedMb, availableMemorySegments.size(), segmentSize);\n-\t}\n-\n-\t@Nullable\n-\tpublic MemorySegment requestMemorySegment() {\n-\t\tsynchronized (availableMemorySegments) {\n-\t\t\treturn internalRequestMemorySegment();\n-\t\t}\n-\t}\n-\n-\tpublic void recycle(MemorySegment segment) {\n-\t\t// Adds the segment back to the queue, which does not immediately free the memory\n-\t\t// however, since this happens when references to the global pool are also released,\n-\t\t// making the availableMemorySegments queue and its contained object reclaimable\n-\t\tinternalRecycleMemorySegments(Collections.singleton(checkNotNull(segment)));\n-\t}\n-\n-\t@Override\n-\tpublic List<MemorySegment> requestMemorySegments() throws IOException {\n-\t\tsynchronized (factoryLock) {\n-\t\t\tif (isDestroyed) {\n-\t\t\t\tthrow new IllegalStateException(\"Network buffer pool has already been destroyed.\");\n-\t\t\t}\n-\n-\t\t\tif (numberOfSegmentsToRequest == 0) {\n-\t\t\t\treturn Collections.emptyList();\n-\t\t\t}\n-\n-\t\t\ttryRedistributeBuffers();\n-\t\t}\n-\n-\t\tfinal List<MemorySegment> segments = new ArrayList<>(numberOfSegmentsToRequest);\n-\t\ttry {\n-\t\t\tfinal Deadline deadline = Deadline.fromNow(requestSegmentsTimeout);\n-\t\t\twhile (true) {\n-\t\t\t\tif (isDestroyed) {\n-\t\t\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n-\t\t\t\t}\n-\n-\t\t\t\tMemorySegment segment;\n-\t\t\t\tsynchronized (availableMemorySegments) {\n-\t\t\t\t\tif ((segment = internalRequestMemorySegment()) == null) {\n-\t\t\t\t\t\tavailableMemorySegments.wait(2000);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (segment != null) {\n-\t\t\t\t\tsegments.add(segment);\n-\t\t\t\t}\n-\n-\t\t\t\tif (segments.size() >= numberOfSegmentsToRequest) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\n-\t\t\t\tif (!deadline.hasTimeLeft()) {\n-\t\t\t\t\tthrow new IOException(String.format(\"Timeout triggered when requesting exclusive buffers: %s, \" +\n-\t\t\t\t\t\t\t\t\t\" or you may increase the timeout which is %dms by setting the key '%s'.\",\n-\t\t\t\t\t\t\tgetConfigDescription(),\n-\t\t\t\t\t\t\trequestSegmentsTimeout.toMillis(),\n-\t\t\t\t\t\t\tNettyShuffleEnvironmentOptions.NETWORK_EXCLUSIVE_BUFFERS_REQUEST_TIMEOUT_MILLISECONDS.key()));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Throwable e) {\n-\t\t\ttry {\n-\t\t\t\trecycleMemorySegments(segments, numberOfSegmentsToRequest);\n-\t\t\t} catch (IOException inner) {\n-\t\t\t\te.addSuppressed(inner);\n-\t\t\t}\n-\t\t\tExceptionUtils.rethrowIOException(e);\n-\t\t}\n-\n-\t\treturn segments;\n-\t}\n-\n-\t@Nullable\n-\tprivate MemorySegment internalRequestMemorySegment() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n-\n-\t\tfinal MemorySegment segment = availableMemorySegments.poll();\n-\t\tif (availableMemorySegments.isEmpty() && segment != null) {\n-\t\t\tavailabilityHelper.resetUnavailable();\n-\t\t}\n-\t\treturn segment;\n-\t}\n-\n-\t@Override\n-\tpublic void recycleMemorySegments(Collection<MemorySegment> segments) throws IOException {\n-\t\trecycleMemorySegments(segments, segments.size());\n-\t}\n-\n-\tprivate void recycleMemorySegments(Collection<MemorySegment> segments, int size) throws IOException {\n-\t\tinternalRecycleMemorySegments(segments);\n-\n-\t\tsynchronized (factoryLock) {\n-\t\t\tnumTotalRequiredBuffers -= size;\n-\n-\t\t\t// note: if this fails, we're fine for the buffer pool since we already recycled the segments\n-\t\t\tredistributeBuffers();\n-\t\t}\n-\t}\n-\n-\tprivate void internalRecycleMemorySegments(Collection<MemorySegment> segments) {\n-\t\tCompletableFuture<?> toNotify = null;\n-\t\tsynchronized (availableMemorySegments) {\n-\t\t\tif (availableMemorySegments.isEmpty() && !segments.isEmpty()) {\n-\t\t\t\ttoNotify = availabilityHelper.getUnavailableToResetAvailable();\n-\t\t\t}\n-\t\t\tavailableMemorySegments.addAll(segments);\n-\t\t\tavailableMemorySegments.notifyAll();\n-\t\t}\n-\n-\t\tif (toNotify != null) {\n-\t\t\ttoNotify.complete(null);\n-\t\t}\n-\t}\n-\n-\tpublic void destroy() {\n-\t\tsynchronized (factoryLock) {\n-\t\t\tisDestroyed = true;\n-\t\t}\n-\n-\t\tsynchronized (availableMemorySegments) {\n-\t\t\tMemorySegment segment;\n-\t\t\twhile ((segment = availableMemorySegments.poll()) != null) {\n-\t\t\t\tsegment.free();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic boolean isDestroyed() {\n-\t\treturn isDestroyed;\n-\t}\n-\n-\tpublic int getTotalNumberOfMemorySegments() {\n-\t\treturn totalNumberOfMemorySegments;\n-\t}\n-\n-\tpublic int getNumberOfAvailableMemorySegments() {\n-\t\tsynchronized (availableMemorySegments) {\n-\t\t\treturn availableMemorySegments.size();\n-\t\t}\n-\t}\n-\n-\tpublic int getNumberOfRegisteredBufferPools() {\n-\t\tsynchronized (factoryLock) {\n-\t\t\treturn allBufferPools.size();\n-\t\t}\n-\t}\n-\n-\tpublic int countBuffers() {\n-\t\tint buffers = 0;\n-\n-\t\tsynchronized (factoryLock) {\n-\t\t\tfor (BufferPool bp : allBufferPools) {\n-\t\t\t\tbuffers += bp.getNumBuffers();\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn buffers;\n-\t}\n-\n-\t/**\n-\t * Returns a future that is completed when there are free segments\n-\t * in this pool.\n-\t */\n-\t@Override\n-\tpublic CompletableFuture<?> getAvailableFuture() {\n-\t\treturn availabilityHelper.getAvailableFuture();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// BufferPoolFactory\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic BufferPool createBufferPool(int numRequiredBuffers, int maxUsedBuffers) throws IOException {\n-\t\treturn internalCreateBufferPool(\n-\t\t\tnumRequiredBuffers,\n-\t\t\tmaxUsedBuffers,\n-\t\t\tnull,\n-\t\t\t0,\n-\t\t\tInteger.MAX_VALUE);\n-\t}\n-\n-\t@Override\n-\tpublic BufferPool createBufferPool(\n-\t\t\tint numRequiredBuffers,\n-\t\t\tint maxUsedBuffers,\n-\t\t\tBufferPoolOwner bufferPoolOwner,\n-\t\t\tint numSubpartitions,\n-\t\t\tint maxBuffersPerChannel) throws IOException {\n-\t\treturn internalCreateBufferPool(\n-\t\t\tnumRequiredBuffers,\n-\t\t\tmaxUsedBuffers,\n-\t\t\tbufferPoolOwner,\n-\t\t\tnumSubpartitions,\n-\t\t\tmaxBuffersPerChannel);\n-\t}\n-\n-\tprivate BufferPool internalCreateBufferPool(\n-\t\t\tint numRequiredBuffers,\n-\t\t\tint maxUsedBuffers,\n-\t\t\t@Nullable BufferPoolOwner bufferPoolOwner,\n-\t\t\tint numSubpartitions,\n-\t\t\tint maxBuffersPerChannel) throws IOException {\n-\n-\t\t// It is necessary to use a separate lock from the one used for buffer\n-\t\t// requests to ensure deadlock freedom for failure cases.\n-\t\tsynchronized (factoryLock) {\n-\t\t\tif (isDestroyed) {\n-\t\t\t\tthrow new IllegalStateException(\"Network buffer pool has already been destroyed.\");\n-\t\t\t}\n-\n-\t\t\t// Ensure that the number of required buffers can be satisfied.\n-\t\t\t// With dynamic memory management this should become obsolete.\n-\t\t\tif (numTotalRequiredBuffers + numRequiredBuffers > totalNumberOfMemorySegments) {\n-\t\t\t\tthrow new IOException(String.format(\"Insufficient number of network buffers: \" +\n-\t\t\t\t\t\t\t\t\"required %d, but only %d available. %s.\",\n-\t\t\t\t\t\tnumRequiredBuffers,\n-\t\t\t\t\t\ttotalNumberOfMemorySegments - numTotalRequiredBuffers,\n-\t\t\t\t\t\tgetConfigDescription()));\n-\t\t\t}\n-\n-\t\t\tthis.numTotalRequiredBuffers += numRequiredBuffers;\n-\n-\t\t\t// We are good to go, create a new buffer pool and redistribute\n-\t\t\t// non-fixed size buffers.\n-\t\t\tLocalBufferPool localBufferPool =\n-\t\t\t\tnew LocalBufferPool(\n-\t\t\t\t\tthis,\n-\t\t\t\t\tnumRequiredBuffers,\n-\t\t\t\t\tmaxUsedBuffers,\n-\t\t\t\t\tbufferPoolOwner,\n-\t\t\t\t\tnumSubpartitions,\n-\t\t\t\t\tmaxBuffersPerChannel);\n-\n-\t\t\tallBufferPools.add(localBufferPool);\n-\n-\t\t\ttry {\n-\t\t\t\tredistributeBuffers();\n-\t\t\t} catch (IOException e) {\n-\t\t\t\ttry {\n-\t\t\t\t\tdestroyBufferPool(localBufferPool);\n-\t\t\t\t} catch (IOException inner) {\n-\t\t\t\t\te.addSuppressed(inner);\n-\t\t\t\t}\n-\t\t\t\tExceptionUtils.rethrowIOException(e);\n-\t\t\t}\n-\n-\t\t\treturn localBufferPool;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void destroyBufferPool(BufferPool bufferPool) throws IOException {\n-\t\tif (!(bufferPool instanceof LocalBufferPool)) {\n-\t\t\tthrow new IllegalArgumentException(\"bufferPool is no LocalBufferPool\");\n-\t\t}\n-\n-\t\tsynchronized (factoryLock) {\n-\t\t\tif (allBufferPools.remove(bufferPool)) {\n-\t\t\t\tnumTotalRequiredBuffers -= bufferPool.getNumberOfRequiredMemorySegments();\n-\n-\t\t\t\tredistributeBuffers();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Destroys all buffer pools that allocate their buffers from this\n-\t * buffer pool (created via {@link #createBufferPool(int, int)}).\n-\t */\n-\tpublic void destroyAllBufferPools() {\n-\t\tsynchronized (factoryLock) {\n-\t\t\t// create a copy to avoid concurrent modification exceptions\n-\t\t\tLocalBufferPool[] poolsCopy = allBufferPools.toArray(new LocalBufferPool[allBufferPools.size()]);\n-\n-\t\t\tfor (LocalBufferPool pool : poolsCopy) {\n-\t\t\t\tpool.lazyDestroy();\n-\t\t\t}\n-\n-\t\t\t// some sanity checks\n-\t\t\tif (allBufferPools.size() > 0 || numTotalRequiredBuffers > 0) {\n-\t\t\t\tthrow new IllegalStateException(\"NetworkBufferPool is not empty after destroying all LocalBufferPools\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Must be called from synchronized block\n-\tprivate void tryRedistributeBuffers() throws IOException {\n-\t\tassert Thread.holdsLock(factoryLock);\n-\n-\t\tif (numTotalRequiredBuffers + numberOfSegmentsToRequest > totalNumberOfMemorySegments) {\n-\t\t\tthrow new IOException(String.format(\"Insufficient number of network buffers: \" +\n-\t\t\t\t\t\t\t\"required %d, but only %d available. %s.\",\n-\t\t\t\t\tnumberOfSegmentsToRequest,\n-\t\t\t\t\ttotalNumberOfMemorySegments - numTotalRequiredBuffers,\n-\t\t\t\t\tgetConfigDescription()));\n-\t\t}\n-\n-\t\tthis.numTotalRequiredBuffers += numberOfSegmentsToRequest;\n-\n-\t\ttry {\n-\t\t\tredistributeBuffers();\n-\t\t} catch (Throwable t) {\n-\t\t\tthis.numTotalRequiredBuffers -= numberOfSegmentsToRequest;\n-\n-\t\t\ttry {\n-\t\t\t\tredistributeBuffers();\n-\t\t\t} catch (IOException inner) {\n-\t\t\t\tt.addSuppressed(inner);\n-\t\t\t}\n-\t\t\tExceptionUtils.rethrowIOException(t);\n-\t\t}\n-\t}\n-\n-\t// Must be called from synchronized block\n-\tprivate void redistributeBuffers() throws IOException {\n-\t\tassert Thread.holdsLock(factoryLock);\n-\n-\t\t// All buffers, which are not among the required ones\n-\t\tfinal int numAvailableMemorySegment = totalNumberOfMemorySegments - numTotalRequiredBuffers;\n-\n-\t\tif (numAvailableMemorySegment == 0) {\n-\t\t\t// in this case, we need to redistribute buffers so that every pool gets its minimum\n-\t\t\tfor (LocalBufferPool bufferPool : allBufferPools) {\n-\t\t\t\tbufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments());\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t/*\n-\t\t * With buffer pools being potentially limited, let's distribute the available memory\n-\t\t * segments based on the capacity of each buffer pool, i.e. the maximum number of segments\n-\t\t * an unlimited buffer pool can take is numAvailableMemorySegment, for limited buffer pools\n-\t\t * it may be less. Based on this and the sum of all these values (totalCapacity), we build\n-\t\t * a ratio that we use to distribute the buffers.\n-\t\t */\n-\n-\t\tlong totalCapacity = 0; // long to avoid int overflow\n-\n-\t\tfor (LocalBufferPool bufferPool : allBufferPools) {\n-\t\t\tint excessMax = bufferPool.getMaxNumberOfMemorySegments() -\n-\t\t\t\tbufferPool.getNumberOfRequiredMemorySegments();\n-\t\t\ttotalCapacity += Math.min(numAvailableMemorySegment, excessMax);\n-\t\t}\n-\n-\t\t// no capacity to receive additional buffers?\n-\t\tif (totalCapacity == 0) {\n-\t\t\treturn; // necessary to avoid div by zero when nothing to re-distribute\n-\t\t}\n-\n-\t\t// since one of the arguments of 'min(a,b)' is a positive int, this is actually\n-\t\t// guaranteed to be within the 'int' domain\n-\t\t// (we use a checked downCast to handle possible bugs more gracefully).\n-\t\tfinal int memorySegmentsToDistribute = MathUtils.checkedDownCast(\n-\t\t\t\tMath.min(numAvailableMemorySegment, totalCapacity));\n-\n-\t\tlong totalPartsUsed = 0; // of totalCapacity\n-\t\tint numDistributedMemorySegment = 0;\n-\t\tfor (LocalBufferPool bufferPool : allBufferPools) {\n-\t\t\tint excessMax = bufferPool.getMaxNumberOfMemorySegments() -\n-\t\t\t\tbufferPool.getNumberOfRequiredMemorySegments();\n-\n-\t\t\t// shortcut\n-\t\t\tif (excessMax == 0) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\ttotalPartsUsed += Math.min(numAvailableMemorySegment, excessMax);\n-\n-\t\t\t// avoid remaining buffers by looking at the total capacity that should have been\n-\t\t\t// re-distributed up until here\n-\t\t\t// the downcast will always succeed, because both arguments of the subtraction are in the 'int' domain\n-\t\t\tfinal int mySize = MathUtils.checkedDownCast(\n-\t\t\t\t\tmemorySegmentsToDistribute * totalPartsUsed / totalCapacity - numDistributedMemorySegment);\n-\n-\t\t\tnumDistributedMemorySegment += mySize;\n-\t\t\tbufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments() + mySize);\n-\t\t}\n-\n-\t\tassert (totalPartsUsed == totalCapacity);\n-\t\tassert (numDistributedMemorySegment == memorySegmentsToDistribute);\n-\t}\n-\n-\tprivate String getConfigDescription() {\n-\t\treturn String.format(\"The total number of network buffers is currently set to %d of %d bytes each. \" +\n-\t\t\t\t\t\t\"You can increase this number by setting the configuration keys '%s', '%s', and '%s'\",\n-\t\t\t\ttotalNumberOfMemorySegments,\n-\t\t\t\tmemorySegmentSize,\n-\t\t\t\tTaskManagerOptions.NETWORK_MEMORY_FRACTION.key(),\n-\t\t\t\tTaskManagerOptions.NETWORK_MEMORY_MIN.key(),\n-\t\t\t\tTaskManagerOptions.NETWORK_MEMORY_MAX.key());\n-\t}\n+    private final int memorySegmentSize;\n+\n+    private final ArrayDeque<MemorySegment> availableMemorySegments;\n+\n+    private volatile boolean isDestroyed;\n+\n+    // ---- Managed buffer pools ----------------------------------------------\n+\n+    private final Object factoryLock = new Object();\n+\n+    private final Set<LocalBufferPool> allBufferPools = new HashSet<>();\n+\n+    private int numTotalRequiredBuffers;\n+\n+    private final Duration requestSegmentsTimeout;\n+\n+    private final AvailabilityHelper availabilityHelper = new AvailabilityHelper();\n+\n+    @VisibleForTesting\n+    public NetworkBufferPool(int numberOfSegmentsToAllocate, int segmentSize) {\n+        this(numberOfSegmentsToAllocate, segmentSize, Duration.ofMillis(Integer.MAX_VALUE));\n+    }\n+\n+    /** Allocates all {@link MemorySegment} instances managed by this pool. */\n+    public NetworkBufferPool(\n+            int numberOfSegmentsToAllocate, int segmentSize, Duration requestSegmentsTimeout) {\n+        this.totalNumberOfMemorySegments = numberOfSegmentsToAllocate;\n+        this.memorySegmentSize = segmentSize;\n+\n+        Preconditions.checkNotNull(requestSegmentsTimeout);\n+        checkArgument(\n+                requestSegmentsTimeout.toMillis() > 0,\n+                \"The timeout for requesting exclusive buffers should be positive.\");\n+        this.requestSegmentsTimeout = requestSegmentsTimeout;\n+\n+        final long sizeInLong = (long) segmentSize;\n+\n+        try {\n+            this.availableMemorySegments = new ArrayDeque<>(numberOfSegmentsToAllocate);\n+        } catch (OutOfMemoryError err) {\n+            throw new OutOfMemoryError(\n+                    \"Could not allocate buffer queue of length \"\n+                            + numberOfSegmentsToAllocate\n+                            + \" - \"\n+                            + err.getMessage());\n+        }\n+\n+        try {\n+            for (int i = 0; i < numberOfSegmentsToAllocate; i++) {\n+                availableMemorySegments.add(\n+                        MemorySegmentFactory.allocateUnpooledOffHeapMemory(segmentSize, null));\n+            }\n+        } catch (OutOfMemoryError err) {\n+            int allocated = availableMemorySegments.size();\n+\n+            // free some memory\n+            availableMemorySegments.clear();\n+\n+            long requiredMb = (sizeInLong * numberOfSegmentsToAllocate) >> 20;\n+            long allocatedMb = (sizeInLong * allocated) >> 20;\n+            long missingMb = requiredMb - allocatedMb;\n+\n+            throw new OutOfMemoryError(\n+                    \"Could not allocate enough memory segments for NetworkBufferPool \"\n+                            + \"(required (Mb): \"\n+                            + requiredMb\n+                            + \", allocated (Mb): \"\n+                            + allocatedMb\n+                            + \", missing (Mb): \"\n+                            + missingMb\n+                            + \"). Cause: \"\n+                            + err.getMessage());\n+        }\n+\n+        availabilityHelper.resetAvailable();\n+\n+        long allocatedMb = (sizeInLong * availableMemorySegments.size()) >> 20;\n+\n+        LOG.info(\n+                \"Allocated {} MB for network buffer pool (number of memory segments: {}, bytes per segment: {}).\",\n+                allocatedMb,\n+                availableMemorySegments.size(),\n+                segmentSize);\n+    }\n+\n+    @Nullable\n+    public MemorySegment requestMemorySegment() {\n+        synchronized (availableMemorySegments) {\n+            return internalRequestMemorySegment();\n+        }\n+    }\n+\n+    public void recycle(MemorySegment segment) {\n+        // Adds the segment back to the queue, which does not immediately free the memory\n+        // however, since this happens when references to the global pool are also released,\n+        // making the availableMemorySegments queue and its contained object reclaimable\n+        internalRecycleMemorySegments(Collections.singleton(checkNotNull(segment)));\n+    }\n+\n+    @Override\n+    public List<MemorySegment> requestMemorySegments(int numberOfSegmentsToRequest)\n+            throws IOException {\n+        checkArgument(\n+                numberOfSegmentsToRequest >= 0,\n+                \"Number of buffers to request must be larger than 0.\");\n+\n+        synchronized (factoryLock) {\n+            if (isDestroyed) {\n+                throw new IllegalStateException(\"Network buffer pool has already been destroyed.\");\n+            }\n+\n+            if (numberOfSegmentsToRequest == 0) {\n+                return Collections.emptyList();\n+            }\n+\n+            tryRedistributeBuffers(numberOfSegmentsToRequest);\n+        }\n+\n+        final List<MemorySegment> segments = new ArrayList<>(numberOfSegmentsToRequest);\n+        try {\n+            final Deadline deadline = Deadline.fromNow(requestSegmentsTimeout);\n+            while (true) {\n+                if (isDestroyed) {\n+                    throw new IllegalStateException(\"Buffer pool is destroyed.\");\n+                }\n+\n+                MemorySegment segment;\n+                synchronized (availableMemorySegments) {\n+                    if ((segment = internalRequestMemorySegment()) == null) {\n+                        availableMemorySegments.wait(2000);\n+                    }\n+                }\n+                if (segment != null) {\n+                    segments.add(segment);\n+                }\n+\n+                if (segments.size() >= numberOfSegmentsToRequest) {\n+                    break;\n+                }\n+\n+                if (!deadline.hasTimeLeft()) {\n+                    throw new IOException(\n+                            String.format(\n+                                    \"Timeout triggered when requesting exclusive buffers: %s, \"\n+                                            + \" or you may increase the timeout which is %dms by setting the key '%s'.\",\n+                                    getConfigDescription(),\n+                                    requestSegmentsTimeout.toMillis(),\n+                                    NettyShuffleEnvironmentOptions\n+                                            .NETWORK_EXCLUSIVE_BUFFERS_REQUEST_TIMEOUT_MILLISECONDS\n+                                            .key()));\n+                }\n+            }\n+        } catch (Throwable e) {\n+            recycleMemorySegments(segments, numberOfSegmentsToRequest);\n+            ExceptionUtils.rethrowIOException(e);\n+        }\n+\n+        return segments;\n+    }\n+\n+    @Nullable\n+    private MemorySegment internalRequestMemorySegment() {\n+        assert Thread.holdsLock(availableMemorySegments);\n+\n+        final MemorySegment segment = availableMemorySegments.poll();\n+        if (availableMemorySegments.isEmpty() && segment != null) {\n+            availabilityHelper.resetUnavailable();\n+        }\n+        return segment;\n+    }\n+\n+    @Override\n+    public void recycleMemorySegments(Collection<MemorySegment> segments) {\n+        recycleMemorySegments(segments, segments.size());\n+    }\n+\n+    private void recycleMemorySegments(Collection<MemorySegment> segments, int size) {\n+        internalRecycleMemorySegments(segments);\n+\n+        synchronized (factoryLock) {\n+            numTotalRequiredBuffers -= size;\n+\n+            // note: if this fails, we're fine for the buffer pool since we already recycled the\n+            // segments\n+            redistributeBuffers();\n+        }\n+    }\n+\n+    private void internalRecycleMemorySegments(Collection<MemorySegment> segments) {\n+        CompletableFuture<?> toNotify = null;\n+        synchronized (availableMemorySegments) {\n+            if (availableMemorySegments.isEmpty() && !segments.isEmpty()) {\n+                toNotify = availabilityHelper.getUnavailableToResetAvailable();\n+            }\n+            availableMemorySegments.addAll(segments);\n+            availableMemorySegments.notifyAll();\n+        }\n+\n+        if (toNotify != null) {\n+            toNotify.complete(null);\n+        }\n+    }\n+\n+    public void destroy() {\n+        synchronized (factoryLock) {\n+            isDestroyed = true;\n+        }\n+\n+        synchronized (availableMemorySegments) {\n+            MemorySegment segment;\n+            while ((segment = availableMemorySegments.poll()) != null) {\n+                segment.free();\n+            }\n+        }\n+    }\n+\n+    public boolean isDestroyed() {\n+        return isDestroyed;\n+    }\n+\n+    public int getTotalNumberOfMemorySegments() {\n+        return isDestroyed() ? 0 : totalNumberOfMemorySegments;\n+    }\n+\n+    public long getTotalMemory() {\n+        return getTotalNumberOfMemorySegments() * memorySegmentSize;\n+    }\n+\n+    public int getNumberOfAvailableMemorySegments() {\n+        synchronized (availableMemorySegments) {\n+            return availableMemorySegments.size();\n+        }\n+    }\n+\n+    public long getAvailableMemory() {\n+        return getNumberOfAvailableMemorySegments() * memorySegmentSize;\n+    }\n+\n+    public int getNumberOfUsedMemorySegments() {\n+        return getTotalNumberOfMemorySegments() - getNumberOfAvailableMemorySegments();\n+    }\n+\n+    public long getUsedMemory() {\n+        return getNumberOfUsedMemorySegments() * memorySegmentSize;\n+    }\n+\n+    public int getNumberOfRegisteredBufferPools() {\n+        synchronized (factoryLock) {\n+            return allBufferPools.size();\n+        }\n+    }\n+\n+    public int countBuffers() {\n+        int buffers = 0;\n+\n+        synchronized (factoryLock) {\n+            for (BufferPool bp : allBufferPools) {\n+                buffers += bp.getNumBuffers();\n+            }\n+        }\n+\n+        return buffers;\n+    }\n+\n+    /** Returns a future that is completed when there are free segments in this pool. */\n+    @Override\n+    public CompletableFuture<?> getAvailableFuture() {\n+        return availabilityHelper.getAvailableFuture();\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // BufferPoolFactory\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public BufferPool createBufferPool(int numRequiredBuffers, int maxUsedBuffers)\n+            throws IOException {\n+        return internalCreateBufferPool(numRequiredBuffers, maxUsedBuffers, 0, Integer.MAX_VALUE);\n+    }\n+\n+    @Override\n+    public BufferPool createBufferPool(\n+            int numRequiredBuffers,\n+            int maxUsedBuffers,\n+            int numSubpartitions,\n+            int maxBuffersPerChannel)\n+            throws IOException {\n+        return internalCreateBufferPool(\n+                numRequiredBuffers, maxUsedBuffers, numSubpartitions, maxBuffersPerChannel);\n+    }\n+\n+    private BufferPool internalCreateBufferPool(\n+            int numRequiredBuffers,\n+            int maxUsedBuffers,\n+            int numSubpartitions,\n+            int maxBuffersPerChannel)\n+            throws IOException {\n+\n+        // It is necessary to use a separate lock from the one used for buffer\n+        // requests to ensure deadlock freedom for failure cases.\n+        synchronized (factoryLock) {\n+            if (isDestroyed) {\n+                throw new IllegalStateException(\"Network buffer pool has already been destroyed.\");\n+            }\n+\n+            // Ensure that the number of required buffers can be satisfied.\n+            // With dynamic memory management this should become obsolete.\n+            if (numTotalRequiredBuffers + numRequiredBuffers > totalNumberOfMemorySegments) {\n+                throw new IOException(\n+                        String.format(\n+                                \"Insufficient number of network buffers: \"\n+                                        + \"required %d, but only %d available. %s.\",\n+                                numRequiredBuffers,\n+                                totalNumberOfMemorySegments - numTotalRequiredBuffers,\n+                                getConfigDescription()));\n+            }\n+\n+            this.numTotalRequiredBuffers += numRequiredBuffers;\n+\n+            // We are good to go, create a new buffer pool and redistribute\n+            // non-fixed size buffers.\n+            LocalBufferPool localBufferPool =\n+                    new LocalBufferPool(\n+                            this,\n+                            numRequiredBuffers,\n+                            maxUsedBuffers,\n+                            numSubpartitions,\n+                            maxBuffersPerChannel);\n+\n+            allBufferPools.add(localBufferPool);\n+\n+            redistributeBuffers();\n+\n+            return localBufferPool;\n+        }\n+    }\n+\n+    @Override\n+    public void destroyBufferPool(BufferPool bufferPool) {\n+        if (!(bufferPool instanceof LocalBufferPool)) {\n+            throw new IllegalArgumentException(\"bufferPool is no LocalBufferPool\");\n+        }\n+\n+        synchronized (factoryLock) {\n+            if (allBufferPools.remove(bufferPool)) {\n+                numTotalRequiredBuffers -= bufferPool.getNumberOfRequiredMemorySegments();\n+\n+                redistributeBuffers();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Destroys all buffer pools that allocate their buffers from this buffer pool (created via\n+     * {@link #createBufferPool(int, int)}).\n+     */\n+    public void destroyAllBufferPools() {\n+        synchronized (factoryLock) {\n+            // create a copy to avoid concurrent modification exceptions\n+            LocalBufferPool[] poolsCopy =\n+                    allBufferPools.toArray(new LocalBufferPool[allBufferPools.size()]);\n+\n+            for (LocalBufferPool pool : poolsCopy) {\n+                pool.lazyDestroy();\n+            }\n+\n+            // some sanity checks\n+            if (allBufferPools.size() > 0 || numTotalRequiredBuffers > 0) {\n+                throw new IllegalStateException(\n+                        \"NetworkBufferPool is not empty after destroying all LocalBufferPools\");\n+            }\n+        }\n+    }\n+\n+    // Must be called from synchronized block\n+    private void tryRedistributeBuffers(int numberOfSegmentsToRequest) throws IOException {\n+        assert Thread.holdsLock(factoryLock);\n+\n+        if (numTotalRequiredBuffers + numberOfSegmentsToRequest > totalNumberOfMemorySegments) {\n+            throw new IOException(\n+                    String.format(\n+                            \"Insufficient number of network buffers: \"\n+                                    + \"required %d, but only %d available. %s.\",\n+                            numberOfSegmentsToRequest,\n+                            totalNumberOfMemorySegments - numTotalRequiredBuffers,\n+                            getConfigDescription()));\n+        }\n+\n+        this.numTotalRequiredBuffers += numberOfSegmentsToRequest;\n+\n+        try {\n+            redistributeBuffers();\n+        } catch (Throwable t) {\n+            this.numTotalRequiredBuffers -= numberOfSegmentsToRequest;\n+\n+            redistributeBuffers();\n+            ExceptionUtils.rethrow(t);\n+        }\n+    }\n+\n+    // Must be called from synchronized block\n+    private void redistributeBuffers() {\n+        assert Thread.holdsLock(factoryLock);\n+\n+        // All buffers, which are not among the required ones\n+        final int numAvailableMemorySegment = totalNumberOfMemorySegments - numTotalRequiredBuffers;\n+\n+        if (numAvailableMemorySegment == 0) {\n+            // in this case, we need to redistribute buffers so that every pool gets its minimum\n+            for (LocalBufferPool bufferPool : allBufferPools) {\n+                bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments());\n+            }\n+            return;\n+        }\n+\n+        /*\n+         * With buffer pools being potentially limited, let's distribute the available memory\n+         * segments based on the capacity of each buffer pool, i.e. the maximum number of segments\n+         * an unlimited buffer pool can take is numAvailableMemorySegment, for limited buffer pools\n+         * it may be less. Based on this and the sum of all these values (totalCapacity), we build\n+         * a ratio that we use to distribute the buffers.\n+         */\n+\n+        long totalCapacity = 0; // long to avoid int overflow\n+\n+        for (LocalBufferPool bufferPool : allBufferPools) {\n+            int excessMax =\n+                    bufferPool.getMaxNumberOfMemorySegments()\n+                            - bufferPool.getNumberOfRequiredMemorySegments();\n+            totalCapacity += Math.min(numAvailableMemorySegment, excessMax);\n+        }\n+\n+        // no capacity to receive additional buffers?\n+        if (totalCapacity == 0) {\n+            return; // necessary to avoid div by zero when nothing to re-distribute\n+        }\n+\n+        // since one of the arguments of 'min(a,b)' is a positive int, this is actually\n+        // guaranteed to be within the 'int' domain\n+        // (we use a checked downCast to handle possible bugs more gracefully).\n+        final int memorySegmentsToDistribute =\n+                MathUtils.checkedDownCast(Math.min(numAvailableMemorySegment, totalCapacity));\n+\n+        long totalPartsUsed = 0; // of totalCapacity\n+        int numDistributedMemorySegment = 0;\n+        for (LocalBufferPool bufferPool : allBufferPools) {\n+            int excessMax =\n+                    bufferPool.getMaxNumberOfMemorySegments()\n+                            - bufferPool.getNumberOfRequiredMemorySegments();\n+\n+            // shortcut\n+            if (excessMax == 0) {\n+                continue;\n+            }\n+\n+            totalPartsUsed += Math.min(numAvailableMemorySegment, excessMax);\n+\n+            // avoid remaining buffers by looking at the total capacity that should have been\n+            // re-distributed up until here\n+            // the downcast will always succeed, because both arguments of the subtraction are in\n+            // the 'int' domain\n+            final int mySize =\n+                    MathUtils.checkedDownCast(\n+                            memorySegmentsToDistribute * totalPartsUsed / totalCapacity\n+                                    - numDistributedMemorySegment);\n+\n+            numDistributedMemorySegment += mySize;\n+            bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments() + mySize);\n+        }\n+\n+        assert (totalPartsUsed == totalCapacity);\n+        assert (numDistributedMemorySegment == memorySegmentsToDistribute);\n+    }\n+\n+    private String getConfigDescription() {\n+        return String.format(\n+                \"The total number of network buffers is currently set to %d of %d bytes each. \"\n+                        + \"You can increase this number by setting the configuration keys '%s', '%s', and '%s'\",\n+                totalNumberOfMemorySegments,\n+                memorySegmentSize,\n+                TaskManagerOptions.NETWORK_MEMORY_FRACTION.key(),\n+                TaskManagerOptions.NETWORK_MEMORY_MIN.key(),\n+                TaskManagerOptions.NETWORK_MEMORY_MAX.key());\n+    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\nindex 102d16381fa..6112d7d023c 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\n", "chunk": "@@ -50,490 +50,502 @@ import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n- * The NetworkBufferPool is a fixed size pool of {@link MemorySegment} instances\n- * for the network stack.\n+ * The NetworkBufferPool is a fixed size pool of {@link MemorySegment} instances for the network\n+ * stack.\n  *\n  * <p>The NetworkBufferPool creates {@link LocalBufferPool}s from which the individual tasks draw\n  * the buffers for the network data transfer. When new local buffer pools are created, the\n  * NetworkBufferPool dynamically redistributes the buffers between the pools.\n  */\n-public class NetworkBufferPool implements BufferPoolFactory, MemorySegmentProvider, AvailabilityProvider {\n+public class NetworkBufferPool\n+        implements BufferPoolFactory, MemorySegmentProvider, AvailabilityProvider {\n \n-\tprivate static final Logger LOG = LoggerFactory.getLogger(NetworkBufferPool.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(NetworkBufferPool.class);\n+\n+    private final int totalNumberOfMemorySegments;\n \n-\tprivate final int totalNumberOfMemorySegments;\n-\n-\tprivate final int memorySegmentSize;\n-\n-\tprivate final ArrayDeque<MemorySegment> availableMemorySegments;\n-\n-\tprivate volatile boolean isDestroyed;\n-\n-\t// ---- Managed buffer pools ----------------------------------------------\n-\n-\tprivate final Object factoryLock = new Object();\n-\n-\tprivate final Set<LocalBufferPool> allBufferPools = new HashSet<>();\n-\n-\tprivate int numTotalRequiredBuffers;\n-\n-\tprivate final int numberOfSegmentsToRequest;\n-\n-\tprivate final Duration requestSegmentsTimeout;\n-\n-\tprivate final AvailabilityHelper availabilityHelper = new AvailabilityHelper();\n-\n-\t@VisibleForTesting\n-\tpublic NetworkBufferPool(int numberOfSegmentsToAllocate, int segmentSize, int numberOfSegmentsToRequest) {\n-\t\tthis(numberOfSegmentsToAllocate, segmentSize, numberOfSegmentsToRequest, Duration.ofMillis(Integer.MAX_VALUE));\n-\t}\n-\n-\t/**\n-\t * Allocates all {@link MemorySegment} instances managed by this pool.\n-\t */\n-\tpublic NetworkBufferPool(\n-\t\t\tint numberOfSegmentsToAllocate,\n-\t\t\tint segmentSize,\n-\t\t\tint numberOfSegmentsToRequest,\n-\t\t\tDuration requestSegmentsTimeout) {\n-\t\tthis.totalNumberOfMemorySegments = numberOfSegmentsToAllocate;\n-\t\tthis.memorySegmentSize = segmentSize;\n-\n-\t\tcheckArgument(numberOfSegmentsToRequest >= 0, \"The number of required buffers should be non-negative.\");\n-\t\tthis.numberOfSegmentsToRequest = numberOfSegmentsToRequest;\n-\n-\t\tPreconditions.checkNotNull(requestSegmentsTimeout);\n-\t\tcheckArgument(requestSegmentsTimeout.toMillis() > 0,\n-\t\t\t\t\"The timeout for requesting exclusive buffers should be positive.\");\n-\t\tthis.requestSegmentsTimeout = requestSegmentsTimeout;\n-\n-\t\tfinal long sizeInLong = (long) segmentSize;\n-\n-\t\ttry {\n-\t\t\tthis.availableMemorySegments = new ArrayDeque<>(numberOfSegmentsToAllocate);\n-\t\t}\n-\t\tcatch (OutOfMemoryError err) {\n-\t\t\tthrow new OutOfMemoryError(\"Could not allocate buffer queue of length \"\n-\t\t\t\t\t+ numberOfSegmentsToAllocate + \" - \" + err.getMessage());\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tfor (int i = 0; i < numberOfSegmentsToAllocate; i++) {\n-\t\t\t\tavailableMemorySegments.add(MemorySegmentFactory.allocateUnpooledOffHeapMemory(segmentSize, null));\n-\t\t\t}\n-\t\t}\n-\t\tcatch (OutOfMemoryError err) {\n-\t\t\tint allocated = availableMemorySegments.size();\n-\n-\t\t\t// free some memory\n-\t\t\tavailableMemorySegments.clear();\n-\n-\t\t\tlong requiredMb = (sizeInLong * numberOfSegmentsToAllocate) >> 20;\n-\t\t\tlong allocatedMb = (sizeInLong * allocated) >> 20;\n-\t\t\tlong missingMb = requiredMb - allocatedMb;\n-\n-\t\t\tthrow new OutOfMemoryError(\"Could not allocate enough memory segments for NetworkBufferPool \" +\n-\t\t\t\t\t\"(required (Mb): \" + requiredMb +\n-\t\t\t\t\t\", allocated (Mb): \" + allocatedMb +\n-\t\t\t\t\t\", missing (Mb): \" + missingMb + \"). Cause: \" + err.getMessage());\n-\t\t}\n-\n-\t\tavailabilityHelper.resetAvailable();\n-\n-\t\tlong allocatedMb = (sizeInLong * availableMemorySegments.size()) >> 20;\n-\n-\t\tLOG.info(\"Allocated {} MB for network buffer pool (number of memory segments: {}, bytes per segment: {}).\",\n-\t\t\t\tallocatedMb, availableMemorySegments.size(), segmentSize);\n-\t}\n-\n-\t@Nullable\n-\tpublic MemorySegment requestMemorySegment() {\n-\t\tsynchronized (availableMemorySegments) {\n-\t\t\treturn internalRequestMemorySegment();\n-\t\t}\n-\t}\n-\n-\tpublic void recycle(MemorySegment segment) {\n-\t\t// Adds the segment back to the queue, which does not immediately free the memory\n-\t\t// however, since this happens when references to the global pool are also released,\n-\t\t// making the availableMemorySegments queue and its contained object reclaimable\n-\t\tinternalRecycleMemorySegments(Collections.singleton(checkNotNull(segment)));\n-\t}\n-\n-\t@Override\n-\tpublic List<MemorySegment> requestMemorySegments() throws IOException {\n-\t\tif (numberOfSegmentsToRequest <= 0) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\n-\t\tsynchronized (factoryLock) {\n-\t\t\tif (isDestroyed) {\n-\t\t\t\tthrow new IllegalStateException(\"Network buffer pool has already been destroyed.\");\n-\t\t\t}\n-\n-\t\t\ttryRedistributeBuffers();\n-\t\t}\n-\n-\t\tfinal List<MemorySegment> segments = new ArrayList<>(numberOfSegmentsToRequest);\n-\t\ttry {\n-\t\t\tfinal Deadline deadline = Deadline.fromNow(requestSegmentsTimeout);\n-\t\t\twhile (true) {\n-\t\t\t\tif (isDestroyed) {\n-\t\t\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n-\t\t\t\t}\n-\n-\t\t\t\tMemorySegment segment;\n-\t\t\t\tsynchronized (availableMemorySegments) {\n-\t\t\t\t\tif ((segment = internalRequestMemorySegment()) == null) {\n-\t\t\t\t\t\tavailableMemorySegments.wait(2000);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (segment != null) {\n-\t\t\t\t\tsegments.add(segment);\n-\t\t\t\t}\n-\n-\t\t\t\tif (segments.size() >= numberOfSegmentsToRequest) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\n-\t\t\t\tif (!deadline.hasTimeLeft()) {\n-\t\t\t\t\tthrow new IOException(String.format(\"Timeout triggered when requesting exclusive buffers: %s, \" +\n-\t\t\t\t\t\t\t\t\t\" or you may increase the timeout which is %dms by setting the key '%s'.\",\n-\t\t\t\t\t\t\tgetConfigDescription(),\n-\t\t\t\t\t\t\trequestSegmentsTimeout.toMillis(),\n-\t\t\t\t\t\t\tNettyShuffleEnvironmentOptions.NETWORK_EXCLUSIVE_BUFFERS_REQUEST_TIMEOUT_MILLISECONDS.key()));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Throwable e) {\n-\t\t\ttry {\n-\t\t\t\trecycleMemorySegments(segments, numberOfSegmentsToRequest);\n-\t\t\t} catch (IOException inner) {\n-\t\t\t\te.addSuppressed(inner);\n-\t\t\t}\n-\t\t\tExceptionUtils.rethrowIOException(e);\n-\t\t}\n-\n-\t\treturn segments;\n-\t}\n-\n-\t@Nullable\n-\tprivate MemorySegment internalRequestMemorySegment() {\n-\t\tassert Thread.holdsLock(availableMemorySegments);\n-\n-\t\tfinal MemorySegment segment = availableMemorySegments.poll();\n-\t\tif (availableMemorySegments.isEmpty() && segment != null) {\n-\t\t\tavailabilityHelper.resetUnavailable();\n-\t\t}\n-\t\treturn segment;\n-\t}\n-\n-\t@Override\n-\tpublic void recycleMemorySegments(Collection<MemorySegment> segments) throws IOException {\n-\t\trecycleMemorySegments(segments, segments.size());\n-\t}\n-\n-\tprivate void recycleMemorySegments(Collection<MemorySegment> segments, int size) throws IOException {\n-\t\tinternalRecycleMemorySegments(segments);\n-\n-\t\tsynchronized (factoryLock) {\n-\t\t\tnumTotalRequiredBuffers -= size;\n-\n-\t\t\t// note: if this fails, we're fine for the buffer pool since we already recycled the segments\n-\t\t\tredistributeBuffers();\n-\t\t}\n-\t}\n-\n-\tprivate void internalRecycleMemorySegments(Collection<MemorySegment> segments) {\n-\t\tCompletableFuture<?> toNotify = null;\n-\t\tsynchronized (availableMemorySegments) {\n-\t\t\tif (availableMemorySegments.isEmpty() && !segments.isEmpty()) {\n-\t\t\t\ttoNotify = availabilityHelper.getUnavailableToResetAvailable();\n-\t\t\t}\n-\t\t\tavailableMemorySegments.addAll(segments);\n-\t\t\tavailableMemorySegments.notifyAll();\n-\t\t}\n-\n-\t\tif (toNotify != null) {\n-\t\t\ttoNotify.complete(null);\n-\t\t}\n-\t}\n-\n-\tpublic void destroy() {\n-\t\tsynchronized (factoryLock) {\n-\t\t\tisDestroyed = true;\n-\t\t}\n-\n-\t\tsynchronized (availableMemorySegments) {\n-\t\t\tMemorySegment segment;\n-\t\t\twhile ((segment = availableMemorySegments.poll()) != null) {\n-\t\t\t\tsegment.free();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic boolean isDestroyed() {\n-\t\treturn isDestroyed;\n-\t}\n-\n-\tpublic int getTotalNumberOfMemorySegments() {\n-\t\treturn totalNumberOfMemorySegments;\n-\t}\n-\n-\tpublic int getNumberOfAvailableMemorySegments() {\n-\t\tsynchronized (availableMemorySegments) {\n-\t\t\treturn availableMemorySegments.size();\n-\t\t}\n-\t}\n-\n-\tpublic int getNumberOfRegisteredBufferPools() {\n-\t\tsynchronized (factoryLock) {\n-\t\t\treturn allBufferPools.size();\n-\t\t}\n-\t}\n-\n-\tpublic int countBuffers() {\n-\t\tint buffers = 0;\n-\n-\t\tsynchronized (factoryLock) {\n-\t\t\tfor (BufferPool bp : allBufferPools) {\n-\t\t\t\tbuffers += bp.getNumBuffers();\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn buffers;\n-\t}\n-\n-\t/**\n-\t * Returns a future that is completed when there are free segments\n-\t * in this pool.\n-\t */\n-\t@Override\n-\tpublic CompletableFuture<?> getAvailableFuture() {\n-\t\treturn availabilityHelper.getAvailableFuture();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// BufferPoolFactory\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic BufferPool createBufferPool(int numRequiredBuffers, int maxUsedBuffers) throws IOException {\n-\t\treturn internalCreateBufferPool(\n-\t\t\tnumRequiredBuffers,\n-\t\t\tmaxUsedBuffers,\n-\t\t\tnull,\n-\t\t\t0,\n-\t\t\tInteger.MAX_VALUE);\n-\t}\n-\n-\t@Override\n-\tpublic BufferPool createBufferPool(\n-\t\t\tint numRequiredBuffers,\n-\t\t\tint maxUsedBuffers,\n-\t\t\tBufferPoolOwner bufferPoolOwner,\n-\t\t\tint numSubpartitions,\n-\t\t\tint maxBuffersPerChannel) throws IOException {\n-\t\treturn internalCreateBufferPool(\n-\t\t\tnumRequiredBuffers,\n-\t\t\tmaxUsedBuffers,\n-\t\t\tbufferPoolOwner,\n-\t\t\tnumSubpartitions,\n-\t\t\tmaxBuffersPerChannel);\n-\t}\n-\n-\tprivate BufferPool internalCreateBufferPool(\n-\t\t\tint numRequiredBuffers,\n-\t\t\tint maxUsedBuffers,\n-\t\t\t@Nullable BufferPoolOwner bufferPoolOwner,\n-\t\t\tint numSubpartitions,\n-\t\t\tint maxBuffersPerChannel) throws IOException {\n-\n-\t\t// It is necessary to use a separate lock from the one used for buffer\n-\t\t// requests to ensure deadlock freedom for failure cases.\n-\t\tsynchronized (factoryLock) {\n-\t\t\tif (isDestroyed) {\n-\t\t\t\tthrow new IllegalStateException(\"Network buffer pool has already been destroyed.\");\n-\t\t\t}\n-\n-\t\t\t// Ensure that the number of required buffers can be satisfied.\n-\t\t\t// With dynamic memory management this should become obsolete.\n-\t\t\tif (numTotalRequiredBuffers + numRequiredBuffers > totalNumberOfMemorySegments) {\n-\t\t\t\tthrow new IOException(String.format(\"Insufficient number of network buffers: \" +\n-\t\t\t\t\t\t\t\t\"required %d, but only %d available. %s.\",\n-\t\t\t\t\t\tnumRequiredBuffers,\n-\t\t\t\t\t\ttotalNumberOfMemorySegments - numTotalRequiredBuffers,\n-\t\t\t\t\t\tgetConfigDescription()));\n-\t\t\t}\n-\n-\t\t\tthis.numTotalRequiredBuffers += numRequiredBuffers;\n-\n-\t\t\t// We are good to go, create a new buffer pool and redistribute\n-\t\t\t// non-fixed size buffers.\n-\t\t\tLocalBufferPool localBufferPool =\n-\t\t\t\tnew LocalBufferPool(\n-\t\t\t\t\tthis,\n-\t\t\t\t\tnumRequiredBuffers,\n-\t\t\t\t\tmaxUsedBuffers,\n-\t\t\t\t\tbufferPoolOwner,\n-\t\t\t\t\tnumSubpartitions,\n-\t\t\t\t\tmaxBuffersPerChannel);\n-\n-\t\t\tallBufferPools.add(localBufferPool);\n-\n-\t\t\ttry {\n-\t\t\t\tredistributeBuffers();\n-\t\t\t} catch (IOException e) {\n-\t\t\t\ttry {\n-\t\t\t\t\tdestroyBufferPool(localBufferPool);\n-\t\t\t\t} catch (IOException inner) {\n-\t\t\t\t\te.addSuppressed(inner);\n-\t\t\t\t}\n-\t\t\t\tExceptionUtils.rethrowIOException(e);\n-\t\t\t}\n-\n-\t\t\treturn localBufferPool;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void destroyBufferPool(BufferPool bufferPool) throws IOException {\n-\t\tif (!(bufferPool instanceof LocalBufferPool)) {\n-\t\t\tthrow new IllegalArgumentException(\"bufferPool is no LocalBufferPool\");\n-\t\t}\n-\n-\t\tsynchronized (factoryLock) {\n-\t\t\tif (allBufferPools.remove(bufferPool)) {\n-\t\t\t\tnumTotalRequiredBuffers -= bufferPool.getNumberOfRequiredMemorySegments();\n-\n-\t\t\t\tredistributeBuffers();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Destroys all buffer pools that allocate their buffers from this\n-\t * buffer pool (created via {@link #createBufferPool(int, int)}).\n-\t */\n-\tpublic void destroyAllBufferPools() {\n-\t\tsynchronized (factoryLock) {\n-\t\t\t// create a copy to avoid concurrent modification exceptions\n-\t\t\tLocalBufferPool[] poolsCopy = allBufferPools.toArray(new LocalBufferPool[allBufferPools.size()]);\n-\n-\t\t\tfor (LocalBufferPool pool : poolsCopy) {\n-\t\t\t\tpool.lazyDestroy();\n-\t\t\t}\n-\n-\t\t\t// some sanity checks\n-\t\t\tif (allBufferPools.size() > 0 || numTotalRequiredBuffers > 0) {\n-\t\t\t\tthrow new IllegalStateException(\"NetworkBufferPool is not empty after destroying all LocalBufferPools\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Must be called from synchronized block\n-\tprivate void tryRedistributeBuffers() throws IOException {\n-\t\tassert Thread.holdsLock(factoryLock);\n-\n-\t\tif (numTotalRequiredBuffers + numberOfSegmentsToRequest > totalNumberOfMemorySegments) {\n-\t\t\tthrow new IOException(String.format(\"Insufficient number of network buffers: \" +\n-\t\t\t\t\t\t\t\"required %d, but only %d available. %s.\",\n-\t\t\t\t\tnumberOfSegmentsToRequest,\n-\t\t\t\t\ttotalNumberOfMemorySegments - numTotalRequiredBuffers,\n-\t\t\t\t\tgetConfigDescription()));\n-\t\t}\n-\n-\t\tthis.numTotalRequiredBuffers += numberOfSegmentsToRequest;\n-\n-\t\ttry {\n-\t\t\tredistributeBuffers();\n-\t\t} catch (Throwable t) {\n-\t\t\tthis.numTotalRequiredBuffers -= numberOfSegmentsToRequest;\n-\n-\t\t\ttry {\n-\t\t\t\tredistributeBuffers();\n-\t\t\t} catch (IOException inner) {\n-\t\t\t\tt.addSuppressed(inner);\n-\t\t\t}\n-\t\t\tExceptionUtils.rethrowIOException(t);\n-\t\t}\n-\t}\n-\n-\t// Must be called from synchronized block\n-\tprivate void redistributeBuffers() throws IOException {\n-\t\tassert Thread.holdsLock(factoryLock);\n-\n-\t\t// All buffers, which are not among the required ones\n-\t\tfinal int numAvailableMemorySegment = totalNumberOfMemorySegments - numTotalRequiredBuffers;\n-\n-\t\tif (numAvailableMemorySegment == 0) {\n-\t\t\t// in this case, we need to redistribute buffers so that every pool gets its minimum\n-\t\t\tfor (LocalBufferPool bufferPool : allBufferPools) {\n-\t\t\t\tbufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments());\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t/*\n-\t\t * With buffer pools being potentially limited, let's distribute the available memory\n-\t\t * segments based on the capacity of each buffer pool, i.e. the maximum number of segments\n-\t\t * an unlimited buffer pool can take is numAvailableMemorySegment, for limited buffer pools\n-\t\t * it may be less. Based on this and the sum of all these values (totalCapacity), we build\n-\t\t * a ratio that we use to distribute the buffers.\n-\t\t */\n-\n-\t\tlong totalCapacity = 0; // long to avoid int overflow\n-\n-\t\tfor (LocalBufferPool bufferPool : allBufferPools) {\n-\t\t\tint excessMax = bufferPool.getMaxNumberOfMemorySegments() -\n-\t\t\t\tbufferPool.getNumberOfRequiredMemorySegments();\n-\t\t\ttotalCapacity += Math.min(numAvailableMemorySegment, excessMax);\n-\t\t}\n-\n-\t\t// no capacity to receive additional buffers?\n-\t\tif (totalCapacity == 0) {\n-\t\t\treturn; // necessary to avoid div by zero when nothing to re-distribute\n-\t\t}\n-\n-\t\t// since one of the arguments of 'min(a,b)' is a positive int, this is actually\n-\t\t// guaranteed to be within the 'int' domain\n-\t\t// (we use a checked downCast to handle possible bugs more gracefully).\n-\t\tfinal int memorySegmentsToDistribute = MathUtils.checkedDownCast(\n-\t\t\t\tMath.min(numAvailableMemorySegment, totalCapacity));\n-\n-\t\tlong totalPartsUsed = 0; // of totalCapacity\n-\t\tint numDistributedMemorySegment = 0;\n-\t\tfor (LocalBufferPool bufferPool : allBufferPools) {\n-\t\t\tint excessMax = bufferPool.getMaxNumberOfMemorySegments() -\n-\t\t\t\tbufferPool.getNumberOfRequiredMemorySegments();\n-\n-\t\t\t// shortcut\n-\t\t\tif (excessMax == 0) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\ttotalPartsUsed += Math.min(numAvailableMemorySegment, excessMax);\n-\n-\t\t\t// avoid remaining buffers by looking at the total capacity that should have been\n-\t\t\t// re-distributed up until here\n-\t\t\t// the downcast will always succeed, because both arguments of the subtraction are in the 'int' domain\n-\t\t\tfinal int mySize = MathUtils.checkedDownCast(\n-\t\t\t\t\tmemorySegmentsToDistribute * totalPartsUsed / totalCapacity - numDistributedMemorySegment);\n-\n-\t\t\tnumDistributedMemorySegment += mySize;\n-\t\t\tbufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments() + mySize);\n-\t\t}\n-\n-\t\tassert (totalPartsUsed == totalCapacity);\n-\t\tassert (numDistributedMemorySegment == memorySegmentsToDistribute);\n-\t}\n-\n-\tprivate String getConfigDescription() {\n-\t\treturn String.format(\"The total number of network buffers is currently set to %d of %d bytes each. \" +\n-\t\t\t\t\t\t\"You can increase this number by setting the configuration keys '%s', '%s', and '%s'\",\n-\t\t\t\ttotalNumberOfMemorySegments,\n-\t\t\t\tmemorySegmentSize,\n-\t\t\t\tTaskManagerOptions.NETWORK_MEMORY_FRACTION.key(),\n-\t\t\t\tTaskManagerOptions.NETWORK_MEMORY_MIN.key(),\n-\t\t\t\tTaskManagerOptions.NETWORK_MEMORY_MAX.key());\n-\t}\n+    private final int memorySegmentSize;\n+\n+    private final ArrayDeque<MemorySegment> availableMemorySegments;\n+\n+    private volatile boolean isDestroyed;\n+\n+    // ---- Managed buffer pools ----------------------------------------------\n+\n+    private final Object factoryLock = new Object();\n+\n+    private final Set<LocalBufferPool> allBufferPools = new HashSet<>();\n+\n+    private int numTotalRequiredBuffers;\n+\n+    private final Duration requestSegmentsTimeout;\n+\n+    private final AvailabilityHelper availabilityHelper = new AvailabilityHelper();\n+\n+    @VisibleForTesting\n+    public NetworkBufferPool(int numberOfSegmentsToAllocate, int segmentSize) {\n+        this(numberOfSegmentsToAllocate, segmentSize, Duration.ofMillis(Integer.MAX_VALUE));\n+    }\n+\n+    /** Allocates all {@link MemorySegment} instances managed by this pool. */\n+    public NetworkBufferPool(\n+            int numberOfSegmentsToAllocate, int segmentSize, Duration requestSegmentsTimeout) {\n+        this.totalNumberOfMemorySegments = numberOfSegmentsToAllocate;\n+        this.memorySegmentSize = segmentSize;\n+\n+        Preconditions.checkNotNull(requestSegmentsTimeout);\n+        checkArgument(\n+                requestSegmentsTimeout.toMillis() > 0,\n+                \"The timeout for requesting exclusive buffers should be positive.\");\n+        this.requestSegmentsTimeout = requestSegmentsTimeout;\n+\n+        final long sizeInLong = (long) segmentSize;\n+\n+        try {\n+            this.availableMemorySegments = new ArrayDeque<>(numberOfSegmentsToAllocate);\n+        } catch (OutOfMemoryError err) {\n+            throw new OutOfMemoryError(\n+                    \"Could not allocate buffer queue of length \"\n+                            + numberOfSegmentsToAllocate\n+                            + \" - \"\n+                            + err.getMessage());\n+        }\n+\n+        try {\n+            for (int i = 0; i < numberOfSegmentsToAllocate; i++) {\n+                availableMemorySegments.add(\n+                        MemorySegmentFactory.allocateUnpooledOffHeapMemory(segmentSize, null));\n+            }\n+        } catch (OutOfMemoryError err) {\n+            int allocated = availableMemorySegments.size();\n+\n+            // free some memory\n+            availableMemorySegments.clear();\n+\n+            long requiredMb = (sizeInLong * numberOfSegmentsToAllocate) >> 20;\n+            long allocatedMb = (sizeInLong * allocated) >> 20;\n+            long missingMb = requiredMb - allocatedMb;\n+\n+            throw new OutOfMemoryError(\n+                    \"Could not allocate enough memory segments for NetworkBufferPool \"\n+                            + \"(required (Mb): \"\n+                            + requiredMb\n+                            + \", allocated (Mb): \"\n+                            + allocatedMb\n+                            + \", missing (Mb): \"\n+                            + missingMb\n+                            + \"). Cause: \"\n+                            + err.getMessage());\n+        }\n+\n+        availabilityHelper.resetAvailable();\n+\n+        long allocatedMb = (sizeInLong * availableMemorySegments.size()) >> 20;\n+\n+        LOG.info(\n+                \"Allocated {} MB for network buffer pool (number of memory segments: {}, bytes per segment: {}).\",\n+                allocatedMb,\n+                availableMemorySegments.size(),\n+                segmentSize);\n+    }\n+\n+    @Nullable\n+    public MemorySegment requestMemorySegment() {\n+        synchronized (availableMemorySegments) {\n+            return internalRequestMemorySegment();\n+        }\n+    }\n+\n+    public void recycle(MemorySegment segment) {\n+        // Adds the segment back to the queue, which does not immediately free the memory\n+        // however, since this happens when references to the global pool are also released,\n+        // making the availableMemorySegments queue and its contained object reclaimable\n+        internalRecycleMemorySegments(Collections.singleton(checkNotNull(segment)));\n+    }\n+\n+    @Override\n+    public List<MemorySegment> requestMemorySegments(int numberOfSegmentsToRequest)\n+            throws IOException {\n+        checkArgument(\n+                numberOfSegmentsToRequest >= 0,\n+                \"Number of buffers to request must be non-negative.\");\n+\n+        synchronized (factoryLock) {\n+            if (isDestroyed) {\n+                throw new IllegalStateException(\"Network buffer pool has already been destroyed.\");\n+            }\n+\n+            if (numberOfSegmentsToRequest == 0) {\n+                return Collections.emptyList();\n+            }\n+\n+            tryRedistributeBuffers(numberOfSegmentsToRequest);\n+        }\n+\n+        final List<MemorySegment> segments = new ArrayList<>(numberOfSegmentsToRequest);\n+        try {\n+            final Deadline deadline = Deadline.fromNow(requestSegmentsTimeout);\n+            while (true) {\n+                if (isDestroyed) {\n+                    throw new IllegalStateException(\"Buffer pool is destroyed.\");\n+                }\n+\n+                MemorySegment segment;\n+                synchronized (availableMemorySegments) {\n+                    if ((segment = internalRequestMemorySegment()) == null) {\n+                        availableMemorySegments.wait(2000);\n+                    }\n+                }\n+                if (segment != null) {\n+                    segments.add(segment);\n+                }\n+\n+                if (segments.size() >= numberOfSegmentsToRequest) {\n+                    break;\n+                }\n+\n+                if (!deadline.hasTimeLeft()) {\n+                    throw new IOException(\n+                            String.format(\n+                                    \"Timeout triggered when requesting exclusive buffers: %s, \"\n+                                            + \" or you may increase the timeout which is %dms by setting the key '%s'.\",\n+                                    getConfigDescription(),\n+                                    requestSegmentsTimeout.toMillis(),\n+                                    NettyShuffleEnvironmentOptions\n+                                            .NETWORK_EXCLUSIVE_BUFFERS_REQUEST_TIMEOUT_MILLISECONDS\n+                                            .key()));\n+                }\n+            }\n+        } catch (Throwable e) {\n+            recycleMemorySegments(segments, numberOfSegmentsToRequest);\n+            ExceptionUtils.rethrowIOException(e);\n+        }\n+\n+        return segments;\n+    }\n+\n+    @Nullable\n+    private MemorySegment internalRequestMemorySegment() {\n+        assert Thread.holdsLock(availableMemorySegments);\n+\n+        final MemorySegment segment = availableMemorySegments.poll();\n+        if (availableMemorySegments.isEmpty() && segment != null) {\n+            availabilityHelper.resetUnavailable();\n+        }\n+        return segment;\n+    }\n+\n+    @Override\n+    public void recycleMemorySegments(Collection<MemorySegment> segments) {\n+        recycleMemorySegments(segments, segments.size());\n+    }\n+\n+    private void recycleMemorySegments(Collection<MemorySegment> segments, int size) {\n+        internalRecycleMemorySegments(segments);\n+\n+        synchronized (factoryLock) {\n+            numTotalRequiredBuffers -= size;\n+\n+            // note: if this fails, we're fine for the buffer pool since we already recycled the\n+            // segments\n+            redistributeBuffers();\n+        }\n+    }\n+\n+    private void internalRecycleMemorySegments(Collection<MemorySegment> segments) {\n+        CompletableFuture<?> toNotify = null;\n+        synchronized (availableMemorySegments) {\n+            if (availableMemorySegments.isEmpty() && !segments.isEmpty()) {\n+                toNotify = availabilityHelper.getUnavailableToResetAvailable();\n+            }\n+            availableMemorySegments.addAll(segments);\n+            availableMemorySegments.notifyAll();\n+        }\n+\n+        if (toNotify != null) {\n+            toNotify.complete(null);\n+        }\n+    }\n+\n+    public void destroy() {\n+        synchronized (factoryLock) {\n+            isDestroyed = true;\n+        }\n+\n+        synchronized (availableMemorySegments) {\n+            MemorySegment segment;\n+            while ((segment = availableMemorySegments.poll()) != null) {\n+                segment.free();\n+            }\n+        }\n+    }\n+\n+    public boolean isDestroyed() {\n+        return isDestroyed;\n+    }\n+\n+    public int getTotalNumberOfMemorySegments() {\n+        return isDestroyed() ? 0 : totalNumberOfMemorySegments;\n+    }\n+\n+    public long getTotalMemory() {\n+        return (long) getTotalNumberOfMemorySegments() * memorySegmentSize;\n+    }\n+\n+    public int getNumberOfAvailableMemorySegments() {\n+        synchronized (availableMemorySegments) {\n+            return availableMemorySegments.size();\n+        }\n+    }\n+\n+    public long getAvailableMemory() {\n+        return (long) getNumberOfAvailableMemorySegments() * memorySegmentSize;\n+    }\n+\n+    public int getNumberOfUsedMemorySegments() {\n+        return getTotalNumberOfMemorySegments() - getNumberOfAvailableMemorySegments();\n+    }\n+\n+    public long getUsedMemory() {\n+        return (long) getNumberOfUsedMemorySegments() * memorySegmentSize;\n+    }\n+\n+    public int getNumberOfRegisteredBufferPools() {\n+        synchronized (factoryLock) {\n+            return allBufferPools.size();\n+        }\n+    }\n+\n+    public int countBuffers() {\n+        int buffers = 0;\n+\n+        synchronized (factoryLock) {\n+            for (BufferPool bp : allBufferPools) {\n+                buffers += bp.getNumBuffers();\n+            }\n+        }\n+\n+        return buffers;\n+    }\n+\n+    /** Returns a future that is completed when there are free segments in this pool. */\n+    @Override\n+    public CompletableFuture<?> getAvailableFuture() {\n+        return availabilityHelper.getAvailableFuture();\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // BufferPoolFactory\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public BufferPool createBufferPool(int numRequiredBuffers, int maxUsedBuffers)\n+            throws IOException {\n+        return internalCreateBufferPool(numRequiredBuffers, maxUsedBuffers, 0, Integer.MAX_VALUE);\n+    }\n+\n+    @Override\n+    public BufferPool createBufferPool(\n+            int numRequiredBuffers,\n+            int maxUsedBuffers,\n+            int numSubpartitions,\n+            int maxBuffersPerChannel)\n+            throws IOException {\n+        return internalCreateBufferPool(\n+                numRequiredBuffers, maxUsedBuffers, numSubpartitions, maxBuffersPerChannel);\n+    }\n+\n+    private BufferPool internalCreateBufferPool(\n+            int numRequiredBuffers,\n+            int maxUsedBuffers,\n+            int numSubpartitions,\n+            int maxBuffersPerChannel)\n+            throws IOException {\n+\n+        // It is necessary to use a separate lock from the one used for buffer\n+        // requests to ensure deadlock freedom for failure cases.\n+        synchronized (factoryLock) {\n+            if (isDestroyed) {\n+                throw new IllegalStateException(\"Network buffer pool has already been destroyed.\");\n+            }\n+\n+            // Ensure that the number of required buffers can be satisfied.\n+            // With dynamic memory management this should become obsolete.\n+            if (numTotalRequiredBuffers + numRequiredBuffers > totalNumberOfMemorySegments) {\n+                throw new IOException(\n+                        String.format(\n+                                \"Insufficient number of network buffers: \"\n+                                        + \"required %d, but only %d available. %s.\",\n+                                numRequiredBuffers,\n+                                totalNumberOfMemorySegments - numTotalRequiredBuffers,\n+                                getConfigDescription()));\n+            }\n+\n+            this.numTotalRequiredBuffers += numRequiredBuffers;\n+\n+            // We are good to go, create a new buffer pool and redistribute\n+            // non-fixed size buffers.\n+            LocalBufferPool localBufferPool =\n+                    new LocalBufferPool(\n+                            this,\n+                            numRequiredBuffers,\n+                            maxUsedBuffers,\n+                            numSubpartitions,\n+                            maxBuffersPerChannel);\n+\n+            allBufferPools.add(localBufferPool);\n+\n+            redistributeBuffers();\n+\n+            return localBufferPool;\n+        }\n+    }\n+\n+    @Override\n+    public void destroyBufferPool(BufferPool bufferPool) {\n+        if (!(bufferPool instanceof LocalBufferPool)) {\n+            throw new IllegalArgumentException(\"bufferPool is no LocalBufferPool\");\n+        }\n+\n+        synchronized (factoryLock) {\n+            if (allBufferPools.remove(bufferPool)) {\n+                numTotalRequiredBuffers -= bufferPool.getNumberOfRequiredMemorySegments();\n+\n+                redistributeBuffers();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Destroys all buffer pools that allocate their buffers from this buffer pool (created via\n+     * {@link #createBufferPool(int, int)}).\n+     */\n+    public void destroyAllBufferPools() {\n+        synchronized (factoryLock) {\n+            // create a copy to avoid concurrent modification exceptions\n+            LocalBufferPool[] poolsCopy =\n+                    allBufferPools.toArray(new LocalBufferPool[allBufferPools.size()]);\n+\n+            for (LocalBufferPool pool : poolsCopy) {\n+                pool.lazyDestroy();\n+            }\n+\n+            // some sanity checks\n+            if (allBufferPools.size() > 0 || numTotalRequiredBuffers > 0) {\n+                throw new IllegalStateException(\n+                        \"NetworkBufferPool is not empty after destroying all LocalBufferPools\");\n+            }\n+        }\n+    }\n+\n+    // Must be called from synchronized block\n+    private void tryRedistributeBuffers(int numberOfSegmentsToRequest) throws IOException {\n+        assert Thread.holdsLock(factoryLock);\n+\n+        if (numTotalRequiredBuffers + numberOfSegmentsToRequest > totalNumberOfMemorySegments) {\n+            throw new IOException(\n+                    String.format(\n+                            \"Insufficient number of network buffers: \"\n+                                    + \"required %d, but only %d available. %s.\",\n+                            numberOfSegmentsToRequest,\n+                            totalNumberOfMemorySegments - numTotalRequiredBuffers,\n+                            getConfigDescription()));\n+        }\n+\n+        this.numTotalRequiredBuffers += numberOfSegmentsToRequest;\n+\n+        try {\n+            redistributeBuffers();\n+        } catch (Throwable t) {\n+            this.numTotalRequiredBuffers -= numberOfSegmentsToRequest;\n+\n+            redistributeBuffers();\n+            ExceptionUtils.rethrow(t);\n+        }\n+    }\n+\n+    // Must be called from synchronized block\n+    private void redistributeBuffers() {\n+        assert Thread.holdsLock(factoryLock);\n+\n+        // All buffers, which are not among the required ones\n+        final int numAvailableMemorySegment = totalNumberOfMemorySegments - numTotalRequiredBuffers;\n+\n+        if (numAvailableMemorySegment == 0) {\n+            // in this case, we need to redistribute buffers so that every pool gets its minimum\n+            for (LocalBufferPool bufferPool : allBufferPools) {\n+                bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments());\n+            }\n+            return;\n+        }\n+\n+        /*\n+         * With buffer pools being potentially limited, let's distribute the available memory\n+         * segments based on the capacity of each buffer pool, i.e. the maximum number of segments\n+         * an unlimited buffer pool can take is numAvailableMemorySegment, for limited buffer pools\n+         * it may be less. Based on this and the sum of all these values (totalCapacity), we build\n+         * a ratio that we use to distribute the buffers.\n+         */\n+\n+        long totalCapacity = 0; // long to avoid int overflow\n+\n+        for (LocalBufferPool bufferPool : allBufferPools) {\n+            int excessMax =\n+                    bufferPool.getMaxNumberOfMemorySegments()\n+                            - bufferPool.getNumberOfRequiredMemorySegments();\n+            totalCapacity += Math.min(numAvailableMemorySegment, excessMax);\n+        }\n+\n+        // no capacity to receive additional buffers?\n+        if (totalCapacity == 0) {\n+            return; // necessary to avoid div by zero when nothing to re-distribute\n+        }\n+\n+        // since one of the arguments of 'min(a,b)' is a positive int, this is actually\n+        // guaranteed to be within the 'int' domain\n+        // (we use a checked downCast to handle possible bugs more gracefully).\n+        final int memorySegmentsToDistribute =\n+                MathUtils.checkedDownCast(Math.min(numAvailableMemorySegment, totalCapacity));\n+\n+        long totalPartsUsed = 0; // of totalCapacity\n+        int numDistributedMemorySegment = 0;\n+        for (LocalBufferPool bufferPool : allBufferPools) {\n+            int excessMax =\n+                    bufferPool.getMaxNumberOfMemorySegments()\n+                            - bufferPool.getNumberOfRequiredMemorySegments();\n+\n+            // shortcut\n+            if (excessMax == 0) {\n+                continue;\n+            }\n+\n+            totalPartsUsed += Math.min(numAvailableMemorySegment, excessMax);\n+\n+            // avoid remaining buffers by looking at the total capacity that should have been\n+            // re-distributed up until here\n+            // the downcast will always succeed, because both arguments of the subtraction are in\n+            // the 'int' domain\n+            final int mySize =\n+                    MathUtils.checkedDownCast(\n+                            memorySegmentsToDistribute * totalPartsUsed / totalCapacity\n+                                    - numDistributedMemorySegment);\n+\n+            numDistributedMemorySegment += mySize;\n+            bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments() + mySize);\n+        }\n+\n+        assert (totalPartsUsed == totalCapacity);\n+        assert (numDistributedMemorySegment == memorySegmentsToDistribute);\n+    }\n+\n+    private String getConfigDescription() {\n+        return String.format(\n+                \"The total number of network buffers is currently set to %d of %d bytes each. \"\n+                        + \"You can increase this number by setting the configuration keys '%s', '%s', and '%s'\",\n+                totalNumberOfMemorySegments,\n+                memorySegmentSize,\n+                TaskManagerOptions.NETWORK_MEMORY_FRACTION.key(),\n+                TaskManagerOptions.NETWORK_MEMORY_MIN.key(),\n+                TaskManagerOptions.NETWORK_MEMORY_MAX.key());\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "d82b69ef5dbe353d0afbd5645f9eaf32ebd4e2f5", "committedDate": "2021-08-31 08:04:07 +0200", "message": "[FLINK-24035][network] Guarantee that the LocalBufferPool is initialized with one buffer"}, {"oid": "75adb3214a4c4142e52e3af9d6f57da2e09b2849", "committedDate": "2021-09-01 18:08:15 +0200", "message": "[FLINK-24035][network][refactor] Move the blocking allocation of one floating buffer logic from the constructor of LocalBufferPool to SingleInputGate#setupChannels()"}, {"oid": "38f7c593538d78e67ed75f006826b9fc3e97826e", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[hotfix] Rename some methods of NetworkBufferPool and add more comments for better readability"}, {"oid": "1ea2a7a5c90288dff08f702bac71de4d91c00f6f", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[FLINK-25407][network] Fix the issues caused by FLINK-24035"}, {"oid": "dea617c69c04f0f2405fa9df8bdf952ebdd5d650", "committedDate": "2022-01-26 09:57:45 +0100", "message": "[FLINK-25590][metrics] Introduce RequestedMemoryUsage and log warnings if usage exceeds 100%"}, {"oid": "cfe5e9a728d702aac0652dffb30cbe155b152ada", "committedDate": "2022-01-26 09:57:45 +0100", "message": "fixup! [FLINK-25590][metrics] Introduce RequestedMemoryUsage and log warnings if usage exceeds 100%"}, {"oid": "855348a9ac482f141131c302b21d4a67e4c3e0c7", "committedDate": "2022-02-07 17:13:41 +0800", "message": "[FLINK-25741][runtime] Skip buffer pools which have no floating buffer in buffer redistributing."}, {"oid": "3f45abd6ac939add5550d179824936c83f320ff4", "committedDate": "2022-06-13 15:34:02 +0200", "message": "[hotfix][docs] Update memory unit Mb."}, {"oid": "0b60ee8e295baaade575d051e3fe9cc6a540cc5d", "committedDate": "2022-06-21 09:55:52 +0200", "message": "[FLINK-26762][network] Add the overdraft buffer in ResultPartition"}, {"oid": "c6b3a8aa25607fb62d51b92f11f72778e5d618b2", "committedDate": "2022-07-05 15:07:06 +0800", "message": "[FLINK-28240][network] Fix the bug that NetworkBufferPool#getRequestedSegmentsUsage may throw ArithmeticException."}, {"oid": "f80d7a4428e26b319172a56e02976bcbf5707a4f", "committedDate": "2023-05-06 10:40:23 +0800", "message": "[FLINK-31764][runtime] Introduce getNumberOfRequestedMemorySegments and rename the old one to a more appropriate name."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2MzQyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424163429", "body": "nit: import `NettyMessage.AddBacklog` because it occurs many times in this part.", "bodyText": "nit: import NettyMessage.AddBacklog because it occurs many times in this part.", "bodyHTML": "<p dir=\"auto\">nit: import <code>NettyMessage.AddBacklog</code> because it occurs many times in this part.</p>", "author": "zhijiangW", "createdAt": "2020-05-13T04:17:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -291,6 +290,11 @@ private void decodeMsg(Object msg) throws Throwable {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t} else if (msgClazz == NettyMessage.AddBacklog.class) {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex aa34a03e96b..6a41febf423 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n", "chunk": "@@ -290,8 +291,8 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t} else if (msgClazz == NettyMessage.AddBacklog.class) {\n-\t\t\tNettyMessage.AddBacklog addBacklog = (NettyMessage.AddBacklog) msg;\n+\t\t} else if (msgClazz == AddBacklog.class) {\n+\t\t\tAddBacklog addBacklog = (AddBacklog) msg;\n \n \t\t\tRemoteInputChannel inputChannel = inputChannels.get(addBacklog.receiverId);\n \t\t\tinputChannel.onSenderBacklog(addBacklog.backlog);\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex 6a41febf423..729def756d8 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n", "chunk": "@@ -47,352 +49,404 @@ import java.util.concurrent.atomic.AtomicReference;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n- * Channel handler to read the messages of buffer response or error response from the\n- * producer, to write and flush the unannounced credits for the producer.\n+ * Channel handler to read the messages of buffer response or error response from the producer, to\n+ * write and flush the unannounced credits for the producer.\n  *\n  * <p>It is used in the new network credit-based mode.\n  */\n-class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdapter implements NetworkClientHandler {\n-\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(CreditBasedPartitionRequestClientHandler.class);\n-\n-\t/** Channels, which already requested partitions from the producers. */\n-\tprivate final ConcurrentMap<InputChannelID, RemoteInputChannel> inputChannels = new ConcurrentHashMap<>();\n-\n-\t/** Messages to be sent to the producers (credit announcement or resume consumption request). */\n-\tprivate final ArrayDeque<ClientOutboundMessage> clientOutboundMessages = new ArrayDeque<>();\n-\n-\tprivate final AtomicReference<Throwable> channelError = new AtomicReference<>();\n-\n-\tprivate final ChannelFutureListener writeListener = new WriteAndFlushNextMessageIfPossibleListener();\n-\n-\t/**\n-\t * Set of cancelled partition requests. A request is cancelled iff an input channel is cleared\n-\t * while data is still coming in for this channel.\n-\t */\n-\tprivate final ConcurrentMap<InputChannelID, InputChannelID> cancelled = new ConcurrentHashMap<>();\n-\n-\t/**\n-\t * The channel handler context is initialized in channel active event by netty thread, the context may also\n-\t * be accessed by task thread or canceler thread to cancel partition request during releasing resources.\n-\t */\n-\tprivate volatile ChannelHandlerContext ctx;\n-\n-\t// ------------------------------------------------------------------------\n-\t// Input channel/receiver registration\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic void addInputChannel(RemoteInputChannel listener) throws IOException {\n-\t\tcheckError();\n-\n-\t\tinputChannels.putIfAbsent(listener.getInputChannelId(), listener);\n-\t}\n-\n-\t@Override\n-\tpublic void removeInputChannel(RemoteInputChannel listener) {\n-\t\tinputChannels.remove(listener.getInputChannelId());\n-\t}\n-\n-\t@Override\n-\tpublic RemoteInputChannel getInputChannel(InputChannelID inputChannelId) {\n-\t\treturn inputChannels.get(inputChannelId);\n-\t}\n-\n-\t@Override\n-\tpublic void cancelRequestFor(InputChannelID inputChannelId) {\n-\t\tif (inputChannelId == null || ctx == null) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (cancelled.putIfAbsent(inputChannelId, inputChannelId) == null) {\n-\t\t\tctx.writeAndFlush(new NettyMessage.CancelPartitionRequest(inputChannelId));\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void notifyCreditAvailable(final RemoteInputChannel inputChannel) {\n-\t\tctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(new AddCreditMessage(inputChannel)));\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption(RemoteInputChannel inputChannel) {\n-\t\tctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(new ResumeConsumptionMessage(inputChannel)));\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic void channelActive(final ChannelHandlerContext ctx) throws Exception {\n-\t\tif (this.ctx == null) {\n-\t\t\tthis.ctx = ctx;\n-\t\t}\n-\n-\t\tsuper.channelActive(ctx);\n-\t}\n-\n-\t@Override\n-\tpublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-\t\t// Unexpected close. In normal operation, the client closes the connection after all input\n-\t\t// channels have been removed. This indicates a problem with the remote task manager.\n-\t\tif (!inputChannels.isEmpty()) {\n-\t\t\tfinal SocketAddress remoteAddr = ctx.channel().remoteAddress();\n-\n-\t\t\tnotifyAllChannelsOfErrorAndClose(new RemoteTransportException(\n-\t\t\t\t\"Connection unexpectedly closed by remote task manager '\" + remoteAddr + \"'. \"\n-\t\t\t\t\t+ \"This might indicate that the remote task manager was lost.\", remoteAddr));\n-\t\t}\n-\n-\t\tsuper.channelInactive(ctx);\n-\t}\n-\n-\t/**\n-\t * Called on exceptions in the client handler pipeline.\n-\t *\n-\t * <p>Remote exceptions are received as regular payload.\n-\t */\n-\t@Override\n-\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-\t\tif (cause instanceof TransportException) {\n-\t\t\tnotifyAllChannelsOfErrorAndClose(cause);\n-\t\t} else {\n-\t\t\tfinal SocketAddress remoteAddr = ctx.channel().remoteAddress();\n-\n-\t\t\tfinal TransportException tex;\n-\n-\t\t\t// Improve on the connection reset by peer error message\n-\t\t\tif (cause instanceof IOException && cause.getMessage().equals(\"Connection reset by peer\")) {\n-\t\t\t\ttex = new RemoteTransportException(\"Lost connection to task manager '\" + remoteAddr + \"'. \" +\n-\t\t\t\t\t\"This indicates that the remote task manager was lost.\", remoteAddr, cause);\n-\t\t\t} else {\n-\t\t\t\tfinal SocketAddress localAddr = ctx.channel().localAddress();\n-\t\t\t\ttex = new LocalTransportException(\n-\t\t\t\t\tString.format(\"%s (connection to '%s')\", cause.getMessage(), remoteAddr), localAddr, cause);\n-\t\t\t}\n-\n-\t\t\tnotifyAllChannelsOfErrorAndClose(tex);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\ttry {\n-\t\t\tdecodeMsg(msg);\n-\t\t} catch (Throwable t) {\n-\t\t\tnotifyAllChannelsOfErrorAndClose(t);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Triggered by notifying credit available in the client handler pipeline.\n-\t *\n-\t * <p>Enqueues the input channel and will trigger write&flush unannounced credits\n-\t * for this input channel if it is the first one in the queue.\n-\t */\n-\t@Override\n-\tpublic void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\tif (msg instanceof ClientOutboundMessage) {\n-\t\t\tboolean triggerWrite = clientOutboundMessages.isEmpty();\n-\n-\t\t\tclientOutboundMessages.add((ClientOutboundMessage) msg);\n-\n-\t\t\tif (triggerWrite) {\n-\t\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t\t\t}\n-\t\t} else {\n-\t\t\tctx.fireUserEventTriggered(msg);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t}\n-\n-\tprivate void notifyAllChannelsOfErrorAndClose(Throwable cause) {\n-\t\tif (channelError.compareAndSet(null, cause)) {\n-\t\t\ttry {\n-\t\t\t\tfor (RemoteInputChannel inputChannel : inputChannels.values()) {\n-\t\t\t\t\tinputChannel.onError(cause);\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\t// We can only swallow the Exception at this point. :(\n-\t\t\t\tLOG.warn(\"An Exception was thrown during error notification of a remote input channel.\", t);\n-\t\t\t} finally {\n-\t\t\t\tinputChannels.clear();\n-\t\t\t\tclientOutboundMessages.clear();\n-\n-\t\t\t\tif (ctx != null) {\n-\t\t\t\t\tctx.close();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Checks for an error and rethrows it if one was reported.\n-\t */\n-\tprivate void checkError() throws IOException {\n-\t\tfinal Throwable t = channelError.get();\n-\n-\t\tif (t != null) {\n-\t\t\tif (t instanceof IOException) {\n-\t\t\t\tthrow (IOException) t;\n-\t\t\t} else {\n-\t\t\t\tthrow new IOException(\"There has been an error in the channel.\", t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void decodeMsg(Object msg) throws Throwable {\n-\t\tfinal Class<?> msgClazz = msg.getClass();\n-\n-\t\t// ---- Buffer --------------------------------------------------------\n-\t\tif (msgClazz == NettyMessage.BufferResponse.class) {\n-\t\t\tNettyMessage.BufferResponse bufferOrEvent = (NettyMessage.BufferResponse) msg;\n-\n-\t\t\tRemoteInputChannel inputChannel = inputChannels.get(bufferOrEvent.receiverId);\n-\t\t\tif (inputChannel == null || inputChannel.isReleased()) {\n-\t\t\t\tbufferOrEvent.releaseBuffer();\n-\n-\t\t\t\tcancelRequestFor(bufferOrEvent.receiverId);\n-\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tdecodeBufferOrEvent(inputChannel, bufferOrEvent);\n-\n-\t\t} else if (msgClazz == NettyMessage.ErrorResponse.class) {\n-\t\t\t// ---- Error ---------------------------------------------------------\n-\t\t\tNettyMessage.ErrorResponse error = (NettyMessage.ErrorResponse) msg;\n-\n-\t\t\tSocketAddress remoteAddr = ctx.channel().remoteAddress();\n-\n-\t\t\tif (error.isFatalError()) {\n-\t\t\t\tnotifyAllChannelsOfErrorAndClose(new RemoteTransportException(\n-\t\t\t\t\t\"Fatal error at remote task manager '\" + remoteAddr + \"'.\",\n-\t\t\t\t\tremoteAddr,\n-\t\t\t\t\terror.cause));\n-\t\t\t} else {\n-\t\t\t\tRemoteInputChannel inputChannel = inputChannels.get(error.receiverId);\n-\n-\t\t\t\tif (inputChannel != null) {\n-\t\t\t\t\tif (error.cause.getClass() == PartitionNotFoundException.class) {\n-\t\t\t\t\t\tinputChannel.onFailedPartitionRequest();\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tinputChannel.onError(new RemoteTransportException(\n-\t\t\t\t\t\t\t\"Error at remote task manager '\" + remoteAddr + \"'.\",\n-\t\t\t\t\t\t\tremoteAddr,\n-\t\t\t\t\t\t\terror.cause));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else if (msgClazz == AddBacklog.class) {\n-\t\t\tAddBacklog addBacklog = (AddBacklog) msg;\n-\n-\t\t\tRemoteInputChannel inputChannel = inputChannels.get(addBacklog.receiverId);\n-\t\t\tinputChannel.onSenderBacklog(addBacklog.backlog);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"Received unknown message from producer: \" + msg.getClass());\n-\t\t}\n-\t}\n-\n-\tprivate void decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent) throws Throwable {\n-\t\tif (bufferOrEvent.isBuffer() && bufferOrEvent.bufferSize == 0) {\n-\t\t\tinputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n-\t\t} else if (bufferOrEvent.getBuffer() != null) {\n-\t\t\tinputChannel.onBuffer(bufferOrEvent.getBuffer(), bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"The read buffer is null in credit-based input channel.\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Tries to write&flush unannounced credits for the next input channel in queue.\n-\t *\n-\t * <p>This method may be called by the first input channel enqueuing, or the complete\n-\t * future's callback in previous input channel, or the channel writability changed event.\n-\t */\n-\tprivate void writeAndFlushNextMessageIfPossible(Channel channel) throws IOException {\n-\t\tif (channelError.get() != null || !channel.isWritable()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\twhile (true) {\n-\t\t\tClientOutboundMessage outboundMessage = clientOutboundMessages.poll();\n-\n-\t\t\t// The input channel may be null because of the write callbacks\n-\t\t\t// that are executed after each write.\n-\t\t\tif (outboundMessage == null) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t//It is no need to notify credit or resume data consumption for the released channel.\n-\t\t\tif (!outboundMessage.inputChannel.isReleased()) {\n-\t\t\t\tObject msg = outboundMessage.buildMessage();\n-\n-\t\t\t\t// Write and flush and wait until this is done before\n-\t\t\t\t// trying to continue with the next input channel.\n-\t\t\t\tchannel.writeAndFlush(msg).addListener(writeListener);\n-\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n-\n-\t\t@Override\n-\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n-\t\t\ttry {\n-\t\t\t\tif (future.isSuccess()) {\n-\t\t\t\t\twriteAndFlushNextMessageIfPossible(future.channel());\n-\t\t\t\t} else if (future.cause() != null) {\n-\t\t\t\t\tnotifyAllChannelsOfErrorAndClose(future.cause());\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyAllChannelsOfErrorAndClose(new IllegalStateException(\"Sending cancelled by user.\"));\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tnotifyAllChannelsOfErrorAndClose(t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static abstract class ClientOutboundMessage {\n-\t\tprotected final RemoteInputChannel inputChannel;\n-\n-\t\tClientOutboundMessage(RemoteInputChannel inputChannel) {\n-\t\t\tthis.inputChannel = inputChannel;\n-\t\t}\n-\n-\t\tabstract Object buildMessage() throws IOException;\n-\t}\n-\n-\tprivate static class AddCreditMessage extends ClientOutboundMessage {\n-\n-\t\tAddCreditMessage(RemoteInputChannel inputChannel) {\n-\t\t\tsuper(checkNotNull(inputChannel));\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Object buildMessage() {\n-\t\t\treturn new AddCredit(inputChannel.getAndResetUnannouncedCredit(), inputChannel.getInputChannelId());\n-\t\t}\n-\t}\n-\n-\tprivate static class ResumeConsumptionMessage extends ClientOutboundMessage {\n-\n-\t\tResumeConsumptionMessage(RemoteInputChannel inputChannel) {\n-\t\t\tsuper(checkNotNull(inputChannel));\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject buildMessage() throws IOException {\n-\t\t\treturn inputChannel.getResumeConsumptionMessage();\n-\t\t}\n-\t}\n+class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdapter\n+        implements NetworkClientHandler {\n+\n+    private static final Logger LOG =\n+            LoggerFactory.getLogger(CreditBasedPartitionRequestClientHandler.class);\n+\n+    /** Channels, which already requested partitions from the producers. */\n+    private final ConcurrentMap<InputChannelID, RemoteInputChannel> inputChannels =\n+            new ConcurrentHashMap<>();\n+\n+    /** Messages to be sent to the producers (credit announcement or resume consumption request). */\n+    private final ArrayDeque<ClientOutboundMessage> clientOutboundMessages = new ArrayDeque<>();\n+\n+    private final AtomicReference<Throwable> channelError = new AtomicReference<>();\n+\n+    private final ChannelFutureListener writeListener =\n+            new WriteAndFlushNextMessageIfPossibleListener();\n+\n+    /**\n+     * Set of cancelled partition requests. A request is cancelled iff an input channel is cleared\n+     * while data is still coming in for this channel.\n+     */\n+    private final ConcurrentMap<InputChannelID, InputChannelID> cancelled =\n+            new ConcurrentHashMap<>();\n+\n+    /**\n+     * The channel handler context is initialized in channel active event by netty thread, the\n+     * context may also be accessed by task thread or canceler thread to cancel partition request\n+     * during releasing resources.\n+     */\n+    private volatile ChannelHandlerContext ctx;\n+\n+    // ------------------------------------------------------------------------\n+    // Input channel/receiver registration\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public void addInputChannel(RemoteInputChannel listener) throws IOException {\n+        checkError();\n+\n+        inputChannels.putIfAbsent(listener.getInputChannelId(), listener);\n+    }\n+\n+    @Override\n+    public void removeInputChannel(RemoteInputChannel listener) {\n+        inputChannels.remove(listener.getInputChannelId());\n+    }\n+\n+    @Override\n+    public RemoteInputChannel getInputChannel(InputChannelID inputChannelId) {\n+        return inputChannels.get(inputChannelId);\n+    }\n+\n+    @Override\n+    public void cancelRequestFor(InputChannelID inputChannelId) {\n+        if (inputChannelId == null || ctx == null) {\n+            return;\n+        }\n+\n+        if (cancelled.putIfAbsent(inputChannelId, inputChannelId) == null) {\n+            ctx.writeAndFlush(new NettyMessage.CancelPartitionRequest(inputChannelId));\n+        }\n+    }\n+\n+    @Override\n+    public void notifyCreditAvailable(final RemoteInputChannel inputChannel) {\n+        ctx.executor()\n+                .execute(\n+                        () ->\n+                                ctx.pipeline()\n+                                        .fireUserEventTriggered(\n+                                                new AddCreditMessage(inputChannel)));\n+    }\n+\n+    @Override\n+    public void resumeConsumption(RemoteInputChannel inputChannel) {\n+        ctx.executor()\n+                .execute(\n+                        () ->\n+                                ctx.pipeline()\n+                                        .fireUserEventTriggered(\n+                                                new ResumeConsumptionMessage(inputChannel)));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public void channelActive(final ChannelHandlerContext ctx) throws Exception {\n+        if (this.ctx == null) {\n+            this.ctx = ctx;\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        // Unexpected close. In normal operation, the client closes the connection after all input\n+        // channels have been removed. This indicates a problem with the remote task manager.\n+        if (!inputChannels.isEmpty()) {\n+            final SocketAddress remoteAddr = ctx.channel().remoteAddress();\n+\n+            notifyAllChannelsOfErrorAndClose(\n+                    new RemoteTransportException(\n+                            \"Connection unexpectedly closed by remote task manager '\"\n+                                    + remoteAddr\n+                                    + \"'. \"\n+                                    + \"This might indicate that the remote task manager was lost.\",\n+                            remoteAddr));\n+        }\n+\n+        super.channelInactive(ctx);\n+    }\n+\n+    /**\n+     * Called on exceptions in the client handler pipeline.\n+     *\n+     * <p>Remote exceptions are received as regular payload.\n+     */\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        if (cause instanceof TransportException) {\n+            notifyAllChannelsOfErrorAndClose(cause);\n+        } else {\n+            final SocketAddress remoteAddr = ctx.channel().remoteAddress();\n+\n+            final TransportException tex;\n+\n+            // Improve on the connection reset by peer error message\n+            if (cause instanceof IOException\n+                    && cause.getMessage().equals(\"Connection reset by peer\")) {\n+                tex =\n+                        new RemoteTransportException(\n+                                \"Lost connection to task manager '\"\n+                                        + remoteAddr\n+                                        + \"'. \"\n+                                        + \"This indicates that the remote task manager was lost.\",\n+                                remoteAddr,\n+                                cause);\n+            } else {\n+                final SocketAddress localAddr = ctx.channel().localAddress();\n+                tex =\n+                        new LocalTransportException(\n+                                String.format(\n+                                        \"%s (connection to '%s')\", cause.getMessage(), remoteAddr),\n+                                localAddr,\n+                                cause);\n+            }\n+\n+            notifyAllChannelsOfErrorAndClose(tex);\n+        }\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        try {\n+            decodeMsg(msg);\n+        } catch (Throwable t) {\n+            notifyAllChannelsOfErrorAndClose(t);\n+        }\n+    }\n+\n+    /**\n+     * Triggered by notifying credit available in the client handler pipeline.\n+     *\n+     * <p>Enqueues the input channel and will trigger write&flush unannounced credits for this input\n+     * channel if it is the first one in the queue.\n+     */\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        if (msg instanceof ClientOutboundMessage) {\n+            boolean triggerWrite = clientOutboundMessages.isEmpty();\n+\n+            clientOutboundMessages.add((ClientOutboundMessage) msg);\n+\n+            if (triggerWrite) {\n+                writeAndFlushNextMessageIfPossible(ctx.channel());\n+            }\n+        } else {\n+            ctx.fireUserEventTriggered(msg);\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        writeAndFlushNextMessageIfPossible(ctx.channel());\n+    }\n+\n+    private void notifyAllChannelsOfErrorAndClose(Throwable cause) {\n+        if (channelError.compareAndSet(null, cause)) {\n+            try {\n+                for (RemoteInputChannel inputChannel : inputChannels.values()) {\n+                    inputChannel.onError(cause);\n+                }\n+            } catch (Throwable t) {\n+                // We can only swallow the Exception at this point. :(\n+                LOG.warn(\n+                        \"An Exception was thrown during error notification of a remote input channel.\",\n+                        t);\n+            } finally {\n+                inputChannels.clear();\n+                clientOutboundMessages.clear();\n+\n+                if (ctx != null) {\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+\n+    /** Checks for an error and rethrows it if one was reported. */\n+    @VisibleForTesting\n+    void checkError() throws IOException {\n+        final Throwable t = channelError.get();\n+\n+        if (t != null) {\n+            if (t instanceof IOException) {\n+                throw (IOException) t;\n+            } else {\n+                throw new IOException(\"There has been an error in the channel.\", t);\n+            }\n+        }\n+    }\n+\n+    private void decodeMsg(Object msg) throws Throwable {\n+        final Class<?> msgClazz = msg.getClass();\n+\n+        // ---- Buffer --------------------------------------------------------\n+        if (msgClazz == NettyMessage.BufferResponse.class) {\n+            NettyMessage.BufferResponse bufferOrEvent = (NettyMessage.BufferResponse) msg;\n+\n+            RemoteInputChannel inputChannel = inputChannels.get(bufferOrEvent.receiverId);\n+            if (inputChannel == null || inputChannel.isReleased()) {\n+                bufferOrEvent.releaseBuffer();\n+\n+                cancelRequestFor(bufferOrEvent.receiverId);\n+\n+                return;\n+            }\n+\n+            try {\n+                decodeBufferOrEvent(inputChannel, bufferOrEvent);\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+                inputChannel.onError(t);\n+            }\n+\n+        } else if (msgClazz == NettyMessage.ErrorResponse.class) {\n+            // ---- Error ---------------------------------------------------------\n+            NettyMessage.ErrorResponse error = (NettyMessage.ErrorResponse) msg;\n+\n+            SocketAddress remoteAddr = ctx.channel().remoteAddress();\n+\n+            if (error.isFatalError()) {\n+                notifyAllChannelsOfErrorAndClose(\n+                        new RemoteTransportException(\n+                                \"Fatal error at remote task manager '\" + remoteAddr + \"'.\",\n+                                remoteAddr,\n+                                error.cause));\n+            } else {\n+                RemoteInputChannel inputChannel = inputChannels.get(error.receiverId);\n+\n+                if (inputChannel != null) {\n+                    if (error.cause.getClass() == PartitionNotFoundException.class) {\n+                        inputChannel.onFailedPartitionRequest();\n+                    } else {\n+                        inputChannel.onError(\n+                                new RemoteTransportException(\n+                                        \"Error at remote task manager '\" + remoteAddr + \"'.\",\n+                                        remoteAddr,\n+                                        error.cause));\n+                    }\n+                }\n+            }\n+        } else if (msgClazz == NettyMessage.BacklogAnnouncement.class) {\n+            NettyMessage.BacklogAnnouncement announcement = (NettyMessage.BacklogAnnouncement) msg;\n+\n+            RemoteInputChannel inputChannel = inputChannels.get(announcement.receiverId);\n+            inputChannel.onSenderBacklog(announcement.backlog);\n+        } else {\n+            throw new IllegalStateException(\n+                    \"Received unknown message from producer: \" + msg.getClass());\n+        }\n+    }\n+\n+    private void decodeBufferOrEvent(\n+            RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent)\n+            throws Throwable {\n+        if (bufferOrEvent.isBuffer() && bufferOrEvent.bufferSize == 0) {\n+            inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n+            // recycle the empty buffer directly\n+            Buffer buffer = bufferOrEvent.getBuffer();\n+            if (buffer != null) {\n+                buffer.recycleBuffer();\n+            }\n+        } else if (bufferOrEvent.getBuffer() != null) {\n+            inputChannel.onBuffer(\n+                    bufferOrEvent.getBuffer(), bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n+        } else {\n+            throw new IllegalStateException(\n+                    \"The read buffer is null in credit-based input channel.\");\n+        }\n+    }\n+\n+    /**\n+     * Tries to write&flush unannounced credits for the next input channel in queue.\n+     *\n+     * <p>This method may be called by the first input channel enqueuing, or the complete future's\n+     * callback in previous input channel, or the channel writability changed event.\n+     */\n+    private void writeAndFlushNextMessageIfPossible(Channel channel) {\n+        if (channelError.get() != null || !channel.isWritable()) {\n+            return;\n+        }\n+\n+        while (true) {\n+            ClientOutboundMessage outboundMessage = clientOutboundMessages.poll();\n+\n+            // The input channel may be null because of the write callbacks\n+            // that are executed after each write.\n+            if (outboundMessage == null) {\n+                return;\n+            }\n+\n+            // It is no need to notify credit or resume data consumption for the released channel.\n+            if (!outboundMessage.inputChannel.isReleased()) {\n+                Object msg = outboundMessage.buildMessage();\n+\n+                // Write and flush and wait until this is done before\n+                // trying to continue with the next input channel.\n+                channel.writeAndFlush(msg).addListener(writeListener);\n+\n+                return;\n+            }\n+        }\n+    }\n+\n+    private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            try {\n+                if (future.isSuccess()) {\n+                    writeAndFlushNextMessageIfPossible(future.channel());\n+                } else if (future.cause() != null) {\n+                    notifyAllChannelsOfErrorAndClose(future.cause());\n+                } else {\n+                    notifyAllChannelsOfErrorAndClose(\n+                            new IllegalStateException(\"Sending cancelled by user.\"));\n+                }\n+            } catch (Throwable t) {\n+                notifyAllChannelsOfErrorAndClose(t);\n+            }\n+        }\n+    }\n+\n+    private abstract static class ClientOutboundMessage {\n+        protected final RemoteInputChannel inputChannel;\n+\n+        ClientOutboundMessage(RemoteInputChannel inputChannel) {\n+            this.inputChannel = inputChannel;\n+        }\n+\n+        abstract Object buildMessage();\n+    }\n+\n+    private static class AddCreditMessage extends ClientOutboundMessage {\n+\n+        AddCreditMessage(RemoteInputChannel inputChannel) {\n+            super(checkNotNull(inputChannel));\n+        }\n+\n+        @Override\n+        public Object buildMessage() {\n+            return new AddCredit(\n+                    inputChannel.getAndResetUnannouncedCredit(), inputChannel.getInputChannelId());\n+        }\n+    }\n+\n+    private static class ResumeConsumptionMessage extends ClientOutboundMessage {\n+\n+        ResumeConsumptionMessage(RemoteInputChannel inputChannel) {\n+            super(checkNotNull(inputChannel));\n+        }\n+\n+        @Override\n+        Object buildMessage() {\n+            inputChannel.onConsumptionResumed();\n+            return new ResumeConsumption(inputChannel.getInputChannelId());\n+        }\n+    }\n }\n", "next_change": {"commit": "8550965d808fe7b4d6ff2d48034612878937a579", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex 729def756d8..92425db4f8e 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n", "chunk": "@@ -445,7 +459,6 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n \n         @Override\n         Object buildMessage() {\n-            inputChannel.onConsumptionResumed();\n             return new ResumeConsumption(inputChannel.getInputChannelId());\n         }\n     }\n", "next_change": {"commit": "1814aee57851711782cc2d922c4ef8f118a74c13", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex 92425db4f8e..bb83e4aa2ec 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n", "chunk": "@@ -462,4 +475,16 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n             return new ResumeConsumption(inputChannel.getInputChannelId());\n         }\n     }\n+\n+    private static class AcknowledgeAllRecordsProcessedMessage extends ClientOutboundMessage {\n+\n+        AcknowledgeAllRecordsProcessedMessage(RemoteInputChannel inputChannel) {\n+            super(checkNotNull(inputChannel));\n+        }\n+\n+        @Override\n+        Object buildMessage() {\n+            return new AckAllUserRecordsProcessed(inputChannel.getInputChannelId());\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex aa34a03e96b..41d91430e70 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n", "chunk": "@@ -46,352 +51,434 @@ import java.util.concurrent.atomic.AtomicReference;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n- * Channel handler to read the messages of buffer response or error response from the\n- * producer, to write and flush the unannounced credits for the producer.\n+ * Channel handler to read the messages of buffer response or error response from the producer, to\n+ * write and flush the unannounced credits for the producer.\n  *\n  * <p>It is used in the new network credit-based mode.\n  */\n-class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdapter implements NetworkClientHandler {\n-\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(CreditBasedPartitionRequestClientHandler.class);\n-\n-\t/** Channels, which already requested partitions from the producers. */\n-\tprivate final ConcurrentMap<InputChannelID, RemoteInputChannel> inputChannels = new ConcurrentHashMap<>();\n-\n-\t/** Messages to be sent to the producers (credit announcement or resume consumption request). */\n-\tprivate final ArrayDeque<ClientOutboundMessage> clientOutboundMessages = new ArrayDeque<>();\n-\n-\tprivate final AtomicReference<Throwable> channelError = new AtomicReference<>();\n-\n-\tprivate final ChannelFutureListener writeListener = new WriteAndFlushNextMessageIfPossibleListener();\n-\n-\t/**\n-\t * Set of cancelled partition requests. A request is cancelled iff an input channel is cleared\n-\t * while data is still coming in for this channel.\n-\t */\n-\tprivate final ConcurrentMap<InputChannelID, InputChannelID> cancelled = new ConcurrentHashMap<>();\n-\n-\t/**\n-\t * The channel handler context is initialized in channel active event by netty thread, the context may also\n-\t * be accessed by task thread or canceler thread to cancel partition request during releasing resources.\n-\t */\n-\tprivate volatile ChannelHandlerContext ctx;\n-\n-\t// ------------------------------------------------------------------------\n-\t// Input channel/receiver registration\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic void addInputChannel(RemoteInputChannel listener) throws IOException {\n-\t\tcheckError();\n-\n-\t\tinputChannels.putIfAbsent(listener.getInputChannelId(), listener);\n-\t}\n-\n-\t@Override\n-\tpublic void removeInputChannel(RemoteInputChannel listener) {\n-\t\tinputChannels.remove(listener.getInputChannelId());\n-\t}\n-\n-\t@Override\n-\tpublic RemoteInputChannel getInputChannel(InputChannelID inputChannelId) {\n-\t\treturn inputChannels.get(inputChannelId);\n-\t}\n-\n-\t@Override\n-\tpublic void cancelRequestFor(InputChannelID inputChannelId) {\n-\t\tif (inputChannelId == null || ctx == null) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (cancelled.putIfAbsent(inputChannelId, inputChannelId) == null) {\n-\t\t\tctx.writeAndFlush(new NettyMessage.CancelPartitionRequest(inputChannelId));\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void notifyCreditAvailable(final RemoteInputChannel inputChannel) {\n-\t\tctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(new AddCreditMessage(inputChannel)));\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption(RemoteInputChannel inputChannel) {\n-\t\tctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(new ResumeConsumptionMessage(inputChannel)));\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic void channelActive(final ChannelHandlerContext ctx) throws Exception {\n-\t\tif (this.ctx == null) {\n-\t\t\tthis.ctx = ctx;\n-\t\t}\n-\n-\t\tsuper.channelActive(ctx);\n-\t}\n-\n-\t@Override\n-\tpublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-\t\t// Unexpected close. In normal operation, the client closes the connection after all input\n-\t\t// channels have been removed. This indicates a problem with the remote task manager.\n-\t\tif (!inputChannels.isEmpty()) {\n-\t\t\tfinal SocketAddress remoteAddr = ctx.channel().remoteAddress();\n-\n-\t\t\tnotifyAllChannelsOfErrorAndClose(new RemoteTransportException(\n-\t\t\t\t\"Connection unexpectedly closed by remote task manager '\" + remoteAddr + \"'. \"\n-\t\t\t\t\t+ \"This might indicate that the remote task manager was lost.\", remoteAddr));\n-\t\t}\n-\n-\t\tsuper.channelInactive(ctx);\n-\t}\n-\n-\t/**\n-\t * Called on exceptions in the client handler pipeline.\n-\t *\n-\t * <p>Remote exceptions are received as regular payload.\n-\t */\n-\t@Override\n-\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-\t\tif (cause instanceof TransportException) {\n-\t\t\tnotifyAllChannelsOfErrorAndClose(cause);\n-\t\t} else {\n-\t\t\tfinal SocketAddress remoteAddr = ctx.channel().remoteAddress();\n-\n-\t\t\tfinal TransportException tex;\n-\n-\t\t\t// Improve on the connection reset by peer error message\n-\t\t\tif (cause instanceof IOException && cause.getMessage().equals(\"Connection reset by peer\")) {\n-\t\t\t\ttex = new RemoteTransportException(\"Lost connection to task manager '\" + remoteAddr + \"'. \" +\n-\t\t\t\t\t\"This indicates that the remote task manager was lost.\", remoteAddr, cause);\n-\t\t\t} else {\n-\t\t\t\tfinal SocketAddress localAddr = ctx.channel().localAddress();\n-\t\t\t\ttex = new LocalTransportException(\n-\t\t\t\t\tString.format(\"%s (connection to '%s')\", cause.getMessage(), remoteAddr), localAddr, cause);\n-\t\t\t}\n-\n-\t\t\tnotifyAllChannelsOfErrorAndClose(tex);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\ttry {\n-\t\t\tdecodeMsg(msg);\n-\t\t} catch (Throwable t) {\n-\t\t\tnotifyAllChannelsOfErrorAndClose(t);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Triggered by notifying credit available in the client handler pipeline.\n-\t *\n-\t * <p>Enqueues the input channel and will trigger write&flush unannounced credits\n-\t * for this input channel if it is the first one in the queue.\n-\t */\n-\t@Override\n-\tpublic void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\tif (msg instanceof ClientOutboundMessage) {\n-\t\t\tboolean triggerWrite = clientOutboundMessages.isEmpty();\n-\n-\t\t\tclientOutboundMessages.add((ClientOutboundMessage) msg);\n-\n-\t\t\tif (triggerWrite) {\n-\t\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t\t\t}\n-\t\t} else {\n-\t\t\tctx.fireUserEventTriggered(msg);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t}\n-\n-\tprivate void notifyAllChannelsOfErrorAndClose(Throwable cause) {\n-\t\tif (channelError.compareAndSet(null, cause)) {\n-\t\t\ttry {\n-\t\t\t\tfor (RemoteInputChannel inputChannel : inputChannels.values()) {\n-\t\t\t\t\tinputChannel.onError(cause);\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\t// We can only swallow the Exception at this point. :(\n-\t\t\t\tLOG.warn(\"An Exception was thrown during error notification of a remote input channel.\", t);\n-\t\t\t} finally {\n-\t\t\t\tinputChannels.clear();\n-\t\t\t\tclientOutboundMessages.clear();\n-\n-\t\t\t\tif (ctx != null) {\n-\t\t\t\t\tctx.close();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Checks for an error and rethrows it if one was reported.\n-\t */\n-\tprivate void checkError() throws IOException {\n-\t\tfinal Throwable t = channelError.get();\n-\n-\t\tif (t != null) {\n-\t\t\tif (t instanceof IOException) {\n-\t\t\t\tthrow (IOException) t;\n-\t\t\t} else {\n-\t\t\t\tthrow new IOException(\"There has been an error in the channel.\", t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void decodeMsg(Object msg) throws Throwable {\n-\t\tfinal Class<?> msgClazz = msg.getClass();\n-\n-\t\t// ---- Buffer --------------------------------------------------------\n-\t\tif (msgClazz == NettyMessage.BufferResponse.class) {\n-\t\t\tNettyMessage.BufferResponse bufferOrEvent = (NettyMessage.BufferResponse) msg;\n-\n-\t\t\tRemoteInputChannel inputChannel = inputChannels.get(bufferOrEvent.receiverId);\n-\t\t\tif (inputChannel == null || inputChannel.isReleased()) {\n-\t\t\t\tbufferOrEvent.releaseBuffer();\n-\n-\t\t\t\tcancelRequestFor(bufferOrEvent.receiverId);\n-\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tdecodeBufferOrEvent(inputChannel, bufferOrEvent);\n-\n-\t\t} else if (msgClazz == NettyMessage.ErrorResponse.class) {\n-\t\t\t// ---- Error ---------------------------------------------------------\n-\t\t\tNettyMessage.ErrorResponse error = (NettyMessage.ErrorResponse) msg;\n-\n-\t\t\tSocketAddress remoteAddr = ctx.channel().remoteAddress();\n-\n-\t\t\tif (error.isFatalError()) {\n-\t\t\t\tnotifyAllChannelsOfErrorAndClose(new RemoteTransportException(\n-\t\t\t\t\t\"Fatal error at remote task manager '\" + remoteAddr + \"'.\",\n-\t\t\t\t\tremoteAddr,\n-\t\t\t\t\terror.cause));\n-\t\t\t} else {\n-\t\t\t\tRemoteInputChannel inputChannel = inputChannels.get(error.receiverId);\n-\n-\t\t\t\tif (inputChannel != null) {\n-\t\t\t\t\tif (error.cause.getClass() == PartitionNotFoundException.class) {\n-\t\t\t\t\t\tinputChannel.onFailedPartitionRequest();\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tinputChannel.onError(new RemoteTransportException(\n-\t\t\t\t\t\t\t\"Error at remote task manager '\" + remoteAddr + \"'.\",\n-\t\t\t\t\t\t\tremoteAddr,\n-\t\t\t\t\t\t\terror.cause));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else if (msgClazz == NettyMessage.AddBacklog.class) {\n-\t\t\tNettyMessage.AddBacklog addBacklog = (NettyMessage.AddBacklog) msg;\n-\n-\t\t\tRemoteInputChannel inputChannel = inputChannels.get(addBacklog.receiverId);\n-\t\t\tinputChannel.onSenderBacklog(addBacklog.backlog);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"Received unknown message from producer: \" + msg.getClass());\n-\t\t}\n-\t}\n-\n-\tprivate void decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent) throws Throwable {\n-\t\tif (bufferOrEvent.isBuffer() && bufferOrEvent.bufferSize == 0) {\n-\t\t\tinputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n-\t\t} else if (bufferOrEvent.getBuffer() != null) {\n-\t\t\tinputChannel.onBuffer(bufferOrEvent.getBuffer(), bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"The read buffer is null in credit-based input channel.\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Tries to write&flush unannounced credits for the next input channel in queue.\n-\t *\n-\t * <p>This method may be called by the first input channel enqueuing, or the complete\n-\t * future's callback in previous input channel, or the channel writability changed event.\n-\t */\n-\tprivate void writeAndFlushNextMessageIfPossible(Channel channel) throws IOException {\n-\t\tif (channelError.get() != null || !channel.isWritable()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\twhile (true) {\n-\t\t\tClientOutboundMessage outboundMessage = clientOutboundMessages.poll();\n-\n-\t\t\t// The input channel may be null because of the write callbacks\n-\t\t\t// that are executed after each write.\n-\t\t\tif (outboundMessage == null) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t//It is no need to notify credit or resume data consumption for the released channel.\n-\t\t\tif (!outboundMessage.inputChannel.isReleased()) {\n-\t\t\t\tObject msg = outboundMessage.buildMessage();\n-\n-\t\t\t\t// Write and flush and wait until this is done before\n-\t\t\t\t// trying to continue with the next input channel.\n-\t\t\t\tchannel.writeAndFlush(msg).addListener(writeListener);\n-\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n-\n-\t\t@Override\n-\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n-\t\t\ttry {\n-\t\t\t\tif (future.isSuccess()) {\n-\t\t\t\t\twriteAndFlushNextMessageIfPossible(future.channel());\n-\t\t\t\t} else if (future.cause() != null) {\n-\t\t\t\t\tnotifyAllChannelsOfErrorAndClose(future.cause());\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyAllChannelsOfErrorAndClose(new IllegalStateException(\"Sending cancelled by user.\"));\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tnotifyAllChannelsOfErrorAndClose(t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static abstract class ClientOutboundMessage {\n-\t\tprotected final RemoteInputChannel inputChannel;\n-\n-\t\tClientOutboundMessage(RemoteInputChannel inputChannel) {\n-\t\t\tthis.inputChannel = inputChannel;\n-\t\t}\n-\n-\t\tabstract Object buildMessage() throws IOException;\n-\t}\n-\n-\tprivate static class AddCreditMessage extends ClientOutboundMessage {\n-\n-\t\tAddCreditMessage(RemoteInputChannel inputChannel) {\n-\t\t\tsuper(checkNotNull(inputChannel));\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Object buildMessage() {\n-\t\t\treturn new AddCredit(inputChannel.getAndResetUnannouncedCredit(), inputChannel.getInputChannelId());\n-\t\t}\n-\t}\n-\n-\tprivate static class ResumeConsumptionMessage extends ClientOutboundMessage {\n-\n-\t\tResumeConsumptionMessage(RemoteInputChannel inputChannel) {\n-\t\t\tsuper(checkNotNull(inputChannel));\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject buildMessage() throws IOException {\n-\t\t\treturn inputChannel.resumeAndGetResumptionMessage();\n-\t\t}\n-\t}\n+class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdapter\n+        implements NetworkClientHandler {\n+\n+    private static final Logger LOG =\n+            LoggerFactory.getLogger(CreditBasedPartitionRequestClientHandler.class);\n+\n+    /** Channels, which already requested partitions from the producers. */\n+    private final ConcurrentMap<InputChannelID, RemoteInputChannel> inputChannels =\n+            new ConcurrentHashMap<>();\n+\n+    /** Messages to be sent to the producers (credit announcement or resume consumption request). */\n+    private final ArrayDeque<ClientOutboundMessage> clientOutboundMessages = new ArrayDeque<>();\n+\n+    private final AtomicReference<Throwable> channelError = new AtomicReference<>();\n+\n+    private final ChannelFutureListener writeListener =\n+            new WriteAndFlushNextMessageIfPossibleListener();\n+\n+    /**\n+     * Set of cancelled partition requests. A request is cancelled iff an input channel is cleared\n+     * while data is still coming in for this channel.\n+     */\n+    private final ConcurrentMap<InputChannelID, InputChannelID> cancelled =\n+            new ConcurrentHashMap<>();\n+\n+    /**\n+     * The channel handler context is initialized in channel active event by netty thread, the\n+     * context may also be accessed by task thread or canceler thread to cancel partition request\n+     * during releasing resources.\n+     */\n+    private volatile ChannelHandlerContext ctx;\n+\n+    // ------------------------------------------------------------------------\n+    // Input channel/receiver registration\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public void addInputChannel(RemoteInputChannel listener) throws IOException {\n+        checkError();\n+\n+        inputChannels.putIfAbsent(listener.getInputChannelId(), listener);\n+    }\n+\n+    @Override\n+    public void removeInputChannel(RemoteInputChannel listener) {\n+        inputChannels.remove(listener.getInputChannelId());\n+    }\n+\n+    @Override\n+    public RemoteInputChannel getInputChannel(InputChannelID inputChannelId) {\n+        return inputChannels.get(inputChannelId);\n+    }\n+\n+    @Override\n+    public void cancelRequestFor(InputChannelID inputChannelId) {\n+        if (inputChannelId == null || ctx == null) {\n+            return;\n+        }\n+\n+        if (cancelled.putIfAbsent(inputChannelId, inputChannelId) == null) {\n+            ctx.writeAndFlush(new NettyMessage.CancelPartitionRequest(inputChannelId));\n+        }\n+    }\n+\n+    @Override\n+    public void notifyCreditAvailable(final RemoteInputChannel inputChannel) {\n+        ctx.executor()\n+                .execute(\n+                        () ->\n+                                ctx.pipeline()\n+                                        .fireUserEventTriggered(\n+                                                new AddCreditMessage(inputChannel)));\n+    }\n+\n+    @Override\n+    public void resumeConsumption(RemoteInputChannel inputChannel) {\n+        ctx.executor()\n+                .execute(\n+                        () ->\n+                                ctx.pipeline()\n+                                        .fireUserEventTriggered(\n+                                                new ResumeConsumptionMessage(inputChannel)));\n+    }\n+\n+    @Override\n+    public void acknowledgeAllRecordsProcessed(RemoteInputChannel inputChannel) {\n+        ctx.executor()\n+                .execute(\n+                        () -> {\n+                            ctx.pipeline()\n+                                    .fireUserEventTriggered(\n+                                            new AcknowledgeAllRecordsProcessedMessage(\n+                                                    inputChannel));\n+                        });\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public void channelActive(final ChannelHandlerContext ctx) throws Exception {\n+        if (this.ctx == null) {\n+            this.ctx = ctx;\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        // Unexpected close. In normal operation, the client closes the connection after all input\n+        // channels have been removed. This indicates a problem with the remote task manager.\n+        if (!inputChannels.isEmpty()) {\n+            final SocketAddress remoteAddr = ctx.channel().remoteAddress();\n+\n+            notifyAllChannelsOfErrorAndClose(\n+                    new RemoteTransportException(\n+                            \"Connection unexpectedly closed by remote task manager '\"\n+                                    + remoteAddr\n+                                    + \"'. \"\n+                                    + \"This might indicate that the remote task manager was lost.\",\n+                            remoteAddr));\n+        }\n+\n+        super.channelInactive(ctx);\n+    }\n+\n+    /**\n+     * Called on exceptions in the client handler pipeline.\n+     *\n+     * <p>Remote exceptions are received as regular payload.\n+     */\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        if (cause instanceof TransportException) {\n+            notifyAllChannelsOfErrorAndClose(cause);\n+        } else {\n+            final SocketAddress remoteAddr = ctx.channel().remoteAddress();\n+\n+            final TransportException tex;\n+\n+            // Improve on the connection reset by peer error message\n+            if (cause.getMessage() != null\n+                    && cause.getMessage().contains(\"Connection reset by peer\")) {\n+                tex =\n+                        new RemoteTransportException(\n+                                \"Lost connection to task manager '\"\n+                                        + remoteAddr\n+                                        + \"'. \"\n+                                        + \"This indicates that the remote task manager was lost.\",\n+                                remoteAddr,\n+                                cause);\n+            } else {\n+                final SocketAddress localAddr = ctx.channel().localAddress();\n+                tex =\n+                        new LocalTransportException(\n+                                String.format(\n+                                        \"%s (connection to '%s')\", cause.getMessage(), remoteAddr),\n+                                localAddr,\n+                                cause);\n+            }\n+\n+            notifyAllChannelsOfErrorAndClose(tex);\n+        }\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        try {\n+            decodeMsg(msg);\n+        } catch (Throwable t) {\n+            notifyAllChannelsOfErrorAndClose(t);\n+        }\n+    }\n+\n+    /**\n+     * Triggered by notifying credit available in the client handler pipeline.\n+     *\n+     * <p>Enqueues the input channel and will trigger write&flush unannounced credits for this input\n+     * channel if it is the first one in the queue.\n+     */\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        if (msg instanceof ClientOutboundMessage) {\n+            boolean triggerWrite = clientOutboundMessages.isEmpty();\n+\n+            clientOutboundMessages.add((ClientOutboundMessage) msg);\n+\n+            if (triggerWrite) {\n+                writeAndFlushNextMessageIfPossible(ctx.channel());\n+            }\n+        } else {\n+            ctx.fireUserEventTriggered(msg);\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        writeAndFlushNextMessageIfPossible(ctx.channel());\n+    }\n+\n+    private void notifyAllChannelsOfErrorAndClose(Throwable cause) {\n+        if (channelError.compareAndSet(null, cause)) {\n+            try {\n+                for (RemoteInputChannel inputChannel : inputChannels.values()) {\n+                    inputChannel.onError(cause);\n+                }\n+            } catch (Throwable t) {\n+                // We can only swallow the Exception at this point. :(\n+                LOG.warn(\n+                        \"An Exception was thrown during error notification of a remote input channel.\",\n+                        t);\n+            } finally {\n+                inputChannels.clear();\n+                clientOutboundMessages.clear();\n+\n+                if (ctx != null) {\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+\n+    /** Checks for an error and rethrows it if one was reported. */\n+    @VisibleForTesting\n+    void checkError() throws IOException {\n+        final Throwable t = channelError.get();\n+\n+        if (t != null) {\n+            if (t instanceof IOException) {\n+                throw (IOException) t;\n+            } else {\n+                throw new IOException(\"There has been an error in the channel.\", t);\n+            }\n+        }\n+    }\n+\n+    private void decodeMsg(Object msg) throws Throwable {\n+        final Class<?> msgClazz = msg.getClass();\n+\n+        // ---- Buffer --------------------------------------------------------\n+        if (msgClazz == NettyMessage.BufferResponse.class) {\n+            NettyMessage.BufferResponse bufferOrEvent = (NettyMessage.BufferResponse) msg;\n+\n+            RemoteInputChannel inputChannel = inputChannels.get(bufferOrEvent.receiverId);\n+            if (inputChannel == null || inputChannel.isReleased()) {\n+                bufferOrEvent.releaseBuffer();\n+\n+                cancelRequestFor(bufferOrEvent.receiverId);\n+\n+                return;\n+            }\n+\n+            try {\n+                decodeBufferOrEvent(inputChannel, bufferOrEvent);\n+            } catch (Throwable t) {\n+                inputChannel.onError(t);\n+            }\n+\n+        } else if (msgClazz == NettyMessage.ErrorResponse.class) {\n+            // ---- Error ---------------------------------------------------------\n+            NettyMessage.ErrorResponse error = (NettyMessage.ErrorResponse) msg;\n+\n+            SocketAddress remoteAddr = ctx.channel().remoteAddress();\n+\n+            if (error.isFatalError()) {\n+                notifyAllChannelsOfErrorAndClose(\n+                        new RemoteTransportException(\n+                                \"Fatal error at remote task manager '\" + remoteAddr + \"'.\",\n+                                remoteAddr,\n+                                error.cause));\n+            } else {\n+                RemoteInputChannel inputChannel = inputChannels.get(error.receiverId);\n+\n+                if (inputChannel != null) {\n+                    if (error.cause.getClass() == PartitionNotFoundException.class) {\n+                        inputChannel.onFailedPartitionRequest();\n+                    } else {\n+                        inputChannel.onError(\n+                                new RemoteTransportException(\n+                                        \"Error at remote task manager '\" + remoteAddr + \"'.\",\n+                                        remoteAddr,\n+                                        error.cause));\n+                    }\n+                }\n+            }\n+        } else if (msgClazz == NettyMessage.BacklogAnnouncement.class) {\n+            NettyMessage.BacklogAnnouncement announcement = (NettyMessage.BacklogAnnouncement) msg;\n+\n+            RemoteInputChannel inputChannel = inputChannels.get(announcement.receiverId);\n+            if (inputChannel == null || inputChannel.isReleased()) {\n+                cancelRequestFor(announcement.receiverId);\n+                return;\n+            }\n+\n+            try {\n+                inputChannel.onSenderBacklog(announcement.backlog);\n+            } catch (Throwable throwable) {\n+                inputChannel.onError(throwable);\n+            }\n+        } else {\n+            throw new IllegalStateException(\n+                    \"Received unknown message from producer: \" + msg.getClass());\n+        }\n+    }\n+\n+    private void decodeBufferOrEvent(\n+            RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent)\n+            throws Throwable {\n+        if (bufferOrEvent.isBuffer() && bufferOrEvent.bufferSize == 0) {\n+            inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n+        } else if (bufferOrEvent.getBuffer() != null) {\n+            inputChannel.onBuffer(\n+                    bufferOrEvent.getBuffer(), bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n+        } else {\n+            throw new IllegalStateException(\n+                    \"The read buffer is null in credit-based input channel.\");\n+        }\n+    }\n+\n+    /**\n+     * Tries to write&flush unannounced credits for the next input channel in queue.\n+     *\n+     * <p>This method may be called by the first input channel enqueuing, or the complete future's\n+     * callback in previous input channel, or the channel writability changed event.\n+     */\n+    private void writeAndFlushNextMessageIfPossible(Channel channel) {\n+        if (channelError.get() != null || !channel.isWritable()) {\n+            return;\n+        }\n+\n+        while (true) {\n+            ClientOutboundMessage outboundMessage = clientOutboundMessages.poll();\n+\n+            // The input channel may be null because of the write callbacks\n+            // that are executed after each write.\n+            if (outboundMessage == null) {\n+                return;\n+            }\n+\n+            // It is no need to notify credit or resume data consumption for the released channel.\n+            if (!outboundMessage.inputChannel.isReleased()) {\n+                Object msg = outboundMessage.buildMessage();\n+                if (msg == null) {\n+                    continue;\n+                }\n+\n+                // Write and flush and wait until this is done before\n+                // trying to continue with the next input channel.\n+                channel.writeAndFlush(msg).addListener(writeListener);\n+\n+                return;\n+            }\n+        }\n+    }\n+\n+    private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            try {\n+                if (future.isSuccess()) {\n+                    writeAndFlushNextMessageIfPossible(future.channel());\n+                } else if (future.cause() != null) {\n+                    notifyAllChannelsOfErrorAndClose(future.cause());\n+                } else {\n+                    notifyAllChannelsOfErrorAndClose(\n+                            new IllegalStateException(\"Sending cancelled by user.\"));\n+                }\n+            } catch (Throwable t) {\n+                notifyAllChannelsOfErrorAndClose(t);\n+            }\n+        }\n+    }\n+\n+    private abstract static class ClientOutboundMessage {\n+        protected final RemoteInputChannel inputChannel;\n+\n+        ClientOutboundMessage(RemoteInputChannel inputChannel) {\n+            this.inputChannel = inputChannel;\n+        }\n+\n+        @Nullable\n+        abstract Object buildMessage();\n+    }\n+\n+    private static class AddCreditMessage extends ClientOutboundMessage {\n+\n+        AddCreditMessage(RemoteInputChannel inputChannel) {\n+            super(checkNotNull(inputChannel));\n+        }\n+\n+        @Override\n+        public Object buildMessage() {\n+            int credits = inputChannel.getAndResetUnannouncedCredit();\n+            return credits > 0 ? new AddCredit(credits, inputChannel.getInputChannelId()) : null;\n+        }\n+    }\n+\n+    private static class ResumeConsumptionMessage extends ClientOutboundMessage {\n+\n+        ResumeConsumptionMessage(RemoteInputChannel inputChannel) {\n+            super(checkNotNull(inputChannel));\n+        }\n+\n+        @Override\n+        Object buildMessage() {\n+            return new ResumeConsumption(inputChannel.getInputChannelId());\n+        }\n+    }\n+\n+    private static class AcknowledgeAllRecordsProcessedMessage extends ClientOutboundMessage {\n+\n+        AcknowledgeAllRecordsProcessedMessage(RemoteInputChannel inputChannel) {\n+            super(checkNotNull(inputChannel));\n+        }\n+\n+        @Override\n+        Object buildMessage() {\n+            return new AckAllUserRecordsProcessed(inputChannel.getInputChannelId());\n+        }\n+    }\n }\n", "next_change": {"commit": "4648e8af115410b4d1a5aefed44cdb6bd9d07ebb", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex 41d91430e70..55ca906f529 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n", "chunk": "@@ -433,52 +394,4 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n             }\n         }\n     }\n-\n-    private abstract static class ClientOutboundMessage {\n-        protected final RemoteInputChannel inputChannel;\n-\n-        ClientOutboundMessage(RemoteInputChannel inputChannel) {\n-            this.inputChannel = inputChannel;\n-        }\n-\n-        @Nullable\n-        abstract Object buildMessage();\n-    }\n-\n-    private static class AddCreditMessage extends ClientOutboundMessage {\n-\n-        AddCreditMessage(RemoteInputChannel inputChannel) {\n-            super(checkNotNull(inputChannel));\n-        }\n-\n-        @Override\n-        public Object buildMessage() {\n-            int credits = inputChannel.getAndResetUnannouncedCredit();\n-            return credits > 0 ? new AddCredit(credits, inputChannel.getInputChannelId()) : null;\n-        }\n-    }\n-\n-    private static class ResumeConsumptionMessage extends ClientOutboundMessage {\n-\n-        ResumeConsumptionMessage(RemoteInputChannel inputChannel) {\n-            super(checkNotNull(inputChannel));\n-        }\n-\n-        @Override\n-        Object buildMessage() {\n-            return new ResumeConsumption(inputChannel.getInputChannelId());\n-        }\n-    }\n-\n-    private static class AcknowledgeAllRecordsProcessedMessage extends ClientOutboundMessage {\n-\n-        AcknowledgeAllRecordsProcessedMessage(RemoteInputChannel inputChannel) {\n-            super(checkNotNull(inputChannel));\n-        }\n-\n-        @Override\n-        Object buildMessage() {\n-            return new AckAllUserRecordsProcessed(inputChannel.getInputChannelId());\n-        }\n-    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "a36fac6fceff59a237e90e55965abf76b39e3127", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Message for notification about new buffer size(NewBufferSize) was added"}, {"oid": "4648e8af115410b4d1a5aefed44cdb6bd9d07ebb", "committedDate": "2021-10-21 17:37:16 +0200", "message": "[FLINK-24468][runtime] Moved the methods for sending messages from NetworkClientHandler to NettyPartitioonRequestClient since it is not responsibility of handler to send them"}, {"oid": "c0cca2e16430758950627068306c7bf6056c98c9", "committedDate": "2022-02-16 14:05:13 +0800", "message": "[hotfix][network] Remove the deduplication for CancelPartitionRequest."}, {"oid": "5be7d480dd3a54c17ef34d76b82b9f6a80ba8bf0", "committedDate": "2022-02-16 14:05:44 +0800", "message": "[FLINK-15455][network] Enabled tcp connection reuse across multi jobs."}, {"oid": "93c834be953f1336adb3ec5b5bf759a20e25eddf", "committedDate": "2022-11-18 10:40:25 +0800", "message": "[FLINK-29639] Print resourceId of remote taskmanager when encounter transport exception."}, {"oid": "4b10f422f20ca22661a1870eadc343cab4a44567", "committedDate": "2022-11-21 11:44:39 +0100", "message": "[FLINK-28695][hotfix][network] Remove some unused exceptions"}, {"oid": "e7854193816dc348086423b42d4dff12dca4a80e", "committedDate": "2022-11-21 11:44:39 +0100", "message": "[FLINK-28695][network] Fix the bug of old netty client isn't closed when netty server closes channel and no input channel"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NDM5NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424164395", "body": "this change should be together with the previous hotfix commit \" making `initialCredit` as final\"", "bodyText": "this change should be together with the previous hotfix commit \" making initialCredit as final\"", "bodyHTML": "<p dir=\"auto\">this change should be together with the previous hotfix commit \" making <code>initialCredit</code> as final\"</p>", "author": "zhijiangW", "createdAt": "2020-05-13T04:22:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -129,7 +132,6 @@ private boolean shouldContinueRequest(BufferPool bufferPool) {\n \t */\n \tvoid requestExclusiveBuffers() throws IOException {\n \t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI4NDM4Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424284387", "bodyText": "Before the last commit, we can't set numExclusive buffers to 0, so the check should be reserved before the last commit.", "author": "wsry", "createdAt": "2020-05-13T09:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NDM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkxMTkwMQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424911901", "bodyText": "Got it. So do you think we add the if (initialCredit > 0) before calling this method inside RemoteInputChannel#assignExclusiveSegments?  Just for not necessary to synchronized below for empty segments.", "author": "zhijiangW", "createdAt": "2020-05-14T07:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NDM5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 37e357b2ea0..7fb7cf9358b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -128,7 +125,7 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t}\n \n \t/**\n-\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n+\t * Requests exclusive buffers from the provider.\n \t */\n \tvoid requestExclusiveBuffers() throws IOException {\n \t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 7fb7cf9358b..ba6e75d3a43 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -44,394 +44,399 @@ import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += numRequired;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n-\t\t\tnumRequiredBuffers += bufferReleased;\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tnumRequiredBuffers = 0;\n-\t\t\tbufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint getNumberOfRequiredBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn numRequiredBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn isWaitingForFloatingBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffers() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer(int initialCredit) {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            if (initialCredit == 0) {\n+                checkState(\n+                        bufferQueue.getAvailableBufferSize() <= numRequiredBuffers,\n+                        \"Too many buffers allocated.\");\n+                --numRequiredBuffers;\n+            }\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        if (numExclusiveBuffers <= 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        int numAddedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                } else {\n+                    numAddedBuffers =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        try {\n+            inputChannel.notifyBufferAvailable(numAddedBuffers);\n+        } catch (Throwable t) {\n+            ExceptionUtils.rethrow(t);\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            bufferQueue.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            if (buffer.getRecycler() == this) {\n+                exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+            } else {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+        synchronized (bufferQueue) {\n+            bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+            bufferQueue.notifyAll();\n+        }\n+\n+        if (exclusiveRecyclingSegments.size() > 0) {\n+            globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n+         * number of available buffers in queue is more than the required amount.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return How many buffers were added to the queue\n+         */\n+        int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                Buffer floatingBuffer = floatingBuffers.poll();\n+                if (floatingBuffer != null) {\n+                    floatingBuffer.recycleBuffer();\n+                    return 0;\n+                }\n+            }\n+            return 1;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": {"commit": "8550965d808fe7b4d6ff2d48034612878937a579", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex ba6e75d3a43..8031f6b5d3c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -428,11 +448,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..82162f51ae3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,10 +448,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        Queue<Buffer> clearFloatingBuffers() {\n-            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n-            floatingBuffers.clear();\n-            return buffers;\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 82162f51ae3..0867fbba828 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,11 +458,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 37e357b2ea0..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -41,416 +38,435 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Queue;\n \n+import static org.apache.flink.util.ExceptionUtils.firstOrSuppressed;\n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given backlog, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int backlog) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += backlog;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage(\n-\t\t\tInputChannelID channelID,\n-\t\t\tint initialCredit) throws IOException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tcheckState(numRequiredBuffers >= 0, \"Number of required buffers should be non-negative.\");\n-\t\t\tcheckState(bufferQueue.getAvailableBufferSize() == initialCredit, \"Illegal number of available buffers.\");\n-\n-\t\t\tif (initialCredit > 0) {\n-\t\t\t\treturn new NettyMessage.ResumeConsumption(channelID, initialCredit, numRequiredBuffers);\n-\t\t\t}\n-\n-\t\t\tint numCredit = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numCredit;\n-\t\t\treturn new NettyMessage.ResumeConsumption(channelID, numCredit, numRequiredBuffers);\n-\t\t}\n-\t}\n-\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier, int initialCredit) {\n-\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t}\n-\n-\t\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n-\t\t\t\tnumRequiredBuffers += bufferReleased;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tnumRequiredBuffers = 0;\n-\t\t\tbufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint unsynchronizedGetNumberOfRequiredBuffers() {\n-\t\treturn numRequiredBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean unsynchronizedIsWaitingForFloatingBuffers() {\n-\t\treturn isWaitingForFloatingBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer() {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            --numRequiredBuffers;\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        checkArgument(numExclusiveBuffers >= 0, \"Num exclusive buffers must be non-negative.\");\n+        if (numExclusiveBuffers == 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            // AvailableBufferQueue::addExclusiveBuffer may release the previously allocated\n+            // floating buffer, which requires the caller to recycle these released floating\n+            // buffers. There should be no floating buffers that have been allocated before the\n+            // exclusive buffers are initialized, so here only a simple assertion is required\n+            checkState(\n+                    unsynchronizedGetFloatingBuffersAvailable() == 0,\n+                    \"Bug in buffer allocation logic: floating buffer is allocated before exclusive buffers are initialized.\");\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        @Nullable Buffer releasedFloatingBuffer = null;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                    return;\n+                } else {\n+                    releasedFloatingBuffer =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        if (releasedFloatingBuffer != null) {\n+            releasedFloatingBuffer.recycleBuffer();\n+        } else {\n+            try {\n+                inputChannel.notifyBufferAvailable(1);\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            }\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        Queue<Buffer> buffers;\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            buffers = bufferQueue.clearFloatingBuffers();\n+        }\n+\n+        // recycle all buffers out of the synchronization block to avoid dead lock\n+        while (!buffers.isEmpty()) {\n+            buffers.poll().recycleBuffer();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Exception err = null;\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            try {\n+                if (buffer.getRecycler() == BufferManager.this) {\n+                    exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+                } else {\n+                    buffer.recycleBuffer();\n+                }\n+            } catch (Exception e) {\n+                err = firstOrSuppressed(e, err);\n+            }\n+        }\n+        try {\n+            synchronized (bufferQueue) {\n+                bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+                bufferQueue.notifyAll();\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        try {\n+            if (exclusiveRecyclingSegments.size() > 0) {\n+                globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        if (err != null) {\n+            throw err instanceof IOException ? (IOException) err : new IOException(err);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and releases one floating buffer if the\n+         * number of available buffers in queue is more than the required amount. If floating buffer\n+         * is released, the total amount of available buffers after adding this exclusive buffer has\n+         * not changed, and no new buffers are available. The caller is responsible for recycling\n+         * the release/returned floating buffer.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return An released floating buffer, may be null if the numRequiredBuffers is not met.\n+         */\n+        @Nullable\n+        Buffer addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                return floatingBuffers.poll();\n+            }\n+            return null;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "48a384dffc770289a38df816a38bd336ea992ed7", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[FLINK-23466][network] Fix the bug that buffer listeners may not be notified when recycling buffers"}, {"oid": "c91837edb782c67eab799a569077053695a29fc3", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[hotfix][refactor] Remove BufferListener#NotificationResult to simplify the code"}, {"oid": "38f7c593538d78e67ed75f006826b9fc3e97826e", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[hotfix] Rename some methods of NetworkBufferPool and add more comments for better readability"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NTEwMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424165102", "body": "This renaming is not necessary. \r\n\r\n`BufferManager` is abstracted as a general purpose, not coupled with credit-based process, so it is better to not define a argument strongly related to credit-based purpose. `numRequired` seems more general to describe the semantic.", "bodyText": "This renaming is not necessary.\nBufferManager is abstracted as a general purpose, not coupled with credit-based process, so it is better to not define a argument strongly related to credit-based purpose. numRequired seems more general to describe the semantic.", "bodyHTML": "<p dir=\"auto\">This renaming is not necessary.</p>\n<p dir=\"auto\"><code>BufferManager</code> is abstracted as a general purpose, not coupled with credit-based process, so it is better to not define a argument strongly related to credit-based purpose. <code>numRequired</code> seems more general to describe the semantic.</p>", "author": "zhijiangW", "createdAt": "2020-05-13T04:25:12Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -139,10 +141,10 @@ void requestExclusiveBuffers() throws IOException {\n \t}\n \n \t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n+\t * Requests floating buffers from the buffer pool based on the given backlog, and returns the actual\n \t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n \t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n+\tint requestFloatingBuffers(int backlog) throws IOException {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 37e357b2ea0..7fb7cf9358b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -141,10 +138,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t}\n \n \t/**\n-\t * Requests floating buffers from the buffer pool based on the given backlog, and returns the actual\n+\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n \t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n \t */\n-\tint requestFloatingBuffers(int backlog) throws IOException {\n+\tint requestFloatingBuffers(int numRequired) throws IOException {\n \t\tint numRequestedBuffers = 0;\n \t\tsynchronized (bufferQueue) {\n \t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 7fb7cf9358b..ba6e75d3a43 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -44,394 +44,399 @@ import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += numRequired;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n-\t\t\tnumRequiredBuffers += bufferReleased;\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tnumRequiredBuffers = 0;\n-\t\t\tbufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint getNumberOfRequiredBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn numRequiredBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn isWaitingForFloatingBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffers() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer(int initialCredit) {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            if (initialCredit == 0) {\n+                checkState(\n+                        bufferQueue.getAvailableBufferSize() <= numRequiredBuffers,\n+                        \"Too many buffers allocated.\");\n+                --numRequiredBuffers;\n+            }\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        if (numExclusiveBuffers <= 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        int numAddedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                } else {\n+                    numAddedBuffers =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        try {\n+            inputChannel.notifyBufferAvailable(numAddedBuffers);\n+        } catch (Throwable t) {\n+            ExceptionUtils.rethrow(t);\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            bufferQueue.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            if (buffer.getRecycler() == this) {\n+                exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+            } else {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+        synchronized (bufferQueue) {\n+            bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+            bufferQueue.notifyAll();\n+        }\n+\n+        if (exclusiveRecyclingSegments.size() > 0) {\n+            globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n+         * number of available buffers in queue is more than the required amount.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return How many buffers were added to the queue\n+         */\n+        int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                Buffer floatingBuffer = floatingBuffers.poll();\n+                if (floatingBuffer != null) {\n+                    floatingBuffer.recycleBuffer();\n+                    return 0;\n+                }\n+            }\n+            return 1;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": {"commit": "8550965d808fe7b4d6ff2d48034612878937a579", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex ba6e75d3a43..8031f6b5d3c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -428,11 +448,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..82162f51ae3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,10 +448,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        Queue<Buffer> clearFloatingBuffers() {\n-            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n-            floatingBuffers.clear();\n-            return buffers;\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 82162f51ae3..0867fbba828 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,11 +458,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 37e357b2ea0..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -41,416 +38,435 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Queue;\n \n+import static org.apache.flink.util.ExceptionUtils.firstOrSuppressed;\n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given backlog, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int backlog) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += backlog;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage(\n-\t\t\tInputChannelID channelID,\n-\t\t\tint initialCredit) throws IOException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tcheckState(numRequiredBuffers >= 0, \"Number of required buffers should be non-negative.\");\n-\t\t\tcheckState(bufferQueue.getAvailableBufferSize() == initialCredit, \"Illegal number of available buffers.\");\n-\n-\t\t\tif (initialCredit > 0) {\n-\t\t\t\treturn new NettyMessage.ResumeConsumption(channelID, initialCredit, numRequiredBuffers);\n-\t\t\t}\n-\n-\t\t\tint numCredit = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numCredit;\n-\t\t\treturn new NettyMessage.ResumeConsumption(channelID, numCredit, numRequiredBuffers);\n-\t\t}\n-\t}\n-\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier, int initialCredit) {\n-\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t}\n-\n-\t\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n-\t\t\t\tnumRequiredBuffers += bufferReleased;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tnumRequiredBuffers = 0;\n-\t\t\tbufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint unsynchronizedGetNumberOfRequiredBuffers() {\n-\t\treturn numRequiredBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean unsynchronizedIsWaitingForFloatingBuffers() {\n-\t\treturn isWaitingForFloatingBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer() {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            --numRequiredBuffers;\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        checkArgument(numExclusiveBuffers >= 0, \"Num exclusive buffers must be non-negative.\");\n+        if (numExclusiveBuffers == 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            // AvailableBufferQueue::addExclusiveBuffer may release the previously allocated\n+            // floating buffer, which requires the caller to recycle these released floating\n+            // buffers. There should be no floating buffers that have been allocated before the\n+            // exclusive buffers are initialized, so here only a simple assertion is required\n+            checkState(\n+                    unsynchronizedGetFloatingBuffersAvailable() == 0,\n+                    \"Bug in buffer allocation logic: floating buffer is allocated before exclusive buffers are initialized.\");\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        @Nullable Buffer releasedFloatingBuffer = null;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                    return;\n+                } else {\n+                    releasedFloatingBuffer =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        if (releasedFloatingBuffer != null) {\n+            releasedFloatingBuffer.recycleBuffer();\n+        } else {\n+            try {\n+                inputChannel.notifyBufferAvailable(1);\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            }\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        Queue<Buffer> buffers;\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            buffers = bufferQueue.clearFloatingBuffers();\n+        }\n+\n+        // recycle all buffers out of the synchronization block to avoid dead lock\n+        while (!buffers.isEmpty()) {\n+            buffers.poll().recycleBuffer();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Exception err = null;\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            try {\n+                if (buffer.getRecycler() == BufferManager.this) {\n+                    exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+                } else {\n+                    buffer.recycleBuffer();\n+                }\n+            } catch (Exception e) {\n+                err = firstOrSuppressed(e, err);\n+            }\n+        }\n+        try {\n+            synchronized (bufferQueue) {\n+                bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+                bufferQueue.notifyAll();\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        try {\n+            if (exclusiveRecyclingSegments.size() > 0) {\n+                globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        if (err != null) {\n+            throw err instanceof IOException ? (IOException) err : new IOException(err);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and releases one floating buffer if the\n+         * number of available buffers in queue is more than the required amount. If floating buffer\n+         * is released, the total amount of available buffers after adding this exclusive buffer has\n+         * not changed, and no new buffers are available. The caller is responsible for recycling\n+         * the release/returned floating buffer.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return An released floating buffer, may be null if the numRequiredBuffers is not met.\n+         */\n+        @Nullable\n+        Buffer addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                return floatingBuffers.poll();\n+            }\n+            return null;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "48a384dffc770289a38df816a38bd336ea992ed7", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[FLINK-23466][network] Fix the bug that buffer listeners may not be notified when recycling buffers"}, {"oid": "c91837edb782c67eab799a569077053695a29fc3", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[hotfix][refactor] Remove BufferListener#NotificationResult to simplify the code"}, {"oid": "38f7c593538d78e67ed75f006826b9fc3e97826e", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[hotfix] Rename some methods of NetworkBufferPool and add more comments for better readability"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NzY5OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424167698", "body": "Keep in mind that `BufferManager` is only for buffer request/release related operations, so it should not understand the other specific logics which should be done inside the respective `InputChannel`. Otherwise we would dirty this component and have ambiguous definition what is the role of this component.\r\n\r\nIn detail, the following should be done inside `RemoteInputChannel`\r\n\r\n```\r\nCheckpointOptions options = barrier.getCheckpointOptions();\r\nif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) \r\n```\r\nAnd rename  the method `onCheckpointBarrier` to distinguish with existing `releaseFloatingBuffers()`. From the perspective of outside caller, we should give a clear semantic method naming in order to be reused future.", "bodyText": "Keep in mind that BufferManager is only for buffer request/release related operations, so it should not understand the other specific logics which should be done inside the respective InputChannel. Otherwise we would dirty this component and have ambiguous definition what is the role of this component.\nIn detail, the following should be done inside RemoteInputChannel\nCheckpointOptions options = barrier.getCheckpointOptions();\nif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) \n\nAnd rename  the method onCheckpointBarrier to distinguish with existing releaseFloatingBuffers(). From the perspective of outside caller, we should give a clear semantic method naming in order to be reused future.", "bodyHTML": "<p dir=\"auto\">Keep in mind that <code>BufferManager</code> is only for buffer request/release related operations, so it should not understand the other specific logics which should be done inside the respective <code>InputChannel</code>. Otherwise we would dirty this component and have ambiguous definition what is the role of this component.</p>\n<p dir=\"auto\">In detail, the following should be done inside <code>RemoteInputChannel</code></p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"CheckpointOptions options = barrier.getCheckpointOptions();\nif (initialCredit == 0 &amp;&amp; options.isExactlyOnceMode() &amp;&amp; !options.isUnalignedCheckpoint()) \n\"><pre><code>CheckpointOptions options = barrier.getCheckpointOptions();\nif (initialCredit == 0 &amp;&amp; options.isExactlyOnceMode() &amp;&amp; !options.isUnalignedCheckpoint()) \n</code></pre></div>\n<p dir=\"auto\">And rename  the method <code>onCheckpointBarrier</code> to distinguish with existing <code>releaseFloatingBuffers()</code>. From the perspective of outside caller, we should give a clear semantic method naming in order to be reused future.</p>", "author": "zhijiangW", "createdAt": "2020-05-13T04:37:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -151,23 +153,63 @@ int requestFloatingBuffers(int numRequired) throws IOException {\n \t\t\t\treturn numRequestedBuffers;\n \t\t\t}\n \n-\t\t\tnumRequiredBuffers = numRequired;\n+\t\t\tnumRequiredBuffers += backlog;\n+\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n \n-\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n-\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\t\tnumRequestedBuffers++;\n-\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n+\t\tassert Thread.holdsLock(bufferQueue);\n+\n+\t\tint numRequestedBuffers = 0;\n+\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n+\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\tif (buffer != null) {\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\tnumRequestedBuffers++;\n+\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\treturn numRequestedBuffers;\n \t}\n \n+\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage(\n+\t\t\tInputChannelID channelID,\n+\t\t\tint initialCredit) throws IOException {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tcheckState(numRequiredBuffers >= 0, \"Number of required buffers should be non-negative.\");\n+\t\t\tcheckState(bufferQueue.getAvailableBufferSize() == initialCredit, \"Illegal number of available buffers.\");\n+\n+\t\t\tif (initialCredit > 0) {\n+\t\t\t\treturn new NettyMessage.ResumeConsumption(channelID, initialCredit, numRequiredBuffers);\n+\t\t\t}\n+\n+\t\t\tint numCredit = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numCredit;\n+\t\t\treturn new NettyMessage.ResumeConsumption(channelID, numCredit, numRequiredBuffers);\n+\t\t}\n+\t}\n+\n+\tpublic void onCheckpointBarrier(CheckpointBarrier barrier, int initialCredit) {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 37e357b2ea0..7fb7cf9358b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -178,35 +175,15 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t\treturn numRequestedBuffers;\n \t}\n \n-\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage(\n-\t\t\tInputChannelID channelID,\n-\t\t\tint initialCredit) throws IOException {\n+\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n \t\tsynchronized (bufferQueue) {\n-\t\t\tcheckState(numRequiredBuffers >= 0, \"Number of required buffers should be non-negative.\");\n-\t\t\tcheckState(bufferQueue.getAvailableBufferSize() == initialCredit, \"Illegal number of available buffers.\");\n-\n-\t\t\tif (initialCredit > 0) {\n-\t\t\t\treturn new NettyMessage.ResumeConsumption(channelID, initialCredit, numRequiredBuffers);\n+\t\t\tif (isWaitingForFloatingBuffers) {\n+\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n+\t\t\t\tisWaitingForFloatingBuffers = false;\n \t\t\t}\n \n-\t\t\tint numCredit = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numCredit;\n-\t\t\treturn new NettyMessage.ResumeConsumption(channelID, numCredit, numRequiredBuffers);\n-\t\t}\n-\t}\n-\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier, int initialCredit) {\n-\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t}\n-\n-\t\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n-\t\t\t\tnumRequiredBuffers += bufferReleased;\n-\t\t\t}\n+\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n+\t\t\tnumRequiredBuffers += bufferReleased;\n \t\t}\n \t}\n \n", "next_change": {"commit": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 7fb7cf9358b..78c34783461 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -182,8 +182,7 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t\t\t\tisWaitingForFloatingBuffers = false;\n \t\t\t}\n \n-\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n-\t\t\tnumRequiredBuffers += bufferReleased;\n+\t\t\tnumRequiredBuffers += bufferQueue.releaseFloatingBuffers();\n \t\t}\n \t}\n \n", "next_change": {"commit": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 78c34783461..0f216cae4d1 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -175,17 +174,6 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t\treturn numRequestedBuffers;\n \t}\n \n-\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += bufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n \t// ------------------------------------------------------------------------\n \t// Buffer recycle\n \t// ------------------------------------------------------------------------\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 0f216cae4d1..ba6e75d3a43 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -41,391 +41,402 @@ import java.util.List;\n \n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += numRequired;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers(boolean isTemporaryRelease) {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tint numReleasedBuffers = bufferQueue.releaseFloatingBuffers();\n-\t\t\tif (isTemporaryRelease) {\n-\t\t\t\tnumRequiredBuffers += numReleasedBuffers;\n-\t\t\t} else {\n-\t\t\t\tnumRequiredBuffers = 0;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint getNumberOfRequiredBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn numRequiredBuffers;\n-\t\t}\n-\t}\n-\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn isWaitingForFloatingBuffers;\n-\t\t}\n-\t}\n-\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffers() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer(int initialCredit) {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            if (initialCredit == 0) {\n+                checkState(\n+                        bufferQueue.getAvailableBufferSize() <= numRequiredBuffers,\n+                        \"Too many buffers allocated.\");\n+                --numRequiredBuffers;\n+            }\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        if (numExclusiveBuffers <= 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        int numAddedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                } else {\n+                    numAddedBuffers =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        try {\n+            inputChannel.notifyBufferAvailable(numAddedBuffers);\n+        } catch (Throwable t) {\n+            ExceptionUtils.rethrow(t);\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            bufferQueue.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            if (buffer.getRecycler() == this) {\n+                exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+            } else {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+        synchronized (bufferQueue) {\n+            bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+            bufferQueue.notifyAll();\n+        }\n+\n+        if (exclusiveRecyclingSegments.size() > 0) {\n+            globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n+         * number of available buffers in queue is more than the required amount.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return How many buffers were added to the queue\n+         */\n+        int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                Buffer floatingBuffer = floatingBuffers.poll();\n+                if (floatingBuffer != null) {\n+                    floatingBuffer.recycleBuffer();\n+                    return 0;\n+                }\n+            }\n+            return 1;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": {"commit": "8550965d808fe7b4d6ff2d48034612878937a579", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex ba6e75d3a43..8031f6b5d3c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -428,11 +448,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..82162f51ae3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,10 +448,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        Queue<Buffer> clearFloatingBuffers() {\n-            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n-            floatingBuffers.clear();\n-            return buffers;\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 82162f51ae3..0867fbba828 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,11 +458,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 37e357b2ea0..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -41,416 +38,435 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Queue;\n \n+import static org.apache.flink.util.ExceptionUtils.firstOrSuppressed;\n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given backlog, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int backlog) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += backlog;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage(\n-\t\t\tInputChannelID channelID,\n-\t\t\tint initialCredit) throws IOException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tcheckState(numRequiredBuffers >= 0, \"Number of required buffers should be non-negative.\");\n-\t\t\tcheckState(bufferQueue.getAvailableBufferSize() == initialCredit, \"Illegal number of available buffers.\");\n-\n-\t\t\tif (initialCredit > 0) {\n-\t\t\t\treturn new NettyMessage.ResumeConsumption(channelID, initialCredit, numRequiredBuffers);\n-\t\t\t}\n-\n-\t\t\tint numCredit = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numCredit;\n-\t\t\treturn new NettyMessage.ResumeConsumption(channelID, numCredit, numRequiredBuffers);\n-\t\t}\n-\t}\n-\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier, int initialCredit) {\n-\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t}\n-\n-\t\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n-\t\t\t\tnumRequiredBuffers += bufferReleased;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tnumRequiredBuffers = 0;\n-\t\t\tbufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint unsynchronizedGetNumberOfRequiredBuffers() {\n-\t\treturn numRequiredBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean unsynchronizedIsWaitingForFloatingBuffers() {\n-\t\treturn isWaitingForFloatingBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer() {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            --numRequiredBuffers;\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        checkArgument(numExclusiveBuffers >= 0, \"Num exclusive buffers must be non-negative.\");\n+        if (numExclusiveBuffers == 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            // AvailableBufferQueue::addExclusiveBuffer may release the previously allocated\n+            // floating buffer, which requires the caller to recycle these released floating\n+            // buffers. There should be no floating buffers that have been allocated before the\n+            // exclusive buffers are initialized, so here only a simple assertion is required\n+            checkState(\n+                    unsynchronizedGetFloatingBuffersAvailable() == 0,\n+                    \"Bug in buffer allocation logic: floating buffer is allocated before exclusive buffers are initialized.\");\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        @Nullable Buffer releasedFloatingBuffer = null;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                    return;\n+                } else {\n+                    releasedFloatingBuffer =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        if (releasedFloatingBuffer != null) {\n+            releasedFloatingBuffer.recycleBuffer();\n+        } else {\n+            try {\n+                inputChannel.notifyBufferAvailable(1);\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            }\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        Queue<Buffer> buffers;\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            buffers = bufferQueue.clearFloatingBuffers();\n+        }\n+\n+        // recycle all buffers out of the synchronization block to avoid dead lock\n+        while (!buffers.isEmpty()) {\n+            buffers.poll().recycleBuffer();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Exception err = null;\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            try {\n+                if (buffer.getRecycler() == BufferManager.this) {\n+                    exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+                } else {\n+                    buffer.recycleBuffer();\n+                }\n+            } catch (Exception e) {\n+                err = firstOrSuppressed(e, err);\n+            }\n+        }\n+        try {\n+            synchronized (bufferQueue) {\n+                bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+                bufferQueue.notifyAll();\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        try {\n+            if (exclusiveRecyclingSegments.size() > 0) {\n+                globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        if (err != null) {\n+            throw err instanceof IOException ? (IOException) err : new IOException(err);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and releases one floating buffer if the\n+         * number of available buffers in queue is more than the required amount. If floating buffer\n+         * is released, the total amount of available buffers after adding this exclusive buffer has\n+         * not changed, and no new buffers are available. The caller is responsible for recycling\n+         * the release/returned floating buffer.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return An released floating buffer, may be null if the numRequiredBuffers is not met.\n+         */\n+        @Nullable\n+        Buffer addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                return floatingBuffers.poll();\n+            }\n+            return null;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "48a384dffc770289a38df816a38bd336ea992ed7", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[FLINK-23466][network] Fix the bug that buffer listeners may not be notified when recycling buffers"}, {"oid": "c91837edb782c67eab799a569077053695a29fc3", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[hotfix][refactor] Remove BufferListener#NotificationResult to simplify the code"}, {"oid": "38f7c593538d78e67ed75f006826b9fc3e97826e", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[hotfix] Rename some methods of NetworkBufferPool and add more comments for better readability"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2ODI2NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424168264", "body": "As mentioned in https://github.com/apache/flink/pull/11877/commits/708b2ceb97564084900c555d6f38e6ba1174d735#r424167698, this logic should be done inside `RemoteInputChannel`, because the `BufferManager` should not understand the specific logics unless buffer request/release.", "bodyText": "As mentioned in 708b2ce#r424167698, this logic should be done inside RemoteInputChannel, because the BufferManager should not understand the specific logics unless buffer request/release.", "bodyHTML": "<p dir=\"auto\">As mentioned in <a class=\"commit-link\" href=\"https://github.com/apache/flink/commit/708b2ceb97564084900c555d6f38e6ba1174d735#r424167698\"><tt>708b2ce</tt>#r424167698</a>, this logic should be done inside <code>RemoteInputChannel</code>, because the <code>BufferManager</code> should not understand the specific logics unless buffer request/release.</p>", "author": "zhijiangW", "createdAt": "2020-05-13T04:39:46Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -151,23 +153,63 @@ int requestFloatingBuffers(int numRequired) throws IOException {\n \t\t\t\treturn numRequestedBuffers;\n \t\t\t}\n \n-\t\t\tnumRequiredBuffers = numRequired;\n+\t\t\tnumRequiredBuffers += backlog;\n+\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n \n-\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n-\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\t\tnumRequestedBuffers++;\n-\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n+\t\tassert Thread.holdsLock(bufferQueue);\n+\n+\t\tint numRequestedBuffers = 0;\n+\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n+\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\tif (buffer != null) {\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\tnumRequestedBuffers++;\n+\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\treturn numRequestedBuffers;\n \t}\n \n+\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage(", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 37e357b2ea0..7fb7cf9358b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -178,35 +175,15 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t\treturn numRequestedBuffers;\n \t}\n \n-\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage(\n-\t\t\tInputChannelID channelID,\n-\t\t\tint initialCredit) throws IOException {\n+\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n \t\tsynchronized (bufferQueue) {\n-\t\t\tcheckState(numRequiredBuffers >= 0, \"Number of required buffers should be non-negative.\");\n-\t\t\tcheckState(bufferQueue.getAvailableBufferSize() == initialCredit, \"Illegal number of available buffers.\");\n-\n-\t\t\tif (initialCredit > 0) {\n-\t\t\t\treturn new NettyMessage.ResumeConsumption(channelID, initialCredit, numRequiredBuffers);\n+\t\t\tif (isWaitingForFloatingBuffers) {\n+\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n+\t\t\t\tisWaitingForFloatingBuffers = false;\n \t\t\t}\n \n-\t\t\tint numCredit = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numCredit;\n-\t\t\treturn new NettyMessage.ResumeConsumption(channelID, numCredit, numRequiredBuffers);\n-\t\t}\n-\t}\n-\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier, int initialCredit) {\n-\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t}\n-\n-\t\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n-\t\t\t\tnumRequiredBuffers += bufferReleased;\n-\t\t\t}\n+\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n+\t\t\tnumRequiredBuffers += bufferReleased;\n \t\t}\n \t}\n \n", "next_change": {"commit": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 7fb7cf9358b..78c34783461 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -182,8 +182,7 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t\t\t\tisWaitingForFloatingBuffers = false;\n \t\t\t}\n \n-\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n-\t\t\tnumRequiredBuffers += bufferReleased;\n+\t\t\tnumRequiredBuffers += bufferQueue.releaseFloatingBuffers();\n \t\t}\n \t}\n \n", "next_change": {"commit": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 78c34783461..0f216cae4d1 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -175,17 +174,6 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t\treturn numRequestedBuffers;\n \t}\n \n-\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += bufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n \t// ------------------------------------------------------------------------\n \t// Buffer recycle\n \t// ------------------------------------------------------------------------\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 0f216cae4d1..ba6e75d3a43 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -41,391 +41,402 @@ import java.util.List;\n \n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += numRequired;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers(boolean isTemporaryRelease) {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tint numReleasedBuffers = bufferQueue.releaseFloatingBuffers();\n-\t\t\tif (isTemporaryRelease) {\n-\t\t\t\tnumRequiredBuffers += numReleasedBuffers;\n-\t\t\t} else {\n-\t\t\t\tnumRequiredBuffers = 0;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint getNumberOfRequiredBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn numRequiredBuffers;\n-\t\t}\n-\t}\n-\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn isWaitingForFloatingBuffers;\n-\t\t}\n-\t}\n-\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffers() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer(int initialCredit) {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            if (initialCredit == 0) {\n+                checkState(\n+                        bufferQueue.getAvailableBufferSize() <= numRequiredBuffers,\n+                        \"Too many buffers allocated.\");\n+                --numRequiredBuffers;\n+            }\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        if (numExclusiveBuffers <= 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        int numAddedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                } else {\n+                    numAddedBuffers =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        try {\n+            inputChannel.notifyBufferAvailable(numAddedBuffers);\n+        } catch (Throwable t) {\n+            ExceptionUtils.rethrow(t);\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            bufferQueue.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            if (buffer.getRecycler() == this) {\n+                exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+            } else {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+        synchronized (bufferQueue) {\n+            bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+            bufferQueue.notifyAll();\n+        }\n+\n+        if (exclusiveRecyclingSegments.size() > 0) {\n+            globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n+         * number of available buffers in queue is more than the required amount.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return How many buffers were added to the queue\n+         */\n+        int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                Buffer floatingBuffer = floatingBuffers.poll();\n+                if (floatingBuffer != null) {\n+                    floatingBuffer.recycleBuffer();\n+                    return 0;\n+                }\n+            }\n+            return 1;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": {"commit": "8550965d808fe7b4d6ff2d48034612878937a579", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex ba6e75d3a43..8031f6b5d3c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -428,11 +448,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..82162f51ae3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,10 +448,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        Queue<Buffer> clearFloatingBuffers() {\n-            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n-            floatingBuffers.clear();\n-            return buffers;\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 82162f51ae3..0867fbba828 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,11 +458,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 37e357b2ea0..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -41,416 +38,435 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Queue;\n \n+import static org.apache.flink.util.ExceptionUtils.firstOrSuppressed;\n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given backlog, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int backlog) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += backlog;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage(\n-\t\t\tInputChannelID channelID,\n-\t\t\tint initialCredit) throws IOException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tcheckState(numRequiredBuffers >= 0, \"Number of required buffers should be non-negative.\");\n-\t\t\tcheckState(bufferQueue.getAvailableBufferSize() == initialCredit, \"Illegal number of available buffers.\");\n-\n-\t\t\tif (initialCredit > 0) {\n-\t\t\t\treturn new NettyMessage.ResumeConsumption(channelID, initialCredit, numRequiredBuffers);\n-\t\t\t}\n-\n-\t\t\tint numCredit = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numCredit;\n-\t\t\treturn new NettyMessage.ResumeConsumption(channelID, numCredit, numRequiredBuffers);\n-\t\t}\n-\t}\n-\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier, int initialCredit) {\n-\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t}\n-\n-\t\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n-\t\t\t\tnumRequiredBuffers += bufferReleased;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tnumRequiredBuffers = 0;\n-\t\t\tbufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint unsynchronizedGetNumberOfRequiredBuffers() {\n-\t\treturn numRequiredBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean unsynchronizedIsWaitingForFloatingBuffers() {\n-\t\treturn isWaitingForFloatingBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer() {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            --numRequiredBuffers;\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        checkArgument(numExclusiveBuffers >= 0, \"Num exclusive buffers must be non-negative.\");\n+        if (numExclusiveBuffers == 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            // AvailableBufferQueue::addExclusiveBuffer may release the previously allocated\n+            // floating buffer, which requires the caller to recycle these released floating\n+            // buffers. There should be no floating buffers that have been allocated before the\n+            // exclusive buffers are initialized, so here only a simple assertion is required\n+            checkState(\n+                    unsynchronizedGetFloatingBuffersAvailable() == 0,\n+                    \"Bug in buffer allocation logic: floating buffer is allocated before exclusive buffers are initialized.\");\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        @Nullable Buffer releasedFloatingBuffer = null;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                    return;\n+                } else {\n+                    releasedFloatingBuffer =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        if (releasedFloatingBuffer != null) {\n+            releasedFloatingBuffer.recycleBuffer();\n+        } else {\n+            try {\n+                inputChannel.notifyBufferAvailable(1);\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            }\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        Queue<Buffer> buffers;\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            buffers = bufferQueue.clearFloatingBuffers();\n+        }\n+\n+        // recycle all buffers out of the synchronization block to avoid dead lock\n+        while (!buffers.isEmpty()) {\n+            buffers.poll().recycleBuffer();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Exception err = null;\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            try {\n+                if (buffer.getRecycler() == BufferManager.this) {\n+                    exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+                } else {\n+                    buffer.recycleBuffer();\n+                }\n+            } catch (Exception e) {\n+                err = firstOrSuppressed(e, err);\n+            }\n+        }\n+        try {\n+            synchronized (bufferQueue) {\n+                bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+                bufferQueue.notifyAll();\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        try {\n+            if (exclusiveRecyclingSegments.size() > 0) {\n+                globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        if (err != null) {\n+            throw err instanceof IOException ? (IOException) err : new IOException(err);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and releases one floating buffer if the\n+         * number of available buffers in queue is more than the required amount. If floating buffer\n+         * is released, the total amount of available buffers after adding this exclusive buffer has\n+         * not changed, and no new buffers are available. The caller is responsible for recycling\n+         * the release/returned floating buffer.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return An released floating buffer, may be null if the numRequiredBuffers is not met.\n+         */\n+        @Nullable\n+        Buffer addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                return floatingBuffers.poll();\n+            }\n+            return null;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "48a384dffc770289a38df816a38bd336ea992ed7", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[FLINK-23466][network] Fix the bug that buffer listeners may not be notified when recycling buffers"}, {"oid": "c91837edb782c67eab799a569077053695a29fc3", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[hotfix][refactor] Remove BufferListener#NotificationResult to simplify the code"}, {"oid": "38f7c593538d78e67ed75f006826b9fc3e97826e", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[hotfix] Rename some methods of NetworkBufferPool and add more comments for better readability"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MjkwMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424182902", "body": "resumeAndGetResumptionMessage() -> getResumeConsumptionMessage()", "bodyText": "resumeAndGetResumptionMessage() -> getResumeConsumptionMessage()", "bodyHTML": "<p dir=\"auto\">resumeAndGetResumptionMessage() -&gt; getResumeConsumptionMessage()</p>", "author": "zhijiangW", "createdAt": "2020-05-13T05:36:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -334,6 +335,15 @@ public void resumeConsumption() {\n \t\tpartitionRequestClient.resumeConsumption(this);\n \t}\n \n+\t/**\n+\t * Called by netty thread to request buffers and generate {@link NettyMessage.ResumeConsumption} message.\n+\t */\n+\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage() throws IOException {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 2cbd3801b56..861d407262c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -336,12 +343,19 @@ public class RemoteInputChannel extends InputChannel {\n \t}\n \n \t/**\n-\t * Called by netty thread to request buffers and generate {@link NettyMessage.ResumeConsumption} message.\n+\t * Called by netty thread to request buffers and generate {@link ResumeConsumption} message.\n \t */\n-\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage() throws IOException {\n+\tpublic ResumeConsumption getResumeConsumptionMessage() throws IOException {\n \t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n+\t\tcheckState(bufferManager.getNumberOfAvailableBuffers() == initialCredit, \"Illegal number of available buffers.\");\n+\t\tcheckState(!bufferManager.isWaitingForFloatingBuffers(), \"Should not be waiting for floating buffers.\");\n+\n+\t\tif (initialCredit > 0) {\n+\t\t\treturn new ResumeConsumption(id, initialCredit, bufferManager.getNumberOfRequiredBuffers());\n+\t\t}\n \n-\t\treturn bufferManager.resumeAndGetResumptionMessage(id, initialCredit);\n+\t\tint availableCredit = bufferManager.requestFloatingBuffers(0);\n+\t\treturn new ResumeConsumption(id, availableCredit, bufferManager.getNumberOfRequiredBuffers());\n \t}\n \n \t// ------------------------------------------------------------------------\n", "next_change": {"commit": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 861d407262c..5e125aef0d0 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -347,15 +345,15 @@ public class RemoteInputChannel extends InputChannel {\n \t */\n \tpublic ResumeConsumption getResumeConsumptionMessage() throws IOException {\n \t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n-\t\tcheckState(bufferManager.getNumberOfAvailableBuffers() == initialCredit, \"Illegal number of available buffers.\");\n-\t\tcheckState(!bufferManager.isWaitingForFloatingBuffers(), \"Should not be waiting for floating buffers.\");\n+\t\tcheckState(getNumberOfAvailableBuffers() == initialCredit, \"Illegal number of available buffers.\");\n+\t\tcheckState(isWaitingForFloatingBuffers(), \"Should not be waiting for floating buffers.\");\n \n \t\tif (initialCredit > 0) {\n-\t\t\treturn new ResumeConsumption(id, initialCredit, bufferManager.getNumberOfRequiredBuffers());\n+\t\t\treturn new ResumeConsumption(id, initialCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n \t\t}\n \n \t\tint availableCredit = bufferManager.requestFloatingBuffers(0);\n-\t\treturn new ResumeConsumption(id, availableCredit, bufferManager.getNumberOfRequiredBuffers());\n+\t\treturn new ResumeConsumption(id, availableCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n \t}\n \n \t// ------------------------------------------------------------------------\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 5e125aef0d0..3e976686f91 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -20,533 +20,781 @@ package org.apache.flink.runtime.io.network.partition.consumer;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.metrics.Counter;\n-import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.runtime.checkpoint.CheckpointException;\n+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;\n import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;\n+import org.apache.flink.runtime.event.AbstractEvent;\n import org.apache.flink.runtime.event.TaskEvent;\n+import org.apache.flink.runtime.execution.CancelTaskException;\n import org.apache.flink.runtime.io.network.ConnectionID;\n import org.apache.flink.runtime.io.network.ConnectionManager;\n import org.apache.flink.runtime.io.network.PartitionRequestClient;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+import org.apache.flink.runtime.io.network.api.EventAnnouncement;\n+import org.apache.flink.runtime.io.network.api.serialization.EventSerializer;\n import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.Buffer.DataType;\n import org.apache.flink.runtime.io.network.buffer.BufferProvider;\n-import org.apache.flink.runtime.io.network.buffer.BufferReceivedListener;\n-import org.apache.flink.runtime.io.network.netty.NettyMessage.ResumeConsumption;\n+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;\n import org.apache.flink.runtime.io.network.partition.PartitionNotFoundException;\n+import org.apache.flink.runtime.io.network.partition.PrioritizedDeque;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n \n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterators;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n-/**\n- * An input channel, which requests a remote partition queue.\n- */\n+/** An input channel, which requests a remote partition queue. */\n public class RemoteInputChannel extends InputChannel {\n-\n-\t/** ID to distinguish this channel from other channels sharing the same TCP connection. */\n-\tprivate final InputChannelID id = new InputChannelID();\n-\n-\t/** The connection to use to request the remote partition. */\n-\tprivate final ConnectionID connectionId;\n-\n-\t/** The connection manager to use connect to the remote partition provider. */\n-\tprivate final ConnectionManager connectionManager;\n-\n-\t/**\n-\t * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n-\t * is consumed by the receiving task thread.\n-\t */\n-\tprivate final ArrayDeque<Buffer> receivedBuffers = new ArrayDeque<>();\n-\n-\t/**\n-\t * Flag indicating whether this channel has been released. Either called by the receiving task\n-\t * thread or the task manager actor.\n-\t */\n-\tprivate final AtomicBoolean isReleased = new AtomicBoolean();\n-\n-\t/** Client to establish a (possibly shared) TCP connection and request the partition. */\n-\tprivate volatile PartitionRequestClient partitionRequestClient;\n-\n-\t/**\n-\t * The next expected sequence number for the next buffer. This is modified by the network\n-\t * I/O thread only.\n-\t */\n-\tprivate int expectedSequenceNumber = 0;\n-\n-\t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate final int initialCredit;\n-\n-\t/** The number of available buffers that have not been announced to the producer yet. */\n-\tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n-\n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n-\n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n-\n-\tprivate final BufferManager bufferManager;\n-\n-\tpublic RemoteInputChannel(\n-\t\tSingleInputGate inputGate,\n-\t\tint channelIndex,\n-\t\tResultPartitionID partitionId,\n-\t\tConnectionID connectionId,\n-\t\tConnectionManager connectionManager,\n-\t\tint initialBackOff,\n-\t\tint maxBackoff,\n-\t\tint networkBuffersPerChannel,\n-\t\tCounter numBytesIn,\n-\t\tCounter numBuffersIn) {\n-\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, numBytesIn, numBuffersIn);\n-\n-\t\tthis.initialCredit = networkBuffersPerChannel;\n-\t\tthis.connectionId = checkNotNull(connectionId);\n-\t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n-\t}\n-\n-\t/**\n-\t * Assigns exclusive buffers to this input channel, and this method should be called only once\n-\t * after this input channel is created.\n-\t */\n-\tvoid assignExclusiveSegments() throws IOException {\n-\t\tcheckState(bufferManager.unsynchronizedGetExclusiveBuffers() == 0, \"Bug in input channel setup logic: \" +\n-\t\t\t\"exclusive buffers have already been set for this input channel.\");\n-\n-\t\tbufferManager.requestExclusiveBuffers();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests a remote subpartition.\n-\t */\n-\t@VisibleForTesting\n-\t@Override\n-\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n-\t\tif (partitionRequestClient == null) {\n-\t\t\t// Create a client and request the partition\n-\t\t\ttry {\n-\t\t\t\tpartitionRequestClient = connectionManager.createPartitionRequestClient(connectionId);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\t// IOExceptions indicate that we could not open a connection to the remote TaskExecutor\n-\t\t\t\tthrow new PartitionConnectionException(partitionId, e);\n-\t\t\t}\n-\n-\t\t\tpartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Retriggers a remote subpartition request.\n-\t */\n-\tvoid retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n-\t\tcheckState(partitionRequestClient != null, \"Missing initial subpartition request.\");\n-\n-\t\tif (increaseBackoff()) {\n-\t\t\tpartitionRequestClient.requestSubpartition(\n-\t\t\t\tpartitionId, subpartitionIndex, this, getCurrentBackoff());\n-\t\t} else {\n-\t\t\tfailPartitionRequest();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tOptional<BufferAndAvailability> getNextBuffer() throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Queried for a buffer after channel has been closed.\");\n-\t\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tfinal Buffer next;\n-\t\tfinal boolean moreAvailable;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tnext = receivedBuffers.poll();\n-\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n-\t\t}\n-\n-\t\tnumBytesIn.inc(next.getSize());\n-\t\tnumBuffersIn.inc();\n-\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable));\n-\t}\n-\n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlastRequestedCheckpointId = checkpointId;\n-\n-\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\tcheckpointId,\n-\t\t\t\tchannelInfo,\n-\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tvoid sendTaskEvent(TaskEvent event) throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Tried to send task event to producer after channel has been released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tpartitionRequestClient.sendTaskEvent(partitionId, event, this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n-\t}\n-\n-\t/**\n-\t * Releases all exclusive and floating buffers, closes the partition request client.\n-\t */\n-\t@Override\n-\tvoid releaseAllResources() throws IOException {\n-\t\tif (isReleased.compareAndSet(false, true)) {\n-\n-\t\t\tArrayDeque<Buffer> releasedBuffers;\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\treleasedBuffers = receivedBuffers;\n-\t\t\t}\n-\t\t\tbufferManager.releaseAllBuffers(releasedBuffers);\n-\n-\t\t\t// The released flag has to be set before closing the connection to ensure that\n-\t\t\t// buffers received concurrently with closing are properly recycled.\n-\t\t\tif (partitionRequestClient != null) {\n-\t\t\t\tpartitionRequestClient.close(this);\n-\t\t\t} else {\n-\t\t\t\tconnectionManager.closeOpenChannelConnections(connectionId);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void failPartitionRequest() {\n-\t\tsetError(new PartitionNotFoundException(partitionId));\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Credit-based\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n-\t */\n-\tprivate void notifyCreditAvailable() {\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tpartitionRequestClient.notifyCreditAvailable(this);\n-\t}\n-\n-\tpublic int getNumberOfAvailableBuffers() {\n-\t\treturn bufferManager.getNumberOfAvailableBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn bufferManager.getNumberOfRequiredBuffers();\n-\t}\n-\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\treturn bufferManager.isWaitingForFloatingBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n-\t}\n-\n-\t@VisibleForTesting\n-\tBufferManager getBufferManager() {\n-\t\treturn bufferManager;\n-\t}\n-\n-\t@VisibleForTesting\n-\tPartitionRequestClient getPartitionRequestClient() {\n-\t\treturn partitionRequestClient;\n-\t}\n-\n-\t/**\n-\t * The unannounced credit is increased by the given amount and might notify\n-\t * increased credit to the producer.\n-\t */\n-\t@Override\n-\tpublic void notifyBufferAvailable(int numAvailableBuffers) {\n-\t\tif (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tbufferManager.releaseFloatingBuffers(true);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption() {\n-\t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n-\n-\t\t// notifies the producer that this channel is ready to\n-\t\t// unblock from checkpoint and resume data consumption\n-\t\tpartitionRequestClient.resumeConsumption(this);\n-\t}\n-\n-\t/**\n-\t * Called by netty thread to request buffers and generate {@link ResumeConsumption} message.\n-\t */\n-\tpublic ResumeConsumption getResumeConsumptionMessage() throws IOException {\n-\t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n-\t\tcheckState(getNumberOfAvailableBuffers() == initialCredit, \"Illegal number of available buffers.\");\n-\t\tcheckState(isWaitingForFloatingBuffers(), \"Should not be waiting for floating buffers.\");\n-\n-\t\tif (initialCredit > 0) {\n-\t\t\treturn new ResumeConsumption(id, initialCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t\t}\n-\n-\t\tint availableCredit = bufferManager.requestFloatingBuffers(0);\n-\t\treturn new ResumeConsumption(id, availableCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network I/O notifications (called by network I/O thread)\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Gets the currently unannounced credit.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getUnannouncedCredit() {\n-\t\treturn unannouncedCredit.get();\n-\t}\n-\n-\t/**\n-\t * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n-\t}\n-\n-\t/**\n-\t * Gets the current number of received buffers which have not been processed yet.\n-\t *\n-\t * @return Buffers queued for processing.\n-\t */\n-\tpublic int getNumberOfQueuedBuffers() {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treturn receivedBuffers.size();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn Math.max(0, receivedBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferManager.unsynchronizedGetExclusiveBuffers());\n-\t}\n-\n-\tpublic int unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n-\t}\n-\n-\tpublic InputChannelID getInputChannelId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic int getInitialCredit() {\n-\t\treturn initialCredit;\n-\t}\n-\n-\tpublic BufferProvider getBufferProvider() throws IOException {\n-\t\tif (isReleased.get()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn inputGate.getBufferProvider();\n-\t}\n-\n-\t/**\n-\t * Requests buffer from input channel directly for receiving network data.\n-\t * It should always return an available buffer in credit-based mode unless\n-\t * the channel has been released.\n-\t *\n-\t * @return The available buffer.\n-\t */\n-\t@Nullable\n-\tpublic Buffer requestBuffer() {\n-\t\treturn bufferManager.requestBuffer();\n-\t}\n-\n-\t/**\n-\t * Receives the backlog from the producer's buffer response. If the number of available\n-\t * buffers is less than backlog + initialCredit, it will request floating buffers from\n-\t * the buffer manager, and then notify unannounced credits to the producer.\n-\t *\n-\t * @param backlog The number of unsent buffers in the producer's sub partition.\n-\t */\n-\tpublic void onSenderBacklog(int backlog) throws IOException {\n-\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));\n-\t}\n-\n-\tpublic void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean recycleBuffer = true;\n-\n-\t\ttry {\n-\t\t\tif (expectedSequenceNumber != sequenceNumber) {\n-\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tfinal boolean wasEmpty;\n-\t\t\tfinal CheckpointBarrier notifyReceivedBarrier;\n-\t\t\tfinal Buffer notifyReceivedBuffer;\n-\t\t\tfinal CheckpointBarrier barrier;\n-\t\t\tfinal BufferReceivedListener listener = inputGate.getBufferReceivedListener();\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after releaseAllResources() released all buffers from receivedBuffers\n-\t\t\t\t// (see above for details).\n-\t\t\t\tif (isReleased.get()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n-\n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n-\t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n-\t\t\t\tbarrier = listener != null ? notifyReceivedBarrier : parseCheckpointBarrierOrNull(buffer);\n-\t\t\t}\n-\t\t\trecycleBuffer = false;\n-\n-\t\t\t++expectedSequenceNumber;\n-\n-\t\t\tif (wasEmpty) {\n-\t\t\t\tnotifyChannelNonEmpty();\n-\t\t\t}\n-\n-\t\t\tif (backlog >= 0) {\n-\t\t\t\tonSenderBacklog(backlog);\n-\t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n-\n-\t\t\tif (barrier != null) {\n-\t\t\t\tonCheckpointBarrier(barrier);\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tif (recycleBuffer) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean success = false;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tif (!isReleased.get()) {\n-\t\t\t\tif (expectedSequenceNumber == sequenceNumber) {\n-\t\t\t\t\texpectedSequenceNumber++;\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t} else {\n-\t\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (success && backlog >= 0) {\n-\t\t\tonSenderBacklog(backlog);\n-\t\t}\n-\t}\n-\n-\tpublic void onFailedPartitionRequest() {\n-\t\tinputGate.triggerPartitionStateCheck(partitionId);\n-\t}\n-\n-\tpublic void onError(Throwable cause) {\n-\t\tsetError(cause);\n-\t}\n-\n-\tprivate static class BufferReorderingException extends IOException {\n-\n-\t\tprivate static final long serialVersionUID = -888282210356266816L;\n-\n-\t\tprivate final int expectedSequenceNumber;\n-\n-\t\tprivate final int actualSequenceNumber;\n-\n-\t\tBufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n-\t\t\tthis.expectedSequenceNumber = expectedSequenceNumber;\n-\t\t\tthis.actualSequenceNumber = actualSequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String getMessage() {\n-\t\t\treturn String.format(\"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n-\t\t\t\texpectedSequenceNumber, actualSequenceNumber);\n-\t\t}\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(RemoteInputChannel.class);\n+\n+    private static final int NONE = -1;\n+\n+    /** ID to distinguish this channel from other channels sharing the same TCP connection. */\n+    private final InputChannelID id = new InputChannelID();\n+\n+    /** The connection to use to request the remote partition. */\n+    private final ConnectionID connectionId;\n+\n+    /** The connection manager to use connect to the remote partition provider. */\n+    private final ConnectionManager connectionManager;\n+\n+    /**\n+     * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n+     * is consumed by the receiving task thread.\n+     */\n+    private final PrioritizedDeque<SequenceBuffer> receivedBuffers = new PrioritizedDeque<>();\n+\n+    /**\n+     * Flag indicating whether this channel has been released. Either called by the receiving task\n+     * thread or the task manager actor.\n+     */\n+    private final AtomicBoolean isReleased = new AtomicBoolean();\n+\n+    /** Client to establish a (possibly shared) TCP connection and request the partition. */\n+    private volatile PartitionRequestClient partitionRequestClient;\n+\n+    /** The next expected sequence number for the next buffer. */\n+    private int expectedSequenceNumber = 0;\n+\n+    /** The initial number of exclusive buffers assigned to this channel. */\n+    private final int initialCredit;\n+\n+    /** The number of available buffers that have not been announced to the producer yet. */\n+    private final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n+\n+    private final BufferManager bufferManager;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private int lastBarrierSequenceNumber = NONE;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private long lastBarrierId = NONE;\n+\n+    private final ChannelStatePersister channelStatePersister;\n+\n+    private boolean isUpstreamBlocked;\n+\n+    public RemoteInputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            ConnectionID connectionId,\n+            ConnectionManager connectionManager,\n+            int initialBackOff,\n+            int maxBackoff,\n+            int networkBuffersPerChannel,\n+            Counter numBytesIn,\n+            Counter numBuffersIn,\n+            ChannelStateWriter stateWriter) {\n+\n+        super(\n+                inputGate,\n+                channelIndex,\n+                partitionId,\n+                initialBackOff,\n+                maxBackoff,\n+                numBytesIn,\n+                numBuffersIn);\n+        checkArgument(networkBuffersPerChannel >= 0, \"Must be non-negative.\");\n+\n+        this.initialCredit = networkBuffersPerChannel;\n+        this.connectionId = checkNotNull(connectionId);\n+        this.connectionManager = checkNotNull(connectionManager);\n+        this.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n+        this.channelStatePersister = new ChannelStatePersister(stateWriter, getChannelInfo());\n+    }\n+\n+    @VisibleForTesting\n+    void setExpectedSequenceNumber(int expectedSequenceNumber) {\n+        this.expectedSequenceNumber = expectedSequenceNumber;\n+    }\n+\n+    /**\n+     * Setup includes assigning exclusive buffers to this input channel, and this method should be\n+     * called only once after this input channel is created.\n+     */\n+    @Override\n+    void setup() throws IOException {\n+        checkState(\n+                bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+                \"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n+\n+        bufferManager.requestExclusiveBuffers(initialCredit);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /** Requests a remote subpartition. */\n+    @VisibleForTesting\n+    @Override\n+    public void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException {\n+        if (partitionRequestClient == null) {\n+            LOG.debug(\n+                    \"{}: Requesting REMOTE subpartition {} of partition {}. {}\",\n+                    this,\n+                    subpartitionIndex,\n+                    partitionId,\n+                    channelStatePersister);\n+            // Create a client and request the partition\n+            try {\n+                partitionRequestClient =\n+                        connectionManager.createPartitionRequestClient(connectionId);\n+            } catch (IOException e) {\n+                // IOExceptions indicate that we could not open a connection to the remote\n+                // TaskExecutor\n+                throw new PartitionConnectionException(partitionId, e);\n+            }\n+\n+            partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n+        }\n+    }\n+\n+    /** Retriggers a remote subpartition request. */\n+    void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (increaseBackoff()) {\n+            partitionRequestClient.requestSubpartition(\n+                    partitionId, subpartitionIndex, this, getCurrentBackoff());\n+        } else {\n+            failPartitionRequest();\n+        }\n+    }\n+\n+    @Override\n+    Optional<BufferAndAvailability> getNextBuffer() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        final SequenceBuffer next;\n+        final DataType nextDataType;\n+\n+        synchronized (receivedBuffers) {\n+            next = receivedBuffers.poll();\n+            nextDataType =\n+                    receivedBuffers.peek() != null\n+                            ? receivedBuffers.peek().buffer.getDataType()\n+                            : DataType.NONE;\n+        }\n+\n+        if (next == null) {\n+            if (isReleased.get()) {\n+                throw new CancelTaskException(\n+                        \"Queried for a buffer after channel has been released.\");\n+            }\n+            return Optional.empty();\n+        }\n+\n+        numBytesIn.inc(next.buffer.getSize());\n+        numBuffersIn.inc();\n+        return Optional.of(\n+                new BufferAndAvailability(next.buffer, nextDataType, 0, next.sequenceNumber));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    void sendTaskEvent(TaskEvent event) throws IOException {\n+        checkState(\n+                !isReleased.get(),\n+                \"Tried to send task event to producer after channel has been released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.sendTaskEvent(partitionId, event, this);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased.get();\n+    }\n+\n+    /** Releases all exclusive and floating buffers, closes the partition request client. */\n+    @Override\n+    void releaseAllResources() throws IOException {\n+        if (isReleased.compareAndSet(false, true)) {\n+\n+            final ArrayDeque<Buffer> releasedBuffers;\n+            synchronized (receivedBuffers) {\n+                releasedBuffers =\n+                        receivedBuffers.stream()\n+                                .map(sb -> sb.buffer)\n+                                .collect(Collectors.toCollection(ArrayDeque::new));\n+                receivedBuffers.clear();\n+            }\n+            bufferManager.releaseAllBuffers(releasedBuffers);\n+\n+            // The released flag has to be set before closing the connection to ensure that\n+            // buffers received concurrently with closing are properly recycled.\n+            if (partitionRequestClient != null) {\n+                partitionRequestClient.close(this);\n+            } else {\n+                connectionManager.closeOpenChannelConnections(connectionId);\n+            }\n+        }\n+    }\n+\n+    private void failPartitionRequest() {\n+        setError(new PartitionNotFoundException(partitionId));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Credit-based\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n+     */\n+    private void notifyCreditAvailable() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.notifyCreditAvailable(this);\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfAvailableBuffers() {\n+        return bufferManager.getNumberOfAvailableBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfRequiredBuffers() {\n+        return bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getSenderBacklog() {\n+        return getNumberOfRequiredBuffers() - initialCredit;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isWaitingForFloatingBuffers() {\n+        return bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public Buffer getNextReceivedBuffer() {\n+        final SequenceBuffer sequenceBuffer = receivedBuffers.poll();\n+        return sequenceBuffer != null ? sequenceBuffer.buffer : null;\n+    }\n+\n+    @VisibleForTesting\n+    BufferManager getBufferManager() {\n+        return bufferManager;\n+    }\n+\n+    @VisibleForTesting\n+    PartitionRequestClient getPartitionRequestClient() {\n+        return partitionRequestClient;\n+    }\n+\n+    /**\n+     * The unannounced credit is increased by the given amount and might notify increased credit to\n+     * the producer.\n+     */\n+    @Override\n+    public void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n+        if (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+            notifyCreditAvailable();\n+        }\n+    }\n+\n+    @Override\n+    public void resumeConsumption() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        // notifies the producer that this channel is ready to\n+        // unblock from checkpoint and resume data consumption\n+        partitionRequestClient.resumeConsumption(this);\n+    }\n+\n+    private void onBlockingUpstream() {\n+        isUpstreamBlocked = true;\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    public void onConsumptionResumed() {\n+        isUpstreamBlocked = false;\n+        if (initialCredit == 0) {\n+            unannouncedCredit.set(0);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network I/O notifications (called by network I/O thread)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the currently unannounced credit.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getUnannouncedCredit() {\n+        return unannouncedCredit.get();\n+    }\n+\n+    /**\n+     * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getAndResetUnannouncedCredit() {\n+        return unannouncedCredit.getAndSet(0);\n+    }\n+\n+    /**\n+     * Gets the current number of received buffers which have not been processed yet.\n+     *\n+     * @return Buffers queued for processing.\n+     */\n+    public int getNumberOfQueuedBuffers() {\n+        synchronized (receivedBuffers) {\n+            return receivedBuffers.size();\n+        }\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return Math.max(0, receivedBuffers.size());\n+    }\n+\n+    public int unsynchronizedGetExclusiveBuffersUsed() {\n+        return Math.max(\n+                0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n+    }\n+\n+    public int unsynchronizedGetFloatingBuffersAvailable() {\n+        return Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n+    }\n+\n+    public InputChannelID getInputChannelId() {\n+        return id;\n+    }\n+\n+    public int getInitialCredit() {\n+        return initialCredit;\n+    }\n+\n+    public BufferProvider getBufferProvider() throws IOException {\n+        if (isReleased.get()) {\n+            return null;\n+        }\n+\n+        return inputGate.getBufferProvider();\n+    }\n+\n+    /**\n+     * Requests buffer from input channel directly for receiving network data. It should always\n+     * return an available buffer in credit-based mode unless the channel has been released.\n+     *\n+     * @return The available buffer.\n+     */\n+    @Nullable\n+    public Buffer requestBuffer() {\n+        return bufferManager.requestBuffer(initialCredit);\n+    }\n+\n+    /**\n+     * Receives the backlog from the producer's buffer response. If the number of available buffers\n+     * is less than backlog + initialCredit, it will request floating buffers from the buffer\n+     * manager, and then notify unannounced credits to the producer.\n+     *\n+     * @param backlog The number of unsent buffers in the producer's sub partition.\n+     */\n+    public void onSenderBacklog(int backlog) throws IOException {\n+        // never allocate any new buffers if upstream has been blocked\n+        if (!isUpstreamBlocked) {\n+            notifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+        }\n+    }\n+\n+    public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n+        boolean recycleBuffer = true;\n+\n+        try {\n+            if (expectedSequenceNumber != sequenceNumber) {\n+                onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                return;\n+            }\n+\n+            final boolean wasEmpty;\n+            boolean firstPriorityEvent = false;\n+            synchronized (receivedBuffers) {\n+                NetworkActionsLogger.traceInput(\n+                        \"RemoteInputChannel#onBuffer\",\n+                        buffer,\n+                        inputGate.getOwningTaskName(),\n+                        channelInfo,\n+                        channelStatePersister,\n+                        sequenceNumber);\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after releaseAllResources() released all buffers from receivedBuffers\n+                // (see above for details).\n+                if (isReleased.get()) {\n+                    return;\n+                }\n+\n+                wasEmpty = receivedBuffers.isEmpty();\n+\n+                SequenceBuffer sequenceBuffer = new SequenceBuffer(buffer, sequenceNumber);\n+                DataType dataType = buffer.getDataType();\n+                if (dataType.hasPriority()) {\n+                    firstPriorityEvent = addPriorityBuffer(sequenceBuffer);\n+                } else {\n+                    receivedBuffers.add(sequenceBuffer);\n+                    if (dataType.requiresAnnouncement()) {\n+                        firstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n+                    }\n+                }\n+                channelStatePersister\n+                        .checkForBarrier(sequenceBuffer.buffer)\n+                        .filter(id -> id > lastBarrierId)\n+                        .ifPresent(\n+                                id -> {\n+                                    // checkpoint was not yet started by task thread,\n+                                    // so remember the numbers of buffers to spill for the time when\n+                                    // it will be started\n+                                    lastBarrierId = id;\n+                                    lastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+                                });\n+                channelStatePersister.maybePersist(buffer);\n+                ++expectedSequenceNumber;\n+            }\n+            recycleBuffer = false;\n+\n+            if (firstPriorityEvent) {\n+                notifyPriorityEvent(sequenceNumber);\n+            }\n+            if (wasEmpty) {\n+                notifyChannelNonEmpty();\n+            }\n+\n+            if (backlog >= 0) {\n+                onSenderBacklog(backlog);\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+            }\n+        } finally {\n+            if (recycleBuffer) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+    }\n+\n+    /** @return {@code true} if this was first priority buffer added. */\n+    private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) {\n+        receivedBuffers.addPriorityElement(sequenceBuffer);\n+        return receivedBuffers.getNumPriorityElements() == 1;\n+    }\n+\n+    private SequenceBuffer announce(SequenceBuffer sequenceBuffer) throws IOException {\n+        checkState(\n+                !sequenceBuffer.buffer.isBuffer(),\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        checkAnnouncedOnlyOnce(sequenceBuffer);\n+        AbstractEvent event =\n+                EventSerializer.fromBuffer(sequenceBuffer.buffer, getClass().getClassLoader());\n+        checkState(\n+                event instanceof CheckpointBarrier,\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        CheckpointBarrier barrier = (CheckpointBarrier) event;\n+        return new SequenceBuffer(\n+                EventSerializer.toBuffer(\n+                        new EventAnnouncement(barrier, sequenceBuffer.sequenceNumber), true),\n+                sequenceBuffer.sequenceNumber);\n+    }\n+\n+    private void checkAnnouncedOnlyOnce(SequenceBuffer sequenceBuffer) {\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        int count = 0;\n+        while (iterator.hasNext()) {\n+            if (iterator.next().sequenceNumber == sequenceBuffer.sequenceNumber) {\n+                count++;\n+            }\n+        }\n+        checkState(\n+                count == 1,\n+                \"Before enqueuing the announcement there should be exactly single occurrence of the buffer, but found [%d]\",\n+                count);\n+    }\n+\n+    /**\n+     * Spills all queued buffers on checkpoint start. If barrier has already been received (and\n+     * reordered), spill only the overtaken buffers.\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {\n+        synchronized (receivedBuffers) {\n+            if (barrier.getId() < lastBarrierId) {\n+                throw new CheckpointException(\n+                        String.format(\n+                                \"Sequence number for checkpoint %d is not known (it was likely been overwritten by a newer checkpoint %d)\",\n+                                barrier.getId(), lastBarrierId),\n+                        CheckpointFailureReason\n+                                .CHECKPOINT_SUBSUMED); // currently, at most one active unaligned\n+                // checkpoint is possible\n+            } else if (barrier.getId() > lastBarrierId) {\n+                // This channel has received some obsolete barrier, older compared to the\n+                // checkpointId\n+                // which we are processing right now, and we should ignore that obsoleted checkpoint\n+                // barrier sequence number.\n+                resetLastBarrier();\n+            }\n+\n+            channelStatePersister.startPersisting(\n+                    barrier.getId(), getInflightBuffersUnsafe(barrier.getId()));\n+        }\n+    }\n+\n+    public void checkpointStopped(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            channelStatePersister.stopPersisting(checkpointId);\n+            if (lastBarrierId == checkpointId) {\n+                resetLastBarrier();\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    List<Buffer> getInflightBuffers(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            return getInflightBuffersUnsafe(checkpointId);\n+        }\n+    }\n+\n+    @Override\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n+        boolean firstPriorityEvent;\n+        synchronized (receivedBuffers) {\n+            checkState(channelStatePersister.hasBarrierReceived());\n+            int numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n+            SequenceBuffer toPrioritize =\n+                    receivedBuffers.getAndRemove(\n+                            sequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n+            checkState(lastBarrierSequenceNumber == sequenceNumber);\n+            checkState(!toPrioritize.buffer.isBuffer());\n+            checkState(\n+                    numPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n+                    \"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n+                    toPrioritize,\n+                    numPriorityElementsBeforeRemoval);\n+            // set the priority flag (checked on poll)\n+            // don't convert the barrier itself (barrier controller might not have been switched\n+            // yet)\n+            AbstractEvent e =\n+                    EventSerializer.fromBuffer(\n+                            toPrioritize.buffer, this.getClass().getClassLoader());\n+            toPrioritize.buffer.setReaderIndex(0);\n+            toPrioritize =\n+                    new SequenceBuffer(\n+                            EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n+            firstPriorityEvent =\n+                    addPriorityBuffer(\n+                            toPrioritize); // note that only position of the element is changed\n+            // converting the event itself would require switching the controller sooner\n+        }\n+        if (firstPriorityEvent) {\n+            notifyPriorityEventForce(); // forcibly notify about the priority event\n+            // instead of passing barrier SQN to be checked\n+            // because this SQN might have be seen by the input gate during the announcement\n+        }\n+    }\n+\n+    private void notifyPriorityEventForce() {\n+        inputGate.notifyPriorityEventForce(this);\n+    }\n+\n+    /**\n+     * Returns a list of buffers, checking the first n non-priority buffers, and skipping all\n+     * events.\n+     */\n+    private List<Buffer> getInflightBuffersUnsafe(long checkpointId) {\n+        assert Thread.holdsLock(receivedBuffers);\n+\n+        checkState(checkpointId == lastBarrierId || lastBarrierId == NONE);\n+\n+        final List<Buffer> inflightBuffers = new ArrayList<>();\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        // skip all priority events (only buffers are stored anyways)\n+        Iterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n+\n+        while (iterator.hasNext()) {\n+            SequenceBuffer sequenceBuffer = iterator.next();\n+            if (sequenceBuffer.buffer.isBuffer()) {\n+                if (shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+                    inflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return inflightBuffers;\n+    }\n+\n+    private void resetLastBarrier() {\n+        lastBarrierId = NONE;\n+        lastBarrierSequenceNumber = NONE;\n+    }\n+\n+    /**\n+     * @return if given {@param sequenceNumber} should be spilled given {@link\n+     *     #lastBarrierSequenceNumber}. We might not have yet received {@link CheckpointBarrier} and\n+     *     we might need to spill everything. If we have already received it, there is a bit nasty\n+     *     corner case of {@link SequenceBuffer#sequenceNumber} overflowing that needs to be handled\n+     *     as well.\n+     */\n+    private boolean shouldBeSpilled(int sequenceNumber) {\n+        if (lastBarrierSequenceNumber == NONE) {\n+            return true;\n+        }\n+        checkState(\n+                receivedBuffers.size() < Integer.MAX_VALUE / 2,\n+                \"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+        boolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastBarrierSequenceNumber;\n+        boolean possibleOverflowBeforeOvertaking =\n+                lastBarrierSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+        if (possibleOverflowAfterOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber && sequenceNumber > 0;\n+        } else if (possibleOverflowBeforeOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber || sequenceNumber > 0;\n+        } else {\n+            return sequenceNumber < lastBarrierSequenceNumber;\n+        }\n+    }\n+\n+    public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n+        boolean success = false;\n+\n+        synchronized (receivedBuffers) {\n+            if (!isReleased.get()) {\n+                if (expectedSequenceNumber == sequenceNumber) {\n+                    expectedSequenceNumber++;\n+                    success = true;\n+                } else {\n+                    onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                }\n+            }\n+        }\n+\n+        if (success && backlog >= 0) {\n+            onSenderBacklog(backlog);\n+        }\n+    }\n+\n+    public void onFailedPartitionRequest() {\n+        inputGate.triggerPartitionStateCheck(partitionId);\n+    }\n+\n+    public void onError(Throwable cause) {\n+        setError(cause);\n+    }\n+\n+    private void checkPartitionRequestQueueInitialized() throws IOException {\n+        checkError();\n+        checkState(\n+                partitionRequestClient != null,\n+                \"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n+    }\n+\n+    private static class BufferReorderingException extends IOException {\n+\n+        private static final long serialVersionUID = -888282210356266816L;\n+\n+        private final int expectedSequenceNumber;\n+\n+        private final int actualSequenceNumber;\n+\n+        BufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n+            this.expectedSequenceNumber = expectedSequenceNumber;\n+            this.actualSequenceNumber = actualSequenceNumber;\n+        }\n+\n+        @Override\n+        public String getMessage() {\n+            return String.format(\n+                    \"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n+                    expectedSequenceNumber, actualSequenceNumber);\n+        }\n+    }\n+\n+    private static final class SequenceBuffer {\n+        final Buffer buffer;\n+        final int sequenceNumber;\n+\n+        private SequenceBuffer(Buffer buffer, int sequenceNumber) {\n+            this.buffer = buffer;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\n+                    \"SequenceBuffer(isEvent = %s, dataType = %s, sequenceNumber = %s)\",\n+                    !buffer.isBuffer(), buffer.getDataType(), sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 2cbd3801b56..f9cedf71105 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -20,520 +20,798 @@ package org.apache.flink.runtime.io.network.partition.consumer;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.checkpoint.CheckpointException;\n+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;\n import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;\n+import org.apache.flink.runtime.event.AbstractEvent;\n import org.apache.flink.runtime.event.TaskEvent;\n+import org.apache.flink.runtime.execution.CancelTaskException;\n import org.apache.flink.runtime.io.network.ConnectionID;\n import org.apache.flink.runtime.io.network.ConnectionManager;\n import org.apache.flink.runtime.io.network.PartitionRequestClient;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+import org.apache.flink.runtime.io.network.api.EventAnnouncement;\n+import org.apache.flink.runtime.io.network.api.serialization.EventSerializer;\n import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.Buffer.DataType;\n import org.apache.flink.runtime.io.network.buffer.BufferProvider;\n-import org.apache.flink.runtime.io.network.buffer.BufferReceivedListener;\n-import org.apache.flink.runtime.io.network.netty.NettyMessage;\n+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;\n import org.apache.flink.runtime.io.network.partition.PartitionNotFoundException;\n+import org.apache.flink.runtime.io.network.partition.PrioritizedDeque;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n \n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterators;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n-/**\n- * An input channel, which requests a remote partition queue.\n- */\n+/** An input channel, which requests a remote partition queue. */\n public class RemoteInputChannel extends InputChannel {\n-\n-\t/** ID to distinguish this channel from other channels sharing the same TCP connection. */\n-\tprivate final InputChannelID id = new InputChannelID();\n-\n-\t/** The connection to use to request the remote partition. */\n-\tprivate final ConnectionID connectionId;\n-\n-\t/** The connection manager to use connect to the remote partition provider. */\n-\tprivate final ConnectionManager connectionManager;\n-\n-\t/**\n-\t * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n-\t * is consumed by the receiving task thread.\n-\t */\n-\tprivate final ArrayDeque<Buffer> receivedBuffers = new ArrayDeque<>();\n-\n-\t/**\n-\t * Flag indicating whether this channel has been released. Either called by the receiving task\n-\t * thread or the task manager actor.\n-\t */\n-\tprivate final AtomicBoolean isReleased = new AtomicBoolean();\n-\n-\t/** Client to establish a (possibly shared) TCP connection and request the partition. */\n-\tprivate volatile PartitionRequestClient partitionRequestClient;\n-\n-\t/**\n-\t * The next expected sequence number for the next buffer. This is modified by the network\n-\t * I/O thread only.\n-\t */\n-\tprivate int expectedSequenceNumber = 0;\n-\n-\t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate final int initialCredit;\n-\n-\t/** The number of available buffers that have not been announced to the producer yet. */\n-\tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n-\n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n-\n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n-\n-\tprivate final BufferManager bufferManager;\n-\n-\tpublic RemoteInputChannel(\n-\t\tSingleInputGate inputGate,\n-\t\tint channelIndex,\n-\t\tResultPartitionID partitionId,\n-\t\tConnectionID connectionId,\n-\t\tConnectionManager connectionManager,\n-\t\tint initialBackOff,\n-\t\tint maxBackoff,\n-\t\tint networkBuffersPerChannel,\n-\t\tCounter numBytesIn,\n-\t\tCounter numBuffersIn) {\n-\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, numBytesIn, numBuffersIn);\n-\n-\t\tthis.initialCredit = networkBuffersPerChannel;\n-\t\tthis.connectionId = checkNotNull(connectionId);\n-\t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n-\t}\n-\n-\t/**\n-\t * Assigns exclusive buffers to this input channel, and this method should be called only once\n-\t * after this input channel is created.\n-\t */\n-\tvoid assignExclusiveSegments() throws IOException {\n-\t\tbufferManager.requestExclusiveBuffers();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests a remote subpartition.\n-\t */\n-\t@VisibleForTesting\n-\t@Override\n-\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n-\t\tif (partitionRequestClient == null) {\n-\t\t\t// Create a client and request the partition\n-\t\t\ttry {\n-\t\t\t\tpartitionRequestClient = connectionManager.createPartitionRequestClient(connectionId);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\t// IOExceptions indicate that we could not open a connection to the remote TaskExecutor\n-\t\t\t\tthrow new PartitionConnectionException(partitionId, e);\n-\t\t\t}\n-\n-\t\t\tpartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Retriggers a remote subpartition request.\n-\t */\n-\tvoid retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n-\t\tcheckState(partitionRequestClient != null, \"Missing initial subpartition request.\");\n-\n-\t\tif (increaseBackoff()) {\n-\t\t\tpartitionRequestClient.requestSubpartition(\n-\t\t\t\tpartitionId, subpartitionIndex, this, getCurrentBackoff());\n-\t\t} else {\n-\t\t\tfailPartitionRequest();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tOptional<BufferAndAvailability> getNextBuffer() throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Queried for a buffer after channel has been closed.\");\n-\t\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tfinal Buffer next;\n-\t\tfinal boolean moreAvailable;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tnext = receivedBuffers.poll();\n-\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n-\t\t}\n-\n-\t\tnumBytesIn.inc(next.getSize());\n-\t\tnumBuffersIn.inc();\n-\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable));\n-\t}\n-\n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlastRequestedCheckpointId = checkpointId;\n-\n-\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\tcheckpointId,\n-\t\t\t\tchannelInfo,\n-\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tvoid sendTaskEvent(TaskEvent event) throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Tried to send task event to producer after channel has been released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tpartitionRequestClient.sendTaskEvent(partitionId, event, this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n-\t}\n-\n-\t/**\n-\t * Releases all exclusive and floating buffers, closes the partition request client.\n-\t */\n-\t@Override\n-\tvoid releaseAllResources() throws IOException {\n-\t\tif (isReleased.compareAndSet(false, true)) {\n-\n-\t\t\tArrayDeque<Buffer> releasedBuffers;\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\treleasedBuffers = receivedBuffers;\n-\t\t\t}\n-\t\t\tbufferManager.releaseAllBuffers(releasedBuffers);\n-\n-\t\t\t// The released flag has to be set before closing the connection to ensure that\n-\t\t\t// buffers received concurrently with closing are properly recycled.\n-\t\t\tif (partitionRequestClient != null) {\n-\t\t\t\tpartitionRequestClient.close(this);\n-\t\t\t} else {\n-\t\t\t\tconnectionManager.closeOpenChannelConnections(connectionId);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void failPartitionRequest() {\n-\t\tsetError(new PartitionNotFoundException(partitionId));\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Credit-based\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n-\t */\n-\tprivate void notifyCreditAvailable() {\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tpartitionRequestClient.notifyCreditAvailable(this);\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfAvailableBuffers() {\n-\t\treturn bufferManager.getNumberOfAvailableBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\treturn bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n-\t}\n-\n-\t@VisibleForTesting\n-\tBufferManager getBufferManager() {\n-\t\treturn bufferManager;\n-\t}\n-\n-\t@VisibleForTesting\n-\tPartitionRequestClient getPartitionRequestClient() {\n-\t\treturn partitionRequestClient;\n-\t}\n-\n-\t/**\n-\t * The unannounced credit is increased by the given amount and might notify\n-\t * increased credit to the producer.\n-\t */\n-\t@Override\n-\tpublic void notifyBufferAvailable(int numAvailableBuffers) {\n-\t\tif (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tbufferManager.onCheckpointBarrier(barrier, initialCredit);\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption() {\n-\t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n-\n-\t\t// notifies the producer that this channel is ready to\n-\t\t// unblock from checkpoint and resume data consumption\n-\t\tpartitionRequestClient.resumeConsumption(this);\n-\t}\n-\n-\t/**\n-\t * Called by netty thread to request buffers and generate {@link NettyMessage.ResumeConsumption} message.\n-\t */\n-\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage() throws IOException {\n-\t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n-\n-\t\treturn bufferManager.resumeAndGetResumptionMessage(id, initialCredit);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network I/O notifications (called by network I/O thread)\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Gets the currently unannounced credit.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getUnannouncedCredit() {\n-\t\treturn unannouncedCredit.get();\n-\t}\n-\n-\t/**\n-\t * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n-\t}\n-\n-\t/**\n-\t * Gets the current number of received buffers which have not been processed yet.\n-\t *\n-\t * @return Buffers queued for processing.\n-\t */\n-\tpublic int getNumberOfQueuedBuffers() {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treturn receivedBuffers.size();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn Math.max(0, receivedBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferManager.unsynchronizedGetExclusiveBuffersUsed());\n-\t}\n-\n-\tpublic int unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n-\t}\n-\n-\tpublic InputChannelID getInputChannelId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic int getInitialCredit() {\n-\t\treturn initialCredit;\n-\t}\n-\n-\tpublic BufferProvider getBufferProvider() throws IOException {\n-\t\tif (isReleased.get()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn inputGate.getBufferProvider();\n-\t}\n-\n-\t/**\n-\t * Requests buffer from input channel directly for receiving network data.\n-\t * It should always return an available buffer in credit-based mode unless\n-\t * the channel has been released.\n-\t *\n-\t * @return The available buffer.\n-\t */\n-\t@Nullable\n-\tpublic Buffer requestBuffer() {\n-\t\treturn bufferManager.requestBuffer();\n-\t}\n-\n-\t/**\n-\t * Receives the backlog from the producer's buffer response. If the number of available\n-\t * buffers is less than backlog + initialCredit, it will request floating buffers from\n-\t * the buffer manager, and then notify unannounced credits to the producer.\n-\t *\n-\t * @param backlog The number of unsent buffers in the producer's sub partition.\n-\t */\n-\tpublic void onSenderBacklog(int backlog) throws IOException {\n-\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));\n-\t}\n-\n-\tpublic void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean recycleBuffer = true;\n-\n-\t\ttry {\n-\t\t\tif (expectedSequenceNumber != sequenceNumber) {\n-\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tfinal boolean wasEmpty;\n-\t\t\tfinal CheckpointBarrier notifyReceivedBarrier;\n-\t\t\tfinal Buffer notifyReceivedBuffer;\n-\t\t\tfinal BufferReceivedListener listener = inputGate.getBufferReceivedListener();\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after releaseAllResources() released all buffers from receivedBuffers\n-\t\t\t\t// (see above for details).\n-\t\t\t\tif (isReleased.get()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n-\n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n-\t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n-\t\t\t}\n-\t\t\trecycleBuffer = false;\n-\n-\t\t\t++expectedSequenceNumber;\n-\n-\t\t\tif (wasEmpty) {\n-\t\t\t\tnotifyChannelNonEmpty();\n-\t\t\t}\n-\n-\t\t\tif (backlog >= 0) {\n-\t\t\t\tonSenderBacklog(backlog);\n-\t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n-\n-\t\t\tCheckpointBarrier barrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\tif (barrier != null) {\n-\t\t\t\tonCheckpointBarrier(barrier);\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tif (recycleBuffer) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean success = false;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tif (!isReleased.get()) {\n-\t\t\t\tif (expectedSequenceNumber == sequenceNumber) {\n-\t\t\t\t\texpectedSequenceNumber++;\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t} else {\n-\t\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (success && backlog >= 0) {\n-\t\t\tonSenderBacklog(backlog);\n-\t\t}\n-\t}\n-\n-\tpublic void onFailedPartitionRequest() {\n-\t\tinputGate.triggerPartitionStateCheck(partitionId);\n-\t}\n-\n-\tpublic void onError(Throwable cause) {\n-\t\tsetError(cause);\n-\t}\n-\n-\tprivate static class BufferReorderingException extends IOException {\n-\n-\t\tprivate static final long serialVersionUID = -888282210356266816L;\n-\n-\t\tprivate final int expectedSequenceNumber;\n-\n-\t\tprivate final int actualSequenceNumber;\n-\n-\t\tBufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n-\t\t\tthis.expectedSequenceNumber = expectedSequenceNumber;\n-\t\t\tthis.actualSequenceNumber = actualSequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String getMessage() {\n-\t\t\treturn String.format(\"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n-\t\t\t\texpectedSequenceNumber, actualSequenceNumber);\n-\t\t}\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(RemoteInputChannel.class);\n+\n+    private static final int NONE = -1;\n+\n+    /** ID to distinguish this channel from other channels sharing the same TCP connection. */\n+    private final InputChannelID id = new InputChannelID();\n+\n+    /** The connection to use to request the remote partition. */\n+    private final ConnectionID connectionId;\n+\n+    /** The connection manager to use connect to the remote partition provider. */\n+    private final ConnectionManager connectionManager;\n+\n+    /**\n+     * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n+     * is consumed by the receiving task thread.\n+     */\n+    private final PrioritizedDeque<SequenceBuffer> receivedBuffers = new PrioritizedDeque<>();\n+\n+    /**\n+     * Flag indicating whether this channel has been released. Either called by the receiving task\n+     * thread or the task manager actor.\n+     */\n+    private final AtomicBoolean isReleased = new AtomicBoolean();\n+\n+    /** Client to establish a (possibly shared) TCP connection and request the partition. */\n+    private volatile PartitionRequestClient partitionRequestClient;\n+\n+    /** The next expected sequence number for the next buffer. */\n+    private int expectedSequenceNumber = 0;\n+\n+    /** The initial number of exclusive buffers assigned to this channel. */\n+    private final int initialCredit;\n+\n+    /** The number of available buffers that have not been announced to the producer yet. */\n+    private final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n+\n+    private final BufferManager bufferManager;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private int lastBarrierSequenceNumber = NONE;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private long lastBarrierId = NONE;\n+\n+    private final ChannelStatePersister channelStatePersister;\n+\n+    public RemoteInputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            ConnectionID connectionId,\n+            ConnectionManager connectionManager,\n+            int initialBackOff,\n+            int maxBackoff,\n+            int networkBuffersPerChannel,\n+            Counter numBytesIn,\n+            Counter numBuffersIn,\n+            ChannelStateWriter stateWriter) {\n+\n+        super(\n+                inputGate,\n+                channelIndex,\n+                partitionId,\n+                initialBackOff,\n+                maxBackoff,\n+                numBytesIn,\n+                numBuffersIn);\n+        checkArgument(networkBuffersPerChannel >= 0, \"Must be non-negative.\");\n+\n+        this.initialCredit = networkBuffersPerChannel;\n+        this.connectionId = checkNotNull(connectionId);\n+        this.connectionManager = checkNotNull(connectionManager);\n+        this.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n+        this.channelStatePersister = new ChannelStatePersister(stateWriter, getChannelInfo());\n+    }\n+\n+    @VisibleForTesting\n+    void setExpectedSequenceNumber(int expectedSequenceNumber) {\n+        this.expectedSequenceNumber = expectedSequenceNumber;\n+    }\n+\n+    /**\n+     * Setup includes assigning exclusive buffers to this input channel, and this method should be\n+     * called only once after this input channel is created.\n+     */\n+    @Override\n+    void setup() throws IOException {\n+        checkState(\n+                bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+                \"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n+\n+        bufferManager.requestExclusiveBuffers(initialCredit);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /** Requests a remote subpartition. */\n+    @VisibleForTesting\n+    @Override\n+    public void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException {\n+        if (partitionRequestClient == null) {\n+            LOG.debug(\n+                    \"{}: Requesting REMOTE subpartition {} of partition {}. {}\",\n+                    this,\n+                    subpartitionIndex,\n+                    partitionId,\n+                    channelStatePersister);\n+            // Create a client and request the partition\n+            try {\n+                partitionRequestClient =\n+                        connectionManager.createPartitionRequestClient(connectionId);\n+            } catch (IOException e) {\n+                // IOExceptions indicate that we could not open a connection to the remote\n+                // TaskExecutor\n+                throw new PartitionConnectionException(partitionId, e);\n+            }\n+\n+            partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n+        }\n+    }\n+\n+    /** Retriggers a remote subpartition request. */\n+    void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (increaseBackoff()) {\n+            partitionRequestClient.requestSubpartition(\n+                    partitionId, subpartitionIndex, this, getCurrentBackoff());\n+        } else {\n+            failPartitionRequest();\n+        }\n+    }\n+\n+    @Override\n+    Optional<BufferAndAvailability> getNextBuffer() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        final SequenceBuffer next;\n+        final DataType nextDataType;\n+\n+        synchronized (receivedBuffers) {\n+            next = receivedBuffers.poll();\n+            nextDataType =\n+                    receivedBuffers.peek() != null\n+                            ? receivedBuffers.peek().buffer.getDataType()\n+                            : DataType.NONE;\n+        }\n+\n+        if (next == null) {\n+            if (isReleased.get()) {\n+                throw new CancelTaskException(\n+                        \"Queried for a buffer after channel has been released.\");\n+            }\n+            return Optional.empty();\n+        }\n+\n+        NetworkActionsLogger.traceInput(\n+                \"RemoteInputChannel#getNextBuffer\",\n+                next.buffer,\n+                inputGate.getOwningTaskName(),\n+                channelInfo,\n+                channelStatePersister,\n+                next.sequenceNumber);\n+        numBytesIn.inc(next.buffer.getSize());\n+        numBuffersIn.inc();\n+        return Optional.of(\n+                new BufferAndAvailability(next.buffer, nextDataType, 0, next.sequenceNumber));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    void sendTaskEvent(TaskEvent event) throws IOException {\n+        checkState(\n+                !isReleased.get(),\n+                \"Tried to send task event to producer after channel has been released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.sendTaskEvent(partitionId, event, this);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased.get();\n+    }\n+\n+    /** Releases all exclusive and floating buffers, closes the partition request client. */\n+    @Override\n+    void releaseAllResources() throws IOException {\n+        if (isReleased.compareAndSet(false, true)) {\n+\n+            final ArrayDeque<Buffer> releasedBuffers;\n+            synchronized (receivedBuffers) {\n+                releasedBuffers =\n+                        receivedBuffers.stream()\n+                                .map(sb -> sb.buffer)\n+                                .collect(Collectors.toCollection(ArrayDeque::new));\n+                receivedBuffers.clear();\n+            }\n+            bufferManager.releaseAllBuffers(releasedBuffers);\n+\n+            // The released flag has to be set before closing the connection to ensure that\n+            // buffers received concurrently with closing are properly recycled.\n+            if (partitionRequestClient != null) {\n+                partitionRequestClient.close(this);\n+            } else {\n+                connectionManager.closeOpenChannelConnections(connectionId);\n+            }\n+        }\n+    }\n+\n+    private void failPartitionRequest() {\n+        setError(new PartitionNotFoundException(partitionId));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Credit-based\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n+     */\n+    private void notifyCreditAvailable() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.notifyCreditAvailable(this);\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfAvailableBuffers() {\n+        return bufferManager.getNumberOfAvailableBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfRequiredBuffers() {\n+        return bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getSenderBacklog() {\n+        return getNumberOfRequiredBuffers() - initialCredit;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isWaitingForFloatingBuffers() {\n+        return bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public Buffer getNextReceivedBuffer() {\n+        final SequenceBuffer sequenceBuffer = receivedBuffers.poll();\n+        return sequenceBuffer != null ? sequenceBuffer.buffer : null;\n+    }\n+\n+    @VisibleForTesting\n+    BufferManager getBufferManager() {\n+        return bufferManager;\n+    }\n+\n+    @VisibleForTesting\n+    PartitionRequestClient getPartitionRequestClient() {\n+        return partitionRequestClient;\n+    }\n+\n+    /**\n+     * The unannounced credit is increased by the given amount and might notify increased credit to\n+     * the producer.\n+     */\n+    @Override\n+    public void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n+        if (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+            notifyCreditAvailable();\n+        }\n+    }\n+\n+    @Override\n+    public void resumeConsumption() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (initialCredit == 0) {\n+            // this unannounced credit can be a positive value because credit assignment and the\n+            // increase of this value is not an atomic operation and as a result, this unannounced\n+            // credit value can be get increased even after this channel has been blocked and all\n+            // floating credits are released, it is important to clear this unannounced credit and\n+            // at the same time reset the sender's available credits to keep consistency\n+            unannouncedCredit.set(0);\n+        }\n+\n+        // notifies the producer that this channel is ready to\n+        // unblock from checkpoint and resume data consumption\n+        partitionRequestClient.resumeConsumption(this);\n+    }\n+\n+    @Override\n+    public void acknowledgeAllRecordsProcessed() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.acknowledgeAllRecordsProcessed(this);\n+    }\n+\n+    private void onBlockingUpstream() {\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network I/O notifications (called by network I/O thread)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the currently unannounced credit.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getUnannouncedCredit() {\n+        return unannouncedCredit.get();\n+    }\n+\n+    /**\n+     * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getAndResetUnannouncedCredit() {\n+        return unannouncedCredit.getAndSet(0);\n+    }\n+\n+    /**\n+     * Gets the current number of received buffers which have not been processed yet.\n+     *\n+     * @return Buffers queued for processing.\n+     */\n+    public int getNumberOfQueuedBuffers() {\n+        synchronized (receivedBuffers) {\n+            return receivedBuffers.size();\n+        }\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return Math.max(0, receivedBuffers.size());\n+    }\n+\n+    public int unsynchronizedGetExclusiveBuffersUsed() {\n+        return Math.max(\n+                0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n+    }\n+\n+    public int unsynchronizedGetFloatingBuffersAvailable() {\n+        return Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n+    }\n+\n+    public InputChannelID getInputChannelId() {\n+        return id;\n+    }\n+\n+    public int getInitialCredit() {\n+        return initialCredit;\n+    }\n+\n+    public BufferProvider getBufferProvider() throws IOException {\n+        if (isReleased.get()) {\n+            return null;\n+        }\n+\n+        return inputGate.getBufferProvider();\n+    }\n+\n+    /**\n+     * Requests buffer from input channel directly for receiving network data. It should always\n+     * return an available buffer in credit-based mode unless the channel has been released.\n+     *\n+     * @return The available buffer.\n+     */\n+    @Nullable\n+    public Buffer requestBuffer() {\n+        return bufferManager.requestBuffer();\n+    }\n+\n+    /**\n+     * Receives the backlog from the producer's buffer response. If the number of available buffers\n+     * is less than backlog + initialCredit, it will request floating buffers from the buffer\n+     * manager, and then notify unannounced credits to the producer.\n+     *\n+     * @param backlog The number of unsent buffers in the producer's sub partition.\n+     */\n+    public void onSenderBacklog(int backlog) throws IOException {\n+        notifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+    }\n+\n+    /**\n+     * Handles the input buffer. This method is taking over the ownership of the buffer and is fully\n+     * responsible for cleaning it up both on the happy path and in case of an error.\n+     */\n+    public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n+        boolean recycleBuffer = true;\n+\n+        try {\n+            if (expectedSequenceNumber != sequenceNumber) {\n+                onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                return;\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+                checkArgument(backlog == 0, \"Illegal number of backlog: %s, should be 0.\", backlog);\n+            }\n+\n+            final boolean wasEmpty;\n+            boolean firstPriorityEvent = false;\n+            synchronized (receivedBuffers) {\n+                NetworkActionsLogger.traceInput(\n+                        \"RemoteInputChannel#onBuffer\",\n+                        buffer,\n+                        inputGate.getOwningTaskName(),\n+                        channelInfo,\n+                        channelStatePersister,\n+                        sequenceNumber);\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after releaseAllResources() released all buffers from receivedBuffers\n+                // (see above for details).\n+                if (isReleased.get()) {\n+                    return;\n+                }\n+\n+                wasEmpty = receivedBuffers.isEmpty();\n+\n+                SequenceBuffer sequenceBuffer = new SequenceBuffer(buffer, sequenceNumber);\n+                DataType dataType = buffer.getDataType();\n+                if (dataType.hasPriority()) {\n+                    firstPriorityEvent = addPriorityBuffer(sequenceBuffer);\n+                    recycleBuffer = false;\n+                } else {\n+                    receivedBuffers.add(sequenceBuffer);\n+                    recycleBuffer = false;\n+                    if (dataType.requiresAnnouncement()) {\n+                        firstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n+                    }\n+                }\n+                channelStatePersister\n+                        .checkForBarrier(sequenceBuffer.buffer)\n+                        .filter(id -> id > lastBarrierId)\n+                        .ifPresent(\n+                                id -> {\n+                                    // checkpoint was not yet started by task thread,\n+                                    // so remember the numbers of buffers to spill for the time when\n+                                    // it will be started\n+                                    lastBarrierId = id;\n+                                    lastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+                                });\n+                channelStatePersister.maybePersist(buffer);\n+                ++expectedSequenceNumber;\n+            }\n+\n+            if (firstPriorityEvent) {\n+                notifyPriorityEvent(sequenceNumber);\n+            }\n+            if (wasEmpty) {\n+                notifyChannelNonEmpty();\n+            }\n+\n+            if (backlog >= 0) {\n+                onSenderBacklog(backlog);\n+            }\n+        } finally {\n+            if (recycleBuffer) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+    }\n+\n+    /** @return {@code true} if this was first priority buffer added. */\n+    private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) {\n+        receivedBuffers.addPriorityElement(sequenceBuffer);\n+        return receivedBuffers.getNumPriorityElements() == 1;\n+    }\n+\n+    private SequenceBuffer announce(SequenceBuffer sequenceBuffer) throws IOException {\n+        checkState(\n+                !sequenceBuffer.buffer.isBuffer(),\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        checkAnnouncedOnlyOnce(sequenceBuffer);\n+        AbstractEvent event =\n+                EventSerializer.fromBuffer(sequenceBuffer.buffer, getClass().getClassLoader());\n+        checkState(\n+                event instanceof CheckpointBarrier,\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        CheckpointBarrier barrier = (CheckpointBarrier) event;\n+        return new SequenceBuffer(\n+                EventSerializer.toBuffer(\n+                        new EventAnnouncement(barrier, sequenceBuffer.sequenceNumber), true),\n+                sequenceBuffer.sequenceNumber);\n+    }\n+\n+    private void checkAnnouncedOnlyOnce(SequenceBuffer sequenceBuffer) {\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        int count = 0;\n+        while (iterator.hasNext()) {\n+            if (iterator.next().sequenceNumber == sequenceBuffer.sequenceNumber) {\n+                count++;\n+            }\n+        }\n+        checkState(\n+                count == 1,\n+                \"Before enqueuing the announcement there should be exactly single occurrence of the buffer, but found [%d]\",\n+                count);\n+    }\n+\n+    /**\n+     * Spills all queued buffers on checkpoint start. If barrier has already been received (and\n+     * reordered), spill only the overtaken buffers.\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {\n+        synchronized (receivedBuffers) {\n+            if (barrier.getId() < lastBarrierId) {\n+                throw new CheckpointException(\n+                        String.format(\n+                                \"Sequence number for checkpoint %d is not known (it was likely been overwritten by a newer checkpoint %d)\",\n+                                barrier.getId(), lastBarrierId),\n+                        CheckpointFailureReason\n+                                .CHECKPOINT_SUBSUMED); // currently, at most one active unaligned\n+                // checkpoint is possible\n+            } else if (barrier.getId() > lastBarrierId) {\n+                // This channel has received some obsolete barrier, older compared to the\n+                // checkpointId\n+                // which we are processing right now, and we should ignore that obsoleted checkpoint\n+                // barrier sequence number.\n+                resetLastBarrier();\n+            }\n+\n+            channelStatePersister.startPersisting(\n+                    barrier.getId(), getInflightBuffersUnsafe(barrier.getId()));\n+        }\n+    }\n+\n+    public void checkpointStopped(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            channelStatePersister.stopPersisting(checkpointId);\n+            if (lastBarrierId == checkpointId) {\n+                resetLastBarrier();\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    List<Buffer> getInflightBuffers(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            return getInflightBuffersUnsafe(checkpointId);\n+        }\n+    }\n+\n+    @Override\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n+        boolean firstPriorityEvent;\n+        synchronized (receivedBuffers) {\n+            checkState(channelStatePersister.hasBarrierReceived());\n+            int numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n+            SequenceBuffer toPrioritize =\n+                    receivedBuffers.getAndRemove(\n+                            sequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n+            checkState(lastBarrierSequenceNumber == sequenceNumber);\n+            checkState(!toPrioritize.buffer.isBuffer());\n+            checkState(\n+                    numPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n+                    \"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n+                    toPrioritize,\n+                    numPriorityElementsBeforeRemoval);\n+            // set the priority flag (checked on poll)\n+            // don't convert the barrier itself (barrier controller might not have been switched\n+            // yet)\n+            AbstractEvent e =\n+                    EventSerializer.fromBuffer(\n+                            toPrioritize.buffer, this.getClass().getClassLoader());\n+            toPrioritize.buffer.setReaderIndex(0);\n+            toPrioritize =\n+                    new SequenceBuffer(\n+                            EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n+            firstPriorityEvent =\n+                    addPriorityBuffer(\n+                            toPrioritize); // note that only position of the element is changed\n+            // converting the event itself would require switching the controller sooner\n+        }\n+        if (firstPriorityEvent) {\n+            notifyPriorityEventForce(); // forcibly notify about the priority event\n+            // instead of passing barrier SQN to be checked\n+            // because this SQN might have be seen by the input gate during the announcement\n+        }\n+    }\n+\n+    private void notifyPriorityEventForce() {\n+        inputGate.notifyPriorityEventForce(this);\n+    }\n+\n+    /**\n+     * Returns a list of buffers, checking the first n non-priority buffers, and skipping all\n+     * events.\n+     */\n+    private List<Buffer> getInflightBuffersUnsafe(long checkpointId) {\n+        assert Thread.holdsLock(receivedBuffers);\n+\n+        checkState(checkpointId == lastBarrierId || lastBarrierId == NONE);\n+\n+        final List<Buffer> inflightBuffers = new ArrayList<>();\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        // skip all priority events (only buffers are stored anyways)\n+        Iterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n+\n+        while (iterator.hasNext()) {\n+            SequenceBuffer sequenceBuffer = iterator.next();\n+            if (sequenceBuffer.buffer.isBuffer()) {\n+                if (shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+                    inflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return inflightBuffers;\n+    }\n+\n+    private void resetLastBarrier() {\n+        lastBarrierId = NONE;\n+        lastBarrierSequenceNumber = NONE;\n+    }\n+\n+    /**\n+     * @return if given {@param sequenceNumber} should be spilled given {@link\n+     *     #lastBarrierSequenceNumber}. We might not have yet received {@link CheckpointBarrier} and\n+     *     we might need to spill everything. If we have already received it, there is a bit nasty\n+     *     corner case of {@link SequenceBuffer#sequenceNumber} overflowing that needs to be handled\n+     *     as well.\n+     */\n+    private boolean shouldBeSpilled(int sequenceNumber) {\n+        if (lastBarrierSequenceNumber == NONE) {\n+            return true;\n+        }\n+        checkState(\n+                receivedBuffers.size() < Integer.MAX_VALUE / 2,\n+                \"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+        boolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastBarrierSequenceNumber;\n+        boolean possibleOverflowBeforeOvertaking =\n+                lastBarrierSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+        if (possibleOverflowAfterOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber && sequenceNumber > 0;\n+        } else if (possibleOverflowBeforeOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber || sequenceNumber > 0;\n+        } else {\n+            return sequenceNumber < lastBarrierSequenceNumber;\n+        }\n+    }\n+\n+    public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n+        boolean success = false;\n+\n+        synchronized (receivedBuffers) {\n+            if (!isReleased.get()) {\n+                if (expectedSequenceNumber == sequenceNumber) {\n+                    expectedSequenceNumber++;\n+                    success = true;\n+                } else {\n+                    onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                }\n+            }\n+        }\n+\n+        if (success && backlog >= 0) {\n+            onSenderBacklog(backlog);\n+        }\n+    }\n+\n+    public void onFailedPartitionRequest() {\n+        inputGate.triggerPartitionStateCheck(partitionId);\n+    }\n+\n+    public void onError(Throwable cause) {\n+        setError(cause);\n+    }\n+\n+    private void checkPartitionRequestQueueInitialized() throws IOException {\n+        checkError();\n+        checkState(\n+                partitionRequestClient != null,\n+                \"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n+    }\n+\n+    private static class BufferReorderingException extends IOException {\n+\n+        private static final long serialVersionUID = -888282210356266816L;\n+\n+        private final int expectedSequenceNumber;\n+\n+        private final int actualSequenceNumber;\n+\n+        BufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n+            this.expectedSequenceNumber = expectedSequenceNumber;\n+            this.actualSequenceNumber = actualSequenceNumber;\n+        }\n+\n+        @Override\n+        public String getMessage() {\n+            return String.format(\n+                    \"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n+                    expectedSequenceNumber, actualSequenceNumber);\n+        }\n+    }\n+\n+    private static final class SequenceBuffer {\n+        final Buffer buffer;\n+        final int sequenceNumber;\n+\n+        private SequenceBuffer(Buffer buffer, int sequenceNumber) {\n+            this.buffer = buffer;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\n+                    \"SequenceBuffer(isEvent = %s, dataType = %s, sequenceNumber = %s)\",\n+                    !buffer.isBuffer(), buffer.getDataType(), sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "0ee049db1ffe8a4a68bcd97608774ee488d02a21", "committedDate": "2021-09-03 08:19:32 +0200", "message": "[FLINK-23907] Use primitive functional interfaces"}, {"oid": "138e83e2bc6feb59ecd839b03491cd8f23ee1c66", "committedDate": "2021-11-08 08:56:34 +0100", "message": "[FLINK-24738][runtime] Ignoring buffer size announcement if the channel is released already"}, {"oid": "4eea7bc9352134a06d2b207c9a94dd46a01c6132", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[FLINK-24657][runtime] Added metric of the total real size of input/output buffers queue"}, {"oid": "f4fd4f8bb66867821cb0f171218d85f8386b0897", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] Move consumedSubpartitionIndex from SingleInputGate to InputChannel"}, {"oid": "5c2ec72982128fc1a30014677916e0dd21f9c1d2", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] SingleInputGate supports consuming subpartition range"}, {"oid": "6398abcbff06b3e488a273144680f4838b4f1c92", "committedDate": "2023-06-09 22:48:37 +0800", "message": "[FLINK-31636][network] Introduce the NettyService framework"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NjMwOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424186308", "body": "Make this change a separate hotfix?", "bodyText": "Make this change a separate hotfix?", "bodyHTML": "<p dir=\"auto\">Make this change a separate hotfix?</p>", "author": "zhijiangW", "createdAt": "2020-05-13T05:48:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -415,11 +425,8 @@ public Buffer requestBuffer() {\n \t *\n \t * @param backlog The number of unsent buffers in the producer's sub partition.\n \t */\n-\tvoid onSenderBacklog(int backlog) throws IOException {\n-\t\tint numRequestedBuffers = bufferManager.requestFloatingBuffers(backlog + initialCredit);\n-\t\tif (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n+\tpublic void onSenderBacklog(int backlog) throws IOException {\n+\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2cb05ba959c5ac264eb8fa85d711f499301ed767", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 2cbd3801b56..0c4f32d2f89 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -419,11 +431,11 @@ public class RemoteInputChannel extends InputChannel {\n \t}\n \n \t/**\n-\t * Receives the backlog from the producer's buffer response. If the number of available\n-\t * buffers is less than backlog + initialCredit, it will request floating buffers from\n-\t * the buffer manager, and then notify unannounced credits to the producer.\n+\t * Receives the backlog from the producer's buffer response. Floating buffers will\n+\t * be requested from the {@link BufferManager} according to the announced backlog,\n+\t * and then it will notify unannounced credits to the producer.\n \t *\n-\t * @param backlog The number of unsent buffers in the producer's sub partition.\n+\t * @param backlog Number of the announced backlog from producer.\n \t */\n \tpublic void onSenderBacklog(int backlog) throws IOException {\n \t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 0c4f32d2f89..3e976686f91 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -20,533 +20,781 @@ package org.apache.flink.runtime.io.network.partition.consumer;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.metrics.Counter;\n-import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.runtime.checkpoint.CheckpointException;\n+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;\n import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;\n+import org.apache.flink.runtime.event.AbstractEvent;\n import org.apache.flink.runtime.event.TaskEvent;\n+import org.apache.flink.runtime.execution.CancelTaskException;\n import org.apache.flink.runtime.io.network.ConnectionID;\n import org.apache.flink.runtime.io.network.ConnectionManager;\n import org.apache.flink.runtime.io.network.PartitionRequestClient;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+import org.apache.flink.runtime.io.network.api.EventAnnouncement;\n+import org.apache.flink.runtime.io.network.api.serialization.EventSerializer;\n import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.Buffer.DataType;\n import org.apache.flink.runtime.io.network.buffer.BufferProvider;\n-import org.apache.flink.runtime.io.network.buffer.BufferReceivedListener;\n-import org.apache.flink.runtime.io.network.netty.NettyMessage.ResumeConsumption;\n+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;\n import org.apache.flink.runtime.io.network.partition.PartitionNotFoundException;\n+import org.apache.flink.runtime.io.network.partition.PrioritizedDeque;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n \n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterators;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n-/**\n- * An input channel, which requests a remote partition queue.\n- */\n+/** An input channel, which requests a remote partition queue. */\n public class RemoteInputChannel extends InputChannel {\n-\n-\t/** ID to distinguish this channel from other channels sharing the same TCP connection. */\n-\tprivate final InputChannelID id = new InputChannelID();\n-\n-\t/** The connection to use to request the remote partition. */\n-\tprivate final ConnectionID connectionId;\n-\n-\t/** The connection manager to use connect to the remote partition provider. */\n-\tprivate final ConnectionManager connectionManager;\n-\n-\t/**\n-\t * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n-\t * is consumed by the receiving task thread.\n-\t */\n-\tprivate final ArrayDeque<Buffer> receivedBuffers = new ArrayDeque<>();\n-\n-\t/**\n-\t * Flag indicating whether this channel has been released. Either called by the receiving task\n-\t * thread or the task manager actor.\n-\t */\n-\tprivate final AtomicBoolean isReleased = new AtomicBoolean();\n-\n-\t/** Client to establish a (possibly shared) TCP connection and request the partition. */\n-\tprivate volatile PartitionRequestClient partitionRequestClient;\n-\n-\t/**\n-\t * The next expected sequence number for the next buffer. This is modified by the network\n-\t * I/O thread only.\n-\t */\n-\tprivate int expectedSequenceNumber = 0;\n-\n-\t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate final int initialCredit;\n-\n-\t/** The number of available buffers that have not been announced to the producer yet. */\n-\tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n-\n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n-\n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n-\n-\tprivate final BufferManager bufferManager;\n-\n-\tpublic RemoteInputChannel(\n-\t\tSingleInputGate inputGate,\n-\t\tint channelIndex,\n-\t\tResultPartitionID partitionId,\n-\t\tConnectionID connectionId,\n-\t\tConnectionManager connectionManager,\n-\t\tint initialBackOff,\n-\t\tint maxBackoff,\n-\t\tint networkBuffersPerChannel,\n-\t\tCounter numBytesIn,\n-\t\tCounter numBuffersIn) {\n-\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, numBytesIn, numBuffersIn);\n-\n-\t\tthis.initialCredit = networkBuffersPerChannel;\n-\t\tthis.connectionId = checkNotNull(connectionId);\n-\t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n-\t}\n-\n-\t/**\n-\t * Assigns exclusive buffers to this input channel, and this method should be called only once\n-\t * after this input channel is created.\n-\t */\n-\tvoid assignExclusiveSegments() throws IOException {\n-\t\tcheckState(bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n-\t\t\t\"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n-\n-\t\tbufferManager.requestExclusiveBuffers();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests a remote subpartition.\n-\t */\n-\t@VisibleForTesting\n-\t@Override\n-\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n-\t\tif (partitionRequestClient == null) {\n-\t\t\t// Create a client and request the partition\n-\t\t\ttry {\n-\t\t\t\tpartitionRequestClient = connectionManager.createPartitionRequestClient(connectionId);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\t// IOExceptions indicate that we could not open a connection to the remote TaskExecutor\n-\t\t\t\tthrow new PartitionConnectionException(partitionId, e);\n-\t\t\t}\n-\n-\t\t\tpartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Retriggers a remote subpartition request.\n-\t */\n-\tvoid retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n-\t\tcheckState(partitionRequestClient != null, \"Missing initial subpartition request.\");\n-\n-\t\tif (increaseBackoff()) {\n-\t\t\tpartitionRequestClient.requestSubpartition(\n-\t\t\t\tpartitionId, subpartitionIndex, this, getCurrentBackoff());\n-\t\t} else {\n-\t\t\tfailPartitionRequest();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tOptional<BufferAndAvailability> getNextBuffer() throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Queried for a buffer after channel has been closed.\");\n-\t\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tfinal Buffer next;\n-\t\tfinal boolean moreAvailable;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tnext = receivedBuffers.poll();\n-\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n-\t\t}\n-\n-\t\tnumBytesIn.inc(next.getSize());\n-\t\tnumBuffersIn.inc();\n-\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable));\n-\t}\n-\n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlastRequestedCheckpointId = checkpointId;\n-\n-\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\tcheckpointId,\n-\t\t\t\tchannelInfo,\n-\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tvoid sendTaskEvent(TaskEvent event) throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Tried to send task event to producer after channel has been released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tpartitionRequestClient.sendTaskEvent(partitionId, event, this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n-\t}\n-\n-\t/**\n-\t * Releases all exclusive and floating buffers, closes the partition request client.\n-\t */\n-\t@Override\n-\tvoid releaseAllResources() throws IOException {\n-\t\tif (isReleased.compareAndSet(false, true)) {\n-\n-\t\t\tArrayDeque<Buffer> releasedBuffers;\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\treleasedBuffers = receivedBuffers;\n-\t\t\t}\n-\t\t\tbufferManager.releaseAllBuffers(releasedBuffers);\n-\n-\t\t\t// The released flag has to be set before closing the connection to ensure that\n-\t\t\t// buffers received concurrently with closing are properly recycled.\n-\t\t\tif (partitionRequestClient != null) {\n-\t\t\t\tpartitionRequestClient.close(this);\n-\t\t\t} else {\n-\t\t\t\tconnectionManager.closeOpenChannelConnections(connectionId);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void failPartitionRequest() {\n-\t\tsetError(new PartitionNotFoundException(partitionId));\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Credit-based\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n-\t */\n-\tprivate void notifyCreditAvailable() {\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tpartitionRequestClient.notifyCreditAvailable(this);\n-\t}\n-\n-\tpublic int getNumberOfAvailableBuffers() {\n-\t\treturn bufferManager.getNumberOfAvailableBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn bufferManager.getNumberOfRequiredBuffers();\n-\t}\n-\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\treturn bufferManager.isWaitingForFloatingBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n-\t}\n-\n-\t@VisibleForTesting\n-\tBufferManager getBufferManager() {\n-\t\treturn bufferManager;\n-\t}\n-\n-\t@VisibleForTesting\n-\tPartitionRequestClient getPartitionRequestClient() {\n-\t\treturn partitionRequestClient;\n-\t}\n-\n-\t/**\n-\t * The unannounced credit is increased by the given amount and might notify\n-\t * increased credit to the producer.\n-\t */\n-\t@Override\n-\tpublic void notifyBufferAvailable(int numAvailableBuffers) {\n-\t\tif (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tbufferManager.releaseFloatingBuffers(true);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption() {\n-\t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n-\n-\t\t// notifies the producer that this channel is ready to\n-\t\t// unblock from checkpoint and resume data consumption\n-\t\tpartitionRequestClient.resumeConsumption(this);\n-\t}\n-\n-\t/**\n-\t * Called by netty thread to request buffers and generate {@link ResumeConsumption} message.\n-\t */\n-\tpublic ResumeConsumption getResumeConsumptionMessage() throws IOException {\n-\t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n-\t\tcheckState(getNumberOfAvailableBuffers() == initialCredit, \"Illegal number of available buffers.\");\n-\t\tcheckState(!isWaitingForFloatingBuffers(), \"Should not be waiting for floating buffers.\");\n-\n-\t\tif (initialCredit > 0) {\n-\t\t\treturn new ResumeConsumption(id, initialCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t\t}\n-\n-\t\tint availableCredit = bufferManager.requestFloatingBuffers(0);\n-\t\treturn new ResumeConsumption(id, availableCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network I/O notifications (called by network I/O thread)\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Gets the currently unannounced credit.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getUnannouncedCredit() {\n-\t\treturn unannouncedCredit.get();\n-\t}\n-\n-\t/**\n-\t * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n-\t}\n-\n-\t/**\n-\t * Gets the current number of received buffers which have not been processed yet.\n-\t *\n-\t * @return Buffers queued for processing.\n-\t */\n-\tpublic int getNumberOfQueuedBuffers() {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treturn receivedBuffers.size();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn Math.max(0, receivedBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n-\t}\n-\n-\tpublic int unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n-\t}\n-\n-\tpublic InputChannelID getInputChannelId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic int getInitialCredit() {\n-\t\treturn initialCredit;\n-\t}\n-\n-\tpublic BufferProvider getBufferProvider() throws IOException {\n-\t\tif (isReleased.get()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn inputGate.getBufferProvider();\n-\t}\n-\n-\t/**\n-\t * Requests buffer from input channel directly for receiving network data.\n-\t * It should always return an available buffer in credit-based mode unless\n-\t * the channel has been released.\n-\t *\n-\t * @return The available buffer.\n-\t */\n-\t@Nullable\n-\tpublic Buffer requestBuffer() {\n-\t\treturn bufferManager.requestBuffer();\n-\t}\n-\n-\t/**\n-\t * Receives the backlog from the producer's buffer response. Floating buffers will\n-\t * be requested from the {@link BufferManager} according to the announced backlog,\n-\t * and then it will notify unannounced credits to the producer.\n-\t *\n-\t * @param backlog Number of the announced backlog from producer.\n-\t */\n-\tpublic void onSenderBacklog(int backlog) throws IOException {\n-\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));\n-\t}\n-\n-\tpublic void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean recycleBuffer = true;\n-\n-\t\ttry {\n-\t\t\tif (expectedSequenceNumber != sequenceNumber) {\n-\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tfinal boolean wasEmpty;\n-\t\t\tfinal CheckpointBarrier notifyReceivedBarrier;\n-\t\t\tfinal Buffer notifyReceivedBuffer;\n-\t\t\tfinal CheckpointBarrier barrier;\n-\t\t\tfinal BufferReceivedListener listener = inputGate.getBufferReceivedListener();\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after releaseAllResources() released all buffers from receivedBuffers\n-\t\t\t\t// (see above for details).\n-\t\t\t\tif (isReleased.get()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n-\n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n-\t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n-\t\t\t\tbarrier = listener != null ? notifyReceivedBarrier : parseCheckpointBarrierOrNull(buffer);\n-\t\t\t}\n-\t\t\trecycleBuffer = false;\n-\n-\t\t\t++expectedSequenceNumber;\n-\n-\t\t\tif (wasEmpty) {\n-\t\t\t\tnotifyChannelNonEmpty();\n-\t\t\t}\n-\n-\t\t\tif (backlog >= 0) {\n-\t\t\t\tonSenderBacklog(backlog);\n-\t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n-\n-\t\t\tif (barrier != null) {\n-\t\t\t\tonCheckpointBarrier(barrier);\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tif (recycleBuffer) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean success = false;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tif (!isReleased.get()) {\n-\t\t\t\tif (expectedSequenceNumber == sequenceNumber) {\n-\t\t\t\t\texpectedSequenceNumber++;\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t} else {\n-\t\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (success && backlog >= 0) {\n-\t\t\tonSenderBacklog(backlog);\n-\t\t}\n-\t}\n-\n-\tpublic void onFailedPartitionRequest() {\n-\t\tinputGate.triggerPartitionStateCheck(partitionId);\n-\t}\n-\n-\tpublic void onError(Throwable cause) {\n-\t\tsetError(cause);\n-\t}\n-\n-\tprivate static class BufferReorderingException extends IOException {\n-\n-\t\tprivate static final long serialVersionUID = -888282210356266816L;\n-\n-\t\tprivate final int expectedSequenceNumber;\n-\n-\t\tprivate final int actualSequenceNumber;\n-\n-\t\tBufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n-\t\t\tthis.expectedSequenceNumber = expectedSequenceNumber;\n-\t\t\tthis.actualSequenceNumber = actualSequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String getMessage() {\n-\t\t\treturn String.format(\"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n-\t\t\t\texpectedSequenceNumber, actualSequenceNumber);\n-\t\t}\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(RemoteInputChannel.class);\n+\n+    private static final int NONE = -1;\n+\n+    /** ID to distinguish this channel from other channels sharing the same TCP connection. */\n+    private final InputChannelID id = new InputChannelID();\n+\n+    /** The connection to use to request the remote partition. */\n+    private final ConnectionID connectionId;\n+\n+    /** The connection manager to use connect to the remote partition provider. */\n+    private final ConnectionManager connectionManager;\n+\n+    /**\n+     * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n+     * is consumed by the receiving task thread.\n+     */\n+    private final PrioritizedDeque<SequenceBuffer> receivedBuffers = new PrioritizedDeque<>();\n+\n+    /**\n+     * Flag indicating whether this channel has been released. Either called by the receiving task\n+     * thread or the task manager actor.\n+     */\n+    private final AtomicBoolean isReleased = new AtomicBoolean();\n+\n+    /** Client to establish a (possibly shared) TCP connection and request the partition. */\n+    private volatile PartitionRequestClient partitionRequestClient;\n+\n+    /** The next expected sequence number for the next buffer. */\n+    private int expectedSequenceNumber = 0;\n+\n+    /** The initial number of exclusive buffers assigned to this channel. */\n+    private final int initialCredit;\n+\n+    /** The number of available buffers that have not been announced to the producer yet. */\n+    private final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n+\n+    private final BufferManager bufferManager;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private int lastBarrierSequenceNumber = NONE;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private long lastBarrierId = NONE;\n+\n+    private final ChannelStatePersister channelStatePersister;\n+\n+    private boolean isUpstreamBlocked;\n+\n+    public RemoteInputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            ConnectionID connectionId,\n+            ConnectionManager connectionManager,\n+            int initialBackOff,\n+            int maxBackoff,\n+            int networkBuffersPerChannel,\n+            Counter numBytesIn,\n+            Counter numBuffersIn,\n+            ChannelStateWriter stateWriter) {\n+\n+        super(\n+                inputGate,\n+                channelIndex,\n+                partitionId,\n+                initialBackOff,\n+                maxBackoff,\n+                numBytesIn,\n+                numBuffersIn);\n+        checkArgument(networkBuffersPerChannel >= 0, \"Must be non-negative.\");\n+\n+        this.initialCredit = networkBuffersPerChannel;\n+        this.connectionId = checkNotNull(connectionId);\n+        this.connectionManager = checkNotNull(connectionManager);\n+        this.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n+        this.channelStatePersister = new ChannelStatePersister(stateWriter, getChannelInfo());\n+    }\n+\n+    @VisibleForTesting\n+    void setExpectedSequenceNumber(int expectedSequenceNumber) {\n+        this.expectedSequenceNumber = expectedSequenceNumber;\n+    }\n+\n+    /**\n+     * Setup includes assigning exclusive buffers to this input channel, and this method should be\n+     * called only once after this input channel is created.\n+     */\n+    @Override\n+    void setup() throws IOException {\n+        checkState(\n+                bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+                \"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n+\n+        bufferManager.requestExclusiveBuffers(initialCredit);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /** Requests a remote subpartition. */\n+    @VisibleForTesting\n+    @Override\n+    public void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException {\n+        if (partitionRequestClient == null) {\n+            LOG.debug(\n+                    \"{}: Requesting REMOTE subpartition {} of partition {}. {}\",\n+                    this,\n+                    subpartitionIndex,\n+                    partitionId,\n+                    channelStatePersister);\n+            // Create a client and request the partition\n+            try {\n+                partitionRequestClient =\n+                        connectionManager.createPartitionRequestClient(connectionId);\n+            } catch (IOException e) {\n+                // IOExceptions indicate that we could not open a connection to the remote\n+                // TaskExecutor\n+                throw new PartitionConnectionException(partitionId, e);\n+            }\n+\n+            partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n+        }\n+    }\n+\n+    /** Retriggers a remote subpartition request. */\n+    void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (increaseBackoff()) {\n+            partitionRequestClient.requestSubpartition(\n+                    partitionId, subpartitionIndex, this, getCurrentBackoff());\n+        } else {\n+            failPartitionRequest();\n+        }\n+    }\n+\n+    @Override\n+    Optional<BufferAndAvailability> getNextBuffer() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        final SequenceBuffer next;\n+        final DataType nextDataType;\n+\n+        synchronized (receivedBuffers) {\n+            next = receivedBuffers.poll();\n+            nextDataType =\n+                    receivedBuffers.peek() != null\n+                            ? receivedBuffers.peek().buffer.getDataType()\n+                            : DataType.NONE;\n+        }\n+\n+        if (next == null) {\n+            if (isReleased.get()) {\n+                throw new CancelTaskException(\n+                        \"Queried for a buffer after channel has been released.\");\n+            }\n+            return Optional.empty();\n+        }\n+\n+        numBytesIn.inc(next.buffer.getSize());\n+        numBuffersIn.inc();\n+        return Optional.of(\n+                new BufferAndAvailability(next.buffer, nextDataType, 0, next.sequenceNumber));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    void sendTaskEvent(TaskEvent event) throws IOException {\n+        checkState(\n+                !isReleased.get(),\n+                \"Tried to send task event to producer after channel has been released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.sendTaskEvent(partitionId, event, this);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased.get();\n+    }\n+\n+    /** Releases all exclusive and floating buffers, closes the partition request client. */\n+    @Override\n+    void releaseAllResources() throws IOException {\n+        if (isReleased.compareAndSet(false, true)) {\n+\n+            final ArrayDeque<Buffer> releasedBuffers;\n+            synchronized (receivedBuffers) {\n+                releasedBuffers =\n+                        receivedBuffers.stream()\n+                                .map(sb -> sb.buffer)\n+                                .collect(Collectors.toCollection(ArrayDeque::new));\n+                receivedBuffers.clear();\n+            }\n+            bufferManager.releaseAllBuffers(releasedBuffers);\n+\n+            // The released flag has to be set before closing the connection to ensure that\n+            // buffers received concurrently with closing are properly recycled.\n+            if (partitionRequestClient != null) {\n+                partitionRequestClient.close(this);\n+            } else {\n+                connectionManager.closeOpenChannelConnections(connectionId);\n+            }\n+        }\n+    }\n+\n+    private void failPartitionRequest() {\n+        setError(new PartitionNotFoundException(partitionId));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Credit-based\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n+     */\n+    private void notifyCreditAvailable() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.notifyCreditAvailable(this);\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfAvailableBuffers() {\n+        return bufferManager.getNumberOfAvailableBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfRequiredBuffers() {\n+        return bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getSenderBacklog() {\n+        return getNumberOfRequiredBuffers() - initialCredit;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isWaitingForFloatingBuffers() {\n+        return bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public Buffer getNextReceivedBuffer() {\n+        final SequenceBuffer sequenceBuffer = receivedBuffers.poll();\n+        return sequenceBuffer != null ? sequenceBuffer.buffer : null;\n+    }\n+\n+    @VisibleForTesting\n+    BufferManager getBufferManager() {\n+        return bufferManager;\n+    }\n+\n+    @VisibleForTesting\n+    PartitionRequestClient getPartitionRequestClient() {\n+        return partitionRequestClient;\n+    }\n+\n+    /**\n+     * The unannounced credit is increased by the given amount and might notify increased credit to\n+     * the producer.\n+     */\n+    @Override\n+    public void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n+        if (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+            notifyCreditAvailable();\n+        }\n+    }\n+\n+    @Override\n+    public void resumeConsumption() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        // notifies the producer that this channel is ready to\n+        // unblock from checkpoint and resume data consumption\n+        partitionRequestClient.resumeConsumption(this);\n+    }\n+\n+    private void onBlockingUpstream() {\n+        isUpstreamBlocked = true;\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    public void onConsumptionResumed() {\n+        isUpstreamBlocked = false;\n+        if (initialCredit == 0) {\n+            unannouncedCredit.set(0);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network I/O notifications (called by network I/O thread)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the currently unannounced credit.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getUnannouncedCredit() {\n+        return unannouncedCredit.get();\n+    }\n+\n+    /**\n+     * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getAndResetUnannouncedCredit() {\n+        return unannouncedCredit.getAndSet(0);\n+    }\n+\n+    /**\n+     * Gets the current number of received buffers which have not been processed yet.\n+     *\n+     * @return Buffers queued for processing.\n+     */\n+    public int getNumberOfQueuedBuffers() {\n+        synchronized (receivedBuffers) {\n+            return receivedBuffers.size();\n+        }\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return Math.max(0, receivedBuffers.size());\n+    }\n+\n+    public int unsynchronizedGetExclusiveBuffersUsed() {\n+        return Math.max(\n+                0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n+    }\n+\n+    public int unsynchronizedGetFloatingBuffersAvailable() {\n+        return Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n+    }\n+\n+    public InputChannelID getInputChannelId() {\n+        return id;\n+    }\n+\n+    public int getInitialCredit() {\n+        return initialCredit;\n+    }\n+\n+    public BufferProvider getBufferProvider() throws IOException {\n+        if (isReleased.get()) {\n+            return null;\n+        }\n+\n+        return inputGate.getBufferProvider();\n+    }\n+\n+    /**\n+     * Requests buffer from input channel directly for receiving network data. It should always\n+     * return an available buffer in credit-based mode unless the channel has been released.\n+     *\n+     * @return The available buffer.\n+     */\n+    @Nullable\n+    public Buffer requestBuffer() {\n+        return bufferManager.requestBuffer(initialCredit);\n+    }\n+\n+    /**\n+     * Receives the backlog from the producer's buffer response. If the number of available buffers\n+     * is less than backlog + initialCredit, it will request floating buffers from the buffer\n+     * manager, and then notify unannounced credits to the producer.\n+     *\n+     * @param backlog The number of unsent buffers in the producer's sub partition.\n+     */\n+    public void onSenderBacklog(int backlog) throws IOException {\n+        // never allocate any new buffers if upstream has been blocked\n+        if (!isUpstreamBlocked) {\n+            notifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+        }\n+    }\n+\n+    public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n+        boolean recycleBuffer = true;\n+\n+        try {\n+            if (expectedSequenceNumber != sequenceNumber) {\n+                onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                return;\n+            }\n+\n+            final boolean wasEmpty;\n+            boolean firstPriorityEvent = false;\n+            synchronized (receivedBuffers) {\n+                NetworkActionsLogger.traceInput(\n+                        \"RemoteInputChannel#onBuffer\",\n+                        buffer,\n+                        inputGate.getOwningTaskName(),\n+                        channelInfo,\n+                        channelStatePersister,\n+                        sequenceNumber);\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after releaseAllResources() released all buffers from receivedBuffers\n+                // (see above for details).\n+                if (isReleased.get()) {\n+                    return;\n+                }\n+\n+                wasEmpty = receivedBuffers.isEmpty();\n+\n+                SequenceBuffer sequenceBuffer = new SequenceBuffer(buffer, sequenceNumber);\n+                DataType dataType = buffer.getDataType();\n+                if (dataType.hasPriority()) {\n+                    firstPriorityEvent = addPriorityBuffer(sequenceBuffer);\n+                } else {\n+                    receivedBuffers.add(sequenceBuffer);\n+                    if (dataType.requiresAnnouncement()) {\n+                        firstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n+                    }\n+                }\n+                channelStatePersister\n+                        .checkForBarrier(sequenceBuffer.buffer)\n+                        .filter(id -> id > lastBarrierId)\n+                        .ifPresent(\n+                                id -> {\n+                                    // checkpoint was not yet started by task thread,\n+                                    // so remember the numbers of buffers to spill for the time when\n+                                    // it will be started\n+                                    lastBarrierId = id;\n+                                    lastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+                                });\n+                channelStatePersister.maybePersist(buffer);\n+                ++expectedSequenceNumber;\n+            }\n+            recycleBuffer = false;\n+\n+            if (firstPriorityEvent) {\n+                notifyPriorityEvent(sequenceNumber);\n+            }\n+            if (wasEmpty) {\n+                notifyChannelNonEmpty();\n+            }\n+\n+            if (backlog >= 0) {\n+                onSenderBacklog(backlog);\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+            }\n+        } finally {\n+            if (recycleBuffer) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+    }\n+\n+    /** @return {@code true} if this was first priority buffer added. */\n+    private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) {\n+        receivedBuffers.addPriorityElement(sequenceBuffer);\n+        return receivedBuffers.getNumPriorityElements() == 1;\n+    }\n+\n+    private SequenceBuffer announce(SequenceBuffer sequenceBuffer) throws IOException {\n+        checkState(\n+                !sequenceBuffer.buffer.isBuffer(),\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        checkAnnouncedOnlyOnce(sequenceBuffer);\n+        AbstractEvent event =\n+                EventSerializer.fromBuffer(sequenceBuffer.buffer, getClass().getClassLoader());\n+        checkState(\n+                event instanceof CheckpointBarrier,\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        CheckpointBarrier barrier = (CheckpointBarrier) event;\n+        return new SequenceBuffer(\n+                EventSerializer.toBuffer(\n+                        new EventAnnouncement(barrier, sequenceBuffer.sequenceNumber), true),\n+                sequenceBuffer.sequenceNumber);\n+    }\n+\n+    private void checkAnnouncedOnlyOnce(SequenceBuffer sequenceBuffer) {\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        int count = 0;\n+        while (iterator.hasNext()) {\n+            if (iterator.next().sequenceNumber == sequenceBuffer.sequenceNumber) {\n+                count++;\n+            }\n+        }\n+        checkState(\n+                count == 1,\n+                \"Before enqueuing the announcement there should be exactly single occurrence of the buffer, but found [%d]\",\n+                count);\n+    }\n+\n+    /**\n+     * Spills all queued buffers on checkpoint start. If barrier has already been received (and\n+     * reordered), spill only the overtaken buffers.\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {\n+        synchronized (receivedBuffers) {\n+            if (barrier.getId() < lastBarrierId) {\n+                throw new CheckpointException(\n+                        String.format(\n+                                \"Sequence number for checkpoint %d is not known (it was likely been overwritten by a newer checkpoint %d)\",\n+                                barrier.getId(), lastBarrierId),\n+                        CheckpointFailureReason\n+                                .CHECKPOINT_SUBSUMED); // currently, at most one active unaligned\n+                // checkpoint is possible\n+            } else if (barrier.getId() > lastBarrierId) {\n+                // This channel has received some obsolete barrier, older compared to the\n+                // checkpointId\n+                // which we are processing right now, and we should ignore that obsoleted checkpoint\n+                // barrier sequence number.\n+                resetLastBarrier();\n+            }\n+\n+            channelStatePersister.startPersisting(\n+                    barrier.getId(), getInflightBuffersUnsafe(barrier.getId()));\n+        }\n+    }\n+\n+    public void checkpointStopped(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            channelStatePersister.stopPersisting(checkpointId);\n+            if (lastBarrierId == checkpointId) {\n+                resetLastBarrier();\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    List<Buffer> getInflightBuffers(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            return getInflightBuffersUnsafe(checkpointId);\n+        }\n+    }\n+\n+    @Override\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n+        boolean firstPriorityEvent;\n+        synchronized (receivedBuffers) {\n+            checkState(channelStatePersister.hasBarrierReceived());\n+            int numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n+            SequenceBuffer toPrioritize =\n+                    receivedBuffers.getAndRemove(\n+                            sequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n+            checkState(lastBarrierSequenceNumber == sequenceNumber);\n+            checkState(!toPrioritize.buffer.isBuffer());\n+            checkState(\n+                    numPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n+                    \"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n+                    toPrioritize,\n+                    numPriorityElementsBeforeRemoval);\n+            // set the priority flag (checked on poll)\n+            // don't convert the barrier itself (barrier controller might not have been switched\n+            // yet)\n+            AbstractEvent e =\n+                    EventSerializer.fromBuffer(\n+                            toPrioritize.buffer, this.getClass().getClassLoader());\n+            toPrioritize.buffer.setReaderIndex(0);\n+            toPrioritize =\n+                    new SequenceBuffer(\n+                            EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n+            firstPriorityEvent =\n+                    addPriorityBuffer(\n+                            toPrioritize); // note that only position of the element is changed\n+            // converting the event itself would require switching the controller sooner\n+        }\n+        if (firstPriorityEvent) {\n+            notifyPriorityEventForce(); // forcibly notify about the priority event\n+            // instead of passing barrier SQN to be checked\n+            // because this SQN might have be seen by the input gate during the announcement\n+        }\n+    }\n+\n+    private void notifyPriorityEventForce() {\n+        inputGate.notifyPriorityEventForce(this);\n+    }\n+\n+    /**\n+     * Returns a list of buffers, checking the first n non-priority buffers, and skipping all\n+     * events.\n+     */\n+    private List<Buffer> getInflightBuffersUnsafe(long checkpointId) {\n+        assert Thread.holdsLock(receivedBuffers);\n+\n+        checkState(checkpointId == lastBarrierId || lastBarrierId == NONE);\n+\n+        final List<Buffer> inflightBuffers = new ArrayList<>();\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        // skip all priority events (only buffers are stored anyways)\n+        Iterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n+\n+        while (iterator.hasNext()) {\n+            SequenceBuffer sequenceBuffer = iterator.next();\n+            if (sequenceBuffer.buffer.isBuffer()) {\n+                if (shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+                    inflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return inflightBuffers;\n+    }\n+\n+    private void resetLastBarrier() {\n+        lastBarrierId = NONE;\n+        lastBarrierSequenceNumber = NONE;\n+    }\n+\n+    /**\n+     * @return if given {@param sequenceNumber} should be spilled given {@link\n+     *     #lastBarrierSequenceNumber}. We might not have yet received {@link CheckpointBarrier} and\n+     *     we might need to spill everything. If we have already received it, there is a bit nasty\n+     *     corner case of {@link SequenceBuffer#sequenceNumber} overflowing that needs to be handled\n+     *     as well.\n+     */\n+    private boolean shouldBeSpilled(int sequenceNumber) {\n+        if (lastBarrierSequenceNumber == NONE) {\n+            return true;\n+        }\n+        checkState(\n+                receivedBuffers.size() < Integer.MAX_VALUE / 2,\n+                \"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+        boolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastBarrierSequenceNumber;\n+        boolean possibleOverflowBeforeOvertaking =\n+                lastBarrierSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+        if (possibleOverflowAfterOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber && sequenceNumber > 0;\n+        } else if (possibleOverflowBeforeOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber || sequenceNumber > 0;\n+        } else {\n+            return sequenceNumber < lastBarrierSequenceNumber;\n+        }\n+    }\n+\n+    public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n+        boolean success = false;\n+\n+        synchronized (receivedBuffers) {\n+            if (!isReleased.get()) {\n+                if (expectedSequenceNumber == sequenceNumber) {\n+                    expectedSequenceNumber++;\n+                    success = true;\n+                } else {\n+                    onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                }\n+            }\n+        }\n+\n+        if (success && backlog >= 0) {\n+            onSenderBacklog(backlog);\n+        }\n+    }\n+\n+    public void onFailedPartitionRequest() {\n+        inputGate.triggerPartitionStateCheck(partitionId);\n+    }\n+\n+    public void onError(Throwable cause) {\n+        setError(cause);\n+    }\n+\n+    private void checkPartitionRequestQueueInitialized() throws IOException {\n+        checkError();\n+        checkState(\n+                partitionRequestClient != null,\n+                \"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n+    }\n+\n+    private static class BufferReorderingException extends IOException {\n+\n+        private static final long serialVersionUID = -888282210356266816L;\n+\n+        private final int expectedSequenceNumber;\n+\n+        private final int actualSequenceNumber;\n+\n+        BufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n+            this.expectedSequenceNumber = expectedSequenceNumber;\n+            this.actualSequenceNumber = actualSequenceNumber;\n+        }\n+\n+        @Override\n+        public String getMessage() {\n+            return String.format(\n+                    \"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n+                    expectedSequenceNumber, actualSequenceNumber);\n+        }\n+    }\n+\n+    private static final class SequenceBuffer {\n+        final Buffer buffer;\n+        final int sequenceNumber;\n+\n+        private SequenceBuffer(Buffer buffer, int sequenceNumber) {\n+            this.buffer = buffer;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\n+                    \"SequenceBuffer(isEvent = %s, dataType = %s, sequenceNumber = %s)\",\n+                    !buffer.isBuffer(), buffer.getDataType(), sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 2cbd3801b56..f9cedf71105 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -20,520 +20,798 @@ package org.apache.flink.runtime.io.network.partition.consumer;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.checkpoint.CheckpointException;\n+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;\n import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;\n+import org.apache.flink.runtime.event.AbstractEvent;\n import org.apache.flink.runtime.event.TaskEvent;\n+import org.apache.flink.runtime.execution.CancelTaskException;\n import org.apache.flink.runtime.io.network.ConnectionID;\n import org.apache.flink.runtime.io.network.ConnectionManager;\n import org.apache.flink.runtime.io.network.PartitionRequestClient;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+import org.apache.flink.runtime.io.network.api.EventAnnouncement;\n+import org.apache.flink.runtime.io.network.api.serialization.EventSerializer;\n import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.Buffer.DataType;\n import org.apache.flink.runtime.io.network.buffer.BufferProvider;\n-import org.apache.flink.runtime.io.network.buffer.BufferReceivedListener;\n-import org.apache.flink.runtime.io.network.netty.NettyMessage;\n+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;\n import org.apache.flink.runtime.io.network.partition.PartitionNotFoundException;\n+import org.apache.flink.runtime.io.network.partition.PrioritizedDeque;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n \n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterators;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n-/**\n- * An input channel, which requests a remote partition queue.\n- */\n+/** An input channel, which requests a remote partition queue. */\n public class RemoteInputChannel extends InputChannel {\n-\n-\t/** ID to distinguish this channel from other channels sharing the same TCP connection. */\n-\tprivate final InputChannelID id = new InputChannelID();\n-\n-\t/** The connection to use to request the remote partition. */\n-\tprivate final ConnectionID connectionId;\n-\n-\t/** The connection manager to use connect to the remote partition provider. */\n-\tprivate final ConnectionManager connectionManager;\n-\n-\t/**\n-\t * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n-\t * is consumed by the receiving task thread.\n-\t */\n-\tprivate final ArrayDeque<Buffer> receivedBuffers = new ArrayDeque<>();\n-\n-\t/**\n-\t * Flag indicating whether this channel has been released. Either called by the receiving task\n-\t * thread or the task manager actor.\n-\t */\n-\tprivate final AtomicBoolean isReleased = new AtomicBoolean();\n-\n-\t/** Client to establish a (possibly shared) TCP connection and request the partition. */\n-\tprivate volatile PartitionRequestClient partitionRequestClient;\n-\n-\t/**\n-\t * The next expected sequence number for the next buffer. This is modified by the network\n-\t * I/O thread only.\n-\t */\n-\tprivate int expectedSequenceNumber = 0;\n-\n-\t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate final int initialCredit;\n-\n-\t/** The number of available buffers that have not been announced to the producer yet. */\n-\tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n-\n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n-\n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n-\n-\tprivate final BufferManager bufferManager;\n-\n-\tpublic RemoteInputChannel(\n-\t\tSingleInputGate inputGate,\n-\t\tint channelIndex,\n-\t\tResultPartitionID partitionId,\n-\t\tConnectionID connectionId,\n-\t\tConnectionManager connectionManager,\n-\t\tint initialBackOff,\n-\t\tint maxBackoff,\n-\t\tint networkBuffersPerChannel,\n-\t\tCounter numBytesIn,\n-\t\tCounter numBuffersIn) {\n-\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, numBytesIn, numBuffersIn);\n-\n-\t\tthis.initialCredit = networkBuffersPerChannel;\n-\t\tthis.connectionId = checkNotNull(connectionId);\n-\t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n-\t}\n-\n-\t/**\n-\t * Assigns exclusive buffers to this input channel, and this method should be called only once\n-\t * after this input channel is created.\n-\t */\n-\tvoid assignExclusiveSegments() throws IOException {\n-\t\tbufferManager.requestExclusiveBuffers();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests a remote subpartition.\n-\t */\n-\t@VisibleForTesting\n-\t@Override\n-\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n-\t\tif (partitionRequestClient == null) {\n-\t\t\t// Create a client and request the partition\n-\t\t\ttry {\n-\t\t\t\tpartitionRequestClient = connectionManager.createPartitionRequestClient(connectionId);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\t// IOExceptions indicate that we could not open a connection to the remote TaskExecutor\n-\t\t\t\tthrow new PartitionConnectionException(partitionId, e);\n-\t\t\t}\n-\n-\t\t\tpartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Retriggers a remote subpartition request.\n-\t */\n-\tvoid retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n-\t\tcheckState(partitionRequestClient != null, \"Missing initial subpartition request.\");\n-\n-\t\tif (increaseBackoff()) {\n-\t\t\tpartitionRequestClient.requestSubpartition(\n-\t\t\t\tpartitionId, subpartitionIndex, this, getCurrentBackoff());\n-\t\t} else {\n-\t\t\tfailPartitionRequest();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tOptional<BufferAndAvailability> getNextBuffer() throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Queried for a buffer after channel has been closed.\");\n-\t\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tfinal Buffer next;\n-\t\tfinal boolean moreAvailable;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tnext = receivedBuffers.poll();\n-\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n-\t\t}\n-\n-\t\tnumBytesIn.inc(next.getSize());\n-\t\tnumBuffersIn.inc();\n-\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable));\n-\t}\n-\n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlastRequestedCheckpointId = checkpointId;\n-\n-\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\tcheckpointId,\n-\t\t\t\tchannelInfo,\n-\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tvoid sendTaskEvent(TaskEvent event) throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Tried to send task event to producer after channel has been released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tpartitionRequestClient.sendTaskEvent(partitionId, event, this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n-\t}\n-\n-\t/**\n-\t * Releases all exclusive and floating buffers, closes the partition request client.\n-\t */\n-\t@Override\n-\tvoid releaseAllResources() throws IOException {\n-\t\tif (isReleased.compareAndSet(false, true)) {\n-\n-\t\t\tArrayDeque<Buffer> releasedBuffers;\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\treleasedBuffers = receivedBuffers;\n-\t\t\t}\n-\t\t\tbufferManager.releaseAllBuffers(releasedBuffers);\n-\n-\t\t\t// The released flag has to be set before closing the connection to ensure that\n-\t\t\t// buffers received concurrently with closing are properly recycled.\n-\t\t\tif (partitionRequestClient != null) {\n-\t\t\t\tpartitionRequestClient.close(this);\n-\t\t\t} else {\n-\t\t\t\tconnectionManager.closeOpenChannelConnections(connectionId);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void failPartitionRequest() {\n-\t\tsetError(new PartitionNotFoundException(partitionId));\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Credit-based\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n-\t */\n-\tprivate void notifyCreditAvailable() {\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tpartitionRequestClient.notifyCreditAvailable(this);\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfAvailableBuffers() {\n-\t\treturn bufferManager.getNumberOfAvailableBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\treturn bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n-\t}\n-\n-\t@VisibleForTesting\n-\tBufferManager getBufferManager() {\n-\t\treturn bufferManager;\n-\t}\n-\n-\t@VisibleForTesting\n-\tPartitionRequestClient getPartitionRequestClient() {\n-\t\treturn partitionRequestClient;\n-\t}\n-\n-\t/**\n-\t * The unannounced credit is increased by the given amount and might notify\n-\t * increased credit to the producer.\n-\t */\n-\t@Override\n-\tpublic void notifyBufferAvailable(int numAvailableBuffers) {\n-\t\tif (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tbufferManager.onCheckpointBarrier(barrier, initialCredit);\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption() {\n-\t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n-\n-\t\t// notifies the producer that this channel is ready to\n-\t\t// unblock from checkpoint and resume data consumption\n-\t\tpartitionRequestClient.resumeConsumption(this);\n-\t}\n-\n-\t/**\n-\t * Called by netty thread to request buffers and generate {@link NettyMessage.ResumeConsumption} message.\n-\t */\n-\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage() throws IOException {\n-\t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n-\n-\t\treturn bufferManager.resumeAndGetResumptionMessage(id, initialCredit);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network I/O notifications (called by network I/O thread)\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Gets the currently unannounced credit.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getUnannouncedCredit() {\n-\t\treturn unannouncedCredit.get();\n-\t}\n-\n-\t/**\n-\t * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n-\t}\n-\n-\t/**\n-\t * Gets the current number of received buffers which have not been processed yet.\n-\t *\n-\t * @return Buffers queued for processing.\n-\t */\n-\tpublic int getNumberOfQueuedBuffers() {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treturn receivedBuffers.size();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn Math.max(0, receivedBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferManager.unsynchronizedGetExclusiveBuffersUsed());\n-\t}\n-\n-\tpublic int unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n-\t}\n-\n-\tpublic InputChannelID getInputChannelId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic int getInitialCredit() {\n-\t\treturn initialCredit;\n-\t}\n-\n-\tpublic BufferProvider getBufferProvider() throws IOException {\n-\t\tif (isReleased.get()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn inputGate.getBufferProvider();\n-\t}\n-\n-\t/**\n-\t * Requests buffer from input channel directly for receiving network data.\n-\t * It should always return an available buffer in credit-based mode unless\n-\t * the channel has been released.\n-\t *\n-\t * @return The available buffer.\n-\t */\n-\t@Nullable\n-\tpublic Buffer requestBuffer() {\n-\t\treturn bufferManager.requestBuffer();\n-\t}\n-\n-\t/**\n-\t * Receives the backlog from the producer's buffer response. If the number of available\n-\t * buffers is less than backlog + initialCredit, it will request floating buffers from\n-\t * the buffer manager, and then notify unannounced credits to the producer.\n-\t *\n-\t * @param backlog The number of unsent buffers in the producer's sub partition.\n-\t */\n-\tpublic void onSenderBacklog(int backlog) throws IOException {\n-\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));\n-\t}\n-\n-\tpublic void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean recycleBuffer = true;\n-\n-\t\ttry {\n-\t\t\tif (expectedSequenceNumber != sequenceNumber) {\n-\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tfinal boolean wasEmpty;\n-\t\t\tfinal CheckpointBarrier notifyReceivedBarrier;\n-\t\t\tfinal Buffer notifyReceivedBuffer;\n-\t\t\tfinal BufferReceivedListener listener = inputGate.getBufferReceivedListener();\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after releaseAllResources() released all buffers from receivedBuffers\n-\t\t\t\t// (see above for details).\n-\t\t\t\tif (isReleased.get()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n-\n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n-\t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n-\t\t\t}\n-\t\t\trecycleBuffer = false;\n-\n-\t\t\t++expectedSequenceNumber;\n-\n-\t\t\tif (wasEmpty) {\n-\t\t\t\tnotifyChannelNonEmpty();\n-\t\t\t}\n-\n-\t\t\tif (backlog >= 0) {\n-\t\t\t\tonSenderBacklog(backlog);\n-\t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n-\n-\t\t\tCheckpointBarrier barrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\tif (barrier != null) {\n-\t\t\t\tonCheckpointBarrier(barrier);\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tif (recycleBuffer) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean success = false;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tif (!isReleased.get()) {\n-\t\t\t\tif (expectedSequenceNumber == sequenceNumber) {\n-\t\t\t\t\texpectedSequenceNumber++;\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t} else {\n-\t\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (success && backlog >= 0) {\n-\t\t\tonSenderBacklog(backlog);\n-\t\t}\n-\t}\n-\n-\tpublic void onFailedPartitionRequest() {\n-\t\tinputGate.triggerPartitionStateCheck(partitionId);\n-\t}\n-\n-\tpublic void onError(Throwable cause) {\n-\t\tsetError(cause);\n-\t}\n-\n-\tprivate static class BufferReorderingException extends IOException {\n-\n-\t\tprivate static final long serialVersionUID = -888282210356266816L;\n-\n-\t\tprivate final int expectedSequenceNumber;\n-\n-\t\tprivate final int actualSequenceNumber;\n-\n-\t\tBufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n-\t\t\tthis.expectedSequenceNumber = expectedSequenceNumber;\n-\t\t\tthis.actualSequenceNumber = actualSequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String getMessage() {\n-\t\t\treturn String.format(\"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n-\t\t\t\texpectedSequenceNumber, actualSequenceNumber);\n-\t\t}\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(RemoteInputChannel.class);\n+\n+    private static final int NONE = -1;\n+\n+    /** ID to distinguish this channel from other channels sharing the same TCP connection. */\n+    private final InputChannelID id = new InputChannelID();\n+\n+    /** The connection to use to request the remote partition. */\n+    private final ConnectionID connectionId;\n+\n+    /** The connection manager to use connect to the remote partition provider. */\n+    private final ConnectionManager connectionManager;\n+\n+    /**\n+     * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n+     * is consumed by the receiving task thread.\n+     */\n+    private final PrioritizedDeque<SequenceBuffer> receivedBuffers = new PrioritizedDeque<>();\n+\n+    /**\n+     * Flag indicating whether this channel has been released. Either called by the receiving task\n+     * thread or the task manager actor.\n+     */\n+    private final AtomicBoolean isReleased = new AtomicBoolean();\n+\n+    /** Client to establish a (possibly shared) TCP connection and request the partition. */\n+    private volatile PartitionRequestClient partitionRequestClient;\n+\n+    /** The next expected sequence number for the next buffer. */\n+    private int expectedSequenceNumber = 0;\n+\n+    /** The initial number of exclusive buffers assigned to this channel. */\n+    private final int initialCredit;\n+\n+    /** The number of available buffers that have not been announced to the producer yet. */\n+    private final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n+\n+    private final BufferManager bufferManager;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private int lastBarrierSequenceNumber = NONE;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private long lastBarrierId = NONE;\n+\n+    private final ChannelStatePersister channelStatePersister;\n+\n+    public RemoteInputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            ConnectionID connectionId,\n+            ConnectionManager connectionManager,\n+            int initialBackOff,\n+            int maxBackoff,\n+            int networkBuffersPerChannel,\n+            Counter numBytesIn,\n+            Counter numBuffersIn,\n+            ChannelStateWriter stateWriter) {\n+\n+        super(\n+                inputGate,\n+                channelIndex,\n+                partitionId,\n+                initialBackOff,\n+                maxBackoff,\n+                numBytesIn,\n+                numBuffersIn);\n+        checkArgument(networkBuffersPerChannel >= 0, \"Must be non-negative.\");\n+\n+        this.initialCredit = networkBuffersPerChannel;\n+        this.connectionId = checkNotNull(connectionId);\n+        this.connectionManager = checkNotNull(connectionManager);\n+        this.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n+        this.channelStatePersister = new ChannelStatePersister(stateWriter, getChannelInfo());\n+    }\n+\n+    @VisibleForTesting\n+    void setExpectedSequenceNumber(int expectedSequenceNumber) {\n+        this.expectedSequenceNumber = expectedSequenceNumber;\n+    }\n+\n+    /**\n+     * Setup includes assigning exclusive buffers to this input channel, and this method should be\n+     * called only once after this input channel is created.\n+     */\n+    @Override\n+    void setup() throws IOException {\n+        checkState(\n+                bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+                \"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n+\n+        bufferManager.requestExclusiveBuffers(initialCredit);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /** Requests a remote subpartition. */\n+    @VisibleForTesting\n+    @Override\n+    public void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException {\n+        if (partitionRequestClient == null) {\n+            LOG.debug(\n+                    \"{}: Requesting REMOTE subpartition {} of partition {}. {}\",\n+                    this,\n+                    subpartitionIndex,\n+                    partitionId,\n+                    channelStatePersister);\n+            // Create a client and request the partition\n+            try {\n+                partitionRequestClient =\n+                        connectionManager.createPartitionRequestClient(connectionId);\n+            } catch (IOException e) {\n+                // IOExceptions indicate that we could not open a connection to the remote\n+                // TaskExecutor\n+                throw new PartitionConnectionException(partitionId, e);\n+            }\n+\n+            partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n+        }\n+    }\n+\n+    /** Retriggers a remote subpartition request. */\n+    void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (increaseBackoff()) {\n+            partitionRequestClient.requestSubpartition(\n+                    partitionId, subpartitionIndex, this, getCurrentBackoff());\n+        } else {\n+            failPartitionRequest();\n+        }\n+    }\n+\n+    @Override\n+    Optional<BufferAndAvailability> getNextBuffer() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        final SequenceBuffer next;\n+        final DataType nextDataType;\n+\n+        synchronized (receivedBuffers) {\n+            next = receivedBuffers.poll();\n+            nextDataType =\n+                    receivedBuffers.peek() != null\n+                            ? receivedBuffers.peek().buffer.getDataType()\n+                            : DataType.NONE;\n+        }\n+\n+        if (next == null) {\n+            if (isReleased.get()) {\n+                throw new CancelTaskException(\n+                        \"Queried for a buffer after channel has been released.\");\n+            }\n+            return Optional.empty();\n+        }\n+\n+        NetworkActionsLogger.traceInput(\n+                \"RemoteInputChannel#getNextBuffer\",\n+                next.buffer,\n+                inputGate.getOwningTaskName(),\n+                channelInfo,\n+                channelStatePersister,\n+                next.sequenceNumber);\n+        numBytesIn.inc(next.buffer.getSize());\n+        numBuffersIn.inc();\n+        return Optional.of(\n+                new BufferAndAvailability(next.buffer, nextDataType, 0, next.sequenceNumber));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    void sendTaskEvent(TaskEvent event) throws IOException {\n+        checkState(\n+                !isReleased.get(),\n+                \"Tried to send task event to producer after channel has been released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.sendTaskEvent(partitionId, event, this);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased.get();\n+    }\n+\n+    /** Releases all exclusive and floating buffers, closes the partition request client. */\n+    @Override\n+    void releaseAllResources() throws IOException {\n+        if (isReleased.compareAndSet(false, true)) {\n+\n+            final ArrayDeque<Buffer> releasedBuffers;\n+            synchronized (receivedBuffers) {\n+                releasedBuffers =\n+                        receivedBuffers.stream()\n+                                .map(sb -> sb.buffer)\n+                                .collect(Collectors.toCollection(ArrayDeque::new));\n+                receivedBuffers.clear();\n+            }\n+            bufferManager.releaseAllBuffers(releasedBuffers);\n+\n+            // The released flag has to be set before closing the connection to ensure that\n+            // buffers received concurrently with closing are properly recycled.\n+            if (partitionRequestClient != null) {\n+                partitionRequestClient.close(this);\n+            } else {\n+                connectionManager.closeOpenChannelConnections(connectionId);\n+            }\n+        }\n+    }\n+\n+    private void failPartitionRequest() {\n+        setError(new PartitionNotFoundException(partitionId));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Credit-based\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n+     */\n+    private void notifyCreditAvailable() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.notifyCreditAvailable(this);\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfAvailableBuffers() {\n+        return bufferManager.getNumberOfAvailableBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfRequiredBuffers() {\n+        return bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getSenderBacklog() {\n+        return getNumberOfRequiredBuffers() - initialCredit;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isWaitingForFloatingBuffers() {\n+        return bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public Buffer getNextReceivedBuffer() {\n+        final SequenceBuffer sequenceBuffer = receivedBuffers.poll();\n+        return sequenceBuffer != null ? sequenceBuffer.buffer : null;\n+    }\n+\n+    @VisibleForTesting\n+    BufferManager getBufferManager() {\n+        return bufferManager;\n+    }\n+\n+    @VisibleForTesting\n+    PartitionRequestClient getPartitionRequestClient() {\n+        return partitionRequestClient;\n+    }\n+\n+    /**\n+     * The unannounced credit is increased by the given amount and might notify increased credit to\n+     * the producer.\n+     */\n+    @Override\n+    public void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n+        if (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+            notifyCreditAvailable();\n+        }\n+    }\n+\n+    @Override\n+    public void resumeConsumption() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (initialCredit == 0) {\n+            // this unannounced credit can be a positive value because credit assignment and the\n+            // increase of this value is not an atomic operation and as a result, this unannounced\n+            // credit value can be get increased even after this channel has been blocked and all\n+            // floating credits are released, it is important to clear this unannounced credit and\n+            // at the same time reset the sender's available credits to keep consistency\n+            unannouncedCredit.set(0);\n+        }\n+\n+        // notifies the producer that this channel is ready to\n+        // unblock from checkpoint and resume data consumption\n+        partitionRequestClient.resumeConsumption(this);\n+    }\n+\n+    @Override\n+    public void acknowledgeAllRecordsProcessed() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.acknowledgeAllRecordsProcessed(this);\n+    }\n+\n+    private void onBlockingUpstream() {\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network I/O notifications (called by network I/O thread)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the currently unannounced credit.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getUnannouncedCredit() {\n+        return unannouncedCredit.get();\n+    }\n+\n+    /**\n+     * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getAndResetUnannouncedCredit() {\n+        return unannouncedCredit.getAndSet(0);\n+    }\n+\n+    /**\n+     * Gets the current number of received buffers which have not been processed yet.\n+     *\n+     * @return Buffers queued for processing.\n+     */\n+    public int getNumberOfQueuedBuffers() {\n+        synchronized (receivedBuffers) {\n+            return receivedBuffers.size();\n+        }\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return Math.max(0, receivedBuffers.size());\n+    }\n+\n+    public int unsynchronizedGetExclusiveBuffersUsed() {\n+        return Math.max(\n+                0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n+    }\n+\n+    public int unsynchronizedGetFloatingBuffersAvailable() {\n+        return Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n+    }\n+\n+    public InputChannelID getInputChannelId() {\n+        return id;\n+    }\n+\n+    public int getInitialCredit() {\n+        return initialCredit;\n+    }\n+\n+    public BufferProvider getBufferProvider() throws IOException {\n+        if (isReleased.get()) {\n+            return null;\n+        }\n+\n+        return inputGate.getBufferProvider();\n+    }\n+\n+    /**\n+     * Requests buffer from input channel directly for receiving network data. It should always\n+     * return an available buffer in credit-based mode unless the channel has been released.\n+     *\n+     * @return The available buffer.\n+     */\n+    @Nullable\n+    public Buffer requestBuffer() {\n+        return bufferManager.requestBuffer();\n+    }\n+\n+    /**\n+     * Receives the backlog from the producer's buffer response. If the number of available buffers\n+     * is less than backlog + initialCredit, it will request floating buffers from the buffer\n+     * manager, and then notify unannounced credits to the producer.\n+     *\n+     * @param backlog The number of unsent buffers in the producer's sub partition.\n+     */\n+    public void onSenderBacklog(int backlog) throws IOException {\n+        notifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+    }\n+\n+    /**\n+     * Handles the input buffer. This method is taking over the ownership of the buffer and is fully\n+     * responsible for cleaning it up both on the happy path and in case of an error.\n+     */\n+    public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n+        boolean recycleBuffer = true;\n+\n+        try {\n+            if (expectedSequenceNumber != sequenceNumber) {\n+                onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                return;\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+                checkArgument(backlog == 0, \"Illegal number of backlog: %s, should be 0.\", backlog);\n+            }\n+\n+            final boolean wasEmpty;\n+            boolean firstPriorityEvent = false;\n+            synchronized (receivedBuffers) {\n+                NetworkActionsLogger.traceInput(\n+                        \"RemoteInputChannel#onBuffer\",\n+                        buffer,\n+                        inputGate.getOwningTaskName(),\n+                        channelInfo,\n+                        channelStatePersister,\n+                        sequenceNumber);\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after releaseAllResources() released all buffers from receivedBuffers\n+                // (see above for details).\n+                if (isReleased.get()) {\n+                    return;\n+                }\n+\n+                wasEmpty = receivedBuffers.isEmpty();\n+\n+                SequenceBuffer sequenceBuffer = new SequenceBuffer(buffer, sequenceNumber);\n+                DataType dataType = buffer.getDataType();\n+                if (dataType.hasPriority()) {\n+                    firstPriorityEvent = addPriorityBuffer(sequenceBuffer);\n+                    recycleBuffer = false;\n+                } else {\n+                    receivedBuffers.add(sequenceBuffer);\n+                    recycleBuffer = false;\n+                    if (dataType.requiresAnnouncement()) {\n+                        firstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n+                    }\n+                }\n+                channelStatePersister\n+                        .checkForBarrier(sequenceBuffer.buffer)\n+                        .filter(id -> id > lastBarrierId)\n+                        .ifPresent(\n+                                id -> {\n+                                    // checkpoint was not yet started by task thread,\n+                                    // so remember the numbers of buffers to spill for the time when\n+                                    // it will be started\n+                                    lastBarrierId = id;\n+                                    lastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+                                });\n+                channelStatePersister.maybePersist(buffer);\n+                ++expectedSequenceNumber;\n+            }\n+\n+            if (firstPriorityEvent) {\n+                notifyPriorityEvent(sequenceNumber);\n+            }\n+            if (wasEmpty) {\n+                notifyChannelNonEmpty();\n+            }\n+\n+            if (backlog >= 0) {\n+                onSenderBacklog(backlog);\n+            }\n+        } finally {\n+            if (recycleBuffer) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+    }\n+\n+    /** @return {@code true} if this was first priority buffer added. */\n+    private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) {\n+        receivedBuffers.addPriorityElement(sequenceBuffer);\n+        return receivedBuffers.getNumPriorityElements() == 1;\n+    }\n+\n+    private SequenceBuffer announce(SequenceBuffer sequenceBuffer) throws IOException {\n+        checkState(\n+                !sequenceBuffer.buffer.isBuffer(),\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        checkAnnouncedOnlyOnce(sequenceBuffer);\n+        AbstractEvent event =\n+                EventSerializer.fromBuffer(sequenceBuffer.buffer, getClass().getClassLoader());\n+        checkState(\n+                event instanceof CheckpointBarrier,\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        CheckpointBarrier barrier = (CheckpointBarrier) event;\n+        return new SequenceBuffer(\n+                EventSerializer.toBuffer(\n+                        new EventAnnouncement(barrier, sequenceBuffer.sequenceNumber), true),\n+                sequenceBuffer.sequenceNumber);\n+    }\n+\n+    private void checkAnnouncedOnlyOnce(SequenceBuffer sequenceBuffer) {\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        int count = 0;\n+        while (iterator.hasNext()) {\n+            if (iterator.next().sequenceNumber == sequenceBuffer.sequenceNumber) {\n+                count++;\n+            }\n+        }\n+        checkState(\n+                count == 1,\n+                \"Before enqueuing the announcement there should be exactly single occurrence of the buffer, but found [%d]\",\n+                count);\n+    }\n+\n+    /**\n+     * Spills all queued buffers on checkpoint start. If barrier has already been received (and\n+     * reordered), spill only the overtaken buffers.\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {\n+        synchronized (receivedBuffers) {\n+            if (barrier.getId() < lastBarrierId) {\n+                throw new CheckpointException(\n+                        String.format(\n+                                \"Sequence number for checkpoint %d is not known (it was likely been overwritten by a newer checkpoint %d)\",\n+                                barrier.getId(), lastBarrierId),\n+                        CheckpointFailureReason\n+                                .CHECKPOINT_SUBSUMED); // currently, at most one active unaligned\n+                // checkpoint is possible\n+            } else if (barrier.getId() > lastBarrierId) {\n+                // This channel has received some obsolete barrier, older compared to the\n+                // checkpointId\n+                // which we are processing right now, and we should ignore that obsoleted checkpoint\n+                // barrier sequence number.\n+                resetLastBarrier();\n+            }\n+\n+            channelStatePersister.startPersisting(\n+                    barrier.getId(), getInflightBuffersUnsafe(barrier.getId()));\n+        }\n+    }\n+\n+    public void checkpointStopped(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            channelStatePersister.stopPersisting(checkpointId);\n+            if (lastBarrierId == checkpointId) {\n+                resetLastBarrier();\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    List<Buffer> getInflightBuffers(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            return getInflightBuffersUnsafe(checkpointId);\n+        }\n+    }\n+\n+    @Override\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n+        boolean firstPriorityEvent;\n+        synchronized (receivedBuffers) {\n+            checkState(channelStatePersister.hasBarrierReceived());\n+            int numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n+            SequenceBuffer toPrioritize =\n+                    receivedBuffers.getAndRemove(\n+                            sequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n+            checkState(lastBarrierSequenceNumber == sequenceNumber);\n+            checkState(!toPrioritize.buffer.isBuffer());\n+            checkState(\n+                    numPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n+                    \"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n+                    toPrioritize,\n+                    numPriorityElementsBeforeRemoval);\n+            // set the priority flag (checked on poll)\n+            // don't convert the barrier itself (barrier controller might not have been switched\n+            // yet)\n+            AbstractEvent e =\n+                    EventSerializer.fromBuffer(\n+                            toPrioritize.buffer, this.getClass().getClassLoader());\n+            toPrioritize.buffer.setReaderIndex(0);\n+            toPrioritize =\n+                    new SequenceBuffer(\n+                            EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n+            firstPriorityEvent =\n+                    addPriorityBuffer(\n+                            toPrioritize); // note that only position of the element is changed\n+            // converting the event itself would require switching the controller sooner\n+        }\n+        if (firstPriorityEvent) {\n+            notifyPriorityEventForce(); // forcibly notify about the priority event\n+            // instead of passing barrier SQN to be checked\n+            // because this SQN might have be seen by the input gate during the announcement\n+        }\n+    }\n+\n+    private void notifyPriorityEventForce() {\n+        inputGate.notifyPriorityEventForce(this);\n+    }\n+\n+    /**\n+     * Returns a list of buffers, checking the first n non-priority buffers, and skipping all\n+     * events.\n+     */\n+    private List<Buffer> getInflightBuffersUnsafe(long checkpointId) {\n+        assert Thread.holdsLock(receivedBuffers);\n+\n+        checkState(checkpointId == lastBarrierId || lastBarrierId == NONE);\n+\n+        final List<Buffer> inflightBuffers = new ArrayList<>();\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        // skip all priority events (only buffers are stored anyways)\n+        Iterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n+\n+        while (iterator.hasNext()) {\n+            SequenceBuffer sequenceBuffer = iterator.next();\n+            if (sequenceBuffer.buffer.isBuffer()) {\n+                if (shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+                    inflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return inflightBuffers;\n+    }\n+\n+    private void resetLastBarrier() {\n+        lastBarrierId = NONE;\n+        lastBarrierSequenceNumber = NONE;\n+    }\n+\n+    /**\n+     * @return if given {@param sequenceNumber} should be spilled given {@link\n+     *     #lastBarrierSequenceNumber}. We might not have yet received {@link CheckpointBarrier} and\n+     *     we might need to spill everything. If we have already received it, there is a bit nasty\n+     *     corner case of {@link SequenceBuffer#sequenceNumber} overflowing that needs to be handled\n+     *     as well.\n+     */\n+    private boolean shouldBeSpilled(int sequenceNumber) {\n+        if (lastBarrierSequenceNumber == NONE) {\n+            return true;\n+        }\n+        checkState(\n+                receivedBuffers.size() < Integer.MAX_VALUE / 2,\n+                \"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+        boolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastBarrierSequenceNumber;\n+        boolean possibleOverflowBeforeOvertaking =\n+                lastBarrierSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+        if (possibleOverflowAfterOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber && sequenceNumber > 0;\n+        } else if (possibleOverflowBeforeOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber || sequenceNumber > 0;\n+        } else {\n+            return sequenceNumber < lastBarrierSequenceNumber;\n+        }\n+    }\n+\n+    public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n+        boolean success = false;\n+\n+        synchronized (receivedBuffers) {\n+            if (!isReleased.get()) {\n+                if (expectedSequenceNumber == sequenceNumber) {\n+                    expectedSequenceNumber++;\n+                    success = true;\n+                } else {\n+                    onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                }\n+            }\n+        }\n+\n+        if (success && backlog >= 0) {\n+            onSenderBacklog(backlog);\n+        }\n+    }\n+\n+    public void onFailedPartitionRequest() {\n+        inputGate.triggerPartitionStateCheck(partitionId);\n+    }\n+\n+    public void onError(Throwable cause) {\n+        setError(cause);\n+    }\n+\n+    private void checkPartitionRequestQueueInitialized() throws IOException {\n+        checkError();\n+        checkState(\n+                partitionRequestClient != null,\n+                \"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n+    }\n+\n+    private static class BufferReorderingException extends IOException {\n+\n+        private static final long serialVersionUID = -888282210356266816L;\n+\n+        private final int expectedSequenceNumber;\n+\n+        private final int actualSequenceNumber;\n+\n+        BufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n+            this.expectedSequenceNumber = expectedSequenceNumber;\n+            this.actualSequenceNumber = actualSequenceNumber;\n+        }\n+\n+        @Override\n+        public String getMessage() {\n+            return String.format(\n+                    \"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n+                    expectedSequenceNumber, actualSequenceNumber);\n+        }\n+    }\n+\n+    private static final class SequenceBuffer {\n+        final Buffer buffer;\n+        final int sequenceNumber;\n+\n+        private SequenceBuffer(Buffer buffer, int sequenceNumber) {\n+            this.buffer = buffer;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\n+                    \"SequenceBuffer(isEvent = %s, dataType = %s, sequenceNumber = %s)\",\n+                    !buffer.isBuffer(), buffer.getDataType(), sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "0ee049db1ffe8a4a68bcd97608774ee488d02a21", "committedDate": "2021-09-03 08:19:32 +0200", "message": "[FLINK-23907] Use primitive functional interfaces"}, {"oid": "138e83e2bc6feb59ecd839b03491cd8f23ee1c66", "committedDate": "2021-11-08 08:56:34 +0100", "message": "[FLINK-24738][runtime] Ignoring buffer size announcement if the channel is released already"}, {"oid": "4eea7bc9352134a06d2b207c9a94dd46a01c6132", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[FLINK-24657][runtime] Added metric of the total real size of input/output buffers queue"}, {"oid": "f4fd4f8bb66867821cb0f171218d85f8386b0897", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] Move consumedSubpartitionIndex from SingleInputGate to InputChannel"}, {"oid": "5c2ec72982128fc1a30014677916e0dd21f9c1d2", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] SingleInputGate supports consuming subpartition range"}, {"oid": "6398abcbff06b3e488a273144680f4838b4f1c92", "committedDate": "2023-06-09 22:48:37 +0800", "message": "[FLINK-31636][network] Introduce the NettyService framework"}]}, {"oid": "59b651c070adcca2b7e4e4a78e6b10411429c589", "url": "https://github.com/apache/flink/commit/59b651c070adcca2b7e4e4a78e6b10411429c589", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-13T10:25:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1MzQzOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424353439", "body": "Actually the logic for adding credit does not need `needAnnounceBacklog`, so it might bring trouble to understand the logic of addCredit by reusing the common codes here.\r\n\r\nOne possible solution is to call `enqueueAvailableReader` in reader stack while applying the function, then the `NetworkSequenceViewReader#addCredit` and `NetworkSequenceViewReader#resumeConsumption` can judge the separate conditions before calling `enqueueAvailableReader`.", "bodyText": "Actually the logic for adding credit does not need needAnnounceBacklog, so it might bring trouble to understand the logic of addCredit by reusing the common codes here.\nOne possible solution is to call enqueueAvailableReader in reader stack while applying the function, then the NetworkSequenceViewReader#addCredit and NetworkSequenceViewReader#resumeConsumption can judge the separate conditions before calling enqueueAvailableReader.", "bodyHTML": "<p dir=\"auto\">Actually the logic for adding credit does not need <code>needAnnounceBacklog</code>, so it might bring trouble to understand the logic of addCredit by reusing the common codes here.</p>\n<p dir=\"auto\">One possible solution is to call <code>enqueueAvailableReader</code> in reader stack while applying the function, then the <code>NetworkSequenceViewReader#addCredit</code> and <code>NetworkSequenceViewReader#resumeConsumption</code> can judge the separate conditions before calling <code>enqueueAvailableReader</code>.</p>", "author": "zhijiangW", "createdAt": "2020-05-13T11:04:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -145,20 +148,20 @@ public void close() throws IOException {\n \t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n \t *\n \t * @param receiverId The input channel id to identify the consumer.\n-\t * @param operation The operation to be performed (add credit or resume data consumption).\n+\t * @param function The operation to be performed (add credit or resume data consumption).\n \t */\n \tvoid addCreditOrResumeConsumption(\n \t\t\tInputChannelID receiverId,\n-\t\t\tConsumer<NetworkSequenceViewReader> operation) throws Exception {\n+\t\t\tFunction<NetworkSequenceViewReader, Boolean> function) throws Exception {\n \t\tif (fatalError) {\n \t\t\treturn;\n \t\t}\n \n \t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n \t\tif (reader != null) {\n-\t\t\toperation.accept(reader);\n+\t\t\tboolean needAnnounceBacklog = function.apply(reader);", "originalCommit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1Mzk0Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424353946", "bodyText": "To do so we can also avoid adjusting to return unnecessary boolean value for NetworkSequenceViewReader#addCredit", "author": "zhijiangW", "createdAt": "2020-05-13T11:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1MzQzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 8cfbd108656..70ec735057f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -148,20 +149,18 @@ public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n \t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n \t *\n \t * @param receiverId The input channel id to identify the consumer.\n-\t * @param function The operation to be performed (add credit or resume data consumption).\n+\t * @param operation The operation to be performed (add credit or resume data consumption).\n \t */\n \tvoid addCreditOrResumeConsumption(\n \t\t\tInputChannelID receiverId,\n-\t\t\tFunction<NetworkSequenceViewReader, Boolean> function) throws Exception {\n+\t\t\tFutureConsumerWithException<NetworkSequenceViewReader, Exception> operation) throws Exception {\n \t\tif (fatalError) {\n \t\t\treturn;\n \t\t}\n \n \t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n \t\tif (reader != null) {\n-\t\t\tboolean needAnnounceBacklog = function.apply(reader);\n-\n-\t\t\tenqueueAvailableReader(reader, needAnnounceBacklog);\n+\t\t\toperation.acceptWithException(reader);\n \t\t} else {\n \t\t\tthrow new IllegalStateException(\"No reader for receiverId = \" + receiverId + \" exists.\");\n \t\t}\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 70ec735057f..df17ef3877c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -42,350 +41,321 @@ import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n \n import static org.apache.flink.runtime.io.network.netty.NettyMessage.BufferResponse;\n-import static org.apache.flink.util.Preconditions.checkArgument;\n-import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n- * A nonEmptyReader of partition queues, which listens for channel writability changed\n- * events before writing and flushing {@link Buffer} instances.\n+ * A nonEmptyReader of partition queues, which listens for channel writability changed events before\n+ * writing and flushing {@link Buffer} instances.\n  */\n-public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n-\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n-\n-\tprivate final ChannelFutureListener writeListener = new WriteAndFlushNextMessageIfPossibleListener();\n-\n-\t/** The readers which are already enqueued available for transferring data or announcing backlog. */\n-\tprivate final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n-\n-\t/** All the readers created for the consumers' partition requests. */\n-\tprivate final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders = new ConcurrentHashMap<>();\n-\n-\tprivate boolean fatalError;\n-\n-\tprivate ChannelHandlerContext ctx;\n-\n-\t@Override\n-\tpublic void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n-\t\tif (this.ctx == null) {\n-\t\t\tthis.ctx = ctx;\n-\t\t}\n-\n-\t\tsuper.channelRegistered(ctx);\n-\t}\n-\n-\tvoid notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n-\t\t// The notification might come from the same thread. For the initial writes this\n-\t\t// might happen before the reader has set its reference to the view, because\n-\t\t// creating the queue and the initial notification happen in the same method call.\n-\t\t// This can be resolved by separating the creation of the view and allowing\n-\t\t// notifications.\n-\n-\t\t// TODO This could potentially have a bad performance impact as in the\n-\t\t// worst case (network consumes faster than the producer) each buffer\n-\t\t// will trigger a separate event loop task being scheduled.\n-\t\tctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n-\t}\n-\n-\t/**\n-\t * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n-\t * non-empty reader notification from the producer.\n-\t *\n-\t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n-\t * availability, so there is no race condition here.\n-\t */\n-\tvoid enqueueAvailableReader(final NetworkSequenceViewReader reader, BooleanSupplier condition) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || !condition.getAsBoolean()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Queue an available reader for consumption. If the queue is empty,\n-\t\t// we try trigger the actual write. Otherwise this will be handled by\n-\t\t// the writeAndFlushNextMessageIfPossible calls.\n-\t\tboolean triggerWrite = availableReaders.isEmpty();\n-\t\tregisterAvailableReader(reader);\n-\n-\t\tif (triggerWrite) {\n-\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Accesses internal state to verify reader registration in the unit tests.\n-\t *\n-\t * <p><strong>Do not use anywhere else!</strong>\n-\t *\n-\t * @return readers which are enqueued available for transferring data or announcing backlog\n-\t */\n-\t@VisibleForTesting\n-\tArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n-\t\treturn availableReaders;\n-\t}\n-\n-\tpublic void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n-\t\tallReaders.put(reader.getReceiverId(), reader);\n-\t}\n-\n-\tpublic void cancel(InputChannelID receiverId) {\n-\t\tctx.pipeline().fireUserEventTriggered(receiverId);\n-\t}\n-\n-\tpublic void close() throws IOException {\n-\t\tif (ctx != null) {\n-\t\t\tctx.channel().close();\n-\t\t}\n-\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\t\tallReaders.clear();\n-\t}\n-\n-\t/**\n-\t * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n-\t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n-\t *\n-\t * @param receiverId The input channel id to identify the consumer.\n-\t * @param operation The operation to be performed (add credit or resume data consumption).\n-\t */\n-\tvoid addCreditOrResumeConsumption(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tFutureConsumerWithException<NetworkSequenceViewReader, Exception> operation) throws Exception {\n-\t\tif (fatalError) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n-\t\tif (reader != null) {\n-\t\t\toperation.acceptWithException(reader);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"No reader for receiverId = \" + receiverId + \" exists.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\t// The user event triggered event loop callback is used for thread-safe\n-\t\t// hand over of reader queues and cancelled producers.\n-\n-\t\tif (msg instanceof NetworkSequenceViewReader) {\n-\t\t\tNetworkSequenceViewReader reader = (NetworkSequenceViewReader) msg;\n-\t\t\tenqueueAvailableReader(reader, () -> (reader.isAvailable() || reader.shouldAnnounceBacklog()));\n-\t\t} else if (msg.getClass() == InputChannelID.class) {\n-\t\t\t// Release partition view that get a cancel request.\n-\t\t\tInputChannelID toCancel = (InputChannelID) msg;\n-\n-\t\t\t// remove reader from queue of available readers\n-\t\t\tavailableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n-\n-\t\t\t// remove reader from queue of all readers and release its resource\n-\t\t\tfinal NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n-\t\t\tif (toRelease != null) {\n-\t\t\t\treleaseViewReader(toRelease);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tctx.fireUserEventTriggered(msg);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t}\n-\n-\tprivate void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n-\t\tif (fatalError || !channel.isWritable()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// The logic here is very similar to the combined input gate and local\n-\t\t// input channel logic. You can think of this class acting as the input\n-\t\t// gate and the consumed views as the local input channels.\n-\n-\t\tServerOutboundMessage next = null;\n-\t\ttry {\n-\t\t\twhile (true) {\n-\t\t\t\tNetworkSequenceViewReader reader = pollAvailableReader();\n-\n-\t\t\t\t// No queue with available data. We allow this here, because\n-\t\t\t\t// of the write callbacks that are executed after each write.\n-\t\t\t\tif (reader == null) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\tnext = reader.getNextMessage();\n-\t\t\t\tif (next == null) {\n-\t\t\t\t\tif (!reader.isReleased()) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tThrowable cause = reader.getFailureCause();\n-\t\t\t\t\tif (cause != null) {\n-\t\t\t\t\t\tErrorResponse msg = new ErrorResponse(\n-\t\t\t\t\t\t\tnew ProducerFailedException(cause),\n-\t\t\t\t\t\t\treader.getReceiverId());\n-\n-\t\t\t\t\t\tctx.writeAndFlush(msg);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// This channel was now removed from the available reader queue.\n-\t\t\t\t\t// We re-add it into the queue if it is still available\n-\t\t\t\t\tif (next.isMoreAvailable()) {\n-\t\t\t\t\t\tregisterAvailableReader(reader);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Write and flush and wait until this is done before\n-\t\t\t\t\t// trying to continue with the next buffer.\n-\t\t\t\t\tchannel.writeAndFlush(next.build()).addListener(writeListener);\n-\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tif (next != null) {\n-\t\t\t\tnext.recycleBufferIfNeeded();\n-\t\t\t}\n-\n-\t\t\tthrow new IOException(t.getMessage(), t);\n-\t\t}\n-\t}\n-\n-\tprivate void registerAvailableReader(NetworkSequenceViewReader reader) {\n-\t\tavailableReaders.add(reader);\n-\t\treader.setRegisteredAsAvailable(true);\n-\t}\n-\n-\t@Nullable\n-\tprivate NetworkSequenceViewReader pollAvailableReader() {\n-\t\tNetworkSequenceViewReader reader = availableReaders.poll();\n-\t\tif (reader != null) {\n-\t\t\treader.setRegisteredAsAvailable(false);\n-\t\t}\n-\t\treturn reader;\n-\t}\n-\n-\t@Override\n-\tpublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-\t\treleaseAllResources();\n-\n-\t\tctx.fireChannelInactive();\n-\t}\n-\n-\t@Override\n-\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-\t\thandleException(ctx.channel(), cause);\n-\t}\n-\n-\tprivate void handleException(Channel channel, Throwable cause) throws IOException {\n-\t\tLOG.error(\"Encountered error while consuming partitions\", cause);\n-\n-\t\tfatalError = true;\n-\t\treleaseAllResources();\n-\n-\t\tif (channel.isActive()) {\n-\t\t\tchannel.writeAndFlush(new ErrorResponse(cause)).addListener(ChannelFutureListener.CLOSE);\n-\t\t}\n-\t}\n-\n-\tprivate void releaseAllResources() throws IOException {\n-\t\t// note: this is only ever executed by one thread: the Netty IO thread!\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\n-\t\tavailableReaders.clear();\n-\t\tallReaders.clear();\n-\t}\n-\n-\tprivate void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n-\t\treader.setRegisteredAsAvailable(false);\n-\t\treader.releaseAllResources();\n-\t}\n-\n-\t// This listener is called after an element of the current nonEmptyReader has been\n-\t// flushed. If successful, the listener triggers further processing of the\n-\t// queues.\n-\tprivate class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n-\n-\t\t@Override\n-\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n-\t\t\ttry {\n-\t\t\t\tif (future.isSuccess()) {\n-\t\t\t\t\twriteAndFlushNextMessageIfPossible(future.channel());\n-\t\t\t\t} else if (future.cause() != null) {\n-\t\t\t\t\thandleException(future.channel(), future.cause());\n-\t\t\t\t} else {\n-\t\t\t\t\thandleException(future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\thandleException(future.channel(), t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Outbound message to be sent to the client.\n-\t */\n-\tpublic static abstract class ServerOutboundMessage {\n-\t\tprotected final InputChannelID receiverId;\n-\t\tprotected final int backlog;\n-\t\tprivate final boolean moreAvailable;\n-\n-\t\tServerOutboundMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tcheckArgument(backlog >= 0, \"Number of backlog must be non-negative.\");\n-\t\t\tthis.receiverId = checkNotNull(receiverId);\n-\t\t\tthis.backlog = backlog;\n-\t\t\tthis.moreAvailable = moreAvailable;\n-\t\t}\n-\n-\t\tabstract Object build();\n-\n-\t\tpublic boolean isMoreAvailable() {\n-\t\t\treturn moreAvailable;\n-\t\t}\n-\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t}\n-\t}\n-\n-\tstatic class BufferResponseMessage extends ServerOutboundMessage {\n-\t\tprivate final Buffer buffer;\n-\t\tprivate final int sequenceNumber;\n-\n-\t\tBufferResponseMessage(\n-\t\t\t\tBuffer buffer,\n-\t\t\t\tInputChannelID receiverId,\n-\t\t\t\tint sequenceNumber,\n-\t\t\t\tint backlog,\n-\t\t\t\tboolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n-\t\t\tthis.buffer = checkNotNull(buffer);\n-\t\t\tthis.sequenceNumber = sequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new BufferResponse(buffer, sequenceNumber, receiverId, backlog);\n-\t\t}\n-\n-\t\t@Override\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t\tbuffer.recycleBuffer();\n-\t\t}\n-\t}\n-\n-\tstatic class AddBacklogMessage extends ServerOutboundMessage {\n-\n-\t\tAddBacklogMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new AddBacklog(backlog, receiverId);\n-\t\t}\n-\t}\n+class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n+\n+    private final ChannelFutureListener writeListener =\n+            new WriteAndFlushNextMessageIfPossibleListener();\n+\n+    /** The readers which are already enqueued available for transferring data. */\n+    private final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n+\n+    /** All the readers created for the consumers' partition requests. */\n+    private final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders =\n+            new ConcurrentHashMap<>();\n+\n+    private boolean fatalError;\n+\n+    private ChannelHandlerContext ctx;\n+\n+    @Override\n+    public void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n+        if (this.ctx == null) {\n+            this.ctx = ctx;\n+        }\n+\n+        super.channelRegistered(ctx);\n+    }\n+\n+    void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n+        // The notification might come from the same thread. For the initial writes this\n+        // might happen before the reader has set its reference to the view, because\n+        // creating the queue and the initial notification happen in the same method call.\n+        // This can be resolved by separating the creation of the view and allowing\n+        // notifications.\n+\n+        // TODO This could potentially have a bad performance impact as in the\n+        // worst case (network consumes faster than the producer) each buffer\n+        // will trigger a separate event loop task being scheduled.\n+        ctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n+    }\n+\n+    /**\n+     * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n+     * non-empty reader notification from the producer.\n+     *\n+     * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n+     * availability, so there is no race condition here.\n+     */\n+    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n+        announceBacklogIfNeeded(reader, reader.getRemainingBacklog());\n+        if (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {\n+            return;\n+        }\n+        // Queue an available reader for consumption. If the queue is empty,\n+        // we try trigger the actual write. Otherwise this will be handled by\n+        // the writeAndFlushNextMessageIfPossible calls.\n+        boolean triggerWrite = availableReaders.isEmpty();\n+        registerAvailableReader(reader);\n+\n+        if (triggerWrite) {\n+            writeAndFlushNextMessageIfPossible(ctx.channel());\n+        }\n+    }\n+\n+    /**\n+     * Accesses internal state to verify reader registration in the unit tests.\n+     *\n+     * <p><strong>Do not use anywhere else!</strong>\n+     *\n+     * @return readers which are enqueued available for transferring data\n+     */\n+    @VisibleForTesting\n+    ArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n+        return availableReaders;\n+    }\n+\n+    public void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n+        allReaders.put(reader.getReceiverId(), reader);\n+    }\n+\n+    public void cancel(InputChannelID receiverId) {\n+        ctx.pipeline().fireUserEventTriggered(receiverId);\n+    }\n+\n+    public void close() throws IOException {\n+        if (ctx != null) {\n+            ctx.channel().close();\n+        }\n+\n+        releaseAllResources();\n+    }\n+\n+    /**\n+     * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n+     * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n+     *\n+     * @param receiverId The input channel id to identify the consumer.\n+     * @param operation The operation to be performed (add credit or resume data consumption).\n+     */\n+    void addCreditOrResumeConsumption(\n+            InputChannelID receiverId, Consumer<NetworkSequenceViewReader> operation)\n+            throws Exception {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            operation.accept(reader);\n+\n+            enqueueAvailableReader(reader);\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    /**\n+     * Announces remaining backlog to the consumer after the available data notification or data\n+     * consumption resumption.\n+     */\n+    private void announceBacklogIfNeeded(NetworkSequenceViewReader reader, int backlog) {\n+        if (backlog > 0 && reader.needAnnounceBacklog()) {\n+            NettyMessage.BacklogAnnouncement announcement =\n+                    new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n+            ctx.channel()\n+                    .writeAndFlush(announcement)\n+                    .addListener(\n+                            (ChannelFutureListener)\n+                                    future -> {\n+                                        if (!future.isSuccess()) {\n+                                            onChannelFutureFailure(future);\n+                                        }\n+                                    });\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        // The user event triggered event loop callback is used for thread-safe\n+        // hand over of reader queues and cancelled producers.\n+\n+        if (msg instanceof NetworkSequenceViewReader) {\n+            enqueueAvailableReader((NetworkSequenceViewReader) msg);\n+        } else if (msg.getClass() == InputChannelID.class) {\n+            // Release partition view that get a cancel request.\n+            InputChannelID toCancel = (InputChannelID) msg;\n+\n+            // remove reader from queue of available readers\n+            availableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n+\n+            // remove reader from queue of all readers and release its resource\n+            final NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n+            if (toRelease != null) {\n+                releaseViewReader(toRelease);\n+            }\n+        } else {\n+            ctx.fireUserEventTriggered(msg);\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        writeAndFlushNextMessageIfPossible(ctx.channel());\n+    }\n+\n+    private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n+        if (fatalError || !channel.isWritable()) {\n+            return;\n+        }\n+\n+        // The logic here is very similar to the combined input gate and local\n+        // input channel logic. You can think of this class acting as the input\n+        // gate and the consumed views as the local input channels.\n+\n+        BufferAndAvailability next = null;\n+        try {\n+            while (true) {\n+                NetworkSequenceViewReader reader = pollAvailableReader();\n+\n+                // No queue with available data. We allow this here, because\n+                // of the write callbacks that are executed after each write.\n+                if (reader == null) {\n+                    return;\n+                }\n+\n+                next = reader.getNextBuffer();\n+                if (next == null) {\n+                    if (!reader.isReleased()) {\n+                        continue;\n+                    }\n+\n+                    Throwable cause = reader.getFailureCause();\n+                    if (cause != null) {\n+                        ErrorResponse msg =\n+                                new ErrorResponse(\n+                                        new ProducerFailedException(cause), reader.getReceiverId());\n+\n+                        ctx.writeAndFlush(msg);\n+                    }\n+                } else {\n+                    // This channel was now removed from the available reader queue.\n+                    // We re-add it into the queue if it is still available\n+                    if (next.moreAvailable()) {\n+                        registerAvailableReader(reader);\n+                    }\n+\n+                    BufferResponse msg =\n+                            new BufferResponse(\n+                                    next.buffer(),\n+                                    next.getSequenceNumber(),\n+                                    reader.getReceiverId(),\n+                                    next.buffersInBacklog());\n+\n+                    // Write and flush and wait until this is done before\n+                    // trying to continue with the next buffer.\n+                    channel.writeAndFlush(msg).addListener(writeListener);\n+\n+                    return;\n+                }\n+            }\n+        } catch (Throwable t) {\n+            if (next != null) {\n+                next.buffer().recycleBuffer();\n+            }\n+\n+            throw new IOException(t.getMessage(), t);\n+        }\n+    }\n+\n+    private void registerAvailableReader(NetworkSequenceViewReader reader) {\n+        availableReaders.add(reader);\n+        reader.setRegisteredAsAvailable(true);\n+    }\n+\n+    @Nullable\n+    private NetworkSequenceViewReader pollAvailableReader() {\n+        NetworkSequenceViewReader reader = availableReaders.poll();\n+        if (reader != null) {\n+            reader.setRegisteredAsAvailable(false);\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        releaseAllResources();\n+\n+        ctx.fireChannelInactive();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        handleException(ctx.channel(), cause);\n+    }\n+\n+    private void handleException(Channel channel, Throwable cause) throws IOException {\n+        LOG.error(\"Encountered error while consuming partitions\", cause);\n+\n+        fatalError = true;\n+        releaseAllResources();\n+\n+        if (channel.isActive()) {\n+            channel.writeAndFlush(new ErrorResponse(cause))\n+                    .addListener(ChannelFutureListener.CLOSE);\n+        }\n+    }\n+\n+    private void releaseAllResources() throws IOException {\n+        // note: this is only ever executed by one thread: the Netty IO thread!\n+        for (NetworkSequenceViewReader reader : allReaders.values()) {\n+            releaseViewReader(reader);\n+        }\n+\n+        availableReaders.clear();\n+        allReaders.clear();\n+    }\n+\n+    private void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n+        reader.setRegisteredAsAvailable(false);\n+        reader.releaseAllResources();\n+    }\n+\n+    private void onChannelFutureFailure(ChannelFuture future) throws Exception {\n+        if (future.cause() != null) {\n+            handleException(future.channel(), future.cause());\n+        } else {\n+            handleException(\n+                    future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n+        }\n+    }\n+\n+    // This listener is called after an element of the current nonEmptyReader has been\n+    // flushed. If successful, the listener triggers further processing of the\n+    // queues.\n+    private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            try {\n+                if (future.isSuccess()) {\n+                    writeAndFlushNextMessageIfPossible(future.channel());\n+                } else {\n+                    onChannelFutureFailure(future);\n+                }\n+            } catch (Throwable t) {\n+                handleException(future.channel(), t);\n+            }\n+        }\n+    }\n }\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex df17ef3877c..0e3b6ddc57c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -350,8 +334,12 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n             try {\n                 if (future.isSuccess()) {\n                     writeAndFlushNextMessageIfPossible(future.channel());\n+                } else if (future.cause() != null) {\n+                    handleException(future.channel(), future.cause());\n                 } else {\n-                    onChannelFutureFailure(future);\n+                    handleException(\n+                            future.channel(),\n+                            new IllegalStateException(\"Sending cancelled by user.\"));\n                 }\n             } catch (Throwable t) {\n                 handleException(future.channel(), t);\n", "next_change": {"commit": "639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 0e3b6ddc57c..72ede48bda2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -334,12 +376,8 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n             try {\n                 if (future.isSuccess()) {\n                     writeAndFlushNextMessageIfPossible(future.channel());\n-                } else if (future.cause() != null) {\n-                    handleException(future.channel(), future.cause());\n                 } else {\n-                    handleException(\n-                            future.channel(),\n-                            new IllegalStateException(\"Sending cancelled by user.\"));\n+                    onChannelFutureFailure(future);\n                 }\n             } catch (Throwable t) {\n                 handleException(future.channel(), t);\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 8cfbd108656..72ede48bda2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -41,352 +42,346 @@ import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.function.Function;\n+import java.util.function.Consumer;\n \n import static org.apache.flink.runtime.io.network.netty.NettyMessage.BufferResponse;\n import static org.apache.flink.util.Preconditions.checkArgument;\n-import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n- * A nonEmptyReader of partition queues, which listens for channel writability changed\n- * events before writing and flushing {@link Buffer} instances.\n+ * A nonEmptyReader of partition queues, which listens for channel writability changed events before\n+ * writing and flushing {@link Buffer} instances.\n  */\n-public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n-\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n-\n-\tprivate final ChannelFutureListener writeListener = new WriteAndFlushNextMessageIfPossibleListener();\n-\n-\t/** The readers which are already enqueued available for transferring data or announcing backlog. */\n-\tprivate final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n-\n-\t/** All the readers created for the consumers' partition requests. */\n-\tprivate final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders = new ConcurrentHashMap<>();\n-\n-\tprivate boolean fatalError;\n-\n-\tprivate ChannelHandlerContext ctx;\n-\n-\t@Override\n-\tpublic void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n-\t\tif (this.ctx == null) {\n-\t\t\tthis.ctx = ctx;\n-\t\t}\n-\n-\t\tsuper.channelRegistered(ctx);\n-\t}\n-\n-\tvoid notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n-\t\t// The notification might come from the same thread. For the initial writes this\n-\t\t// might happen before the reader has set its reference to the view, because\n-\t\t// creating the queue and the initial notification happen in the same method call.\n-\t\t// This can be resolved by separating the creation of the view and allowing\n-\t\t// notifications.\n-\n-\t\t// TODO This could potentially have a bad performance impact as in the\n-\t\t// worst case (network consumes faster than the producer) each buffer\n-\t\t// will trigger a separate event loop task being scheduled.\n-\t\tctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n-\t}\n-\n-\t/**\n-\t * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n-\t * non-empty reader notification from the producer.\n-\t *\n-\t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n-\t * availability, so there is no race condition here.\n-\t */\n-\tprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader, boolean announceBacklog) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || (!reader.isAvailable() && !announceBacklog)) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Queue an available reader for consumption. If the queue is empty,\n-\t\t// we try trigger the actual write. Otherwise this will be handled by\n-\t\t// the writeAndFlushNextMessageIfPossible calls.\n-\t\tboolean triggerWrite = availableReaders.isEmpty();\n-\t\tregisterAvailableReader(reader);\n-\n-\t\tif (triggerWrite) {\n-\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Accesses internal state to verify reader registration in the unit tests.\n-\t *\n-\t * <p><strong>Do not use anywhere else!</strong>\n-\t *\n-\t * @return readers which are enqueued available for transferring data or announcing backlog\n-\t */\n-\t@VisibleForTesting\n-\tArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n-\t\treturn availableReaders;\n-\t}\n-\n-\tpublic void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n-\t\tallReaders.put(reader.getReceiverId(), reader);\n-\t}\n-\n-\tpublic void cancel(InputChannelID receiverId) {\n-\t\tctx.pipeline().fireUserEventTriggered(receiverId);\n-\t}\n-\n-\tpublic void close() throws IOException {\n-\t\tif (ctx != null) {\n-\t\t\tctx.channel().close();\n-\t\t}\n-\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\t\tallReaders.clear();\n-\t}\n-\n-\t/**\n-\t * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n-\t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n-\t *\n-\t * @param receiverId The input channel id to identify the consumer.\n-\t * @param function The operation to be performed (add credit or resume data consumption).\n-\t */\n-\tvoid addCreditOrResumeConsumption(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tFunction<NetworkSequenceViewReader, Boolean> function) throws Exception {\n-\t\tif (fatalError) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n-\t\tif (reader != null) {\n-\t\t\tboolean needAnnounceBacklog = function.apply(reader);\n-\n-\t\t\tenqueueAvailableReader(reader, needAnnounceBacklog);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"No reader for receiverId = \" + receiverId + \" exists.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\t// The user event triggered event loop callback is used for thread-safe\n-\t\t// hand over of reader queues and cancelled producers.\n-\n-\t\tif (msg instanceof NetworkSequenceViewReader) {\n-\t\t\tNetworkSequenceViewReader reader = (NetworkSequenceViewReader) msg;\n-\t\t\tenqueueAvailableReader(reader, reader.shouldAnnounceBacklog());\n-\t\t} else if (msg.getClass() == InputChannelID.class) {\n-\t\t\t// Release partition view that get a cancel request.\n-\t\t\tInputChannelID toCancel = (InputChannelID) msg;\n-\n-\t\t\t// remove reader from queue of available readers\n-\t\t\tavailableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n-\n-\t\t\t// remove reader from queue of all readers and release its resource\n-\t\t\tfinal NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n-\t\t\tif (toRelease != null) {\n-\t\t\t\treleaseViewReader(toRelease);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tctx.fireUserEventTriggered(msg);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t}\n-\n-\tprivate void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n-\t\tif (fatalError || !channel.isWritable()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// The logic here is very similar to the combined input gate and local\n-\t\t// input channel logic. You can think of this class acting as the input\n-\t\t// gate and the consumed views as the local input channels.\n-\n-\t\tServerOutboundMessage next = null;\n-\t\ttry {\n-\t\t\twhile (true) {\n-\t\t\t\tNetworkSequenceViewReader reader = pollAvailableReader();\n-\n-\t\t\t\t// No queue with available data. We allow this here, because\n-\t\t\t\t// of the write callbacks that are executed after each write.\n-\t\t\t\tif (reader == null) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\tnext = reader.getNextMessage();\n-\t\t\t\tif (next == null) {\n-\t\t\t\t\tif (!reader.isReleased()) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tThrowable cause = reader.getFailureCause();\n-\t\t\t\t\tif (cause != null) {\n-\t\t\t\t\t\tErrorResponse msg = new ErrorResponse(\n-\t\t\t\t\t\t\tnew ProducerFailedException(cause),\n-\t\t\t\t\t\t\treader.getReceiverId());\n-\n-\t\t\t\t\t\tctx.writeAndFlush(msg);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// This channel was now removed from the available reader queue.\n-\t\t\t\t\t// We re-add it into the queue if it is still available\n-\t\t\t\t\tif (next.isMoreAvailable()) {\n-\t\t\t\t\t\tregisterAvailableReader(reader);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Write and flush and wait until this is done before\n-\t\t\t\t\t// trying to continue with the next buffer.\n-\t\t\t\t\tchannel.writeAndFlush(next.build()).addListener(writeListener);\n-\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tif (next != null) {\n-\t\t\t\tnext.recycleBufferIfNeeded();\n-\t\t\t}\n-\n-\t\t\tthrow new IOException(t.getMessage(), t);\n-\t\t}\n-\t}\n-\n-\tprivate void registerAvailableReader(NetworkSequenceViewReader reader) {\n-\t\tavailableReaders.add(reader);\n-\t\treader.setRegisteredAsAvailable(true);\n-\t}\n-\n-\t@Nullable\n-\tprivate NetworkSequenceViewReader pollAvailableReader() {\n-\t\tNetworkSequenceViewReader reader = availableReaders.poll();\n-\t\tif (reader != null) {\n-\t\t\treader.setRegisteredAsAvailable(false);\n-\t\t}\n-\t\treturn reader;\n-\t}\n-\n-\t@Override\n-\tpublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-\t\treleaseAllResources();\n-\n-\t\tctx.fireChannelInactive();\n-\t}\n-\n-\t@Override\n-\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-\t\thandleException(ctx.channel(), cause);\n-\t}\n-\n-\tprivate void handleException(Channel channel, Throwable cause) throws IOException {\n-\t\tLOG.error(\"Encountered error while consuming partitions\", cause);\n-\n-\t\tfatalError = true;\n-\t\treleaseAllResources();\n-\n-\t\tif (channel.isActive()) {\n-\t\t\tchannel.writeAndFlush(new ErrorResponse(cause)).addListener(ChannelFutureListener.CLOSE);\n-\t\t}\n-\t}\n-\n-\tprivate void releaseAllResources() throws IOException {\n-\t\t// note: this is only ever executed by one thread: the Netty IO thread!\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\n-\t\tavailableReaders.clear();\n-\t\tallReaders.clear();\n-\t}\n-\n-\tprivate void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n-\t\treader.setRegisteredAsAvailable(false);\n-\t\treader.releaseAllResources();\n-\t}\n-\n-\t// This listener is called after an element of the current nonEmptyReader has been\n-\t// flushed. If successful, the listener triggers further processing of the\n-\t// queues.\n-\tprivate class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n-\n-\t\t@Override\n-\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n-\t\t\ttry {\n-\t\t\t\tif (future.isSuccess()) {\n-\t\t\t\t\twriteAndFlushNextMessageIfPossible(future.channel());\n-\t\t\t\t} else if (future.cause() != null) {\n-\t\t\t\t\thandleException(future.channel(), future.cause());\n-\t\t\t\t} else {\n-\t\t\t\t\thandleException(future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\thandleException(future.channel(), t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Outbound message to be sent to the client.\n-\t */\n-\tpublic static abstract class ServerOutboundMessage {\n-\t\tprotected final InputChannelID receiverId;\n-\t\tprotected final int backlog;\n-\t\tprivate final boolean moreAvailable;\n-\n-\t\tServerOutboundMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tcheckArgument(backlog >= 0, \"Number of backlog must be non-negative.\");\n-\t\t\tthis.receiverId = checkNotNull(receiverId);\n-\t\t\tthis.backlog = backlog;\n-\t\t\tthis.moreAvailable = moreAvailable;\n-\t\t}\n-\n-\t\tabstract Object build();\n-\n-\t\tpublic boolean isMoreAvailable() {\n-\t\t\treturn moreAvailable;\n-\t\t}\n-\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t}\n-\t}\n-\n-\tstatic class BufferResponseMessage extends ServerOutboundMessage {\n-\t\tprivate final Buffer buffer;\n-\t\tprivate final int sequenceNumber;\n-\n-\t\tBufferResponseMessage(\n-\t\t\t\tBuffer buffer,\n-\t\t\t\tInputChannelID receiverId,\n-\t\t\t\tint sequenceNumber,\n-\t\t\t\tint backlog,\n-\t\t\t\tboolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n-\t\t\tthis.buffer = checkNotNull(buffer);\n-\t\t\tthis.sequenceNumber = sequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new BufferResponse(buffer, sequenceNumber, receiverId, backlog);\n-\t\t}\n-\n-\t\t@Override\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t\tbuffer.recycleBuffer();\n-\t\t}\n-\t}\n-\n-\tstatic class AddBacklogMessage extends ServerOutboundMessage {\n-\n-\t\tAddBacklogMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new AddBacklog(backlog, receiverId);\n-\t\t}\n-\t}\n+class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n+\n+    private final ChannelFutureListener writeListener =\n+            new WriteAndFlushNextMessageIfPossibleListener();\n+\n+    /** The readers which are already enqueued available for transferring data. */\n+    private final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n+\n+    /** All the readers created for the consumers' partition requests. */\n+    private final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders =\n+            new ConcurrentHashMap<>();\n+\n+    private boolean fatalError;\n+\n+    private ChannelHandlerContext ctx;\n+\n+    @Override\n+    public void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n+        if (this.ctx == null) {\n+            this.ctx = ctx;\n+        }\n+\n+        super.channelRegistered(ctx);\n+    }\n+\n+    void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n+        // The notification might come from the same thread. For the initial writes this\n+        // might happen before the reader has set its reference to the view, because\n+        // creating the queue and the initial notification happen in the same method call.\n+        // This can be resolved by separating the creation of the view and allowing\n+        // notifications.\n+\n+        // TODO This could potentially have a bad performance impact as in the\n+        // worst case (network consumes faster than the producer) each buffer\n+        // will trigger a separate event loop task being scheduled.\n+        ctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n+    }\n+\n+    /**\n+     * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n+     * non-empty reader notification from the producer.\n+     *\n+     * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n+     * availability, so there is no race condition here.\n+     */\n+    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n+        if (reader.isRegisteredAsAvailable()) {\n+            return;\n+        }\n+\n+        ResultSubpartitionView.AvailabilityWithBacklog availabilityWithBacklog =\n+                reader.getAvailabilityAndBacklog();\n+        if (!availabilityWithBacklog.isAvailable()) {\n+            int backlog = availabilityWithBacklog.getBacklog();\n+            if (backlog > 0 && reader.needAnnounceBacklog()) {\n+                announceBacklog(reader, backlog);\n+            }\n+            return;\n+        }\n+\n+        // Queue an available reader for consumption. If the queue is empty,\n+        // we try trigger the actual write. Otherwise this will be handled by\n+        // the writeAndFlushNextMessageIfPossible calls.\n+        boolean triggerWrite = availableReaders.isEmpty();\n+        registerAvailableReader(reader);\n+\n+        if (triggerWrite) {\n+            writeAndFlushNextMessageIfPossible(ctx.channel());\n+        }\n+    }\n+\n+    /**\n+     * Accesses internal state to verify reader registration in the unit tests.\n+     *\n+     * <p><strong>Do not use anywhere else!</strong>\n+     *\n+     * @return readers which are enqueued available for transferring data\n+     */\n+    @VisibleForTesting\n+    ArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n+        return availableReaders;\n+    }\n+\n+    public void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n+        allReaders.put(reader.getReceiverId(), reader);\n+    }\n+\n+    public void cancel(InputChannelID receiverId) {\n+        ctx.pipeline().fireUserEventTriggered(receiverId);\n+    }\n+\n+    public void close() throws IOException {\n+        if (ctx != null) {\n+            ctx.channel().close();\n+        }\n+\n+        releaseAllResources();\n+    }\n+\n+    /**\n+     * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n+     * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n+     *\n+     * @param receiverId The input channel id to identify the consumer.\n+     * @param operation The operation to be performed (add credit or resume data consumption).\n+     */\n+    void addCreditOrResumeConsumption(\n+            InputChannelID receiverId, Consumer<NetworkSequenceViewReader> operation)\n+            throws Exception {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            operation.accept(reader);\n+\n+            enqueueAvailableReader(reader);\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    void acknowledgeAllRecordsProcessed(InputChannelID receiverId) {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            reader.acknowledgeAllRecordsProcessed();\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    /**\n+     * Announces remaining backlog to the consumer after the available data notification or data\n+     * consumption resumption.\n+     */\n+    private void announceBacklog(NetworkSequenceViewReader reader, int backlog) {\n+        checkArgument(backlog > 0, \"Backlog must be positive.\");\n+\n+        NettyMessage.BacklogAnnouncement announcement =\n+                new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n+        ctx.channel()\n+                .writeAndFlush(announcement)\n+                .addListener(\n+                        (ChannelFutureListener)\n+                                future -> {\n+                                    if (!future.isSuccess()) {\n+                                        onChannelFutureFailure(future);\n+                                    }\n+                                });\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        // The user event triggered event loop callback is used for thread-safe\n+        // hand over of reader queues and cancelled producers.\n+\n+        if (msg instanceof NetworkSequenceViewReader) {\n+            enqueueAvailableReader((NetworkSequenceViewReader) msg);\n+        } else if (msg.getClass() == InputChannelID.class) {\n+            // Release partition view that get a cancel request.\n+            InputChannelID toCancel = (InputChannelID) msg;\n+\n+            // remove reader from queue of available readers\n+            availableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n+\n+            // remove reader from queue of all readers and release its resource\n+            final NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n+            if (toRelease != null) {\n+                releaseViewReader(toRelease);\n+            }\n+        } else {\n+            ctx.fireUserEventTriggered(msg);\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        writeAndFlushNextMessageIfPossible(ctx.channel());\n+    }\n+\n+    private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n+        if (fatalError || !channel.isWritable()) {\n+            return;\n+        }\n+\n+        // The logic here is very similar to the combined input gate and local\n+        // input channel logic. You can think of this class acting as the input\n+        // gate and the consumed views as the local input channels.\n+\n+        BufferAndAvailability next = null;\n+        try {\n+            while (true) {\n+                NetworkSequenceViewReader reader = pollAvailableReader();\n+\n+                // No queue with available data. We allow this here, because\n+                // of the write callbacks that are executed after each write.\n+                if (reader == null) {\n+                    return;\n+                }\n+\n+                next = reader.getNextBuffer();\n+                if (next == null) {\n+                    if (!reader.isReleased()) {\n+                        continue;\n+                    }\n+\n+                    Throwable cause = reader.getFailureCause();\n+                    if (cause != null) {\n+                        ErrorResponse msg =\n+                                new ErrorResponse(\n+                                        new ProducerFailedException(cause), reader.getReceiverId());\n+\n+                        ctx.writeAndFlush(msg);\n+                    }\n+                } else {\n+                    // This channel was now removed from the available reader queue.\n+                    // We re-add it into the queue if it is still available\n+                    if (next.moreAvailable()) {\n+                        registerAvailableReader(reader);\n+                    }\n+\n+                    BufferResponse msg =\n+                            new BufferResponse(\n+                                    next.buffer(),\n+                                    next.getSequenceNumber(),\n+                                    reader.getReceiverId(),\n+                                    next.buffersInBacklog());\n+\n+                    // Write and flush and wait until this is done before\n+                    // trying to continue with the next buffer.\n+                    channel.writeAndFlush(msg).addListener(writeListener);\n+\n+                    return;\n+                }\n+            }\n+        } catch (Throwable t) {\n+            if (next != null) {\n+                next.buffer().recycleBuffer();\n+            }\n+\n+            throw new IOException(t.getMessage(), t);\n+        }\n+    }\n+\n+    private void registerAvailableReader(NetworkSequenceViewReader reader) {\n+        availableReaders.add(reader);\n+        reader.setRegisteredAsAvailable(true);\n+    }\n+\n+    @Nullable\n+    private NetworkSequenceViewReader pollAvailableReader() {\n+        NetworkSequenceViewReader reader = availableReaders.poll();\n+        if (reader != null) {\n+            reader.setRegisteredAsAvailable(false);\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        releaseAllResources();\n+\n+        ctx.fireChannelInactive();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        handleException(ctx.channel(), cause);\n+    }\n+\n+    private void handleException(Channel channel, Throwable cause) throws IOException {\n+        LOG.error(\"Encountered error while consuming partitions\", cause);\n+\n+        fatalError = true;\n+        releaseAllResources();\n+\n+        if (channel.isActive()) {\n+            channel.writeAndFlush(new ErrorResponse(cause))\n+                    .addListener(ChannelFutureListener.CLOSE);\n+        }\n+    }\n+\n+    private void releaseAllResources() throws IOException {\n+        // note: this is only ever executed by one thread: the Netty IO thread!\n+        for (NetworkSequenceViewReader reader : allReaders.values()) {\n+            releaseViewReader(reader);\n+        }\n+\n+        availableReaders.clear();\n+        allReaders.clear();\n+    }\n+\n+    private void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n+        reader.setRegisteredAsAvailable(false);\n+        reader.releaseAllResources();\n+    }\n+\n+    private void onChannelFutureFailure(ChannelFuture future) throws Exception {\n+        if (future.cause() != null) {\n+            handleException(future.channel(), future.cause());\n+        } else {\n+            handleException(\n+                    future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n+        }\n+    }\n+\n+    // This listener is called after an element of the current nonEmptyReader has been\n+    // flushed. If successful, the listener triggers further processing of the\n+    // queues.\n+    private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            try {\n+                if (future.isSuccess()) {\n+                    writeAndFlushNextMessageIfPossible(future.channel());\n+                } else {\n+                    onChannelFutureFailure(future);\n+                }\n+            } catch (Throwable t) {\n+                handleException(future.channel(), t);\n+            }\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "7478445aa30cd28b7b6402565ca304c916024475", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[refactor][runtime] Unification of obtaining reader in PartitionRequestQueue"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}, {"oid": "7bacef09622d43c01ca9a749bbcd259d5cd3e0fe", "committedDate": "2021-09-17 20:16:25 +0200", "message": "[FLINK-24233][runtime] Ignore message about new buffer size if the reader doesn't ready yet"}, {"oid": "f957e3fee50e734dd6b2cbf0cbbef00fe810cd32", "committedDate": "2022-01-13 15:07:28 +0100", "message": "[FLINK-25441][network] Wrap failure cuase with ProducerFailedException only for PipelinedSubpartitionView."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1NDY4Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424354683", "body": "Based on this [comment](https://github.com/apache/flink/pull/11877#discussion_r424353439), we might not need to bring `announceBacklog` argument in this method, to understand all the related processes together.", "bodyText": "Based on this comment, we might not need to bring announceBacklog argument in this method, to understand all the related processes together.", "bodyHTML": "<p dir=\"auto\">Based on this <a href=\"https://github.com/apache/flink/pull/11877#discussion_r424353439\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/apache/flink/pull/11877/hovercard\">comment</a>, we might not need to bring <code>announceBacklog</code> argument in this method, to understand all the related processes together.</p>", "author": "zhijiangW", "createdAt": "2020-05-13T11:07:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -94,10 +96,11 @@ void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n \t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n \t * availability, so there is no race condition here.\n \t */\n-\tprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {\n+\tprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader, boolean announceBacklog) throws Exception {\n+\t\tif (reader.isRegisteredAsAvailable() || (!reader.isAvailable() && !announceBacklog)) {", "originalCommit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 8cfbd108656..70ec735057f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -96,8 +97,8 @@ public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n \t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n \t * availability, so there is no race condition here.\n \t */\n-\tprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader, boolean announceBacklog) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || (!reader.isAvailable() && !announceBacklog)) {\n+\tvoid enqueueAvailableReader(final NetworkSequenceViewReader reader, BooleanSupplier condition) throws Exception {\n+\t\tif (reader.isRegisteredAsAvailable() || !condition.getAsBoolean()) {\n \t\t\treturn;\n \t\t}\n \n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 70ec735057f..df17ef3877c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -42,350 +41,321 @@ import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n \n import static org.apache.flink.runtime.io.network.netty.NettyMessage.BufferResponse;\n-import static org.apache.flink.util.Preconditions.checkArgument;\n-import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n- * A nonEmptyReader of partition queues, which listens for channel writability changed\n- * events before writing and flushing {@link Buffer} instances.\n+ * A nonEmptyReader of partition queues, which listens for channel writability changed events before\n+ * writing and flushing {@link Buffer} instances.\n  */\n-public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n-\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n-\n-\tprivate final ChannelFutureListener writeListener = new WriteAndFlushNextMessageIfPossibleListener();\n-\n-\t/** The readers which are already enqueued available for transferring data or announcing backlog. */\n-\tprivate final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n-\n-\t/** All the readers created for the consumers' partition requests. */\n-\tprivate final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders = new ConcurrentHashMap<>();\n-\n-\tprivate boolean fatalError;\n-\n-\tprivate ChannelHandlerContext ctx;\n-\n-\t@Override\n-\tpublic void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n-\t\tif (this.ctx == null) {\n-\t\t\tthis.ctx = ctx;\n-\t\t}\n-\n-\t\tsuper.channelRegistered(ctx);\n-\t}\n-\n-\tvoid notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n-\t\t// The notification might come from the same thread. For the initial writes this\n-\t\t// might happen before the reader has set its reference to the view, because\n-\t\t// creating the queue and the initial notification happen in the same method call.\n-\t\t// This can be resolved by separating the creation of the view and allowing\n-\t\t// notifications.\n-\n-\t\t// TODO This could potentially have a bad performance impact as in the\n-\t\t// worst case (network consumes faster than the producer) each buffer\n-\t\t// will trigger a separate event loop task being scheduled.\n-\t\tctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n-\t}\n-\n-\t/**\n-\t * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n-\t * non-empty reader notification from the producer.\n-\t *\n-\t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n-\t * availability, so there is no race condition here.\n-\t */\n-\tvoid enqueueAvailableReader(final NetworkSequenceViewReader reader, BooleanSupplier condition) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || !condition.getAsBoolean()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Queue an available reader for consumption. If the queue is empty,\n-\t\t// we try trigger the actual write. Otherwise this will be handled by\n-\t\t// the writeAndFlushNextMessageIfPossible calls.\n-\t\tboolean triggerWrite = availableReaders.isEmpty();\n-\t\tregisterAvailableReader(reader);\n-\n-\t\tif (triggerWrite) {\n-\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Accesses internal state to verify reader registration in the unit tests.\n-\t *\n-\t * <p><strong>Do not use anywhere else!</strong>\n-\t *\n-\t * @return readers which are enqueued available for transferring data or announcing backlog\n-\t */\n-\t@VisibleForTesting\n-\tArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n-\t\treturn availableReaders;\n-\t}\n-\n-\tpublic void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n-\t\tallReaders.put(reader.getReceiverId(), reader);\n-\t}\n-\n-\tpublic void cancel(InputChannelID receiverId) {\n-\t\tctx.pipeline().fireUserEventTriggered(receiverId);\n-\t}\n-\n-\tpublic void close() throws IOException {\n-\t\tif (ctx != null) {\n-\t\t\tctx.channel().close();\n-\t\t}\n-\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\t\tallReaders.clear();\n-\t}\n-\n-\t/**\n-\t * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n-\t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n-\t *\n-\t * @param receiverId The input channel id to identify the consumer.\n-\t * @param operation The operation to be performed (add credit or resume data consumption).\n-\t */\n-\tvoid addCreditOrResumeConsumption(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tFutureConsumerWithException<NetworkSequenceViewReader, Exception> operation) throws Exception {\n-\t\tif (fatalError) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n-\t\tif (reader != null) {\n-\t\t\toperation.acceptWithException(reader);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"No reader for receiverId = \" + receiverId + \" exists.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\t// The user event triggered event loop callback is used for thread-safe\n-\t\t// hand over of reader queues and cancelled producers.\n-\n-\t\tif (msg instanceof NetworkSequenceViewReader) {\n-\t\t\tNetworkSequenceViewReader reader = (NetworkSequenceViewReader) msg;\n-\t\t\tenqueueAvailableReader(reader, () -> (reader.isAvailable() || reader.shouldAnnounceBacklog()));\n-\t\t} else if (msg.getClass() == InputChannelID.class) {\n-\t\t\t// Release partition view that get a cancel request.\n-\t\t\tInputChannelID toCancel = (InputChannelID) msg;\n-\n-\t\t\t// remove reader from queue of available readers\n-\t\t\tavailableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n-\n-\t\t\t// remove reader from queue of all readers and release its resource\n-\t\t\tfinal NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n-\t\t\tif (toRelease != null) {\n-\t\t\t\treleaseViewReader(toRelease);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tctx.fireUserEventTriggered(msg);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t}\n-\n-\tprivate void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n-\t\tif (fatalError || !channel.isWritable()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// The logic here is very similar to the combined input gate and local\n-\t\t// input channel logic. You can think of this class acting as the input\n-\t\t// gate and the consumed views as the local input channels.\n-\n-\t\tServerOutboundMessage next = null;\n-\t\ttry {\n-\t\t\twhile (true) {\n-\t\t\t\tNetworkSequenceViewReader reader = pollAvailableReader();\n-\n-\t\t\t\t// No queue with available data. We allow this here, because\n-\t\t\t\t// of the write callbacks that are executed after each write.\n-\t\t\t\tif (reader == null) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\tnext = reader.getNextMessage();\n-\t\t\t\tif (next == null) {\n-\t\t\t\t\tif (!reader.isReleased()) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tThrowable cause = reader.getFailureCause();\n-\t\t\t\t\tif (cause != null) {\n-\t\t\t\t\t\tErrorResponse msg = new ErrorResponse(\n-\t\t\t\t\t\t\tnew ProducerFailedException(cause),\n-\t\t\t\t\t\t\treader.getReceiverId());\n-\n-\t\t\t\t\t\tctx.writeAndFlush(msg);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// This channel was now removed from the available reader queue.\n-\t\t\t\t\t// We re-add it into the queue if it is still available\n-\t\t\t\t\tif (next.isMoreAvailable()) {\n-\t\t\t\t\t\tregisterAvailableReader(reader);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Write and flush and wait until this is done before\n-\t\t\t\t\t// trying to continue with the next buffer.\n-\t\t\t\t\tchannel.writeAndFlush(next.build()).addListener(writeListener);\n-\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tif (next != null) {\n-\t\t\t\tnext.recycleBufferIfNeeded();\n-\t\t\t}\n-\n-\t\t\tthrow new IOException(t.getMessage(), t);\n-\t\t}\n-\t}\n-\n-\tprivate void registerAvailableReader(NetworkSequenceViewReader reader) {\n-\t\tavailableReaders.add(reader);\n-\t\treader.setRegisteredAsAvailable(true);\n-\t}\n-\n-\t@Nullable\n-\tprivate NetworkSequenceViewReader pollAvailableReader() {\n-\t\tNetworkSequenceViewReader reader = availableReaders.poll();\n-\t\tif (reader != null) {\n-\t\t\treader.setRegisteredAsAvailable(false);\n-\t\t}\n-\t\treturn reader;\n-\t}\n-\n-\t@Override\n-\tpublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-\t\treleaseAllResources();\n-\n-\t\tctx.fireChannelInactive();\n-\t}\n-\n-\t@Override\n-\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-\t\thandleException(ctx.channel(), cause);\n-\t}\n-\n-\tprivate void handleException(Channel channel, Throwable cause) throws IOException {\n-\t\tLOG.error(\"Encountered error while consuming partitions\", cause);\n-\n-\t\tfatalError = true;\n-\t\treleaseAllResources();\n-\n-\t\tif (channel.isActive()) {\n-\t\t\tchannel.writeAndFlush(new ErrorResponse(cause)).addListener(ChannelFutureListener.CLOSE);\n-\t\t}\n-\t}\n-\n-\tprivate void releaseAllResources() throws IOException {\n-\t\t// note: this is only ever executed by one thread: the Netty IO thread!\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\n-\t\tavailableReaders.clear();\n-\t\tallReaders.clear();\n-\t}\n-\n-\tprivate void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n-\t\treader.setRegisteredAsAvailable(false);\n-\t\treader.releaseAllResources();\n-\t}\n-\n-\t// This listener is called after an element of the current nonEmptyReader has been\n-\t// flushed. If successful, the listener triggers further processing of the\n-\t// queues.\n-\tprivate class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n-\n-\t\t@Override\n-\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n-\t\t\ttry {\n-\t\t\t\tif (future.isSuccess()) {\n-\t\t\t\t\twriteAndFlushNextMessageIfPossible(future.channel());\n-\t\t\t\t} else if (future.cause() != null) {\n-\t\t\t\t\thandleException(future.channel(), future.cause());\n-\t\t\t\t} else {\n-\t\t\t\t\thandleException(future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\thandleException(future.channel(), t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Outbound message to be sent to the client.\n-\t */\n-\tpublic static abstract class ServerOutboundMessage {\n-\t\tprotected final InputChannelID receiverId;\n-\t\tprotected final int backlog;\n-\t\tprivate final boolean moreAvailable;\n-\n-\t\tServerOutboundMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tcheckArgument(backlog >= 0, \"Number of backlog must be non-negative.\");\n-\t\t\tthis.receiverId = checkNotNull(receiverId);\n-\t\t\tthis.backlog = backlog;\n-\t\t\tthis.moreAvailable = moreAvailable;\n-\t\t}\n-\n-\t\tabstract Object build();\n-\n-\t\tpublic boolean isMoreAvailable() {\n-\t\t\treturn moreAvailable;\n-\t\t}\n-\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t}\n-\t}\n-\n-\tstatic class BufferResponseMessage extends ServerOutboundMessage {\n-\t\tprivate final Buffer buffer;\n-\t\tprivate final int sequenceNumber;\n-\n-\t\tBufferResponseMessage(\n-\t\t\t\tBuffer buffer,\n-\t\t\t\tInputChannelID receiverId,\n-\t\t\t\tint sequenceNumber,\n-\t\t\t\tint backlog,\n-\t\t\t\tboolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n-\t\t\tthis.buffer = checkNotNull(buffer);\n-\t\t\tthis.sequenceNumber = sequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new BufferResponse(buffer, sequenceNumber, receiverId, backlog);\n-\t\t}\n-\n-\t\t@Override\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t\tbuffer.recycleBuffer();\n-\t\t}\n-\t}\n-\n-\tstatic class AddBacklogMessage extends ServerOutboundMessage {\n-\n-\t\tAddBacklogMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new AddBacklog(backlog, receiverId);\n-\t\t}\n-\t}\n+class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n+\n+    private final ChannelFutureListener writeListener =\n+            new WriteAndFlushNextMessageIfPossibleListener();\n+\n+    /** The readers which are already enqueued available for transferring data. */\n+    private final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n+\n+    /** All the readers created for the consumers' partition requests. */\n+    private final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders =\n+            new ConcurrentHashMap<>();\n+\n+    private boolean fatalError;\n+\n+    private ChannelHandlerContext ctx;\n+\n+    @Override\n+    public void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n+        if (this.ctx == null) {\n+            this.ctx = ctx;\n+        }\n+\n+        super.channelRegistered(ctx);\n+    }\n+\n+    void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n+        // The notification might come from the same thread. For the initial writes this\n+        // might happen before the reader has set its reference to the view, because\n+        // creating the queue and the initial notification happen in the same method call.\n+        // This can be resolved by separating the creation of the view and allowing\n+        // notifications.\n+\n+        // TODO This could potentially have a bad performance impact as in the\n+        // worst case (network consumes faster than the producer) each buffer\n+        // will trigger a separate event loop task being scheduled.\n+        ctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n+    }\n+\n+    /**\n+     * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n+     * non-empty reader notification from the producer.\n+     *\n+     * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n+     * availability, so there is no race condition here.\n+     */\n+    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n+        announceBacklogIfNeeded(reader, reader.getRemainingBacklog());\n+        if (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {\n+            return;\n+        }\n+        // Queue an available reader for consumption. If the queue is empty,\n+        // we try trigger the actual write. Otherwise this will be handled by\n+        // the writeAndFlushNextMessageIfPossible calls.\n+        boolean triggerWrite = availableReaders.isEmpty();\n+        registerAvailableReader(reader);\n+\n+        if (triggerWrite) {\n+            writeAndFlushNextMessageIfPossible(ctx.channel());\n+        }\n+    }\n+\n+    /**\n+     * Accesses internal state to verify reader registration in the unit tests.\n+     *\n+     * <p><strong>Do not use anywhere else!</strong>\n+     *\n+     * @return readers which are enqueued available for transferring data\n+     */\n+    @VisibleForTesting\n+    ArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n+        return availableReaders;\n+    }\n+\n+    public void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n+        allReaders.put(reader.getReceiverId(), reader);\n+    }\n+\n+    public void cancel(InputChannelID receiverId) {\n+        ctx.pipeline().fireUserEventTriggered(receiverId);\n+    }\n+\n+    public void close() throws IOException {\n+        if (ctx != null) {\n+            ctx.channel().close();\n+        }\n+\n+        releaseAllResources();\n+    }\n+\n+    /**\n+     * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n+     * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n+     *\n+     * @param receiverId The input channel id to identify the consumer.\n+     * @param operation The operation to be performed (add credit or resume data consumption).\n+     */\n+    void addCreditOrResumeConsumption(\n+            InputChannelID receiverId, Consumer<NetworkSequenceViewReader> operation)\n+            throws Exception {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            operation.accept(reader);\n+\n+            enqueueAvailableReader(reader);\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    /**\n+     * Announces remaining backlog to the consumer after the available data notification or data\n+     * consumption resumption.\n+     */\n+    private void announceBacklogIfNeeded(NetworkSequenceViewReader reader, int backlog) {\n+        if (backlog > 0 && reader.needAnnounceBacklog()) {\n+            NettyMessage.BacklogAnnouncement announcement =\n+                    new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n+            ctx.channel()\n+                    .writeAndFlush(announcement)\n+                    .addListener(\n+                            (ChannelFutureListener)\n+                                    future -> {\n+                                        if (!future.isSuccess()) {\n+                                            onChannelFutureFailure(future);\n+                                        }\n+                                    });\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        // The user event triggered event loop callback is used for thread-safe\n+        // hand over of reader queues and cancelled producers.\n+\n+        if (msg instanceof NetworkSequenceViewReader) {\n+            enqueueAvailableReader((NetworkSequenceViewReader) msg);\n+        } else if (msg.getClass() == InputChannelID.class) {\n+            // Release partition view that get a cancel request.\n+            InputChannelID toCancel = (InputChannelID) msg;\n+\n+            // remove reader from queue of available readers\n+            availableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n+\n+            // remove reader from queue of all readers and release its resource\n+            final NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n+            if (toRelease != null) {\n+                releaseViewReader(toRelease);\n+            }\n+        } else {\n+            ctx.fireUserEventTriggered(msg);\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        writeAndFlushNextMessageIfPossible(ctx.channel());\n+    }\n+\n+    private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n+        if (fatalError || !channel.isWritable()) {\n+            return;\n+        }\n+\n+        // The logic here is very similar to the combined input gate and local\n+        // input channel logic. You can think of this class acting as the input\n+        // gate and the consumed views as the local input channels.\n+\n+        BufferAndAvailability next = null;\n+        try {\n+            while (true) {\n+                NetworkSequenceViewReader reader = pollAvailableReader();\n+\n+                // No queue with available data. We allow this here, because\n+                // of the write callbacks that are executed after each write.\n+                if (reader == null) {\n+                    return;\n+                }\n+\n+                next = reader.getNextBuffer();\n+                if (next == null) {\n+                    if (!reader.isReleased()) {\n+                        continue;\n+                    }\n+\n+                    Throwable cause = reader.getFailureCause();\n+                    if (cause != null) {\n+                        ErrorResponse msg =\n+                                new ErrorResponse(\n+                                        new ProducerFailedException(cause), reader.getReceiverId());\n+\n+                        ctx.writeAndFlush(msg);\n+                    }\n+                } else {\n+                    // This channel was now removed from the available reader queue.\n+                    // We re-add it into the queue if it is still available\n+                    if (next.moreAvailable()) {\n+                        registerAvailableReader(reader);\n+                    }\n+\n+                    BufferResponse msg =\n+                            new BufferResponse(\n+                                    next.buffer(),\n+                                    next.getSequenceNumber(),\n+                                    reader.getReceiverId(),\n+                                    next.buffersInBacklog());\n+\n+                    // Write and flush and wait until this is done before\n+                    // trying to continue with the next buffer.\n+                    channel.writeAndFlush(msg).addListener(writeListener);\n+\n+                    return;\n+                }\n+            }\n+        } catch (Throwable t) {\n+            if (next != null) {\n+                next.buffer().recycleBuffer();\n+            }\n+\n+            throw new IOException(t.getMessage(), t);\n+        }\n+    }\n+\n+    private void registerAvailableReader(NetworkSequenceViewReader reader) {\n+        availableReaders.add(reader);\n+        reader.setRegisteredAsAvailable(true);\n+    }\n+\n+    @Nullable\n+    private NetworkSequenceViewReader pollAvailableReader() {\n+        NetworkSequenceViewReader reader = availableReaders.poll();\n+        if (reader != null) {\n+            reader.setRegisteredAsAvailable(false);\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        releaseAllResources();\n+\n+        ctx.fireChannelInactive();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        handleException(ctx.channel(), cause);\n+    }\n+\n+    private void handleException(Channel channel, Throwable cause) throws IOException {\n+        LOG.error(\"Encountered error while consuming partitions\", cause);\n+\n+        fatalError = true;\n+        releaseAllResources();\n+\n+        if (channel.isActive()) {\n+            channel.writeAndFlush(new ErrorResponse(cause))\n+                    .addListener(ChannelFutureListener.CLOSE);\n+        }\n+    }\n+\n+    private void releaseAllResources() throws IOException {\n+        // note: this is only ever executed by one thread: the Netty IO thread!\n+        for (NetworkSequenceViewReader reader : allReaders.values()) {\n+            releaseViewReader(reader);\n+        }\n+\n+        availableReaders.clear();\n+        allReaders.clear();\n+    }\n+\n+    private void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n+        reader.setRegisteredAsAvailable(false);\n+        reader.releaseAllResources();\n+    }\n+\n+    private void onChannelFutureFailure(ChannelFuture future) throws Exception {\n+        if (future.cause() != null) {\n+            handleException(future.channel(), future.cause());\n+        } else {\n+            handleException(\n+                    future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n+        }\n+    }\n+\n+    // This listener is called after an element of the current nonEmptyReader has been\n+    // flushed. If successful, the listener triggers further processing of the\n+    // queues.\n+    private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            try {\n+                if (future.isSuccess()) {\n+                    writeAndFlushNextMessageIfPossible(future.channel());\n+                } else {\n+                    onChannelFutureFailure(future);\n+                }\n+            } catch (Throwable t) {\n+                handleException(future.channel(), t);\n+            }\n+        }\n+    }\n }\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex df17ef3877c..0e3b6ddc57c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -350,8 +334,12 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n             try {\n                 if (future.isSuccess()) {\n                     writeAndFlushNextMessageIfPossible(future.channel());\n+                } else if (future.cause() != null) {\n+                    handleException(future.channel(), future.cause());\n                 } else {\n-                    onChannelFutureFailure(future);\n+                    handleException(\n+                            future.channel(),\n+                            new IllegalStateException(\"Sending cancelled by user.\"));\n                 }\n             } catch (Throwable t) {\n                 handleException(future.channel(), t);\n", "next_change": {"commit": "639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 0e3b6ddc57c..72ede48bda2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -334,12 +376,8 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n             try {\n                 if (future.isSuccess()) {\n                     writeAndFlushNextMessageIfPossible(future.channel());\n-                } else if (future.cause() != null) {\n-                    handleException(future.channel(), future.cause());\n                 } else {\n-                    handleException(\n-                            future.channel(),\n-                            new IllegalStateException(\"Sending cancelled by user.\"));\n+                    onChannelFutureFailure(future);\n                 }\n             } catch (Throwable t) {\n                 handleException(future.channel(), t);\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 8cfbd108656..72ede48bda2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -41,352 +42,346 @@ import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.function.Function;\n+import java.util.function.Consumer;\n \n import static org.apache.flink.runtime.io.network.netty.NettyMessage.BufferResponse;\n import static org.apache.flink.util.Preconditions.checkArgument;\n-import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n- * A nonEmptyReader of partition queues, which listens for channel writability changed\n- * events before writing and flushing {@link Buffer} instances.\n+ * A nonEmptyReader of partition queues, which listens for channel writability changed events before\n+ * writing and flushing {@link Buffer} instances.\n  */\n-public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n-\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n-\n-\tprivate final ChannelFutureListener writeListener = new WriteAndFlushNextMessageIfPossibleListener();\n-\n-\t/** The readers which are already enqueued available for transferring data or announcing backlog. */\n-\tprivate final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n-\n-\t/** All the readers created for the consumers' partition requests. */\n-\tprivate final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders = new ConcurrentHashMap<>();\n-\n-\tprivate boolean fatalError;\n-\n-\tprivate ChannelHandlerContext ctx;\n-\n-\t@Override\n-\tpublic void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n-\t\tif (this.ctx == null) {\n-\t\t\tthis.ctx = ctx;\n-\t\t}\n-\n-\t\tsuper.channelRegistered(ctx);\n-\t}\n-\n-\tvoid notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n-\t\t// The notification might come from the same thread. For the initial writes this\n-\t\t// might happen before the reader has set its reference to the view, because\n-\t\t// creating the queue and the initial notification happen in the same method call.\n-\t\t// This can be resolved by separating the creation of the view and allowing\n-\t\t// notifications.\n-\n-\t\t// TODO This could potentially have a bad performance impact as in the\n-\t\t// worst case (network consumes faster than the producer) each buffer\n-\t\t// will trigger a separate event loop task being scheduled.\n-\t\tctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n-\t}\n-\n-\t/**\n-\t * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n-\t * non-empty reader notification from the producer.\n-\t *\n-\t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n-\t * availability, so there is no race condition here.\n-\t */\n-\tprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader, boolean announceBacklog) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || (!reader.isAvailable() && !announceBacklog)) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Queue an available reader for consumption. If the queue is empty,\n-\t\t// we try trigger the actual write. Otherwise this will be handled by\n-\t\t// the writeAndFlushNextMessageIfPossible calls.\n-\t\tboolean triggerWrite = availableReaders.isEmpty();\n-\t\tregisterAvailableReader(reader);\n-\n-\t\tif (triggerWrite) {\n-\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Accesses internal state to verify reader registration in the unit tests.\n-\t *\n-\t * <p><strong>Do not use anywhere else!</strong>\n-\t *\n-\t * @return readers which are enqueued available for transferring data or announcing backlog\n-\t */\n-\t@VisibleForTesting\n-\tArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n-\t\treturn availableReaders;\n-\t}\n-\n-\tpublic void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n-\t\tallReaders.put(reader.getReceiverId(), reader);\n-\t}\n-\n-\tpublic void cancel(InputChannelID receiverId) {\n-\t\tctx.pipeline().fireUserEventTriggered(receiverId);\n-\t}\n-\n-\tpublic void close() throws IOException {\n-\t\tif (ctx != null) {\n-\t\t\tctx.channel().close();\n-\t\t}\n-\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\t\tallReaders.clear();\n-\t}\n-\n-\t/**\n-\t * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n-\t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n-\t *\n-\t * @param receiverId The input channel id to identify the consumer.\n-\t * @param function The operation to be performed (add credit or resume data consumption).\n-\t */\n-\tvoid addCreditOrResumeConsumption(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tFunction<NetworkSequenceViewReader, Boolean> function) throws Exception {\n-\t\tif (fatalError) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n-\t\tif (reader != null) {\n-\t\t\tboolean needAnnounceBacklog = function.apply(reader);\n-\n-\t\t\tenqueueAvailableReader(reader, needAnnounceBacklog);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"No reader for receiverId = \" + receiverId + \" exists.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\t// The user event triggered event loop callback is used for thread-safe\n-\t\t// hand over of reader queues and cancelled producers.\n-\n-\t\tif (msg instanceof NetworkSequenceViewReader) {\n-\t\t\tNetworkSequenceViewReader reader = (NetworkSequenceViewReader) msg;\n-\t\t\tenqueueAvailableReader(reader, reader.shouldAnnounceBacklog());\n-\t\t} else if (msg.getClass() == InputChannelID.class) {\n-\t\t\t// Release partition view that get a cancel request.\n-\t\t\tInputChannelID toCancel = (InputChannelID) msg;\n-\n-\t\t\t// remove reader from queue of available readers\n-\t\t\tavailableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n-\n-\t\t\t// remove reader from queue of all readers and release its resource\n-\t\t\tfinal NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n-\t\t\tif (toRelease != null) {\n-\t\t\t\treleaseViewReader(toRelease);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tctx.fireUserEventTriggered(msg);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t}\n-\n-\tprivate void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n-\t\tif (fatalError || !channel.isWritable()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// The logic here is very similar to the combined input gate and local\n-\t\t// input channel logic. You can think of this class acting as the input\n-\t\t// gate and the consumed views as the local input channels.\n-\n-\t\tServerOutboundMessage next = null;\n-\t\ttry {\n-\t\t\twhile (true) {\n-\t\t\t\tNetworkSequenceViewReader reader = pollAvailableReader();\n-\n-\t\t\t\t// No queue with available data. We allow this here, because\n-\t\t\t\t// of the write callbacks that are executed after each write.\n-\t\t\t\tif (reader == null) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\tnext = reader.getNextMessage();\n-\t\t\t\tif (next == null) {\n-\t\t\t\t\tif (!reader.isReleased()) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tThrowable cause = reader.getFailureCause();\n-\t\t\t\t\tif (cause != null) {\n-\t\t\t\t\t\tErrorResponse msg = new ErrorResponse(\n-\t\t\t\t\t\t\tnew ProducerFailedException(cause),\n-\t\t\t\t\t\t\treader.getReceiverId());\n-\n-\t\t\t\t\t\tctx.writeAndFlush(msg);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// This channel was now removed from the available reader queue.\n-\t\t\t\t\t// We re-add it into the queue if it is still available\n-\t\t\t\t\tif (next.isMoreAvailable()) {\n-\t\t\t\t\t\tregisterAvailableReader(reader);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Write and flush and wait until this is done before\n-\t\t\t\t\t// trying to continue with the next buffer.\n-\t\t\t\t\tchannel.writeAndFlush(next.build()).addListener(writeListener);\n-\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tif (next != null) {\n-\t\t\t\tnext.recycleBufferIfNeeded();\n-\t\t\t}\n-\n-\t\t\tthrow new IOException(t.getMessage(), t);\n-\t\t}\n-\t}\n-\n-\tprivate void registerAvailableReader(NetworkSequenceViewReader reader) {\n-\t\tavailableReaders.add(reader);\n-\t\treader.setRegisteredAsAvailable(true);\n-\t}\n-\n-\t@Nullable\n-\tprivate NetworkSequenceViewReader pollAvailableReader() {\n-\t\tNetworkSequenceViewReader reader = availableReaders.poll();\n-\t\tif (reader != null) {\n-\t\t\treader.setRegisteredAsAvailable(false);\n-\t\t}\n-\t\treturn reader;\n-\t}\n-\n-\t@Override\n-\tpublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-\t\treleaseAllResources();\n-\n-\t\tctx.fireChannelInactive();\n-\t}\n-\n-\t@Override\n-\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-\t\thandleException(ctx.channel(), cause);\n-\t}\n-\n-\tprivate void handleException(Channel channel, Throwable cause) throws IOException {\n-\t\tLOG.error(\"Encountered error while consuming partitions\", cause);\n-\n-\t\tfatalError = true;\n-\t\treleaseAllResources();\n-\n-\t\tif (channel.isActive()) {\n-\t\t\tchannel.writeAndFlush(new ErrorResponse(cause)).addListener(ChannelFutureListener.CLOSE);\n-\t\t}\n-\t}\n-\n-\tprivate void releaseAllResources() throws IOException {\n-\t\t// note: this is only ever executed by one thread: the Netty IO thread!\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\n-\t\tavailableReaders.clear();\n-\t\tallReaders.clear();\n-\t}\n-\n-\tprivate void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n-\t\treader.setRegisteredAsAvailable(false);\n-\t\treader.releaseAllResources();\n-\t}\n-\n-\t// This listener is called after an element of the current nonEmptyReader has been\n-\t// flushed. If successful, the listener triggers further processing of the\n-\t// queues.\n-\tprivate class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n-\n-\t\t@Override\n-\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n-\t\t\ttry {\n-\t\t\t\tif (future.isSuccess()) {\n-\t\t\t\t\twriteAndFlushNextMessageIfPossible(future.channel());\n-\t\t\t\t} else if (future.cause() != null) {\n-\t\t\t\t\thandleException(future.channel(), future.cause());\n-\t\t\t\t} else {\n-\t\t\t\t\thandleException(future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\thandleException(future.channel(), t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Outbound message to be sent to the client.\n-\t */\n-\tpublic static abstract class ServerOutboundMessage {\n-\t\tprotected final InputChannelID receiverId;\n-\t\tprotected final int backlog;\n-\t\tprivate final boolean moreAvailable;\n-\n-\t\tServerOutboundMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tcheckArgument(backlog >= 0, \"Number of backlog must be non-negative.\");\n-\t\t\tthis.receiverId = checkNotNull(receiverId);\n-\t\t\tthis.backlog = backlog;\n-\t\t\tthis.moreAvailable = moreAvailable;\n-\t\t}\n-\n-\t\tabstract Object build();\n-\n-\t\tpublic boolean isMoreAvailable() {\n-\t\t\treturn moreAvailable;\n-\t\t}\n-\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t}\n-\t}\n-\n-\tstatic class BufferResponseMessage extends ServerOutboundMessage {\n-\t\tprivate final Buffer buffer;\n-\t\tprivate final int sequenceNumber;\n-\n-\t\tBufferResponseMessage(\n-\t\t\t\tBuffer buffer,\n-\t\t\t\tInputChannelID receiverId,\n-\t\t\t\tint sequenceNumber,\n-\t\t\t\tint backlog,\n-\t\t\t\tboolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n-\t\t\tthis.buffer = checkNotNull(buffer);\n-\t\t\tthis.sequenceNumber = sequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new BufferResponse(buffer, sequenceNumber, receiverId, backlog);\n-\t\t}\n-\n-\t\t@Override\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t\tbuffer.recycleBuffer();\n-\t\t}\n-\t}\n-\n-\tstatic class AddBacklogMessage extends ServerOutboundMessage {\n-\n-\t\tAddBacklogMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new AddBacklog(backlog, receiverId);\n-\t\t}\n-\t}\n+class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n+\n+    private final ChannelFutureListener writeListener =\n+            new WriteAndFlushNextMessageIfPossibleListener();\n+\n+    /** The readers which are already enqueued available for transferring data. */\n+    private final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n+\n+    /** All the readers created for the consumers' partition requests. */\n+    private final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders =\n+            new ConcurrentHashMap<>();\n+\n+    private boolean fatalError;\n+\n+    private ChannelHandlerContext ctx;\n+\n+    @Override\n+    public void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n+        if (this.ctx == null) {\n+            this.ctx = ctx;\n+        }\n+\n+        super.channelRegistered(ctx);\n+    }\n+\n+    void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n+        // The notification might come from the same thread. For the initial writes this\n+        // might happen before the reader has set its reference to the view, because\n+        // creating the queue and the initial notification happen in the same method call.\n+        // This can be resolved by separating the creation of the view and allowing\n+        // notifications.\n+\n+        // TODO This could potentially have a bad performance impact as in the\n+        // worst case (network consumes faster than the producer) each buffer\n+        // will trigger a separate event loop task being scheduled.\n+        ctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n+    }\n+\n+    /**\n+     * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n+     * non-empty reader notification from the producer.\n+     *\n+     * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n+     * availability, so there is no race condition here.\n+     */\n+    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n+        if (reader.isRegisteredAsAvailable()) {\n+            return;\n+        }\n+\n+        ResultSubpartitionView.AvailabilityWithBacklog availabilityWithBacklog =\n+                reader.getAvailabilityAndBacklog();\n+        if (!availabilityWithBacklog.isAvailable()) {\n+            int backlog = availabilityWithBacklog.getBacklog();\n+            if (backlog > 0 && reader.needAnnounceBacklog()) {\n+                announceBacklog(reader, backlog);\n+            }\n+            return;\n+        }\n+\n+        // Queue an available reader for consumption. If the queue is empty,\n+        // we try trigger the actual write. Otherwise this will be handled by\n+        // the writeAndFlushNextMessageIfPossible calls.\n+        boolean triggerWrite = availableReaders.isEmpty();\n+        registerAvailableReader(reader);\n+\n+        if (triggerWrite) {\n+            writeAndFlushNextMessageIfPossible(ctx.channel());\n+        }\n+    }\n+\n+    /**\n+     * Accesses internal state to verify reader registration in the unit tests.\n+     *\n+     * <p><strong>Do not use anywhere else!</strong>\n+     *\n+     * @return readers which are enqueued available for transferring data\n+     */\n+    @VisibleForTesting\n+    ArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n+        return availableReaders;\n+    }\n+\n+    public void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n+        allReaders.put(reader.getReceiverId(), reader);\n+    }\n+\n+    public void cancel(InputChannelID receiverId) {\n+        ctx.pipeline().fireUserEventTriggered(receiverId);\n+    }\n+\n+    public void close() throws IOException {\n+        if (ctx != null) {\n+            ctx.channel().close();\n+        }\n+\n+        releaseAllResources();\n+    }\n+\n+    /**\n+     * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n+     * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n+     *\n+     * @param receiverId The input channel id to identify the consumer.\n+     * @param operation The operation to be performed (add credit or resume data consumption).\n+     */\n+    void addCreditOrResumeConsumption(\n+            InputChannelID receiverId, Consumer<NetworkSequenceViewReader> operation)\n+            throws Exception {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            operation.accept(reader);\n+\n+            enqueueAvailableReader(reader);\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    void acknowledgeAllRecordsProcessed(InputChannelID receiverId) {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            reader.acknowledgeAllRecordsProcessed();\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    /**\n+     * Announces remaining backlog to the consumer after the available data notification or data\n+     * consumption resumption.\n+     */\n+    private void announceBacklog(NetworkSequenceViewReader reader, int backlog) {\n+        checkArgument(backlog > 0, \"Backlog must be positive.\");\n+\n+        NettyMessage.BacklogAnnouncement announcement =\n+                new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n+        ctx.channel()\n+                .writeAndFlush(announcement)\n+                .addListener(\n+                        (ChannelFutureListener)\n+                                future -> {\n+                                    if (!future.isSuccess()) {\n+                                        onChannelFutureFailure(future);\n+                                    }\n+                                });\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        // The user event triggered event loop callback is used for thread-safe\n+        // hand over of reader queues and cancelled producers.\n+\n+        if (msg instanceof NetworkSequenceViewReader) {\n+            enqueueAvailableReader((NetworkSequenceViewReader) msg);\n+        } else if (msg.getClass() == InputChannelID.class) {\n+            // Release partition view that get a cancel request.\n+            InputChannelID toCancel = (InputChannelID) msg;\n+\n+            // remove reader from queue of available readers\n+            availableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n+\n+            // remove reader from queue of all readers and release its resource\n+            final NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n+            if (toRelease != null) {\n+                releaseViewReader(toRelease);\n+            }\n+        } else {\n+            ctx.fireUserEventTriggered(msg);\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        writeAndFlushNextMessageIfPossible(ctx.channel());\n+    }\n+\n+    private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n+        if (fatalError || !channel.isWritable()) {\n+            return;\n+        }\n+\n+        // The logic here is very similar to the combined input gate and local\n+        // input channel logic. You can think of this class acting as the input\n+        // gate and the consumed views as the local input channels.\n+\n+        BufferAndAvailability next = null;\n+        try {\n+            while (true) {\n+                NetworkSequenceViewReader reader = pollAvailableReader();\n+\n+                // No queue with available data. We allow this here, because\n+                // of the write callbacks that are executed after each write.\n+                if (reader == null) {\n+                    return;\n+                }\n+\n+                next = reader.getNextBuffer();\n+                if (next == null) {\n+                    if (!reader.isReleased()) {\n+                        continue;\n+                    }\n+\n+                    Throwable cause = reader.getFailureCause();\n+                    if (cause != null) {\n+                        ErrorResponse msg =\n+                                new ErrorResponse(\n+                                        new ProducerFailedException(cause), reader.getReceiverId());\n+\n+                        ctx.writeAndFlush(msg);\n+                    }\n+                } else {\n+                    // This channel was now removed from the available reader queue.\n+                    // We re-add it into the queue if it is still available\n+                    if (next.moreAvailable()) {\n+                        registerAvailableReader(reader);\n+                    }\n+\n+                    BufferResponse msg =\n+                            new BufferResponse(\n+                                    next.buffer(),\n+                                    next.getSequenceNumber(),\n+                                    reader.getReceiverId(),\n+                                    next.buffersInBacklog());\n+\n+                    // Write and flush and wait until this is done before\n+                    // trying to continue with the next buffer.\n+                    channel.writeAndFlush(msg).addListener(writeListener);\n+\n+                    return;\n+                }\n+            }\n+        } catch (Throwable t) {\n+            if (next != null) {\n+                next.buffer().recycleBuffer();\n+            }\n+\n+            throw new IOException(t.getMessage(), t);\n+        }\n+    }\n+\n+    private void registerAvailableReader(NetworkSequenceViewReader reader) {\n+        availableReaders.add(reader);\n+        reader.setRegisteredAsAvailable(true);\n+    }\n+\n+    @Nullable\n+    private NetworkSequenceViewReader pollAvailableReader() {\n+        NetworkSequenceViewReader reader = availableReaders.poll();\n+        if (reader != null) {\n+            reader.setRegisteredAsAvailable(false);\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        releaseAllResources();\n+\n+        ctx.fireChannelInactive();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        handleException(ctx.channel(), cause);\n+    }\n+\n+    private void handleException(Channel channel, Throwable cause) throws IOException {\n+        LOG.error(\"Encountered error while consuming partitions\", cause);\n+\n+        fatalError = true;\n+        releaseAllResources();\n+\n+        if (channel.isActive()) {\n+            channel.writeAndFlush(new ErrorResponse(cause))\n+                    .addListener(ChannelFutureListener.CLOSE);\n+        }\n+    }\n+\n+    private void releaseAllResources() throws IOException {\n+        // note: this is only ever executed by one thread: the Netty IO thread!\n+        for (NetworkSequenceViewReader reader : allReaders.values()) {\n+            releaseViewReader(reader);\n+        }\n+\n+        availableReaders.clear();\n+        allReaders.clear();\n+    }\n+\n+    private void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n+        reader.setRegisteredAsAvailable(false);\n+        reader.releaseAllResources();\n+    }\n+\n+    private void onChannelFutureFailure(ChannelFuture future) throws Exception {\n+        if (future.cause() != null) {\n+            handleException(future.channel(), future.cause());\n+        } else {\n+            handleException(\n+                    future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n+        }\n+    }\n+\n+    // This listener is called after an element of the current nonEmptyReader has been\n+    // flushed. If successful, the listener triggers further processing of the\n+    // queues.\n+    private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            try {\n+                if (future.isSuccess()) {\n+                    writeAndFlushNextMessageIfPossible(future.channel());\n+                } else {\n+                    onChannelFutureFailure(future);\n+                }\n+            } catch (Throwable t) {\n+                handleException(future.channel(), t);\n+            }\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "7478445aa30cd28b7b6402565ca304c916024475", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[refactor][runtime] Unification of obtaining reader in PartitionRequestQueue"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}, {"oid": "7bacef09622d43c01ca9a749bbcd259d5cd3e0fe", "committedDate": "2021-09-17 20:16:25 +0200", "message": "[FLINK-24233][runtime] Ignore message about new buffer size if the reader doesn't ready yet"}, {"oid": "f957e3fee50e734dd6b2cbf0cbbef00fe810cd32", "committedDate": "2022-01-13 15:07:28 +0100", "message": "[FLINK-25441][network] Wrap failure cuase with ProducerFailedException only for PipelinedSubpartitionView."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM3NDk3NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424374975", "body": "Renaming it to a boolean type `withoutExclusiveCredits` seems more direct to understand", "bodyText": "Renaming it to a boolean type withoutExclusiveCredits seems more direct to understand", "bodyHTML": "<p dir=\"auto\">Renaming it to a boolean type <code>withoutExclusiveCredits</code> seems more direct to understand</p>", "author": "zhijiangW", "createdAt": "2020-05-13T11:48:34Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -45,6 +47,8 @@\n \n \tprivate final PartitionRequestQueue requestQueue;\n \n+\tprivate final int initialCredit;", "originalCommit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 401550a55d3..09ce436d1ec 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -47,7 +47,7 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \n \tprivate final PartitionRequestQueue requestQueue;\n \n-\tprivate final int initialCredit;\n+\tprivate final boolean withoutExclusiveCredits;\n \n \tprivate volatile ResultSubpartitionView subpartitionView;\n \n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 09ce436d1ec..b1a8400b7a1 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -20,227 +20,225 @@ package org.apache.flink.runtime.io.network.netty;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.runtime.io.network.NetworkSequenceViewReader;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.AddBacklogMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.BufferResponseMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.ServerOutboundMessage;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n import org.apache.flink.runtime.io.network.partition.BufferAvailabilityListener;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionProvider;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputChannel.BufferAndAvailability;\n import org.apache.flink.runtime.io.network.partition.consumer.InputChannelID;\n import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n \n+import javax.annotation.Nullable;\n+\n import java.io.IOException;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n+\n /**\n  * Simple wrapper for the subpartition view used in the new network credit-based mode.\n  *\n- * <p>It also keeps track of available buffers and notifies the outbound\n- * handler about non-emptiness, similar to the {@link LocalInputChannel}.\n+ * <p>It also keeps track of available buffers and notifies the outbound handler about\n+ * non-emptiness, similar to the {@link LocalInputChannel}.\n  */\n-class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListener, NetworkSequenceViewReader {\n-\n-\tprivate final Object requestLock = new Object();\n-\n-\tprivate final InputChannelID receiverId;\n-\n-\tprivate final PartitionRequestQueue requestQueue;\n-\n-\tprivate final boolean withoutExclusiveCredits;\n-\n-\tprivate volatile ResultSubpartitionView subpartitionView;\n-\n-\t/**\n-\t * The status indicating whether this reader is already enqueued in the pipeline for transferring\n-\t * data or not.\n-\t *\n-\t * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n-\t * thread only since there is no synchronisation.\n-\t */\n-\tprivate boolean isRegisteredAsAvailable = false;\n-\n-\t/** The number of available buffers for holding data on the consumer side. */\n-\tprivate int numCreditsAvailable;\n-\n-\tprivate int sequenceNumber = -1;\n-\n-\tCreditBasedSequenceNumberingViewReader(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tint initialCredit,\n-\t\t\tPartitionRequestQueue requestQueue) {\n-\n-\t\tthis.receiverId = receiverId;\n-\t\tthis.numCreditsAvailable = initialCredit;\n-\t\tthis.requestQueue = requestQueue;\n-\t\tthis.withoutExclusiveCredits = initialCredit > 0;\n-\t}\n-\n-\t@Override\n-\tpublic void requestSubpartitionView(\n-\t\tResultPartitionProvider partitionProvider,\n-\t\tResultPartitionID resultPartitionId,\n-\t\tint subPartitionIndex) throws IOException {\n-\n-\t\tsynchronized (requestLock) {\n-\t\t\tif (subpartitionView == null) {\n-\t\t\t\t// This this call can trigger a notification we have to\n-\t\t\t\t// schedule a separate task at the event loop that will\n-\t\t\t\t// start consuming this. Otherwise the reference to the\n-\t\t\t\t// view cannot be available in getNextBuffer().\n-\t\t\t\tthis.subpartitionView = partitionProvider.createSubpartitionView(\n-\t\t\t\t\tresultPartitionId,\n-\t\t\t\t\tsubPartitionIndex,\n-\t\t\t\t\tthis);\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalStateException(\"Subpartition already requested\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void addCredit(int creditDeltas) throws Exception {\n-\t\tnumCreditsAvailable += creditDeltas;\n-\t\trequestQueue.enqueueAvailableReader(this, this::isAvailable);\n-\t}\n-\n-\t@Override\n-\tpublic boolean shouldAnnounceBacklog() {\n-\t\treturn !withoutExclusiveCredits && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption(int availableCredit, boolean hasUnfulfilledBacklog) throws Exception {\n-\t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredit;\n-\t\tsubpartitionView.resumeConsumption();\n-\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || !hasUnfulfilledBacklog && shouldAnnounceBacklog()));\n-\t}\n-\n-\t@Override\n-\tpublic void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n-\t\tthis.isRegisteredAsAvailable = isRegisteredAvailable;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRegisteredAsAvailable() {\n-\t\treturn isRegisteredAsAvailable;\n-\t}\n-\n-\t/**\n-\t * Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t */\n-\t@Override\n-\tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n-\t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n-\t}\n-\n-\t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n-\t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t *\n-\t * @param bufferAndBacklog\n-\t * \t\tcurrent buffer and backlog including information about the next buffer\n-\t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n-\t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic InputChannelID getReceiverId() {\n-\t\treturn receiverId;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumCreditsAvailable() {\n-\t\treturn numCreditsAvailable;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean hasBuffersAvailable() {\n-\t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\tprivate AddBacklogMessage getAddBacklogMessage() {\n-\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n-\t\tif (backlog > 0) {\n-\t\t\treturn new AddBacklogMessage(receiverId, backlog, false);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate BufferResponseMessage getBufferResponseMessage() throws IOException {\n-\t\tBufferAndBacklog next = subpartitionView.getNextBuffer();\n-\t\tif (next != null) {\n-\t\t\tsequenceNumber++;\n-\n-\t\t\tif (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n-\t\t\t\tthrow new IllegalStateException(\"no credit available\");\n-\t\t\t}\n-\n-\t\t\treturn new BufferResponseMessage(\n-\t\t\t\tnext.buffer(), receiverId, sequenceNumber, next.unannouncedBacklog(), isAvailable(next));\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic ServerOutboundMessage getNextMessage() throws IOException {\n-\t\t// BufferResponse is processed with higher priority compared with AddBacklog. There are three scenarios\n-\t\t// that we never announce backlog to the consumer through AddBacklog message:\n-\t\t// 1. We have exclusive credits which means unannounced backlog can be always carried by BufferResponse.\n-\t\t//    So AddBacklog message is never needed.\n-\t\t// 2. We already have available credits so we do not need to announce backlog to the consumer to request\n-\t\t//    new ones.\n-\t\t// 3. Next Buffer is an event which does not consume any credit. So we can just send the event and bring\n-\t\t//    the unannounced backlog with it.\n-\t\tif (withoutExclusiveCredits || numCreditsAvailable > 0 || subpartitionView.isAvailable(0)) {\n-\t\t\treturn getBufferResponseMessage();\n-\t\t}\n-\t\treturn getAddBacklogMessage();\n-\t}\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn subpartitionView.isReleased();\n-\t}\n-\n-\t@Override\n-\tpublic Throwable getFailureCause() {\n-\t\treturn subpartitionView.getFailureCause();\n-\t}\n-\n-\t@Override\n-\tpublic void releaseAllResources() throws IOException {\n-\t\tsubpartitionView.releaseAllResources();\n-\t}\n-\n-\t@Override\n-\tpublic void notifyDataAvailable() {\n-\t\trequestQueue.notifyReaderNonEmpty(this);\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"CreditBasedSequenceNumberingViewReader{\" +\n-\t\t\t\"requestLock=\" + requestLock +\n-\t\t\t\", receiverId=\" + receiverId +\n-\t\t\t\", withoutExclusiveCredits=\" + withoutExclusiveCredits +\n-\t\t\t\", sequenceNumber=\" + sequenceNumber +\n-\t\t\t\", numCreditsAvailable=\" + numCreditsAvailable +\n-\t\t\t\", isRegisteredAsAvailable=\" + isRegisteredAsAvailable +\n-\t\t\t'}';\n-\t}\n+class CreditBasedSequenceNumberingViewReader\n+        implements BufferAvailabilityListener, NetworkSequenceViewReader {\n+\n+    private final Object requestLock = new Object();\n+\n+    private final InputChannelID receiverId;\n+\n+    private final PartitionRequestQueue requestQueue;\n+\n+    private final int initialCredit;\n+\n+    private volatile ResultSubpartitionView subpartitionView;\n+\n+    /**\n+     * The status indicating whether this reader is already enqueued in the pipeline for\n+     * transferring data or not.\n+     *\n+     * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n+     * thread only since there is no synchronisation.\n+     */\n+    private boolean isRegisteredAsAvailable = false;\n+\n+    /** The number of available buffers for holding data on the consumer side. */\n+    private int numCreditsAvailable;\n+\n+    CreditBasedSequenceNumberingViewReader(\n+            InputChannelID receiverId, int initialCredit, PartitionRequestQueue requestQueue) {\n+        checkArgument(initialCredit >= 0, \"Must be non-negative.\");\n+\n+        this.receiverId = receiverId;\n+        this.initialCredit = initialCredit;\n+        this.numCreditsAvailable = initialCredit;\n+        this.requestQueue = requestQueue;\n+    }\n+\n+    @Override\n+    public void requestSubpartitionView(\n+            ResultPartitionProvider partitionProvider,\n+            ResultPartitionID resultPartitionId,\n+            int subPartitionIndex)\n+            throws IOException {\n+\n+        synchronized (requestLock) {\n+            if (subpartitionView == null) {\n+                // This this call can trigger a notification we have to\n+                // schedule a separate task at the event loop that will\n+                // start consuming this. Otherwise the reference to the\n+                // view cannot be available in getNextBuffer().\n+                this.subpartitionView =\n+                        partitionProvider.createSubpartitionView(\n+                                resultPartitionId, subPartitionIndex, this);\n+            } else {\n+                throw new IllegalStateException(\"Subpartition already requested\");\n+            }\n+        }\n+\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public void addCredit(int creditDeltas) {\n+        numCreditsAvailable += creditDeltas;\n+    }\n+\n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n+    @Override\n+    public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;\n+        }\n+\n+        subpartitionView.resumeConsumption();\n+    }\n+\n+    @Override\n+    public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n+        this.isRegisteredAsAvailable = isRegisteredAvailable;\n+    }\n+\n+    @Override\n+    public boolean isRegisteredAsAvailable() {\n+        return isRegisteredAsAvailable;\n+    }\n+\n+    /**\n+     * Returns true only if the next buffer is an event or the reader has both available credits and\n+     * buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such\n+     *     that {@code getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n+     */\n+    @Override\n+    public boolean isAvailable() {\n+        return subpartitionView.isAvailable(numCreditsAvailable);\n+    }\n+\n+    /**\n+     * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next\n+     * buffer in line.\n+     *\n+     * <p>Returns the next data type only if the next buffer is an event or the reader has both\n+     * available credits and buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #isAvailable()}, such that {@code\n+     *     getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n+     * @param bufferAndBacklog current buffer and backlog including information about the next\n+     *     buffer\n+     * @return the next data type if the next buffer can be pulled immediately or {@link\n+     *     Buffer.DataType#NONE}\n+     */\n+    private Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n+        final Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+        if (numCreditsAvailable > 0 || nextDataType.isEvent()) {\n+            return nextDataType;\n+        }\n+        return Buffer.DataType.NONE;\n+    }\n+\n+    @Override\n+    public InputChannelID getReceiverId() {\n+        return receiverId;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumCreditsAvailable() {\n+        return numCreditsAvailable;\n+    }\n+\n+    @VisibleForTesting\n+    boolean hasBuffersAvailable() {\n+        return subpartitionView.isAvailable(Integer.MAX_VALUE);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BufferAndAvailability getNextBuffer() throws IOException {\n+        BufferAndBacklog next = subpartitionView.getNextBuffer();\n+        if (next != null) {\n+            if (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n+                throw new IllegalStateException(\"no credit available\");\n+            }\n+\n+            final Buffer.DataType nextDataType = getNextDataType(next);\n+            return new BufferAndAvailability(\n+                    next.buffer(), nextDataType, next.buffersInBacklog(), next.getSequenceNumber());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public int getRemainingBacklog() {\n+        return subpartitionView.getRemainingBacklog();\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        return subpartitionView.isReleased();\n+    }\n+\n+    @Override\n+    public Throwable getFailureCause() {\n+        return subpartitionView.getFailureCause();\n+    }\n+\n+    @Override\n+    public void releaseAllResources() throws IOException {\n+        subpartitionView.releaseAllResources();\n+    }\n+\n+    @Override\n+    public void notifyDataAvailable() {\n+        requestQueue.notifyReaderNonEmpty(this);\n+    }\n+\n+    @Override\n+    public void notifyPriorityEvent(int prioritySequenceNumber) {\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CreditBasedSequenceNumberingViewReader{\"\n+                + \"requestLock=\"\n+                + requestLock\n+                + \", receiverId=\"\n+                + receiverId\n+                + \", numCreditsAvailable=\"\n+                + numCreditsAvailable\n+                + \", isRegisteredAsAvailable=\"\n+                + isRegisteredAsAvailable\n+                + '}';\n+    }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 401550a55d3..01d08d5f53c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -20,220 +20,226 @@ package org.apache.flink.runtime.io.network.netty;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.runtime.io.network.NetworkSequenceViewReader;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.AddBacklogMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.BufferResponseMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.ServerOutboundMessage;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n import org.apache.flink.runtime.io.network.partition.BufferAvailabilityListener;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionProvider;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputChannel.BufferAndAvailability;\n import org.apache.flink.runtime.io.network.partition.consumer.InputChannelID;\n import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n \n+import javax.annotation.Nullable;\n+\n import java.io.IOException;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n+\n /**\n  * Simple wrapper for the subpartition view used in the new network credit-based mode.\n  *\n- * <p>It also keeps track of available buffers and notifies the outbound\n- * handler about non-emptiness, similar to the {@link LocalInputChannel}.\n+ * <p>It also keeps track of available buffers and notifies the outbound handler about\n+ * non-emptiness, similar to the {@link LocalInputChannel}.\n  */\n-class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListener, NetworkSequenceViewReader {\n-\n-\tprivate final Object requestLock = new Object();\n-\n-\tprivate final InputChannelID receiverId;\n-\n-\tprivate final PartitionRequestQueue requestQueue;\n-\n-\tprivate final int initialCredit;\n-\n-\tprivate volatile ResultSubpartitionView subpartitionView;\n-\n-\t/**\n-\t * The status indicating whether this reader is already enqueued in the pipeline for transferring\n-\t * data or not.\n-\t *\n-\t * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n-\t * thread only since there is no synchronisation.\n-\t */\n-\tprivate boolean isRegisteredAsAvailable = false;\n-\n-\t/** The number of available buffers for holding data on the consumer side. */\n-\tprivate int numCreditsAvailable;\n-\n-\tprivate int sequenceNumber = -1;\n-\n-\tCreditBasedSequenceNumberingViewReader(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tint initialCredit,\n-\t\t\tPartitionRequestQueue requestQueue) {\n-\n-\t\tthis.receiverId = receiverId;\n-\t\tthis.numCreditsAvailable = initialCredit;\n-\t\tthis.requestQueue = requestQueue;\n-\t\tthis.initialCredit = initialCredit;\n-\t}\n-\n-\t@Override\n-\tpublic void requestSubpartitionView(\n-\t\tResultPartitionProvider partitionProvider,\n-\t\tResultPartitionID resultPartitionId,\n-\t\tint subPartitionIndex) throws IOException {\n-\n-\t\tsynchronized (requestLock) {\n-\t\t\tif (subpartitionView == null) {\n-\t\t\t\t// This this call can trigger a notification we have to\n-\t\t\t\t// schedule a separate task at the event loop that will\n-\t\t\t\t// start consuming this. Otherwise the reference to the\n-\t\t\t\t// view cannot be available in getNextBuffer().\n-\t\t\t\tthis.subpartitionView = partitionProvider.createSubpartitionView(\n-\t\t\t\t\tresultPartitionId,\n-\t\t\t\t\tsubPartitionIndex,\n-\t\t\t\t\tthis);\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalStateException(\"Subpartition already requested\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic boolean addCredit(int creditDeltas) {\n-\t\tnumCreditsAvailable += creditDeltas;\n-\t\treturn false;\n-\t}\n-\n-\t@Override\n-\tpublic boolean shouldAnnounceBacklog() {\n-\t\treturn initialCredit == 0 && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\t@Override\n-\tpublic boolean resumeConsumption(int availableCredit, int unfulfilledBacklog) {\n-\t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredit;\n-\t\tsubpartitionView.resumeConsumption();\n-\n-\t\treturn shouldAnnounceBacklog() && unfulfilledBacklog == 0;\n-\t}\n-\n-\t@Override\n-\tpublic void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n-\t\tthis.isRegisteredAsAvailable = isRegisteredAvailable;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRegisteredAsAvailable() {\n-\t\treturn isRegisteredAsAvailable;\n-\t}\n-\n-\t/**\n-\t * Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t */\n-\t@Override\n-\tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n-\t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n-\t}\n-\n-\t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n-\t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t *\n-\t * @param bufferAndBacklog\n-\t * \t\tcurrent buffer and backlog including information about the next buffer\n-\t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n-\t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic InputChannelID getReceiverId() {\n-\t\treturn receiverId;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumCreditsAvailable() {\n-\t\treturn numCreditsAvailable;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean hasBuffersAvailable() {\n-\t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\tprivate AddBacklogMessage getAddBacklogMessage() {\n-\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n-\t\tif (backlog > 0) {\n-\t\t\treturn new AddBacklogMessage(receiverId, backlog, false);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate BufferResponseMessage getBufferResponseMessage() throws IOException {\n-\t\tBufferAndBacklog next = subpartitionView.getNextBuffer();\n-\t\tif (next != null) {\n-\t\t\tsequenceNumber++;\n-\n-\t\t\tif (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n-\t\t\t\tthrow new IllegalStateException(\"no credit available\");\n-\t\t\t}\n-\n-\t\t\treturn new BufferResponseMessage(\n-\t\t\t\tnext.buffer(), receiverId, sequenceNumber, next.unannouncedBacklog(), isAvailable(next));\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic ServerOutboundMessage getNextMessage() throws IOException {\n-\t\tif (numCreditsAvailable == 0 && initialCredit == 0 && !subpartitionView.isAvailable(0)) {\n-\t\t\treturn getAddBacklogMessage();\n-\t\t}\n-\t\treturn getBufferResponseMessage();\n-\t}\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn subpartitionView.isReleased();\n-\t}\n-\n-\t@Override\n-\tpublic Throwable getFailureCause() {\n-\t\treturn subpartitionView.getFailureCause();\n-\t}\n-\n-\t@Override\n-\tpublic void releaseAllResources() throws IOException {\n-\t\tsubpartitionView.releaseAllResources();\n-\t}\n-\n-\t@Override\n-\tpublic void notifyDataAvailable() {\n-\t\trequestQueue.notifyReaderNonEmpty(this);\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"CreditBasedSequenceNumberingViewReader{\" +\n-\t\t\t\"requestLock=\" + requestLock +\n-\t\t\t\", receiverId=\" + receiverId +\n-\t\t\t\", initialCredit=\" + initialCredit +\n-\t\t\t\", sequenceNumber=\" + sequenceNumber +\n-\t\t\t\", numCreditsAvailable=\" + numCreditsAvailable +\n-\t\t\t\", isRegisteredAsAvailable=\" + isRegisteredAsAvailable +\n-\t\t\t'}';\n-\t}\n+class CreditBasedSequenceNumberingViewReader\n+        implements BufferAvailabilityListener, NetworkSequenceViewReader {\n+\n+    private final Object requestLock = new Object();\n+\n+    private final InputChannelID receiverId;\n+\n+    private final PartitionRequestQueue requestQueue;\n+\n+    private final int initialCredit;\n+\n+    private volatile ResultSubpartitionView subpartitionView;\n+\n+    /**\n+     * The status indicating whether this reader is already enqueued in the pipeline for\n+     * transferring data or not.\n+     *\n+     * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n+     * thread only since there is no synchronisation.\n+     */\n+    private boolean isRegisteredAsAvailable = false;\n+\n+    /** The number of available buffers for holding data on the consumer side. */\n+    private int numCreditsAvailable;\n+\n+    CreditBasedSequenceNumberingViewReader(\n+            InputChannelID receiverId, int initialCredit, PartitionRequestQueue requestQueue) {\n+        checkArgument(initialCredit >= 0, \"Must be non-negative.\");\n+\n+        this.receiverId = receiverId;\n+        this.initialCredit = initialCredit;\n+        this.numCreditsAvailable = initialCredit;\n+        this.requestQueue = requestQueue;\n+    }\n+\n+    @Override\n+    public void requestSubpartitionView(\n+            ResultPartitionProvider partitionProvider,\n+            ResultPartitionID resultPartitionId,\n+            int subPartitionIndex)\n+            throws IOException {\n+\n+        synchronized (requestLock) {\n+            if (subpartitionView == null) {\n+                // This call can trigger a notification we have to\n+                // schedule a separate task at the event loop that will\n+                // start consuming this. Otherwise the reference to the\n+                // view cannot be available in getNextBuffer().\n+                this.subpartitionView =\n+                        partitionProvider.createSubpartitionView(\n+                                resultPartitionId, subPartitionIndex, this);\n+            } else {\n+                throw new IllegalStateException(\"Subpartition already requested\");\n+            }\n+        }\n+\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public void addCredit(int creditDeltas) {\n+        numCreditsAvailable += creditDeltas;\n+    }\n+\n+    @Override\n+    public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;\n+        }\n+        subpartitionView.resumeConsumption();\n+    }\n+\n+    @Override\n+    public void acknowledgeAllRecordsProcessed() {\n+        subpartitionView.acknowledgeAllRecordsProcessed();\n+    }\n+\n+    @Override\n+    public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n+        this.isRegisteredAsAvailable = isRegisteredAvailable;\n+    }\n+\n+    @Override\n+    public boolean isRegisteredAsAvailable() {\n+        return isRegisteredAsAvailable;\n+    }\n+\n+    /**\n+     * Returns true only if the next buffer is an event or the reader has both available credits and\n+     * buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such\n+     *     that {@code getNextDataType(bufferAndBacklog) != NONE <=>\n+     *     AvailabilityWithBacklog#isAvailable()}!\n+     */\n+    @Override\n+    public ResultSubpartitionView.AvailabilityWithBacklog getAvailabilityAndBacklog() {\n+        return subpartitionView.getAvailabilityAndBacklog(numCreditsAvailable);\n+    }\n+\n+    /**\n+     * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next\n+     * buffer in line.\n+     *\n+     * <p>Returns the next data type only if the next buffer is an event or the reader has both\n+     * available credits and buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getAvailabilityAndBacklog()}, such that\n+     *     {@code getNextDataType(bufferAndBacklog) != NONE <=>\n+     *     AvailabilityWithBacklog#isAvailable()}!\n+     * @param bufferAndBacklog current buffer and backlog including information about the next\n+     *     buffer\n+     * @return the next data type if the next buffer can be pulled immediately or {@link\n+     *     Buffer.DataType#NONE}\n+     */\n+    private Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n+        final Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+        if (numCreditsAvailable > 0 || nextDataType.isEvent()) {\n+            return nextDataType;\n+        }\n+        return Buffer.DataType.NONE;\n+    }\n+\n+    @Override\n+    public InputChannelID getReceiverId() {\n+        return receiverId;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumCreditsAvailable() {\n+        return numCreditsAvailable;\n+    }\n+\n+    @VisibleForTesting\n+    ResultSubpartitionView.AvailabilityWithBacklog hasBuffersAvailable() {\n+        return subpartitionView.getAvailabilityAndBacklog(Integer.MAX_VALUE);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BufferAndAvailability getNextBuffer() throws IOException {\n+        BufferAndBacklog next = subpartitionView.getNextBuffer();\n+        if (next != null) {\n+            if (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n+                throw new IllegalStateException(\"no credit available\");\n+            }\n+\n+            final Buffer.DataType nextDataType = getNextDataType(next);\n+            return new BufferAndAvailability(\n+                    next.buffer(), nextDataType, next.buffersInBacklog(), next.getSequenceNumber());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        return subpartitionView.isReleased();\n+    }\n+\n+    @Override\n+    public Throwable getFailureCause() {\n+        return subpartitionView.getFailureCause();\n+    }\n+\n+    @Override\n+    public void releaseAllResources() throws IOException {\n+        subpartitionView.releaseAllResources();\n+    }\n+\n+    @Override\n+    public void notifyDataAvailable() {\n+        requestQueue.notifyReaderNonEmpty(this);\n+    }\n+\n+    @Override\n+    public void notifyPriorityEvent(int prioritySequenceNumber) {\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CreditBasedSequenceNumberingViewReader{\"\n+                + \"requestLock=\"\n+                + requestLock\n+                + \", receiverId=\"\n+                + receiverId\n+                + \", numCreditsAvailable=\"\n+                + numCreditsAvailable\n+                + \", isRegisteredAsAvailable=\"\n+                + isRegisteredAsAvailable\n+                + '}';\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MDk0MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424860940", "body": "nit: bufferReleased  -> numReleasedBuffers", "bodyText": "nit: bufferReleased  -> numReleasedBuffers", "bodyHTML": "<p dir=\"auto\">nit: bufferReleased  -&gt; numReleasedBuffers</p>", "author": "zhijiangW", "createdAt": "2020-05-14T04:14:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -151,23 +150,43 @@ int requestFloatingBuffers(int numRequired) throws IOException {\n \t\t\t\treturn numRequestedBuffers;\n \t\t\t}\n \n-\t\t\tnumRequiredBuffers = numRequired;\n+\t\t\tnumRequiredBuffers += numRequired;\n+\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n \n-\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n-\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\t\tnumRequestedBuffers++;\n-\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n+\t\tassert Thread.holdsLock(bufferQueue);\n+\n+\t\tint numRequestedBuffers = 0;\n+\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n+\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\tif (buffer != null) {\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\tnumRequestedBuffers++;\n+\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\treturn numRequestedBuffers;\n \t}\n \n+\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tif (isWaitingForFloatingBuffers) {\n+\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n+\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t}\n+\n+\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();", "originalCommit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 7fb7cf9358b..78c34783461 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -182,8 +182,7 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t\t\t\tisWaitingForFloatingBuffers = false;\n \t\t\t}\n \n-\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n-\t\t\tnumRequiredBuffers += bufferReleased;\n+\t\t\tnumRequiredBuffers += bufferQueue.releaseFloatingBuffers();\n \t\t}\n \t}\n \n", "next_change": {"commit": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 78c34783461..0f216cae4d1 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -175,17 +174,6 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t\treturn numRequestedBuffers;\n \t}\n \n-\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += bufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n \t// ------------------------------------------------------------------------\n \t// Buffer recycle\n \t// ------------------------------------------------------------------------\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 0f216cae4d1..ba6e75d3a43 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -41,391 +41,402 @@ import java.util.List;\n \n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += numRequired;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers(boolean isTemporaryRelease) {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tint numReleasedBuffers = bufferQueue.releaseFloatingBuffers();\n-\t\t\tif (isTemporaryRelease) {\n-\t\t\t\tnumRequiredBuffers += numReleasedBuffers;\n-\t\t\t} else {\n-\t\t\t\tnumRequiredBuffers = 0;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint getNumberOfRequiredBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn numRequiredBuffers;\n-\t\t}\n-\t}\n-\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn isWaitingForFloatingBuffers;\n-\t\t}\n-\t}\n-\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffers() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer(int initialCredit) {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            if (initialCredit == 0) {\n+                checkState(\n+                        bufferQueue.getAvailableBufferSize() <= numRequiredBuffers,\n+                        \"Too many buffers allocated.\");\n+                --numRequiredBuffers;\n+            }\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        if (numExclusiveBuffers <= 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        int numAddedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                } else {\n+                    numAddedBuffers =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        try {\n+            inputChannel.notifyBufferAvailable(numAddedBuffers);\n+        } catch (Throwable t) {\n+            ExceptionUtils.rethrow(t);\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            bufferQueue.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            if (buffer.getRecycler() == this) {\n+                exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+            } else {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+        synchronized (bufferQueue) {\n+            bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+            bufferQueue.notifyAll();\n+        }\n+\n+        if (exclusiveRecyclingSegments.size() > 0) {\n+            globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n+         * number of available buffers in queue is more than the required amount.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return How many buffers were added to the queue\n+         */\n+        int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                Buffer floatingBuffer = floatingBuffers.poll();\n+                if (floatingBuffer != null) {\n+                    floatingBuffer.recycleBuffer();\n+                    return 0;\n+                }\n+            }\n+            return 1;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": {"commit": "8550965d808fe7b4d6ff2d48034612878937a579", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex ba6e75d3a43..8031f6b5d3c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -428,11 +448,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..82162f51ae3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,10 +448,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        Queue<Buffer> clearFloatingBuffers() {\n-            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n-            floatingBuffers.clear();\n-            return buffers;\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 82162f51ae3..0867fbba828 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,11 +458,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 7fb7cf9358b..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -38,400 +38,435 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Queue;\n \n+import static org.apache.flink.util.ExceptionUtils.firstOrSuppressed;\n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += numRequired;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n-\t\t\tnumRequiredBuffers += bufferReleased;\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tnumRequiredBuffers = 0;\n-\t\t\tbufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint getNumberOfRequiredBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn numRequiredBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn isWaitingForFloatingBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffers() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer() {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            --numRequiredBuffers;\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        checkArgument(numExclusiveBuffers >= 0, \"Num exclusive buffers must be non-negative.\");\n+        if (numExclusiveBuffers == 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            // AvailableBufferQueue::addExclusiveBuffer may release the previously allocated\n+            // floating buffer, which requires the caller to recycle these released floating\n+            // buffers. There should be no floating buffers that have been allocated before the\n+            // exclusive buffers are initialized, so here only a simple assertion is required\n+            checkState(\n+                    unsynchronizedGetFloatingBuffersAvailable() == 0,\n+                    \"Bug in buffer allocation logic: floating buffer is allocated before exclusive buffers are initialized.\");\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        @Nullable Buffer releasedFloatingBuffer = null;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                    return;\n+                } else {\n+                    releasedFloatingBuffer =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        if (releasedFloatingBuffer != null) {\n+            releasedFloatingBuffer.recycleBuffer();\n+        } else {\n+            try {\n+                inputChannel.notifyBufferAvailable(1);\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            }\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        Queue<Buffer> buffers;\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            buffers = bufferQueue.clearFloatingBuffers();\n+        }\n+\n+        // recycle all buffers out of the synchronization block to avoid dead lock\n+        while (!buffers.isEmpty()) {\n+            buffers.poll().recycleBuffer();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Exception err = null;\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            try {\n+                if (buffer.getRecycler() == BufferManager.this) {\n+                    exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+                } else {\n+                    buffer.recycleBuffer();\n+                }\n+            } catch (Exception e) {\n+                err = firstOrSuppressed(e, err);\n+            }\n+        }\n+        try {\n+            synchronized (bufferQueue) {\n+                bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+                bufferQueue.notifyAll();\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        try {\n+            if (exclusiveRecyclingSegments.size() > 0) {\n+                globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        if (err != null) {\n+            throw err instanceof IOException ? (IOException) err : new IOException(err);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and releases one floating buffer if the\n+         * number of available buffers in queue is more than the required amount. If floating buffer\n+         * is released, the total amount of available buffers after adding this exclusive buffer has\n+         * not changed, and no new buffers are available. The caller is responsible for recycling\n+         * the release/returned floating buffer.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return An released floating buffer, may be null if the numRequiredBuffers is not met.\n+         */\n+        @Nullable\n+        Buffer addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                return floatingBuffers.poll();\n+            }\n+            return null;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "48a384dffc770289a38df816a38bd336ea992ed7", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[FLINK-23466][network] Fix the bug that buffer listeners may not be notified when recycling buffers"}, {"oid": "c91837edb782c67eab799a569077053695a29fc3", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[hotfix][refactor] Remove BufferListener#NotificationResult to simplify the code"}, {"oid": "38f7c593538d78e67ed75f006826b9fc3e97826e", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[hotfix] Rename some methods of NetworkBufferPool and add more comments for better readability"}]}, {"oid": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "url": "https://github.com/apache/flink/commit/b0bc4fc762c88de29509bb7ffb16c71203327fa8", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T04:17:19Z", "type": "forcePushed"}, {"oid": "e033307ba22ee660cd6c39063896500075b60671", "url": "https://github.com/apache/flink/commit/e033307ba22ee660cd6c39063896500075b60671", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T04:22:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MzUyMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424863522", "body": "This method should be placed into the below section `Buffer recycle`. \r\n\r\nI think it is better to integrate this method with existing `#releaseFloatingBuffers` to provide a general one, otherwise it might bring confusing to understand the difference among them, especially for the different handle of `numRequiredBuffers`, to make them seem customized logic.\r\n\r\nThe integration is as below\r\n\r\n```\r\nvoid releaseFloatingBuffers(boolean isTemporaryRelease) {\r\n\t\tsynchronized (bufferQueue) {\r\n\t\t\tif (isWaitingForFloatingBuffers) {\r\n\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\r\n\t\t\t\tisWaitingForFloatingBuffers = false;\r\n\t\t\t}\r\n\r\n\t\t\tint numReleasedBuffers = bufferQueue.releaseFloatingBuffers();\r\n\t\t\tif (isTemporaryRelease) {\r\n\t\t\t\tnumRequiredBuffers += numReleasedBuffers;\r\n\t\t\t} else {\r\n\t\t\t\tnumRequiredBuffers = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n```", "bodyText": "This method should be placed into the below section Buffer recycle.\nI think it is better to integrate this method with existing #releaseFloatingBuffers to provide a general one, otherwise it might bring confusing to understand the difference among them, especially for the different handle of numRequiredBuffers, to make them seem customized logic.\nThe integration is as below\nvoid releaseFloatingBuffers(boolean isTemporaryRelease) {\n\t\tsynchronized (bufferQueue) {\n\t\t\tif (isWaitingForFloatingBuffers) {\n\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n\t\t\t\tisWaitingForFloatingBuffers = false;\n\t\t\t}\n\n\t\t\tint numReleasedBuffers = bufferQueue.releaseFloatingBuffers();\n\t\t\tif (isTemporaryRelease) {\n\t\t\t\tnumRequiredBuffers += numReleasedBuffers;\n\t\t\t} else {\n\t\t\t\tnumRequiredBuffers = 0;\n\t\t\t}\n\t\t}\n\t}", "bodyHTML": "<p dir=\"auto\">This method should be placed into the below section <code>Buffer recycle</code>.</p>\n<p dir=\"auto\">I think it is better to integrate this method with existing <code>#releaseFloatingBuffers</code> to provide a general one, otherwise it might bring confusing to understand the difference among them, especially for the different handle of <code>numRequiredBuffers</code>, to make them seem customized logic.</p>\n<p dir=\"auto\">The integration is as below</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"void releaseFloatingBuffers(boolean isTemporaryRelease) {\n\t\tsynchronized (bufferQueue) {\n\t\t\tif (isWaitingForFloatingBuffers) {\n\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n\t\t\t\tisWaitingForFloatingBuffers = false;\n\t\t\t}\n\n\t\t\tint numReleasedBuffers = bufferQueue.releaseFloatingBuffers();\n\t\t\tif (isTemporaryRelease) {\n\t\t\t\tnumRequiredBuffers += numReleasedBuffers;\n\t\t\t} else {\n\t\t\t\tnumRequiredBuffers = 0;\n\t\t\t}\n\t\t}\n\t}\n\"><pre><code>void releaseFloatingBuffers(boolean isTemporaryRelease) {\n\t\tsynchronized (bufferQueue) {\n\t\t\tif (isWaitingForFloatingBuffers) {\n\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n\t\t\t\tisWaitingForFloatingBuffers = false;\n\t\t\t}\n\n\t\t\tint numReleasedBuffers = bufferQueue.releaseFloatingBuffers();\n\t\t\tif (isTemporaryRelease) {\n\t\t\t\tnumRequiredBuffers += numReleasedBuffers;\n\t\t\t} else {\n\t\t\t\tnumRequiredBuffers = 0;\n\t\t\t}\n\t\t}\n\t}\n</code></pre></div>", "author": "zhijiangW", "createdAt": "2020-05-14T04:25:44Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -151,23 +149,42 @@ int requestFloatingBuffers(int numRequired) throws IOException {\n \t\t\t\treturn numRequestedBuffers;\n \t\t\t}\n \n-\t\t\tnumRequiredBuffers = numRequired;\n+\t\t\tnumRequiredBuffers += numRequired;\n+\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n \n-\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n-\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\t\tnumRequestedBuffers++;\n-\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n+\t\tassert Thread.holdsLock(bufferQueue);\n+\n+\t\tint numRequestedBuffers = 0;\n+\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n+\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\tif (buffer != null) {\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\tnumRequestedBuffers++;\n+\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\treturn numRequestedBuffers;\n \t}\n \n+\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {", "originalCommit": "e033307ba22ee660cd6c39063896500075b60671", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 6074cef11af..0f216cae4d1 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -174,17 +174,6 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t\treturn numRequestedBuffers;\n \t}\n \n-\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += bufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n \t// ------------------------------------------------------------------------\n \t// Buffer recycle\n \t// ------------------------------------------------------------------------\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 0f216cae4d1..ba6e75d3a43 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -41,391 +41,402 @@ import java.util.List;\n \n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += numRequired;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers(boolean isTemporaryRelease) {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tint numReleasedBuffers = bufferQueue.releaseFloatingBuffers();\n-\t\t\tif (isTemporaryRelease) {\n-\t\t\t\tnumRequiredBuffers += numReleasedBuffers;\n-\t\t\t} else {\n-\t\t\t\tnumRequiredBuffers = 0;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint getNumberOfRequiredBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn numRequiredBuffers;\n-\t\t}\n-\t}\n-\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn isWaitingForFloatingBuffers;\n-\t\t}\n-\t}\n-\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffers() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer(int initialCredit) {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            if (initialCredit == 0) {\n+                checkState(\n+                        bufferQueue.getAvailableBufferSize() <= numRequiredBuffers,\n+                        \"Too many buffers allocated.\");\n+                --numRequiredBuffers;\n+            }\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        if (numExclusiveBuffers <= 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        int numAddedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                } else {\n+                    numAddedBuffers =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        try {\n+            inputChannel.notifyBufferAvailable(numAddedBuffers);\n+        } catch (Throwable t) {\n+            ExceptionUtils.rethrow(t);\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            bufferQueue.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            if (buffer.getRecycler() == this) {\n+                exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+            } else {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+        synchronized (bufferQueue) {\n+            bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+            bufferQueue.notifyAll();\n+        }\n+\n+        if (exclusiveRecyclingSegments.size() > 0) {\n+            globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n+         * number of available buffers in queue is more than the required amount.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return How many buffers were added to the queue\n+         */\n+        int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                Buffer floatingBuffer = floatingBuffers.poll();\n+                if (floatingBuffer != null) {\n+                    floatingBuffer.recycleBuffer();\n+                    return 0;\n+                }\n+            }\n+            return 1;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": {"commit": "8550965d808fe7b4d6ff2d48034612878937a579", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex ba6e75d3a43..8031f6b5d3c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -428,11 +448,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..82162f51ae3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,10 +448,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        Queue<Buffer> clearFloatingBuffers() {\n-            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n-            floatingBuffers.clear();\n-            return buffers;\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 82162f51ae3..0867fbba828 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,11 +458,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 6074cef11af..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -38,398 +38,435 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Queue;\n \n+import static org.apache.flink.util.ExceptionUtils.firstOrSuppressed;\n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += numRequired;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += bufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tnumRequiredBuffers = 0;\n-\t\t\tbufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint getNumberOfRequiredBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn numRequiredBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn isWaitingForFloatingBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffers() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer() {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            --numRequiredBuffers;\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        checkArgument(numExclusiveBuffers >= 0, \"Num exclusive buffers must be non-negative.\");\n+        if (numExclusiveBuffers == 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            // AvailableBufferQueue::addExclusiveBuffer may release the previously allocated\n+            // floating buffer, which requires the caller to recycle these released floating\n+            // buffers. There should be no floating buffers that have been allocated before the\n+            // exclusive buffers are initialized, so here only a simple assertion is required\n+            checkState(\n+                    unsynchronizedGetFloatingBuffersAvailable() == 0,\n+                    \"Bug in buffer allocation logic: floating buffer is allocated before exclusive buffers are initialized.\");\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        @Nullable Buffer releasedFloatingBuffer = null;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                    return;\n+                } else {\n+                    releasedFloatingBuffer =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        if (releasedFloatingBuffer != null) {\n+            releasedFloatingBuffer.recycleBuffer();\n+        } else {\n+            try {\n+                inputChannel.notifyBufferAvailable(1);\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            }\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        Queue<Buffer> buffers;\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            buffers = bufferQueue.clearFloatingBuffers();\n+        }\n+\n+        // recycle all buffers out of the synchronization block to avoid dead lock\n+        while (!buffers.isEmpty()) {\n+            buffers.poll().recycleBuffer();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Exception err = null;\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            try {\n+                if (buffer.getRecycler() == BufferManager.this) {\n+                    exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+                } else {\n+                    buffer.recycleBuffer();\n+                }\n+            } catch (Exception e) {\n+                err = firstOrSuppressed(e, err);\n+            }\n+        }\n+        try {\n+            synchronized (bufferQueue) {\n+                bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+                bufferQueue.notifyAll();\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        try {\n+            if (exclusiveRecyclingSegments.size() > 0) {\n+                globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        if (err != null) {\n+            throw err instanceof IOException ? (IOException) err : new IOException(err);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and releases one floating buffer if the\n+         * number of available buffers in queue is more than the required amount. If floating buffer\n+         * is released, the total amount of available buffers after adding this exclusive buffer has\n+         * not changed, and no new buffers are available. The caller is responsible for recycling\n+         * the release/returned floating buffer.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return An released floating buffer, may be null if the numRequiredBuffers is not met.\n+         */\n+        @Nullable\n+        Buffer addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                return floatingBuffers.poll();\n+            }\n+            return null;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "48a384dffc770289a38df816a38bd336ea992ed7", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[FLINK-23466][network] Fix the bug that buffer listeners may not be notified when recycling buffers"}, {"oid": "c91837edb782c67eab799a569077053695a29fc3", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[hotfix][refactor] Remove BufferListener#NotificationResult to simplify the code"}, {"oid": "38f7c593538d78e67ed75f006826b9fc3e97826e", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[hotfix] Rename some methods of NetworkBufferPool and add more comments for better readability"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NjA3Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424866076", "body": "It should not be changed here. If the `numRequiredBuffers` is 0, `getAvailableBufferSize()` must be more than it. If `numRequiredBuffers` is `1` or something else, as long as the `getAvailableBufferSize()` is more than it, we also need to release a floating buffer.", "bodyText": "It should not be changed here. If the numRequiredBuffers is 0, getAvailableBufferSize() must be more than it. If numRequiredBuffers is 1 or something else, as long as the getAvailableBufferSize() is more than it, we also need to release a floating buffer.", "bodyHTML": "<p dir=\"auto\">It should not be changed here. If the <code>numRequiredBuffers</code> is 0, <code>getAvailableBufferSize()</code> must be more than it. If <code>numRequiredBuffers</code> is <code>1</code> or something else, as long as the <code>getAvailableBufferSize()</code> is more than it, we also need to release a floating buffer.</p>", "author": "zhijiangW", "createdAt": "2020-05-14T04:36:33Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -349,7 +373,7 @@ int unsynchronizedGetFloatingBuffersAvailable() {\n \t\t */\n \t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n \t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (getAvailableBufferSize() > numRequiredBuffers) {\n+\t\t\tif (numRequiredBuffers == 0) {", "originalCommit": "e033307ba22ee660cd6c39063896500075b60671", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 6074cef11af..ba6e75d3a43 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -41,395 +41,402 @@ import java.util.List;\n \n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += numRequired;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += bufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tnumRequiredBuffers = 0;\n-\t\t\tbufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint getNumberOfRequiredBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn numRequiredBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn isWaitingForFloatingBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffers() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer(int initialCredit) {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            if (initialCredit == 0) {\n+                checkState(\n+                        bufferQueue.getAvailableBufferSize() <= numRequiredBuffers,\n+                        \"Too many buffers allocated.\");\n+                --numRequiredBuffers;\n+            }\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        if (numExclusiveBuffers <= 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        int numAddedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                } else {\n+                    numAddedBuffers =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        try {\n+            inputChannel.notifyBufferAvailable(numAddedBuffers);\n+        } catch (Throwable t) {\n+            ExceptionUtils.rethrow(t);\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            bufferQueue.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            if (buffer.getRecycler() == this) {\n+                exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+            } else {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+        synchronized (bufferQueue) {\n+            bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+            bufferQueue.notifyAll();\n+        }\n+\n+        if (exclusiveRecyclingSegments.size() > 0) {\n+            globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n+         * number of available buffers in queue is more than the required amount.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return How many buffers were added to the queue\n+         */\n+        int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                Buffer floatingBuffer = floatingBuffers.poll();\n+                if (floatingBuffer != null) {\n+                    floatingBuffer.recycleBuffer();\n+                    return 0;\n+                }\n+            }\n+            return 1;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": {"commit": "8550965d808fe7b4d6ff2d48034612878937a579", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex ba6e75d3a43..8031f6b5d3c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -428,11 +448,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..82162f51ae3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,10 +448,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        Queue<Buffer> clearFloatingBuffers() {\n-            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n-            floatingBuffers.clear();\n-            return buffers;\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 82162f51ae3..0867fbba828 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,11 +458,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 6074cef11af..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -38,398 +38,435 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Queue;\n \n+import static org.apache.flink.util.ExceptionUtils.firstOrSuppressed;\n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += numRequired;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += bufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tnumRequiredBuffers = 0;\n-\t\t\tbufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint getNumberOfRequiredBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn numRequiredBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn isWaitingForFloatingBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffers() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer() {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            --numRequiredBuffers;\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        checkArgument(numExclusiveBuffers >= 0, \"Num exclusive buffers must be non-negative.\");\n+        if (numExclusiveBuffers == 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            // AvailableBufferQueue::addExclusiveBuffer may release the previously allocated\n+            // floating buffer, which requires the caller to recycle these released floating\n+            // buffers. There should be no floating buffers that have been allocated before the\n+            // exclusive buffers are initialized, so here only a simple assertion is required\n+            checkState(\n+                    unsynchronizedGetFloatingBuffersAvailable() == 0,\n+                    \"Bug in buffer allocation logic: floating buffer is allocated before exclusive buffers are initialized.\");\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        @Nullable Buffer releasedFloatingBuffer = null;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                    return;\n+                } else {\n+                    releasedFloatingBuffer =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        if (releasedFloatingBuffer != null) {\n+            releasedFloatingBuffer.recycleBuffer();\n+        } else {\n+            try {\n+                inputChannel.notifyBufferAvailable(1);\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            }\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        Queue<Buffer> buffers;\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            buffers = bufferQueue.clearFloatingBuffers();\n+        }\n+\n+        // recycle all buffers out of the synchronization block to avoid dead lock\n+        while (!buffers.isEmpty()) {\n+            buffers.poll().recycleBuffer();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Exception err = null;\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            try {\n+                if (buffer.getRecycler() == BufferManager.this) {\n+                    exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+                } else {\n+                    buffer.recycleBuffer();\n+                }\n+            } catch (Exception e) {\n+                err = firstOrSuppressed(e, err);\n+            }\n+        }\n+        try {\n+            synchronized (bufferQueue) {\n+                bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+                bufferQueue.notifyAll();\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        try {\n+            if (exclusiveRecyclingSegments.size() > 0) {\n+                globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        if (err != null) {\n+            throw err instanceof IOException ? (IOException) err : new IOException(err);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and releases one floating buffer if the\n+         * number of available buffers in queue is more than the required amount. If floating buffer\n+         * is released, the total amount of available buffers after adding this exclusive buffer has\n+         * not changed, and no new buffers are available. The caller is responsible for recycling\n+         * the release/returned floating buffer.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return An released floating buffer, may be null if the numRequiredBuffers is not met.\n+         */\n+        @Nullable\n+        Buffer addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                return floatingBuffers.poll();\n+            }\n+            return null;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "48a384dffc770289a38df816a38bd336ea992ed7", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[FLINK-23466][network] Fix the bug that buffer listeners may not be notified when recycling buffers"}, {"oid": "c91837edb782c67eab799a569077053695a29fc3", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[hotfix][refactor] Remove BufferListener#NotificationResult to simplify the code"}, {"oid": "38f7c593538d78e67ed75f006826b9fc3e97826e", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[hotfix] Rename some methods of NetworkBufferPool and add more comments for better readability"}]}, {"oid": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "url": "https://github.com/apache/flink/commit/10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T06:16:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5OTUxNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424899517", "body": "make it only private method inside `RemoteInputChannel`, because it is never used outside.", "bodyText": "make it only private method inside RemoteInputChannel, because it is never used outside.", "bodyHTML": "<p dir=\"auto\">make it only private method inside <code>RemoteInputChannel</code>, because it is never used outside.</p>", "author": "zhijiangW", "createdAt": "2020-05-14T06:32:19Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -327,6 +322,14 @@ public void notifyBufferAvailable(int numAvailableBuffers) {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {", "originalCommit": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a933d700d53457d7743252c2a3c735a04fbd87f8", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 5e125aef0d0..82a1243aa5c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -322,8 +322,7 @@ public class RemoteInputChannel extends InputChannel {\n \t\t}\n \t}\n \n-\t@Override\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n+\tprivate void onCheckpointBarrier(CheckpointBarrier barrier) {\n \t\tCheckpointOptions options = barrier.getCheckpointOptions();\n \t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n \t\t\tbufferManager.releaseFloatingBuffers(true);\n", "next_change": {"commit": "fb4c607a5c4780729143d458b1c7633adcba59bf", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 82a1243aa5c..23d440c00b5 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -322,11 +323,8 @@ public class RemoteInputChannel extends InputChannel {\n \t\t}\n \t}\n \n-\tprivate void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tbufferManager.releaseFloatingBuffers(true);\n-\t\t}\n+\tprivate void onExactlyOnceAlignedCheckpointBarrier() {\n+\t\tbufferManager.releaseFloatingBuffers(true);\n \t}\n \n \t@Override\n", "next_change": {"commit": "a51d7760c34c0652321427daa153070874c54a61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 23d440c00b5..22630fed197 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -323,7 +323,7 @@ public class RemoteInputChannel extends InputChannel {\n \t\t}\n \t}\n \n-\tprivate void onExactlyOnceAlignedCheckpointBarrier() {\n+\tprivate void onCheckpointBarrier() {\n \t\tbufferManager.releaseFloatingBuffers(true);\n \t}\n \n", "next_change": {"commit": "7dfdb8bfa05b783479697bd3aa3de3fac2628482", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 22630fed197..28ed2c1b156 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -328,9 +334,9 @@ public class RemoteInputChannel extends InputChannel {\n \t}\n \n \t@Override\n-\tpublic void resumeConsumption() {\n+\tpublic void resumeConsumption() throws IOException {\n \t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n+\t\tcheckPartitionRequestQueueInitialized();\n \n \t\t// notifies the producer that this channel is ready to\n \t\t// unblock from checkpoint and resume data consumption\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 28ed2c1b156..3e976686f91 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -41,521 +51,750 @@ import javax.annotation.concurrent.GuardedBy;\n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n-/**\n- * An input channel, which requests a remote partition queue.\n- */\n+/** An input channel, which requests a remote partition queue. */\n public class RemoteInputChannel extends InputChannel {\n-\n-\t/** ID to distinguish this channel from other channels sharing the same TCP connection. */\n-\tprivate final InputChannelID id = new InputChannelID();\n-\n-\t/** The connection to use to request the remote partition. */\n-\tprivate final ConnectionID connectionId;\n-\n-\t/** The connection manager to use connect to the remote partition provider. */\n-\tprivate final ConnectionManager connectionManager;\n-\n-\t/**\n-\t * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n-\t * is consumed by the receiving task thread.\n-\t */\n-\tprivate final ArrayDeque<Buffer> receivedBuffers = new ArrayDeque<>();\n-\n-\t/**\n-\t * Flag indicating whether this channel has been released. Either called by the receiving task\n-\t * thread or the task manager actor.\n-\t */\n-\tprivate final AtomicBoolean isReleased = new AtomicBoolean();\n-\n-\t/** Client to establish a (possibly shared) TCP connection and request the partition. */\n-\tprivate volatile PartitionRequestClient partitionRequestClient;\n-\n-\t/**\n-\t * The next expected sequence number for the next buffer. This is modified by the network\n-\t * I/O thread only.\n-\t */\n-\tprivate int expectedSequenceNumber = 0;\n-\n-\t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate final int initialCredit;\n-\n-\t/** The number of available buffers that have not been announced to the producer yet. */\n-\tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n-\n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n-\n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n-\n-\tprivate final BufferManager bufferManager;\n-\n-\tpublic RemoteInputChannel(\n-\t\tSingleInputGate inputGate,\n-\t\tint channelIndex,\n-\t\tResultPartitionID partitionId,\n-\t\tConnectionID connectionId,\n-\t\tConnectionManager connectionManager,\n-\t\tint initialBackOff,\n-\t\tint maxBackoff,\n-\t\tint networkBuffersPerChannel,\n-\t\tCounter numBytesIn,\n-\t\tCounter numBuffersIn) {\n-\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, numBytesIn, numBuffersIn);\n-\n-\t\tthis.initialCredit = networkBuffersPerChannel;\n-\t\tthis.connectionId = checkNotNull(connectionId);\n-\t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n-\t}\n-\n-\t/**\n-\t * Assigns exclusive buffers to this input channel, and this method should be called only once\n-\t * after this input channel is created.\n-\t */\n-\tvoid assignExclusiveSegments() throws IOException {\n-\t\tcheckState(bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n-\t\t\t\"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n-\n-\t\tif (initialCredit > 0) {\n-\t\t\tbufferManager.requestExclusiveBuffers();\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests a remote subpartition.\n-\t */\n-\t@VisibleForTesting\n-\t@Override\n-\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n-\t\tif (partitionRequestClient == null) {\n-\t\t\t// Create a client and request the partition\n-\t\t\ttry {\n-\t\t\t\tpartitionRequestClient = connectionManager.createPartitionRequestClient(connectionId);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\t// IOExceptions indicate that we could not open a connection to the remote TaskExecutor\n-\t\t\t\tthrow new PartitionConnectionException(partitionId, e);\n-\t\t\t}\n-\n-\t\t\tpartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Retriggers a remote subpartition request.\n-\t */\n-\tvoid retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n-\t\tcheckPartitionRequestQueueInitialized();\n-\n-\t\tif (increaseBackoff()) {\n-\t\t\tpartitionRequestClient.requestSubpartition(\n-\t\t\t\tpartitionId, subpartitionIndex, this, getCurrentBackoff());\n-\t\t} else {\n-\t\t\tfailPartitionRequest();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tOptional<BufferAndAvailability> getNextBuffer() throws IOException {\n-\t\tcheckPartitionRequestQueueInitialized();\n-\n-\t\tfinal Buffer next;\n-\t\tfinal boolean moreAvailable;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tnext = receivedBuffers.poll();\n-\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n-\t\t}\n-\n-\t\tif (next == null) {\n-\t\t\tif (isReleased.get()) {\n-\t\t\t\tthrow new CancelTaskException(\"Queried for a buffer after channel has been released.\");\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalStateException(\"There should always have queued buffers for unreleased channel.\");\n-\t\t\t}\n-\t\t}\n-\n-\t\tnumBytesIn.inc(next.getSize());\n-\t\tnumBuffersIn.inc();\n-\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable));\n-\t}\n-\n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlastRequestedCheckpointId = checkpointId;\n-\n-\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\tcheckpointId,\n-\t\t\t\tchannelInfo,\n-\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\tCloseableIterator.fromList(inflightBuffers, Buffer::recycleBuffer));\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tvoid sendTaskEvent(TaskEvent event) throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Tried to send task event to producer after channel has been released.\");\n-\t\tcheckPartitionRequestQueueInitialized();\n-\n-\t\tpartitionRequestClient.sendTaskEvent(partitionId, event, this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n-\t}\n-\n-\t/**\n-\t * Releases all exclusive and floating buffers, closes the partition request client.\n-\t */\n-\t@Override\n-\tvoid releaseAllResources() throws IOException {\n-\t\tif (isReleased.compareAndSet(false, true)) {\n-\n-\t\t\tfinal ArrayDeque<Buffer> releasedBuffers;\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\treleasedBuffers = new ArrayDeque<>(receivedBuffers);\n-\t\t\t\treceivedBuffers.clear();\n-\t\t\t}\n-\t\t\tbufferManager.releaseAllBuffers(releasedBuffers);\n-\n-\t\t\t// The released flag has to be set before closing the connection to ensure that\n-\t\t\t// buffers received concurrently with closing are properly recycled.\n-\t\t\tif (partitionRequestClient != null) {\n-\t\t\t\tpartitionRequestClient.close(this);\n-\t\t\t} else {\n-\t\t\t\tconnectionManager.closeOpenChannelConnections(connectionId);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void failPartitionRequest() {\n-\t\tsetError(new PartitionNotFoundException(partitionId));\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Credit-based\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n-\t */\n-\tprivate void notifyCreditAvailable() throws IOException {\n-\t\tcheckPartitionRequestQueueInitialized();\n-\n-\t\tpartitionRequestClient.notifyCreditAvailable(this);\n-\t}\n-\n-\tpublic int getNumberOfAvailableBuffers() {\n-\t\treturn bufferManager.getNumberOfAvailableBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn bufferManager.getNumberOfRequiredBuffers();\n-\t}\n-\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\treturn bufferManager.isWaitingForFloatingBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n-\t}\n-\n-\t@VisibleForTesting\n-\tBufferManager getBufferManager() {\n-\t\treturn bufferManager;\n-\t}\n-\n-\t@VisibleForTesting\n-\tPartitionRequestClient getPartitionRequestClient() {\n-\t\treturn partitionRequestClient;\n-\t}\n-\n-\t/**\n-\t * The unannounced credit is increased by the given amount and might notify\n-\t * increased credit to the producer.\n-\t */\n-\t@Override\n-\tpublic void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n-\t\tif (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\tprivate void onCheckpointBarrier() {\n-\t\tbufferManager.releaseFloatingBuffers(true);\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption() throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckPartitionRequestQueueInitialized();\n-\n-\t\t// notifies the producer that this channel is ready to\n-\t\t// unblock from checkpoint and resume data consumption\n-\t\tpartitionRequestClient.resumeConsumption(this);\n-\t}\n-\n-\t/**\n-\t * Called by netty thread to request buffers and generate {@link ResumeConsumption} message.\n-\t */\n-\tpublic ResumeConsumption getResumeConsumptionMessage() throws IOException {\n-\t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n-\t\tcheckState(getNumberOfAvailableBuffers() == initialCredit, \"Illegal number of available buffers.\");\n-\t\tcheckState(!isWaitingForFloatingBuffers(), \"Should not be waiting for floating buffers.\");\n-\n-\t\tif (initialCredit > 0) {\n-\t\t\treturn new ResumeConsumption(id, initialCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t\t}\n-\n-\t\tint availableCredit = bufferManager.requestFloatingBuffers(0);\n-\t\treturn new ResumeConsumption(id, availableCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network I/O notifications (called by network I/O thread)\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Gets the currently unannounced credit.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getUnannouncedCredit() {\n-\t\treturn unannouncedCredit.get();\n-\t}\n-\n-\t/**\n-\t * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n-\t}\n-\n-\t/**\n-\t * Gets the current number of received buffers which have not been processed yet.\n-\t *\n-\t * @return Buffers queued for processing.\n-\t */\n-\tpublic int getNumberOfQueuedBuffers() {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treturn receivedBuffers.size();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn Math.max(0, receivedBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n-\t}\n-\n-\tpublic int unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n-\t}\n-\n-\tpublic InputChannelID getInputChannelId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic int getInitialCredit() {\n-\t\treturn initialCredit;\n-\t}\n-\n-\tpublic BufferProvider getBufferProvider() throws IOException {\n-\t\tif (isReleased.get()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn inputGate.getBufferProvider();\n-\t}\n-\n-\t/**\n-\t * Requests buffer from input channel directly for receiving network data.\n-\t * It should always return an available buffer in credit-based mode unless\n-\t * the channel has been released.\n-\t *\n-\t * @return The available buffer.\n-\t */\n-\t@Nullable\n-\tpublic Buffer requestBuffer() {\n-\t\treturn bufferManager.requestBuffer();\n-\t}\n-\n-\t/**\n-\t * Receives the backlog from the producer's buffer response. Floating buffers will\n-\t * be requested from the {@link BufferManager} according to the announced backlog,\n-\t * and then it will notify unannounced credits to the producer.\n-\t *\n-\t * @param backlog Number of the announced backlog from producer.\n-\t */\n-\tpublic void onSenderBacklog(int backlog) throws IOException {\n-\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));\n-\t}\n-\n-\tpublic void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean recycleBuffer = true;\n-\n-\t\ttry {\n-\t\t\tif (expectedSequenceNumber != sequenceNumber) {\n-\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tfinal boolean wasEmpty;\n-\t\t\tfinal CheckpointBarrier notifyReceivedBarrier;\n-\t\t\tfinal Buffer notifyReceivedBuffer;\n-\t\t\tfinal BufferReceivedListener listener = inputGate.getBufferReceivedListener();\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after releaseAllResources() released all buffers from receivedBuffers\n-\t\t\t\t// (see above for details).\n-\t\t\t\tif (isReleased.get()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n-\n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n-\t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n-\t\t\t}\n-\t\t\trecycleBuffer = false;\n-\n-\t\t\t++expectedSequenceNumber;\n-\n-\t\t\tif (wasEmpty) {\n-\t\t\t\tnotifyChannelNonEmpty();\n-\t\t\t}\n-\n-\t\t\tif (backlog >= 0) {\n-\t\t\t\tonSenderBacklog(backlog);\n-\t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tif (notifyReceivedBarrier.isCheckpoint()) {\n-\t\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t\t}\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n-\n-\t\t\tif (buffer.getDataType().isBlockingUpstream()) {\n-\t\t\t\tonCheckpointBarrier();\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tif (recycleBuffer) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean success = false;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tif (!isReleased.get()) {\n-\t\t\t\tif (expectedSequenceNumber == sequenceNumber) {\n-\t\t\t\t\texpectedSequenceNumber++;\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t} else {\n-\t\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (success && backlog >= 0) {\n-\t\t\tonSenderBacklog(backlog);\n-\t\t}\n-\t}\n-\n-\tpublic void onFailedPartitionRequest() {\n-\t\tinputGate.triggerPartitionStateCheck(partitionId);\n-\t}\n-\n-\tpublic void onError(Throwable cause) {\n-\t\tsetError(cause);\n-\t}\n-\n-\tprivate void checkPartitionRequestQueueInitialized() throws IOException {\n-\t\tcheckError();\n-\t\tcheckState(partitionRequestClient != null,\n-\t\t\t\t\"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n-\t}\n-\n-\tprivate static class BufferReorderingException extends IOException {\n-\n-\t\tprivate static final long serialVersionUID = -888282210356266816L;\n-\n-\t\tprivate final int expectedSequenceNumber;\n-\n-\t\tprivate final int actualSequenceNumber;\n-\n-\t\tBufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n-\t\t\tthis.expectedSequenceNumber = expectedSequenceNumber;\n-\t\t\tthis.actualSequenceNumber = actualSequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String getMessage() {\n-\t\t\treturn String.format(\"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n-\t\t\t\texpectedSequenceNumber, actualSequenceNumber);\n-\t\t}\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(RemoteInputChannel.class);\n+\n+    private static final int NONE = -1;\n+\n+    /** ID to distinguish this channel from other channels sharing the same TCP connection. */\n+    private final InputChannelID id = new InputChannelID();\n+\n+    /** The connection to use to request the remote partition. */\n+    private final ConnectionID connectionId;\n+\n+    /** The connection manager to use connect to the remote partition provider. */\n+    private final ConnectionManager connectionManager;\n+\n+    /**\n+     * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n+     * is consumed by the receiving task thread.\n+     */\n+    private final PrioritizedDeque<SequenceBuffer> receivedBuffers = new PrioritizedDeque<>();\n+\n+    /**\n+     * Flag indicating whether this channel has been released. Either called by the receiving task\n+     * thread or the task manager actor.\n+     */\n+    private final AtomicBoolean isReleased = new AtomicBoolean();\n+\n+    /** Client to establish a (possibly shared) TCP connection and request the partition. */\n+    private volatile PartitionRequestClient partitionRequestClient;\n+\n+    /** The next expected sequence number for the next buffer. */\n+    private int expectedSequenceNumber = 0;\n+\n+    /** The initial number of exclusive buffers assigned to this channel. */\n+    private final int initialCredit;\n+\n+    /** The number of available buffers that have not been announced to the producer yet. */\n+    private final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n+\n+    private final BufferManager bufferManager;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private int lastBarrierSequenceNumber = NONE;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private long lastBarrierId = NONE;\n+\n+    private final ChannelStatePersister channelStatePersister;\n+\n+    private boolean isUpstreamBlocked;\n+\n+    public RemoteInputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            ConnectionID connectionId,\n+            ConnectionManager connectionManager,\n+            int initialBackOff,\n+            int maxBackoff,\n+            int networkBuffersPerChannel,\n+            Counter numBytesIn,\n+            Counter numBuffersIn,\n+            ChannelStateWriter stateWriter) {\n+\n+        super(\n+                inputGate,\n+                channelIndex,\n+                partitionId,\n+                initialBackOff,\n+                maxBackoff,\n+                numBytesIn,\n+                numBuffersIn);\n+        checkArgument(networkBuffersPerChannel >= 0, \"Must be non-negative.\");\n+\n+        this.initialCredit = networkBuffersPerChannel;\n+        this.connectionId = checkNotNull(connectionId);\n+        this.connectionManager = checkNotNull(connectionManager);\n+        this.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n+        this.channelStatePersister = new ChannelStatePersister(stateWriter, getChannelInfo());\n+    }\n+\n+    @VisibleForTesting\n+    void setExpectedSequenceNumber(int expectedSequenceNumber) {\n+        this.expectedSequenceNumber = expectedSequenceNumber;\n+    }\n+\n+    /**\n+     * Setup includes assigning exclusive buffers to this input channel, and this method should be\n+     * called only once after this input channel is created.\n+     */\n+    @Override\n+    void setup() throws IOException {\n+        checkState(\n+                bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+                \"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n+\n+        bufferManager.requestExclusiveBuffers(initialCredit);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /** Requests a remote subpartition. */\n+    @VisibleForTesting\n+    @Override\n+    public void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException {\n+        if (partitionRequestClient == null) {\n+            LOG.debug(\n+                    \"{}: Requesting REMOTE subpartition {} of partition {}. {}\",\n+                    this,\n+                    subpartitionIndex,\n+                    partitionId,\n+                    channelStatePersister);\n+            // Create a client and request the partition\n+            try {\n+                partitionRequestClient =\n+                        connectionManager.createPartitionRequestClient(connectionId);\n+            } catch (IOException e) {\n+                // IOExceptions indicate that we could not open a connection to the remote\n+                // TaskExecutor\n+                throw new PartitionConnectionException(partitionId, e);\n+            }\n+\n+            partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n+        }\n+    }\n+\n+    /** Retriggers a remote subpartition request. */\n+    void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (increaseBackoff()) {\n+            partitionRequestClient.requestSubpartition(\n+                    partitionId, subpartitionIndex, this, getCurrentBackoff());\n+        } else {\n+            failPartitionRequest();\n+        }\n+    }\n+\n+    @Override\n+    Optional<BufferAndAvailability> getNextBuffer() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        final SequenceBuffer next;\n+        final DataType nextDataType;\n+\n+        synchronized (receivedBuffers) {\n+            next = receivedBuffers.poll();\n+            nextDataType =\n+                    receivedBuffers.peek() != null\n+                            ? receivedBuffers.peek().buffer.getDataType()\n+                            : DataType.NONE;\n+        }\n+\n+        if (next == null) {\n+            if (isReleased.get()) {\n+                throw new CancelTaskException(\n+                        \"Queried for a buffer after channel has been released.\");\n+            }\n+            return Optional.empty();\n+        }\n+\n+        numBytesIn.inc(next.buffer.getSize());\n+        numBuffersIn.inc();\n+        return Optional.of(\n+                new BufferAndAvailability(next.buffer, nextDataType, 0, next.sequenceNumber));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    void sendTaskEvent(TaskEvent event) throws IOException {\n+        checkState(\n+                !isReleased.get(),\n+                \"Tried to send task event to producer after channel has been released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.sendTaskEvent(partitionId, event, this);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased.get();\n+    }\n+\n+    /** Releases all exclusive and floating buffers, closes the partition request client. */\n+    @Override\n+    void releaseAllResources() throws IOException {\n+        if (isReleased.compareAndSet(false, true)) {\n+\n+            final ArrayDeque<Buffer> releasedBuffers;\n+            synchronized (receivedBuffers) {\n+                releasedBuffers =\n+                        receivedBuffers.stream()\n+                                .map(sb -> sb.buffer)\n+                                .collect(Collectors.toCollection(ArrayDeque::new));\n+                receivedBuffers.clear();\n+            }\n+            bufferManager.releaseAllBuffers(releasedBuffers);\n+\n+            // The released flag has to be set before closing the connection to ensure that\n+            // buffers received concurrently with closing are properly recycled.\n+            if (partitionRequestClient != null) {\n+                partitionRequestClient.close(this);\n+            } else {\n+                connectionManager.closeOpenChannelConnections(connectionId);\n+            }\n+        }\n+    }\n+\n+    private void failPartitionRequest() {\n+        setError(new PartitionNotFoundException(partitionId));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Credit-based\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n+     */\n+    private void notifyCreditAvailable() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.notifyCreditAvailable(this);\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfAvailableBuffers() {\n+        return bufferManager.getNumberOfAvailableBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfRequiredBuffers() {\n+        return bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getSenderBacklog() {\n+        return getNumberOfRequiredBuffers() - initialCredit;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isWaitingForFloatingBuffers() {\n+        return bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public Buffer getNextReceivedBuffer() {\n+        final SequenceBuffer sequenceBuffer = receivedBuffers.poll();\n+        return sequenceBuffer != null ? sequenceBuffer.buffer : null;\n+    }\n+\n+    @VisibleForTesting\n+    BufferManager getBufferManager() {\n+        return bufferManager;\n+    }\n+\n+    @VisibleForTesting\n+    PartitionRequestClient getPartitionRequestClient() {\n+        return partitionRequestClient;\n+    }\n+\n+    /**\n+     * The unannounced credit is increased by the given amount and might notify increased credit to\n+     * the producer.\n+     */\n+    @Override\n+    public void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n+        if (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+            notifyCreditAvailable();\n+        }\n+    }\n+\n+    @Override\n+    public void resumeConsumption() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        // notifies the producer that this channel is ready to\n+        // unblock from checkpoint and resume data consumption\n+        partitionRequestClient.resumeConsumption(this);\n+    }\n+\n+    private void onBlockingUpstream() {\n+        isUpstreamBlocked = true;\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    public void onConsumptionResumed() {\n+        isUpstreamBlocked = false;\n+        if (initialCredit == 0) {\n+            unannouncedCredit.set(0);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network I/O notifications (called by network I/O thread)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the currently unannounced credit.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getUnannouncedCredit() {\n+        return unannouncedCredit.get();\n+    }\n+\n+    /**\n+     * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getAndResetUnannouncedCredit() {\n+        return unannouncedCredit.getAndSet(0);\n+    }\n+\n+    /**\n+     * Gets the current number of received buffers which have not been processed yet.\n+     *\n+     * @return Buffers queued for processing.\n+     */\n+    public int getNumberOfQueuedBuffers() {\n+        synchronized (receivedBuffers) {\n+            return receivedBuffers.size();\n+        }\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return Math.max(0, receivedBuffers.size());\n+    }\n+\n+    public int unsynchronizedGetExclusiveBuffersUsed() {\n+        return Math.max(\n+                0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n+    }\n+\n+    public int unsynchronizedGetFloatingBuffersAvailable() {\n+        return Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n+    }\n+\n+    public InputChannelID getInputChannelId() {\n+        return id;\n+    }\n+\n+    public int getInitialCredit() {\n+        return initialCredit;\n+    }\n+\n+    public BufferProvider getBufferProvider() throws IOException {\n+        if (isReleased.get()) {\n+            return null;\n+        }\n+\n+        return inputGate.getBufferProvider();\n+    }\n+\n+    /**\n+     * Requests buffer from input channel directly for receiving network data. It should always\n+     * return an available buffer in credit-based mode unless the channel has been released.\n+     *\n+     * @return The available buffer.\n+     */\n+    @Nullable\n+    public Buffer requestBuffer() {\n+        return bufferManager.requestBuffer(initialCredit);\n+    }\n+\n+    /**\n+     * Receives the backlog from the producer's buffer response. If the number of available buffers\n+     * is less than backlog + initialCredit, it will request floating buffers from the buffer\n+     * manager, and then notify unannounced credits to the producer.\n+     *\n+     * @param backlog The number of unsent buffers in the producer's sub partition.\n+     */\n+    public void onSenderBacklog(int backlog) throws IOException {\n+        // never allocate any new buffers if upstream has been blocked\n+        if (!isUpstreamBlocked) {\n+            notifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+        }\n+    }\n+\n+    public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n+        boolean recycleBuffer = true;\n+\n+        try {\n+            if (expectedSequenceNumber != sequenceNumber) {\n+                onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                return;\n+            }\n+\n+            final boolean wasEmpty;\n+            boolean firstPriorityEvent = false;\n+            synchronized (receivedBuffers) {\n+                NetworkActionsLogger.traceInput(\n+                        \"RemoteInputChannel#onBuffer\",\n+                        buffer,\n+                        inputGate.getOwningTaskName(),\n+                        channelInfo,\n+                        channelStatePersister,\n+                        sequenceNumber);\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after releaseAllResources() released all buffers from receivedBuffers\n+                // (see above for details).\n+                if (isReleased.get()) {\n+                    return;\n+                }\n+\n+                wasEmpty = receivedBuffers.isEmpty();\n+\n+                SequenceBuffer sequenceBuffer = new SequenceBuffer(buffer, sequenceNumber);\n+                DataType dataType = buffer.getDataType();\n+                if (dataType.hasPriority()) {\n+                    firstPriorityEvent = addPriorityBuffer(sequenceBuffer);\n+                } else {\n+                    receivedBuffers.add(sequenceBuffer);\n+                    if (dataType.requiresAnnouncement()) {\n+                        firstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n+                    }\n+                }\n+                channelStatePersister\n+                        .checkForBarrier(sequenceBuffer.buffer)\n+                        .filter(id -> id > lastBarrierId)\n+                        .ifPresent(\n+                                id -> {\n+                                    // checkpoint was not yet started by task thread,\n+                                    // so remember the numbers of buffers to spill for the time when\n+                                    // it will be started\n+                                    lastBarrierId = id;\n+                                    lastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+                                });\n+                channelStatePersister.maybePersist(buffer);\n+                ++expectedSequenceNumber;\n+            }\n+            recycleBuffer = false;\n+\n+            if (firstPriorityEvent) {\n+                notifyPriorityEvent(sequenceNumber);\n+            }\n+            if (wasEmpty) {\n+                notifyChannelNonEmpty();\n+            }\n+\n+            if (backlog >= 0) {\n+                onSenderBacklog(backlog);\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+            }\n+        } finally {\n+            if (recycleBuffer) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+    }\n+\n+    /** @return {@code true} if this was first priority buffer added. */\n+    private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) {\n+        receivedBuffers.addPriorityElement(sequenceBuffer);\n+        return receivedBuffers.getNumPriorityElements() == 1;\n+    }\n+\n+    private SequenceBuffer announce(SequenceBuffer sequenceBuffer) throws IOException {\n+        checkState(\n+                !sequenceBuffer.buffer.isBuffer(),\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        checkAnnouncedOnlyOnce(sequenceBuffer);\n+        AbstractEvent event =\n+                EventSerializer.fromBuffer(sequenceBuffer.buffer, getClass().getClassLoader());\n+        checkState(\n+                event instanceof CheckpointBarrier,\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        CheckpointBarrier barrier = (CheckpointBarrier) event;\n+        return new SequenceBuffer(\n+                EventSerializer.toBuffer(\n+                        new EventAnnouncement(barrier, sequenceBuffer.sequenceNumber), true),\n+                sequenceBuffer.sequenceNumber);\n+    }\n+\n+    private void checkAnnouncedOnlyOnce(SequenceBuffer sequenceBuffer) {\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        int count = 0;\n+        while (iterator.hasNext()) {\n+            if (iterator.next().sequenceNumber == sequenceBuffer.sequenceNumber) {\n+                count++;\n+            }\n+        }\n+        checkState(\n+                count == 1,\n+                \"Before enqueuing the announcement there should be exactly single occurrence of the buffer, but found [%d]\",\n+                count);\n+    }\n+\n+    /**\n+     * Spills all queued buffers on checkpoint start. If barrier has already been received (and\n+     * reordered), spill only the overtaken buffers.\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {\n+        synchronized (receivedBuffers) {\n+            if (barrier.getId() < lastBarrierId) {\n+                throw new CheckpointException(\n+                        String.format(\n+                                \"Sequence number for checkpoint %d is not known (it was likely been overwritten by a newer checkpoint %d)\",\n+                                barrier.getId(), lastBarrierId),\n+                        CheckpointFailureReason\n+                                .CHECKPOINT_SUBSUMED); // currently, at most one active unaligned\n+                // checkpoint is possible\n+            } else if (barrier.getId() > lastBarrierId) {\n+                // This channel has received some obsolete barrier, older compared to the\n+                // checkpointId\n+                // which we are processing right now, and we should ignore that obsoleted checkpoint\n+                // barrier sequence number.\n+                resetLastBarrier();\n+            }\n+\n+            channelStatePersister.startPersisting(\n+                    barrier.getId(), getInflightBuffersUnsafe(barrier.getId()));\n+        }\n+    }\n+\n+    public void checkpointStopped(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            channelStatePersister.stopPersisting(checkpointId);\n+            if (lastBarrierId == checkpointId) {\n+                resetLastBarrier();\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    List<Buffer> getInflightBuffers(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            return getInflightBuffersUnsafe(checkpointId);\n+        }\n+    }\n+\n+    @Override\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n+        boolean firstPriorityEvent;\n+        synchronized (receivedBuffers) {\n+            checkState(channelStatePersister.hasBarrierReceived());\n+            int numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n+            SequenceBuffer toPrioritize =\n+                    receivedBuffers.getAndRemove(\n+                            sequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n+            checkState(lastBarrierSequenceNumber == sequenceNumber);\n+            checkState(!toPrioritize.buffer.isBuffer());\n+            checkState(\n+                    numPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n+                    \"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n+                    toPrioritize,\n+                    numPriorityElementsBeforeRemoval);\n+            // set the priority flag (checked on poll)\n+            // don't convert the barrier itself (barrier controller might not have been switched\n+            // yet)\n+            AbstractEvent e =\n+                    EventSerializer.fromBuffer(\n+                            toPrioritize.buffer, this.getClass().getClassLoader());\n+            toPrioritize.buffer.setReaderIndex(0);\n+            toPrioritize =\n+                    new SequenceBuffer(\n+                            EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n+            firstPriorityEvent =\n+                    addPriorityBuffer(\n+                            toPrioritize); // note that only position of the element is changed\n+            // converting the event itself would require switching the controller sooner\n+        }\n+        if (firstPriorityEvent) {\n+            notifyPriorityEventForce(); // forcibly notify about the priority event\n+            // instead of passing barrier SQN to be checked\n+            // because this SQN might have be seen by the input gate during the announcement\n+        }\n+    }\n+\n+    private void notifyPriorityEventForce() {\n+        inputGate.notifyPriorityEventForce(this);\n+    }\n+\n+    /**\n+     * Returns a list of buffers, checking the first n non-priority buffers, and skipping all\n+     * events.\n+     */\n+    private List<Buffer> getInflightBuffersUnsafe(long checkpointId) {\n+        assert Thread.holdsLock(receivedBuffers);\n+\n+        checkState(checkpointId == lastBarrierId || lastBarrierId == NONE);\n+\n+        final List<Buffer> inflightBuffers = new ArrayList<>();\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        // skip all priority events (only buffers are stored anyways)\n+        Iterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n+\n+        while (iterator.hasNext()) {\n+            SequenceBuffer sequenceBuffer = iterator.next();\n+            if (sequenceBuffer.buffer.isBuffer()) {\n+                if (shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+                    inflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return inflightBuffers;\n+    }\n+\n+    private void resetLastBarrier() {\n+        lastBarrierId = NONE;\n+        lastBarrierSequenceNumber = NONE;\n+    }\n+\n+    /**\n+     * @return if given {@param sequenceNumber} should be spilled given {@link\n+     *     #lastBarrierSequenceNumber}. We might not have yet received {@link CheckpointBarrier} and\n+     *     we might need to spill everything. If we have already received it, there is a bit nasty\n+     *     corner case of {@link SequenceBuffer#sequenceNumber} overflowing that needs to be handled\n+     *     as well.\n+     */\n+    private boolean shouldBeSpilled(int sequenceNumber) {\n+        if (lastBarrierSequenceNumber == NONE) {\n+            return true;\n+        }\n+        checkState(\n+                receivedBuffers.size() < Integer.MAX_VALUE / 2,\n+                \"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+        boolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastBarrierSequenceNumber;\n+        boolean possibleOverflowBeforeOvertaking =\n+                lastBarrierSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+        if (possibleOverflowAfterOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber && sequenceNumber > 0;\n+        } else if (possibleOverflowBeforeOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber || sequenceNumber > 0;\n+        } else {\n+            return sequenceNumber < lastBarrierSequenceNumber;\n+        }\n+    }\n+\n+    public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n+        boolean success = false;\n+\n+        synchronized (receivedBuffers) {\n+            if (!isReleased.get()) {\n+                if (expectedSequenceNumber == sequenceNumber) {\n+                    expectedSequenceNumber++;\n+                    success = true;\n+                } else {\n+                    onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                }\n+            }\n+        }\n+\n+        if (success && backlog >= 0) {\n+            onSenderBacklog(backlog);\n+        }\n+    }\n+\n+    public void onFailedPartitionRequest() {\n+        inputGate.triggerPartitionStateCheck(partitionId);\n+    }\n+\n+    public void onError(Throwable cause) {\n+        setError(cause);\n+    }\n+\n+    private void checkPartitionRequestQueueInitialized() throws IOException {\n+        checkError();\n+        checkState(\n+                partitionRequestClient != null,\n+                \"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n+    }\n+\n+    private static class BufferReorderingException extends IOException {\n+\n+        private static final long serialVersionUID = -888282210356266816L;\n+\n+        private final int expectedSequenceNumber;\n+\n+        private final int actualSequenceNumber;\n+\n+        BufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n+            this.expectedSequenceNumber = expectedSequenceNumber;\n+            this.actualSequenceNumber = actualSequenceNumber;\n+        }\n+\n+        @Override\n+        public String getMessage() {\n+            return String.format(\n+                    \"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n+                    expectedSequenceNumber, actualSequenceNumber);\n+        }\n+    }\n+\n+    private static final class SequenceBuffer {\n+        final Buffer buffer;\n+        final int sequenceNumber;\n+\n+        private SequenceBuffer(Buffer buffer, int sequenceNumber) {\n+            this.buffer = buffer;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\n+                    \"SequenceBuffer(isEvent = %s, dataType = %s, sequenceNumber = %s)\",\n+                    !buffer.isBuffer(), buffer.getDataType(), sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 5e125aef0d0..f9cedf71105 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -20,533 +20,798 @@ package org.apache.flink.runtime.io.network.partition.consumer;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.metrics.Counter;\n-import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.runtime.checkpoint.CheckpointException;\n+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;\n import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;\n+import org.apache.flink.runtime.event.AbstractEvent;\n import org.apache.flink.runtime.event.TaskEvent;\n+import org.apache.flink.runtime.execution.CancelTaskException;\n import org.apache.flink.runtime.io.network.ConnectionID;\n import org.apache.flink.runtime.io.network.ConnectionManager;\n import org.apache.flink.runtime.io.network.PartitionRequestClient;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+import org.apache.flink.runtime.io.network.api.EventAnnouncement;\n+import org.apache.flink.runtime.io.network.api.serialization.EventSerializer;\n import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.Buffer.DataType;\n import org.apache.flink.runtime.io.network.buffer.BufferProvider;\n-import org.apache.flink.runtime.io.network.buffer.BufferReceivedListener;\n-import org.apache.flink.runtime.io.network.netty.NettyMessage.ResumeConsumption;\n+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;\n import org.apache.flink.runtime.io.network.partition.PartitionNotFoundException;\n+import org.apache.flink.runtime.io.network.partition.PrioritizedDeque;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n \n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterators;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n-/**\n- * An input channel, which requests a remote partition queue.\n- */\n+/** An input channel, which requests a remote partition queue. */\n public class RemoteInputChannel extends InputChannel {\n-\n-\t/** ID to distinguish this channel from other channels sharing the same TCP connection. */\n-\tprivate final InputChannelID id = new InputChannelID();\n-\n-\t/** The connection to use to request the remote partition. */\n-\tprivate final ConnectionID connectionId;\n-\n-\t/** The connection manager to use connect to the remote partition provider. */\n-\tprivate final ConnectionManager connectionManager;\n-\n-\t/**\n-\t * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n-\t * is consumed by the receiving task thread.\n-\t */\n-\tprivate final ArrayDeque<Buffer> receivedBuffers = new ArrayDeque<>();\n-\n-\t/**\n-\t * Flag indicating whether this channel has been released. Either called by the receiving task\n-\t * thread or the task manager actor.\n-\t */\n-\tprivate final AtomicBoolean isReleased = new AtomicBoolean();\n-\n-\t/** Client to establish a (possibly shared) TCP connection and request the partition. */\n-\tprivate volatile PartitionRequestClient partitionRequestClient;\n-\n-\t/**\n-\t * The next expected sequence number for the next buffer. This is modified by the network\n-\t * I/O thread only.\n-\t */\n-\tprivate int expectedSequenceNumber = 0;\n-\n-\t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate final int initialCredit;\n-\n-\t/** The number of available buffers that have not been announced to the producer yet. */\n-\tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n-\n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n-\n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n-\n-\tprivate final BufferManager bufferManager;\n-\n-\tpublic RemoteInputChannel(\n-\t\tSingleInputGate inputGate,\n-\t\tint channelIndex,\n-\t\tResultPartitionID partitionId,\n-\t\tConnectionID connectionId,\n-\t\tConnectionManager connectionManager,\n-\t\tint initialBackOff,\n-\t\tint maxBackoff,\n-\t\tint networkBuffersPerChannel,\n-\t\tCounter numBytesIn,\n-\t\tCounter numBuffersIn) {\n-\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, numBytesIn, numBuffersIn);\n-\n-\t\tthis.initialCredit = networkBuffersPerChannel;\n-\t\tthis.connectionId = checkNotNull(connectionId);\n-\t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n-\t}\n-\n-\t/**\n-\t * Assigns exclusive buffers to this input channel, and this method should be called only once\n-\t * after this input channel is created.\n-\t */\n-\tvoid assignExclusiveSegments() throws IOException {\n-\t\tcheckState(bufferManager.unsynchronizedGetExclusiveBuffers() == 0, \"Bug in input channel setup logic: \" +\n-\t\t\t\"exclusive buffers have already been set for this input channel.\");\n-\n-\t\tbufferManager.requestExclusiveBuffers();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests a remote subpartition.\n-\t */\n-\t@VisibleForTesting\n-\t@Override\n-\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n-\t\tif (partitionRequestClient == null) {\n-\t\t\t// Create a client and request the partition\n-\t\t\ttry {\n-\t\t\t\tpartitionRequestClient = connectionManager.createPartitionRequestClient(connectionId);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\t// IOExceptions indicate that we could not open a connection to the remote TaskExecutor\n-\t\t\t\tthrow new PartitionConnectionException(partitionId, e);\n-\t\t\t}\n-\n-\t\t\tpartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Retriggers a remote subpartition request.\n-\t */\n-\tvoid retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n-\t\tcheckState(partitionRequestClient != null, \"Missing initial subpartition request.\");\n-\n-\t\tif (increaseBackoff()) {\n-\t\t\tpartitionRequestClient.requestSubpartition(\n-\t\t\t\tpartitionId, subpartitionIndex, this, getCurrentBackoff());\n-\t\t} else {\n-\t\t\tfailPartitionRequest();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tOptional<BufferAndAvailability> getNextBuffer() throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Queried for a buffer after channel has been closed.\");\n-\t\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tfinal Buffer next;\n-\t\tfinal boolean moreAvailable;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tnext = receivedBuffers.poll();\n-\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n-\t\t}\n-\n-\t\tnumBytesIn.inc(next.getSize());\n-\t\tnumBuffersIn.inc();\n-\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable));\n-\t}\n-\n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlastRequestedCheckpointId = checkpointId;\n-\n-\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\tcheckpointId,\n-\t\t\t\tchannelInfo,\n-\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tvoid sendTaskEvent(TaskEvent event) throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Tried to send task event to producer after channel has been released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tpartitionRequestClient.sendTaskEvent(partitionId, event, this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n-\t}\n-\n-\t/**\n-\t * Releases all exclusive and floating buffers, closes the partition request client.\n-\t */\n-\t@Override\n-\tvoid releaseAllResources() throws IOException {\n-\t\tif (isReleased.compareAndSet(false, true)) {\n-\n-\t\t\tArrayDeque<Buffer> releasedBuffers;\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\treleasedBuffers = receivedBuffers;\n-\t\t\t}\n-\t\t\tbufferManager.releaseAllBuffers(releasedBuffers);\n-\n-\t\t\t// The released flag has to be set before closing the connection to ensure that\n-\t\t\t// buffers received concurrently with closing are properly recycled.\n-\t\t\tif (partitionRequestClient != null) {\n-\t\t\t\tpartitionRequestClient.close(this);\n-\t\t\t} else {\n-\t\t\t\tconnectionManager.closeOpenChannelConnections(connectionId);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void failPartitionRequest() {\n-\t\tsetError(new PartitionNotFoundException(partitionId));\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Credit-based\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n-\t */\n-\tprivate void notifyCreditAvailable() {\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tpartitionRequestClient.notifyCreditAvailable(this);\n-\t}\n-\n-\tpublic int getNumberOfAvailableBuffers() {\n-\t\treturn bufferManager.getNumberOfAvailableBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn bufferManager.getNumberOfRequiredBuffers();\n-\t}\n-\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\treturn bufferManager.isWaitingForFloatingBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n-\t}\n-\n-\t@VisibleForTesting\n-\tBufferManager getBufferManager() {\n-\t\treturn bufferManager;\n-\t}\n-\n-\t@VisibleForTesting\n-\tPartitionRequestClient getPartitionRequestClient() {\n-\t\treturn partitionRequestClient;\n-\t}\n-\n-\t/**\n-\t * The unannounced credit is increased by the given amount and might notify\n-\t * increased credit to the producer.\n-\t */\n-\t@Override\n-\tpublic void notifyBufferAvailable(int numAvailableBuffers) {\n-\t\tif (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tbufferManager.releaseFloatingBuffers(true);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption() {\n-\t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n-\n-\t\t// notifies the producer that this channel is ready to\n-\t\t// unblock from checkpoint and resume data consumption\n-\t\tpartitionRequestClient.resumeConsumption(this);\n-\t}\n-\n-\t/**\n-\t * Called by netty thread to request buffers and generate {@link ResumeConsumption} message.\n-\t */\n-\tpublic ResumeConsumption getResumeConsumptionMessage() throws IOException {\n-\t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n-\t\tcheckState(getNumberOfAvailableBuffers() == initialCredit, \"Illegal number of available buffers.\");\n-\t\tcheckState(isWaitingForFloatingBuffers(), \"Should not be waiting for floating buffers.\");\n-\n-\t\tif (initialCredit > 0) {\n-\t\t\treturn new ResumeConsumption(id, initialCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t\t}\n-\n-\t\tint availableCredit = bufferManager.requestFloatingBuffers(0);\n-\t\treturn new ResumeConsumption(id, availableCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network I/O notifications (called by network I/O thread)\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Gets the currently unannounced credit.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getUnannouncedCredit() {\n-\t\treturn unannouncedCredit.get();\n-\t}\n-\n-\t/**\n-\t * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n-\t}\n-\n-\t/**\n-\t * Gets the current number of received buffers which have not been processed yet.\n-\t *\n-\t * @return Buffers queued for processing.\n-\t */\n-\tpublic int getNumberOfQueuedBuffers() {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treturn receivedBuffers.size();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn Math.max(0, receivedBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferManager.unsynchronizedGetExclusiveBuffers());\n-\t}\n-\n-\tpublic int unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n-\t}\n-\n-\tpublic InputChannelID getInputChannelId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic int getInitialCredit() {\n-\t\treturn initialCredit;\n-\t}\n-\n-\tpublic BufferProvider getBufferProvider() throws IOException {\n-\t\tif (isReleased.get()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn inputGate.getBufferProvider();\n-\t}\n-\n-\t/**\n-\t * Requests buffer from input channel directly for receiving network data.\n-\t * It should always return an available buffer in credit-based mode unless\n-\t * the channel has been released.\n-\t *\n-\t * @return The available buffer.\n-\t */\n-\t@Nullable\n-\tpublic Buffer requestBuffer() {\n-\t\treturn bufferManager.requestBuffer();\n-\t}\n-\n-\t/**\n-\t * Receives the backlog from the producer's buffer response. If the number of available\n-\t * buffers is less than backlog + initialCredit, it will request floating buffers from\n-\t * the buffer manager, and then notify unannounced credits to the producer.\n-\t *\n-\t * @param backlog The number of unsent buffers in the producer's sub partition.\n-\t */\n-\tpublic void onSenderBacklog(int backlog) throws IOException {\n-\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));\n-\t}\n-\n-\tpublic void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean recycleBuffer = true;\n-\n-\t\ttry {\n-\t\t\tif (expectedSequenceNumber != sequenceNumber) {\n-\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tfinal boolean wasEmpty;\n-\t\t\tfinal CheckpointBarrier notifyReceivedBarrier;\n-\t\t\tfinal Buffer notifyReceivedBuffer;\n-\t\t\tfinal CheckpointBarrier barrier;\n-\t\t\tfinal BufferReceivedListener listener = inputGate.getBufferReceivedListener();\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after releaseAllResources() released all buffers from receivedBuffers\n-\t\t\t\t// (see above for details).\n-\t\t\t\tif (isReleased.get()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n-\n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n-\t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n-\t\t\t\tbarrier = listener != null ? notifyReceivedBarrier : parseCheckpointBarrierOrNull(buffer);\n-\t\t\t}\n-\t\t\trecycleBuffer = false;\n-\n-\t\t\t++expectedSequenceNumber;\n-\n-\t\t\tif (wasEmpty) {\n-\t\t\t\tnotifyChannelNonEmpty();\n-\t\t\t}\n-\n-\t\t\tif (backlog >= 0) {\n-\t\t\t\tonSenderBacklog(backlog);\n-\t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n-\n-\t\t\tif (barrier != null) {\n-\t\t\t\tonCheckpointBarrier(barrier);\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tif (recycleBuffer) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean success = false;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tif (!isReleased.get()) {\n-\t\t\t\tif (expectedSequenceNumber == sequenceNumber) {\n-\t\t\t\t\texpectedSequenceNumber++;\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t} else {\n-\t\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (success && backlog >= 0) {\n-\t\t\tonSenderBacklog(backlog);\n-\t\t}\n-\t}\n-\n-\tpublic void onFailedPartitionRequest() {\n-\t\tinputGate.triggerPartitionStateCheck(partitionId);\n-\t}\n-\n-\tpublic void onError(Throwable cause) {\n-\t\tsetError(cause);\n-\t}\n-\n-\tprivate static class BufferReorderingException extends IOException {\n-\n-\t\tprivate static final long serialVersionUID = -888282210356266816L;\n-\n-\t\tprivate final int expectedSequenceNumber;\n-\n-\t\tprivate final int actualSequenceNumber;\n-\n-\t\tBufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n-\t\t\tthis.expectedSequenceNumber = expectedSequenceNumber;\n-\t\t\tthis.actualSequenceNumber = actualSequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String getMessage() {\n-\t\t\treturn String.format(\"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n-\t\t\t\texpectedSequenceNumber, actualSequenceNumber);\n-\t\t}\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(RemoteInputChannel.class);\n+\n+    private static final int NONE = -1;\n+\n+    /** ID to distinguish this channel from other channels sharing the same TCP connection. */\n+    private final InputChannelID id = new InputChannelID();\n+\n+    /** The connection to use to request the remote partition. */\n+    private final ConnectionID connectionId;\n+\n+    /** The connection manager to use connect to the remote partition provider. */\n+    private final ConnectionManager connectionManager;\n+\n+    /**\n+     * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n+     * is consumed by the receiving task thread.\n+     */\n+    private final PrioritizedDeque<SequenceBuffer> receivedBuffers = new PrioritizedDeque<>();\n+\n+    /**\n+     * Flag indicating whether this channel has been released. Either called by the receiving task\n+     * thread or the task manager actor.\n+     */\n+    private final AtomicBoolean isReleased = new AtomicBoolean();\n+\n+    /** Client to establish a (possibly shared) TCP connection and request the partition. */\n+    private volatile PartitionRequestClient partitionRequestClient;\n+\n+    /** The next expected sequence number for the next buffer. */\n+    private int expectedSequenceNumber = 0;\n+\n+    /** The initial number of exclusive buffers assigned to this channel. */\n+    private final int initialCredit;\n+\n+    /** The number of available buffers that have not been announced to the producer yet. */\n+    private final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n+\n+    private final BufferManager bufferManager;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private int lastBarrierSequenceNumber = NONE;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private long lastBarrierId = NONE;\n+\n+    private final ChannelStatePersister channelStatePersister;\n+\n+    public RemoteInputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            ConnectionID connectionId,\n+            ConnectionManager connectionManager,\n+            int initialBackOff,\n+            int maxBackoff,\n+            int networkBuffersPerChannel,\n+            Counter numBytesIn,\n+            Counter numBuffersIn,\n+            ChannelStateWriter stateWriter) {\n+\n+        super(\n+                inputGate,\n+                channelIndex,\n+                partitionId,\n+                initialBackOff,\n+                maxBackoff,\n+                numBytesIn,\n+                numBuffersIn);\n+        checkArgument(networkBuffersPerChannel >= 0, \"Must be non-negative.\");\n+\n+        this.initialCredit = networkBuffersPerChannel;\n+        this.connectionId = checkNotNull(connectionId);\n+        this.connectionManager = checkNotNull(connectionManager);\n+        this.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n+        this.channelStatePersister = new ChannelStatePersister(stateWriter, getChannelInfo());\n+    }\n+\n+    @VisibleForTesting\n+    void setExpectedSequenceNumber(int expectedSequenceNumber) {\n+        this.expectedSequenceNumber = expectedSequenceNumber;\n+    }\n+\n+    /**\n+     * Setup includes assigning exclusive buffers to this input channel, and this method should be\n+     * called only once after this input channel is created.\n+     */\n+    @Override\n+    void setup() throws IOException {\n+        checkState(\n+                bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+                \"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n+\n+        bufferManager.requestExclusiveBuffers(initialCredit);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /** Requests a remote subpartition. */\n+    @VisibleForTesting\n+    @Override\n+    public void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException {\n+        if (partitionRequestClient == null) {\n+            LOG.debug(\n+                    \"{}: Requesting REMOTE subpartition {} of partition {}. {}\",\n+                    this,\n+                    subpartitionIndex,\n+                    partitionId,\n+                    channelStatePersister);\n+            // Create a client and request the partition\n+            try {\n+                partitionRequestClient =\n+                        connectionManager.createPartitionRequestClient(connectionId);\n+            } catch (IOException e) {\n+                // IOExceptions indicate that we could not open a connection to the remote\n+                // TaskExecutor\n+                throw new PartitionConnectionException(partitionId, e);\n+            }\n+\n+            partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n+        }\n+    }\n+\n+    /** Retriggers a remote subpartition request. */\n+    void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (increaseBackoff()) {\n+            partitionRequestClient.requestSubpartition(\n+                    partitionId, subpartitionIndex, this, getCurrentBackoff());\n+        } else {\n+            failPartitionRequest();\n+        }\n+    }\n+\n+    @Override\n+    Optional<BufferAndAvailability> getNextBuffer() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        final SequenceBuffer next;\n+        final DataType nextDataType;\n+\n+        synchronized (receivedBuffers) {\n+            next = receivedBuffers.poll();\n+            nextDataType =\n+                    receivedBuffers.peek() != null\n+                            ? receivedBuffers.peek().buffer.getDataType()\n+                            : DataType.NONE;\n+        }\n+\n+        if (next == null) {\n+            if (isReleased.get()) {\n+                throw new CancelTaskException(\n+                        \"Queried for a buffer after channel has been released.\");\n+            }\n+            return Optional.empty();\n+        }\n+\n+        NetworkActionsLogger.traceInput(\n+                \"RemoteInputChannel#getNextBuffer\",\n+                next.buffer,\n+                inputGate.getOwningTaskName(),\n+                channelInfo,\n+                channelStatePersister,\n+                next.sequenceNumber);\n+        numBytesIn.inc(next.buffer.getSize());\n+        numBuffersIn.inc();\n+        return Optional.of(\n+                new BufferAndAvailability(next.buffer, nextDataType, 0, next.sequenceNumber));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    void sendTaskEvent(TaskEvent event) throws IOException {\n+        checkState(\n+                !isReleased.get(),\n+                \"Tried to send task event to producer after channel has been released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.sendTaskEvent(partitionId, event, this);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased.get();\n+    }\n+\n+    /** Releases all exclusive and floating buffers, closes the partition request client. */\n+    @Override\n+    void releaseAllResources() throws IOException {\n+        if (isReleased.compareAndSet(false, true)) {\n+\n+            final ArrayDeque<Buffer> releasedBuffers;\n+            synchronized (receivedBuffers) {\n+                releasedBuffers =\n+                        receivedBuffers.stream()\n+                                .map(sb -> sb.buffer)\n+                                .collect(Collectors.toCollection(ArrayDeque::new));\n+                receivedBuffers.clear();\n+            }\n+            bufferManager.releaseAllBuffers(releasedBuffers);\n+\n+            // The released flag has to be set before closing the connection to ensure that\n+            // buffers received concurrently with closing are properly recycled.\n+            if (partitionRequestClient != null) {\n+                partitionRequestClient.close(this);\n+            } else {\n+                connectionManager.closeOpenChannelConnections(connectionId);\n+            }\n+        }\n+    }\n+\n+    private void failPartitionRequest() {\n+        setError(new PartitionNotFoundException(partitionId));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Credit-based\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n+     */\n+    private void notifyCreditAvailable() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.notifyCreditAvailable(this);\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfAvailableBuffers() {\n+        return bufferManager.getNumberOfAvailableBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfRequiredBuffers() {\n+        return bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getSenderBacklog() {\n+        return getNumberOfRequiredBuffers() - initialCredit;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isWaitingForFloatingBuffers() {\n+        return bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public Buffer getNextReceivedBuffer() {\n+        final SequenceBuffer sequenceBuffer = receivedBuffers.poll();\n+        return sequenceBuffer != null ? sequenceBuffer.buffer : null;\n+    }\n+\n+    @VisibleForTesting\n+    BufferManager getBufferManager() {\n+        return bufferManager;\n+    }\n+\n+    @VisibleForTesting\n+    PartitionRequestClient getPartitionRequestClient() {\n+        return partitionRequestClient;\n+    }\n+\n+    /**\n+     * The unannounced credit is increased by the given amount and might notify increased credit to\n+     * the producer.\n+     */\n+    @Override\n+    public void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n+        if (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+            notifyCreditAvailable();\n+        }\n+    }\n+\n+    @Override\n+    public void resumeConsumption() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (initialCredit == 0) {\n+            // this unannounced credit can be a positive value because credit assignment and the\n+            // increase of this value is not an atomic operation and as a result, this unannounced\n+            // credit value can be get increased even after this channel has been blocked and all\n+            // floating credits are released, it is important to clear this unannounced credit and\n+            // at the same time reset the sender's available credits to keep consistency\n+            unannouncedCredit.set(0);\n+        }\n+\n+        // notifies the producer that this channel is ready to\n+        // unblock from checkpoint and resume data consumption\n+        partitionRequestClient.resumeConsumption(this);\n+    }\n+\n+    @Override\n+    public void acknowledgeAllRecordsProcessed() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.acknowledgeAllRecordsProcessed(this);\n+    }\n+\n+    private void onBlockingUpstream() {\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network I/O notifications (called by network I/O thread)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the currently unannounced credit.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getUnannouncedCredit() {\n+        return unannouncedCredit.get();\n+    }\n+\n+    /**\n+     * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getAndResetUnannouncedCredit() {\n+        return unannouncedCredit.getAndSet(0);\n+    }\n+\n+    /**\n+     * Gets the current number of received buffers which have not been processed yet.\n+     *\n+     * @return Buffers queued for processing.\n+     */\n+    public int getNumberOfQueuedBuffers() {\n+        synchronized (receivedBuffers) {\n+            return receivedBuffers.size();\n+        }\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return Math.max(0, receivedBuffers.size());\n+    }\n+\n+    public int unsynchronizedGetExclusiveBuffersUsed() {\n+        return Math.max(\n+                0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n+    }\n+\n+    public int unsynchronizedGetFloatingBuffersAvailable() {\n+        return Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n+    }\n+\n+    public InputChannelID getInputChannelId() {\n+        return id;\n+    }\n+\n+    public int getInitialCredit() {\n+        return initialCredit;\n+    }\n+\n+    public BufferProvider getBufferProvider() throws IOException {\n+        if (isReleased.get()) {\n+            return null;\n+        }\n+\n+        return inputGate.getBufferProvider();\n+    }\n+\n+    /**\n+     * Requests buffer from input channel directly for receiving network data. It should always\n+     * return an available buffer in credit-based mode unless the channel has been released.\n+     *\n+     * @return The available buffer.\n+     */\n+    @Nullable\n+    public Buffer requestBuffer() {\n+        return bufferManager.requestBuffer();\n+    }\n+\n+    /**\n+     * Receives the backlog from the producer's buffer response. If the number of available buffers\n+     * is less than backlog + initialCredit, it will request floating buffers from the buffer\n+     * manager, and then notify unannounced credits to the producer.\n+     *\n+     * @param backlog The number of unsent buffers in the producer's sub partition.\n+     */\n+    public void onSenderBacklog(int backlog) throws IOException {\n+        notifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+    }\n+\n+    /**\n+     * Handles the input buffer. This method is taking over the ownership of the buffer and is fully\n+     * responsible for cleaning it up both on the happy path and in case of an error.\n+     */\n+    public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n+        boolean recycleBuffer = true;\n+\n+        try {\n+            if (expectedSequenceNumber != sequenceNumber) {\n+                onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                return;\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+                checkArgument(backlog == 0, \"Illegal number of backlog: %s, should be 0.\", backlog);\n+            }\n+\n+            final boolean wasEmpty;\n+            boolean firstPriorityEvent = false;\n+            synchronized (receivedBuffers) {\n+                NetworkActionsLogger.traceInput(\n+                        \"RemoteInputChannel#onBuffer\",\n+                        buffer,\n+                        inputGate.getOwningTaskName(),\n+                        channelInfo,\n+                        channelStatePersister,\n+                        sequenceNumber);\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after releaseAllResources() released all buffers from receivedBuffers\n+                // (see above for details).\n+                if (isReleased.get()) {\n+                    return;\n+                }\n+\n+                wasEmpty = receivedBuffers.isEmpty();\n+\n+                SequenceBuffer sequenceBuffer = new SequenceBuffer(buffer, sequenceNumber);\n+                DataType dataType = buffer.getDataType();\n+                if (dataType.hasPriority()) {\n+                    firstPriorityEvent = addPriorityBuffer(sequenceBuffer);\n+                    recycleBuffer = false;\n+                } else {\n+                    receivedBuffers.add(sequenceBuffer);\n+                    recycleBuffer = false;\n+                    if (dataType.requiresAnnouncement()) {\n+                        firstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n+                    }\n+                }\n+                channelStatePersister\n+                        .checkForBarrier(sequenceBuffer.buffer)\n+                        .filter(id -> id > lastBarrierId)\n+                        .ifPresent(\n+                                id -> {\n+                                    // checkpoint was not yet started by task thread,\n+                                    // so remember the numbers of buffers to spill for the time when\n+                                    // it will be started\n+                                    lastBarrierId = id;\n+                                    lastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+                                });\n+                channelStatePersister.maybePersist(buffer);\n+                ++expectedSequenceNumber;\n+            }\n+\n+            if (firstPriorityEvent) {\n+                notifyPriorityEvent(sequenceNumber);\n+            }\n+            if (wasEmpty) {\n+                notifyChannelNonEmpty();\n+            }\n+\n+            if (backlog >= 0) {\n+                onSenderBacklog(backlog);\n+            }\n+        } finally {\n+            if (recycleBuffer) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+    }\n+\n+    /** @return {@code true} if this was first priority buffer added. */\n+    private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) {\n+        receivedBuffers.addPriorityElement(sequenceBuffer);\n+        return receivedBuffers.getNumPriorityElements() == 1;\n+    }\n+\n+    private SequenceBuffer announce(SequenceBuffer sequenceBuffer) throws IOException {\n+        checkState(\n+                !sequenceBuffer.buffer.isBuffer(),\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        checkAnnouncedOnlyOnce(sequenceBuffer);\n+        AbstractEvent event =\n+                EventSerializer.fromBuffer(sequenceBuffer.buffer, getClass().getClassLoader());\n+        checkState(\n+                event instanceof CheckpointBarrier,\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        CheckpointBarrier barrier = (CheckpointBarrier) event;\n+        return new SequenceBuffer(\n+                EventSerializer.toBuffer(\n+                        new EventAnnouncement(barrier, sequenceBuffer.sequenceNumber), true),\n+                sequenceBuffer.sequenceNumber);\n+    }\n+\n+    private void checkAnnouncedOnlyOnce(SequenceBuffer sequenceBuffer) {\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        int count = 0;\n+        while (iterator.hasNext()) {\n+            if (iterator.next().sequenceNumber == sequenceBuffer.sequenceNumber) {\n+                count++;\n+            }\n+        }\n+        checkState(\n+                count == 1,\n+                \"Before enqueuing the announcement there should be exactly single occurrence of the buffer, but found [%d]\",\n+                count);\n+    }\n+\n+    /**\n+     * Spills all queued buffers on checkpoint start. If barrier has already been received (and\n+     * reordered), spill only the overtaken buffers.\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {\n+        synchronized (receivedBuffers) {\n+            if (barrier.getId() < lastBarrierId) {\n+                throw new CheckpointException(\n+                        String.format(\n+                                \"Sequence number for checkpoint %d is not known (it was likely been overwritten by a newer checkpoint %d)\",\n+                                barrier.getId(), lastBarrierId),\n+                        CheckpointFailureReason\n+                                .CHECKPOINT_SUBSUMED); // currently, at most one active unaligned\n+                // checkpoint is possible\n+            } else if (barrier.getId() > lastBarrierId) {\n+                // This channel has received some obsolete barrier, older compared to the\n+                // checkpointId\n+                // which we are processing right now, and we should ignore that obsoleted checkpoint\n+                // barrier sequence number.\n+                resetLastBarrier();\n+            }\n+\n+            channelStatePersister.startPersisting(\n+                    barrier.getId(), getInflightBuffersUnsafe(barrier.getId()));\n+        }\n+    }\n+\n+    public void checkpointStopped(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            channelStatePersister.stopPersisting(checkpointId);\n+            if (lastBarrierId == checkpointId) {\n+                resetLastBarrier();\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    List<Buffer> getInflightBuffers(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            return getInflightBuffersUnsafe(checkpointId);\n+        }\n+    }\n+\n+    @Override\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n+        boolean firstPriorityEvent;\n+        synchronized (receivedBuffers) {\n+            checkState(channelStatePersister.hasBarrierReceived());\n+            int numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n+            SequenceBuffer toPrioritize =\n+                    receivedBuffers.getAndRemove(\n+                            sequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n+            checkState(lastBarrierSequenceNumber == sequenceNumber);\n+            checkState(!toPrioritize.buffer.isBuffer());\n+            checkState(\n+                    numPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n+                    \"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n+                    toPrioritize,\n+                    numPriorityElementsBeforeRemoval);\n+            // set the priority flag (checked on poll)\n+            // don't convert the barrier itself (barrier controller might not have been switched\n+            // yet)\n+            AbstractEvent e =\n+                    EventSerializer.fromBuffer(\n+                            toPrioritize.buffer, this.getClass().getClassLoader());\n+            toPrioritize.buffer.setReaderIndex(0);\n+            toPrioritize =\n+                    new SequenceBuffer(\n+                            EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n+            firstPriorityEvent =\n+                    addPriorityBuffer(\n+                            toPrioritize); // note that only position of the element is changed\n+            // converting the event itself would require switching the controller sooner\n+        }\n+        if (firstPriorityEvent) {\n+            notifyPriorityEventForce(); // forcibly notify about the priority event\n+            // instead of passing barrier SQN to be checked\n+            // because this SQN might have be seen by the input gate during the announcement\n+        }\n+    }\n+\n+    private void notifyPriorityEventForce() {\n+        inputGate.notifyPriorityEventForce(this);\n+    }\n+\n+    /**\n+     * Returns a list of buffers, checking the first n non-priority buffers, and skipping all\n+     * events.\n+     */\n+    private List<Buffer> getInflightBuffersUnsafe(long checkpointId) {\n+        assert Thread.holdsLock(receivedBuffers);\n+\n+        checkState(checkpointId == lastBarrierId || lastBarrierId == NONE);\n+\n+        final List<Buffer> inflightBuffers = new ArrayList<>();\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        // skip all priority events (only buffers are stored anyways)\n+        Iterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n+\n+        while (iterator.hasNext()) {\n+            SequenceBuffer sequenceBuffer = iterator.next();\n+            if (sequenceBuffer.buffer.isBuffer()) {\n+                if (shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+                    inflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return inflightBuffers;\n+    }\n+\n+    private void resetLastBarrier() {\n+        lastBarrierId = NONE;\n+        lastBarrierSequenceNumber = NONE;\n+    }\n+\n+    /**\n+     * @return if given {@param sequenceNumber} should be spilled given {@link\n+     *     #lastBarrierSequenceNumber}. We might not have yet received {@link CheckpointBarrier} and\n+     *     we might need to spill everything. If we have already received it, there is a bit nasty\n+     *     corner case of {@link SequenceBuffer#sequenceNumber} overflowing that needs to be handled\n+     *     as well.\n+     */\n+    private boolean shouldBeSpilled(int sequenceNumber) {\n+        if (lastBarrierSequenceNumber == NONE) {\n+            return true;\n+        }\n+        checkState(\n+                receivedBuffers.size() < Integer.MAX_VALUE / 2,\n+                \"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+        boolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastBarrierSequenceNumber;\n+        boolean possibleOverflowBeforeOvertaking =\n+                lastBarrierSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+        if (possibleOverflowAfterOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber && sequenceNumber > 0;\n+        } else if (possibleOverflowBeforeOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber || sequenceNumber > 0;\n+        } else {\n+            return sequenceNumber < lastBarrierSequenceNumber;\n+        }\n+    }\n+\n+    public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n+        boolean success = false;\n+\n+        synchronized (receivedBuffers) {\n+            if (!isReleased.get()) {\n+                if (expectedSequenceNumber == sequenceNumber) {\n+                    expectedSequenceNumber++;\n+                    success = true;\n+                } else {\n+                    onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                }\n+            }\n+        }\n+\n+        if (success && backlog >= 0) {\n+            onSenderBacklog(backlog);\n+        }\n+    }\n+\n+    public void onFailedPartitionRequest() {\n+        inputGate.triggerPartitionStateCheck(partitionId);\n+    }\n+\n+    public void onError(Throwable cause) {\n+        setError(cause);\n+    }\n+\n+    private void checkPartitionRequestQueueInitialized() throws IOException {\n+        checkError();\n+        checkState(\n+                partitionRequestClient != null,\n+                \"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n+    }\n+\n+    private static class BufferReorderingException extends IOException {\n+\n+        private static final long serialVersionUID = -888282210356266816L;\n+\n+        private final int expectedSequenceNumber;\n+\n+        private final int actualSequenceNumber;\n+\n+        BufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n+            this.expectedSequenceNumber = expectedSequenceNumber;\n+            this.actualSequenceNumber = actualSequenceNumber;\n+        }\n+\n+        @Override\n+        public String getMessage() {\n+            return String.format(\n+                    \"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n+                    expectedSequenceNumber, actualSequenceNumber);\n+        }\n+    }\n+\n+    private static final class SequenceBuffer {\n+        final Buffer buffer;\n+        final int sequenceNumber;\n+\n+        private SequenceBuffer(Buffer buffer, int sequenceNumber) {\n+            this.buffer = buffer;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\n+                    \"SequenceBuffer(isEvent = %s, dataType = %s, sequenceNumber = %s)\",\n+                    !buffer.isBuffer(), buffer.getDataType(), sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "0ee049db1ffe8a4a68bcd97608774ee488d02a21", "committedDate": "2021-09-03 08:19:32 +0200", "message": "[FLINK-23907] Use primitive functional interfaces"}, {"oid": "138e83e2bc6feb59ecd839b03491cd8f23ee1c66", "committedDate": "2021-11-08 08:56:34 +0100", "message": "[FLINK-24738][runtime] Ignoring buffer size announcement if the channel is released already"}, {"oid": "4eea7bc9352134a06d2b207c9a94dd46a01c6132", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[FLINK-24657][runtime] Added metric of the total real size of input/output buffers queue"}, {"oid": "f4fd4f8bb66867821cb0f171218d85f8386b0897", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] Move consumedSubpartitionIndex from SingleInputGate to InputChannel"}, {"oid": "5c2ec72982128fc1a30014677916e0dd21f9c1d2", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] SingleInputGate supports consuming subpartition range"}, {"oid": "6398abcbff06b3e488a273144680f4838b4f1c92", "committedDate": "2023-06-09 22:48:37 +0800", "message": "[FLINK-31636][network] Introduce the NettyService framework"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkwMjAyNA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424902024", "body": "nit: also adjust the javadoc of this method accordingly.", "bodyText": "nit: also adjust the javadoc of this method accordingly.", "bodyHTML": "<p dir=\"auto\">nit: also adjust the javadoc of this method accordingly.</p>", "author": "zhijiangW", "createdAt": "2020-05-14T06:38:25Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -418,8 +437,8 @@ public Buffer requestBuffer() {\n \t *\n \t * @param backlog The number of unsent buffers in the producer's sub partition.\n \t */\n-\tvoid onSenderBacklog(int backlog) throws IOException {\n-\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+\tpublic void onSenderBacklog(int backlog) throws IOException {", "originalCommit": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2cb05ba959c5ac264eb8fa85d711f499301ed767", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 5e125aef0d0..0c4f32d2f89 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -431,11 +431,11 @@ public class RemoteInputChannel extends InputChannel {\n \t}\n \n \t/**\n-\t * Receives the backlog from the producer's buffer response. If the number of available\n-\t * buffers is less than backlog + initialCredit, it will request floating buffers from\n-\t * the buffer manager, and then notify unannounced credits to the producer.\n+\t * Receives the backlog from the producer's buffer response. Floating buffers will\n+\t * be requested from the {@link BufferManager} according to the announced backlog,\n+\t * and then it will notify unannounced credits to the producer.\n \t *\n-\t * @param backlog The number of unsent buffers in the producer's sub partition.\n+\t * @param backlog Number of the announced backlog from producer.\n \t */\n \tpublic void onSenderBacklog(int backlog) throws IOException {\n \t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 0c4f32d2f89..3e976686f91 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -20,533 +20,781 @@ package org.apache.flink.runtime.io.network.partition.consumer;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.metrics.Counter;\n-import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.runtime.checkpoint.CheckpointException;\n+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;\n import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;\n+import org.apache.flink.runtime.event.AbstractEvent;\n import org.apache.flink.runtime.event.TaskEvent;\n+import org.apache.flink.runtime.execution.CancelTaskException;\n import org.apache.flink.runtime.io.network.ConnectionID;\n import org.apache.flink.runtime.io.network.ConnectionManager;\n import org.apache.flink.runtime.io.network.PartitionRequestClient;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+import org.apache.flink.runtime.io.network.api.EventAnnouncement;\n+import org.apache.flink.runtime.io.network.api.serialization.EventSerializer;\n import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.Buffer.DataType;\n import org.apache.flink.runtime.io.network.buffer.BufferProvider;\n-import org.apache.flink.runtime.io.network.buffer.BufferReceivedListener;\n-import org.apache.flink.runtime.io.network.netty.NettyMessage.ResumeConsumption;\n+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;\n import org.apache.flink.runtime.io.network.partition.PartitionNotFoundException;\n+import org.apache.flink.runtime.io.network.partition.PrioritizedDeque;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n \n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterators;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n-/**\n- * An input channel, which requests a remote partition queue.\n- */\n+/** An input channel, which requests a remote partition queue. */\n public class RemoteInputChannel extends InputChannel {\n-\n-\t/** ID to distinguish this channel from other channels sharing the same TCP connection. */\n-\tprivate final InputChannelID id = new InputChannelID();\n-\n-\t/** The connection to use to request the remote partition. */\n-\tprivate final ConnectionID connectionId;\n-\n-\t/** The connection manager to use connect to the remote partition provider. */\n-\tprivate final ConnectionManager connectionManager;\n-\n-\t/**\n-\t * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n-\t * is consumed by the receiving task thread.\n-\t */\n-\tprivate final ArrayDeque<Buffer> receivedBuffers = new ArrayDeque<>();\n-\n-\t/**\n-\t * Flag indicating whether this channel has been released. Either called by the receiving task\n-\t * thread or the task manager actor.\n-\t */\n-\tprivate final AtomicBoolean isReleased = new AtomicBoolean();\n-\n-\t/** Client to establish a (possibly shared) TCP connection and request the partition. */\n-\tprivate volatile PartitionRequestClient partitionRequestClient;\n-\n-\t/**\n-\t * The next expected sequence number for the next buffer. This is modified by the network\n-\t * I/O thread only.\n-\t */\n-\tprivate int expectedSequenceNumber = 0;\n-\n-\t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate final int initialCredit;\n-\n-\t/** The number of available buffers that have not been announced to the producer yet. */\n-\tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n-\n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n-\n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n-\n-\tprivate final BufferManager bufferManager;\n-\n-\tpublic RemoteInputChannel(\n-\t\tSingleInputGate inputGate,\n-\t\tint channelIndex,\n-\t\tResultPartitionID partitionId,\n-\t\tConnectionID connectionId,\n-\t\tConnectionManager connectionManager,\n-\t\tint initialBackOff,\n-\t\tint maxBackoff,\n-\t\tint networkBuffersPerChannel,\n-\t\tCounter numBytesIn,\n-\t\tCounter numBuffersIn) {\n-\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, numBytesIn, numBuffersIn);\n-\n-\t\tthis.initialCredit = networkBuffersPerChannel;\n-\t\tthis.connectionId = checkNotNull(connectionId);\n-\t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n-\t}\n-\n-\t/**\n-\t * Assigns exclusive buffers to this input channel, and this method should be called only once\n-\t * after this input channel is created.\n-\t */\n-\tvoid assignExclusiveSegments() throws IOException {\n-\t\tcheckState(bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n-\t\t\t\"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n-\n-\t\tbufferManager.requestExclusiveBuffers();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests a remote subpartition.\n-\t */\n-\t@VisibleForTesting\n-\t@Override\n-\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n-\t\tif (partitionRequestClient == null) {\n-\t\t\t// Create a client and request the partition\n-\t\t\ttry {\n-\t\t\t\tpartitionRequestClient = connectionManager.createPartitionRequestClient(connectionId);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\t// IOExceptions indicate that we could not open a connection to the remote TaskExecutor\n-\t\t\t\tthrow new PartitionConnectionException(partitionId, e);\n-\t\t\t}\n-\n-\t\t\tpartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Retriggers a remote subpartition request.\n-\t */\n-\tvoid retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n-\t\tcheckState(partitionRequestClient != null, \"Missing initial subpartition request.\");\n-\n-\t\tif (increaseBackoff()) {\n-\t\t\tpartitionRequestClient.requestSubpartition(\n-\t\t\t\tpartitionId, subpartitionIndex, this, getCurrentBackoff());\n-\t\t} else {\n-\t\t\tfailPartitionRequest();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tOptional<BufferAndAvailability> getNextBuffer() throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Queried for a buffer after channel has been closed.\");\n-\t\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tfinal Buffer next;\n-\t\tfinal boolean moreAvailable;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tnext = receivedBuffers.poll();\n-\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n-\t\t}\n-\n-\t\tnumBytesIn.inc(next.getSize());\n-\t\tnumBuffersIn.inc();\n-\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable));\n-\t}\n-\n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlastRequestedCheckpointId = checkpointId;\n-\n-\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\tcheckpointId,\n-\t\t\t\tchannelInfo,\n-\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tvoid sendTaskEvent(TaskEvent event) throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Tried to send task event to producer after channel has been released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tpartitionRequestClient.sendTaskEvent(partitionId, event, this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n-\t}\n-\n-\t/**\n-\t * Releases all exclusive and floating buffers, closes the partition request client.\n-\t */\n-\t@Override\n-\tvoid releaseAllResources() throws IOException {\n-\t\tif (isReleased.compareAndSet(false, true)) {\n-\n-\t\t\tArrayDeque<Buffer> releasedBuffers;\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\treleasedBuffers = receivedBuffers;\n-\t\t\t}\n-\t\t\tbufferManager.releaseAllBuffers(releasedBuffers);\n-\n-\t\t\t// The released flag has to be set before closing the connection to ensure that\n-\t\t\t// buffers received concurrently with closing are properly recycled.\n-\t\t\tif (partitionRequestClient != null) {\n-\t\t\t\tpartitionRequestClient.close(this);\n-\t\t\t} else {\n-\t\t\t\tconnectionManager.closeOpenChannelConnections(connectionId);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void failPartitionRequest() {\n-\t\tsetError(new PartitionNotFoundException(partitionId));\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Credit-based\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n-\t */\n-\tprivate void notifyCreditAvailable() {\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tpartitionRequestClient.notifyCreditAvailable(this);\n-\t}\n-\n-\tpublic int getNumberOfAvailableBuffers() {\n-\t\treturn bufferManager.getNumberOfAvailableBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn bufferManager.getNumberOfRequiredBuffers();\n-\t}\n-\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\treturn bufferManager.isWaitingForFloatingBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n-\t}\n-\n-\t@VisibleForTesting\n-\tBufferManager getBufferManager() {\n-\t\treturn bufferManager;\n-\t}\n-\n-\t@VisibleForTesting\n-\tPartitionRequestClient getPartitionRequestClient() {\n-\t\treturn partitionRequestClient;\n-\t}\n-\n-\t/**\n-\t * The unannounced credit is increased by the given amount and might notify\n-\t * increased credit to the producer.\n-\t */\n-\t@Override\n-\tpublic void notifyBufferAvailable(int numAvailableBuffers) {\n-\t\tif (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tbufferManager.releaseFloatingBuffers(true);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption() {\n-\t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n-\n-\t\t// notifies the producer that this channel is ready to\n-\t\t// unblock from checkpoint and resume data consumption\n-\t\tpartitionRequestClient.resumeConsumption(this);\n-\t}\n-\n-\t/**\n-\t * Called by netty thread to request buffers and generate {@link ResumeConsumption} message.\n-\t */\n-\tpublic ResumeConsumption getResumeConsumptionMessage() throws IOException {\n-\t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n-\t\tcheckState(getNumberOfAvailableBuffers() == initialCredit, \"Illegal number of available buffers.\");\n-\t\tcheckState(!isWaitingForFloatingBuffers(), \"Should not be waiting for floating buffers.\");\n-\n-\t\tif (initialCredit > 0) {\n-\t\t\treturn new ResumeConsumption(id, initialCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t\t}\n-\n-\t\tint availableCredit = bufferManager.requestFloatingBuffers(0);\n-\t\treturn new ResumeConsumption(id, availableCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network I/O notifications (called by network I/O thread)\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Gets the currently unannounced credit.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getUnannouncedCredit() {\n-\t\treturn unannouncedCredit.get();\n-\t}\n-\n-\t/**\n-\t * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n-\t}\n-\n-\t/**\n-\t * Gets the current number of received buffers which have not been processed yet.\n-\t *\n-\t * @return Buffers queued for processing.\n-\t */\n-\tpublic int getNumberOfQueuedBuffers() {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treturn receivedBuffers.size();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn Math.max(0, receivedBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n-\t}\n-\n-\tpublic int unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n-\t}\n-\n-\tpublic InputChannelID getInputChannelId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic int getInitialCredit() {\n-\t\treturn initialCredit;\n-\t}\n-\n-\tpublic BufferProvider getBufferProvider() throws IOException {\n-\t\tif (isReleased.get()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn inputGate.getBufferProvider();\n-\t}\n-\n-\t/**\n-\t * Requests buffer from input channel directly for receiving network data.\n-\t * It should always return an available buffer in credit-based mode unless\n-\t * the channel has been released.\n-\t *\n-\t * @return The available buffer.\n-\t */\n-\t@Nullable\n-\tpublic Buffer requestBuffer() {\n-\t\treturn bufferManager.requestBuffer();\n-\t}\n-\n-\t/**\n-\t * Receives the backlog from the producer's buffer response. Floating buffers will\n-\t * be requested from the {@link BufferManager} according to the announced backlog,\n-\t * and then it will notify unannounced credits to the producer.\n-\t *\n-\t * @param backlog Number of the announced backlog from producer.\n-\t */\n-\tpublic void onSenderBacklog(int backlog) throws IOException {\n-\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));\n-\t}\n-\n-\tpublic void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean recycleBuffer = true;\n-\n-\t\ttry {\n-\t\t\tif (expectedSequenceNumber != sequenceNumber) {\n-\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tfinal boolean wasEmpty;\n-\t\t\tfinal CheckpointBarrier notifyReceivedBarrier;\n-\t\t\tfinal Buffer notifyReceivedBuffer;\n-\t\t\tfinal CheckpointBarrier barrier;\n-\t\t\tfinal BufferReceivedListener listener = inputGate.getBufferReceivedListener();\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after releaseAllResources() released all buffers from receivedBuffers\n-\t\t\t\t// (see above for details).\n-\t\t\t\tif (isReleased.get()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n-\n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n-\t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n-\t\t\t\tbarrier = listener != null ? notifyReceivedBarrier : parseCheckpointBarrierOrNull(buffer);\n-\t\t\t}\n-\t\t\trecycleBuffer = false;\n-\n-\t\t\t++expectedSequenceNumber;\n-\n-\t\t\tif (wasEmpty) {\n-\t\t\t\tnotifyChannelNonEmpty();\n-\t\t\t}\n-\n-\t\t\tif (backlog >= 0) {\n-\t\t\t\tonSenderBacklog(backlog);\n-\t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n-\n-\t\t\tif (barrier != null) {\n-\t\t\t\tonCheckpointBarrier(barrier);\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tif (recycleBuffer) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean success = false;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tif (!isReleased.get()) {\n-\t\t\t\tif (expectedSequenceNumber == sequenceNumber) {\n-\t\t\t\t\texpectedSequenceNumber++;\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t} else {\n-\t\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (success && backlog >= 0) {\n-\t\t\tonSenderBacklog(backlog);\n-\t\t}\n-\t}\n-\n-\tpublic void onFailedPartitionRequest() {\n-\t\tinputGate.triggerPartitionStateCheck(partitionId);\n-\t}\n-\n-\tpublic void onError(Throwable cause) {\n-\t\tsetError(cause);\n-\t}\n-\n-\tprivate static class BufferReorderingException extends IOException {\n-\n-\t\tprivate static final long serialVersionUID = -888282210356266816L;\n-\n-\t\tprivate final int expectedSequenceNumber;\n-\n-\t\tprivate final int actualSequenceNumber;\n-\n-\t\tBufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n-\t\t\tthis.expectedSequenceNumber = expectedSequenceNumber;\n-\t\t\tthis.actualSequenceNumber = actualSequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String getMessage() {\n-\t\t\treturn String.format(\"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n-\t\t\t\texpectedSequenceNumber, actualSequenceNumber);\n-\t\t}\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(RemoteInputChannel.class);\n+\n+    private static final int NONE = -1;\n+\n+    /** ID to distinguish this channel from other channels sharing the same TCP connection. */\n+    private final InputChannelID id = new InputChannelID();\n+\n+    /** The connection to use to request the remote partition. */\n+    private final ConnectionID connectionId;\n+\n+    /** The connection manager to use connect to the remote partition provider. */\n+    private final ConnectionManager connectionManager;\n+\n+    /**\n+     * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n+     * is consumed by the receiving task thread.\n+     */\n+    private final PrioritizedDeque<SequenceBuffer> receivedBuffers = new PrioritizedDeque<>();\n+\n+    /**\n+     * Flag indicating whether this channel has been released. Either called by the receiving task\n+     * thread or the task manager actor.\n+     */\n+    private final AtomicBoolean isReleased = new AtomicBoolean();\n+\n+    /** Client to establish a (possibly shared) TCP connection and request the partition. */\n+    private volatile PartitionRequestClient partitionRequestClient;\n+\n+    /** The next expected sequence number for the next buffer. */\n+    private int expectedSequenceNumber = 0;\n+\n+    /** The initial number of exclusive buffers assigned to this channel. */\n+    private final int initialCredit;\n+\n+    /** The number of available buffers that have not been announced to the producer yet. */\n+    private final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n+\n+    private final BufferManager bufferManager;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private int lastBarrierSequenceNumber = NONE;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private long lastBarrierId = NONE;\n+\n+    private final ChannelStatePersister channelStatePersister;\n+\n+    private boolean isUpstreamBlocked;\n+\n+    public RemoteInputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            ConnectionID connectionId,\n+            ConnectionManager connectionManager,\n+            int initialBackOff,\n+            int maxBackoff,\n+            int networkBuffersPerChannel,\n+            Counter numBytesIn,\n+            Counter numBuffersIn,\n+            ChannelStateWriter stateWriter) {\n+\n+        super(\n+                inputGate,\n+                channelIndex,\n+                partitionId,\n+                initialBackOff,\n+                maxBackoff,\n+                numBytesIn,\n+                numBuffersIn);\n+        checkArgument(networkBuffersPerChannel >= 0, \"Must be non-negative.\");\n+\n+        this.initialCredit = networkBuffersPerChannel;\n+        this.connectionId = checkNotNull(connectionId);\n+        this.connectionManager = checkNotNull(connectionManager);\n+        this.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n+        this.channelStatePersister = new ChannelStatePersister(stateWriter, getChannelInfo());\n+    }\n+\n+    @VisibleForTesting\n+    void setExpectedSequenceNumber(int expectedSequenceNumber) {\n+        this.expectedSequenceNumber = expectedSequenceNumber;\n+    }\n+\n+    /**\n+     * Setup includes assigning exclusive buffers to this input channel, and this method should be\n+     * called only once after this input channel is created.\n+     */\n+    @Override\n+    void setup() throws IOException {\n+        checkState(\n+                bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+                \"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n+\n+        bufferManager.requestExclusiveBuffers(initialCredit);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /** Requests a remote subpartition. */\n+    @VisibleForTesting\n+    @Override\n+    public void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException {\n+        if (partitionRequestClient == null) {\n+            LOG.debug(\n+                    \"{}: Requesting REMOTE subpartition {} of partition {}. {}\",\n+                    this,\n+                    subpartitionIndex,\n+                    partitionId,\n+                    channelStatePersister);\n+            // Create a client and request the partition\n+            try {\n+                partitionRequestClient =\n+                        connectionManager.createPartitionRequestClient(connectionId);\n+            } catch (IOException e) {\n+                // IOExceptions indicate that we could not open a connection to the remote\n+                // TaskExecutor\n+                throw new PartitionConnectionException(partitionId, e);\n+            }\n+\n+            partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n+        }\n+    }\n+\n+    /** Retriggers a remote subpartition request. */\n+    void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (increaseBackoff()) {\n+            partitionRequestClient.requestSubpartition(\n+                    partitionId, subpartitionIndex, this, getCurrentBackoff());\n+        } else {\n+            failPartitionRequest();\n+        }\n+    }\n+\n+    @Override\n+    Optional<BufferAndAvailability> getNextBuffer() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        final SequenceBuffer next;\n+        final DataType nextDataType;\n+\n+        synchronized (receivedBuffers) {\n+            next = receivedBuffers.poll();\n+            nextDataType =\n+                    receivedBuffers.peek() != null\n+                            ? receivedBuffers.peek().buffer.getDataType()\n+                            : DataType.NONE;\n+        }\n+\n+        if (next == null) {\n+            if (isReleased.get()) {\n+                throw new CancelTaskException(\n+                        \"Queried for a buffer after channel has been released.\");\n+            }\n+            return Optional.empty();\n+        }\n+\n+        numBytesIn.inc(next.buffer.getSize());\n+        numBuffersIn.inc();\n+        return Optional.of(\n+                new BufferAndAvailability(next.buffer, nextDataType, 0, next.sequenceNumber));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    void sendTaskEvent(TaskEvent event) throws IOException {\n+        checkState(\n+                !isReleased.get(),\n+                \"Tried to send task event to producer after channel has been released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.sendTaskEvent(partitionId, event, this);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased.get();\n+    }\n+\n+    /** Releases all exclusive and floating buffers, closes the partition request client. */\n+    @Override\n+    void releaseAllResources() throws IOException {\n+        if (isReleased.compareAndSet(false, true)) {\n+\n+            final ArrayDeque<Buffer> releasedBuffers;\n+            synchronized (receivedBuffers) {\n+                releasedBuffers =\n+                        receivedBuffers.stream()\n+                                .map(sb -> sb.buffer)\n+                                .collect(Collectors.toCollection(ArrayDeque::new));\n+                receivedBuffers.clear();\n+            }\n+            bufferManager.releaseAllBuffers(releasedBuffers);\n+\n+            // The released flag has to be set before closing the connection to ensure that\n+            // buffers received concurrently with closing are properly recycled.\n+            if (partitionRequestClient != null) {\n+                partitionRequestClient.close(this);\n+            } else {\n+                connectionManager.closeOpenChannelConnections(connectionId);\n+            }\n+        }\n+    }\n+\n+    private void failPartitionRequest() {\n+        setError(new PartitionNotFoundException(partitionId));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Credit-based\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n+     */\n+    private void notifyCreditAvailable() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.notifyCreditAvailable(this);\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfAvailableBuffers() {\n+        return bufferManager.getNumberOfAvailableBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfRequiredBuffers() {\n+        return bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getSenderBacklog() {\n+        return getNumberOfRequiredBuffers() - initialCredit;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isWaitingForFloatingBuffers() {\n+        return bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public Buffer getNextReceivedBuffer() {\n+        final SequenceBuffer sequenceBuffer = receivedBuffers.poll();\n+        return sequenceBuffer != null ? sequenceBuffer.buffer : null;\n+    }\n+\n+    @VisibleForTesting\n+    BufferManager getBufferManager() {\n+        return bufferManager;\n+    }\n+\n+    @VisibleForTesting\n+    PartitionRequestClient getPartitionRequestClient() {\n+        return partitionRequestClient;\n+    }\n+\n+    /**\n+     * The unannounced credit is increased by the given amount and might notify increased credit to\n+     * the producer.\n+     */\n+    @Override\n+    public void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n+        if (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+            notifyCreditAvailable();\n+        }\n+    }\n+\n+    @Override\n+    public void resumeConsumption() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        // notifies the producer that this channel is ready to\n+        // unblock from checkpoint and resume data consumption\n+        partitionRequestClient.resumeConsumption(this);\n+    }\n+\n+    private void onBlockingUpstream() {\n+        isUpstreamBlocked = true;\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    public void onConsumptionResumed() {\n+        isUpstreamBlocked = false;\n+        if (initialCredit == 0) {\n+            unannouncedCredit.set(0);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network I/O notifications (called by network I/O thread)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the currently unannounced credit.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getUnannouncedCredit() {\n+        return unannouncedCredit.get();\n+    }\n+\n+    /**\n+     * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getAndResetUnannouncedCredit() {\n+        return unannouncedCredit.getAndSet(0);\n+    }\n+\n+    /**\n+     * Gets the current number of received buffers which have not been processed yet.\n+     *\n+     * @return Buffers queued for processing.\n+     */\n+    public int getNumberOfQueuedBuffers() {\n+        synchronized (receivedBuffers) {\n+            return receivedBuffers.size();\n+        }\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return Math.max(0, receivedBuffers.size());\n+    }\n+\n+    public int unsynchronizedGetExclusiveBuffersUsed() {\n+        return Math.max(\n+                0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n+    }\n+\n+    public int unsynchronizedGetFloatingBuffersAvailable() {\n+        return Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n+    }\n+\n+    public InputChannelID getInputChannelId() {\n+        return id;\n+    }\n+\n+    public int getInitialCredit() {\n+        return initialCredit;\n+    }\n+\n+    public BufferProvider getBufferProvider() throws IOException {\n+        if (isReleased.get()) {\n+            return null;\n+        }\n+\n+        return inputGate.getBufferProvider();\n+    }\n+\n+    /**\n+     * Requests buffer from input channel directly for receiving network data. It should always\n+     * return an available buffer in credit-based mode unless the channel has been released.\n+     *\n+     * @return The available buffer.\n+     */\n+    @Nullable\n+    public Buffer requestBuffer() {\n+        return bufferManager.requestBuffer(initialCredit);\n+    }\n+\n+    /**\n+     * Receives the backlog from the producer's buffer response. If the number of available buffers\n+     * is less than backlog + initialCredit, it will request floating buffers from the buffer\n+     * manager, and then notify unannounced credits to the producer.\n+     *\n+     * @param backlog The number of unsent buffers in the producer's sub partition.\n+     */\n+    public void onSenderBacklog(int backlog) throws IOException {\n+        // never allocate any new buffers if upstream has been blocked\n+        if (!isUpstreamBlocked) {\n+            notifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+        }\n+    }\n+\n+    public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n+        boolean recycleBuffer = true;\n+\n+        try {\n+            if (expectedSequenceNumber != sequenceNumber) {\n+                onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                return;\n+            }\n+\n+            final boolean wasEmpty;\n+            boolean firstPriorityEvent = false;\n+            synchronized (receivedBuffers) {\n+                NetworkActionsLogger.traceInput(\n+                        \"RemoteInputChannel#onBuffer\",\n+                        buffer,\n+                        inputGate.getOwningTaskName(),\n+                        channelInfo,\n+                        channelStatePersister,\n+                        sequenceNumber);\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after releaseAllResources() released all buffers from receivedBuffers\n+                // (see above for details).\n+                if (isReleased.get()) {\n+                    return;\n+                }\n+\n+                wasEmpty = receivedBuffers.isEmpty();\n+\n+                SequenceBuffer sequenceBuffer = new SequenceBuffer(buffer, sequenceNumber);\n+                DataType dataType = buffer.getDataType();\n+                if (dataType.hasPriority()) {\n+                    firstPriorityEvent = addPriorityBuffer(sequenceBuffer);\n+                } else {\n+                    receivedBuffers.add(sequenceBuffer);\n+                    if (dataType.requiresAnnouncement()) {\n+                        firstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n+                    }\n+                }\n+                channelStatePersister\n+                        .checkForBarrier(sequenceBuffer.buffer)\n+                        .filter(id -> id > lastBarrierId)\n+                        .ifPresent(\n+                                id -> {\n+                                    // checkpoint was not yet started by task thread,\n+                                    // so remember the numbers of buffers to spill for the time when\n+                                    // it will be started\n+                                    lastBarrierId = id;\n+                                    lastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+                                });\n+                channelStatePersister.maybePersist(buffer);\n+                ++expectedSequenceNumber;\n+            }\n+            recycleBuffer = false;\n+\n+            if (firstPriorityEvent) {\n+                notifyPriorityEvent(sequenceNumber);\n+            }\n+            if (wasEmpty) {\n+                notifyChannelNonEmpty();\n+            }\n+\n+            if (backlog >= 0) {\n+                onSenderBacklog(backlog);\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+            }\n+        } finally {\n+            if (recycleBuffer) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+    }\n+\n+    /** @return {@code true} if this was first priority buffer added. */\n+    private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) {\n+        receivedBuffers.addPriorityElement(sequenceBuffer);\n+        return receivedBuffers.getNumPriorityElements() == 1;\n+    }\n+\n+    private SequenceBuffer announce(SequenceBuffer sequenceBuffer) throws IOException {\n+        checkState(\n+                !sequenceBuffer.buffer.isBuffer(),\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        checkAnnouncedOnlyOnce(sequenceBuffer);\n+        AbstractEvent event =\n+                EventSerializer.fromBuffer(sequenceBuffer.buffer, getClass().getClassLoader());\n+        checkState(\n+                event instanceof CheckpointBarrier,\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        CheckpointBarrier barrier = (CheckpointBarrier) event;\n+        return new SequenceBuffer(\n+                EventSerializer.toBuffer(\n+                        new EventAnnouncement(barrier, sequenceBuffer.sequenceNumber), true),\n+                sequenceBuffer.sequenceNumber);\n+    }\n+\n+    private void checkAnnouncedOnlyOnce(SequenceBuffer sequenceBuffer) {\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        int count = 0;\n+        while (iterator.hasNext()) {\n+            if (iterator.next().sequenceNumber == sequenceBuffer.sequenceNumber) {\n+                count++;\n+            }\n+        }\n+        checkState(\n+                count == 1,\n+                \"Before enqueuing the announcement there should be exactly single occurrence of the buffer, but found [%d]\",\n+                count);\n+    }\n+\n+    /**\n+     * Spills all queued buffers on checkpoint start. If barrier has already been received (and\n+     * reordered), spill only the overtaken buffers.\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {\n+        synchronized (receivedBuffers) {\n+            if (barrier.getId() < lastBarrierId) {\n+                throw new CheckpointException(\n+                        String.format(\n+                                \"Sequence number for checkpoint %d is not known (it was likely been overwritten by a newer checkpoint %d)\",\n+                                barrier.getId(), lastBarrierId),\n+                        CheckpointFailureReason\n+                                .CHECKPOINT_SUBSUMED); // currently, at most one active unaligned\n+                // checkpoint is possible\n+            } else if (barrier.getId() > lastBarrierId) {\n+                // This channel has received some obsolete barrier, older compared to the\n+                // checkpointId\n+                // which we are processing right now, and we should ignore that obsoleted checkpoint\n+                // barrier sequence number.\n+                resetLastBarrier();\n+            }\n+\n+            channelStatePersister.startPersisting(\n+                    barrier.getId(), getInflightBuffersUnsafe(barrier.getId()));\n+        }\n+    }\n+\n+    public void checkpointStopped(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            channelStatePersister.stopPersisting(checkpointId);\n+            if (lastBarrierId == checkpointId) {\n+                resetLastBarrier();\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    List<Buffer> getInflightBuffers(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            return getInflightBuffersUnsafe(checkpointId);\n+        }\n+    }\n+\n+    @Override\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n+        boolean firstPriorityEvent;\n+        synchronized (receivedBuffers) {\n+            checkState(channelStatePersister.hasBarrierReceived());\n+            int numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n+            SequenceBuffer toPrioritize =\n+                    receivedBuffers.getAndRemove(\n+                            sequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n+            checkState(lastBarrierSequenceNumber == sequenceNumber);\n+            checkState(!toPrioritize.buffer.isBuffer());\n+            checkState(\n+                    numPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n+                    \"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n+                    toPrioritize,\n+                    numPriorityElementsBeforeRemoval);\n+            // set the priority flag (checked on poll)\n+            // don't convert the barrier itself (barrier controller might not have been switched\n+            // yet)\n+            AbstractEvent e =\n+                    EventSerializer.fromBuffer(\n+                            toPrioritize.buffer, this.getClass().getClassLoader());\n+            toPrioritize.buffer.setReaderIndex(0);\n+            toPrioritize =\n+                    new SequenceBuffer(\n+                            EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n+            firstPriorityEvent =\n+                    addPriorityBuffer(\n+                            toPrioritize); // note that only position of the element is changed\n+            // converting the event itself would require switching the controller sooner\n+        }\n+        if (firstPriorityEvent) {\n+            notifyPriorityEventForce(); // forcibly notify about the priority event\n+            // instead of passing barrier SQN to be checked\n+            // because this SQN might have be seen by the input gate during the announcement\n+        }\n+    }\n+\n+    private void notifyPriorityEventForce() {\n+        inputGate.notifyPriorityEventForce(this);\n+    }\n+\n+    /**\n+     * Returns a list of buffers, checking the first n non-priority buffers, and skipping all\n+     * events.\n+     */\n+    private List<Buffer> getInflightBuffersUnsafe(long checkpointId) {\n+        assert Thread.holdsLock(receivedBuffers);\n+\n+        checkState(checkpointId == lastBarrierId || lastBarrierId == NONE);\n+\n+        final List<Buffer> inflightBuffers = new ArrayList<>();\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        // skip all priority events (only buffers are stored anyways)\n+        Iterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n+\n+        while (iterator.hasNext()) {\n+            SequenceBuffer sequenceBuffer = iterator.next();\n+            if (sequenceBuffer.buffer.isBuffer()) {\n+                if (shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+                    inflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return inflightBuffers;\n+    }\n+\n+    private void resetLastBarrier() {\n+        lastBarrierId = NONE;\n+        lastBarrierSequenceNumber = NONE;\n+    }\n+\n+    /**\n+     * @return if given {@param sequenceNumber} should be spilled given {@link\n+     *     #lastBarrierSequenceNumber}. We might not have yet received {@link CheckpointBarrier} and\n+     *     we might need to spill everything. If we have already received it, there is a bit nasty\n+     *     corner case of {@link SequenceBuffer#sequenceNumber} overflowing that needs to be handled\n+     *     as well.\n+     */\n+    private boolean shouldBeSpilled(int sequenceNumber) {\n+        if (lastBarrierSequenceNumber == NONE) {\n+            return true;\n+        }\n+        checkState(\n+                receivedBuffers.size() < Integer.MAX_VALUE / 2,\n+                \"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+        boolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastBarrierSequenceNumber;\n+        boolean possibleOverflowBeforeOvertaking =\n+                lastBarrierSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+        if (possibleOverflowAfterOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber && sequenceNumber > 0;\n+        } else if (possibleOverflowBeforeOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber || sequenceNumber > 0;\n+        } else {\n+            return sequenceNumber < lastBarrierSequenceNumber;\n+        }\n+    }\n+\n+    public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n+        boolean success = false;\n+\n+        synchronized (receivedBuffers) {\n+            if (!isReleased.get()) {\n+                if (expectedSequenceNumber == sequenceNumber) {\n+                    expectedSequenceNumber++;\n+                    success = true;\n+                } else {\n+                    onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                }\n+            }\n+        }\n+\n+        if (success && backlog >= 0) {\n+            onSenderBacklog(backlog);\n+        }\n+    }\n+\n+    public void onFailedPartitionRequest() {\n+        inputGate.triggerPartitionStateCheck(partitionId);\n+    }\n+\n+    public void onError(Throwable cause) {\n+        setError(cause);\n+    }\n+\n+    private void checkPartitionRequestQueueInitialized() throws IOException {\n+        checkError();\n+        checkState(\n+                partitionRequestClient != null,\n+                \"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n+    }\n+\n+    private static class BufferReorderingException extends IOException {\n+\n+        private static final long serialVersionUID = -888282210356266816L;\n+\n+        private final int expectedSequenceNumber;\n+\n+        private final int actualSequenceNumber;\n+\n+        BufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n+            this.expectedSequenceNumber = expectedSequenceNumber;\n+            this.actualSequenceNumber = actualSequenceNumber;\n+        }\n+\n+        @Override\n+        public String getMessage() {\n+            return String.format(\n+                    \"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n+                    expectedSequenceNumber, actualSequenceNumber);\n+        }\n+    }\n+\n+    private static final class SequenceBuffer {\n+        final Buffer buffer;\n+        final int sequenceNumber;\n+\n+        private SequenceBuffer(Buffer buffer, int sequenceNumber) {\n+            this.buffer = buffer;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\n+                    \"SequenceBuffer(isEvent = %s, dataType = %s, sequenceNumber = %s)\",\n+                    !buffer.isBuffer(), buffer.getDataType(), sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 5e125aef0d0..f9cedf71105 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -20,533 +20,798 @@ package org.apache.flink.runtime.io.network.partition.consumer;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.metrics.Counter;\n-import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.runtime.checkpoint.CheckpointException;\n+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;\n import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;\n+import org.apache.flink.runtime.event.AbstractEvent;\n import org.apache.flink.runtime.event.TaskEvent;\n+import org.apache.flink.runtime.execution.CancelTaskException;\n import org.apache.flink.runtime.io.network.ConnectionID;\n import org.apache.flink.runtime.io.network.ConnectionManager;\n import org.apache.flink.runtime.io.network.PartitionRequestClient;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+import org.apache.flink.runtime.io.network.api.EventAnnouncement;\n+import org.apache.flink.runtime.io.network.api.serialization.EventSerializer;\n import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.Buffer.DataType;\n import org.apache.flink.runtime.io.network.buffer.BufferProvider;\n-import org.apache.flink.runtime.io.network.buffer.BufferReceivedListener;\n-import org.apache.flink.runtime.io.network.netty.NettyMessage.ResumeConsumption;\n+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;\n import org.apache.flink.runtime.io.network.partition.PartitionNotFoundException;\n+import org.apache.flink.runtime.io.network.partition.PrioritizedDeque;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n \n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterators;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n-/**\n- * An input channel, which requests a remote partition queue.\n- */\n+/** An input channel, which requests a remote partition queue. */\n public class RemoteInputChannel extends InputChannel {\n-\n-\t/** ID to distinguish this channel from other channels sharing the same TCP connection. */\n-\tprivate final InputChannelID id = new InputChannelID();\n-\n-\t/** The connection to use to request the remote partition. */\n-\tprivate final ConnectionID connectionId;\n-\n-\t/** The connection manager to use connect to the remote partition provider. */\n-\tprivate final ConnectionManager connectionManager;\n-\n-\t/**\n-\t * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n-\t * is consumed by the receiving task thread.\n-\t */\n-\tprivate final ArrayDeque<Buffer> receivedBuffers = new ArrayDeque<>();\n-\n-\t/**\n-\t * Flag indicating whether this channel has been released. Either called by the receiving task\n-\t * thread or the task manager actor.\n-\t */\n-\tprivate final AtomicBoolean isReleased = new AtomicBoolean();\n-\n-\t/** Client to establish a (possibly shared) TCP connection and request the partition. */\n-\tprivate volatile PartitionRequestClient partitionRequestClient;\n-\n-\t/**\n-\t * The next expected sequence number for the next buffer. This is modified by the network\n-\t * I/O thread only.\n-\t */\n-\tprivate int expectedSequenceNumber = 0;\n-\n-\t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate final int initialCredit;\n-\n-\t/** The number of available buffers that have not been announced to the producer yet. */\n-\tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n-\n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n-\n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n-\n-\tprivate final BufferManager bufferManager;\n-\n-\tpublic RemoteInputChannel(\n-\t\tSingleInputGate inputGate,\n-\t\tint channelIndex,\n-\t\tResultPartitionID partitionId,\n-\t\tConnectionID connectionId,\n-\t\tConnectionManager connectionManager,\n-\t\tint initialBackOff,\n-\t\tint maxBackoff,\n-\t\tint networkBuffersPerChannel,\n-\t\tCounter numBytesIn,\n-\t\tCounter numBuffersIn) {\n-\n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, numBytesIn, numBuffersIn);\n-\n-\t\tthis.initialCredit = networkBuffersPerChannel;\n-\t\tthis.connectionId = checkNotNull(connectionId);\n-\t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n-\t}\n-\n-\t/**\n-\t * Assigns exclusive buffers to this input channel, and this method should be called only once\n-\t * after this input channel is created.\n-\t */\n-\tvoid assignExclusiveSegments() throws IOException {\n-\t\tcheckState(bufferManager.unsynchronizedGetExclusiveBuffers() == 0, \"Bug in input channel setup logic: \" +\n-\t\t\t\"exclusive buffers have already been set for this input channel.\");\n-\n-\t\tbufferManager.requestExclusiveBuffers();\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Consume\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Requests a remote subpartition.\n-\t */\n-\t@VisibleForTesting\n-\t@Override\n-\tpublic void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n-\t\tif (partitionRequestClient == null) {\n-\t\t\t// Create a client and request the partition\n-\t\t\ttry {\n-\t\t\t\tpartitionRequestClient = connectionManager.createPartitionRequestClient(connectionId);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\t// IOExceptions indicate that we could not open a connection to the remote TaskExecutor\n-\t\t\t\tthrow new PartitionConnectionException(partitionId, e);\n-\t\t\t}\n-\n-\t\t\tpartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Retriggers a remote subpartition request.\n-\t */\n-\tvoid retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n-\t\tcheckState(partitionRequestClient != null, \"Missing initial subpartition request.\");\n-\n-\t\tif (increaseBackoff()) {\n-\t\t\tpartitionRequestClient.requestSubpartition(\n-\t\t\t\tpartitionId, subpartitionIndex, this, getCurrentBackoff());\n-\t\t} else {\n-\t\t\tfailPartitionRequest();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tOptional<BufferAndAvailability> getNextBuffer() throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Queried for a buffer after channel has been closed.\");\n-\t\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tfinal Buffer next;\n-\t\tfinal boolean moreAvailable;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tnext = receivedBuffers.poll();\n-\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n-\t\t}\n-\n-\t\tnumBytesIn.inc(next.getSize());\n-\t\tnumBuffersIn.inc();\n-\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable));\n-\t}\n-\n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlastRequestedCheckpointId = checkpointId;\n-\n-\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\tcheckpointId,\n-\t\t\t\tchannelInfo,\n-\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Task events\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tvoid sendTaskEvent(TaskEvent event) throws IOException {\n-\t\tcheckState(!isReleased.get(), \"Tried to send task event to producer after channel has been released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tcheckError();\n-\n-\t\tpartitionRequestClient.sendTaskEvent(partitionId, event, this);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Life cycle\n-\t// ------------------------------------------------------------------------\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n-\t}\n-\n-\t/**\n-\t * Releases all exclusive and floating buffers, closes the partition request client.\n-\t */\n-\t@Override\n-\tvoid releaseAllResources() throws IOException {\n-\t\tif (isReleased.compareAndSet(false, true)) {\n-\n-\t\t\tArrayDeque<Buffer> releasedBuffers;\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\treleasedBuffers = receivedBuffers;\n-\t\t\t}\n-\t\t\tbufferManager.releaseAllBuffers(releasedBuffers);\n-\n-\t\t\t// The released flag has to be set before closing the connection to ensure that\n-\t\t\t// buffers received concurrently with closing are properly recycled.\n-\t\t\tif (partitionRequestClient != null) {\n-\t\t\t\tpartitionRequestClient.close(this);\n-\t\t\t} else {\n-\t\t\t\tconnectionManager.closeOpenChannelConnections(connectionId);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void failPartitionRequest() {\n-\t\tsetError(new PartitionNotFoundException(partitionId));\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Credit-based\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n-\t */\n-\tprivate void notifyCreditAvailable() {\n-\t\tcheckState(partitionRequestClient != null, \"Tried to send task event to producer before requesting a queue.\");\n-\n-\t\tpartitionRequestClient.notifyCreditAvailable(this);\n-\t}\n-\n-\tpublic int getNumberOfAvailableBuffers() {\n-\t\treturn bufferManager.getNumberOfAvailableBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn bufferManager.getNumberOfRequiredBuffers();\n-\t}\n-\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\treturn bufferManager.isWaitingForFloatingBuffers();\n-\t}\n-\n-\t@VisibleForTesting\n-\tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n-\t}\n-\n-\t@VisibleForTesting\n-\tBufferManager getBufferManager() {\n-\t\treturn bufferManager;\n-\t}\n-\n-\t@VisibleForTesting\n-\tPartitionRequestClient getPartitionRequestClient() {\n-\t\treturn partitionRequestClient;\n-\t}\n-\n-\t/**\n-\t * The unannounced credit is increased by the given amount and might notify\n-\t * increased credit to the producer.\n-\t */\n-\t@Override\n-\tpublic void notifyBufferAvailable(int numAvailableBuffers) {\n-\t\tif (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\tbufferManager.releaseFloatingBuffers(true);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption() {\n-\t\tcheckState(!isReleased.get(), \"Channel released.\");\n-\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n-\n-\t\t// notifies the producer that this channel is ready to\n-\t\t// unblock from checkpoint and resume data consumption\n-\t\tpartitionRequestClient.resumeConsumption(this);\n-\t}\n-\n-\t/**\n-\t * Called by netty thread to request buffers and generate {@link ResumeConsumption} message.\n-\t */\n-\tpublic ResumeConsumption getResumeConsumptionMessage() throws IOException {\n-\t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n-\t\tcheckState(getNumberOfAvailableBuffers() == initialCredit, \"Illegal number of available buffers.\");\n-\t\tcheckState(isWaitingForFloatingBuffers(), \"Should not be waiting for floating buffers.\");\n-\n-\t\tif (initialCredit > 0) {\n-\t\t\treturn new ResumeConsumption(id, initialCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t\t}\n-\n-\t\tint availableCredit = bufferManager.requestFloatingBuffers(0);\n-\t\treturn new ResumeConsumption(id, availableCredit, bufferManager.getNumberOfRequiredBuffers() > 0);\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Network I/O notifications (called by network I/O thread)\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Gets the currently unannounced credit.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getUnannouncedCredit() {\n-\t\treturn unannouncedCredit.get();\n-\t}\n-\n-\t/**\n-\t * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n-\t *\n-\t * @return Credit which was not announced to the sender yet.\n-\t */\n-\tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n-\t}\n-\n-\t/**\n-\t * Gets the current number of received buffers which have not been processed yet.\n-\t *\n-\t * @return Buffers queued for processing.\n-\t */\n-\tpublic int getNumberOfQueuedBuffers() {\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treturn receivedBuffers.size();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int unsynchronizedGetNumberOfQueuedBuffers() {\n-\t\treturn Math.max(0, receivedBuffers.size());\n-\t}\n-\n-\tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferManager.unsynchronizedGetExclusiveBuffers());\n-\t}\n-\n-\tpublic int unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n-\t}\n-\n-\tpublic InputChannelID getInputChannelId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic int getInitialCredit() {\n-\t\treturn initialCredit;\n-\t}\n-\n-\tpublic BufferProvider getBufferProvider() throws IOException {\n-\t\tif (isReleased.get()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn inputGate.getBufferProvider();\n-\t}\n-\n-\t/**\n-\t * Requests buffer from input channel directly for receiving network data.\n-\t * It should always return an available buffer in credit-based mode unless\n-\t * the channel has been released.\n-\t *\n-\t * @return The available buffer.\n-\t */\n-\t@Nullable\n-\tpublic Buffer requestBuffer() {\n-\t\treturn bufferManager.requestBuffer();\n-\t}\n-\n-\t/**\n-\t * Receives the backlog from the producer's buffer response. If the number of available\n-\t * buffers is less than backlog + initialCredit, it will request floating buffers from\n-\t * the buffer manager, and then notify unannounced credits to the producer.\n-\t *\n-\t * @param backlog The number of unsent buffers in the producer's sub partition.\n-\t */\n-\tpublic void onSenderBacklog(int backlog) throws IOException {\n-\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));\n-\t}\n-\n-\tpublic void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean recycleBuffer = true;\n-\n-\t\ttry {\n-\t\t\tif (expectedSequenceNumber != sequenceNumber) {\n-\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tfinal boolean wasEmpty;\n-\t\t\tfinal CheckpointBarrier notifyReceivedBarrier;\n-\t\t\tfinal Buffer notifyReceivedBuffer;\n-\t\t\tfinal CheckpointBarrier barrier;\n-\t\t\tfinal BufferReceivedListener listener = inputGate.getBufferReceivedListener();\n-\t\t\tsynchronized (receivedBuffers) {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after releaseAllResources() released all buffers from receivedBuffers\n-\t\t\t\t// (see above for details).\n-\t\t\t\tif (isReleased.get()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n-\n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n-\t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n-\t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n-\t\t\t\tbarrier = listener != null ? notifyReceivedBarrier : parseCheckpointBarrierOrNull(buffer);\n-\t\t\t}\n-\t\t\trecycleBuffer = false;\n-\n-\t\t\t++expectedSequenceNumber;\n-\n-\t\t\tif (wasEmpty) {\n-\t\t\t\tnotifyChannelNonEmpty();\n-\t\t\t}\n-\n-\t\t\tif (backlog >= 0) {\n-\t\t\t\tonSenderBacklog(backlog);\n-\t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n-\n-\t\t\tif (barrier != null) {\n-\t\t\t\tonCheckpointBarrier(barrier);\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tif (recycleBuffer) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n-\t\tboolean success = false;\n-\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tif (!isReleased.get()) {\n-\t\t\t\tif (expectedSequenceNumber == sequenceNumber) {\n-\t\t\t\t\texpectedSequenceNumber++;\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t} else {\n-\t\t\t\t\tonError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (success && backlog >= 0) {\n-\t\t\tonSenderBacklog(backlog);\n-\t\t}\n-\t}\n-\n-\tpublic void onFailedPartitionRequest() {\n-\t\tinputGate.triggerPartitionStateCheck(partitionId);\n-\t}\n-\n-\tpublic void onError(Throwable cause) {\n-\t\tsetError(cause);\n-\t}\n-\n-\tprivate static class BufferReorderingException extends IOException {\n-\n-\t\tprivate static final long serialVersionUID = -888282210356266816L;\n-\n-\t\tprivate final int expectedSequenceNumber;\n-\n-\t\tprivate final int actualSequenceNumber;\n-\n-\t\tBufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n-\t\t\tthis.expectedSequenceNumber = expectedSequenceNumber;\n-\t\t\tthis.actualSequenceNumber = actualSequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String getMessage() {\n-\t\t\treturn String.format(\"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n-\t\t\t\texpectedSequenceNumber, actualSequenceNumber);\n-\t\t}\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(RemoteInputChannel.class);\n+\n+    private static final int NONE = -1;\n+\n+    /** ID to distinguish this channel from other channels sharing the same TCP connection. */\n+    private final InputChannelID id = new InputChannelID();\n+\n+    /** The connection to use to request the remote partition. */\n+    private final ConnectionID connectionId;\n+\n+    /** The connection manager to use connect to the remote partition provider. */\n+    private final ConnectionManager connectionManager;\n+\n+    /**\n+     * The received buffers. Received buffers are enqueued by the network I/O thread and the queue\n+     * is consumed by the receiving task thread.\n+     */\n+    private final PrioritizedDeque<SequenceBuffer> receivedBuffers = new PrioritizedDeque<>();\n+\n+    /**\n+     * Flag indicating whether this channel has been released. Either called by the receiving task\n+     * thread or the task manager actor.\n+     */\n+    private final AtomicBoolean isReleased = new AtomicBoolean();\n+\n+    /** Client to establish a (possibly shared) TCP connection and request the partition. */\n+    private volatile PartitionRequestClient partitionRequestClient;\n+\n+    /** The next expected sequence number for the next buffer. */\n+    private int expectedSequenceNumber = 0;\n+\n+    /** The initial number of exclusive buffers assigned to this channel. */\n+    private final int initialCredit;\n+\n+    /** The number of available buffers that have not been announced to the producer yet. */\n+    private final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n+\n+    private final BufferManager bufferManager;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private int lastBarrierSequenceNumber = NONE;\n+\n+    @GuardedBy(\"receivedBuffers\")\n+    private long lastBarrierId = NONE;\n+\n+    private final ChannelStatePersister channelStatePersister;\n+\n+    public RemoteInputChannel(\n+            SingleInputGate inputGate,\n+            int channelIndex,\n+            ResultPartitionID partitionId,\n+            ConnectionID connectionId,\n+            ConnectionManager connectionManager,\n+            int initialBackOff,\n+            int maxBackoff,\n+            int networkBuffersPerChannel,\n+            Counter numBytesIn,\n+            Counter numBuffersIn,\n+            ChannelStateWriter stateWriter) {\n+\n+        super(\n+                inputGate,\n+                channelIndex,\n+                partitionId,\n+                initialBackOff,\n+                maxBackoff,\n+                numBytesIn,\n+                numBuffersIn);\n+        checkArgument(networkBuffersPerChannel >= 0, \"Must be non-negative.\");\n+\n+        this.initialCredit = networkBuffersPerChannel;\n+        this.connectionId = checkNotNull(connectionId);\n+        this.connectionManager = checkNotNull(connectionManager);\n+        this.bufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n+        this.channelStatePersister = new ChannelStatePersister(stateWriter, getChannelInfo());\n+    }\n+\n+    @VisibleForTesting\n+    void setExpectedSequenceNumber(int expectedSequenceNumber) {\n+        this.expectedSequenceNumber = expectedSequenceNumber;\n+    }\n+\n+    /**\n+     * Setup includes assigning exclusive buffers to this input channel, and this method should be\n+     * called only once after this input channel is created.\n+     */\n+    @Override\n+    void setup() throws IOException {\n+        checkState(\n+                bufferManager.unsynchronizedGetAvailableExclusiveBuffers() == 0,\n+                \"Bug in input channel setup logic: exclusive buffers have already been set for this input channel.\");\n+\n+        bufferManager.requestExclusiveBuffers(initialCredit);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Consume\n+    // ------------------------------------------------------------------------\n+\n+    /** Requests a remote subpartition. */\n+    @VisibleForTesting\n+    @Override\n+    public void requestSubpartition(int subpartitionIndex)\n+            throws IOException, InterruptedException {\n+        if (partitionRequestClient == null) {\n+            LOG.debug(\n+                    \"{}: Requesting REMOTE subpartition {} of partition {}. {}\",\n+                    this,\n+                    subpartitionIndex,\n+                    partitionId,\n+                    channelStatePersister);\n+            // Create a client and request the partition\n+            try {\n+                partitionRequestClient =\n+                        connectionManager.createPartitionRequestClient(connectionId);\n+            } catch (IOException e) {\n+                // IOExceptions indicate that we could not open a connection to the remote\n+                // TaskExecutor\n+                throw new PartitionConnectionException(partitionId, e);\n+            }\n+\n+            partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n+        }\n+    }\n+\n+    /** Retriggers a remote subpartition request. */\n+    void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (increaseBackoff()) {\n+            partitionRequestClient.requestSubpartition(\n+                    partitionId, subpartitionIndex, this, getCurrentBackoff());\n+        } else {\n+            failPartitionRequest();\n+        }\n+    }\n+\n+    @Override\n+    Optional<BufferAndAvailability> getNextBuffer() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        final SequenceBuffer next;\n+        final DataType nextDataType;\n+\n+        synchronized (receivedBuffers) {\n+            next = receivedBuffers.poll();\n+            nextDataType =\n+                    receivedBuffers.peek() != null\n+                            ? receivedBuffers.peek().buffer.getDataType()\n+                            : DataType.NONE;\n+        }\n+\n+        if (next == null) {\n+            if (isReleased.get()) {\n+                throw new CancelTaskException(\n+                        \"Queried for a buffer after channel has been released.\");\n+            }\n+            return Optional.empty();\n+        }\n+\n+        NetworkActionsLogger.traceInput(\n+                \"RemoteInputChannel#getNextBuffer\",\n+                next.buffer,\n+                inputGate.getOwningTaskName(),\n+                channelInfo,\n+                channelStatePersister,\n+                next.sequenceNumber);\n+        numBytesIn.inc(next.buffer.getSize());\n+        numBuffersIn.inc();\n+        return Optional.of(\n+                new BufferAndAvailability(next.buffer, nextDataType, 0, next.sequenceNumber));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Task events\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    void sendTaskEvent(TaskEvent event) throws IOException {\n+        checkState(\n+                !isReleased.get(),\n+                \"Tried to send task event to producer after channel has been released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.sendTaskEvent(partitionId, event, this);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Life cycle\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public boolean isReleased() {\n+        return isReleased.get();\n+    }\n+\n+    /** Releases all exclusive and floating buffers, closes the partition request client. */\n+    @Override\n+    void releaseAllResources() throws IOException {\n+        if (isReleased.compareAndSet(false, true)) {\n+\n+            final ArrayDeque<Buffer> releasedBuffers;\n+            synchronized (receivedBuffers) {\n+                releasedBuffers =\n+                        receivedBuffers.stream()\n+                                .map(sb -> sb.buffer)\n+                                .collect(Collectors.toCollection(ArrayDeque::new));\n+                receivedBuffers.clear();\n+            }\n+            bufferManager.releaseAllBuffers(releasedBuffers);\n+\n+            // The released flag has to be set before closing the connection to ensure that\n+            // buffers received concurrently with closing are properly recycled.\n+            if (partitionRequestClient != null) {\n+                partitionRequestClient.close(this);\n+            } else {\n+                connectionManager.closeOpenChannelConnections(connectionId);\n+            }\n+        }\n+    }\n+\n+    private void failPartitionRequest() {\n+        setError(new PartitionNotFoundException(partitionId));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RemoteInputChannel [\" + partitionId + \" at \" + connectionId + \"]\";\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Credit-based\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.\n+     */\n+    private void notifyCreditAvailable() throws IOException {\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.notifyCreditAvailable(this);\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfAvailableBuffers() {\n+        return bufferManager.getNumberOfAvailableBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getNumberOfRequiredBuffers() {\n+        return bufferManager.unsynchronizedGetNumberOfRequiredBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public int getSenderBacklog() {\n+        return getNumberOfRequiredBuffers() - initialCredit;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isWaitingForFloatingBuffers() {\n+        return bufferManager.unsynchronizedIsWaitingForFloatingBuffers();\n+    }\n+\n+    @VisibleForTesting\n+    public Buffer getNextReceivedBuffer() {\n+        final SequenceBuffer sequenceBuffer = receivedBuffers.poll();\n+        return sequenceBuffer != null ? sequenceBuffer.buffer : null;\n+    }\n+\n+    @VisibleForTesting\n+    BufferManager getBufferManager() {\n+        return bufferManager;\n+    }\n+\n+    @VisibleForTesting\n+    PartitionRequestClient getPartitionRequestClient() {\n+        return partitionRequestClient;\n+    }\n+\n+    /**\n+     * The unannounced credit is increased by the given amount and might notify increased credit to\n+     * the producer.\n+     */\n+    @Override\n+    public void notifyBufferAvailable(int numAvailableBuffers) throws IOException {\n+        if (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+            notifyCreditAvailable();\n+        }\n+    }\n+\n+    @Override\n+    public void resumeConsumption() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        if (initialCredit == 0) {\n+            // this unannounced credit can be a positive value because credit assignment and the\n+            // increase of this value is not an atomic operation and as a result, this unannounced\n+            // credit value can be get increased even after this channel has been blocked and all\n+            // floating credits are released, it is important to clear this unannounced credit and\n+            // at the same time reset the sender's available credits to keep consistency\n+            unannouncedCredit.set(0);\n+        }\n+\n+        // notifies the producer that this channel is ready to\n+        // unblock from checkpoint and resume data consumption\n+        partitionRequestClient.resumeConsumption(this);\n+    }\n+\n+    @Override\n+    public void acknowledgeAllRecordsProcessed() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.acknowledgeAllRecordsProcessed(this);\n+    }\n+\n+    private void onBlockingUpstream() {\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Network I/O notifications (called by network I/O thread)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the currently unannounced credit.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getUnannouncedCredit() {\n+        return unannouncedCredit.get();\n+    }\n+\n+    /**\n+     * Gets the unannounced credit and resets it to <tt>0</tt> atomically.\n+     *\n+     * @return Credit which was not announced to the sender yet.\n+     */\n+    public int getAndResetUnannouncedCredit() {\n+        return unannouncedCredit.getAndSet(0);\n+    }\n+\n+    /**\n+     * Gets the current number of received buffers which have not been processed yet.\n+     *\n+     * @return Buffers queued for processing.\n+     */\n+    public int getNumberOfQueuedBuffers() {\n+        synchronized (receivedBuffers) {\n+            return receivedBuffers.size();\n+        }\n+    }\n+\n+    @Override\n+    public int unsynchronizedGetNumberOfQueuedBuffers() {\n+        return Math.max(0, receivedBuffers.size());\n+    }\n+\n+    public int unsynchronizedGetExclusiveBuffersUsed() {\n+        return Math.max(\n+                0, initialCredit - bufferManager.unsynchronizedGetAvailableExclusiveBuffers());\n+    }\n+\n+    public int unsynchronizedGetFloatingBuffersAvailable() {\n+        return Math.max(0, bufferManager.unsynchronizedGetFloatingBuffersAvailable());\n+    }\n+\n+    public InputChannelID getInputChannelId() {\n+        return id;\n+    }\n+\n+    public int getInitialCredit() {\n+        return initialCredit;\n+    }\n+\n+    public BufferProvider getBufferProvider() throws IOException {\n+        if (isReleased.get()) {\n+            return null;\n+        }\n+\n+        return inputGate.getBufferProvider();\n+    }\n+\n+    /**\n+     * Requests buffer from input channel directly for receiving network data. It should always\n+     * return an available buffer in credit-based mode unless the channel has been released.\n+     *\n+     * @return The available buffer.\n+     */\n+    @Nullable\n+    public Buffer requestBuffer() {\n+        return bufferManager.requestBuffer();\n+    }\n+\n+    /**\n+     * Receives the backlog from the producer's buffer response. If the number of available buffers\n+     * is less than backlog + initialCredit, it will request floating buffers from the buffer\n+     * manager, and then notify unannounced credits to the producer.\n+     *\n+     * @param backlog The number of unsent buffers in the producer's sub partition.\n+     */\n+    public void onSenderBacklog(int backlog) throws IOException {\n+        notifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+    }\n+\n+    /**\n+     * Handles the input buffer. This method is taking over the ownership of the buffer and is fully\n+     * responsible for cleaning it up both on the happy path and in case of an error.\n+     */\n+    public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {\n+        boolean recycleBuffer = true;\n+\n+        try {\n+            if (expectedSequenceNumber != sequenceNumber) {\n+                onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                return;\n+            }\n+\n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+                checkArgument(backlog == 0, \"Illegal number of backlog: %s, should be 0.\", backlog);\n+            }\n+\n+            final boolean wasEmpty;\n+            boolean firstPriorityEvent = false;\n+            synchronized (receivedBuffers) {\n+                NetworkActionsLogger.traceInput(\n+                        \"RemoteInputChannel#onBuffer\",\n+                        buffer,\n+                        inputGate.getOwningTaskName(),\n+                        channelInfo,\n+                        channelStatePersister,\n+                        sequenceNumber);\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after releaseAllResources() released all buffers from receivedBuffers\n+                // (see above for details).\n+                if (isReleased.get()) {\n+                    return;\n+                }\n+\n+                wasEmpty = receivedBuffers.isEmpty();\n+\n+                SequenceBuffer sequenceBuffer = new SequenceBuffer(buffer, sequenceNumber);\n+                DataType dataType = buffer.getDataType();\n+                if (dataType.hasPriority()) {\n+                    firstPriorityEvent = addPriorityBuffer(sequenceBuffer);\n+                    recycleBuffer = false;\n+                } else {\n+                    receivedBuffers.add(sequenceBuffer);\n+                    recycleBuffer = false;\n+                    if (dataType.requiresAnnouncement()) {\n+                        firstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n+                    }\n+                }\n+                channelStatePersister\n+                        .checkForBarrier(sequenceBuffer.buffer)\n+                        .filter(id -> id > lastBarrierId)\n+                        .ifPresent(\n+                                id -> {\n+                                    // checkpoint was not yet started by task thread,\n+                                    // so remember the numbers of buffers to spill for the time when\n+                                    // it will be started\n+                                    lastBarrierId = id;\n+                                    lastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+                                });\n+                channelStatePersister.maybePersist(buffer);\n+                ++expectedSequenceNumber;\n+            }\n+\n+            if (firstPriorityEvent) {\n+                notifyPriorityEvent(sequenceNumber);\n+            }\n+            if (wasEmpty) {\n+                notifyChannelNonEmpty();\n+            }\n+\n+            if (backlog >= 0) {\n+                onSenderBacklog(backlog);\n+            }\n+        } finally {\n+            if (recycleBuffer) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+    }\n+\n+    /** @return {@code true} if this was first priority buffer added. */\n+    private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) {\n+        receivedBuffers.addPriorityElement(sequenceBuffer);\n+        return receivedBuffers.getNumPriorityElements() == 1;\n+    }\n+\n+    private SequenceBuffer announce(SequenceBuffer sequenceBuffer) throws IOException {\n+        checkState(\n+                !sequenceBuffer.buffer.isBuffer(),\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        checkAnnouncedOnlyOnce(sequenceBuffer);\n+        AbstractEvent event =\n+                EventSerializer.fromBuffer(sequenceBuffer.buffer, getClass().getClassLoader());\n+        checkState(\n+                event instanceof CheckpointBarrier,\n+                \"Only a CheckpointBarrier can be announced but found %s\",\n+                sequenceBuffer.buffer);\n+        CheckpointBarrier barrier = (CheckpointBarrier) event;\n+        return new SequenceBuffer(\n+                EventSerializer.toBuffer(\n+                        new EventAnnouncement(barrier, sequenceBuffer.sequenceNumber), true),\n+                sequenceBuffer.sequenceNumber);\n+    }\n+\n+    private void checkAnnouncedOnlyOnce(SequenceBuffer sequenceBuffer) {\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        int count = 0;\n+        while (iterator.hasNext()) {\n+            if (iterator.next().sequenceNumber == sequenceBuffer.sequenceNumber) {\n+                count++;\n+            }\n+        }\n+        checkState(\n+                count == 1,\n+                \"Before enqueuing the announcement there should be exactly single occurrence of the buffer, but found [%d]\",\n+                count);\n+    }\n+\n+    /**\n+     * Spills all queued buffers on checkpoint start. If barrier has already been received (and\n+     * reordered), spill only the overtaken buffers.\n+     */\n+    public void checkpointStarted(CheckpointBarrier barrier) throws CheckpointException {\n+        synchronized (receivedBuffers) {\n+            if (barrier.getId() < lastBarrierId) {\n+                throw new CheckpointException(\n+                        String.format(\n+                                \"Sequence number for checkpoint %d is not known (it was likely been overwritten by a newer checkpoint %d)\",\n+                                barrier.getId(), lastBarrierId),\n+                        CheckpointFailureReason\n+                                .CHECKPOINT_SUBSUMED); // currently, at most one active unaligned\n+                // checkpoint is possible\n+            } else if (barrier.getId() > lastBarrierId) {\n+                // This channel has received some obsolete barrier, older compared to the\n+                // checkpointId\n+                // which we are processing right now, and we should ignore that obsoleted checkpoint\n+                // barrier sequence number.\n+                resetLastBarrier();\n+            }\n+\n+            channelStatePersister.startPersisting(\n+                    barrier.getId(), getInflightBuffersUnsafe(barrier.getId()));\n+        }\n+    }\n+\n+    public void checkpointStopped(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            channelStatePersister.stopPersisting(checkpointId);\n+            if (lastBarrierId == checkpointId) {\n+                resetLastBarrier();\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    List<Buffer> getInflightBuffers(long checkpointId) {\n+        synchronized (receivedBuffers) {\n+            return getInflightBuffersUnsafe(checkpointId);\n+        }\n+    }\n+\n+    @Override\n+    public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n+        boolean firstPriorityEvent;\n+        synchronized (receivedBuffers) {\n+            checkState(channelStatePersister.hasBarrierReceived());\n+            int numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n+            SequenceBuffer toPrioritize =\n+                    receivedBuffers.getAndRemove(\n+                            sequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n+            checkState(lastBarrierSequenceNumber == sequenceNumber);\n+            checkState(!toPrioritize.buffer.isBuffer());\n+            checkState(\n+                    numPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n+                    \"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n+                    toPrioritize,\n+                    numPriorityElementsBeforeRemoval);\n+            // set the priority flag (checked on poll)\n+            // don't convert the barrier itself (barrier controller might not have been switched\n+            // yet)\n+            AbstractEvent e =\n+                    EventSerializer.fromBuffer(\n+                            toPrioritize.buffer, this.getClass().getClassLoader());\n+            toPrioritize.buffer.setReaderIndex(0);\n+            toPrioritize =\n+                    new SequenceBuffer(\n+                            EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n+            firstPriorityEvent =\n+                    addPriorityBuffer(\n+                            toPrioritize); // note that only position of the element is changed\n+            // converting the event itself would require switching the controller sooner\n+        }\n+        if (firstPriorityEvent) {\n+            notifyPriorityEventForce(); // forcibly notify about the priority event\n+            // instead of passing barrier SQN to be checked\n+            // because this SQN might have be seen by the input gate during the announcement\n+        }\n+    }\n+\n+    private void notifyPriorityEventForce() {\n+        inputGate.notifyPriorityEventForce(this);\n+    }\n+\n+    /**\n+     * Returns a list of buffers, checking the first n non-priority buffers, and skipping all\n+     * events.\n+     */\n+    private List<Buffer> getInflightBuffersUnsafe(long checkpointId) {\n+        assert Thread.holdsLock(receivedBuffers);\n+\n+        checkState(checkpointId == lastBarrierId || lastBarrierId == NONE);\n+\n+        final List<Buffer> inflightBuffers = new ArrayList<>();\n+        Iterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n+        // skip all priority events (only buffers are stored anyways)\n+        Iterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n+\n+        while (iterator.hasNext()) {\n+            SequenceBuffer sequenceBuffer = iterator.next();\n+            if (sequenceBuffer.buffer.isBuffer()) {\n+                if (shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+                    inflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return inflightBuffers;\n+    }\n+\n+    private void resetLastBarrier() {\n+        lastBarrierId = NONE;\n+        lastBarrierSequenceNumber = NONE;\n+    }\n+\n+    /**\n+     * @return if given {@param sequenceNumber} should be spilled given {@link\n+     *     #lastBarrierSequenceNumber}. We might not have yet received {@link CheckpointBarrier} and\n+     *     we might need to spill everything. If we have already received it, there is a bit nasty\n+     *     corner case of {@link SequenceBuffer#sequenceNumber} overflowing that needs to be handled\n+     *     as well.\n+     */\n+    private boolean shouldBeSpilled(int sequenceNumber) {\n+        if (lastBarrierSequenceNumber == NONE) {\n+            return true;\n+        }\n+        checkState(\n+                receivedBuffers.size() < Integer.MAX_VALUE / 2,\n+                \"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+        boolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastBarrierSequenceNumber;\n+        boolean possibleOverflowBeforeOvertaking =\n+                lastBarrierSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+        if (possibleOverflowAfterOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber && sequenceNumber > 0;\n+        } else if (possibleOverflowBeforeOvertaking) {\n+            return sequenceNumber < lastBarrierSequenceNumber || sequenceNumber > 0;\n+        } else {\n+            return sequenceNumber < lastBarrierSequenceNumber;\n+        }\n+    }\n+\n+    public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {\n+        boolean success = false;\n+\n+        synchronized (receivedBuffers) {\n+            if (!isReleased.get()) {\n+                if (expectedSequenceNumber == sequenceNumber) {\n+                    expectedSequenceNumber++;\n+                    success = true;\n+                } else {\n+                    onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));\n+                }\n+            }\n+        }\n+\n+        if (success && backlog >= 0) {\n+            onSenderBacklog(backlog);\n+        }\n+    }\n+\n+    public void onFailedPartitionRequest() {\n+        inputGate.triggerPartitionStateCheck(partitionId);\n+    }\n+\n+    public void onError(Throwable cause) {\n+        setError(cause);\n+    }\n+\n+    private void checkPartitionRequestQueueInitialized() throws IOException {\n+        checkError();\n+        checkState(\n+                partitionRequestClient != null,\n+                \"Bug: partitionRequestClient is not initialized before processing data and no error is detected.\");\n+    }\n+\n+    private static class BufferReorderingException extends IOException {\n+\n+        private static final long serialVersionUID = -888282210356266816L;\n+\n+        private final int expectedSequenceNumber;\n+\n+        private final int actualSequenceNumber;\n+\n+        BufferReorderingException(int expectedSequenceNumber, int actualSequenceNumber) {\n+            this.expectedSequenceNumber = expectedSequenceNumber;\n+            this.actualSequenceNumber = actualSequenceNumber;\n+        }\n+\n+        @Override\n+        public String getMessage() {\n+            return String.format(\n+                    \"Buffer re-ordering: expected buffer with sequence number %d, but received %d.\",\n+                    expectedSequenceNumber, actualSequenceNumber);\n+        }\n+    }\n+\n+    private static final class SequenceBuffer {\n+        final Buffer buffer;\n+        final int sequenceNumber;\n+\n+        private SequenceBuffer(Buffer buffer, int sequenceNumber) {\n+            this.buffer = buffer;\n+            this.sequenceNumber = sequenceNumber;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\n+                    \"SequenceBuffer(isEvent = %s, dataType = %s, sequenceNumber = %s)\",\n+                    !buffer.isBuffer(), buffer.getDataType(), sequenceNumber);\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "0ee049db1ffe8a4a68bcd97608774ee488d02a21", "committedDate": "2021-09-03 08:19:32 +0200", "message": "[FLINK-23907] Use primitive functional interfaces"}, {"oid": "138e83e2bc6feb59ecd839b03491cd8f23ee1c66", "committedDate": "2021-11-08 08:56:34 +0100", "message": "[FLINK-24738][runtime] Ignoring buffer size announcement if the channel is released already"}, {"oid": "4eea7bc9352134a06d2b207c9a94dd46a01c6132", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[FLINK-24657][runtime] Added metric of the total real size of input/output buffers queue"}, {"oid": "f4fd4f8bb66867821cb0f171218d85f8386b0897", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] Move consumedSubpartitionIndex from SingleInputGate to InputChannel"}, {"oid": "5c2ec72982128fc1a30014677916e0dd21f9c1d2", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] SingleInputGate supports consuming subpartition range"}, {"oid": "6398abcbff06b3e488a273144680f4838b4f1c92", "committedDate": "2023-06-09 22:48:37 +0800", "message": "[FLINK-31636][network] Introduce the NettyService framework"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkwNjk3Mg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424906972", "body": "unsynchronizedGetAvailableExclusiveBuffers?", "bodyText": "unsynchronizedGetAvailableExclusiveBuffers?", "bodyHTML": "<p dir=\"auto\">unsynchronizedGetAvailableExclusiveBuffers?</p>", "author": "zhijiangW", "createdAt": "2020-05-14T06:49:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -313,7 +313,7 @@ int getNumberOfAvailableBuffers() {\n \t\t}\n \t}\n \n-\tint unsynchronizedGetExclusiveBuffersUsed() {\n+\tint unsynchronizedGetExclusiveBuffers() {", "originalCommit": "2ea543cf392fb1f2d8d7691fa358a93b6765d195", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2cb05ba959c5ac264eb8fa85d711f499301ed767", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex a2c531e35cb..54995d605aa 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -297,23 +312,25 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t// ------------------------------------------------------------------------\n \n \t@VisibleForTesting\n-\tint unsynchronizedGetNumberOfRequiredBuffers() {\n-\t\treturn numRequiredBuffers;\n+\tint getNumberOfRequiredBuffers() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\treturn numRequiredBuffers;\n+\t\t}\n \t}\n \n-\t@VisibleForTesting\n-\tboolean unsynchronizedIsWaitingForFloatingBuffers() {\n-\t\treturn isWaitingForFloatingBuffers;\n+\tboolean isWaitingForFloatingBuffers() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\treturn isWaitingForFloatingBuffers;\n+\t\t}\n \t}\n \n-\t@VisibleForTesting\n \tint getNumberOfAvailableBuffers() {\n \t\tsynchronized (bufferQueue) {\n \t\t\treturn bufferQueue.getAvailableBufferSize();\n \t\t}\n \t}\n \n-\tint unsynchronizedGetExclusiveBuffers() {\n+\tint unsynchronizedGetAvailableExclusiveBuffers() {\n \t\treturn bufferQueue.exclusiveBuffers.size();\n \t}\n \n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 54995d605aa..ba6e75d3a43 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -41,391 +41,402 @@ import java.util.List;\n \n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += numRequired;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers(boolean isTemporaryRelease) {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tint numReleasedBuffers = bufferQueue.releaseFloatingBuffers();\n-\t\t\tif (isTemporaryRelease) {\n-\t\t\t\tnumRequiredBuffers += numReleasedBuffers;\n-\t\t\t} else {\n-\t\t\t\tnumRequiredBuffers = 0;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint getNumberOfRequiredBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn numRequiredBuffers;\n-\t\t}\n-\t}\n-\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn isWaitingForFloatingBuffers;\n-\t\t}\n-\t}\n-\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetAvailableExclusiveBuffers() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer(int initialCredit) {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            if (initialCredit == 0) {\n+                checkState(\n+                        bufferQueue.getAvailableBufferSize() <= numRequiredBuffers,\n+                        \"Too many buffers allocated.\");\n+                --numRequiredBuffers;\n+            }\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        if (numExclusiveBuffers <= 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        int numAddedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                } else {\n+                    numAddedBuffers =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        try {\n+            inputChannel.notifyBufferAvailable(numAddedBuffers);\n+        } catch (Throwable t) {\n+            ExceptionUtils.rethrow(t);\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            bufferQueue.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            if (buffer.getRecycler() == this) {\n+                exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+            } else {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+        synchronized (bufferQueue) {\n+            bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+            bufferQueue.notifyAll();\n+        }\n+\n+        if (exclusiveRecyclingSegments.size() > 0) {\n+            globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n+         * number of available buffers in queue is more than the required amount.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return How many buffers were added to the queue\n+         */\n+        int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                Buffer floatingBuffer = floatingBuffers.poll();\n+                if (floatingBuffer != null) {\n+                    floatingBuffer.recycleBuffer();\n+                    return 0;\n+                }\n+            }\n+            return 1;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": {"commit": "8550965d808fe7b4d6ff2d48034612878937a579", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex ba6e75d3a43..8031f6b5d3c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -428,11 +448,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..82162f51ae3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,10 +448,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        Queue<Buffer> clearFloatingBuffers() {\n-            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n-            floatingBuffers.clear();\n-            return buffers;\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 82162f51ae3..0867fbba828 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -448,11 +458,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        void releaseFloatingBuffers() {\n-            Buffer buffer;\n-            while ((buffer = floatingBuffers.poll()) != null) {\n-                buffer.recycleBuffer();\n-            }\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n         }\n \n         int getAvailableBufferSize() {\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex a2c531e35cb..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -38,375 +38,435 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Queue;\n \n+import static org.apache.flink.util.ExceptionUtils.firstOrSuppressed;\n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of required buffers for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers = 1;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n-\t */\n-\tint requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t\treturn segments.size();\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers = numRequired;\n-\n-\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n-\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\t\tnumRequestedBuffers++;\n-\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tnumRequiredBuffers = 0;\n-\t\t\tbufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tcheckState(isWaitingForFloatingBuffers, \"This channel should be waiting for floating buffers.\");\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (notificationResult != NotificationResult.BUFFER_NOT_USED) {\n-\t\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint unsynchronizedGetNumberOfRequiredBuffers() {\n-\t\treturn numRequiredBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean unsynchronizedIsWaitingForFloatingBuffers() {\n-\t\treturn isWaitingForFloatingBuffers;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffers() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (getAvailableBufferSize() > numRequiredBuffers) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tvoid releaseFloatingBuffers() {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer() {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            --numRequiredBuffers;\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        checkArgument(numExclusiveBuffers >= 0, \"Num exclusive buffers must be non-negative.\");\n+        if (numExclusiveBuffers == 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            // AvailableBufferQueue::addExclusiveBuffer may release the previously allocated\n+            // floating buffer, which requires the caller to recycle these released floating\n+            // buffers. There should be no floating buffers that have been allocated before the\n+            // exclusive buffers are initialized, so here only a simple assertion is required\n+            checkState(\n+                    unsynchronizedGetFloatingBuffersAvailable() == 0,\n+                    \"Bug in buffer allocation logic: floating buffer is allocated before exclusive buffers are initialized.\");\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        @Nullable Buffer releasedFloatingBuffer = null;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                    return;\n+                } else {\n+                    releasedFloatingBuffer =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        if (releasedFloatingBuffer != null) {\n+            releasedFloatingBuffer.recycleBuffer();\n+        } else {\n+            try {\n+                inputChannel.notifyBufferAvailable(1);\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            }\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        Queue<Buffer> buffers;\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            buffers = bufferQueue.clearFloatingBuffers();\n+        }\n+\n+        // recycle all buffers out of the synchronization block to avoid dead lock\n+        while (!buffers.isEmpty()) {\n+            buffers.poll().recycleBuffer();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Exception err = null;\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            try {\n+                if (buffer.getRecycler() == BufferManager.this) {\n+                    exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+                } else {\n+                    buffer.recycleBuffer();\n+                }\n+            } catch (Exception e) {\n+                err = firstOrSuppressed(e, err);\n+            }\n+        }\n+        try {\n+            synchronized (bufferQueue) {\n+                bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+                bufferQueue.notifyAll();\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        try {\n+            if (exclusiveRecyclingSegments.size() > 0) {\n+                globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+            }\n+        } catch (Exception e) {\n+            err = firstOrSuppressed(e, err);\n+        }\n+        if (err != null) {\n+            throw err instanceof IOException ? (IOException) err : new IOException(err);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and releases one floating buffer if the\n+         * number of available buffers in queue is more than the required amount. If floating buffer\n+         * is released, the total amount of available buffers after adding this exclusive buffer has\n+         * not changed, and no new buffers are available. The caller is responsible for recycling\n+         * the release/returned floating buffer.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return An released floating buffer, may be null if the numRequiredBuffers is not met.\n+         */\n+        @Nullable\n+        Buffer addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                return floatingBuffers.poll();\n+            }\n+            return null;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        Queue<Buffer> clearFloatingBuffers() {\n+            Queue<Buffer> buffers = new ArrayDeque<>(floatingBuffers);\n+            floatingBuffers.clear();\n+            return buffers;\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "48a384dffc770289a38df816a38bd336ea992ed7", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[FLINK-23466][network] Fix the bug that buffer listeners may not be notified when recycling buffers"}, {"oid": "c91837edb782c67eab799a569077053695a29fc3", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[hotfix][refactor] Remove BufferListener#NotificationResult to simplify the code"}, {"oid": "38f7c593538d78e67ed75f006826b9fc3e97826e", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[hotfix] Rename some methods of NetworkBufferPool and add more comments for better readability"}]}, {"oid": "2cb05ba959c5ac264eb8fa85d711f499301ed767", "url": "https://github.com/apache/flink/commit/2cb05ba959c5ac264eb8fa85d711f499301ed767", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T09:43:23Z", "type": "forcePushed"}, {"oid": "a933d700d53457d7743252c2a3c735a04fbd87f8", "url": "https://github.com/apache/flink/commit/a933d700d53457d7743252c2a3c735a04fbd87f8", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T09:47:15Z", "type": "forcePushed"}, {"oid": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "url": "https://github.com/apache/flink/commit/ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T09:52:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MjA4NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425072084", "body": "remove `moreAvailable` argument from the constructor, because it seems strange for `AddBacklogMessage`, then we can give false in below `super` instead.", "bodyText": "remove moreAvailable argument from the constructor, because it seems strange for AddBacklogMessage, then we can give false in below super instead.", "bodyHTML": "<p dir=\"auto\">remove <code>moreAvailable</code> argument from the constructor, because it seems strange for <code>AddBacklogMessage</code>, then we can give false in below <code>super</code> instead.</p>", "author": "zhijiangW", "createdAt": "2020-05-14T11:41:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -328,4 +325,67 @@ public void operationComplete(ChannelFuture future) throws Exception {\n \t\t\t}\n \t\t}\n \t}\n+\n+\t/**\n+\t * Outbound message to be sent to the client.\n+\t */\n+\tpublic static abstract class ServerOutboundMessage {\n+\t\tprotected final InputChannelID receiverId;\n+\t\tprotected final int backlog;\n+\t\tprivate final boolean moreAvailable;\n+\n+\t\tServerOutboundMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n+\t\t\tcheckArgument(backlog >= 0, \"Number of backlog must be non-negative.\");\n+\t\t\tthis.receiverId = checkNotNull(receiverId);\n+\t\t\tthis.backlog = backlog;\n+\t\t\tthis.moreAvailable = moreAvailable;\n+\t\t}\n+\n+\t\tabstract Object build();\n+\n+\t\tpublic boolean isMoreAvailable() {\n+\t\t\treturn moreAvailable;\n+\t\t}\n+\n+\t\tvoid recycleBufferIfNeeded() {\n+\t\t}\n+\t}\n+\n+\tstatic class BufferResponseMessage extends ServerOutboundMessage {\n+\t\tprivate final Buffer buffer;\n+\t\tprivate final int sequenceNumber;\n+\n+\t\tBufferResponseMessage(\n+\t\t\t\tBuffer buffer,\n+\t\t\t\tInputChannelID receiverId,\n+\t\t\t\tint sequenceNumber,\n+\t\t\t\tint backlog,\n+\t\t\t\tboolean moreAvailable) {\n+\t\t\tsuper(receiverId, backlog, moreAvailable);\n+\t\t\tthis.buffer = checkNotNull(buffer);\n+\t\t\tthis.sequenceNumber = sequenceNumber;\n+\t\t}\n+\n+\t\t@Override\n+\t\tObject build() {\n+\t\t\treturn new BufferResponse(buffer, sequenceNumber, receiverId, backlog);\n+\t\t}\n+\n+\t\t@Override\n+\t\tvoid recycleBufferIfNeeded() {\n+\t\t\tbuffer.recycleBuffer();\n+\t\t}\n+\t}\n+\n+\tstatic class AddBacklogMessage extends ServerOutboundMessage {\n+\n+\t\tAddBacklogMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb4c607a5c4780729143d458b1c7633adcba59bf", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 70ec735057f..65a7c1d5595 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -379,8 +379,8 @@ public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n \n \tstatic class AddBacklogMessage extends ServerOutboundMessage {\n \n-\t\tAddBacklogMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n+\t\tAddBacklogMessage(InputChannelID receiverId, int backlog) {\n+\t\t\tsuper(receiverId, backlog, false);\n \t\t}\n \n \t\t@Override\n", "next_change": {"commit": "a51d7760c34c0652321427daa153070874c54a61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 65a7c1d5595..a34ba438049 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -325,67 +320,4 @@ public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n \t\t\t}\n \t\t}\n \t}\n-\n-\t/**\n-\t * Outbound message to be sent to the client.\n-\t */\n-\tpublic static abstract class ServerOutboundMessage {\n-\t\tprotected final InputChannelID receiverId;\n-\t\tprotected final int backlog;\n-\t\tprivate final boolean moreAvailable;\n-\n-\t\tServerOutboundMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tcheckArgument(backlog >= 0, \"Number of backlog must be non-negative.\");\n-\t\t\tthis.receiverId = checkNotNull(receiverId);\n-\t\t\tthis.backlog = backlog;\n-\t\t\tthis.moreAvailable = moreAvailable;\n-\t\t}\n-\n-\t\tabstract Object build();\n-\n-\t\tpublic boolean isMoreAvailable() {\n-\t\t\treturn moreAvailable;\n-\t\t}\n-\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t}\n-\t}\n-\n-\tstatic class BufferResponseMessage extends ServerOutboundMessage {\n-\t\tprivate final Buffer buffer;\n-\t\tprivate final int sequenceNumber;\n-\n-\t\tBufferResponseMessage(\n-\t\t\t\tBuffer buffer,\n-\t\t\t\tInputChannelID receiverId,\n-\t\t\t\tint sequenceNumber,\n-\t\t\t\tint backlog,\n-\t\t\t\tboolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n-\t\t\tthis.buffer = checkNotNull(buffer);\n-\t\t\tthis.sequenceNumber = sequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new BufferResponse(buffer, sequenceNumber, receiverId, backlog);\n-\t\t}\n-\n-\t\t@Override\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t\tbuffer.recycleBuffer();\n-\t\t}\n-\t}\n-\n-\tstatic class AddBacklogMessage extends ServerOutboundMessage {\n-\n-\t\tAddBacklogMessage(InputChannelID receiverId, int backlog) {\n-\t\t\tsuper(receiverId, backlog, false);\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new AddBacklog(backlog, receiverId);\n-\t\t}\n-\t}\n }\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex a34ba438049..df17ef3877c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -41,283 +41,321 @@ import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n+\n+import static org.apache.flink.runtime.io.network.netty.NettyMessage.BufferResponse;\n \n /**\n- * A nonEmptyReader of partition queues, which listens for channel writability changed\n- * events before writing and flushing {@link Buffer} instances.\n+ * A nonEmptyReader of partition queues, which listens for channel writability changed events before\n+ * writing and flushing {@link Buffer} instances.\n  */\n-public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n-\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n-\n-\tprivate final ChannelFutureListener writeListener = new WriteAndFlushNextMessageIfPossibleListener();\n-\n-\t/** The readers which are already enqueued available for transferring data or announcing backlog. */\n-\tprivate final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n-\n-\t/** All the readers created for the consumers' partition requests. */\n-\tprivate final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders = new ConcurrentHashMap<>();\n-\n-\tprivate boolean fatalError;\n-\n-\tprivate ChannelHandlerContext ctx;\n-\n-\t@Override\n-\tpublic void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n-\t\tif (this.ctx == null) {\n-\t\t\tthis.ctx = ctx;\n-\t\t}\n-\n-\t\tsuper.channelRegistered(ctx);\n-\t}\n-\n-\tvoid notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n-\t\t// The notification might come from the same thread. For the initial writes this\n-\t\t// might happen before the reader has set its reference to the view, because\n-\t\t// creating the queue and the initial notification happen in the same method call.\n-\t\t// This can be resolved by separating the creation of the view and allowing\n-\t\t// notifications.\n-\n-\t\t// TODO This could potentially have a bad performance impact as in the\n-\t\t// worst case (network consumes faster than the producer) each buffer\n-\t\t// will trigger a separate event loop task being scheduled.\n-\t\tctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n-\t}\n-\n-\t/**\n-\t * Try to enqueue the reader once receiving credit or resume consumption notification from\n-\t * the consumer or receiving non-empty reader notification from the producer.\n-\t *\n-\t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n-\t * availability, so there is no race condition here.\n-\t */\n-\tvoid enqueueAvailableReader(final NetworkSequenceViewReader reader, BooleanSupplier condition) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || !condition.getAsBoolean()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Queue an available reader for consumption. If the queue is empty,\n-\t\t// we try trigger the actual write. Otherwise this will be handled by\n-\t\t// the writeAndFlushNextMessageIfPossible calls.\n-\t\tboolean triggerWrite = availableReaders.isEmpty();\n-\t\tregisterAvailableReader(reader);\n-\n-\t\tif (triggerWrite) {\n-\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Accesses internal state to verify reader registration in the unit tests.\n-\t *\n-\t * <p><strong>Do not use anywhere else!</strong>\n-\t *\n-\t * @return readers which are enqueued available for transferring data or announcing backlog\n-\t */\n-\t@VisibleForTesting\n-\tArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n-\t\treturn availableReaders;\n-\t}\n-\n-\tpublic void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n-\t\tallReaders.put(reader.getReceiverId(), reader);\n-\t}\n-\n-\tpublic void cancel(InputChannelID receiverId) {\n-\t\tctx.pipeline().fireUserEventTriggered(receiverId);\n-\t}\n-\n-\tpublic void close() throws IOException {\n-\t\tif (ctx != null) {\n-\t\t\tctx.channel().close();\n-\t\t}\n-\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\t\tallReaders.clear();\n-\t}\n-\n-\t/**\n-\t * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n-\t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n-\t *\n-\t * @param receiverId The input channel id to identify the consumer.\n-\t * @param operation The operation to be performed (add credit or resume data consumption).\n-\t */\n-\tvoid addCreditOrResumeConsumption(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tFutureConsumerWithException<NetworkSequenceViewReader, Exception> operation) throws Exception {\n-\t\tif (fatalError) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n-\t\tif (reader != null) {\n-\t\t\toperation.acceptWithException(reader);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"No reader for receiverId = \" + receiverId + \" exists.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\t// The user event triggered event loop callback is used for thread-safe\n-\t\t// hand over of reader queues and cancelled producers.\n-\n-\t\tif (msg instanceof NetworkSequenceViewReader) {\n-\t\t\tNetworkSequenceViewReader reader = (NetworkSequenceViewReader) msg;\n-\t\t\tenqueueAvailableReader(reader, () -> (reader.isAvailable() || reader.shouldAnnounceBacklog(false)));\n-\t\t} else if (msg.getClass() == InputChannelID.class) {\n-\t\t\t// Release partition view that get a cancel request.\n-\t\t\tInputChannelID toCancel = (InputChannelID) msg;\n-\n-\t\t\t// remove reader from queue of available readers\n-\t\t\tavailableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n-\n-\t\t\t// remove reader from queue of all readers and release its resource\n-\t\t\tfinal NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n-\t\t\tif (toRelease != null) {\n-\t\t\t\treleaseViewReader(toRelease);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tctx.fireUserEventTriggered(msg);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t}\n-\n-\tprivate void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n-\t\tif (fatalError || !channel.isWritable()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// The logic here is very similar to the combined input gate and local\n-\t\t// input channel logic. You can think of this class acting as the input\n-\t\t// gate and the consumed views as the local input channels.\n-\n-\t\tServerOutboundMessage next = null;\n-\t\ttry {\n-\t\t\twhile (true) {\n-\t\t\t\tNetworkSequenceViewReader reader = pollAvailableReader();\n-\n-\t\t\t\t// No queue with available data. We allow this here, because\n-\t\t\t\t// of the write callbacks that are executed after each write.\n-\t\t\t\tif (reader == null) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\tnext = reader.getNextMessage();\n-\t\t\t\tif (next == null) {\n-\t\t\t\t\tif (!reader.isReleased()) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tThrowable cause = reader.getFailureCause();\n-\t\t\t\t\tif (cause != null) {\n-\t\t\t\t\t\tErrorResponse msg = new ErrorResponse(\n-\t\t\t\t\t\t\tnew ProducerFailedException(cause),\n-\t\t\t\t\t\t\treader.getReceiverId());\n-\n-\t\t\t\t\t\tctx.writeAndFlush(msg);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// This channel was now removed from the available reader queue.\n-\t\t\t\t\t// We re-add it into the queue if it is still available\n-\t\t\t\t\tif (next.isMoreAvailable()) {\n-\t\t\t\t\t\tregisterAvailableReader(reader);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Write and flush and wait until this is done before\n-\t\t\t\t\t// trying to continue with the next buffer.\n-\t\t\t\t\tchannel.writeAndFlush(next.build()).addListener(writeListener);\n-\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tif (next != null) {\n-\t\t\t\tnext.recycle();\n-\t\t\t}\n-\n-\t\t\tthrow new IOException(t.getMessage(), t);\n-\t\t}\n-\t}\n-\n-\tprivate void registerAvailableReader(NetworkSequenceViewReader reader) {\n-\t\tavailableReaders.add(reader);\n-\t\treader.setRegisteredAsAvailable(true);\n-\t}\n-\n-\t@Nullable\n-\tprivate NetworkSequenceViewReader pollAvailableReader() {\n-\t\tNetworkSequenceViewReader reader = availableReaders.poll();\n-\t\tif (reader != null) {\n-\t\t\treader.setRegisteredAsAvailable(false);\n-\t\t}\n-\t\treturn reader;\n-\t}\n-\n-\t@Override\n-\tpublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-\t\treleaseAllResources();\n-\n-\t\tctx.fireChannelInactive();\n-\t}\n-\n-\t@Override\n-\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-\t\thandleException(ctx.channel(), cause);\n-\t}\n-\n-\tprivate void handleException(Channel channel, Throwable cause) throws IOException {\n-\t\tLOG.error(\"Encountered error while consuming partitions\", cause);\n-\n-\t\tfatalError = true;\n-\t\treleaseAllResources();\n-\n-\t\tif (channel.isActive()) {\n-\t\t\tchannel.writeAndFlush(new ErrorResponse(cause)).addListener(ChannelFutureListener.CLOSE);\n-\t\t}\n-\t}\n-\n-\tprivate void releaseAllResources() throws IOException {\n-\t\t// note: this is only ever executed by one thread: the Netty IO thread!\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\n-\t\tavailableReaders.clear();\n-\t\tallReaders.clear();\n-\t}\n-\n-\tprivate void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n-\t\treader.setRegisteredAsAvailable(false);\n-\t\treader.releaseAllResources();\n-\t}\n-\n-\t// This listener is called after an element of the current nonEmptyReader has been\n-\t// flushed. If successful, the listener triggers further processing of the\n-\t// queues.\n-\tprivate class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n-\n-\t\t@Override\n-\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n-\t\t\ttry {\n-\t\t\t\tif (future.isSuccess()) {\n-\t\t\t\t\twriteAndFlushNextMessageIfPossible(future.channel());\n-\t\t\t\t} else if (future.cause() != null) {\n-\t\t\t\t\thandleException(future.channel(), future.cause());\n-\t\t\t\t} else {\n-\t\t\t\t\thandleException(future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\thandleException(future.channel(), t);\n-\t\t\t}\n-\t\t}\n-\t}\n+class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n+\n+    private final ChannelFutureListener writeListener =\n+            new WriteAndFlushNextMessageIfPossibleListener();\n+\n+    /** The readers which are already enqueued available for transferring data. */\n+    private final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n+\n+    /** All the readers created for the consumers' partition requests. */\n+    private final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders =\n+            new ConcurrentHashMap<>();\n+\n+    private boolean fatalError;\n+\n+    private ChannelHandlerContext ctx;\n+\n+    @Override\n+    public void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n+        if (this.ctx == null) {\n+            this.ctx = ctx;\n+        }\n+\n+        super.channelRegistered(ctx);\n+    }\n+\n+    void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n+        // The notification might come from the same thread. For the initial writes this\n+        // might happen before the reader has set its reference to the view, because\n+        // creating the queue and the initial notification happen in the same method call.\n+        // This can be resolved by separating the creation of the view and allowing\n+        // notifications.\n+\n+        // TODO This could potentially have a bad performance impact as in the\n+        // worst case (network consumes faster than the producer) each buffer\n+        // will trigger a separate event loop task being scheduled.\n+        ctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n+    }\n+\n+    /**\n+     * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n+     * non-empty reader notification from the producer.\n+     *\n+     * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n+     * availability, so there is no race condition here.\n+     */\n+    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n+        announceBacklogIfNeeded(reader, reader.getRemainingBacklog());\n+        if (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {\n+            return;\n+        }\n+        // Queue an available reader for consumption. If the queue is empty,\n+        // we try trigger the actual write. Otherwise this will be handled by\n+        // the writeAndFlushNextMessageIfPossible calls.\n+        boolean triggerWrite = availableReaders.isEmpty();\n+        registerAvailableReader(reader);\n+\n+        if (triggerWrite) {\n+            writeAndFlushNextMessageIfPossible(ctx.channel());\n+        }\n+    }\n+\n+    /**\n+     * Accesses internal state to verify reader registration in the unit tests.\n+     *\n+     * <p><strong>Do not use anywhere else!</strong>\n+     *\n+     * @return readers which are enqueued available for transferring data\n+     */\n+    @VisibleForTesting\n+    ArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n+        return availableReaders;\n+    }\n+\n+    public void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n+        allReaders.put(reader.getReceiverId(), reader);\n+    }\n+\n+    public void cancel(InputChannelID receiverId) {\n+        ctx.pipeline().fireUserEventTriggered(receiverId);\n+    }\n+\n+    public void close() throws IOException {\n+        if (ctx != null) {\n+            ctx.channel().close();\n+        }\n+\n+        releaseAllResources();\n+    }\n+\n+    /**\n+     * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n+     * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n+     *\n+     * @param receiverId The input channel id to identify the consumer.\n+     * @param operation The operation to be performed (add credit or resume data consumption).\n+     */\n+    void addCreditOrResumeConsumption(\n+            InputChannelID receiverId, Consumer<NetworkSequenceViewReader> operation)\n+            throws Exception {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            operation.accept(reader);\n+\n+            enqueueAvailableReader(reader);\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    /**\n+     * Announces remaining backlog to the consumer after the available data notification or data\n+     * consumption resumption.\n+     */\n+    private void announceBacklogIfNeeded(NetworkSequenceViewReader reader, int backlog) {\n+        if (backlog > 0 && reader.needAnnounceBacklog()) {\n+            NettyMessage.BacklogAnnouncement announcement =\n+                    new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n+            ctx.channel()\n+                    .writeAndFlush(announcement)\n+                    .addListener(\n+                            (ChannelFutureListener)\n+                                    future -> {\n+                                        if (!future.isSuccess()) {\n+                                            onChannelFutureFailure(future);\n+                                        }\n+                                    });\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        // The user event triggered event loop callback is used for thread-safe\n+        // hand over of reader queues and cancelled producers.\n+\n+        if (msg instanceof NetworkSequenceViewReader) {\n+            enqueueAvailableReader((NetworkSequenceViewReader) msg);\n+        } else if (msg.getClass() == InputChannelID.class) {\n+            // Release partition view that get a cancel request.\n+            InputChannelID toCancel = (InputChannelID) msg;\n+\n+            // remove reader from queue of available readers\n+            availableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n+\n+            // remove reader from queue of all readers and release its resource\n+            final NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n+            if (toRelease != null) {\n+                releaseViewReader(toRelease);\n+            }\n+        } else {\n+            ctx.fireUserEventTriggered(msg);\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        writeAndFlushNextMessageIfPossible(ctx.channel());\n+    }\n+\n+    private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n+        if (fatalError || !channel.isWritable()) {\n+            return;\n+        }\n+\n+        // The logic here is very similar to the combined input gate and local\n+        // input channel logic. You can think of this class acting as the input\n+        // gate and the consumed views as the local input channels.\n+\n+        BufferAndAvailability next = null;\n+        try {\n+            while (true) {\n+                NetworkSequenceViewReader reader = pollAvailableReader();\n+\n+                // No queue with available data. We allow this here, because\n+                // of the write callbacks that are executed after each write.\n+                if (reader == null) {\n+                    return;\n+                }\n+\n+                next = reader.getNextBuffer();\n+                if (next == null) {\n+                    if (!reader.isReleased()) {\n+                        continue;\n+                    }\n+\n+                    Throwable cause = reader.getFailureCause();\n+                    if (cause != null) {\n+                        ErrorResponse msg =\n+                                new ErrorResponse(\n+                                        new ProducerFailedException(cause), reader.getReceiverId());\n+\n+                        ctx.writeAndFlush(msg);\n+                    }\n+                } else {\n+                    // This channel was now removed from the available reader queue.\n+                    // We re-add it into the queue if it is still available\n+                    if (next.moreAvailable()) {\n+                        registerAvailableReader(reader);\n+                    }\n+\n+                    BufferResponse msg =\n+                            new BufferResponse(\n+                                    next.buffer(),\n+                                    next.getSequenceNumber(),\n+                                    reader.getReceiverId(),\n+                                    next.buffersInBacklog());\n+\n+                    // Write and flush and wait until this is done before\n+                    // trying to continue with the next buffer.\n+                    channel.writeAndFlush(msg).addListener(writeListener);\n+\n+                    return;\n+                }\n+            }\n+        } catch (Throwable t) {\n+            if (next != null) {\n+                next.buffer().recycleBuffer();\n+            }\n+\n+            throw new IOException(t.getMessage(), t);\n+        }\n+    }\n+\n+    private void registerAvailableReader(NetworkSequenceViewReader reader) {\n+        availableReaders.add(reader);\n+        reader.setRegisteredAsAvailable(true);\n+    }\n+\n+    @Nullable\n+    private NetworkSequenceViewReader pollAvailableReader() {\n+        NetworkSequenceViewReader reader = availableReaders.poll();\n+        if (reader != null) {\n+            reader.setRegisteredAsAvailable(false);\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        releaseAllResources();\n+\n+        ctx.fireChannelInactive();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        handleException(ctx.channel(), cause);\n+    }\n+\n+    private void handleException(Channel channel, Throwable cause) throws IOException {\n+        LOG.error(\"Encountered error while consuming partitions\", cause);\n+\n+        fatalError = true;\n+        releaseAllResources();\n+\n+        if (channel.isActive()) {\n+            channel.writeAndFlush(new ErrorResponse(cause))\n+                    .addListener(ChannelFutureListener.CLOSE);\n+        }\n+    }\n+\n+    private void releaseAllResources() throws IOException {\n+        // note: this is only ever executed by one thread: the Netty IO thread!\n+        for (NetworkSequenceViewReader reader : allReaders.values()) {\n+            releaseViewReader(reader);\n+        }\n+\n+        availableReaders.clear();\n+        allReaders.clear();\n+    }\n+\n+    private void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n+        reader.setRegisteredAsAvailable(false);\n+        reader.releaseAllResources();\n+    }\n+\n+    private void onChannelFutureFailure(ChannelFuture future) throws Exception {\n+        if (future.cause() != null) {\n+            handleException(future.channel(), future.cause());\n+        } else {\n+            handleException(\n+                    future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n+        }\n+    }\n+\n+    // This listener is called after an element of the current nonEmptyReader has been\n+    // flushed. If successful, the listener triggers further processing of the\n+    // queues.\n+    private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            try {\n+                if (future.isSuccess()) {\n+                    writeAndFlushNextMessageIfPossible(future.channel());\n+                } else {\n+                    onChannelFutureFailure(future);\n+                }\n+            } catch (Throwable t) {\n+                handleException(future.channel(), t);\n+            }\n+        }\n+    }\n }\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex df17ef3877c..0e3b6ddc57c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -350,8 +334,12 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n             try {\n                 if (future.isSuccess()) {\n                     writeAndFlushNextMessageIfPossible(future.channel());\n+                } else if (future.cause() != null) {\n+                    handleException(future.channel(), future.cause());\n                 } else {\n-                    onChannelFutureFailure(future);\n+                    handleException(\n+                            future.channel(),\n+                            new IllegalStateException(\"Sending cancelled by user.\"));\n                 }\n             } catch (Throwable t) {\n                 handleException(future.channel(), t);\n", "next_change": {"commit": "639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 0e3b6ddc57c..72ede48bda2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -334,12 +376,8 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n             try {\n                 if (future.isSuccess()) {\n                     writeAndFlushNextMessageIfPossible(future.channel());\n-                } else if (future.cause() != null) {\n-                    handleException(future.channel(), future.cause());\n                 } else {\n-                    handleException(\n-                            future.channel(),\n-                            new IllegalStateException(\"Sending cancelled by user.\"));\n+                    onChannelFutureFailure(future);\n                 }\n             } catch (Throwable t) {\n                 handleException(future.channel(), t);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 70ec735057f..72ede48bda2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -42,350 +42,346 @@ import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n \n import static org.apache.flink.runtime.io.network.netty.NettyMessage.BufferResponse;\n import static org.apache.flink.util.Preconditions.checkArgument;\n-import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n- * A nonEmptyReader of partition queues, which listens for channel writability changed\n- * events before writing and flushing {@link Buffer} instances.\n+ * A nonEmptyReader of partition queues, which listens for channel writability changed events before\n+ * writing and flushing {@link Buffer} instances.\n  */\n-public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n-\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n-\n-\tprivate final ChannelFutureListener writeListener = new WriteAndFlushNextMessageIfPossibleListener();\n-\n-\t/** The readers which are already enqueued available for transferring data or announcing backlog. */\n-\tprivate final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n-\n-\t/** All the readers created for the consumers' partition requests. */\n-\tprivate final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders = new ConcurrentHashMap<>();\n-\n-\tprivate boolean fatalError;\n-\n-\tprivate ChannelHandlerContext ctx;\n-\n-\t@Override\n-\tpublic void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n-\t\tif (this.ctx == null) {\n-\t\t\tthis.ctx = ctx;\n-\t\t}\n-\n-\t\tsuper.channelRegistered(ctx);\n-\t}\n-\n-\tvoid notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n-\t\t// The notification might come from the same thread. For the initial writes this\n-\t\t// might happen before the reader has set its reference to the view, because\n-\t\t// creating the queue and the initial notification happen in the same method call.\n-\t\t// This can be resolved by separating the creation of the view and allowing\n-\t\t// notifications.\n-\n-\t\t// TODO This could potentially have a bad performance impact as in the\n-\t\t// worst case (network consumes faster than the producer) each buffer\n-\t\t// will trigger a separate event loop task being scheduled.\n-\t\tctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n-\t}\n-\n-\t/**\n-\t * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n-\t * non-empty reader notification from the producer.\n-\t *\n-\t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n-\t * availability, so there is no race condition here.\n-\t */\n-\tvoid enqueueAvailableReader(final NetworkSequenceViewReader reader, BooleanSupplier condition) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || !condition.getAsBoolean()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Queue an available reader for consumption. If the queue is empty,\n-\t\t// we try trigger the actual write. Otherwise this will be handled by\n-\t\t// the writeAndFlushNextMessageIfPossible calls.\n-\t\tboolean triggerWrite = availableReaders.isEmpty();\n-\t\tregisterAvailableReader(reader);\n-\n-\t\tif (triggerWrite) {\n-\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Accesses internal state to verify reader registration in the unit tests.\n-\t *\n-\t * <p><strong>Do not use anywhere else!</strong>\n-\t *\n-\t * @return readers which are enqueued available for transferring data or announcing backlog\n-\t */\n-\t@VisibleForTesting\n-\tArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n-\t\treturn availableReaders;\n-\t}\n-\n-\tpublic void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n-\t\tallReaders.put(reader.getReceiverId(), reader);\n-\t}\n-\n-\tpublic void cancel(InputChannelID receiverId) {\n-\t\tctx.pipeline().fireUserEventTriggered(receiverId);\n-\t}\n-\n-\tpublic void close() throws IOException {\n-\t\tif (ctx != null) {\n-\t\t\tctx.channel().close();\n-\t\t}\n-\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\t\tallReaders.clear();\n-\t}\n-\n-\t/**\n-\t * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n-\t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n-\t *\n-\t * @param receiverId The input channel id to identify the consumer.\n-\t * @param operation The operation to be performed (add credit or resume data consumption).\n-\t */\n-\tvoid addCreditOrResumeConsumption(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tFutureConsumerWithException<NetworkSequenceViewReader, Exception> operation) throws Exception {\n-\t\tif (fatalError) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n-\t\tif (reader != null) {\n-\t\t\toperation.acceptWithException(reader);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"No reader for receiverId = \" + receiverId + \" exists.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\t// The user event triggered event loop callback is used for thread-safe\n-\t\t// hand over of reader queues and cancelled producers.\n-\n-\t\tif (msg instanceof NetworkSequenceViewReader) {\n-\t\t\tNetworkSequenceViewReader reader = (NetworkSequenceViewReader) msg;\n-\t\t\tenqueueAvailableReader(reader, () -> (reader.isAvailable() || reader.shouldAnnounceBacklog()));\n-\t\t} else if (msg.getClass() == InputChannelID.class) {\n-\t\t\t// Release partition view that get a cancel request.\n-\t\t\tInputChannelID toCancel = (InputChannelID) msg;\n-\n-\t\t\t// remove reader from queue of available readers\n-\t\t\tavailableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n-\n-\t\t\t// remove reader from queue of all readers and release its resource\n-\t\t\tfinal NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n-\t\t\tif (toRelease != null) {\n-\t\t\t\treleaseViewReader(toRelease);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tctx.fireUserEventTriggered(msg);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t}\n-\n-\tprivate void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n-\t\tif (fatalError || !channel.isWritable()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// The logic here is very similar to the combined input gate and local\n-\t\t// input channel logic. You can think of this class acting as the input\n-\t\t// gate and the consumed views as the local input channels.\n-\n-\t\tServerOutboundMessage next = null;\n-\t\ttry {\n-\t\t\twhile (true) {\n-\t\t\t\tNetworkSequenceViewReader reader = pollAvailableReader();\n-\n-\t\t\t\t// No queue with available data. We allow this here, because\n-\t\t\t\t// of the write callbacks that are executed after each write.\n-\t\t\t\tif (reader == null) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\tnext = reader.getNextMessage();\n-\t\t\t\tif (next == null) {\n-\t\t\t\t\tif (!reader.isReleased()) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tThrowable cause = reader.getFailureCause();\n-\t\t\t\t\tif (cause != null) {\n-\t\t\t\t\t\tErrorResponse msg = new ErrorResponse(\n-\t\t\t\t\t\t\tnew ProducerFailedException(cause),\n-\t\t\t\t\t\t\treader.getReceiverId());\n-\n-\t\t\t\t\t\tctx.writeAndFlush(msg);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// This channel was now removed from the available reader queue.\n-\t\t\t\t\t// We re-add it into the queue if it is still available\n-\t\t\t\t\tif (next.isMoreAvailable()) {\n-\t\t\t\t\t\tregisterAvailableReader(reader);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Write and flush and wait until this is done before\n-\t\t\t\t\t// trying to continue with the next buffer.\n-\t\t\t\t\tchannel.writeAndFlush(next.build()).addListener(writeListener);\n-\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tif (next != null) {\n-\t\t\t\tnext.recycleBufferIfNeeded();\n-\t\t\t}\n-\n-\t\t\tthrow new IOException(t.getMessage(), t);\n-\t\t}\n-\t}\n-\n-\tprivate void registerAvailableReader(NetworkSequenceViewReader reader) {\n-\t\tavailableReaders.add(reader);\n-\t\treader.setRegisteredAsAvailable(true);\n-\t}\n-\n-\t@Nullable\n-\tprivate NetworkSequenceViewReader pollAvailableReader() {\n-\t\tNetworkSequenceViewReader reader = availableReaders.poll();\n-\t\tif (reader != null) {\n-\t\t\treader.setRegisteredAsAvailable(false);\n-\t\t}\n-\t\treturn reader;\n-\t}\n-\n-\t@Override\n-\tpublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-\t\treleaseAllResources();\n-\n-\t\tctx.fireChannelInactive();\n-\t}\n-\n-\t@Override\n-\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-\t\thandleException(ctx.channel(), cause);\n-\t}\n-\n-\tprivate void handleException(Channel channel, Throwable cause) throws IOException {\n-\t\tLOG.error(\"Encountered error while consuming partitions\", cause);\n-\n-\t\tfatalError = true;\n-\t\treleaseAllResources();\n-\n-\t\tif (channel.isActive()) {\n-\t\t\tchannel.writeAndFlush(new ErrorResponse(cause)).addListener(ChannelFutureListener.CLOSE);\n-\t\t}\n-\t}\n-\n-\tprivate void releaseAllResources() throws IOException {\n-\t\t// note: this is only ever executed by one thread: the Netty IO thread!\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\n-\t\tavailableReaders.clear();\n-\t\tallReaders.clear();\n-\t}\n-\n-\tprivate void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n-\t\treader.setRegisteredAsAvailable(false);\n-\t\treader.releaseAllResources();\n-\t}\n-\n-\t// This listener is called after an element of the current nonEmptyReader has been\n-\t// flushed. If successful, the listener triggers further processing of the\n-\t// queues.\n-\tprivate class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n-\n-\t\t@Override\n-\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n-\t\t\ttry {\n-\t\t\t\tif (future.isSuccess()) {\n-\t\t\t\t\twriteAndFlushNextMessageIfPossible(future.channel());\n-\t\t\t\t} else if (future.cause() != null) {\n-\t\t\t\t\thandleException(future.channel(), future.cause());\n-\t\t\t\t} else {\n-\t\t\t\t\thandleException(future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\thandleException(future.channel(), t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Outbound message to be sent to the client.\n-\t */\n-\tpublic static abstract class ServerOutboundMessage {\n-\t\tprotected final InputChannelID receiverId;\n-\t\tprotected final int backlog;\n-\t\tprivate final boolean moreAvailable;\n-\n-\t\tServerOutboundMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tcheckArgument(backlog >= 0, \"Number of backlog must be non-negative.\");\n-\t\t\tthis.receiverId = checkNotNull(receiverId);\n-\t\t\tthis.backlog = backlog;\n-\t\t\tthis.moreAvailable = moreAvailable;\n-\t\t}\n-\n-\t\tabstract Object build();\n-\n-\t\tpublic boolean isMoreAvailable() {\n-\t\t\treturn moreAvailable;\n-\t\t}\n-\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t}\n-\t}\n-\n-\tstatic class BufferResponseMessage extends ServerOutboundMessage {\n-\t\tprivate final Buffer buffer;\n-\t\tprivate final int sequenceNumber;\n-\n-\t\tBufferResponseMessage(\n-\t\t\t\tBuffer buffer,\n-\t\t\t\tInputChannelID receiverId,\n-\t\t\t\tint sequenceNumber,\n-\t\t\t\tint backlog,\n-\t\t\t\tboolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n-\t\t\tthis.buffer = checkNotNull(buffer);\n-\t\t\tthis.sequenceNumber = sequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new BufferResponse(buffer, sequenceNumber, receiverId, backlog);\n-\t\t}\n-\n-\t\t@Override\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t\tbuffer.recycleBuffer();\n-\t\t}\n-\t}\n-\n-\tstatic class AddBacklogMessage extends ServerOutboundMessage {\n-\n-\t\tAddBacklogMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new AddBacklog(backlog, receiverId);\n-\t\t}\n-\t}\n+class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n+\n+    private final ChannelFutureListener writeListener =\n+            new WriteAndFlushNextMessageIfPossibleListener();\n+\n+    /** The readers which are already enqueued available for transferring data. */\n+    private final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n+\n+    /** All the readers created for the consumers' partition requests. */\n+    private final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders =\n+            new ConcurrentHashMap<>();\n+\n+    private boolean fatalError;\n+\n+    private ChannelHandlerContext ctx;\n+\n+    @Override\n+    public void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n+        if (this.ctx == null) {\n+            this.ctx = ctx;\n+        }\n+\n+        super.channelRegistered(ctx);\n+    }\n+\n+    void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n+        // The notification might come from the same thread. For the initial writes this\n+        // might happen before the reader has set its reference to the view, because\n+        // creating the queue and the initial notification happen in the same method call.\n+        // This can be resolved by separating the creation of the view and allowing\n+        // notifications.\n+\n+        // TODO This could potentially have a bad performance impact as in the\n+        // worst case (network consumes faster than the producer) each buffer\n+        // will trigger a separate event loop task being scheduled.\n+        ctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n+    }\n+\n+    /**\n+     * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n+     * non-empty reader notification from the producer.\n+     *\n+     * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n+     * availability, so there is no race condition here.\n+     */\n+    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n+        if (reader.isRegisteredAsAvailable()) {\n+            return;\n+        }\n+\n+        ResultSubpartitionView.AvailabilityWithBacklog availabilityWithBacklog =\n+                reader.getAvailabilityAndBacklog();\n+        if (!availabilityWithBacklog.isAvailable()) {\n+            int backlog = availabilityWithBacklog.getBacklog();\n+            if (backlog > 0 && reader.needAnnounceBacklog()) {\n+                announceBacklog(reader, backlog);\n+            }\n+            return;\n+        }\n+\n+        // Queue an available reader for consumption. If the queue is empty,\n+        // we try trigger the actual write. Otherwise this will be handled by\n+        // the writeAndFlushNextMessageIfPossible calls.\n+        boolean triggerWrite = availableReaders.isEmpty();\n+        registerAvailableReader(reader);\n+\n+        if (triggerWrite) {\n+            writeAndFlushNextMessageIfPossible(ctx.channel());\n+        }\n+    }\n+\n+    /**\n+     * Accesses internal state to verify reader registration in the unit tests.\n+     *\n+     * <p><strong>Do not use anywhere else!</strong>\n+     *\n+     * @return readers which are enqueued available for transferring data\n+     */\n+    @VisibleForTesting\n+    ArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n+        return availableReaders;\n+    }\n+\n+    public void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n+        allReaders.put(reader.getReceiverId(), reader);\n+    }\n+\n+    public void cancel(InputChannelID receiverId) {\n+        ctx.pipeline().fireUserEventTriggered(receiverId);\n+    }\n+\n+    public void close() throws IOException {\n+        if (ctx != null) {\n+            ctx.channel().close();\n+        }\n+\n+        releaseAllResources();\n+    }\n+\n+    /**\n+     * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n+     * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n+     *\n+     * @param receiverId The input channel id to identify the consumer.\n+     * @param operation The operation to be performed (add credit or resume data consumption).\n+     */\n+    void addCreditOrResumeConsumption(\n+            InputChannelID receiverId, Consumer<NetworkSequenceViewReader> operation)\n+            throws Exception {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            operation.accept(reader);\n+\n+            enqueueAvailableReader(reader);\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    void acknowledgeAllRecordsProcessed(InputChannelID receiverId) {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            reader.acknowledgeAllRecordsProcessed();\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    /**\n+     * Announces remaining backlog to the consumer after the available data notification or data\n+     * consumption resumption.\n+     */\n+    private void announceBacklog(NetworkSequenceViewReader reader, int backlog) {\n+        checkArgument(backlog > 0, \"Backlog must be positive.\");\n+\n+        NettyMessage.BacklogAnnouncement announcement =\n+                new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n+        ctx.channel()\n+                .writeAndFlush(announcement)\n+                .addListener(\n+                        (ChannelFutureListener)\n+                                future -> {\n+                                    if (!future.isSuccess()) {\n+                                        onChannelFutureFailure(future);\n+                                    }\n+                                });\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        // The user event triggered event loop callback is used for thread-safe\n+        // hand over of reader queues and cancelled producers.\n+\n+        if (msg instanceof NetworkSequenceViewReader) {\n+            enqueueAvailableReader((NetworkSequenceViewReader) msg);\n+        } else if (msg.getClass() == InputChannelID.class) {\n+            // Release partition view that get a cancel request.\n+            InputChannelID toCancel = (InputChannelID) msg;\n+\n+            // remove reader from queue of available readers\n+            availableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n+\n+            // remove reader from queue of all readers and release its resource\n+            final NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n+            if (toRelease != null) {\n+                releaseViewReader(toRelease);\n+            }\n+        } else {\n+            ctx.fireUserEventTriggered(msg);\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        writeAndFlushNextMessageIfPossible(ctx.channel());\n+    }\n+\n+    private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n+        if (fatalError || !channel.isWritable()) {\n+            return;\n+        }\n+\n+        // The logic here is very similar to the combined input gate and local\n+        // input channel logic. You can think of this class acting as the input\n+        // gate and the consumed views as the local input channels.\n+\n+        BufferAndAvailability next = null;\n+        try {\n+            while (true) {\n+                NetworkSequenceViewReader reader = pollAvailableReader();\n+\n+                // No queue with available data. We allow this here, because\n+                // of the write callbacks that are executed after each write.\n+                if (reader == null) {\n+                    return;\n+                }\n+\n+                next = reader.getNextBuffer();\n+                if (next == null) {\n+                    if (!reader.isReleased()) {\n+                        continue;\n+                    }\n+\n+                    Throwable cause = reader.getFailureCause();\n+                    if (cause != null) {\n+                        ErrorResponse msg =\n+                                new ErrorResponse(\n+                                        new ProducerFailedException(cause), reader.getReceiverId());\n+\n+                        ctx.writeAndFlush(msg);\n+                    }\n+                } else {\n+                    // This channel was now removed from the available reader queue.\n+                    // We re-add it into the queue if it is still available\n+                    if (next.moreAvailable()) {\n+                        registerAvailableReader(reader);\n+                    }\n+\n+                    BufferResponse msg =\n+                            new BufferResponse(\n+                                    next.buffer(),\n+                                    next.getSequenceNumber(),\n+                                    reader.getReceiverId(),\n+                                    next.buffersInBacklog());\n+\n+                    // Write and flush and wait until this is done before\n+                    // trying to continue with the next buffer.\n+                    channel.writeAndFlush(msg).addListener(writeListener);\n+\n+                    return;\n+                }\n+            }\n+        } catch (Throwable t) {\n+            if (next != null) {\n+                next.buffer().recycleBuffer();\n+            }\n+\n+            throw new IOException(t.getMessage(), t);\n+        }\n+    }\n+\n+    private void registerAvailableReader(NetworkSequenceViewReader reader) {\n+        availableReaders.add(reader);\n+        reader.setRegisteredAsAvailable(true);\n+    }\n+\n+    @Nullable\n+    private NetworkSequenceViewReader pollAvailableReader() {\n+        NetworkSequenceViewReader reader = availableReaders.poll();\n+        if (reader != null) {\n+            reader.setRegisteredAsAvailable(false);\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        releaseAllResources();\n+\n+        ctx.fireChannelInactive();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        handleException(ctx.channel(), cause);\n+    }\n+\n+    private void handleException(Channel channel, Throwable cause) throws IOException {\n+        LOG.error(\"Encountered error while consuming partitions\", cause);\n+\n+        fatalError = true;\n+        releaseAllResources();\n+\n+        if (channel.isActive()) {\n+            channel.writeAndFlush(new ErrorResponse(cause))\n+                    .addListener(ChannelFutureListener.CLOSE);\n+        }\n+    }\n+\n+    private void releaseAllResources() throws IOException {\n+        // note: this is only ever executed by one thread: the Netty IO thread!\n+        for (NetworkSequenceViewReader reader : allReaders.values()) {\n+            releaseViewReader(reader);\n+        }\n+\n+        availableReaders.clear();\n+        allReaders.clear();\n+    }\n+\n+    private void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n+        reader.setRegisteredAsAvailable(false);\n+        reader.releaseAllResources();\n+    }\n+\n+    private void onChannelFutureFailure(ChannelFuture future) throws Exception {\n+        if (future.cause() != null) {\n+            handleException(future.channel(), future.cause());\n+        } else {\n+            handleException(\n+                    future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n+        }\n+    }\n+\n+    // This listener is called after an element of the current nonEmptyReader has been\n+    // flushed. If successful, the listener triggers further processing of the\n+    // queues.\n+    private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            try {\n+                if (future.isSuccess()) {\n+                    writeAndFlushNextMessageIfPossible(future.channel());\n+                } else {\n+                    onChannelFutureFailure(future);\n+                }\n+            } catch (Throwable t) {\n+                handleException(future.channel(), t);\n+            }\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "7478445aa30cd28b7b6402565ca304c916024475", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[refactor][runtime] Unification of obtaining reader in PartitionRequestQueue"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}, {"oid": "7bacef09622d43c01ca9a749bbcd259d5cd3e0fe", "committedDate": "2021-09-17 20:16:25 +0200", "message": "[FLINK-24233][runtime] Ignore message about new buffer size if the reader doesn't ready yet"}, {"oid": "f957e3fee50e734dd6b2cbf0cbbef00fe810cd32", "committedDate": "2022-01-13 15:07:28 +0100", "message": "[FLINK-25441][network] Wrap failure cuase with ProducerFailedException only for PipelinedSubpartitionView."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MzA2Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425073066", "body": "Adjust the javadoc accordingly", "bodyText": "Adjust the javadoc accordingly", "bodyHTML": "<p dir=\"auto\">Adjust the javadoc accordingly</p>", "author": "zhijiangW", "createdAt": "2020-05-14T11:43:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -94,10 +97,11 @@ void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n \t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n \t * availability, so there is no race condition here.\n \t */\n-\tprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {\n+\tvoid enqueueAvailableReader(final NetworkSequenceViewReader reader, BooleanSupplier condition) throws Exception {", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb4c607a5c4780729143d458b1c7633adcba59bf", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 70ec735057f..65a7c1d5595 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -91,8 +91,8 @@ public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n \t}\n \n \t/**\n-\t * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n-\t * non-empty reader notification from the producer.\n+\t * Try to enqueue the reader once receiving credit or resume consumption notification from\n+\t * the consumer or receiving non-empty reader notification from the producer.\n \t *\n \t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n \t * availability, so there is no race condition here.\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 65a7c1d5595..df17ef3877c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -42,350 +41,321 @@ import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n \n import static org.apache.flink.runtime.io.network.netty.NettyMessage.BufferResponse;\n-import static org.apache.flink.util.Preconditions.checkArgument;\n-import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n- * A nonEmptyReader of partition queues, which listens for channel writability changed\n- * events before writing and flushing {@link Buffer} instances.\n+ * A nonEmptyReader of partition queues, which listens for channel writability changed events before\n+ * writing and flushing {@link Buffer} instances.\n  */\n-public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n-\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n-\n-\tprivate final ChannelFutureListener writeListener = new WriteAndFlushNextMessageIfPossibleListener();\n-\n-\t/** The readers which are already enqueued available for transferring data or announcing backlog. */\n-\tprivate final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n-\n-\t/** All the readers created for the consumers' partition requests. */\n-\tprivate final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders = new ConcurrentHashMap<>();\n-\n-\tprivate boolean fatalError;\n-\n-\tprivate ChannelHandlerContext ctx;\n-\n-\t@Override\n-\tpublic void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n-\t\tif (this.ctx == null) {\n-\t\t\tthis.ctx = ctx;\n-\t\t}\n-\n-\t\tsuper.channelRegistered(ctx);\n-\t}\n-\n-\tvoid notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n-\t\t// The notification might come from the same thread. For the initial writes this\n-\t\t// might happen before the reader has set its reference to the view, because\n-\t\t// creating the queue and the initial notification happen in the same method call.\n-\t\t// This can be resolved by separating the creation of the view and allowing\n-\t\t// notifications.\n-\n-\t\t// TODO This could potentially have a bad performance impact as in the\n-\t\t// worst case (network consumes faster than the producer) each buffer\n-\t\t// will trigger a separate event loop task being scheduled.\n-\t\tctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n-\t}\n-\n-\t/**\n-\t * Try to enqueue the reader once receiving credit or resume consumption notification from\n-\t * the consumer or receiving non-empty reader notification from the producer.\n-\t *\n-\t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n-\t * availability, so there is no race condition here.\n-\t */\n-\tvoid enqueueAvailableReader(final NetworkSequenceViewReader reader, BooleanSupplier condition) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || !condition.getAsBoolean()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Queue an available reader for consumption. If the queue is empty,\n-\t\t// we try trigger the actual write. Otherwise this will be handled by\n-\t\t// the writeAndFlushNextMessageIfPossible calls.\n-\t\tboolean triggerWrite = availableReaders.isEmpty();\n-\t\tregisterAvailableReader(reader);\n-\n-\t\tif (triggerWrite) {\n-\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Accesses internal state to verify reader registration in the unit tests.\n-\t *\n-\t * <p><strong>Do not use anywhere else!</strong>\n-\t *\n-\t * @return readers which are enqueued available for transferring data or announcing backlog\n-\t */\n-\t@VisibleForTesting\n-\tArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n-\t\treturn availableReaders;\n-\t}\n-\n-\tpublic void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n-\t\tallReaders.put(reader.getReceiverId(), reader);\n-\t}\n-\n-\tpublic void cancel(InputChannelID receiverId) {\n-\t\tctx.pipeline().fireUserEventTriggered(receiverId);\n-\t}\n-\n-\tpublic void close() throws IOException {\n-\t\tif (ctx != null) {\n-\t\t\tctx.channel().close();\n-\t\t}\n-\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\t\tallReaders.clear();\n-\t}\n-\n-\t/**\n-\t * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n-\t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n-\t *\n-\t * @param receiverId The input channel id to identify the consumer.\n-\t * @param operation The operation to be performed (add credit or resume data consumption).\n-\t */\n-\tvoid addCreditOrResumeConsumption(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tFutureConsumerWithException<NetworkSequenceViewReader, Exception> operation) throws Exception {\n-\t\tif (fatalError) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n-\t\tif (reader != null) {\n-\t\t\toperation.acceptWithException(reader);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"No reader for receiverId = \" + receiverId + \" exists.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\t// The user event triggered event loop callback is used for thread-safe\n-\t\t// hand over of reader queues and cancelled producers.\n-\n-\t\tif (msg instanceof NetworkSequenceViewReader) {\n-\t\t\tNetworkSequenceViewReader reader = (NetworkSequenceViewReader) msg;\n-\t\t\tenqueueAvailableReader(reader, () -> (reader.isAvailable() || reader.shouldAnnounceBacklog(false)));\n-\t\t} else if (msg.getClass() == InputChannelID.class) {\n-\t\t\t// Release partition view that get a cancel request.\n-\t\t\tInputChannelID toCancel = (InputChannelID) msg;\n-\n-\t\t\t// remove reader from queue of available readers\n-\t\t\tavailableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n-\n-\t\t\t// remove reader from queue of all readers and release its resource\n-\t\t\tfinal NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n-\t\t\tif (toRelease != null) {\n-\t\t\t\treleaseViewReader(toRelease);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tctx.fireUserEventTriggered(msg);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t}\n-\n-\tprivate void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n-\t\tif (fatalError || !channel.isWritable()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// The logic here is very similar to the combined input gate and local\n-\t\t// input channel logic. You can think of this class acting as the input\n-\t\t// gate and the consumed views as the local input channels.\n-\n-\t\tServerOutboundMessage next = null;\n-\t\ttry {\n-\t\t\twhile (true) {\n-\t\t\t\tNetworkSequenceViewReader reader = pollAvailableReader();\n-\n-\t\t\t\t// No queue with available data. We allow this here, because\n-\t\t\t\t// of the write callbacks that are executed after each write.\n-\t\t\t\tif (reader == null) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\tnext = reader.getNextMessage();\n-\t\t\t\tif (next == null) {\n-\t\t\t\t\tif (!reader.isReleased()) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tThrowable cause = reader.getFailureCause();\n-\t\t\t\t\tif (cause != null) {\n-\t\t\t\t\t\tErrorResponse msg = new ErrorResponse(\n-\t\t\t\t\t\t\tnew ProducerFailedException(cause),\n-\t\t\t\t\t\t\treader.getReceiverId());\n-\n-\t\t\t\t\t\tctx.writeAndFlush(msg);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// This channel was now removed from the available reader queue.\n-\t\t\t\t\t// We re-add it into the queue if it is still available\n-\t\t\t\t\tif (next.isMoreAvailable()) {\n-\t\t\t\t\t\tregisterAvailableReader(reader);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Write and flush and wait until this is done before\n-\t\t\t\t\t// trying to continue with the next buffer.\n-\t\t\t\t\tchannel.writeAndFlush(next.build()).addListener(writeListener);\n-\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tif (next != null) {\n-\t\t\t\tnext.recycleBufferIfNeeded();\n-\t\t\t}\n-\n-\t\t\tthrow new IOException(t.getMessage(), t);\n-\t\t}\n-\t}\n-\n-\tprivate void registerAvailableReader(NetworkSequenceViewReader reader) {\n-\t\tavailableReaders.add(reader);\n-\t\treader.setRegisteredAsAvailable(true);\n-\t}\n-\n-\t@Nullable\n-\tprivate NetworkSequenceViewReader pollAvailableReader() {\n-\t\tNetworkSequenceViewReader reader = availableReaders.poll();\n-\t\tif (reader != null) {\n-\t\t\treader.setRegisteredAsAvailable(false);\n-\t\t}\n-\t\treturn reader;\n-\t}\n-\n-\t@Override\n-\tpublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-\t\treleaseAllResources();\n-\n-\t\tctx.fireChannelInactive();\n-\t}\n-\n-\t@Override\n-\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-\t\thandleException(ctx.channel(), cause);\n-\t}\n-\n-\tprivate void handleException(Channel channel, Throwable cause) throws IOException {\n-\t\tLOG.error(\"Encountered error while consuming partitions\", cause);\n-\n-\t\tfatalError = true;\n-\t\treleaseAllResources();\n-\n-\t\tif (channel.isActive()) {\n-\t\t\tchannel.writeAndFlush(new ErrorResponse(cause)).addListener(ChannelFutureListener.CLOSE);\n-\t\t}\n-\t}\n-\n-\tprivate void releaseAllResources() throws IOException {\n-\t\t// note: this is only ever executed by one thread: the Netty IO thread!\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\n-\t\tavailableReaders.clear();\n-\t\tallReaders.clear();\n-\t}\n-\n-\tprivate void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n-\t\treader.setRegisteredAsAvailable(false);\n-\t\treader.releaseAllResources();\n-\t}\n-\n-\t// This listener is called after an element of the current nonEmptyReader has been\n-\t// flushed. If successful, the listener triggers further processing of the\n-\t// queues.\n-\tprivate class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n-\n-\t\t@Override\n-\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n-\t\t\ttry {\n-\t\t\t\tif (future.isSuccess()) {\n-\t\t\t\t\twriteAndFlushNextMessageIfPossible(future.channel());\n-\t\t\t\t} else if (future.cause() != null) {\n-\t\t\t\t\thandleException(future.channel(), future.cause());\n-\t\t\t\t} else {\n-\t\t\t\t\thandleException(future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\thandleException(future.channel(), t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Outbound message to be sent to the client.\n-\t */\n-\tpublic static abstract class ServerOutboundMessage {\n-\t\tprotected final InputChannelID receiverId;\n-\t\tprotected final int backlog;\n-\t\tprivate final boolean moreAvailable;\n-\n-\t\tServerOutboundMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tcheckArgument(backlog >= 0, \"Number of backlog must be non-negative.\");\n-\t\t\tthis.receiverId = checkNotNull(receiverId);\n-\t\t\tthis.backlog = backlog;\n-\t\t\tthis.moreAvailable = moreAvailable;\n-\t\t}\n-\n-\t\tabstract Object build();\n-\n-\t\tpublic boolean isMoreAvailable() {\n-\t\t\treturn moreAvailable;\n-\t\t}\n-\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t}\n-\t}\n-\n-\tstatic class BufferResponseMessage extends ServerOutboundMessage {\n-\t\tprivate final Buffer buffer;\n-\t\tprivate final int sequenceNumber;\n-\n-\t\tBufferResponseMessage(\n-\t\t\t\tBuffer buffer,\n-\t\t\t\tInputChannelID receiverId,\n-\t\t\t\tint sequenceNumber,\n-\t\t\t\tint backlog,\n-\t\t\t\tboolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n-\t\t\tthis.buffer = checkNotNull(buffer);\n-\t\t\tthis.sequenceNumber = sequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new BufferResponse(buffer, sequenceNumber, receiverId, backlog);\n-\t\t}\n-\n-\t\t@Override\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t\tbuffer.recycleBuffer();\n-\t\t}\n-\t}\n-\n-\tstatic class AddBacklogMessage extends ServerOutboundMessage {\n-\n-\t\tAddBacklogMessage(InputChannelID receiverId, int backlog) {\n-\t\t\tsuper(receiverId, backlog, false);\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new AddBacklog(backlog, receiverId);\n-\t\t}\n-\t}\n+class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n+\n+    private final ChannelFutureListener writeListener =\n+            new WriteAndFlushNextMessageIfPossibleListener();\n+\n+    /** The readers which are already enqueued available for transferring data. */\n+    private final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n+\n+    /** All the readers created for the consumers' partition requests. */\n+    private final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders =\n+            new ConcurrentHashMap<>();\n+\n+    private boolean fatalError;\n+\n+    private ChannelHandlerContext ctx;\n+\n+    @Override\n+    public void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n+        if (this.ctx == null) {\n+            this.ctx = ctx;\n+        }\n+\n+        super.channelRegistered(ctx);\n+    }\n+\n+    void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n+        // The notification might come from the same thread. For the initial writes this\n+        // might happen before the reader has set its reference to the view, because\n+        // creating the queue and the initial notification happen in the same method call.\n+        // This can be resolved by separating the creation of the view and allowing\n+        // notifications.\n+\n+        // TODO This could potentially have a bad performance impact as in the\n+        // worst case (network consumes faster than the producer) each buffer\n+        // will trigger a separate event loop task being scheduled.\n+        ctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n+    }\n+\n+    /**\n+     * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n+     * non-empty reader notification from the producer.\n+     *\n+     * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n+     * availability, so there is no race condition here.\n+     */\n+    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n+        announceBacklogIfNeeded(reader, reader.getRemainingBacklog());\n+        if (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {\n+            return;\n+        }\n+        // Queue an available reader for consumption. If the queue is empty,\n+        // we try trigger the actual write. Otherwise this will be handled by\n+        // the writeAndFlushNextMessageIfPossible calls.\n+        boolean triggerWrite = availableReaders.isEmpty();\n+        registerAvailableReader(reader);\n+\n+        if (triggerWrite) {\n+            writeAndFlushNextMessageIfPossible(ctx.channel());\n+        }\n+    }\n+\n+    /**\n+     * Accesses internal state to verify reader registration in the unit tests.\n+     *\n+     * <p><strong>Do not use anywhere else!</strong>\n+     *\n+     * @return readers which are enqueued available for transferring data\n+     */\n+    @VisibleForTesting\n+    ArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n+        return availableReaders;\n+    }\n+\n+    public void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n+        allReaders.put(reader.getReceiverId(), reader);\n+    }\n+\n+    public void cancel(InputChannelID receiverId) {\n+        ctx.pipeline().fireUserEventTriggered(receiverId);\n+    }\n+\n+    public void close() throws IOException {\n+        if (ctx != null) {\n+            ctx.channel().close();\n+        }\n+\n+        releaseAllResources();\n+    }\n+\n+    /**\n+     * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n+     * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n+     *\n+     * @param receiverId The input channel id to identify the consumer.\n+     * @param operation The operation to be performed (add credit or resume data consumption).\n+     */\n+    void addCreditOrResumeConsumption(\n+            InputChannelID receiverId, Consumer<NetworkSequenceViewReader> operation)\n+            throws Exception {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            operation.accept(reader);\n+\n+            enqueueAvailableReader(reader);\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    /**\n+     * Announces remaining backlog to the consumer after the available data notification or data\n+     * consumption resumption.\n+     */\n+    private void announceBacklogIfNeeded(NetworkSequenceViewReader reader, int backlog) {\n+        if (backlog > 0 && reader.needAnnounceBacklog()) {\n+            NettyMessage.BacklogAnnouncement announcement =\n+                    new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n+            ctx.channel()\n+                    .writeAndFlush(announcement)\n+                    .addListener(\n+                            (ChannelFutureListener)\n+                                    future -> {\n+                                        if (!future.isSuccess()) {\n+                                            onChannelFutureFailure(future);\n+                                        }\n+                                    });\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        // The user event triggered event loop callback is used for thread-safe\n+        // hand over of reader queues and cancelled producers.\n+\n+        if (msg instanceof NetworkSequenceViewReader) {\n+            enqueueAvailableReader((NetworkSequenceViewReader) msg);\n+        } else if (msg.getClass() == InputChannelID.class) {\n+            // Release partition view that get a cancel request.\n+            InputChannelID toCancel = (InputChannelID) msg;\n+\n+            // remove reader from queue of available readers\n+            availableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n+\n+            // remove reader from queue of all readers and release its resource\n+            final NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n+            if (toRelease != null) {\n+                releaseViewReader(toRelease);\n+            }\n+        } else {\n+            ctx.fireUserEventTriggered(msg);\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        writeAndFlushNextMessageIfPossible(ctx.channel());\n+    }\n+\n+    private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n+        if (fatalError || !channel.isWritable()) {\n+            return;\n+        }\n+\n+        // The logic here is very similar to the combined input gate and local\n+        // input channel logic. You can think of this class acting as the input\n+        // gate and the consumed views as the local input channels.\n+\n+        BufferAndAvailability next = null;\n+        try {\n+            while (true) {\n+                NetworkSequenceViewReader reader = pollAvailableReader();\n+\n+                // No queue with available data. We allow this here, because\n+                // of the write callbacks that are executed after each write.\n+                if (reader == null) {\n+                    return;\n+                }\n+\n+                next = reader.getNextBuffer();\n+                if (next == null) {\n+                    if (!reader.isReleased()) {\n+                        continue;\n+                    }\n+\n+                    Throwable cause = reader.getFailureCause();\n+                    if (cause != null) {\n+                        ErrorResponse msg =\n+                                new ErrorResponse(\n+                                        new ProducerFailedException(cause), reader.getReceiverId());\n+\n+                        ctx.writeAndFlush(msg);\n+                    }\n+                } else {\n+                    // This channel was now removed from the available reader queue.\n+                    // We re-add it into the queue if it is still available\n+                    if (next.moreAvailable()) {\n+                        registerAvailableReader(reader);\n+                    }\n+\n+                    BufferResponse msg =\n+                            new BufferResponse(\n+                                    next.buffer(),\n+                                    next.getSequenceNumber(),\n+                                    reader.getReceiverId(),\n+                                    next.buffersInBacklog());\n+\n+                    // Write and flush and wait until this is done before\n+                    // trying to continue with the next buffer.\n+                    channel.writeAndFlush(msg).addListener(writeListener);\n+\n+                    return;\n+                }\n+            }\n+        } catch (Throwable t) {\n+            if (next != null) {\n+                next.buffer().recycleBuffer();\n+            }\n+\n+            throw new IOException(t.getMessage(), t);\n+        }\n+    }\n+\n+    private void registerAvailableReader(NetworkSequenceViewReader reader) {\n+        availableReaders.add(reader);\n+        reader.setRegisteredAsAvailable(true);\n+    }\n+\n+    @Nullable\n+    private NetworkSequenceViewReader pollAvailableReader() {\n+        NetworkSequenceViewReader reader = availableReaders.poll();\n+        if (reader != null) {\n+            reader.setRegisteredAsAvailable(false);\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        releaseAllResources();\n+\n+        ctx.fireChannelInactive();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        handleException(ctx.channel(), cause);\n+    }\n+\n+    private void handleException(Channel channel, Throwable cause) throws IOException {\n+        LOG.error(\"Encountered error while consuming partitions\", cause);\n+\n+        fatalError = true;\n+        releaseAllResources();\n+\n+        if (channel.isActive()) {\n+            channel.writeAndFlush(new ErrorResponse(cause))\n+                    .addListener(ChannelFutureListener.CLOSE);\n+        }\n+    }\n+\n+    private void releaseAllResources() throws IOException {\n+        // note: this is only ever executed by one thread: the Netty IO thread!\n+        for (NetworkSequenceViewReader reader : allReaders.values()) {\n+            releaseViewReader(reader);\n+        }\n+\n+        availableReaders.clear();\n+        allReaders.clear();\n+    }\n+\n+    private void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n+        reader.setRegisteredAsAvailable(false);\n+        reader.releaseAllResources();\n+    }\n+\n+    private void onChannelFutureFailure(ChannelFuture future) throws Exception {\n+        if (future.cause() != null) {\n+            handleException(future.channel(), future.cause());\n+        } else {\n+            handleException(\n+                    future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n+        }\n+    }\n+\n+    // This listener is called after an element of the current nonEmptyReader has been\n+    // flushed. If successful, the listener triggers further processing of the\n+    // queues.\n+    private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            try {\n+                if (future.isSuccess()) {\n+                    writeAndFlushNextMessageIfPossible(future.channel());\n+                } else {\n+                    onChannelFutureFailure(future);\n+                }\n+            } catch (Throwable t) {\n+                handleException(future.channel(), t);\n+            }\n+        }\n+    }\n }\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex df17ef3877c..0e3b6ddc57c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -350,8 +334,12 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n             try {\n                 if (future.isSuccess()) {\n                     writeAndFlushNextMessageIfPossible(future.channel());\n+                } else if (future.cause() != null) {\n+                    handleException(future.channel(), future.cause());\n                 } else {\n-                    onChannelFutureFailure(future);\n+                    handleException(\n+                            future.channel(),\n+                            new IllegalStateException(\"Sending cancelled by user.\"));\n                 }\n             } catch (Throwable t) {\n                 handleException(future.channel(), t);\n", "next_change": {"commit": "639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 0e3b6ddc57c..72ede48bda2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -334,12 +376,8 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n             try {\n                 if (future.isSuccess()) {\n                     writeAndFlushNextMessageIfPossible(future.channel());\n-                } else if (future.cause() != null) {\n-                    handleException(future.channel(), future.cause());\n                 } else {\n-                    handleException(\n-                            future.channel(),\n-                            new IllegalStateException(\"Sending cancelled by user.\"));\n+                    onChannelFutureFailure(future);\n                 }\n             } catch (Throwable t) {\n                 handleException(future.channel(), t);\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 70ec735057f..72ede48bda2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -42,350 +42,346 @@ import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n \n import static org.apache.flink.runtime.io.network.netty.NettyMessage.BufferResponse;\n import static org.apache.flink.util.Preconditions.checkArgument;\n-import static org.apache.flink.util.Preconditions.checkNotNull;\n \n /**\n- * A nonEmptyReader of partition queues, which listens for channel writability changed\n- * events before writing and flushing {@link Buffer} instances.\n+ * A nonEmptyReader of partition queues, which listens for channel writability changed events before\n+ * writing and flushing {@link Buffer} instances.\n  */\n-public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n-\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n-\n-\tprivate final ChannelFutureListener writeListener = new WriteAndFlushNextMessageIfPossibleListener();\n-\n-\t/** The readers which are already enqueued available for transferring data or announcing backlog. */\n-\tprivate final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n-\n-\t/** All the readers created for the consumers' partition requests. */\n-\tprivate final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders = new ConcurrentHashMap<>();\n-\n-\tprivate boolean fatalError;\n-\n-\tprivate ChannelHandlerContext ctx;\n-\n-\t@Override\n-\tpublic void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n-\t\tif (this.ctx == null) {\n-\t\t\tthis.ctx = ctx;\n-\t\t}\n-\n-\t\tsuper.channelRegistered(ctx);\n-\t}\n-\n-\tvoid notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n-\t\t// The notification might come from the same thread. For the initial writes this\n-\t\t// might happen before the reader has set its reference to the view, because\n-\t\t// creating the queue and the initial notification happen in the same method call.\n-\t\t// This can be resolved by separating the creation of the view and allowing\n-\t\t// notifications.\n-\n-\t\t// TODO This could potentially have a bad performance impact as in the\n-\t\t// worst case (network consumes faster than the producer) each buffer\n-\t\t// will trigger a separate event loop task being scheduled.\n-\t\tctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n-\t}\n-\n-\t/**\n-\t * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n-\t * non-empty reader notification from the producer.\n-\t *\n-\t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n-\t * availability, so there is no race condition here.\n-\t */\n-\tvoid enqueueAvailableReader(final NetworkSequenceViewReader reader, BooleanSupplier condition) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || !condition.getAsBoolean()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Queue an available reader for consumption. If the queue is empty,\n-\t\t// we try trigger the actual write. Otherwise this will be handled by\n-\t\t// the writeAndFlushNextMessageIfPossible calls.\n-\t\tboolean triggerWrite = availableReaders.isEmpty();\n-\t\tregisterAvailableReader(reader);\n-\n-\t\tif (triggerWrite) {\n-\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Accesses internal state to verify reader registration in the unit tests.\n-\t *\n-\t * <p><strong>Do not use anywhere else!</strong>\n-\t *\n-\t * @return readers which are enqueued available for transferring data or announcing backlog\n-\t */\n-\t@VisibleForTesting\n-\tArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n-\t\treturn availableReaders;\n-\t}\n-\n-\tpublic void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n-\t\tallReaders.put(reader.getReceiverId(), reader);\n-\t}\n-\n-\tpublic void cancel(InputChannelID receiverId) {\n-\t\tctx.pipeline().fireUserEventTriggered(receiverId);\n-\t}\n-\n-\tpublic void close() throws IOException {\n-\t\tif (ctx != null) {\n-\t\t\tctx.channel().close();\n-\t\t}\n-\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\t\tallReaders.clear();\n-\t}\n-\n-\t/**\n-\t * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n-\t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n-\t *\n-\t * @param receiverId The input channel id to identify the consumer.\n-\t * @param operation The operation to be performed (add credit or resume data consumption).\n-\t */\n-\tvoid addCreditOrResumeConsumption(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tFutureConsumerWithException<NetworkSequenceViewReader, Exception> operation) throws Exception {\n-\t\tif (fatalError) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n-\t\tif (reader != null) {\n-\t\t\toperation.acceptWithException(reader);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"No reader for receiverId = \" + receiverId + \" exists.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\t// The user event triggered event loop callback is used for thread-safe\n-\t\t// hand over of reader queues and cancelled producers.\n-\n-\t\tif (msg instanceof NetworkSequenceViewReader) {\n-\t\t\tNetworkSequenceViewReader reader = (NetworkSequenceViewReader) msg;\n-\t\t\tenqueueAvailableReader(reader, () -> (reader.isAvailable() || reader.shouldAnnounceBacklog()));\n-\t\t} else if (msg.getClass() == InputChannelID.class) {\n-\t\t\t// Release partition view that get a cancel request.\n-\t\t\tInputChannelID toCancel = (InputChannelID) msg;\n-\n-\t\t\t// remove reader from queue of available readers\n-\t\t\tavailableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n-\n-\t\t\t// remove reader from queue of all readers and release its resource\n-\t\t\tfinal NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n-\t\t\tif (toRelease != null) {\n-\t\t\t\treleaseViewReader(toRelease);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tctx.fireUserEventTriggered(msg);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n-\t}\n-\n-\tprivate void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n-\t\tif (fatalError || !channel.isWritable()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// The logic here is very similar to the combined input gate and local\n-\t\t// input channel logic. You can think of this class acting as the input\n-\t\t// gate and the consumed views as the local input channels.\n-\n-\t\tServerOutboundMessage next = null;\n-\t\ttry {\n-\t\t\twhile (true) {\n-\t\t\t\tNetworkSequenceViewReader reader = pollAvailableReader();\n-\n-\t\t\t\t// No queue with available data. We allow this here, because\n-\t\t\t\t// of the write callbacks that are executed after each write.\n-\t\t\t\tif (reader == null) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\tnext = reader.getNextMessage();\n-\t\t\t\tif (next == null) {\n-\t\t\t\t\tif (!reader.isReleased()) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tThrowable cause = reader.getFailureCause();\n-\t\t\t\t\tif (cause != null) {\n-\t\t\t\t\t\tErrorResponse msg = new ErrorResponse(\n-\t\t\t\t\t\t\tnew ProducerFailedException(cause),\n-\t\t\t\t\t\t\treader.getReceiverId());\n-\n-\t\t\t\t\t\tctx.writeAndFlush(msg);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// This channel was now removed from the available reader queue.\n-\t\t\t\t\t// We re-add it into the queue if it is still available\n-\t\t\t\t\tif (next.isMoreAvailable()) {\n-\t\t\t\t\t\tregisterAvailableReader(reader);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Write and flush and wait until this is done before\n-\t\t\t\t\t// trying to continue with the next buffer.\n-\t\t\t\t\tchannel.writeAndFlush(next.build()).addListener(writeListener);\n-\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tif (next != null) {\n-\t\t\t\tnext.recycleBufferIfNeeded();\n-\t\t\t}\n-\n-\t\t\tthrow new IOException(t.getMessage(), t);\n-\t\t}\n-\t}\n-\n-\tprivate void registerAvailableReader(NetworkSequenceViewReader reader) {\n-\t\tavailableReaders.add(reader);\n-\t\treader.setRegisteredAsAvailable(true);\n-\t}\n-\n-\t@Nullable\n-\tprivate NetworkSequenceViewReader pollAvailableReader() {\n-\t\tNetworkSequenceViewReader reader = availableReaders.poll();\n-\t\tif (reader != null) {\n-\t\t\treader.setRegisteredAsAvailable(false);\n-\t\t}\n-\t\treturn reader;\n-\t}\n-\n-\t@Override\n-\tpublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-\t\treleaseAllResources();\n-\n-\t\tctx.fireChannelInactive();\n-\t}\n-\n-\t@Override\n-\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-\t\thandleException(ctx.channel(), cause);\n-\t}\n-\n-\tprivate void handleException(Channel channel, Throwable cause) throws IOException {\n-\t\tLOG.error(\"Encountered error while consuming partitions\", cause);\n-\n-\t\tfatalError = true;\n-\t\treleaseAllResources();\n-\n-\t\tif (channel.isActive()) {\n-\t\t\tchannel.writeAndFlush(new ErrorResponse(cause)).addListener(ChannelFutureListener.CLOSE);\n-\t\t}\n-\t}\n-\n-\tprivate void releaseAllResources() throws IOException {\n-\t\t// note: this is only ever executed by one thread: the Netty IO thread!\n-\t\tfor (NetworkSequenceViewReader reader : allReaders.values()) {\n-\t\t\treleaseViewReader(reader);\n-\t\t}\n-\n-\t\tavailableReaders.clear();\n-\t\tallReaders.clear();\n-\t}\n-\n-\tprivate void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n-\t\treader.setRegisteredAsAvailable(false);\n-\t\treader.releaseAllResources();\n-\t}\n-\n-\t// This listener is called after an element of the current nonEmptyReader has been\n-\t// flushed. If successful, the listener triggers further processing of the\n-\t// queues.\n-\tprivate class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n-\n-\t\t@Override\n-\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n-\t\t\ttry {\n-\t\t\t\tif (future.isSuccess()) {\n-\t\t\t\t\twriteAndFlushNextMessageIfPossible(future.channel());\n-\t\t\t\t} else if (future.cause() != null) {\n-\t\t\t\t\thandleException(future.channel(), future.cause());\n-\t\t\t\t} else {\n-\t\t\t\t\thandleException(future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\thandleException(future.channel(), t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Outbound message to be sent to the client.\n-\t */\n-\tpublic static abstract class ServerOutboundMessage {\n-\t\tprotected final InputChannelID receiverId;\n-\t\tprotected final int backlog;\n-\t\tprivate final boolean moreAvailable;\n-\n-\t\tServerOutboundMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tcheckArgument(backlog >= 0, \"Number of backlog must be non-negative.\");\n-\t\t\tthis.receiverId = checkNotNull(receiverId);\n-\t\t\tthis.backlog = backlog;\n-\t\t\tthis.moreAvailable = moreAvailable;\n-\t\t}\n-\n-\t\tabstract Object build();\n-\n-\t\tpublic boolean isMoreAvailable() {\n-\t\t\treturn moreAvailable;\n-\t\t}\n-\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t}\n-\t}\n-\n-\tstatic class BufferResponseMessage extends ServerOutboundMessage {\n-\t\tprivate final Buffer buffer;\n-\t\tprivate final int sequenceNumber;\n-\n-\t\tBufferResponseMessage(\n-\t\t\t\tBuffer buffer,\n-\t\t\t\tInputChannelID receiverId,\n-\t\t\t\tint sequenceNumber,\n-\t\t\t\tint backlog,\n-\t\t\t\tboolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n-\t\t\tthis.buffer = checkNotNull(buffer);\n-\t\t\tthis.sequenceNumber = sequenceNumber;\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new BufferResponse(buffer, sequenceNumber, receiverId, backlog);\n-\t\t}\n-\n-\t\t@Override\n-\t\tvoid recycleBufferIfNeeded() {\n-\t\t\tbuffer.recycleBuffer();\n-\t\t}\n-\t}\n-\n-\tstatic class AddBacklogMessage extends ServerOutboundMessage {\n-\n-\t\tAddBacklogMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n-\t\t}\n-\n-\t\t@Override\n-\t\tObject build() {\n-\t\t\treturn new AddBacklog(backlog, receiverId);\n-\t\t}\n-\t}\n+class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PartitionRequestQueue.class);\n+\n+    private final ChannelFutureListener writeListener =\n+            new WriteAndFlushNextMessageIfPossibleListener();\n+\n+    /** The readers which are already enqueued available for transferring data. */\n+    private final ArrayDeque<NetworkSequenceViewReader> availableReaders = new ArrayDeque<>();\n+\n+    /** All the readers created for the consumers' partition requests. */\n+    private final ConcurrentMap<InputChannelID, NetworkSequenceViewReader> allReaders =\n+            new ConcurrentHashMap<>();\n+\n+    private boolean fatalError;\n+\n+    private ChannelHandlerContext ctx;\n+\n+    @Override\n+    public void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n+        if (this.ctx == null) {\n+            this.ctx = ctx;\n+        }\n+\n+        super.channelRegistered(ctx);\n+    }\n+\n+    void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n+        // The notification might come from the same thread. For the initial writes this\n+        // might happen before the reader has set its reference to the view, because\n+        // creating the queue and the initial notification happen in the same method call.\n+        // This can be resolved by separating the creation of the view and allowing\n+        // notifications.\n+\n+        // TODO This could potentially have a bad performance impact as in the\n+        // worst case (network consumes faster than the producer) each buffer\n+        // will trigger a separate event loop task being scheduled.\n+        ctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader));\n+    }\n+\n+    /**\n+     * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n+     * non-empty reader notification from the producer.\n+     *\n+     * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n+     * availability, so there is no race condition here.\n+     */\n+    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n+        if (reader.isRegisteredAsAvailable()) {\n+            return;\n+        }\n+\n+        ResultSubpartitionView.AvailabilityWithBacklog availabilityWithBacklog =\n+                reader.getAvailabilityAndBacklog();\n+        if (!availabilityWithBacklog.isAvailable()) {\n+            int backlog = availabilityWithBacklog.getBacklog();\n+            if (backlog > 0 && reader.needAnnounceBacklog()) {\n+                announceBacklog(reader, backlog);\n+            }\n+            return;\n+        }\n+\n+        // Queue an available reader for consumption. If the queue is empty,\n+        // we try trigger the actual write. Otherwise this will be handled by\n+        // the writeAndFlushNextMessageIfPossible calls.\n+        boolean triggerWrite = availableReaders.isEmpty();\n+        registerAvailableReader(reader);\n+\n+        if (triggerWrite) {\n+            writeAndFlushNextMessageIfPossible(ctx.channel());\n+        }\n+    }\n+\n+    /**\n+     * Accesses internal state to verify reader registration in the unit tests.\n+     *\n+     * <p><strong>Do not use anywhere else!</strong>\n+     *\n+     * @return readers which are enqueued available for transferring data\n+     */\n+    @VisibleForTesting\n+    ArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {\n+        return availableReaders;\n+    }\n+\n+    public void notifyReaderCreated(final NetworkSequenceViewReader reader) {\n+        allReaders.put(reader.getReceiverId(), reader);\n+    }\n+\n+    public void cancel(InputChannelID receiverId) {\n+        ctx.pipeline().fireUserEventTriggered(receiverId);\n+    }\n+\n+    public void close() throws IOException {\n+        if (ctx != null) {\n+            ctx.channel().close();\n+        }\n+\n+        releaseAllResources();\n+    }\n+\n+    /**\n+     * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n+     * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n+     *\n+     * @param receiverId The input channel id to identify the consumer.\n+     * @param operation The operation to be performed (add credit or resume data consumption).\n+     */\n+    void addCreditOrResumeConsumption(\n+            InputChannelID receiverId, Consumer<NetworkSequenceViewReader> operation)\n+            throws Exception {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            operation.accept(reader);\n+\n+            enqueueAvailableReader(reader);\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    void acknowledgeAllRecordsProcessed(InputChannelID receiverId) {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            reader.acknowledgeAllRecordsProcessed();\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n+    /**\n+     * Announces remaining backlog to the consumer after the available data notification or data\n+     * consumption resumption.\n+     */\n+    private void announceBacklog(NetworkSequenceViewReader reader, int backlog) {\n+        checkArgument(backlog > 0, \"Backlog must be positive.\");\n+\n+        NettyMessage.BacklogAnnouncement announcement =\n+                new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n+        ctx.channel()\n+                .writeAndFlush(announcement)\n+                .addListener(\n+                        (ChannelFutureListener)\n+                                future -> {\n+                                    if (!future.isSuccess()) {\n+                                        onChannelFutureFailure(future);\n+                                    }\n+                                });\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        // The user event triggered event loop callback is used for thread-safe\n+        // hand over of reader queues and cancelled producers.\n+\n+        if (msg instanceof NetworkSequenceViewReader) {\n+            enqueueAvailableReader((NetworkSequenceViewReader) msg);\n+        } else if (msg.getClass() == InputChannelID.class) {\n+            // Release partition view that get a cancel request.\n+            InputChannelID toCancel = (InputChannelID) msg;\n+\n+            // remove reader from queue of available readers\n+            availableReaders.removeIf(reader -> reader.getReceiverId().equals(toCancel));\n+\n+            // remove reader from queue of all readers and release its resource\n+            final NetworkSequenceViewReader toRelease = allReaders.remove(toCancel);\n+            if (toRelease != null) {\n+                releaseViewReader(toRelease);\n+            }\n+        } else {\n+            ctx.fireUserEventTriggered(msg);\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        writeAndFlushNextMessageIfPossible(ctx.channel());\n+    }\n+\n+    private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {\n+        if (fatalError || !channel.isWritable()) {\n+            return;\n+        }\n+\n+        // The logic here is very similar to the combined input gate and local\n+        // input channel logic. You can think of this class acting as the input\n+        // gate and the consumed views as the local input channels.\n+\n+        BufferAndAvailability next = null;\n+        try {\n+            while (true) {\n+                NetworkSequenceViewReader reader = pollAvailableReader();\n+\n+                // No queue with available data. We allow this here, because\n+                // of the write callbacks that are executed after each write.\n+                if (reader == null) {\n+                    return;\n+                }\n+\n+                next = reader.getNextBuffer();\n+                if (next == null) {\n+                    if (!reader.isReleased()) {\n+                        continue;\n+                    }\n+\n+                    Throwable cause = reader.getFailureCause();\n+                    if (cause != null) {\n+                        ErrorResponse msg =\n+                                new ErrorResponse(\n+                                        new ProducerFailedException(cause), reader.getReceiverId());\n+\n+                        ctx.writeAndFlush(msg);\n+                    }\n+                } else {\n+                    // This channel was now removed from the available reader queue.\n+                    // We re-add it into the queue if it is still available\n+                    if (next.moreAvailable()) {\n+                        registerAvailableReader(reader);\n+                    }\n+\n+                    BufferResponse msg =\n+                            new BufferResponse(\n+                                    next.buffer(),\n+                                    next.getSequenceNumber(),\n+                                    reader.getReceiverId(),\n+                                    next.buffersInBacklog());\n+\n+                    // Write and flush and wait until this is done before\n+                    // trying to continue with the next buffer.\n+                    channel.writeAndFlush(msg).addListener(writeListener);\n+\n+                    return;\n+                }\n+            }\n+        } catch (Throwable t) {\n+            if (next != null) {\n+                next.buffer().recycleBuffer();\n+            }\n+\n+            throw new IOException(t.getMessage(), t);\n+        }\n+    }\n+\n+    private void registerAvailableReader(NetworkSequenceViewReader reader) {\n+        availableReaders.add(reader);\n+        reader.setRegisteredAsAvailable(true);\n+    }\n+\n+    @Nullable\n+    private NetworkSequenceViewReader pollAvailableReader() {\n+        NetworkSequenceViewReader reader = availableReaders.poll();\n+        if (reader != null) {\n+            reader.setRegisteredAsAvailable(false);\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        releaseAllResources();\n+\n+        ctx.fireChannelInactive();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        handleException(ctx.channel(), cause);\n+    }\n+\n+    private void handleException(Channel channel, Throwable cause) throws IOException {\n+        LOG.error(\"Encountered error while consuming partitions\", cause);\n+\n+        fatalError = true;\n+        releaseAllResources();\n+\n+        if (channel.isActive()) {\n+            channel.writeAndFlush(new ErrorResponse(cause))\n+                    .addListener(ChannelFutureListener.CLOSE);\n+        }\n+    }\n+\n+    private void releaseAllResources() throws IOException {\n+        // note: this is only ever executed by one thread: the Netty IO thread!\n+        for (NetworkSequenceViewReader reader : allReaders.values()) {\n+            releaseViewReader(reader);\n+        }\n+\n+        availableReaders.clear();\n+        allReaders.clear();\n+    }\n+\n+    private void releaseViewReader(NetworkSequenceViewReader reader) throws IOException {\n+        reader.setRegisteredAsAvailable(false);\n+        reader.releaseAllResources();\n+    }\n+\n+    private void onChannelFutureFailure(ChannelFuture future) throws Exception {\n+        if (future.cause() != null) {\n+            handleException(future.channel(), future.cause());\n+        } else {\n+            handleException(\n+                    future.channel(), new IllegalStateException(\"Sending cancelled by user.\"));\n+        }\n+    }\n+\n+    // This listener is called after an element of the current nonEmptyReader has been\n+    // flushed. If successful, the listener triggers further processing of the\n+    // queues.\n+    private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            try {\n+                if (future.isSuccess()) {\n+                    writeAndFlushNextMessageIfPossible(future.channel());\n+                } else {\n+                    onChannelFutureFailure(future);\n+                }\n+            } catch (Throwable t) {\n+                handleException(future.channel(), t);\n+            }\n+        }\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "7478445aa30cd28b7b6402565ca304c916024475", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[refactor][runtime] Unification of obtaining reader in PartitionRequestQueue"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}, {"oid": "7bacef09622d43c01ca9a749bbcd259d5cd3e0fe", "committedDate": "2021-09-17 20:16:25 +0200", "message": "[FLINK-24233][runtime] Ignore message about new buffer size if the reader doesn't ready yet"}, {"oid": "f957e3fee50e734dd6b2cbf0cbbef00fe810cd32", "committedDate": "2022-01-13 15:07:28 +0100", "message": "[FLINK-25441][network] Wrap failure cuase with ProducerFailedException only for PipelinedSubpartitionView."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3ODUyMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425078522", "body": "I guess we should not expect `null` return here. As long as the code path enters `getAddBacklogMessage`, then we should guarantee that the respective backlog should be more than 0. \r\nMaybe add assert backlog instead?", "bodyText": "I guess we should not expect null return here. As long as the code path enters getAddBacklogMessage, then we should guarantee that the respective backlog should be more than 0.\nMaybe add assert backlog instead?", "bodyHTML": "<p dir=\"auto\">I guess we should not expect <code>null</code> return here. As long as the code path enters <code>getAddBacklogMessage</code>, then we should guarantee that the respective backlog should be more than 0.<br>\nMaybe add assert backlog instead?</p>", "author": "zhijiangW", "createdAt": "2020-05-14T11:53:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -163,8 +172,15 @@ boolean hasBuffersAvailable() {\n \t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n \t}\n \n-\t@Override\n-\tpublic BufferAndAvailability getNextBuffer() throws IOException {\n+\tprivate AddBacklogMessage getAddBacklogMessage() {\n+\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n+\t\tif (backlog > 0) {\n+\t\t\treturn new AddBacklogMessage(receiverId, backlog, false);\n+\t\t}\n+\t\treturn null;", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNzEzNg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425117136", "bodyText": "It can be null because of redundant data available notification.", "author": "wsry", "createdAt": "2020-05-14T13:01:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3ODUyMg=="}], "type": "inlineReview", "revised_code": {"commit": "fb4c607a5c4780729143d458b1c7633adcba59bf", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 09ce436d1ec..0c03c332422 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -175,7 +175,7 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \tprivate AddBacklogMessage getAddBacklogMessage() {\n \t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n \t\tif (backlog > 0) {\n-\t\t\treturn new AddBacklogMessage(receiverId, backlog, false);\n+\t\t\treturn new AddBacklogMessage(receiverId, backlog);\n \t\t}\n \t\treturn null;\n \t}\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 0c03c332422..b1a8400b7a1 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -20,227 +20,225 @@ package org.apache.flink.runtime.io.network.netty;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.runtime.io.network.NetworkSequenceViewReader;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.AddBacklogMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.BufferResponseMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.ServerOutboundMessage;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n import org.apache.flink.runtime.io.network.partition.BufferAvailabilityListener;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionProvider;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputChannel.BufferAndAvailability;\n import org.apache.flink.runtime.io.network.partition.consumer.InputChannelID;\n import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n \n+import javax.annotation.Nullable;\n+\n import java.io.IOException;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n+\n /**\n  * Simple wrapper for the subpartition view used in the new network credit-based mode.\n  *\n- * <p>It also keeps track of available buffers and notifies the outbound\n- * handler about non-emptiness, similar to the {@link LocalInputChannel}.\n+ * <p>It also keeps track of available buffers and notifies the outbound handler about\n+ * non-emptiness, similar to the {@link LocalInputChannel}.\n  */\n-class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListener, NetworkSequenceViewReader {\n-\n-\tprivate final Object requestLock = new Object();\n-\n-\tprivate final InputChannelID receiverId;\n-\n-\tprivate final PartitionRequestQueue requestQueue;\n-\n-\tprivate final boolean withoutExclusiveCredits;\n-\n-\tprivate volatile ResultSubpartitionView subpartitionView;\n-\n-\t/**\n-\t * The status indicating whether this reader is already enqueued in the pipeline for transferring\n-\t * data or not.\n-\t *\n-\t * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n-\t * thread only since there is no synchronisation.\n-\t */\n-\tprivate boolean isRegisteredAsAvailable = false;\n-\n-\t/** The number of available buffers for holding data on the consumer side. */\n-\tprivate int numCreditsAvailable;\n-\n-\tprivate int sequenceNumber = -1;\n-\n-\tCreditBasedSequenceNumberingViewReader(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tint initialCredit,\n-\t\t\tPartitionRequestQueue requestQueue) {\n-\n-\t\tthis.receiverId = receiverId;\n-\t\tthis.numCreditsAvailable = initialCredit;\n-\t\tthis.requestQueue = requestQueue;\n-\t\tthis.withoutExclusiveCredits = initialCredit == 0;\n-\t}\n-\n-\t@Override\n-\tpublic void requestSubpartitionView(\n-\t\tResultPartitionProvider partitionProvider,\n-\t\tResultPartitionID resultPartitionId,\n-\t\tint subPartitionIndex) throws IOException {\n-\n-\t\tsynchronized (requestLock) {\n-\t\t\tif (subpartitionView == null) {\n-\t\t\t\t// This this call can trigger a notification we have to\n-\t\t\t\t// schedule a separate task at the event loop that will\n-\t\t\t\t// start consuming this. Otherwise the reference to the\n-\t\t\t\t// view cannot be available in getNextBuffer().\n-\t\t\t\tthis.subpartitionView = partitionProvider.createSubpartitionView(\n-\t\t\t\t\tresultPartitionId,\n-\t\t\t\t\tsubPartitionIndex,\n-\t\t\t\t\tthis);\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalStateException(\"Subpartition already requested\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void addCredit(int creditDeltas) throws Exception {\n-\t\tnumCreditsAvailable += creditDeltas;\n-\t\trequestQueue.enqueueAvailableReader(this, this::isAvailable);\n-\t}\n-\n-\t@Override\n-\tpublic boolean shouldAnnounceBacklog(boolean hasUnfulfilledBacklog) {\n-\t\treturn !hasUnfulfilledBacklog && withoutExclusiveCredits && numCreditsAvailable == 0;\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption(int availableCredits, boolean hasUnfulfilledBacklog) throws Exception {\n-\t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredits;\n-\t\tsubpartitionView.resumeConsumption();\n-\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || shouldAnnounceBacklog(hasUnfulfilledBacklog)));\n-\t}\n-\n-\t@Override\n-\tpublic void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n-\t\tthis.isRegisteredAsAvailable = isRegisteredAvailable;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRegisteredAsAvailable() {\n-\t\treturn isRegisteredAsAvailable;\n-\t}\n-\n-\t/**\n-\t * Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t */\n-\t@Override\n-\tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n-\t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n-\t}\n-\n-\t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n-\t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t *\n-\t * @param bufferAndBacklog\n-\t * \t\tcurrent buffer and backlog including information about the next buffer\n-\t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n-\t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic InputChannelID getReceiverId() {\n-\t\treturn receiverId;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumCreditsAvailable() {\n-\t\treturn numCreditsAvailable;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean hasBuffersAvailable() {\n-\t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\tprivate AddBacklogMessage getAddBacklogMessage() {\n-\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n-\t\tif (backlog > 0) {\n-\t\t\treturn new AddBacklogMessage(receiverId, backlog);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate BufferResponseMessage getBufferResponseMessage() throws IOException {\n-\t\tBufferAndBacklog next = subpartitionView.getNextBuffer();\n-\t\tif (next != null) {\n-\t\t\tsequenceNumber++;\n-\n-\t\t\tif (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n-\t\t\t\tthrow new IllegalStateException(\"no credit available\");\n-\t\t\t}\n-\n-\t\t\treturn new BufferResponseMessage(\n-\t\t\t\tnext.buffer(), receiverId, sequenceNumber, next.unannouncedBacklog(), isAvailable(next));\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic ServerOutboundMessage getNextMessage() throws IOException {\n-\t\t// BufferResponse is processed with higher priority compared with AddBacklog. There are three scenarios\n-\t\t// that we never announce backlog to the consumer through AddBacklog message:\n-\t\t// 1. We have exclusive credits which means unannounced backlog can be always carried by BufferResponse.\n-\t\t//    So AddBacklog message is never needed.\n-\t\t// 2. We already have available credits so we do not need to announce backlog to the consumer to request\n-\t\t//    new ones.\n-\t\t// 3. Next Buffer is an event which does not consume any credit. So we can just send the event and bring\n-\t\t//    the unannounced backlog with it.\n-\t\tif (!withoutExclusiveCredits || numCreditsAvailable > 0 || subpartitionView.isAvailable(0)) {\n-\t\t\treturn getBufferResponseMessage();\n-\t\t}\n-\t\treturn getAddBacklogMessage();\n-\t}\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn subpartitionView.isReleased();\n-\t}\n-\n-\t@Override\n-\tpublic Throwable getFailureCause() {\n-\t\treturn subpartitionView.getFailureCause();\n-\t}\n-\n-\t@Override\n-\tpublic void releaseAllResources() throws IOException {\n-\t\tsubpartitionView.releaseAllResources();\n-\t}\n-\n-\t@Override\n-\tpublic void notifyDataAvailable() {\n-\t\trequestQueue.notifyReaderNonEmpty(this);\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"CreditBasedSequenceNumberingViewReader{\" +\n-\t\t\t\"requestLock=\" + requestLock +\n-\t\t\t\", receiverId=\" + receiverId +\n-\t\t\t\", withoutExclusiveCredits=\" + withoutExclusiveCredits +\n-\t\t\t\", sequenceNumber=\" + sequenceNumber +\n-\t\t\t\", numCreditsAvailable=\" + numCreditsAvailable +\n-\t\t\t\", isRegisteredAsAvailable=\" + isRegisteredAsAvailable +\n-\t\t\t'}';\n-\t}\n+class CreditBasedSequenceNumberingViewReader\n+        implements BufferAvailabilityListener, NetworkSequenceViewReader {\n+\n+    private final Object requestLock = new Object();\n+\n+    private final InputChannelID receiverId;\n+\n+    private final PartitionRequestQueue requestQueue;\n+\n+    private final int initialCredit;\n+\n+    private volatile ResultSubpartitionView subpartitionView;\n+\n+    /**\n+     * The status indicating whether this reader is already enqueued in the pipeline for\n+     * transferring data or not.\n+     *\n+     * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n+     * thread only since there is no synchronisation.\n+     */\n+    private boolean isRegisteredAsAvailable = false;\n+\n+    /** The number of available buffers for holding data on the consumer side. */\n+    private int numCreditsAvailable;\n+\n+    CreditBasedSequenceNumberingViewReader(\n+            InputChannelID receiverId, int initialCredit, PartitionRequestQueue requestQueue) {\n+        checkArgument(initialCredit >= 0, \"Must be non-negative.\");\n+\n+        this.receiverId = receiverId;\n+        this.initialCredit = initialCredit;\n+        this.numCreditsAvailable = initialCredit;\n+        this.requestQueue = requestQueue;\n+    }\n+\n+    @Override\n+    public void requestSubpartitionView(\n+            ResultPartitionProvider partitionProvider,\n+            ResultPartitionID resultPartitionId,\n+            int subPartitionIndex)\n+            throws IOException {\n+\n+        synchronized (requestLock) {\n+            if (subpartitionView == null) {\n+                // This this call can trigger a notification we have to\n+                // schedule a separate task at the event loop that will\n+                // start consuming this. Otherwise the reference to the\n+                // view cannot be available in getNextBuffer().\n+                this.subpartitionView =\n+                        partitionProvider.createSubpartitionView(\n+                                resultPartitionId, subPartitionIndex, this);\n+            } else {\n+                throw new IllegalStateException(\"Subpartition already requested\");\n+            }\n+        }\n+\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public void addCredit(int creditDeltas) {\n+        numCreditsAvailable += creditDeltas;\n+    }\n+\n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n+    @Override\n+    public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;\n+        }\n+\n+        subpartitionView.resumeConsumption();\n+    }\n+\n+    @Override\n+    public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n+        this.isRegisteredAsAvailable = isRegisteredAvailable;\n+    }\n+\n+    @Override\n+    public boolean isRegisteredAsAvailable() {\n+        return isRegisteredAsAvailable;\n+    }\n+\n+    /**\n+     * Returns true only if the next buffer is an event or the reader has both available credits and\n+     * buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such\n+     *     that {@code getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n+     */\n+    @Override\n+    public boolean isAvailable() {\n+        return subpartitionView.isAvailable(numCreditsAvailable);\n+    }\n+\n+    /**\n+     * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next\n+     * buffer in line.\n+     *\n+     * <p>Returns the next data type only if the next buffer is an event or the reader has both\n+     * available credits and buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #isAvailable()}, such that {@code\n+     *     getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n+     * @param bufferAndBacklog current buffer and backlog including information about the next\n+     *     buffer\n+     * @return the next data type if the next buffer can be pulled immediately or {@link\n+     *     Buffer.DataType#NONE}\n+     */\n+    private Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n+        final Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+        if (numCreditsAvailable > 0 || nextDataType.isEvent()) {\n+            return nextDataType;\n+        }\n+        return Buffer.DataType.NONE;\n+    }\n+\n+    @Override\n+    public InputChannelID getReceiverId() {\n+        return receiverId;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumCreditsAvailable() {\n+        return numCreditsAvailable;\n+    }\n+\n+    @VisibleForTesting\n+    boolean hasBuffersAvailable() {\n+        return subpartitionView.isAvailable(Integer.MAX_VALUE);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BufferAndAvailability getNextBuffer() throws IOException {\n+        BufferAndBacklog next = subpartitionView.getNextBuffer();\n+        if (next != null) {\n+            if (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n+                throw new IllegalStateException(\"no credit available\");\n+            }\n+\n+            final Buffer.DataType nextDataType = getNextDataType(next);\n+            return new BufferAndAvailability(\n+                    next.buffer(), nextDataType, next.buffersInBacklog(), next.getSequenceNumber());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public int getRemainingBacklog() {\n+        return subpartitionView.getRemainingBacklog();\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        return subpartitionView.isReleased();\n+    }\n+\n+    @Override\n+    public Throwable getFailureCause() {\n+        return subpartitionView.getFailureCause();\n+    }\n+\n+    @Override\n+    public void releaseAllResources() throws IOException {\n+        subpartitionView.releaseAllResources();\n+    }\n+\n+    @Override\n+    public void notifyDataAvailable() {\n+        requestQueue.notifyReaderNonEmpty(this);\n+    }\n+\n+    @Override\n+    public void notifyPriorityEvent(int prioritySequenceNumber) {\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CreditBasedSequenceNumberingViewReader{\"\n+                + \"requestLock=\"\n+                + requestLock\n+                + \", receiverId=\"\n+                + receiverId\n+                + \", numCreditsAvailable=\"\n+                + numCreditsAvailable\n+                + \", isRegisteredAsAvailable=\"\n+                + isRegisteredAsAvailable\n+                + '}';\n+    }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 09ce436d1ec..01d08d5f53c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -20,227 +20,226 @@ package org.apache.flink.runtime.io.network.netty;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.runtime.io.network.NetworkSequenceViewReader;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.AddBacklogMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.BufferResponseMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.ServerOutboundMessage;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n import org.apache.flink.runtime.io.network.partition.BufferAvailabilityListener;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionProvider;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputChannel.BufferAndAvailability;\n import org.apache.flink.runtime.io.network.partition.consumer.InputChannelID;\n import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n \n+import javax.annotation.Nullable;\n+\n import java.io.IOException;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n+\n /**\n  * Simple wrapper for the subpartition view used in the new network credit-based mode.\n  *\n- * <p>It also keeps track of available buffers and notifies the outbound\n- * handler about non-emptiness, similar to the {@link LocalInputChannel}.\n+ * <p>It also keeps track of available buffers and notifies the outbound handler about\n+ * non-emptiness, similar to the {@link LocalInputChannel}.\n  */\n-class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListener, NetworkSequenceViewReader {\n-\n-\tprivate final Object requestLock = new Object();\n-\n-\tprivate final InputChannelID receiverId;\n-\n-\tprivate final PartitionRequestQueue requestQueue;\n-\n-\tprivate final boolean withoutExclusiveCredits;\n-\n-\tprivate volatile ResultSubpartitionView subpartitionView;\n-\n-\t/**\n-\t * The status indicating whether this reader is already enqueued in the pipeline for transferring\n-\t * data or not.\n-\t *\n-\t * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n-\t * thread only since there is no synchronisation.\n-\t */\n-\tprivate boolean isRegisteredAsAvailable = false;\n-\n-\t/** The number of available buffers for holding data on the consumer side. */\n-\tprivate int numCreditsAvailable;\n-\n-\tprivate int sequenceNumber = -1;\n-\n-\tCreditBasedSequenceNumberingViewReader(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tint initialCredit,\n-\t\t\tPartitionRequestQueue requestQueue) {\n-\n-\t\tthis.receiverId = receiverId;\n-\t\tthis.numCreditsAvailable = initialCredit;\n-\t\tthis.requestQueue = requestQueue;\n-\t\tthis.withoutExclusiveCredits = initialCredit > 0;\n-\t}\n-\n-\t@Override\n-\tpublic void requestSubpartitionView(\n-\t\tResultPartitionProvider partitionProvider,\n-\t\tResultPartitionID resultPartitionId,\n-\t\tint subPartitionIndex) throws IOException {\n-\n-\t\tsynchronized (requestLock) {\n-\t\t\tif (subpartitionView == null) {\n-\t\t\t\t// This this call can trigger a notification we have to\n-\t\t\t\t// schedule a separate task at the event loop that will\n-\t\t\t\t// start consuming this. Otherwise the reference to the\n-\t\t\t\t// view cannot be available in getNextBuffer().\n-\t\t\t\tthis.subpartitionView = partitionProvider.createSubpartitionView(\n-\t\t\t\t\tresultPartitionId,\n-\t\t\t\t\tsubPartitionIndex,\n-\t\t\t\t\tthis);\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalStateException(\"Subpartition already requested\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void addCredit(int creditDeltas) throws Exception {\n-\t\tnumCreditsAvailable += creditDeltas;\n-\t\trequestQueue.enqueueAvailableReader(this, this::isAvailable);\n-\t}\n-\n-\t@Override\n-\tpublic boolean shouldAnnounceBacklog() {\n-\t\treturn !withoutExclusiveCredits && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption(int availableCredit, boolean hasUnfulfilledBacklog) throws Exception {\n-\t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredit;\n-\t\tsubpartitionView.resumeConsumption();\n-\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || !hasUnfulfilledBacklog && shouldAnnounceBacklog()));\n-\t}\n-\n-\t@Override\n-\tpublic void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n-\t\tthis.isRegisteredAsAvailable = isRegisteredAvailable;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRegisteredAsAvailable() {\n-\t\treturn isRegisteredAsAvailable;\n-\t}\n-\n-\t/**\n-\t * Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t */\n-\t@Override\n-\tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n-\t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n-\t}\n-\n-\t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n-\t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t *\n-\t * @param bufferAndBacklog\n-\t * \t\tcurrent buffer and backlog including information about the next buffer\n-\t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n-\t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic InputChannelID getReceiverId() {\n-\t\treturn receiverId;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumCreditsAvailable() {\n-\t\treturn numCreditsAvailable;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean hasBuffersAvailable() {\n-\t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\tprivate AddBacklogMessage getAddBacklogMessage() {\n-\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n-\t\tif (backlog > 0) {\n-\t\t\treturn new AddBacklogMessage(receiverId, backlog, false);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate BufferResponseMessage getBufferResponseMessage() throws IOException {\n-\t\tBufferAndBacklog next = subpartitionView.getNextBuffer();\n-\t\tif (next != null) {\n-\t\t\tsequenceNumber++;\n-\n-\t\t\tif (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n-\t\t\t\tthrow new IllegalStateException(\"no credit available\");\n-\t\t\t}\n-\n-\t\t\treturn new BufferResponseMessage(\n-\t\t\t\tnext.buffer(), receiverId, sequenceNumber, next.unannouncedBacklog(), isAvailable(next));\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic ServerOutboundMessage getNextMessage() throws IOException {\n-\t\t// BufferResponse is processed with higher priority compared with AddBacklog. There are three scenarios\n-\t\t// that we never announce backlog to the consumer through AddBacklog message:\n-\t\t// 1. We have exclusive credits which means unannounced backlog can be always carried by BufferResponse.\n-\t\t//    So AddBacklog message is never needed.\n-\t\t// 2. We already have available credits so we do not need to announce backlog to the consumer to request\n-\t\t//    new ones.\n-\t\t// 3. Next Buffer is an event which does not consume any credit. So we can just send the event and bring\n-\t\t//    the unannounced backlog with it.\n-\t\tif (withoutExclusiveCredits || numCreditsAvailable > 0 || subpartitionView.isAvailable(0)) {\n-\t\t\treturn getBufferResponseMessage();\n-\t\t}\n-\t\treturn getAddBacklogMessage();\n-\t}\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn subpartitionView.isReleased();\n-\t}\n-\n-\t@Override\n-\tpublic Throwable getFailureCause() {\n-\t\treturn subpartitionView.getFailureCause();\n-\t}\n-\n-\t@Override\n-\tpublic void releaseAllResources() throws IOException {\n-\t\tsubpartitionView.releaseAllResources();\n-\t}\n-\n-\t@Override\n-\tpublic void notifyDataAvailable() {\n-\t\trequestQueue.notifyReaderNonEmpty(this);\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"CreditBasedSequenceNumberingViewReader{\" +\n-\t\t\t\"requestLock=\" + requestLock +\n-\t\t\t\", receiverId=\" + receiverId +\n-\t\t\t\", withoutExclusiveCredits=\" + withoutExclusiveCredits +\n-\t\t\t\", sequenceNumber=\" + sequenceNumber +\n-\t\t\t\", numCreditsAvailable=\" + numCreditsAvailable +\n-\t\t\t\", isRegisteredAsAvailable=\" + isRegisteredAsAvailable +\n-\t\t\t'}';\n-\t}\n+class CreditBasedSequenceNumberingViewReader\n+        implements BufferAvailabilityListener, NetworkSequenceViewReader {\n+\n+    private final Object requestLock = new Object();\n+\n+    private final InputChannelID receiverId;\n+\n+    private final PartitionRequestQueue requestQueue;\n+\n+    private final int initialCredit;\n+\n+    private volatile ResultSubpartitionView subpartitionView;\n+\n+    /**\n+     * The status indicating whether this reader is already enqueued in the pipeline for\n+     * transferring data or not.\n+     *\n+     * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n+     * thread only since there is no synchronisation.\n+     */\n+    private boolean isRegisteredAsAvailable = false;\n+\n+    /** The number of available buffers for holding data on the consumer side. */\n+    private int numCreditsAvailable;\n+\n+    CreditBasedSequenceNumberingViewReader(\n+            InputChannelID receiverId, int initialCredit, PartitionRequestQueue requestQueue) {\n+        checkArgument(initialCredit >= 0, \"Must be non-negative.\");\n+\n+        this.receiverId = receiverId;\n+        this.initialCredit = initialCredit;\n+        this.numCreditsAvailable = initialCredit;\n+        this.requestQueue = requestQueue;\n+    }\n+\n+    @Override\n+    public void requestSubpartitionView(\n+            ResultPartitionProvider partitionProvider,\n+            ResultPartitionID resultPartitionId,\n+            int subPartitionIndex)\n+            throws IOException {\n+\n+        synchronized (requestLock) {\n+            if (subpartitionView == null) {\n+                // This call can trigger a notification we have to\n+                // schedule a separate task at the event loop that will\n+                // start consuming this. Otherwise the reference to the\n+                // view cannot be available in getNextBuffer().\n+                this.subpartitionView =\n+                        partitionProvider.createSubpartitionView(\n+                                resultPartitionId, subPartitionIndex, this);\n+            } else {\n+                throw new IllegalStateException(\"Subpartition already requested\");\n+            }\n+        }\n+\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public void addCredit(int creditDeltas) {\n+        numCreditsAvailable += creditDeltas;\n+    }\n+\n+    @Override\n+    public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;\n+        }\n+        subpartitionView.resumeConsumption();\n+    }\n+\n+    @Override\n+    public void acknowledgeAllRecordsProcessed() {\n+        subpartitionView.acknowledgeAllRecordsProcessed();\n+    }\n+\n+    @Override\n+    public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n+        this.isRegisteredAsAvailable = isRegisteredAvailable;\n+    }\n+\n+    @Override\n+    public boolean isRegisteredAsAvailable() {\n+        return isRegisteredAsAvailable;\n+    }\n+\n+    /**\n+     * Returns true only if the next buffer is an event or the reader has both available credits and\n+     * buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such\n+     *     that {@code getNextDataType(bufferAndBacklog) != NONE <=>\n+     *     AvailabilityWithBacklog#isAvailable()}!\n+     */\n+    @Override\n+    public ResultSubpartitionView.AvailabilityWithBacklog getAvailabilityAndBacklog() {\n+        return subpartitionView.getAvailabilityAndBacklog(numCreditsAvailable);\n+    }\n+\n+    /**\n+     * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next\n+     * buffer in line.\n+     *\n+     * <p>Returns the next data type only if the next buffer is an event or the reader has both\n+     * available credits and buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getAvailabilityAndBacklog()}, such that\n+     *     {@code getNextDataType(bufferAndBacklog) != NONE <=>\n+     *     AvailabilityWithBacklog#isAvailable()}!\n+     * @param bufferAndBacklog current buffer and backlog including information about the next\n+     *     buffer\n+     * @return the next data type if the next buffer can be pulled immediately or {@link\n+     *     Buffer.DataType#NONE}\n+     */\n+    private Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n+        final Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+        if (numCreditsAvailable > 0 || nextDataType.isEvent()) {\n+            return nextDataType;\n+        }\n+        return Buffer.DataType.NONE;\n+    }\n+\n+    @Override\n+    public InputChannelID getReceiverId() {\n+        return receiverId;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumCreditsAvailable() {\n+        return numCreditsAvailable;\n+    }\n+\n+    @VisibleForTesting\n+    ResultSubpartitionView.AvailabilityWithBacklog hasBuffersAvailable() {\n+        return subpartitionView.getAvailabilityAndBacklog(Integer.MAX_VALUE);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BufferAndAvailability getNextBuffer() throws IOException {\n+        BufferAndBacklog next = subpartitionView.getNextBuffer();\n+        if (next != null) {\n+            if (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n+                throw new IllegalStateException(\"no credit available\");\n+            }\n+\n+            final Buffer.DataType nextDataType = getNextDataType(next);\n+            return new BufferAndAvailability(\n+                    next.buffer(), nextDataType, next.buffersInBacklog(), next.getSequenceNumber());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        return subpartitionView.isReleased();\n+    }\n+\n+    @Override\n+    public Throwable getFailureCause() {\n+        return subpartitionView.getFailureCause();\n+    }\n+\n+    @Override\n+    public void releaseAllResources() throws IOException {\n+        subpartitionView.releaseAllResources();\n+    }\n+\n+    @Override\n+    public void notifyDataAvailable() {\n+        requestQueue.notifyReaderNonEmpty(this);\n+    }\n+\n+    @Override\n+    public void notifyPriorityEvent(int prioritySequenceNumber) {\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CreditBasedSequenceNumberingViewReader{\"\n+                + \"requestLock=\"\n+                + requestLock\n+                + \", receiverId=\"\n+                + receiverId\n+                + \", numCreditsAvailable=\"\n+                + numCreditsAvailable\n+                + \", isRegisteredAsAvailable=\"\n+                + isRegisteredAsAvailable\n+                + '}';\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3ODcwNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425078707", "body": "initialCredit  == 0", "bodyText": "initialCredit  == 0", "bodyHTML": "<p dir=\"auto\">initialCredit  == 0</p>", "author": "zhijiangW", "createdAt": "2020-05-14T11:54:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -69,6 +73,7 @@\n \t\tthis.receiverId = receiverId;\n \t\tthis.numCreditsAvailable = initialCredit;\n \t\tthis.requestQueue = requestQueue;\n+\t\tthis.withoutExclusiveCredits = initialCredit > 0;", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb4c607a5c4780729143d458b1c7633adcba59bf", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 09ce436d1ec..0c03c332422 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -73,7 +73,7 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t\tthis.receiverId = receiverId;\n \t\tthis.numCreditsAvailable = initialCredit;\n \t\tthis.requestQueue = requestQueue;\n-\t\tthis.withoutExclusiveCredits = initialCredit > 0;\n+\t\tthis.withoutExclusiveCredits = initialCredit == 0;\n \t}\n \n \t@Override\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 0c03c332422..b1a8400b7a1 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -20,227 +20,225 @@ package org.apache.flink.runtime.io.network.netty;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.runtime.io.network.NetworkSequenceViewReader;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.AddBacklogMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.BufferResponseMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.ServerOutboundMessage;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n import org.apache.flink.runtime.io.network.partition.BufferAvailabilityListener;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionProvider;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputChannel.BufferAndAvailability;\n import org.apache.flink.runtime.io.network.partition.consumer.InputChannelID;\n import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n \n+import javax.annotation.Nullable;\n+\n import java.io.IOException;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n+\n /**\n  * Simple wrapper for the subpartition view used in the new network credit-based mode.\n  *\n- * <p>It also keeps track of available buffers and notifies the outbound\n- * handler about non-emptiness, similar to the {@link LocalInputChannel}.\n+ * <p>It also keeps track of available buffers and notifies the outbound handler about\n+ * non-emptiness, similar to the {@link LocalInputChannel}.\n  */\n-class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListener, NetworkSequenceViewReader {\n-\n-\tprivate final Object requestLock = new Object();\n-\n-\tprivate final InputChannelID receiverId;\n-\n-\tprivate final PartitionRequestQueue requestQueue;\n-\n-\tprivate final boolean withoutExclusiveCredits;\n-\n-\tprivate volatile ResultSubpartitionView subpartitionView;\n-\n-\t/**\n-\t * The status indicating whether this reader is already enqueued in the pipeline for transferring\n-\t * data or not.\n-\t *\n-\t * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n-\t * thread only since there is no synchronisation.\n-\t */\n-\tprivate boolean isRegisteredAsAvailable = false;\n-\n-\t/** The number of available buffers for holding data on the consumer side. */\n-\tprivate int numCreditsAvailable;\n-\n-\tprivate int sequenceNumber = -1;\n-\n-\tCreditBasedSequenceNumberingViewReader(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tint initialCredit,\n-\t\t\tPartitionRequestQueue requestQueue) {\n-\n-\t\tthis.receiverId = receiverId;\n-\t\tthis.numCreditsAvailable = initialCredit;\n-\t\tthis.requestQueue = requestQueue;\n-\t\tthis.withoutExclusiveCredits = initialCredit == 0;\n-\t}\n-\n-\t@Override\n-\tpublic void requestSubpartitionView(\n-\t\tResultPartitionProvider partitionProvider,\n-\t\tResultPartitionID resultPartitionId,\n-\t\tint subPartitionIndex) throws IOException {\n-\n-\t\tsynchronized (requestLock) {\n-\t\t\tif (subpartitionView == null) {\n-\t\t\t\t// This this call can trigger a notification we have to\n-\t\t\t\t// schedule a separate task at the event loop that will\n-\t\t\t\t// start consuming this. Otherwise the reference to the\n-\t\t\t\t// view cannot be available in getNextBuffer().\n-\t\t\t\tthis.subpartitionView = partitionProvider.createSubpartitionView(\n-\t\t\t\t\tresultPartitionId,\n-\t\t\t\t\tsubPartitionIndex,\n-\t\t\t\t\tthis);\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalStateException(\"Subpartition already requested\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void addCredit(int creditDeltas) throws Exception {\n-\t\tnumCreditsAvailable += creditDeltas;\n-\t\trequestQueue.enqueueAvailableReader(this, this::isAvailable);\n-\t}\n-\n-\t@Override\n-\tpublic boolean shouldAnnounceBacklog(boolean hasUnfulfilledBacklog) {\n-\t\treturn !hasUnfulfilledBacklog && withoutExclusiveCredits && numCreditsAvailable == 0;\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption(int availableCredits, boolean hasUnfulfilledBacklog) throws Exception {\n-\t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredits;\n-\t\tsubpartitionView.resumeConsumption();\n-\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || shouldAnnounceBacklog(hasUnfulfilledBacklog)));\n-\t}\n-\n-\t@Override\n-\tpublic void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n-\t\tthis.isRegisteredAsAvailable = isRegisteredAvailable;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRegisteredAsAvailable() {\n-\t\treturn isRegisteredAsAvailable;\n-\t}\n-\n-\t/**\n-\t * Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t */\n-\t@Override\n-\tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n-\t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n-\t}\n-\n-\t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n-\t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t *\n-\t * @param bufferAndBacklog\n-\t * \t\tcurrent buffer and backlog including information about the next buffer\n-\t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n-\t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic InputChannelID getReceiverId() {\n-\t\treturn receiverId;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumCreditsAvailable() {\n-\t\treturn numCreditsAvailable;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean hasBuffersAvailable() {\n-\t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\tprivate AddBacklogMessage getAddBacklogMessage() {\n-\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n-\t\tif (backlog > 0) {\n-\t\t\treturn new AddBacklogMessage(receiverId, backlog);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate BufferResponseMessage getBufferResponseMessage() throws IOException {\n-\t\tBufferAndBacklog next = subpartitionView.getNextBuffer();\n-\t\tif (next != null) {\n-\t\t\tsequenceNumber++;\n-\n-\t\t\tif (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n-\t\t\t\tthrow new IllegalStateException(\"no credit available\");\n-\t\t\t}\n-\n-\t\t\treturn new BufferResponseMessage(\n-\t\t\t\tnext.buffer(), receiverId, sequenceNumber, next.unannouncedBacklog(), isAvailable(next));\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic ServerOutboundMessage getNextMessage() throws IOException {\n-\t\t// BufferResponse is processed with higher priority compared with AddBacklog. There are three scenarios\n-\t\t// that we never announce backlog to the consumer through AddBacklog message:\n-\t\t// 1. We have exclusive credits which means unannounced backlog can be always carried by BufferResponse.\n-\t\t//    So AddBacklog message is never needed.\n-\t\t// 2. We already have available credits so we do not need to announce backlog to the consumer to request\n-\t\t//    new ones.\n-\t\t// 3. Next Buffer is an event which does not consume any credit. So we can just send the event and bring\n-\t\t//    the unannounced backlog with it.\n-\t\tif (!withoutExclusiveCredits || numCreditsAvailable > 0 || subpartitionView.isAvailable(0)) {\n-\t\t\treturn getBufferResponseMessage();\n-\t\t}\n-\t\treturn getAddBacklogMessage();\n-\t}\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn subpartitionView.isReleased();\n-\t}\n-\n-\t@Override\n-\tpublic Throwable getFailureCause() {\n-\t\treturn subpartitionView.getFailureCause();\n-\t}\n-\n-\t@Override\n-\tpublic void releaseAllResources() throws IOException {\n-\t\tsubpartitionView.releaseAllResources();\n-\t}\n-\n-\t@Override\n-\tpublic void notifyDataAvailable() {\n-\t\trequestQueue.notifyReaderNonEmpty(this);\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"CreditBasedSequenceNumberingViewReader{\" +\n-\t\t\t\"requestLock=\" + requestLock +\n-\t\t\t\", receiverId=\" + receiverId +\n-\t\t\t\", withoutExclusiveCredits=\" + withoutExclusiveCredits +\n-\t\t\t\", sequenceNumber=\" + sequenceNumber +\n-\t\t\t\", numCreditsAvailable=\" + numCreditsAvailable +\n-\t\t\t\", isRegisteredAsAvailable=\" + isRegisteredAsAvailable +\n-\t\t\t'}';\n-\t}\n+class CreditBasedSequenceNumberingViewReader\n+        implements BufferAvailabilityListener, NetworkSequenceViewReader {\n+\n+    private final Object requestLock = new Object();\n+\n+    private final InputChannelID receiverId;\n+\n+    private final PartitionRequestQueue requestQueue;\n+\n+    private final int initialCredit;\n+\n+    private volatile ResultSubpartitionView subpartitionView;\n+\n+    /**\n+     * The status indicating whether this reader is already enqueued in the pipeline for\n+     * transferring data or not.\n+     *\n+     * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n+     * thread only since there is no synchronisation.\n+     */\n+    private boolean isRegisteredAsAvailable = false;\n+\n+    /** The number of available buffers for holding data on the consumer side. */\n+    private int numCreditsAvailable;\n+\n+    CreditBasedSequenceNumberingViewReader(\n+            InputChannelID receiverId, int initialCredit, PartitionRequestQueue requestQueue) {\n+        checkArgument(initialCredit >= 0, \"Must be non-negative.\");\n+\n+        this.receiverId = receiverId;\n+        this.initialCredit = initialCredit;\n+        this.numCreditsAvailable = initialCredit;\n+        this.requestQueue = requestQueue;\n+    }\n+\n+    @Override\n+    public void requestSubpartitionView(\n+            ResultPartitionProvider partitionProvider,\n+            ResultPartitionID resultPartitionId,\n+            int subPartitionIndex)\n+            throws IOException {\n+\n+        synchronized (requestLock) {\n+            if (subpartitionView == null) {\n+                // This this call can trigger a notification we have to\n+                // schedule a separate task at the event loop that will\n+                // start consuming this. Otherwise the reference to the\n+                // view cannot be available in getNextBuffer().\n+                this.subpartitionView =\n+                        partitionProvider.createSubpartitionView(\n+                                resultPartitionId, subPartitionIndex, this);\n+            } else {\n+                throw new IllegalStateException(\"Subpartition already requested\");\n+            }\n+        }\n+\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public void addCredit(int creditDeltas) {\n+        numCreditsAvailable += creditDeltas;\n+    }\n+\n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n+    @Override\n+    public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;\n+        }\n+\n+        subpartitionView.resumeConsumption();\n+    }\n+\n+    @Override\n+    public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n+        this.isRegisteredAsAvailable = isRegisteredAvailable;\n+    }\n+\n+    @Override\n+    public boolean isRegisteredAsAvailable() {\n+        return isRegisteredAsAvailable;\n+    }\n+\n+    /**\n+     * Returns true only if the next buffer is an event or the reader has both available credits and\n+     * buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such\n+     *     that {@code getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n+     */\n+    @Override\n+    public boolean isAvailable() {\n+        return subpartitionView.isAvailable(numCreditsAvailable);\n+    }\n+\n+    /**\n+     * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next\n+     * buffer in line.\n+     *\n+     * <p>Returns the next data type only if the next buffer is an event or the reader has both\n+     * available credits and buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #isAvailable()}, such that {@code\n+     *     getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n+     * @param bufferAndBacklog current buffer and backlog including information about the next\n+     *     buffer\n+     * @return the next data type if the next buffer can be pulled immediately or {@link\n+     *     Buffer.DataType#NONE}\n+     */\n+    private Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n+        final Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+        if (numCreditsAvailable > 0 || nextDataType.isEvent()) {\n+            return nextDataType;\n+        }\n+        return Buffer.DataType.NONE;\n+    }\n+\n+    @Override\n+    public InputChannelID getReceiverId() {\n+        return receiverId;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumCreditsAvailable() {\n+        return numCreditsAvailable;\n+    }\n+\n+    @VisibleForTesting\n+    boolean hasBuffersAvailable() {\n+        return subpartitionView.isAvailable(Integer.MAX_VALUE);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BufferAndAvailability getNextBuffer() throws IOException {\n+        BufferAndBacklog next = subpartitionView.getNextBuffer();\n+        if (next != null) {\n+            if (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n+                throw new IllegalStateException(\"no credit available\");\n+            }\n+\n+            final Buffer.DataType nextDataType = getNextDataType(next);\n+            return new BufferAndAvailability(\n+                    next.buffer(), nextDataType, next.buffersInBacklog(), next.getSequenceNumber());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public int getRemainingBacklog() {\n+        return subpartitionView.getRemainingBacklog();\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        return subpartitionView.isReleased();\n+    }\n+\n+    @Override\n+    public Throwable getFailureCause() {\n+        return subpartitionView.getFailureCause();\n+    }\n+\n+    @Override\n+    public void releaseAllResources() throws IOException {\n+        subpartitionView.releaseAllResources();\n+    }\n+\n+    @Override\n+    public void notifyDataAvailable() {\n+        requestQueue.notifyReaderNonEmpty(this);\n+    }\n+\n+    @Override\n+    public void notifyPriorityEvent(int prioritySequenceNumber) {\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CreditBasedSequenceNumberingViewReader{\"\n+                + \"requestLock=\"\n+                + requestLock\n+                + \", receiverId=\"\n+                + receiverId\n+                + \", numCreditsAvailable=\"\n+                + numCreditsAvailable\n+                + \", isRegisteredAsAvailable=\"\n+                + isRegisteredAsAvailable\n+                + '}';\n+    }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 09ce436d1ec..01d08d5f53c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -20,227 +20,226 @@ package org.apache.flink.runtime.io.network.netty;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.runtime.io.network.NetworkSequenceViewReader;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.AddBacklogMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.BufferResponseMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.ServerOutboundMessage;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n import org.apache.flink.runtime.io.network.partition.BufferAvailabilityListener;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionProvider;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputChannel.BufferAndAvailability;\n import org.apache.flink.runtime.io.network.partition.consumer.InputChannelID;\n import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n \n+import javax.annotation.Nullable;\n+\n import java.io.IOException;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n+\n /**\n  * Simple wrapper for the subpartition view used in the new network credit-based mode.\n  *\n- * <p>It also keeps track of available buffers and notifies the outbound\n- * handler about non-emptiness, similar to the {@link LocalInputChannel}.\n+ * <p>It also keeps track of available buffers and notifies the outbound handler about\n+ * non-emptiness, similar to the {@link LocalInputChannel}.\n  */\n-class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListener, NetworkSequenceViewReader {\n-\n-\tprivate final Object requestLock = new Object();\n-\n-\tprivate final InputChannelID receiverId;\n-\n-\tprivate final PartitionRequestQueue requestQueue;\n-\n-\tprivate final boolean withoutExclusiveCredits;\n-\n-\tprivate volatile ResultSubpartitionView subpartitionView;\n-\n-\t/**\n-\t * The status indicating whether this reader is already enqueued in the pipeline for transferring\n-\t * data or not.\n-\t *\n-\t * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n-\t * thread only since there is no synchronisation.\n-\t */\n-\tprivate boolean isRegisteredAsAvailable = false;\n-\n-\t/** The number of available buffers for holding data on the consumer side. */\n-\tprivate int numCreditsAvailable;\n-\n-\tprivate int sequenceNumber = -1;\n-\n-\tCreditBasedSequenceNumberingViewReader(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tint initialCredit,\n-\t\t\tPartitionRequestQueue requestQueue) {\n-\n-\t\tthis.receiverId = receiverId;\n-\t\tthis.numCreditsAvailable = initialCredit;\n-\t\tthis.requestQueue = requestQueue;\n-\t\tthis.withoutExclusiveCredits = initialCredit > 0;\n-\t}\n-\n-\t@Override\n-\tpublic void requestSubpartitionView(\n-\t\tResultPartitionProvider partitionProvider,\n-\t\tResultPartitionID resultPartitionId,\n-\t\tint subPartitionIndex) throws IOException {\n-\n-\t\tsynchronized (requestLock) {\n-\t\t\tif (subpartitionView == null) {\n-\t\t\t\t// This this call can trigger a notification we have to\n-\t\t\t\t// schedule a separate task at the event loop that will\n-\t\t\t\t// start consuming this. Otherwise the reference to the\n-\t\t\t\t// view cannot be available in getNextBuffer().\n-\t\t\t\tthis.subpartitionView = partitionProvider.createSubpartitionView(\n-\t\t\t\t\tresultPartitionId,\n-\t\t\t\t\tsubPartitionIndex,\n-\t\t\t\t\tthis);\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalStateException(\"Subpartition already requested\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void addCredit(int creditDeltas) throws Exception {\n-\t\tnumCreditsAvailable += creditDeltas;\n-\t\trequestQueue.enqueueAvailableReader(this, this::isAvailable);\n-\t}\n-\n-\t@Override\n-\tpublic boolean shouldAnnounceBacklog() {\n-\t\treturn !withoutExclusiveCredits && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption(int availableCredit, boolean hasUnfulfilledBacklog) throws Exception {\n-\t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredit;\n-\t\tsubpartitionView.resumeConsumption();\n-\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || !hasUnfulfilledBacklog && shouldAnnounceBacklog()));\n-\t}\n-\n-\t@Override\n-\tpublic void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n-\t\tthis.isRegisteredAsAvailable = isRegisteredAvailable;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRegisteredAsAvailable() {\n-\t\treturn isRegisteredAsAvailable;\n-\t}\n-\n-\t/**\n-\t * Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t */\n-\t@Override\n-\tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n-\t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n-\t}\n-\n-\t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n-\t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t *\n-\t * @param bufferAndBacklog\n-\t * \t\tcurrent buffer and backlog including information about the next buffer\n-\t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n-\t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic InputChannelID getReceiverId() {\n-\t\treturn receiverId;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumCreditsAvailable() {\n-\t\treturn numCreditsAvailable;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean hasBuffersAvailable() {\n-\t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\tprivate AddBacklogMessage getAddBacklogMessage() {\n-\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n-\t\tif (backlog > 0) {\n-\t\t\treturn new AddBacklogMessage(receiverId, backlog, false);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate BufferResponseMessage getBufferResponseMessage() throws IOException {\n-\t\tBufferAndBacklog next = subpartitionView.getNextBuffer();\n-\t\tif (next != null) {\n-\t\t\tsequenceNumber++;\n-\n-\t\t\tif (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n-\t\t\t\tthrow new IllegalStateException(\"no credit available\");\n-\t\t\t}\n-\n-\t\t\treturn new BufferResponseMessage(\n-\t\t\t\tnext.buffer(), receiverId, sequenceNumber, next.unannouncedBacklog(), isAvailable(next));\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic ServerOutboundMessage getNextMessage() throws IOException {\n-\t\t// BufferResponse is processed with higher priority compared with AddBacklog. There are three scenarios\n-\t\t// that we never announce backlog to the consumer through AddBacklog message:\n-\t\t// 1. We have exclusive credits which means unannounced backlog can be always carried by BufferResponse.\n-\t\t//    So AddBacklog message is never needed.\n-\t\t// 2. We already have available credits so we do not need to announce backlog to the consumer to request\n-\t\t//    new ones.\n-\t\t// 3. Next Buffer is an event which does not consume any credit. So we can just send the event and bring\n-\t\t//    the unannounced backlog with it.\n-\t\tif (withoutExclusiveCredits || numCreditsAvailable > 0 || subpartitionView.isAvailable(0)) {\n-\t\t\treturn getBufferResponseMessage();\n-\t\t}\n-\t\treturn getAddBacklogMessage();\n-\t}\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn subpartitionView.isReleased();\n-\t}\n-\n-\t@Override\n-\tpublic Throwable getFailureCause() {\n-\t\treturn subpartitionView.getFailureCause();\n-\t}\n-\n-\t@Override\n-\tpublic void releaseAllResources() throws IOException {\n-\t\tsubpartitionView.releaseAllResources();\n-\t}\n-\n-\t@Override\n-\tpublic void notifyDataAvailable() {\n-\t\trequestQueue.notifyReaderNonEmpty(this);\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"CreditBasedSequenceNumberingViewReader{\" +\n-\t\t\t\"requestLock=\" + requestLock +\n-\t\t\t\", receiverId=\" + receiverId +\n-\t\t\t\", withoutExclusiveCredits=\" + withoutExclusiveCredits +\n-\t\t\t\", sequenceNumber=\" + sequenceNumber +\n-\t\t\t\", numCreditsAvailable=\" + numCreditsAvailable +\n-\t\t\t\", isRegisteredAsAvailable=\" + isRegisteredAsAvailable +\n-\t\t\t'}';\n-\t}\n+class CreditBasedSequenceNumberingViewReader\n+        implements BufferAvailabilityListener, NetworkSequenceViewReader {\n+\n+    private final Object requestLock = new Object();\n+\n+    private final InputChannelID receiverId;\n+\n+    private final PartitionRequestQueue requestQueue;\n+\n+    private final int initialCredit;\n+\n+    private volatile ResultSubpartitionView subpartitionView;\n+\n+    /**\n+     * The status indicating whether this reader is already enqueued in the pipeline for\n+     * transferring data or not.\n+     *\n+     * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n+     * thread only since there is no synchronisation.\n+     */\n+    private boolean isRegisteredAsAvailable = false;\n+\n+    /** The number of available buffers for holding data on the consumer side. */\n+    private int numCreditsAvailable;\n+\n+    CreditBasedSequenceNumberingViewReader(\n+            InputChannelID receiverId, int initialCredit, PartitionRequestQueue requestQueue) {\n+        checkArgument(initialCredit >= 0, \"Must be non-negative.\");\n+\n+        this.receiverId = receiverId;\n+        this.initialCredit = initialCredit;\n+        this.numCreditsAvailable = initialCredit;\n+        this.requestQueue = requestQueue;\n+    }\n+\n+    @Override\n+    public void requestSubpartitionView(\n+            ResultPartitionProvider partitionProvider,\n+            ResultPartitionID resultPartitionId,\n+            int subPartitionIndex)\n+            throws IOException {\n+\n+        synchronized (requestLock) {\n+            if (subpartitionView == null) {\n+                // This call can trigger a notification we have to\n+                // schedule a separate task at the event loop that will\n+                // start consuming this. Otherwise the reference to the\n+                // view cannot be available in getNextBuffer().\n+                this.subpartitionView =\n+                        partitionProvider.createSubpartitionView(\n+                                resultPartitionId, subPartitionIndex, this);\n+            } else {\n+                throw new IllegalStateException(\"Subpartition already requested\");\n+            }\n+        }\n+\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public void addCredit(int creditDeltas) {\n+        numCreditsAvailable += creditDeltas;\n+    }\n+\n+    @Override\n+    public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;\n+        }\n+        subpartitionView.resumeConsumption();\n+    }\n+\n+    @Override\n+    public void acknowledgeAllRecordsProcessed() {\n+        subpartitionView.acknowledgeAllRecordsProcessed();\n+    }\n+\n+    @Override\n+    public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n+        this.isRegisteredAsAvailable = isRegisteredAvailable;\n+    }\n+\n+    @Override\n+    public boolean isRegisteredAsAvailable() {\n+        return isRegisteredAsAvailable;\n+    }\n+\n+    /**\n+     * Returns true only if the next buffer is an event or the reader has both available credits and\n+     * buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such\n+     *     that {@code getNextDataType(bufferAndBacklog) != NONE <=>\n+     *     AvailabilityWithBacklog#isAvailable()}!\n+     */\n+    @Override\n+    public ResultSubpartitionView.AvailabilityWithBacklog getAvailabilityAndBacklog() {\n+        return subpartitionView.getAvailabilityAndBacklog(numCreditsAvailable);\n+    }\n+\n+    /**\n+     * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next\n+     * buffer in line.\n+     *\n+     * <p>Returns the next data type only if the next buffer is an event or the reader has both\n+     * available credits and buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getAvailabilityAndBacklog()}, such that\n+     *     {@code getNextDataType(bufferAndBacklog) != NONE <=>\n+     *     AvailabilityWithBacklog#isAvailable()}!\n+     * @param bufferAndBacklog current buffer and backlog including information about the next\n+     *     buffer\n+     * @return the next data type if the next buffer can be pulled immediately or {@link\n+     *     Buffer.DataType#NONE}\n+     */\n+    private Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n+        final Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+        if (numCreditsAvailable > 0 || nextDataType.isEvent()) {\n+            return nextDataType;\n+        }\n+        return Buffer.DataType.NONE;\n+    }\n+\n+    @Override\n+    public InputChannelID getReceiverId() {\n+        return receiverId;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumCreditsAvailable() {\n+        return numCreditsAvailable;\n+    }\n+\n+    @VisibleForTesting\n+    ResultSubpartitionView.AvailabilityWithBacklog hasBuffersAvailable() {\n+        return subpartitionView.getAvailabilityAndBacklog(Integer.MAX_VALUE);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BufferAndAvailability getNextBuffer() throws IOException {\n+        BufferAndBacklog next = subpartitionView.getNextBuffer();\n+        if (next != null) {\n+            if (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n+                throw new IllegalStateException(\"no credit available\");\n+            }\n+\n+            final Buffer.DataType nextDataType = getNextDataType(next);\n+            return new BufferAndAvailability(\n+                    next.buffer(), nextDataType, next.buffersInBacklog(), next.getSequenceNumber());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        return subpartitionView.isReleased();\n+    }\n+\n+    @Override\n+    public Throwable getFailureCause() {\n+        return subpartitionView.getFailureCause();\n+    }\n+\n+    @Override\n+    public void releaseAllResources() throws IOException {\n+        subpartitionView.releaseAllResources();\n+    }\n+\n+    @Override\n+    public void notifyDataAvailable() {\n+        requestQueue.notifyReaderNonEmpty(this);\n+    }\n+\n+    @Override\n+    public void notifyPriorityEvent(int prioritySequenceNumber) {\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CreditBasedSequenceNumberingViewReader{\"\n+                + \"requestLock=\"\n+                + requestLock\n+                + \", receiverId=\"\n+                + receiverId\n+                + \", numCreditsAvailable=\"\n+                + numCreditsAvailable\n+                + \", isRegisteredAsAvailable=\"\n+                + isRegisteredAsAvailable\n+                + '}';\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3OTMzOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425079339", "body": "nit: availableCredit -> availableCredits", "bodyText": "nit: availableCredit -> availableCredits", "bodyHTML": "<p dir=\"auto\">nit: availableCredit -&gt; availableCredits</p>", "author": "zhijiangW", "createdAt": "2020-05-14T11:55:25Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -94,13 +99,22 @@ public void requestSubpartitionView(\n \t}\n \n \t@Override\n-\tpublic void addCredit(int creditDeltas) {\n+\tpublic void addCredit(int creditDeltas) throws Exception {\n \t\tnumCreditsAvailable += creditDeltas;\n+\t\trequestQueue.enqueueAvailableReader(this, this::isAvailable);\n+\t}\n+\n+\t@Override\n+\tpublic boolean shouldAnnounceBacklog() {\n+\t\treturn !withoutExclusiveCredits && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n \t}\n \n \t@Override\n-\tpublic void resumeConsumption() {\n+\tpublic void resumeConsumption(int availableCredit, boolean hasUnfulfilledBacklog) throws Exception {", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb4c607a5c4780729143d458b1c7633adcba59bf", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 09ce436d1ec..0c03c332422 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -105,16 +105,16 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t}\n \n \t@Override\n-\tpublic boolean shouldAnnounceBacklog() {\n-\t\treturn !withoutExclusiveCredits && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n+\tpublic boolean shouldAnnounceBacklog(boolean hasUnfulfilledBacklog) {\n+\t\treturn !hasUnfulfilledBacklog && withoutExclusiveCredits && numCreditsAvailable == 0;\n \t}\n \n \t@Override\n-\tpublic void resumeConsumption(int availableCredit, boolean hasUnfulfilledBacklog) throws Exception {\n+\tpublic void resumeConsumption(int availableCredits, boolean hasUnfulfilledBacklog) throws Exception {\n \t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredit;\n+\t\tnumCreditsAvailable = availableCredits;\n \t\tsubpartitionView.resumeConsumption();\n-\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || !hasUnfulfilledBacklog && shouldAnnounceBacklog()));\n+\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || shouldAnnounceBacklog(hasUnfulfilledBacklog)));\n \t}\n \n \t@Override\n", "next_change": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 0c03c332422..b1a8400b7a1 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -20,227 +20,225 @@ package org.apache.flink.runtime.io.network.netty;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.runtime.io.network.NetworkSequenceViewReader;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.AddBacklogMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.BufferResponseMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.ServerOutboundMessage;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n import org.apache.flink.runtime.io.network.partition.BufferAvailabilityListener;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionProvider;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputChannel.BufferAndAvailability;\n import org.apache.flink.runtime.io.network.partition.consumer.InputChannelID;\n import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n \n+import javax.annotation.Nullable;\n+\n import java.io.IOException;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n+\n /**\n  * Simple wrapper for the subpartition view used in the new network credit-based mode.\n  *\n- * <p>It also keeps track of available buffers and notifies the outbound\n- * handler about non-emptiness, similar to the {@link LocalInputChannel}.\n+ * <p>It also keeps track of available buffers and notifies the outbound handler about\n+ * non-emptiness, similar to the {@link LocalInputChannel}.\n  */\n-class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListener, NetworkSequenceViewReader {\n-\n-\tprivate final Object requestLock = new Object();\n-\n-\tprivate final InputChannelID receiverId;\n-\n-\tprivate final PartitionRequestQueue requestQueue;\n-\n-\tprivate final boolean withoutExclusiveCredits;\n-\n-\tprivate volatile ResultSubpartitionView subpartitionView;\n-\n-\t/**\n-\t * The status indicating whether this reader is already enqueued in the pipeline for transferring\n-\t * data or not.\n-\t *\n-\t * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n-\t * thread only since there is no synchronisation.\n-\t */\n-\tprivate boolean isRegisteredAsAvailable = false;\n-\n-\t/** The number of available buffers for holding data on the consumer side. */\n-\tprivate int numCreditsAvailable;\n-\n-\tprivate int sequenceNumber = -1;\n-\n-\tCreditBasedSequenceNumberingViewReader(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tint initialCredit,\n-\t\t\tPartitionRequestQueue requestQueue) {\n-\n-\t\tthis.receiverId = receiverId;\n-\t\tthis.numCreditsAvailable = initialCredit;\n-\t\tthis.requestQueue = requestQueue;\n-\t\tthis.withoutExclusiveCredits = initialCredit == 0;\n-\t}\n-\n-\t@Override\n-\tpublic void requestSubpartitionView(\n-\t\tResultPartitionProvider partitionProvider,\n-\t\tResultPartitionID resultPartitionId,\n-\t\tint subPartitionIndex) throws IOException {\n-\n-\t\tsynchronized (requestLock) {\n-\t\t\tif (subpartitionView == null) {\n-\t\t\t\t// This this call can trigger a notification we have to\n-\t\t\t\t// schedule a separate task at the event loop that will\n-\t\t\t\t// start consuming this. Otherwise the reference to the\n-\t\t\t\t// view cannot be available in getNextBuffer().\n-\t\t\t\tthis.subpartitionView = partitionProvider.createSubpartitionView(\n-\t\t\t\t\tresultPartitionId,\n-\t\t\t\t\tsubPartitionIndex,\n-\t\t\t\t\tthis);\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalStateException(\"Subpartition already requested\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void addCredit(int creditDeltas) throws Exception {\n-\t\tnumCreditsAvailable += creditDeltas;\n-\t\trequestQueue.enqueueAvailableReader(this, this::isAvailable);\n-\t}\n-\n-\t@Override\n-\tpublic boolean shouldAnnounceBacklog(boolean hasUnfulfilledBacklog) {\n-\t\treturn !hasUnfulfilledBacklog && withoutExclusiveCredits && numCreditsAvailable == 0;\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption(int availableCredits, boolean hasUnfulfilledBacklog) throws Exception {\n-\t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredits;\n-\t\tsubpartitionView.resumeConsumption();\n-\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || shouldAnnounceBacklog(hasUnfulfilledBacklog)));\n-\t}\n-\n-\t@Override\n-\tpublic void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n-\t\tthis.isRegisteredAsAvailable = isRegisteredAvailable;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRegisteredAsAvailable() {\n-\t\treturn isRegisteredAsAvailable;\n-\t}\n-\n-\t/**\n-\t * Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t */\n-\t@Override\n-\tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n-\t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n-\t}\n-\n-\t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n-\t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t *\n-\t * @param bufferAndBacklog\n-\t * \t\tcurrent buffer and backlog including information about the next buffer\n-\t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n-\t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic InputChannelID getReceiverId() {\n-\t\treturn receiverId;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumCreditsAvailable() {\n-\t\treturn numCreditsAvailable;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean hasBuffersAvailable() {\n-\t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\tprivate AddBacklogMessage getAddBacklogMessage() {\n-\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n-\t\tif (backlog > 0) {\n-\t\t\treturn new AddBacklogMessage(receiverId, backlog);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate BufferResponseMessage getBufferResponseMessage() throws IOException {\n-\t\tBufferAndBacklog next = subpartitionView.getNextBuffer();\n-\t\tif (next != null) {\n-\t\t\tsequenceNumber++;\n-\n-\t\t\tif (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n-\t\t\t\tthrow new IllegalStateException(\"no credit available\");\n-\t\t\t}\n-\n-\t\t\treturn new BufferResponseMessage(\n-\t\t\t\tnext.buffer(), receiverId, sequenceNumber, next.unannouncedBacklog(), isAvailable(next));\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic ServerOutboundMessage getNextMessage() throws IOException {\n-\t\t// BufferResponse is processed with higher priority compared with AddBacklog. There are three scenarios\n-\t\t// that we never announce backlog to the consumer through AddBacklog message:\n-\t\t// 1. We have exclusive credits which means unannounced backlog can be always carried by BufferResponse.\n-\t\t//    So AddBacklog message is never needed.\n-\t\t// 2. We already have available credits so we do not need to announce backlog to the consumer to request\n-\t\t//    new ones.\n-\t\t// 3. Next Buffer is an event which does not consume any credit. So we can just send the event and bring\n-\t\t//    the unannounced backlog with it.\n-\t\tif (!withoutExclusiveCredits || numCreditsAvailable > 0 || subpartitionView.isAvailable(0)) {\n-\t\t\treturn getBufferResponseMessage();\n-\t\t}\n-\t\treturn getAddBacklogMessage();\n-\t}\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn subpartitionView.isReleased();\n-\t}\n-\n-\t@Override\n-\tpublic Throwable getFailureCause() {\n-\t\treturn subpartitionView.getFailureCause();\n-\t}\n-\n-\t@Override\n-\tpublic void releaseAllResources() throws IOException {\n-\t\tsubpartitionView.releaseAllResources();\n-\t}\n-\n-\t@Override\n-\tpublic void notifyDataAvailable() {\n-\t\trequestQueue.notifyReaderNonEmpty(this);\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"CreditBasedSequenceNumberingViewReader{\" +\n-\t\t\t\"requestLock=\" + requestLock +\n-\t\t\t\", receiverId=\" + receiverId +\n-\t\t\t\", withoutExclusiveCredits=\" + withoutExclusiveCredits +\n-\t\t\t\", sequenceNumber=\" + sequenceNumber +\n-\t\t\t\", numCreditsAvailable=\" + numCreditsAvailable +\n-\t\t\t\", isRegisteredAsAvailable=\" + isRegisteredAsAvailable +\n-\t\t\t'}';\n-\t}\n+class CreditBasedSequenceNumberingViewReader\n+        implements BufferAvailabilityListener, NetworkSequenceViewReader {\n+\n+    private final Object requestLock = new Object();\n+\n+    private final InputChannelID receiverId;\n+\n+    private final PartitionRequestQueue requestQueue;\n+\n+    private final int initialCredit;\n+\n+    private volatile ResultSubpartitionView subpartitionView;\n+\n+    /**\n+     * The status indicating whether this reader is already enqueued in the pipeline for\n+     * transferring data or not.\n+     *\n+     * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n+     * thread only since there is no synchronisation.\n+     */\n+    private boolean isRegisteredAsAvailable = false;\n+\n+    /** The number of available buffers for holding data on the consumer side. */\n+    private int numCreditsAvailable;\n+\n+    CreditBasedSequenceNumberingViewReader(\n+            InputChannelID receiverId, int initialCredit, PartitionRequestQueue requestQueue) {\n+        checkArgument(initialCredit >= 0, \"Must be non-negative.\");\n+\n+        this.receiverId = receiverId;\n+        this.initialCredit = initialCredit;\n+        this.numCreditsAvailable = initialCredit;\n+        this.requestQueue = requestQueue;\n+    }\n+\n+    @Override\n+    public void requestSubpartitionView(\n+            ResultPartitionProvider partitionProvider,\n+            ResultPartitionID resultPartitionId,\n+            int subPartitionIndex)\n+            throws IOException {\n+\n+        synchronized (requestLock) {\n+            if (subpartitionView == null) {\n+                // This this call can trigger a notification we have to\n+                // schedule a separate task at the event loop that will\n+                // start consuming this. Otherwise the reference to the\n+                // view cannot be available in getNextBuffer().\n+                this.subpartitionView =\n+                        partitionProvider.createSubpartitionView(\n+                                resultPartitionId, subPartitionIndex, this);\n+            } else {\n+                throw new IllegalStateException(\"Subpartition already requested\");\n+            }\n+        }\n+\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public void addCredit(int creditDeltas) {\n+        numCreditsAvailable += creditDeltas;\n+    }\n+\n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n+    @Override\n+    public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;\n+        }\n+\n+        subpartitionView.resumeConsumption();\n+    }\n+\n+    @Override\n+    public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n+        this.isRegisteredAsAvailable = isRegisteredAvailable;\n+    }\n+\n+    @Override\n+    public boolean isRegisteredAsAvailable() {\n+        return isRegisteredAsAvailable;\n+    }\n+\n+    /**\n+     * Returns true only if the next buffer is an event or the reader has both available credits and\n+     * buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such\n+     *     that {@code getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n+     */\n+    @Override\n+    public boolean isAvailable() {\n+        return subpartitionView.isAvailable(numCreditsAvailable);\n+    }\n+\n+    /**\n+     * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next\n+     * buffer in line.\n+     *\n+     * <p>Returns the next data type only if the next buffer is an event or the reader has both\n+     * available credits and buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #isAvailable()}, such that {@code\n+     *     getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n+     * @param bufferAndBacklog current buffer and backlog including information about the next\n+     *     buffer\n+     * @return the next data type if the next buffer can be pulled immediately or {@link\n+     *     Buffer.DataType#NONE}\n+     */\n+    private Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n+        final Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+        if (numCreditsAvailable > 0 || nextDataType.isEvent()) {\n+            return nextDataType;\n+        }\n+        return Buffer.DataType.NONE;\n+    }\n+\n+    @Override\n+    public InputChannelID getReceiverId() {\n+        return receiverId;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumCreditsAvailable() {\n+        return numCreditsAvailable;\n+    }\n+\n+    @VisibleForTesting\n+    boolean hasBuffersAvailable() {\n+        return subpartitionView.isAvailable(Integer.MAX_VALUE);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BufferAndAvailability getNextBuffer() throws IOException {\n+        BufferAndBacklog next = subpartitionView.getNextBuffer();\n+        if (next != null) {\n+            if (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n+                throw new IllegalStateException(\"no credit available\");\n+            }\n+\n+            final Buffer.DataType nextDataType = getNextDataType(next);\n+            return new BufferAndAvailability(\n+                    next.buffer(), nextDataType, next.buffersInBacklog(), next.getSequenceNumber());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public int getRemainingBacklog() {\n+        return subpartitionView.getRemainingBacklog();\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        return subpartitionView.isReleased();\n+    }\n+\n+    @Override\n+    public Throwable getFailureCause() {\n+        return subpartitionView.getFailureCause();\n+    }\n+\n+    @Override\n+    public void releaseAllResources() throws IOException {\n+        subpartitionView.releaseAllResources();\n+    }\n+\n+    @Override\n+    public void notifyDataAvailable() {\n+        requestQueue.notifyReaderNonEmpty(this);\n+    }\n+\n+    @Override\n+    public void notifyPriorityEvent(int prioritySequenceNumber) {\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CreditBasedSequenceNumberingViewReader{\"\n+                + \"requestLock=\"\n+                + requestLock\n+                + \", receiverId=\"\n+                + receiverId\n+                + \", numCreditsAvailable=\"\n+                + numCreditsAvailable\n+                + \", isRegisteredAsAvailable=\"\n+                + isRegisteredAsAvailable\n+                + '}';\n+    }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 09ce436d1ec..01d08d5f53c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -20,227 +20,226 @@ package org.apache.flink.runtime.io.network.netty;\n \n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.runtime.io.network.NetworkSequenceViewReader;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.AddBacklogMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.BufferResponseMessage;\n-import org.apache.flink.runtime.io.network.netty.PartitionRequestQueue.ServerOutboundMessage;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n import org.apache.flink.runtime.io.network.partition.BufferAvailabilityListener;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionID;\n import org.apache.flink.runtime.io.network.partition.ResultPartitionProvider;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;\n import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputChannel.BufferAndAvailability;\n import org.apache.flink.runtime.io.network.partition.consumer.InputChannelID;\n import org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel;\n \n+import javax.annotation.Nullable;\n+\n import java.io.IOException;\n \n+import static org.apache.flink.util.Preconditions.checkArgument;\n+\n /**\n  * Simple wrapper for the subpartition view used in the new network credit-based mode.\n  *\n- * <p>It also keeps track of available buffers and notifies the outbound\n- * handler about non-emptiness, similar to the {@link LocalInputChannel}.\n+ * <p>It also keeps track of available buffers and notifies the outbound handler about\n+ * non-emptiness, similar to the {@link LocalInputChannel}.\n  */\n-class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListener, NetworkSequenceViewReader {\n-\n-\tprivate final Object requestLock = new Object();\n-\n-\tprivate final InputChannelID receiverId;\n-\n-\tprivate final PartitionRequestQueue requestQueue;\n-\n-\tprivate final boolean withoutExclusiveCredits;\n-\n-\tprivate volatile ResultSubpartitionView subpartitionView;\n-\n-\t/**\n-\t * The status indicating whether this reader is already enqueued in the pipeline for transferring\n-\t * data or not.\n-\t *\n-\t * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n-\t * thread only since there is no synchronisation.\n-\t */\n-\tprivate boolean isRegisteredAsAvailable = false;\n-\n-\t/** The number of available buffers for holding data on the consumer side. */\n-\tprivate int numCreditsAvailable;\n-\n-\tprivate int sequenceNumber = -1;\n-\n-\tCreditBasedSequenceNumberingViewReader(\n-\t\t\tInputChannelID receiverId,\n-\t\t\tint initialCredit,\n-\t\t\tPartitionRequestQueue requestQueue) {\n-\n-\t\tthis.receiverId = receiverId;\n-\t\tthis.numCreditsAvailable = initialCredit;\n-\t\tthis.requestQueue = requestQueue;\n-\t\tthis.withoutExclusiveCredits = initialCredit > 0;\n-\t}\n-\n-\t@Override\n-\tpublic void requestSubpartitionView(\n-\t\tResultPartitionProvider partitionProvider,\n-\t\tResultPartitionID resultPartitionId,\n-\t\tint subPartitionIndex) throws IOException {\n-\n-\t\tsynchronized (requestLock) {\n-\t\t\tif (subpartitionView == null) {\n-\t\t\t\t// This this call can trigger a notification we have to\n-\t\t\t\t// schedule a separate task at the event loop that will\n-\t\t\t\t// start consuming this. Otherwise the reference to the\n-\t\t\t\t// view cannot be available in getNextBuffer().\n-\t\t\t\tthis.subpartitionView = partitionProvider.createSubpartitionView(\n-\t\t\t\t\tresultPartitionId,\n-\t\t\t\t\tsubPartitionIndex,\n-\t\t\t\t\tthis);\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalStateException(\"Subpartition already requested\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void addCredit(int creditDeltas) throws Exception {\n-\t\tnumCreditsAvailable += creditDeltas;\n-\t\trequestQueue.enqueueAvailableReader(this, this::isAvailable);\n-\t}\n-\n-\t@Override\n-\tpublic boolean shouldAnnounceBacklog() {\n-\t\treturn !withoutExclusiveCredits && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\t@Override\n-\tpublic void resumeConsumption(int availableCredit, boolean hasUnfulfilledBacklog) throws Exception {\n-\t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredit;\n-\t\tsubpartitionView.resumeConsumption();\n-\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || !hasUnfulfilledBacklog && shouldAnnounceBacklog()));\n-\t}\n-\n-\t@Override\n-\tpublic void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n-\t\tthis.isRegisteredAsAvailable = isRegisteredAvailable;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isRegisteredAsAvailable() {\n-\t\treturn isRegisteredAsAvailable;\n-\t}\n-\n-\t/**\n-\t * Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t */\n-\t@Override\n-\tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n-\t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n-\t}\n-\n-\t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n-\t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n-\t * credits and buffers.\n-\t *\n-\t * @param bufferAndBacklog\n-\t * \t\tcurrent buffer and backlog including information about the next buffer\n-\t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n-\t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic InputChannelID getReceiverId() {\n-\t\treturn receiverId;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumCreditsAvailable() {\n-\t\treturn numCreditsAvailable;\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean hasBuffersAvailable() {\n-\t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n-\t}\n-\n-\tprivate AddBacklogMessage getAddBacklogMessage() {\n-\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n-\t\tif (backlog > 0) {\n-\t\t\treturn new AddBacklogMessage(receiverId, backlog, false);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tprivate BufferResponseMessage getBufferResponseMessage() throws IOException {\n-\t\tBufferAndBacklog next = subpartitionView.getNextBuffer();\n-\t\tif (next != null) {\n-\t\t\tsequenceNumber++;\n-\n-\t\t\tif (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n-\t\t\t\tthrow new IllegalStateException(\"no credit available\");\n-\t\t\t}\n-\n-\t\t\treturn new BufferResponseMessage(\n-\t\t\t\tnext.buffer(), receiverId, sequenceNumber, next.unannouncedBacklog(), isAvailable(next));\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic ServerOutboundMessage getNextMessage() throws IOException {\n-\t\t// BufferResponse is processed with higher priority compared with AddBacklog. There are three scenarios\n-\t\t// that we never announce backlog to the consumer through AddBacklog message:\n-\t\t// 1. We have exclusive credits which means unannounced backlog can be always carried by BufferResponse.\n-\t\t//    So AddBacklog message is never needed.\n-\t\t// 2. We already have available credits so we do not need to announce backlog to the consumer to request\n-\t\t//    new ones.\n-\t\t// 3. Next Buffer is an event which does not consume any credit. So we can just send the event and bring\n-\t\t//    the unannounced backlog with it.\n-\t\tif (withoutExclusiveCredits || numCreditsAvailable > 0 || subpartitionView.isAvailable(0)) {\n-\t\t\treturn getBufferResponseMessage();\n-\t\t}\n-\t\treturn getAddBacklogMessage();\n-\t}\n-\n-\t@Override\n-\tpublic boolean isReleased() {\n-\t\treturn subpartitionView.isReleased();\n-\t}\n-\n-\t@Override\n-\tpublic Throwable getFailureCause() {\n-\t\treturn subpartitionView.getFailureCause();\n-\t}\n-\n-\t@Override\n-\tpublic void releaseAllResources() throws IOException {\n-\t\tsubpartitionView.releaseAllResources();\n-\t}\n-\n-\t@Override\n-\tpublic void notifyDataAvailable() {\n-\t\trequestQueue.notifyReaderNonEmpty(this);\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"CreditBasedSequenceNumberingViewReader{\" +\n-\t\t\t\"requestLock=\" + requestLock +\n-\t\t\t\", receiverId=\" + receiverId +\n-\t\t\t\", withoutExclusiveCredits=\" + withoutExclusiveCredits +\n-\t\t\t\", sequenceNumber=\" + sequenceNumber +\n-\t\t\t\", numCreditsAvailable=\" + numCreditsAvailable +\n-\t\t\t\", isRegisteredAsAvailable=\" + isRegisteredAsAvailable +\n-\t\t\t'}';\n-\t}\n+class CreditBasedSequenceNumberingViewReader\n+        implements BufferAvailabilityListener, NetworkSequenceViewReader {\n+\n+    private final Object requestLock = new Object();\n+\n+    private final InputChannelID receiverId;\n+\n+    private final PartitionRequestQueue requestQueue;\n+\n+    private final int initialCredit;\n+\n+    private volatile ResultSubpartitionView subpartitionView;\n+\n+    /**\n+     * The status indicating whether this reader is already enqueued in the pipeline for\n+     * transferring data or not.\n+     *\n+     * <p>It is mainly used to avoid repeated registrations but should be accessed by a single\n+     * thread only since there is no synchronisation.\n+     */\n+    private boolean isRegisteredAsAvailable = false;\n+\n+    /** The number of available buffers for holding data on the consumer side. */\n+    private int numCreditsAvailable;\n+\n+    CreditBasedSequenceNumberingViewReader(\n+            InputChannelID receiverId, int initialCredit, PartitionRequestQueue requestQueue) {\n+        checkArgument(initialCredit >= 0, \"Must be non-negative.\");\n+\n+        this.receiverId = receiverId;\n+        this.initialCredit = initialCredit;\n+        this.numCreditsAvailable = initialCredit;\n+        this.requestQueue = requestQueue;\n+    }\n+\n+    @Override\n+    public void requestSubpartitionView(\n+            ResultPartitionProvider partitionProvider,\n+            ResultPartitionID resultPartitionId,\n+            int subPartitionIndex)\n+            throws IOException {\n+\n+        synchronized (requestLock) {\n+            if (subpartitionView == null) {\n+                // This call can trigger a notification we have to\n+                // schedule a separate task at the event loop that will\n+                // start consuming this. Otherwise the reference to the\n+                // view cannot be available in getNextBuffer().\n+                this.subpartitionView =\n+                        partitionProvider.createSubpartitionView(\n+                                resultPartitionId, subPartitionIndex, this);\n+            } else {\n+                throw new IllegalStateException(\"Subpartition already requested\");\n+            }\n+        }\n+\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public void addCredit(int creditDeltas) {\n+        numCreditsAvailable += creditDeltas;\n+    }\n+\n+    @Override\n+    public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;\n+        }\n+        subpartitionView.resumeConsumption();\n+    }\n+\n+    @Override\n+    public void acknowledgeAllRecordsProcessed() {\n+        subpartitionView.acknowledgeAllRecordsProcessed();\n+    }\n+\n+    @Override\n+    public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n+        this.isRegisteredAsAvailable = isRegisteredAvailable;\n+    }\n+\n+    @Override\n+    public boolean isRegisteredAsAvailable() {\n+        return isRegisteredAsAvailable;\n+    }\n+\n+    /**\n+     * Returns true only if the next buffer is an event or the reader has both available credits and\n+     * buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such\n+     *     that {@code getNextDataType(bufferAndBacklog) != NONE <=>\n+     *     AvailabilityWithBacklog#isAvailable()}!\n+     */\n+    @Override\n+    public ResultSubpartitionView.AvailabilityWithBacklog getAvailabilityAndBacklog() {\n+        return subpartitionView.getAvailabilityAndBacklog(numCreditsAvailable);\n+    }\n+\n+    /**\n+     * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next\n+     * buffer in line.\n+     *\n+     * <p>Returns the next data type only if the next buffer is an event or the reader has both\n+     * available credits and buffers.\n+     *\n+     * @implSpec BEWARE: this must be in sync with {@link #getAvailabilityAndBacklog()}, such that\n+     *     {@code getNextDataType(bufferAndBacklog) != NONE <=>\n+     *     AvailabilityWithBacklog#isAvailable()}!\n+     * @param bufferAndBacklog current buffer and backlog including information about the next\n+     *     buffer\n+     * @return the next data type if the next buffer can be pulled immediately or {@link\n+     *     Buffer.DataType#NONE}\n+     */\n+    private Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n+        final Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+        if (numCreditsAvailable > 0 || nextDataType.isEvent()) {\n+            return nextDataType;\n+        }\n+        return Buffer.DataType.NONE;\n+    }\n+\n+    @Override\n+    public InputChannelID getReceiverId() {\n+        return receiverId;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumCreditsAvailable() {\n+        return numCreditsAvailable;\n+    }\n+\n+    @VisibleForTesting\n+    ResultSubpartitionView.AvailabilityWithBacklog hasBuffersAvailable() {\n+        return subpartitionView.getAvailabilityAndBacklog(Integer.MAX_VALUE);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BufferAndAvailability getNextBuffer() throws IOException {\n+        BufferAndBacklog next = subpartitionView.getNextBuffer();\n+        if (next != null) {\n+            if (next.buffer().isBuffer() && --numCreditsAvailable < 0) {\n+                throw new IllegalStateException(\"no credit available\");\n+            }\n+\n+            final Buffer.DataType nextDataType = getNextDataType(next);\n+            return new BufferAndAvailability(\n+                    next.buffer(), nextDataType, next.buffersInBacklog(), next.getSequenceNumber());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        return subpartitionView.isReleased();\n+    }\n+\n+    @Override\n+    public Throwable getFailureCause() {\n+        return subpartitionView.getFailureCause();\n+    }\n+\n+    @Override\n+    public void releaseAllResources() throws IOException {\n+        subpartitionView.releaseAllResources();\n+    }\n+\n+    @Override\n+    public void notifyDataAvailable() {\n+        requestQueue.notifyReaderNonEmpty(this);\n+    }\n+\n+    @Override\n+    public void notifyPriorityEvent(int prioritySequenceNumber) {\n+        notifyDataAvailable();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CreditBasedSequenceNumberingViewReader{\"\n+                + \"requestLock=\"\n+                + requestLock\n+                + \", receiverId=\"\n+                + receiverId\n+                + \", numCreditsAvailable=\"\n+                + numCreditsAvailable\n+                + \", isRegisteredAsAvailable=\"\n+                + isRegisteredAsAvailable\n+                + '}';\n+    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}]}, {"oid": "fb4c607a5c4780729143d458b1c7633adcba59bf", "url": "https://github.com/apache/flink/commit/fb4c607a5c4780729143d458b1c7633adcba59bf", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T13:08:16Z", "type": "forcePushed"}, {"oid": "a51d7760c34c0652321427daa153070874c54a61", "url": "https://github.com/apache/flink/commit/a51d7760c34c0652321427daa153070874c54a61", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-15T18:27:12Z", "type": "forcePushed"}, {"oid": "0ed54d10e01403ccbe4478ad086d4859f6f511cf", "url": "https://github.com/apache/flink/commit/0ed54d10e01403ccbe4478ad086d4859f6f511cf", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-15T18:44:42Z", "type": "forcePushed"}, {"oid": "edabda8971fb299b278a0bd0b42c2dca82c8a6a4", "url": "https://github.com/apache/flink/commit/edabda8971fb299b278a0bd0b42c2dca82c8a6a4", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-16T03:03:56Z", "type": "forcePushed"}, {"oid": "d8b233f483d45b8901cc28770be9da71a39929ef", "url": "https://github.com/apache/flink/commit/d8b233f483d45b8901cc28770be9da71a39929ef", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-16T04:52:00Z", "type": "forcePushed"}, {"oid": "ab13e8a7dff7dcf53ed919196908437c30e78158", "url": "https://github.com/apache/flink/commit/ab13e8a7dff7dcf53ed919196908437c30e78158", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-18T03:56:00Z", "type": "forcePushed"}, {"oid": "3f89d29a4cee4917ff8087e16ab35c5d1274220c", "url": "https://github.com/apache/flink/commit/3f89d29a4cee4917ff8087e16ab35c5d1274220c", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-18T04:05:48Z", "type": "forcePushed"}, {"oid": "7dfdb8bfa05b783479697bd3aa3de3fac2628482", "url": "https://github.com/apache/flink/commit/7dfdb8bfa05b783479697bd3aa3de3fac2628482", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-06-28T05:30:04Z", "type": "forcePushed"}, {"oid": "66de3ded5740c19aab5984c8650b5d6a355ed6e8", "url": "https://github.com/apache/flink/commit/66de3ded5740c19aab5984c8650b5d6a355ed6e8", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-06-28T08:14:19Z", "type": "forcePushed"}, {"oid": "9963994d6a37e8c1721d31519ac7346e25922248", "url": "https://github.com/apache/flink/commit/9963994d6a37e8c1721d31519ac7346e25922248", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-07-01T16:03:05Z", "type": "forcePushed"}, {"oid": "5682e0256634e2ce1a38ca132cdaaddc79ee71c0", "url": "https://github.com/apache/flink/commit/5682e0256634e2ce1a38ca132cdaaddc79ee71c0", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-07-02T03:27:27Z", "type": "forcePushed"}, {"oid": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "url": "https://github.com/apache/flink/commit/1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.", "committedDate": "2021-03-07T13:57:47Z", "type": "forcePushed"}, {"oid": "57cd88378e64e7c534d592d4538b2aa8222a2b00", "url": "https://github.com/apache/flink/commit/57cd88378e64e7c534d592d4538b2aa8222a2b00", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-07T15:25:00Z", "type": "forcePushed"}, {"oid": "379905b396355d37f565230cbcbee323dc626dce", "url": "https://github.com/apache/flink/commit/379905b396355d37f565230cbcbee323dc626dce", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-08T03:36:48Z", "type": "forcePushed"}, {"oid": "522dfaaf4295b903fa0c2d88e79db6d267086730", "url": "https://github.com/apache/flink/commit/522dfaaf4295b903fa0c2d88e79db6d267086730", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-08T05:48:19Z", "type": "forcePushed"}, {"oid": "8006bdc42eddf90eaaf8b1a426e3ee3c9b635e3c", "url": "https://github.com/apache/flink/commit/8006bdc42eddf90eaaf8b1a426e3ee3c9b635e3c", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-08T12:38:46Z", "type": "forcePushed"}, {"oid": "4b4b098f5eb40c7caf885c30b8c12aced99bbe05", "url": "https://github.com/apache/flink/commit/4b4b098f5eb40c7caf885c30b8c12aced99bbe05", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-08T13:58:14Z", "type": "forcePushed"}, {"oid": "87c4d9e67b205d7ca2fedf25a5a59402500de2ce", "url": "https://github.com/apache/flink/commit/87c4d9e67b205d7ca2fedf25a5a59402500de2ce", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-28T12:53:34Z", "type": "forcePushed"}, {"oid": "86af5b748a70ba9bb997d654b6f76c0f3a343bc0", "url": "https://github.com/apache/flink/commit/86af5b748a70ba9bb997d654b6f76c0f3a343bc0", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-05-08T07:29:43Z", "type": "forcePushed"}, {"oid": "ae312385b57ca67cdb73ee96be38c4edbe56478d", "url": "https://github.com/apache/flink/commit/ae312385b57ca67cdb73ee96be38c4edbe56478d", "message": "Commit for test", "committedDate": "2021-05-10T06:49:44Z", "type": "forcePushed"}, {"oid": "4f4ce33b815167b23c8ee3dc8d65e1e97cc0cd07", "url": "https://github.com/apache/flink/commit/4f4ce33b815167b23c8ee3dc8d65e1e97cc0cd07", "message": "Commit for test", "committedDate": "2021-05-10T10:06:29Z", "type": "forcePushed"}, {"oid": "8550965d808fe7b4d6ff2d48034612878937a579", "url": "https://github.com/apache/flink/commit/8550965d808fe7b4d6ff2d48034612878937a579", "message": "Fix commit", "committedDate": "2021-05-11T08:33:04Z", "type": "forcePushed"}, {"oid": "7b6eb661923f59967a116e9074cf790fd694c578", "url": "https://github.com/apache/flink/commit/7b6eb661923f59967a116e9074cf790fd694c578", "message": "Commit for test", "committedDate": "2021-05-11T12:15:11Z", "type": "forcePushed"}, {"oid": "2c49d1a8cee6485e8f367190f152e58960c901ff", "url": "https://github.com/apache/flink/commit/2c49d1a8cee6485e8f367190f152e58960c901ff", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-05-11T12:14:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661546940", "body": "Before these changes where this buffer was recycled? or was it the bug?", "bodyText": "Before these changes where this buffer was recycled? or was it the bug?", "bodyHTML": "<p dir=\"auto\">Before these changes where this buffer was recycled? or was it the bug?</p>", "author": "akalash", "createdAt": "2021-06-30T14:46:42Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -340,7 +355,15 @@ private void decodeBufferOrEvent(\n             RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent)\n             throws Throwable {\n         if (bufferOrEvent.isBuffer() && bufferOrEvent.bufferSize == 0) {\n-            inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n+            try {\n+                inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n+            } finally {\n+                // recycle the empty buffer directly\n+                Buffer buffer = bufferOrEvent.getBuffer();\n+                if (buffer != null) {\n+                    buffer.recycleBuffer();", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk4NjgxMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661986812", "bodyText": "It is not a bug. The empty buffer will not be sent to the downstream before. However, after this change, the empty buffer will be sent to the downstream task to release the credit already allocated for it. If we do not send the empty buffer to the downstream, the corresponding downstream channel will occupy more credits than needed.", "author": "wsry", "createdAt": "2021-07-01T05:32:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDUwMzUyNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664503527", "bodyText": "What do you mean by that @wsry ? That previously bufferOrEevnt.getBuffer() was always null?\nIf so why do we need to keep suport for sending both empty buffers or null buffer?", "author": "pnowojski", "createdAt": "2021-07-06T12:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk5NzIxOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664997218", "bodyText": "Yes, you are right. Previously, bufferOrEevnt.getBuffer() was always null. And currently, it should be never null. So we do not need to support null buffer now.", "author": "wsry", "createdAt": "2021-07-07T02:34:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk5OTc2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664999767", "bodyText": "I think I can keep this logic unchanged and release the buffer in decoder", "author": "wsry", "createdAt": "2021-07-07T02:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA=="}], "type": "inlineReview", "revised_code": {"commit": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex 92425db4f8e..41d91430e70 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n", "chunk": "@@ -355,15 +369,7 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n             RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent)\n             throws Throwable {\n         if (bufferOrEvent.isBuffer() && bufferOrEvent.bufferSize == 0) {\n-            try {\n-                inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n-            } finally {\n-                // recycle the empty buffer directly\n-                Buffer buffer = bufferOrEvent.getBuffer();\n-                if (buffer != null) {\n-                    buffer.recycleBuffer();\n-                }\n-            }\n+            inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n         } else if (bufferOrEvent.getBuffer() != null) {\n             inputChannel.onBuffer(\n                     bufferOrEvent.getBuffer(), bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex 92425db4f8e..41d91430e70 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n", "chunk": "@@ -355,15 +369,7 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n             RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent)\n             throws Throwable {\n         if (bufferOrEvent.isBuffer() && bufferOrEvent.bufferSize == 0) {\n-            try {\n-                inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n-            } finally {\n-                // recycle the empty buffer directly\n-                Buffer buffer = bufferOrEvent.getBuffer();\n-                if (buffer != null) {\n-                    buffer.recycleBuffer();\n-                }\n-            }\n+            inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n         } else if (bufferOrEvent.getBuffer() != null) {\n             inputChannel.onBuffer(\n                     bufferOrEvent.getBuffer(), bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "a36fac6fceff59a237e90e55965abf76b39e3127", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Message for notification about new buffer size(NewBufferSize) was added"}, {"oid": "4648e8af115410b4d1a5aefed44cdb6bd9d07ebb", "committedDate": "2021-10-21 17:37:16 +0200", "message": "[FLINK-24468][runtime] Moved the methods for sending messages from NetworkClientHandler to NettyPartitioonRequestClient since it is not responsibility of handler to send them"}, {"oid": "c0cca2e16430758950627068306c7bf6056c98c9", "committedDate": "2022-02-16 14:05:13 +0800", "message": "[hotfix][network] Remove the deduplication for CancelPartitionRequest."}, {"oid": "5be7d480dd3a54c17ef34d76b82b9f6a80ba8bf0", "committedDate": "2022-02-16 14:05:44 +0800", "message": "[FLINK-15455][network] Enabled tcp connection reuse across multi jobs."}, {"oid": "93c834be953f1336adb3ec5b5bf759a20e25eddf", "committedDate": "2022-11-18 10:40:25 +0800", "message": "[FLINK-29639] Print resourceId of remote taskmanager when encounter transport exception."}, {"oid": "4b10f422f20ca22661a1870eadc343cab4a44567", "committedDate": "2022-11-21 11:44:39 +0100", "message": "[FLINK-28695][hotfix][network] Remove some unused exceptions"}, {"oid": "e7854193816dc348086423b42d4dff12dca4a80e", "committedDate": "2022-11-21 11:44:39 +0100", "message": "[FLINK-28695][network] Fix the bug of old netty client isn't closed when netty server closes channel and no input channel"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661554029", "body": "as I understand, the backlog can not be less or equal to 0 here. So maybe convert it to checkArgument? Or I missed something?", "bodyText": "as I understand, the backlog can not be less or equal to 0 here. So maybe convert it to checkArgument? Or I missed something?", "bodyHTML": "<p dir=\"auto\">as I understand, the backlog can not be less or equal to 0 here. So maybe convert it to checkArgument? Or I missed something?</p>", "author": "akalash", "createdAt": "2021-06-30T14:53:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -164,6 +168,27 @@ void addCreditOrResumeConsumption(\n         }\n     }\n \n+    /**\n+     * Announces remaining backlog to the consumer after the available data notification or data\n+     * consumption resumption.\n+     */\n+    private void announceBacklog(NetworkSequenceViewReader reader) {\n+        int backlog = reader.getRemainingBacklog();\n+        if (backlog > 0) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5MDgyNQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661990825", "bodyText": "The backlog can be 0. For example, after resumption from checkpoint, if there is no pending data in the subpartition.", "author": "wsry", "createdAt": "2021-07-01T05:44:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0ODA4NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664648084", "bodyText": "Have you tested this @wsry ? After all it seems like if reader is available, it should have backlog > 0, shouldn't it?", "author": "pnowojski", "createdAt": "2021-07-06T15:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY2OTg1NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664669854", "bodyText": "Secondly, getRemainingBacklog() is a very costly operation (additional synchronisation) that I think could have been avoided:\n\nBacklog can go up only as a result of org.apache.flink.runtime.io.network.netty.PartitionRequestQueue#notifyReaderNonEmpty(reader).\nBacklog can go down, only as a result of polling the data from the reader.\nSo instead of using thread safe reader.getRemainingBacklog(), we could re-use existing synchronisation in 1. and 2., to maintain remainingBacklog in the netty thread (in the PartitionRequestQueue.\n\nBut it would be even better to completely avoid this check (my comment above).", "author": "pnowojski", "createdAt": "2021-07-06T15:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTAxMjQ0Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665012443", "bodyText": "You are right, we can do some optimization here.", "author": "wsry", "createdAt": "2021-07-07T03:25:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA3MzQ2Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665073463", "bodyText": "I think there is one thing blocking us from reusing the backlog from PartitionRequestQueue#notifyReaderNonEmpty(reader): we have duplicated availability notifications. We may get outdated backlog.", "author": "wsry", "createdAt": "2021-07-07T06:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTIyNTkzMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665225932", "bodyText": "Maybe we can reuse the return value of is available. Instead of just return a bool flag, we may also return the backlog. I will give it a try.", "author": "wsry", "createdAt": "2021-07-07T09:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTkwMDUxNQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665900515", "bodyText": "NetworkSequenceViewReader#isAvailable() has the same problem of synchronisation costs.\n\nI think there is one thing blocking us from reusing the backlog from PartitionRequestQueue#notifyReaderNonEmpty(reader): we have duplicated availability notifications. We may get outdated backlog.\n\nWhat is the problem?  Keep in mind that spurious notifications shouldn't be that big of a problem. If we sometimes wake up too many times, and we rarely send incorrect backlog information that should be fine, as long as we always over estimate the backlog.\nAfter all even in your version I think there can be a race condition where PartitionRequestQueue is notified reader is non empty, you check the getRemainingBacklog() and send the BacklogAnnouncement message, while before it gets processed by the receiver, some buffer is polled from this reader and backlog goes down to 0. And as a result, receiver assigns as a credit to a sender that doesn't have any data anymore?", "author": "pnowojski", "createdAt": "2021-07-08T06:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTkzMzA2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665933067", "bodyText": "NetworkSequenceViewReader#isAvailable() has already been called by PartitionRequestQueue#enqueueAvailableReader:\nprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\nif (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {\nreturn;\n}\n......\n}\n\nI think we can change it to:\n    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n        if (reader.isRegisteredAsAvailable()) {\n            return;\n        }\n\n        ResultSubpartitionView.AvailabilityWithBacklog availabilityWithBacklog =\n                reader.getAvailabilityAndBacklog();\n        if (!availabilityWithBacklog.isAvailable()) {\n            int backlog = availabilityWithBacklog.getBacklog();\n            if (backlog > 0 && reader.needAnnounceBacklog()) {\n                announceBacklog(reader, backlog);\n            }\n            return;\n        }\n......\n}\n\nWhat do you think?\n\nAfter all even in your version I think there can be a race condition where PartitionRequestQueue is notified reader is non empty, you check the getRemainingBacklog() and send the BacklogAnnouncement message, while before it gets processed by the receiver, some buffer is polled from this reader and backlog goes down to 0. And as a result, receiver assigns as a credit to a sender that doesn't have any data anymore?\n\nI think there is no such problem. One reason is that getRemainingBacklog() is in netty thread and we can guarantee the order, the downstream will always process the BacklogAnnouncement before the buffer. The other reason is that we only announce credit when there is no credit available which means if there is credit available, only buffer with backlog will be sent, if there is no credit available, only BacklogAnnouncement will be send, buffer will be always wait for credit. It is also not a problem if we announce the same credit twice because we can guarantee the process order.", "author": "wsry", "createdAt": "2021-07-08T07:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjI4NjM5Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666286396", "bodyText": "Yes you are right. reader.isAvailable() is already being called. I'm not sure why I've missed that.\nreader.getAvailabilityAndBacklog(); should work fine :)", "author": "pnowojski", "createdAt": "2021-07-08T15:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "1814aee57851711782cc2d922c4ef8f118a74c13", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 3d3a36d3006..4395a06e5d3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -168,6 +168,20 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n         }\n     }\n \n+    void acknowledgeAllRecordsProcessed(InputChannelID receiverId) {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            reader.acknowledgeAllRecordsProcessed();\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n     /**\n      * Announces remaining backlog to the consumer after the available data notification or data\n      * consumption resumption.\n", "next_change": {"commit": "01b2bc58b30a2a3730895f7c50ff59099bd273d2", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 4395a06e5d3..72ede48bda2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -186,21 +195,20 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n      * Announces remaining backlog to the consumer after the available data notification or data\n      * consumption resumption.\n      */\n-    private void announceBacklog(NetworkSequenceViewReader reader) {\n-        int backlog = reader.getRemainingBacklog();\n-        if (backlog > 0) {\n-            NettyMessage.BacklogAnnouncement announcement =\n-                    new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n-            ctx.channel()\n-                    .writeAndFlush(announcement)\n-                    .addListener(\n-                            (ChannelFutureListener)\n-                                    future -> {\n-                                        if (!future.isSuccess()) {\n-                                            onChannelFutureFailure(future);\n-                                        }\n-                                    });\n-        }\n+    private void announceBacklog(NetworkSequenceViewReader reader, int backlog) {\n+        checkArgument(backlog > 0, \"Backlog must be positive.\");\n+\n+        NettyMessage.BacklogAnnouncement announcement =\n+                new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n+        ctx.channel()\n+                .writeAndFlush(announcement)\n+                .addListener(\n+                        (ChannelFutureListener)\n+                                future -> {\n+                                    if (!future.isSuccess()) {\n+                                        onChannelFutureFailure(future);\n+                                    }\n+                                });\n     }\n \n     @Override\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 72ede48bda2..0e3b6ddc57c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -191,26 +178,6 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n         }\n     }\n \n-    /**\n-     * Announces remaining backlog to the consumer after the available data notification or data\n-     * consumption resumption.\n-     */\n-    private void announceBacklog(NetworkSequenceViewReader reader, int backlog) {\n-        checkArgument(backlog > 0, \"Backlog must be positive.\");\n-\n-        NettyMessage.BacklogAnnouncement announcement =\n-                new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n-        ctx.channel()\n-                .writeAndFlush(announcement)\n-                .addListener(\n-                        (ChannelFutureListener)\n-                                future -> {\n-                                    if (!future.isSuccess()) {\n-                                        onChannelFutureFailure(future);\n-                                    }\n-                                });\n-    }\n-\n     @Override\n     public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n         // The user event triggered event loop callback is used for thread-safe\n", "next_change": {"commit": "639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 0e3b6ddc57c..72ede48bda2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -178,6 +191,26 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n         }\n     }\n \n+    /**\n+     * Announces remaining backlog to the consumer after the available data notification or data\n+     * consumption resumption.\n+     */\n+    private void announceBacklog(NetworkSequenceViewReader reader, int backlog) {\n+        checkArgument(backlog > 0, \"Backlog must be positive.\");\n+\n+        NettyMessage.BacklogAnnouncement announcement =\n+                new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n+        ctx.channel()\n+                .writeAndFlush(announcement)\n+                .addListener(\n+                        (ChannelFutureListener)\n+                                future -> {\n+                                    if (!future.isSuccess()) {\n+                                        onChannelFutureFailure(future);\n+                                    }\n+                                });\n+    }\n+\n     @Override\n     public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n         // The user event triggered event loop callback is used for thread-safe\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 3d3a36d3006..72ede48bda2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n", "chunk": "@@ -168,25 +177,38 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n         }\n     }\n \n+    void acknowledgeAllRecordsProcessed(InputChannelID receiverId) {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            reader.acknowledgeAllRecordsProcessed();\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n     /**\n      * Announces remaining backlog to the consumer after the available data notification or data\n      * consumption resumption.\n      */\n-    private void announceBacklog(NetworkSequenceViewReader reader) {\n-        int backlog = reader.getRemainingBacklog();\n-        if (backlog > 0) {\n-            NettyMessage.BacklogAnnouncement announcement =\n-                    new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n-            ctx.channel()\n-                    .writeAndFlush(announcement)\n-                    .addListener(\n-                            (ChannelFutureListener)\n-                                    future -> {\n-                                        if (!future.isSuccess()) {\n-                                            onChannelFutureFailure(future);\n-                                        }\n-                                    });\n-        }\n+    private void announceBacklog(NetworkSequenceViewReader reader, int backlog) {\n+        checkArgument(backlog > 0, \"Backlog must be positive.\");\n+\n+        NettyMessage.BacklogAnnouncement announcement =\n+                new NettyMessage.BacklogAnnouncement(backlog, reader.getReceiverId());\n+        ctx.channel()\n+                .writeAndFlush(announcement)\n+                .addListener(\n+                        (ChannelFutureListener)\n+                                future -> {\n+                                    if (!future.isSuccess()) {\n+                                        onChannelFutureFailure(future);\n+                                    }\n+                                });\n     }\n \n     @Override\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "7478445aa30cd28b7b6402565ca304c916024475", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[refactor][runtime] Unification of obtaining reader in PartitionRequestQueue"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}, {"oid": "7bacef09622d43c01ca9a749bbcd259d5cd3e0fe", "committedDate": "2021-09-17 20:16:25 +0200", "message": "[FLINK-24233][runtime] Ignore message about new buffer size if the reader doesn't ready yet"}, {"oid": "f957e3fee50e734dd6b2cbf0cbbef00fe810cd32", "committedDate": "2022-01-13 15:07:28 +0100", "message": "[FLINK-25441][network] Wrap failure cuase with ProducerFailedException only for PipelinedSubpartitionView."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661557618", "body": "Is it also a bug? Or why do we distinguish EVENT_BUFFER and DATA_BUFFER now?", "bodyText": "Is it also a bug? Or why do we distinguish EVENT_BUFFER and DATA_BUFFER now?", "bodyHTML": "<p dir=\"auto\">Is it also a bug? Or why do we distinguish EVENT_BUFFER and DATA_BUFFER now?</p>", "author": "akalash", "createdAt": "2021-06-30T14:57:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java", "diffHunk": "@@ -91,10 +91,14 @@ public BufferAndBacklog getNextBuffer() throws IOException {\n \n         updateStatistics(current);\n \n-        // We simply assume all the data are non-events for batch jobs to avoid pre-fetching the\n-        // next header\n-        Buffer.DataType nextDataType =\n-                numDataAndEventBuffers > 0 ? Buffer.DataType.DATA_BUFFER : Buffer.DataType.NONE;\n+        // We simply assume all the data except for the last one (EndOfPartitionEvent)\n+        // are non-events for batch jobs to avoid pre-fetching the next header\n+        Buffer.DataType nextDataType = Buffer.DataType.NONE;\n+        if (numDataBuffers > 0) {\n+            nextDataType = Buffer.DataType.DATA_BUFFER;\n+        } else if (numDataAndEventBuffers > 0) {\n+            nextDataType = Buffer.DataType.EVENT_BUFFER;\n+        }", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5MjQ1OQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661992459", "bodyText": "An EVENT_BUFFER does not need any credit to be sent. The BoundedBlockingSubpartitionDirectTransferReader Implementation does not distinguish EVENT_BUFFER and DATA_BUFFER for simplicity. However, after this change, we need to distinguish EVENT_BUFFER and DATA_BUFFER because we do not want to allocate any credit at downstream for an EVENT_BUFFER.", "author": "wsry", "createdAt": "2021-07-01T05:48:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1NDk0OQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664654949", "bodyText": "But what would be a problem with requesting for a credit for the EndOfPartitionEvent? In other words, what's wrong with doing it as it was done previously: always returning DATA_BUFFER or NONE?", "author": "pnowojski", "createdAt": "2021-07-06T15:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA1OTAyNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665059027", "bodyText": "I think this is just an optimization. Without this change, the backlog announced to the downstream does not include the event and EVENT_BUFFER and DATA_BUFFER are not distinguished, this means the event buffer also need a credit to send. If there is no exclusive buffer, no enough buffer will be allocated for the event, because we only announce the data buffer backlog to the downstream. As a result, some tests will hang for there is no credit for the event buffer. To solve this dead lock, there are two simple ways:\n\nAnnounce both data buffer and event buffer backlog to the downstream, this lead to allocate more buffers than needed, these buffers will be released when the EOF is received at the downstream task.\nDistinguish EVENT_BUFFER and DATA_BUFFER just like what is doing now.\n\nThese choices are both acceptable to me. I chose the second one because EVENT_BUFFER and DATA_BUFFER are distinguished at the downstream task and we can allocate one less buffer.\nBoth of the choices need to do some change to BoundedBlockingSubpartitionDirectTransferReader. Which one do you prefer? I think both are acceptable for me.", "author": "wsry", "createdAt": "2021-07-07T05:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTgzMDY5MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665830690", "bodyText": "After rethink about it, the first choice can support more events type in the future and the second choice make the assumption that we only have one event at the end of the data. Maybe the first choice is better?", "author": "wsry", "createdAt": "2021-07-08T02:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTg5NTUwNA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665895504", "bodyText": "Let's stay with the option 2 (as you have currently implemented)", "author": "pnowojski", "createdAt": "2021-07-08T06:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}], "type": "inlineReview", "revised_code": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\nindex ec784393e9a..f8472c05b63 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n", "chunk": "@@ -91,14 +91,10 @@ public class BoundedBlockingSubpartitionDirectTransferReader implements ResultSu\n \n         updateStatistics(current);\n \n-        // We simply assume all the data except for the last one (EndOfPartitionEvent)\n-        // are non-events for batch jobs to avoid pre-fetching the next header\n-        Buffer.DataType nextDataType = Buffer.DataType.NONE;\n-        if (numDataBuffers > 0) {\n-            nextDataType = Buffer.DataType.DATA_BUFFER;\n-        } else if (numDataAndEventBuffers > 0) {\n-            nextDataType = Buffer.DataType.EVENT_BUFFER;\n-        }\n+        // We simply assume all the data are non-events for batch jobs to avoid pre-fetching the\n+        // next header\n+        Buffer.DataType nextDataType =\n+                numDataAndEventBuffers > 0 ? Buffer.DataType.DATA_BUFFER : Buffer.DataType.NONE;\n         return BufferAndBacklog.fromBufferAndLookahead(\n                 current, nextDataType, numDataBuffers, sequenceNumber++);\n     }\n", "next_change": {"commit": "0ffa4e02e374cc5724552a4af8a15d03c8e31cca", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\nindex f8472c05b63..84037fc5977 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n", "chunk": "@@ -91,10 +91,14 @@ public class BoundedBlockingSubpartitionDirectTransferReader implements ResultSu\n \n         updateStatistics(current);\n \n-        // We simply assume all the data are non-events for batch jobs to avoid pre-fetching the\n-        // next header\n-        Buffer.DataType nextDataType =\n-                numDataAndEventBuffers > 0 ? Buffer.DataType.DATA_BUFFER : Buffer.DataType.NONE;\n+        // We simply assume all the data except for the last one (EndOfPartitionEvent)\n+        // are non-events for batch jobs to avoid pre-fetching the next header\n+        Buffer.DataType nextDataType = Buffer.DataType.NONE;\n+        if (numDataBuffers > 0) {\n+            nextDataType = Buffer.DataType.DATA_BUFFER;\n+        } else if (numDataAndEventBuffers > 0) {\n+            nextDataType = Buffer.DataType.EVENT_BUFFER;\n+        }\n         return BufferAndBacklog.fromBufferAndLookahead(\n                 current, nextDataType, numDataBuffers, sequenceNumber++);\n     }\n", "next_change": null}]}}]}, "revised_code_in_main": null, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "088d16517126d7128e1f072d588b9ce0f4787ae6", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][refactor] Made a safe method for getting the number of buffers in the queue visible in the interface."}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "96408716fdf31692c940f23a5bd8fa73d53929f6", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Support EndOfData in blocking subpartitions"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU2MzMwNA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661563304", "body": "Does this mean that we don't need the credit for sending the event?", "bodyText": "Does this mean that we don't need the credit for sending the event?", "bodyHTML": "<p dir=\"auto\">Does this mean that we don't need the credit for sending the event?</p>", "author": "akalash", "createdAt": "2021-06-30T15:04:06Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java", "diffHunk": "@@ -110,7 +114,12 @@ private void updateStatistics(Buffer buffer) {\n     public boolean isAvailable(int numCreditsAvailable) {\n         // We simply assume there are no events except EndOfPartitionEvent for bath jobs,\n         // then it has no essential effect to ignore the judgement of next event buffer.\n-        return numCreditsAvailable > 0 && numDataAndEventBuffers > 0;\n+        return (numCreditsAvailable > 0 || numDataBuffers == 0) && numDataAndEventBuffers > 0;", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5MzY0Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661993643", "bodyText": "Yes, you are right. At the downstream task, no credit is needed when decoding an event.", "author": "wsry", "createdAt": "2021-07-01T05:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU2MzMwNA=="}], "type": "inlineReview", "revised_code": {"commit": "01b2bc58b30a2a3730895f7c50ff59099bd273d2", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\nindex ec784393e9a..d9034287be9 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n", "chunk": "@@ -111,15 +111,12 @@ public class BoundedBlockingSubpartitionDirectTransferReader implements ResultSu\n     }\n \n     @Override\n-    public boolean isAvailable(int numCreditsAvailable) {\n+    public AvailabilityWithBacklog getAvailabilityAndBacklog(int numCreditsAvailable) {\n         // We simply assume there are no events except EndOfPartitionEvent for bath jobs,\n         // then it has no essential effect to ignore the judgement of next event buffer.\n-        return (numCreditsAvailable > 0 || numDataBuffers == 0) && numDataAndEventBuffers > 0;\n-    }\n-\n-    @Override\n-    public int getRemainingBacklog() {\n-        return numDataBuffers;\n+        return new AvailabilityWithBacklog(\n+                (numCreditsAvailable > 0 || numDataBuffers == 0) && numDataAndEventBuffers > 0,\n+                numDataBuffers);\n     }\n \n     @Override\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\nindex d9034287be9..f8472c05b63 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n", "chunk": "@@ -111,12 +107,10 @@ public class BoundedBlockingSubpartitionDirectTransferReader implements ResultSu\n     }\n \n     @Override\n-    public AvailabilityWithBacklog getAvailabilityAndBacklog(int numCreditsAvailable) {\n+    public boolean isAvailable(int numCreditsAvailable) {\n         // We simply assume there are no events except EndOfPartitionEvent for bath jobs,\n         // then it has no essential effect to ignore the judgement of next event buffer.\n-        return new AvailabilityWithBacklog(\n-                (numCreditsAvailable > 0 || numDataBuffers == 0) && numDataAndEventBuffers > 0,\n-                numDataBuffers);\n+        return numCreditsAvailable > 0 && numDataAndEventBuffers > 0;\n     }\n \n     @Override\n", "next_change": {"commit": "0ffa4e02e374cc5724552a4af8a15d03c8e31cca", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\nindex f8472c05b63..84037fc5977 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n", "chunk": "@@ -110,7 +114,7 @@ public class BoundedBlockingSubpartitionDirectTransferReader implements ResultSu\n     public boolean isAvailable(int numCreditsAvailable) {\n         // We simply assume there are no events except EndOfPartitionEvent for bath jobs,\n         // then it has no essential effect to ignore the judgement of next event buffer.\n-        return numCreditsAvailable > 0 && numDataAndEventBuffers > 0;\n+        return (numCreditsAvailable > 0 || numDataBuffers == 0) && numDataAndEventBuffers > 0;\n     }\n \n     @Override\n", "next_change": {"commit": "639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\nindex 84037fc5977..d9034287be9 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n", "chunk": "@@ -111,10 +111,12 @@ public class BoundedBlockingSubpartitionDirectTransferReader implements ResultSu\n     }\n \n     @Override\n-    public boolean isAvailable(int numCreditsAvailable) {\n+    public AvailabilityWithBacklog getAvailabilityAndBacklog(int numCreditsAvailable) {\n         // We simply assume there are no events except EndOfPartitionEvent for bath jobs,\n         // then it has no essential effect to ignore the judgement of next event buffer.\n-        return (numCreditsAvailable > 0 || numDataBuffers == 0) && numDataAndEventBuffers > 0;\n+        return new AvailabilityWithBacklog(\n+                (numCreditsAvailable > 0 || numDataBuffers == 0) && numDataAndEventBuffers > 0,\n+                numDataBuffers);\n     }\n \n     @Override\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\nindex ec784393e9a..d9034287be9 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n", "chunk": "@@ -111,15 +111,12 @@ public class BoundedBlockingSubpartitionDirectTransferReader implements ResultSu\n     }\n \n     @Override\n-    public boolean isAvailable(int numCreditsAvailable) {\n+    public AvailabilityWithBacklog getAvailabilityAndBacklog(int numCreditsAvailable) {\n         // We simply assume there are no events except EndOfPartitionEvent for bath jobs,\n         // then it has no essential effect to ignore the judgement of next event buffer.\n-        return (numCreditsAvailable > 0 || numDataBuffers == 0) && numDataAndEventBuffers > 0;\n-    }\n-\n-    @Override\n-    public int getRemainingBacklog() {\n-        return numDataBuffers;\n+        return new AvailabilityWithBacklog(\n+                (numCreditsAvailable > 0 || numDataBuffers == 0) && numDataAndEventBuffers > 0,\n+                numDataBuffers);\n     }\n \n     @Override\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "088d16517126d7128e1f072d588b9ce0f4787ae6", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][refactor] Made a safe method for getting the number of buffers in the queue visible in the interface."}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "96408716fdf31692c940f23a5bd8fa73d53929f6", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Support EndOfData in blocking subpartitions"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661589690", "body": "I don't really get the idea of these changes.\r\n\r\nLet's suppose PipelindedSubpartition#buffers contain several but the first one is empty and finished already.\r\n\r\nHow it was before the changes:\r\n- PartitionRequestQueue requests the buffer.\r\n- in any case, PipelindedSubpartition#pollBuffer returns a buffer(it skip the first one because it is empty and finished but it returns the buffer from the next consumer)\r\n- PartitionRequestQueue continues to request from this Reader until PipelindedSubpartition#buffers is not empty.\r\n\r\nAfter the changes:\r\n\r\n- PartitionRequestQueue requests the buffer.\r\n- PipelindedSubpartition#pollBuffer returns null.\r\n- PartitionRequestQueue remove this reader from the available readers\r\n- Other buffers from PipelindedSubpartition#buffers will be sent only when timeout happens and this reader is added to the available list again.\r\n\r\nWhat the point to delay the sending if we already have credit for it and we have the buffer ready to be sent?", "bodyText": "I don't really get the idea of these changes.\nLet's suppose PipelindedSubpartition#buffers contain several but the first one is empty and finished already.\nHow it was before the changes:\n\nPartitionRequestQueue requests the buffer.\nin any case, PipelindedSubpartition#pollBuffer returns a buffer(it skip the first one because it is empty and finished but it returns the buffer from the next consumer)\nPartitionRequestQueue continues to request from this Reader until PipelindedSubpartition#buffers is not empty.\n\nAfter the changes:\n\nPartitionRequestQueue requests the buffer.\nPipelindedSubpartition#pollBuffer returns null.\nPartitionRequestQueue remove this reader from the available readers\nOther buffers from PipelindedSubpartition#buffers will be sent only when timeout happens and this reader is added to the available list again.\n\nWhat the point to delay the sending if we already have credit for it and we have the buffer ready to be sent?", "bodyHTML": "<p dir=\"auto\">I don't really get the idea of these changes.</p>\n<p dir=\"auto\">Let's suppose PipelindedSubpartition#buffers contain several but the first one is empty and finished already.</p>\n<p dir=\"auto\">How it was before the changes:</p>\n<ul dir=\"auto\">\n<li>PartitionRequestQueue requests the buffer.</li>\n<li>in any case, PipelindedSubpartition#pollBuffer returns a buffer(it skip the first one because it is empty and finished but it returns the buffer from the next consumer)</li>\n<li>PartitionRequestQueue continues to request from this Reader until PipelindedSubpartition#buffers is not empty.</li>\n</ul>\n<p dir=\"auto\">After the changes:</p>\n<ul dir=\"auto\">\n<li>PartitionRequestQueue requests the buffer.</li>\n<li>PipelindedSubpartition#pollBuffer returns null.</li>\n<li>PartitionRequestQueue remove this reader from the available readers</li>\n<li>Other buffers from PipelindedSubpartition#buffers will be sent only when timeout happens and this reader is added to the available list again.</li>\n</ul>\n<p dir=\"auto\">What the point to delay the sending if we already have credit for it and we have the buffer ready to be sent?</p>", "author": "akalash", "createdAt": "2021-06-30T15:33:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -288,9 +288,7 @@ BufferAndBacklog pollBuffer() {\n \n             if (buffers.isEmpty()) {\n                 flushRequested = false;\n-            }\n-\n-            while (!buffers.isEmpty()) {\n+            } else {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5ODg4NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661998885", "bodyText": "After the changes, if the first buffer is finished and empty. The empty buffer will be sent to the downstream to release the allocated credit for it instead of recycled directly.", "author": "wsry", "createdAt": "2021-07-01T05:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjIxNzkxNA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662217914", "bodyText": "Ok, I think I understand it now. Please, tell me I indeed understand the scenario right:\n\nSuppose the buffers contain one unfinished Buffer.\nThe flush was requested\nWhen pollBuffer() was called it collects all readable bytes from this unfinished buffer and getBuffersInBacklog returns 1(because flushRequested set to true)\nOne more credit is requested from downstream because getBuffersInBacklog equal to 1.\nWhen pollBuffer() was called again it reads nothing because all data was read last time. But it already has one credit that should be released(it is exactly what you told about?).", "author": "akalash", "createdAt": "2021-07-01T11:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjY4ODEyMA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662688120", "bodyText": "If there is only one buffer in the buffer queue, after all data is read, the flushRequested flag will be turned off. Consider the following scenario (correct me if I am wrong):\n\nThere is an unfinished buffer in the queue and all data is read.\nThen the buffer is finished but no new data is appended. Note appending data and finish buffer is not an atomic operation.\nNew buffer or event is added to the buffer queue.\nWhen polling buffer, an empty buffer is at the head of the queue and we already allocate a credit for it.", "author": "wsry", "createdAt": "2021-07-02T02:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjc3ODA1NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662778055", "bodyText": "appending data and finish buffer is not an atomic operation.\n\nIt is exactly what I want to emphasize. As I understand, we need the empty buffer only because appending data and finish buffer is not an atomic operation. which happens because BufferBuilder has a gap between commit and finish. So I propose to rewrite BufferBuilder in such a way that if it commits the current state and size == capacity it finishes it immediately(so there is no explicit finish call needed). These changes allow us to avoid all logic with an empty buffer which I think pretty untransparent.\nOne more time, my proposal:\n\nRewriting the BufferBuilder in such a way that it will be impossible to have the empty finished buffer(it just requires removing the gap between the last commit and finish).\nDon't send the empty buffer(after changes described above there won't be any empty buffers)\n\n@wsry WDYT?\n@pnowojski What is your opinion, is it safe to finish BufferBuilder immediately when it becomes full? I mean not to wait for call explicit finish but finish in the commit if it is full?", "author": "akalash", "createdAt": "2021-07-02T06:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjgxNjg1OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662816858", "bodyText": "Does that mean that the BufferBuilder can not finish a partial buffer, for example the last piece of data of the batch execution mode? Besides, there is another case which may lead to the empty buffer: in PipelinedApproximateSubpartition, if a partial record takes more than one buffer in the queue, those partial data will be dropped when recovering.", "author": "wsry", "createdAt": "2021-07-02T07:57:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjg0MTM3NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662841374", "bodyText": "Yes, the batch execution mode still requires the manual calling of finish which brokes my idea.  The same about PipelinedApproximateSubpartition. As I understand, it is impossible to know that a partial record will be sent or not before the request the credit.\nSo I still believe that it would be better to avoid sending the empty buffer if it is possible. But perhaps you right and it will be not so easy to do so in the current implementation, especially because of the scenarios which you described.", "author": "akalash", "createdAt": "2021-07-02T08:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzExOTk1Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r663119956", "bodyText": "How common is that case? Can we measure how many those empty buffers are being sent? Is this an issue of 0.1% more messages or 50%? If it's hard to say or can vary, would it be difficult/would it complicate the code to send the empty buffers only if #exclusiveBuffers == 0 to make sure that there is no performance regression?", "author": "pnowojski", "createdAt": "2021-07-02T16:13:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzU5MTI4NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r663591285", "bodyText": "It is pretty simple to send empty buffer only when  #exclusiveBuffers == 0.", "author": "wsry", "createdAt": "2021-07-05T01:40:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}], "type": "inlineReview", "revised_code": {"commit": "ae5a618edba91af4656de9bab058e4a372a01331", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 44ecb62b410..dd48214990a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -288,7 +299,9 @@ public class PipelinedSubpartition extends ResultSubpartition\n \n             if (buffers.isEmpty()) {\n                 flushRequested = false;\n-            } else {\n+            }\n+\n+            while (!buffers.isEmpty()) {\n                 BufferConsumerWithPartialRecordLength bufferConsumerWithPartialRecordLength =\n                         buffers.peek();\n                 BufferConsumer bufferConsumer =\n", "next_change": null}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 44ecb62b410..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -288,7 +301,9 @@ public class PipelinedSubpartition extends ResultSubpartition\n \n             if (buffers.isEmpty()) {\n                 flushRequested = false;\n-            } else {\n+            }\n+\n+            while (!buffers.isEmpty()) {\n                 BufferConsumerWithPartialRecordLength bufferConsumerWithPartialRecordLength =\n                         buffers.peek();\n                 BufferConsumer bufferConsumer =\n", "next_change": {"commit": "dd8f4e2603309493300099396568ffc681e76e80", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 38d8cf93158..8be8a287836 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -308,7 +477,10 @@ public class PipelinedSubpartition extends ResultSubpartition\n                         buffers.peek();\n                 BufferConsumer bufferConsumer =\n                         bufferConsumerWithPartialRecordLength.getBufferConsumer();\n-\n+                if (Buffer.DataType.TIMEOUTABLE_ALIGNED_CHECKPOINT_BARRIER\n+                        == bufferConsumer.getDataType()) {\n+                    completeTimeoutableCheckpointBarrier(bufferConsumer);\n+                }\n                 buffer = buildSliceBuffer(bufferConsumerWithPartialRecordLength);\n \n                 checkState(\n", "next_change": {"commit": "3b6816e0a6c578dbcbdcf3061ce6205ddb0f5e48", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 8be8a287836..79cf8a5a56c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -488,7 +496,7 @@ public class PipelinedSubpartition extends ResultSubpartition\n                         \"When there are multiple buffers, an unfinished bufferConsumer can not be at the head of the buffers queue.\");\n \n                 if (buffers.size() == 1) {\n-                    // turn off flushRequested flag if we drained all of the available data\n+                    // turn off flushRequested flag if we drained all the available data\n                     flushRequested = false;\n                 }\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "088d16517126d7128e1f072d588b9ce0f4787ae6", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][refactor] Made a safe method for getting the number of buffers in the queue visible in the interface."}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "703662aa61a8f82d4df6de7e0518a568822f71db", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Subpartition is able to notify the desirable buffer size for input buffer consumer."}, {"oid": "60aa2ac29797df576fe14f5c888f09626351b774", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[refactor][runtime] Added postfix `unsafe` for methods ResultSubpartition#getTotalNumberOfBuffers and ResultSubpartition#getTotalNumberOfBytes"}, {"oid": "10b7afae7423d75f94f397699b09deb9fbbdaca5", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Refactor the barrier alignment timer and default priority sequence number"}, {"oid": "dd8f4e2603309493300099396568ffc681e76e80", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Timeout aligned to unaligned checkpoint barrier in the output buffers"}, {"oid": "5c5cc9dbcc1ce9e041ea3aee9ba32ad6a3e19689", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Add missing @GuardedBy annotation for SortMergeResultPartitionReadScheduler and PipelinedSubpartition."}, {"oid": "3b6816e0a6c578dbcbdcf3061ce6205ddb0f5e48", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Fix some typo and syntax mistakes."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5MjQ2Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661592466", "body": "So dangerous, why you so sure that buffers contain at least one object?", "bodyText": "So dangerous, why you so sure that buffers contain at least one object?", "bodyHTML": "<p dir=\"auto\">So dangerous, why you so sure that buffers contain at least one object?</p>", "author": "akalash", "createdAt": "2021-06-30T15:36:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -513,19 +514,20 @@ private void increaseBuffersInBacklog(BufferConsumer buffer) {\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n+    /** Gets the number of non-event buffers in this subpartition. */\n     public int getBuffersInBacklog() {\n-        if (flushRequested || isFinished) {\n-            return buffersInBacklog;\n-        } else {\n-            return Math.max(buffersInBacklog - 1, 0);\n+        synchronized (buffers) {\n+            if (isBlocked || buffers.isEmpty()) {\n+                return 0;\n+            }\n+\n+            if (flushRequested\n+                    || isFinished\n+                    || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5OTc0MQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661999741", "bodyText": "In the previous if block in this method, we have already filtered the case when the buffer queue is empty.", "author": "wsry", "createdAt": "2021-07-01T06:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5MjQ2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 44ecb62b410..fef1387485a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -515,19 +540,24 @@ public class PipelinedSubpartition extends ResultSubpartition\n     }\n \n     /** Gets the number of non-event buffers in this subpartition. */\n+    @Override\n     public int getBuffersInBacklog() {\n         synchronized (buffers) {\n-            if (isBlocked || buffers.isEmpty()) {\n-                return 0;\n-            }\n+            return getBuffersInBacklogUnsafe();\n+        }\n+    }\n \n-            if (flushRequested\n-                    || isFinished\n-                    || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n-                return buffersInBacklog;\n-            } else {\n-                return Math.max(buffersInBacklog - 1, 0);\n-            }\n+    private int getBuffersInBacklogUnsafe() {\n+        if (isBlocked || buffers.isEmpty()) {\n+            return 0;\n+        }\n+\n+        if (flushRequested\n+                || isFinished\n+                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+            return buffersInBacklog;\n+        } else {\n+            return Math.max(buffersInBacklog - 1, 0);\n         }\n     }\n \n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex fef1387485a..134ef688b18 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -539,22 +516,16 @@ public class PipelinedSubpartition extends ResultSubpartition\n         }\n     }\n \n-    /** Gets the number of non-event buffers in this subpartition. */\n-    @Override\n+    /**\n+     * Gets the number of non-event buffers in this subpartition.\n+     *\n+     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n+     * scenarios since it does not make any concurrency guarantees.\n+     */\n+    @SuppressWarnings(\"FieldAccessNotGuarded\")\n+    @VisibleForTesting\n     public int getBuffersInBacklog() {\n-        synchronized (buffers) {\n-            return getBuffersInBacklogUnsafe();\n-        }\n-    }\n-\n-    private int getBuffersInBacklogUnsafe() {\n-        if (isBlocked || buffers.isEmpty()) {\n-            return 0;\n-        }\n-\n-        if (flushRequested\n-                || isFinished\n-                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+        if (flushRequested || isFinished) {\n             return buffersInBacklog;\n         } else {\n             return Math.max(buffersInBacklog - 1, 0);\n", "next_change": {"commit": "639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 134ef688b18..8088cb5d2e3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -516,16 +519,16 @@ public class PipelinedSubpartition extends ResultSubpartition\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n-    public int getBuffersInBacklog() {\n-        if (flushRequested || isFinished) {\n+    /** Gets the number of non-event buffers in this subpartition. */\n+    @Override\n+    public int getBuffersInBacklogUnsafe() {\n+        if (isBlocked || buffers.isEmpty()) {\n+            return 0;\n+        }\n+\n+        if (flushRequested\n+                || isFinished\n+                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n             return buffersInBacklog;\n         } else {\n             return Math.max(buffersInBacklog - 1, 0);\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 44ecb62b410..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -515,19 +543,18 @@ public class PipelinedSubpartition extends ResultSubpartition\n     }\n \n     /** Gets the number of non-event buffers in this subpartition. */\n-    public int getBuffersInBacklog() {\n-        synchronized (buffers) {\n-            if (isBlocked || buffers.isEmpty()) {\n-                return 0;\n-            }\n+    @Override\n+    public int getBuffersInBacklogUnsafe() {\n+        if (isBlocked || buffers.isEmpty()) {\n+            return 0;\n+        }\n \n-            if (flushRequested\n-                    || isFinished\n-                    || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n-                return buffersInBacklog;\n-            } else {\n-                return Math.max(buffersInBacklog - 1, 0);\n-            }\n+        if (flushRequested\n+                || isFinished\n+                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+            return buffersInBacklog;\n+        } else {\n+            return Math.max(buffersInBacklog - 1, 0);\n         }\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "088d16517126d7128e1f072d588b9ce0f4787ae6", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][refactor] Made a safe method for getting the number of buffers in the queue visible in the interface."}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "703662aa61a8f82d4df6de7e0518a568822f71db", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Subpartition is able to notify the desirable buffer size for input buffer consumer."}, {"oid": "60aa2ac29797df576fe14f5c888f09626351b774", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[refactor][runtime] Added postfix `unsafe` for methods ResultSubpartition#getTotalNumberOfBuffers and ResultSubpartition#getTotalNumberOfBytes"}, {"oid": "10b7afae7423d75f94f397699b09deb9fbbdaca5", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Refactor the barrier alignment timer and default priority sequence number"}, {"oid": "dd8f4e2603309493300099396568ffc681e76e80", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Timeout aligned to unaligned checkpoint barrier in the output buffers"}, {"oid": "5c5cc9dbcc1ce9e041ea3aee9ba32ad6a3e19689", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Add missing @GuardedBy annotation for SortMergeResultPartitionReadScheduler and PipelinedSubpartition."}, {"oid": "3b6816e0a6c578dbcbdcf3061ce6205ddb0f5e48", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Fix some typo and syntax mistakes."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5NzQ4Mg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661597482", "body": "It seems that it is the wrong place for such condition. Logically, even if the subpartition is blocked it still has the buffers. But as I understand, specifically for the case where 'initialCredit == 0' it should return 0. So it needs to think how does it do better. ", "bodyText": "It seems that it is the wrong place for such condition. Logically, even if the subpartition is blocked it still has the buffers. But as I understand, specifically for the case where 'initialCredit == 0' it should return 0. So it needs to think how does it do better.", "bodyHTML": "<p dir=\"auto\">It seems that it is the wrong place for such condition. Logically, even if the subpartition is blocked it still has the buffers. But as I understand, specifically for the case where 'initialCredit == 0' it should return 0. So it needs to think how does it do better.</p>", "author": "akalash", "createdAt": "2021-06-30T15:42:05Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -513,19 +514,20 @@ private void increaseBuffersInBacklog(BufferConsumer buffer) {\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n+    /** Gets the number of non-event buffers in this subpartition. */\n     public int getBuffersInBacklog() {\n-        if (flushRequested || isFinished) {\n-            return buffersInBacklog;\n-        } else {\n-            return Math.max(buffersInBacklog - 1, 0);\n+        synchronized (buffers) {\n+            if (isBlocked || buffers.isEmpty()) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAwMzA1OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662003058", "bodyText": "After the channel is blocked, we do not need to allocated any credit at the downstream, because no buffer will be sent. As mentioned in your comment, if the initialCredit is 0, it should return 0. If the initialCredit is not 0, we always have exclusive credits, we still do not need allocate any floating credit. Maybe returning the actual value instead of 0 is a small improvement.", "author": "wsry", "createdAt": "2021-07-01T06:09:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5NzQ4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 44ecb62b410..fef1387485a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -515,19 +540,24 @@ public class PipelinedSubpartition extends ResultSubpartition\n     }\n \n     /** Gets the number of non-event buffers in this subpartition. */\n+    @Override\n     public int getBuffersInBacklog() {\n         synchronized (buffers) {\n-            if (isBlocked || buffers.isEmpty()) {\n-                return 0;\n-            }\n+            return getBuffersInBacklogUnsafe();\n+        }\n+    }\n \n-            if (flushRequested\n-                    || isFinished\n-                    || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n-                return buffersInBacklog;\n-            } else {\n-                return Math.max(buffersInBacklog - 1, 0);\n-            }\n+    private int getBuffersInBacklogUnsafe() {\n+        if (isBlocked || buffers.isEmpty()) {\n+            return 0;\n+        }\n+\n+        if (flushRequested\n+                || isFinished\n+                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+            return buffersInBacklog;\n+        } else {\n+            return Math.max(buffersInBacklog - 1, 0);\n         }\n     }\n \n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex fef1387485a..134ef688b18 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -539,22 +516,16 @@ public class PipelinedSubpartition extends ResultSubpartition\n         }\n     }\n \n-    /** Gets the number of non-event buffers in this subpartition. */\n-    @Override\n+    /**\n+     * Gets the number of non-event buffers in this subpartition.\n+     *\n+     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n+     * scenarios since it does not make any concurrency guarantees.\n+     */\n+    @SuppressWarnings(\"FieldAccessNotGuarded\")\n+    @VisibleForTesting\n     public int getBuffersInBacklog() {\n-        synchronized (buffers) {\n-            return getBuffersInBacklogUnsafe();\n-        }\n-    }\n-\n-    private int getBuffersInBacklogUnsafe() {\n-        if (isBlocked || buffers.isEmpty()) {\n-            return 0;\n-        }\n-\n-        if (flushRequested\n-                || isFinished\n-                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+        if (flushRequested || isFinished) {\n             return buffersInBacklog;\n         } else {\n             return Math.max(buffersInBacklog - 1, 0);\n", "next_change": {"commit": "639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 134ef688b18..8088cb5d2e3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -516,16 +519,16 @@ public class PipelinedSubpartition extends ResultSubpartition\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n-    public int getBuffersInBacklog() {\n-        if (flushRequested || isFinished) {\n+    /** Gets the number of non-event buffers in this subpartition. */\n+    @Override\n+    public int getBuffersInBacklogUnsafe() {\n+        if (isBlocked || buffers.isEmpty()) {\n+            return 0;\n+        }\n+\n+        if (flushRequested\n+                || isFinished\n+                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n             return buffersInBacklog;\n         } else {\n             return Math.max(buffersInBacklog - 1, 0);\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 44ecb62b410..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -515,19 +543,18 @@ public class PipelinedSubpartition extends ResultSubpartition\n     }\n \n     /** Gets the number of non-event buffers in this subpartition. */\n-    public int getBuffersInBacklog() {\n-        synchronized (buffers) {\n-            if (isBlocked || buffers.isEmpty()) {\n-                return 0;\n-            }\n+    @Override\n+    public int getBuffersInBacklogUnsafe() {\n+        if (isBlocked || buffers.isEmpty()) {\n+            return 0;\n+        }\n \n-            if (flushRequested\n-                    || isFinished\n-                    || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n-                return buffersInBacklog;\n-            } else {\n-                return Math.max(buffersInBacklog - 1, 0);\n-            }\n+        if (flushRequested\n+                || isFinished\n+                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+            return buffersInBacklog;\n+        } else {\n+            return Math.max(buffersInBacklog - 1, 0);\n         }\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "088d16517126d7128e1f072d588b9ce0f4787ae6", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][refactor] Made a safe method for getting the number of buffers in the queue visible in the interface."}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "703662aa61a8f82d4df6de7e0518a568822f71db", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Subpartition is able to notify the desirable buffer size for input buffer consumer."}, {"oid": "60aa2ac29797df576fe14f5c888f09626351b774", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[refactor][runtime] Added postfix `unsafe` for methods ResultSubpartition#getTotalNumberOfBuffers and ResultSubpartition#getTotalNumberOfBytes"}, {"oid": "10b7afae7423d75f94f397699b09deb9fbbdaca5", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Refactor the barrier alignment timer and default priority sequence number"}, {"oid": "dd8f4e2603309493300099396568ffc681e76e80", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Timeout aligned to unaligned checkpoint barrier in the output buffers"}, {"oid": "5c5cc9dbcc1ce9e041ea3aee9ba32ad6a3e19689", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Add missing @GuardedBy annotation for SortMergeResultPartitionReadScheduler and PipelinedSubpartition."}, {"oid": "3b6816e0a6c578dbcbdcf3061ce6205ddb0f5e48", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Fix some typo and syntax mistakes."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5OTQ1Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661599456", "body": "As I understand, initialCredit is an unchangeable value, and BufferManager and AvailableBufferQueue know this value so maybe it is better to avoid this parameter?", "bodyText": "As I understand, initialCredit is an unchangeable value, and BufferManager and AvailableBufferQueue know this value so maybe it is better to avoid this parameter?", "bodyHTML": "<p dir=\"auto\">As I understand, initialCredit is an unchangeable value, and BufferManager and AvailableBufferQueue know this value so maybe it is better to avoid this parameter?</p>", "author": "akalash", "createdAt": "2021-06-30T15:44:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -83,8 +84,13 @@ public BufferManager(\n     // ------------------------------------------------------------------------\n \n     @Nullable\n-    Buffer requestBuffer() {\n+    Buffer requestBuffer(int initialCredit) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAwMzQ3Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662003477", "bodyText": "You are right, we can avoid this parameter.", "author": "wsry", "createdAt": "2021-07-01T06:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5OTQ1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c161aff32e5aed483ca0722e0504ec8493348947", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -84,13 +84,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n     // ------------------------------------------------------------------------\n \n     @Nullable\n-    Buffer requestBuffer(int initialCredit) {\n+    Buffer requestBuffer() {\n         synchronized (bufferQueue) {\n             // decrease the number of buffers require to avoid the possibility of\n             // allocating more than required buffers after the buffer is taken\n-            if (initialCredit == 0) {\n-                --numRequiredBuffers;\n-            }\n+            --numRequiredBuffers;\n             return bufferQueue.takeBuffer();\n         }\n     }\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex f417f2dee4b..82162f51ae3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -86,9 +85,6 @@ public class BufferManager implements BufferListener, BufferRecycler {\n     @Nullable\n     Buffer requestBuffer() {\n         synchronized (bufferQueue) {\n-            // decrease the number of buffers require to avoid the possibility of\n-            // allocating more than required buffers after the buffer is taken\n-            --numRequiredBuffers;\n             return bufferQueue.takeBuffer();\n         }\n     }\n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 82162f51ae3..0867fbba828 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -85,6 +86,9 @@ public class BufferManager implements BufferListener, BufferRecycler {\n     @Nullable\n     Buffer requestBuffer() {\n         synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            --numRequiredBuffers;\n             return bufferQueue.takeBuffer();\n         }\n     }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -84,13 +84,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n     // ------------------------------------------------------------------------\n \n     @Nullable\n-    Buffer requestBuffer(int initialCredit) {\n+    Buffer requestBuffer() {\n         synchronized (bufferQueue) {\n             // decrease the number of buffers require to avoid the possibility of\n             // allocating more than required buffers after the buffer is taken\n-            if (initialCredit == 0) {\n-                --numRequiredBuffers;\n-            }\n+            --numRequiredBuffers;\n             return bufferQueue.takeBuffer();\n         }\n     }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "48a384dffc770289a38df816a38bd336ea992ed7", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[FLINK-23466][network] Fix the bug that buffer listeners may not be notified when recycling buffers"}, {"oid": "c91837edb782c67eab799a569077053695a29fc3", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[hotfix][refactor] Remove BufferListener#NotificationResult to simplify the code"}, {"oid": "38f7c593538d78e67ed75f006826b9fc3e97826e", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[hotfix] Rename some methods of NetworkBufferPool and add more comments for better readability"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwMjExMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661602113", "body": "I don't understand why `initialCredit == 0` should be handled differently here. Even if `initialCredit == 1` and the Buffer is requested we should decrease this value, or am I wrong?", "bodyText": "I don't understand why initialCredit == 0 should be handled differently here. Even if initialCredit == 1 and the Buffer is requested we should decrease this value, or am I wrong?", "bodyHTML": "<p dir=\"auto\">I don't understand why <code>initialCredit == 0</code> should be handled differently here. Even if <code>initialCredit == 1</code> and the Buffer is requested we should decrease this value, or am I wrong?</p>", "author": "akalash", "createdAt": "2021-06-30T15:47:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -83,8 +84,13 @@ public BufferManager(\n     // ------------------------------------------------------------------------\n \n     @Nullable\n-    Buffer requestBuffer() {\n+    Buffer requestBuffer(int initialCredit) {\n         synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            if (initialCredit == 0) {\n+                --numRequiredBuffers;", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAwNDMxMQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662004311", "bodyText": "You are right, we should always decrease this value.", "author": "wsry", "createdAt": "2021-07-01T06:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwMjExMw=="}], "type": "inlineReview", "revised_code": {"commit": "c161aff32e5aed483ca0722e0504ec8493348947", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -84,13 +84,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n     // ------------------------------------------------------------------------\n \n     @Nullable\n-    Buffer requestBuffer(int initialCredit) {\n+    Buffer requestBuffer() {\n         synchronized (bufferQueue) {\n             // decrease the number of buffers require to avoid the possibility of\n             // allocating more than required buffers after the buffer is taken\n-            if (initialCredit == 0) {\n-                --numRequiredBuffers;\n-            }\n+            --numRequiredBuffers;\n             return bufferQueue.takeBuffer();\n         }\n     }\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex f417f2dee4b..82162f51ae3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -86,9 +85,6 @@ public class BufferManager implements BufferListener, BufferRecycler {\n     @Nullable\n     Buffer requestBuffer() {\n         synchronized (bufferQueue) {\n-            // decrease the number of buffers require to avoid the possibility of\n-            // allocating more than required buffers after the buffer is taken\n-            --numRequiredBuffers;\n             return bufferQueue.takeBuffer();\n         }\n     }\n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 82162f51ae3..0867fbba828 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -85,6 +86,9 @@ public class BufferManager implements BufferListener, BufferRecycler {\n     @Nullable\n     Buffer requestBuffer() {\n         synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            --numRequiredBuffers;\n             return bufferQueue.takeBuffer();\n         }\n     }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -84,13 +84,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n     // ------------------------------------------------------------------------\n \n     @Nullable\n-    Buffer requestBuffer(int initialCredit) {\n+    Buffer requestBuffer() {\n         synchronized (bufferQueue) {\n             // decrease the number of buffers require to avoid the possibility of\n             // allocating more than required buffers after the buffer is taken\n-            if (initialCredit == 0) {\n-                --numRequiredBuffers;\n-            }\n+            --numRequiredBuffers;\n             return bufferQueue.takeBuffer();\n         }\n     }\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "48a384dffc770289a38df816a38bd336ea992ed7", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[FLINK-23466][network] Fix the bug that buffer listeners may not be notified when recycling buffers"}, {"oid": "c91837edb782c67eab799a569077053695a29fc3", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[hotfix][refactor] Remove BufferListener#NotificationResult to simplify the code"}, {"oid": "38f7c593538d78e67ed75f006826b9fc3e97826e", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[hotfix] Rename some methods of NetworkBufferPool and add more comments for better readability"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwMzY2MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661603660", "body": "As I understand, the negative number is still illegal. So maybe it makes sense to add checkArgument for `numExclusiveBuffers < 0`?", "bodyText": "As I understand, the negative number is still illegal. So maybe it makes sense to add checkArgument for numExclusiveBuffers < 0?", "bodyHTML": "<p dir=\"auto\">As I understand, the negative number is still illegal. So maybe it makes sense to add checkArgument for <code>numExclusiveBuffers &lt; 0</code>?</p>", "author": "akalash", "createdAt": "2021-06-30T15:49:02Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -130,11 +136,11 @@ private boolean shouldContinueRequest(BufferPool bufferPool) {\n \n     /** Requests exclusive buffers from the provider. */\n     void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n-        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n-        checkArgument(\n-                !segments.isEmpty(),\n-                \"The number of exclusive buffers per channel should be larger than 0.\");\n+        if (numExclusiveBuffers <= 0) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAwNTUzMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662005533", "bodyText": "You are right, I will add a checkArgument.", "author": "wsry", "createdAt": "2021-07-01T06:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwMzY2MA=="}], "type": "inlineReview", "revised_code": {"commit": "c161aff32e5aed483ca0722e0504ec8493348947", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -136,12 +134,20 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \n     /** Requests exclusive buffers from the provider. */\n     void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n-        if (numExclusiveBuffers <= 0) {\n+        checkArgument(numExclusiveBuffers >= 0, \"Num exclusive buffers must be non-negative.\");\n+        if (numExclusiveBuffers == 0) {\n             return;\n         }\n \n         Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n         synchronized (bufferQueue) {\n+            // AvailableBufferQueue::addExclusiveBuffer may release the previously allocated\n+            // floating buffer, which requires the caller to recycle these released floating\n+            // buffers. There should be no floating buffers that have been allocated before the\n+            // exclusive buffers are initialized, so here only a simple assertion is required\n+            checkState(\n+                    unsynchronizedGetFloatingBuffersAvailable() == 0,\n+                    \"Bug in buffer allocation logic: floating buffer is allocated before exclusive buffers are initialized.\");\n             for (MemorySegment segment : segments) {\n                 bufferQueue.addExclusiveBuffer(\n                         new NetworkBuffer(segment, this), numRequiredBuffers);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -136,12 +134,20 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \n     /** Requests exclusive buffers from the provider. */\n     void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n-        if (numExclusiveBuffers <= 0) {\n+        checkArgument(numExclusiveBuffers >= 0, \"Num exclusive buffers must be non-negative.\");\n+        if (numExclusiveBuffers == 0) {\n             return;\n         }\n \n         Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n         synchronized (bufferQueue) {\n+            // AvailableBufferQueue::addExclusiveBuffer may release the previously allocated\n+            // floating buffer, which requires the caller to recycle these released floating\n+            // buffers. There should be no floating buffers that have been allocated before the\n+            // exclusive buffers are initialized, so here only a simple assertion is required\n+            checkState(\n+                    unsynchronizedGetFloatingBuffersAvailable() == 0,\n+                    \"Bug in buffer allocation logic: floating buffer is allocated before exclusive buffers are initialized.\");\n             for (MemorySegment segment : segments) {\n                 bufferQueue.addExclusiveBuffer(\n                         new NetworkBuffer(segment, this), numRequiredBuffers);\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "48a384dffc770289a38df816a38bd336ea992ed7", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[FLINK-23466][network] Fix the bug that buffer listeners may not be notified when recycling buffers"}, {"oid": "c91837edb782c67eab799a569077053695a29fc3", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[hotfix][refactor] Remove BufferListener#NotificationResult to simplify the code"}, {"oid": "38f7c593538d78e67ed75f006826b9fc3e97826e", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[hotfix] Rename some methods of NetworkBufferPool and add more comments for better readability"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNTE3Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661605173", "body": "Can you explain what kind of deadlock can happen? Between LocalBufferPool and BufferManager?", "bodyText": "Can you explain what kind of deadlock can happen? Between LocalBufferPool and BufferManager?", "bodyHTML": "<p dir=\"auto\">Can you explain what kind of deadlock can happen? Between LocalBufferPool and BufferManager?</p>", "author": "akalash", "createdAt": "2021-06-30T15:50:49Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -215,9 +221,15 @@ public void recycle(MemorySegment segment) {\n     }\n \n     void releaseFloatingBuffers() {\n+        Queue<Buffer> buffers;\n         synchronized (bufferQueue) {\n             numRequiredBuffers = 0;\n-            bufferQueue.releaseFloatingBuffers();\n+            buffers = bufferQueue.clearFloatingBuffers();\n+        }\n+\n+        // recycle all buffers out of the synchronization block to avoid dead lock", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAxMDQ0NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662010444", "bodyText": "Each RemoteInputChannel has its own BufferManager and bufferQueue, floating buffers recycled by one RemoteInputChannel can be assigned to other RemoteInputChannels directly and the buffer assignment also need to sync the bufferQueue object. Besides, different RemoteInputChannels may recycle buffers simultaneously, which means we may need to lock two bufferQueue objects of different RemoteInputChannels simultaneously in the reverse order. I already encountered this dead lock when running test.", "author": "wsry", "createdAt": "2021-07-01T06:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNTE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjIzOTA2Mg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662239062", "bodyText": "As I understand from your explanation, it relates to this BufferManager#notifyBufferAvailable. But I still don't get which threads can call the releaseFloatingBuffers simultaneously. It is not so important, but just for curiosity if you have the stacktrace of this deadlock can you share it with me(or just tell me which test)?\nAnyway, your changes look correct here.", "author": "akalash", "createdAt": "2021-07-01T12:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNTE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjY4OTEwMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662689103", "bodyText": "It is the new logic added by this PR causes the problem. RemoteInputChannel#onBlockingUpstream will call BufferManager#releaseFloatingBuffers in netty thread and different RemoteInputChannels can have different netty thread.", "author": "wsry", "createdAt": "2021-07-02T02:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNTE3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..82162f51ae3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -213,23 +215,21 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        try {\n-            inputChannel.notifyBufferAvailable(numAddedBuffers);\n-        } catch (Throwable t) {\n-            ExceptionUtils.rethrow(t);\n+        if (releasedFloatingBuffer != null) {\n+            releasedFloatingBuffer.recycleBuffer();\n+        } else {\n+            try {\n+                inputChannel.notifyBufferAvailable(1);\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            }\n         }\n     }\n \n     void releaseFloatingBuffers() {\n-        Queue<Buffer> buffers;\n         synchronized (bufferQueue) {\n             numRequiredBuffers = 0;\n-            buffers = bufferQueue.clearFloatingBuffers();\n-        }\n-\n-        // recycle all buffers out of the synchronization block to avoid dead lock\n-        while (!buffers.isEmpty()) {\n-            buffers.poll().recycleBuffer();\n+            bufferQueue.releaseFloatingBuffers();\n         }\n     }\n \n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 82162f51ae3..0867fbba828 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n", "chunk": "@@ -227,9 +231,15 @@ public class BufferManager implements BufferListener, BufferRecycler {\n     }\n \n     void releaseFloatingBuffers() {\n+        Queue<Buffer> buffers;\n         synchronized (bufferQueue) {\n             numRequiredBuffers = 0;\n-            bufferQueue.releaseFloatingBuffers();\n+            buffers = bufferQueue.clearFloatingBuffers();\n+        }\n+\n+        // recycle all buffers out of the synchronization block to avoid dead lock\n+        while (!buffers.isEmpty()) {\n+            buffers.poll().recycleBuffer();\n         }\n     }\n \n", "next_change": null}]}}]}, "revised_code_in_main": null, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "48a384dffc770289a38df816a38bd336ea992ed7", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[FLINK-23466][network] Fix the bug that buffer listeners may not be notified when recycling buffers"}, {"oid": "c91837edb782c67eab799a569077053695a29fc3", "committedDate": "2021-08-30 11:05:52 +0200", "message": "[hotfix][refactor] Remove BufferListener#NotificationResult to simplify the code"}, {"oid": "38f7c593538d78e67ed75f006826b9fc3e97826e", "committedDate": "2022-01-13 15:10:51 +0100", "message": "[hotfix] Rename some methods of NetworkBufferPool and add more comments for better readability"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNjUwMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661606502", "body": "The same question that earlier - is this bug? or where did we recycle the buffer before this changes?", "bodyText": "The same question that earlier - is this bug? or where did we recycle the buffer before this changes?", "bodyHTML": "<p dir=\"auto\">The same question that earlier - is this bug? or where did we recycle the buffer before this changes?</p>", "author": "akalash", "createdAt": "2021-06-30T15:52:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -265,6 +265,13 @@ public void run() {\n                 channelInfo,\n                 channelStatePersister,\n                 next.getSequenceNumber());\n+\n+        // ignore the empty buffer directly\n+        if (buffer.readableBytes() == 0) {\n+            buffer.recycleBuffer();", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAxMTY2Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662011666", "bodyText": "Before this change, the buffer is recycled in the pollBuffer method of Subpartition because no empty buffer is sent.", "author": "wsry", "createdAt": "2021-07-01T06:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNjUwMg=="}], "type": "inlineReview", "revised_code": {"commit": "01b2bc58b30a2a3730895f7c50ff59099bd273d2", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\nindex bba98cc9e60..15121b2f78f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n", "chunk": "@@ -265,13 +249,6 @@ public class LocalInputChannel extends InputChannel implements BufferAvailabilit\n                 channelInfo,\n                 channelStatePersister,\n                 next.getSequenceNumber());\n-\n-        // ignore the empty buffer directly\n-        if (buffer.readableBytes() == 0) {\n-            buffer.recycleBuffer();\n-            return getNextBuffer();\n-        }\n-\n         return Optional.of(\n                 new BufferAndAvailability(\n                         buffer,\n", "next_change": null}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\nindex bba98cc9e60..15121b2f78f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n", "chunk": "@@ -265,13 +249,6 @@ public class LocalInputChannel extends InputChannel implements BufferAvailabilit\n                 channelInfo,\n                 channelStatePersister,\n                 next.getSequenceNumber());\n-\n-        // ignore the empty buffer directly\n-        if (buffer.readableBytes() == 0) {\n-            buffer.recycleBuffer();\n-            return getNextBuffer();\n-        }\n-\n         return Optional.of(\n                 new BufferAndAvailability(\n                         buffer,\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "88c5091a4d152918fb71844f5c1f15a2d20a1ee1", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] LocalInputChannel notifying the subpartition about the new buffer size directly."}, {"oid": "f91bd772de866a48d65dfcb31d4ef0d1ef2c001e", "committedDate": "2021-11-01 19:13:12 +0800", "message": "[FLINK-24671][runtime] Return 0 buffers in use until subpartition view initialization in order to avoid NPE"}, {"oid": "60a73fa88bf8589f00f1c0be6980ef0703808f21", "committedDate": "2021-11-09 11:40:16 +0100", "message": "[FLINK-24738][runtime] Ignoring buffer size announcement if the subpartition view has not created yet"}, {"oid": "f4fd4f8bb66867821cb0f171218d85f8386b0897", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] Move consumedSubpartitionIndex from SingleInputGate to InputChannel"}, {"oid": "5c2ec72982128fc1a30014677916e0dd21f9c1d2", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] SingleInputGate supports consuming subpartition range"}, {"oid": "1c044753b0f0e4c23f954d71f355d1368c41061f", "committedDate": "2022-08-02 21:59:34 +0800", "message": "[FLINK-28373][network] Read a full buffer of data per file IO read request for sort-shuffle"}, {"oid": "4e790646c378ee69c149781950cdcab50d891618", "committedDate": "2022-08-05 00:48:18 +0800", "message": "Revert \"[FLINK-28373][network] Read a full buffer of data per file IO read request for sort-shuffle\""}, {"oid": "d6a47d897a9a4753c800b39adb17c06e154422cc", "committedDate": "2022-08-09 14:48:39 +0800", "message": "[FLINK-28373][network] Read a full buffer of data per file IO read request for sort-shuffle"}, {"oid": "6398abcbff06b3e488a273144680f4838b4f1c92", "committedDate": "2023-06-09 22:48:37 +0800", "message": "[FLINK-31636][network] Introduce the NettyService framework"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxMDY0Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661610647", "body": "How is it even possible to get an empty buffer? Who is sending it?", "bodyText": "How is it even possible to get an empty buffer? Who is sending it?", "bodyHTML": "<p dir=\"auto\">How is it even possible to get an empty buffer? Who is sending it?</p>", "author": "akalash", "createdAt": "2021-06-30T15:57:06Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -265,6 +265,13 @@ public void run() {\n                 channelInfo,\n                 channelStatePersister,\n                 next.getSequenceNumber());\n+\n+        // ignore the empty buffer directly\n+        if (buffer.readableBytes() == 0) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAxMjY2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662012667", "bodyText": "After this change, we can poll an empty buffer from the Subpartition of the upstream task.", "author": "wsry", "createdAt": "2021-07-01T06:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxMDY0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "01b2bc58b30a2a3730895f7c50ff59099bd273d2", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\nindex bba98cc9e60..15121b2f78f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n", "chunk": "@@ -265,13 +249,6 @@ public class LocalInputChannel extends InputChannel implements BufferAvailabilit\n                 channelInfo,\n                 channelStatePersister,\n                 next.getSequenceNumber());\n-\n-        // ignore the empty buffer directly\n-        if (buffer.readableBytes() == 0) {\n-            buffer.recycleBuffer();\n-            return getNextBuffer();\n-        }\n-\n         return Optional.of(\n                 new BufferAndAvailability(\n                         buffer,\n", "next_change": null}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\nindex bba98cc9e60..15121b2f78f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n", "chunk": "@@ -265,13 +249,6 @@ public class LocalInputChannel extends InputChannel implements BufferAvailabilit\n                 channelInfo,\n                 channelStatePersister,\n                 next.getSequenceNumber());\n-\n-        // ignore the empty buffer directly\n-        if (buffer.readableBytes() == 0) {\n-            buffer.recycleBuffer();\n-            return getNextBuffer();\n-        }\n-\n         return Optional.of(\n                 new BufferAndAvailability(\n                         buffer,\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "88c5091a4d152918fb71844f5c1f15a2d20a1ee1", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] LocalInputChannel notifying the subpartition about the new buffer size directly."}, {"oid": "f91bd772de866a48d65dfcb31d4ef0d1ef2c001e", "committedDate": "2021-11-01 19:13:12 +0800", "message": "[FLINK-24671][runtime] Return 0 buffers in use until subpartition view initialization in order to avoid NPE"}, {"oid": "60a73fa88bf8589f00f1c0be6980ef0703808f21", "committedDate": "2021-11-09 11:40:16 +0100", "message": "[FLINK-24738][runtime] Ignoring buffer size announcement if the subpartition view has not created yet"}, {"oid": "f4fd4f8bb66867821cb0f171218d85f8386b0897", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] Move consumedSubpartitionIndex from SingleInputGate to InputChannel"}, {"oid": "5c2ec72982128fc1a30014677916e0dd21f9c1d2", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] SingleInputGate supports consuming subpartition range"}, {"oid": "1c044753b0f0e4c23f954d71f355d1368c41061f", "committedDate": "2022-08-02 21:59:34 +0800", "message": "[FLINK-28373][network] Read a full buffer of data per file IO read request for sort-shuffle"}, {"oid": "4e790646c378ee69c149781950cdcab50d891618", "committedDate": "2022-08-05 00:48:18 +0800", "message": "Revert \"[FLINK-28373][network] Read a full buffer of data per file IO read request for sort-shuffle\""}, {"oid": "d6a47d897a9a4753c800b39adb17c06e154422cc", "committedDate": "2022-08-09 14:48:39 +0800", "message": "[FLINK-28373][network] Read a full buffer of data per file IO read request for sort-shuffle"}, {"oid": "6398abcbff06b3e488a273144680f4838b4f1c92", "committedDate": "2023-06-09 22:48:37 +0800", "message": "[FLINK-31636][network] Introduce the NettyService framework"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxMzIwMQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661613201", "body": "Why can not we do the same thing for any number of credits not only for `initialCredit == 0`? Or does it slow down the load after resuming?", "bodyText": "Why can not we do the same thing for any number of credits not only for initialCredit == 0? Or does it slow down the load after resuming?", "bodyHTML": "<p dir=\"auto\">Why can not we do the same thing for any number of credits not only for <code>initialCredit == 0</code>? Or does it slow down the load after resuming?</p>", "author": "akalash", "createdAt": "2021-06-30T16:00:20Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -357,11 +359,26 @@ public void resumeConsumption() throws IOException {\n         checkState(!isReleased.get(), \"Channel released.\");\n         checkPartitionRequestQueueInitialized();\n \n+        if (initialCredit == 0) {\n+            unannouncedCredit.set(0);\n+        }\n+\n         // notifies the producer that this channel is ready to\n         // unblock from checkpoint and resume data consumption\n         partitionRequestClient.resumeConsumption(this);\n     }\n \n+    private void onBlockingUpstream() {\n+        if (initialCredit == 0) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAxNjE1Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662016156", "bodyText": "I think it does not slow down the load after resuming. It is just for the simplicity of handling unannounced credit. Maybe we have already announced the credits to the producer.", "author": "wsry", "createdAt": "2021-07-01T06:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxMzIwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "1814aee57851711782cc2d922c4ef8f118a74c13", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex ec5281cb0db..4be0669defa 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -368,6 +368,14 @@ public class RemoteInputChannel extends InputChannel {\n         partitionRequestClient.resumeConsumption(this);\n     }\n \n+    @Override\n+    public void acknowledgeAllRecordsProcessed() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.acknowledgeAllRecordsProcessed(this);\n+    }\n+\n     private void onBlockingUpstream() {\n         if (initialCredit == 0) {\n             // release the allocated floating buffers so that they can be used by other channels if\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 4be0669defa..072db4723c5 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -376,17 +370,6 @@ public class RemoteInputChannel extends InputChannel {\n         partitionRequestClient.acknowledgeAllRecordsProcessed(this);\n     }\n \n-    private void onBlockingUpstream() {\n-        if (initialCredit == 0) {\n-            // release the allocated floating buffers so that they can be used by other channels if\n-            // no exclusive buffer is configured, it is important because a blocked channel can not\n-            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n-            // other channels may can't allocate new buffers for data transmission (an extreme case\n-            // is that we only have 1 floating buffer and 0 exclusive buffer)\n-            bufferManager.releaseFloatingBuffers();\n-        }\n-    }\n-\n     // ------------------------------------------------------------------------\n     // Network I/O notifications (called by network I/O thread)\n     // ------------------------------------------------------------------------\n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 072db4723c5..4ff36b9a632 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -370,6 +380,17 @@ public class RemoteInputChannel extends InputChannel {\n         partitionRequestClient.acknowledgeAllRecordsProcessed(this);\n     }\n \n+    private void onBlockingUpstream() {\n+        if (initialCredit == 0) {\n+            // release the allocated floating buffers so that they can be used by other channels if\n+            // no exclusive buffer is configured, it is important because a blocked channel can not\n+            // transmit any data so the allocated floating buffers can not be recycled, as a result,\n+            // other channels may can't allocate new buffers for data transmission (an extreme case\n+            // is that we only have 1 floating buffer and 0 exclusive buffer)\n+            bufferManager.releaseFloatingBuffers();\n+        }\n+    }\n+\n     // ------------------------------------------------------------------------\n     // Network I/O notifications (called by network I/O thread)\n     // ------------------------------------------------------------------------\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex ec5281cb0db..f9cedf71105 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -368,6 +373,14 @@ public class RemoteInputChannel extends InputChannel {\n         partitionRequestClient.resumeConsumption(this);\n     }\n \n+    @Override\n+    public void acknowledgeAllRecordsProcessed() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.acknowledgeAllRecordsProcessed(this);\n+    }\n+\n     private void onBlockingUpstream() {\n         if (initialCredit == 0) {\n             // release the allocated floating buffers so that they can be used by other channels if\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "0ee049db1ffe8a4a68bcd97608774ee488d02a21", "committedDate": "2021-09-03 08:19:32 +0200", "message": "[FLINK-23907] Use primitive functional interfaces"}, {"oid": "138e83e2bc6feb59ecd839b03491cd8f23ee1c66", "committedDate": "2021-11-08 08:56:34 +0100", "message": "[FLINK-24738][runtime] Ignoring buffer size announcement if the channel is released already"}, {"oid": "4eea7bc9352134a06d2b207c9a94dd46a01c6132", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[FLINK-24657][runtime] Added metric of the total real size of input/output buffers queue"}, {"oid": "f4fd4f8bb66867821cb0f171218d85f8386b0897", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] Move consumedSubpartitionIndex from SingleInputGate to InputChannel"}, {"oid": "5c2ec72982128fc1a30014677916e0dd21f9c1d2", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] SingleInputGate supports consuming subpartition range"}, {"oid": "6398abcbff06b3e488a273144680f4838b4f1c92", "committedDate": "2023-06-09 22:48:37 +0800", "message": "[FLINK-31636][network] Introduce the NettyService framework"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661614767", "body": "Do we need to do so because we released all buffers in onBlockingUpstream? If so can we hold this code in one place, ex. to move it into onBlockingUpstream?", "bodyText": "Do we need to do so because we released all buffers in onBlockingUpstream? If so can we hold this code in one place, ex. to move it into onBlockingUpstream?", "bodyHTML": "<p dir=\"auto\">Do we need to do so because we released all buffers in onBlockingUpstream? If so can we hold this code in one place, ex. to move it into onBlockingUpstream?</p>", "author": "akalash", "createdAt": "2021-06-30T16:02:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -357,11 +359,26 @@ public void resumeConsumption() throws IOException {\n         checkState(!isReleased.get(), \"Channel released.\");\n         checkPartitionRequestQueueInitialized();\n \n+        if (initialCredit == 0) {\n+            unannouncedCredit.set(0);", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAyMDQ3Mg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662020472", "bodyText": "Doing this in the onBlockingUpstream method can guarantee that after resumeConsumption the unannouncedCredit is in a clean state. Because the unannouncedCredit may get increased after that if there is any new available floating credit.", "author": "wsry", "createdAt": "2021-07-01T06:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY4Mjk4OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664682988", "bodyText": "But how can this floating credit be assigned to this blocked RemoteInputChannel? Wouldn't it cause the same deadlock, when floating buffers are assigned to blocked channels and job/task can not make any progress?\nIt sounds like maybe this should have been handled sooner when trying to increase unannouncedCredit?", "author": "pnowojski", "createdAt": "2021-07-06T15:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA2ODA0OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665068048", "bodyText": "This because RemoteInputChannel#notifyBufferAvailable which increases unannouncedCredit and floating buffer assignment is not an atomic operation. There is a possibility:\n\nthe floating buffer is assigned;\nthe floating buffer is released because of receiving an event which blocks the channel;\nthe notifyBufferAvailable is called and the unannouncedCredit is increased.\n\nDo you mean we should make RemoteInputChannel#notifyBufferAvailable and floating buffer assignment an atomic operation?", "author": "wsry", "createdAt": "2021-07-07T06:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTM5NDU1MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665394550", "bodyText": "Something sounds wrong here. The race condition that you described above, does it mean that unannouncedCredit can be out of sync? That we in reality have released all floating buffers, channel is blocked, but actually unannouncedCredit > 0? And it's only fixed after calling resumeConsumption()?\nAnd as I understand it, without your change, this problem doesn't exist, as floating buffers are kept assigned to the blocked channel and the unannouncedCredit (or maybe even assigned AddCredit that might have been sent to the upstream node)  are consistent with the reality. Also those assigned floating buffers are not used because channel is blocked, but that is not a big issue, because thanks to the exclusive buffers, other channels can make a progress?", "author": "pnowojski", "createdAt": "2021-07-07T13:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTgxNDMzNg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665814336", "bodyText": "Something sounds wrong here. The race condition that you described above, does it mean that unannouncedCredit can be out of sync? That we in reality have released all floating buffers, channel is blocked, but actually unannouncedCredit > 0? And it's only fixed after calling resumeConsumption()?\n\nYes, exactly.\n\nAnd as I understand it, without your change, this problem doesn't exist, as floating buffers are kept assigned to the blocked channel and the unannouncedCredit (or maybe even assigned AddCredit that might have been sent to the upstream node) are consistent with the reality. Also those assigned floating buffers are not used because channel is blocked, but that is not a big issue, because thanks to the exclusive buffers, other channels can make a progress?\n\nThat only happens when the exclusive credit is 0. If the exclusive credit is not 0, the allocated floating buffers will not be released and if the exclusive credit is 0, we release the floating buffers allocated to let other channel use them to avoid deadlock, an extreme case is that we only have 1 floating buffer and no exclusive buffer. At downstream, the unannounced credit will be reset, at the upstream, the available credit is also reset to 0 when resume consumption.", "author": "wsry", "createdAt": "2021-07-08T01:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjMzNDUwNg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666334506", "bodyText": "Ok, can you at least add a comment explaining why this is set to 0 here?", "author": "pnowojski", "createdAt": "2021-07-08T16:11:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2792e1a43d72ffc013bb60bdea52a577316d933a", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex ec5281cb0db..f9cedf71105 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -360,6 +360,11 @@ public class RemoteInputChannel extends InputChannel {\n         checkPartitionRequestQueueInitialized();\n \n         if (initialCredit == 0) {\n+            // this unannounced credit can be a positive value because credit assignment and the\n+            // increase of this value is not an atomic operation and as a result, this unannounced\n+            // credit value can be get increased even after this channel has been blocked and all\n+            // floating credits are released, it is important to clear this unannounced credit and\n+            // at the same time reset the sender's available credits to keep consistency\n             unannouncedCredit.set(0);\n         }\n \n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex f9cedf71105..072db4723c5 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -359,15 +357,6 @@ public class RemoteInputChannel extends InputChannel {\n         checkState(!isReleased.get(), \"Channel released.\");\n         checkPartitionRequestQueueInitialized();\n \n-        if (initialCredit == 0) {\n-            // this unannounced credit can be a positive value because credit assignment and the\n-            // increase of this value is not an atomic operation and as a result, this unannounced\n-            // credit value can be get increased even after this channel has been blocked and all\n-            // floating credits are released, it is important to clear this unannounced credit and\n-            // at the same time reset the sender's available credits to keep consistency\n-            unannouncedCredit.set(0);\n-        }\n-\n         // notifies the producer that this channel is ready to\n         // unblock from checkpoint and resume data consumption\n         partitionRequestClient.resumeConsumption(this);\n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 072db4723c5..4ff36b9a632 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -357,6 +358,15 @@ public class RemoteInputChannel extends InputChannel {\n         checkState(!isReleased.get(), \"Channel released.\");\n         checkPartitionRequestQueueInitialized();\n \n+        if (initialCredit == 0) {\n+            // this unannounced credit can be a positive value because credit assignment and the\n+            // increase of this value is not an atomic operation and as a result, this unannounced\n+            // credit value can be get increased even after this channel has been blocked and all\n+            // floating credits are released, it is important to clear this unannounced credit and\n+            // at the same time reset the sender's available credits to keep consistency\n+            unannouncedCredit.set(0);\n+        }\n+\n         // notifies the producer that this channel is ready to\n         // unblock from checkpoint and resume data consumption\n         partitionRequestClient.resumeConsumption(this);\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex ec5281cb0db..f9cedf71105 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -360,6 +360,11 @@ public class RemoteInputChannel extends InputChannel {\n         checkPartitionRequestQueueInitialized();\n \n         if (initialCredit == 0) {\n+            // this unannounced credit can be a positive value because credit assignment and the\n+            // increase of this value is not an atomic operation and as a result, this unannounced\n+            // credit value can be get increased even after this channel has been blocked and all\n+            // floating credits are released, it is important to clear this unannounced credit and\n+            // at the same time reset the sender's available credits to keep consistency\n             unannouncedCredit.set(0);\n         }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "0ee049db1ffe8a4a68bcd97608774ee488d02a21", "committedDate": "2021-09-03 08:19:32 +0200", "message": "[FLINK-23907] Use primitive functional interfaces"}, {"oid": "138e83e2bc6feb59ecd839b03491cd8f23ee1c66", "committedDate": "2021-11-08 08:56:34 +0100", "message": "[FLINK-24738][runtime] Ignoring buffer size announcement if the channel is released already"}, {"oid": "4eea7bc9352134a06d2b207c9a94dd46a01c6132", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[FLINK-24657][runtime] Added metric of the total real size of input/output buffers queue"}, {"oid": "f4fd4f8bb66867821cb0f171218d85f8386b0897", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] Move consumedSubpartitionIndex from SingleInputGate to InputChannel"}, {"oid": "5c2ec72982128fc1a30014677916e0dd21f9c1d2", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] SingleInputGate supports consuming subpartition range"}, {"oid": "6398abcbff06b3e488a273144680f4838b4f1c92", "committedDate": "2023-06-09 22:48:37 +0800", "message": "[FLINK-31636][network] Introduce the NettyService framework"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNzUyNg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661617526", "body": "Do we do it because we know that all floating buffers would be released before the checkpoint when `initialCredit == 0`?", "bodyText": "Do we do it because we know that all floating buffers would be released before the checkpoint when initialCredit == 0?", "bodyHTML": "<p dir=\"auto\">Do we do it because we know that all floating buffers would be released before the checkpoint when <code>initialCredit == 0</code>?</p>", "author": "akalash", "createdAt": "2021-06-30T16:05:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -100,8 +106,19 @@ public void addCredit(int creditDeltas) {\n         numCreditsAvailable += creditDeltas;\n     }\n \n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n     @Override\n     public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAyMDc1OQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662020759", "bodyText": "Yes, you are right.", "author": "wsry", "createdAt": "2021-07-01T06:43:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNzUyNg=="}], "type": "inlineReview", "revised_code": {"commit": "01b2bc58b30a2a3730895f7c50ff59099bd273d2", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 803ab4a3d3b..01d08d5f53c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -106,11 +106,6 @@ class CreditBasedSequenceNumberingViewReader\n         numCreditsAvailable += creditDeltas;\n     }\n \n-    @Override\n-    public boolean needAnnounceBacklog() {\n-        return initialCredit == 0 && numCreditsAvailable == 0;\n-    }\n-\n     @Override\n     public void resumeConsumption() {\n         if (initialCredit == 0) {\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 01d08d5f53c..9bce9389ccc 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -108,11 +102,6 @@ class CreditBasedSequenceNumberingViewReader\n \n     @Override\n     public void resumeConsumption() {\n-        if (initialCredit == 0) {\n-            // reset available credit if no exclusive buffer is available at the\n-            // consumer side for all floating buffers must have been released\n-            numCreditsAvailable = 0;\n-        }\n         subpartitionView.resumeConsumption();\n     }\n \n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 9bce9389ccc..01d08d5f53c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -102,6 +108,11 @@ class CreditBasedSequenceNumberingViewReader\n \n     @Override\n     public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;\n+        }\n         subpartitionView.resumeConsumption();\n     }\n \n", "next_change": null}]}}]}}, {"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 803ab4a3d3b..01d08d5f53c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -118,10 +113,14 @@ class CreditBasedSequenceNumberingViewReader\n             // consumer side for all floating buffers must have been released\n             numCreditsAvailable = 0;\n         }\n-\n         subpartitionView.resumeConsumption();\n     }\n \n+    @Override\n+    public void acknowledgeAllRecordsProcessed() {\n+        subpartitionView.acknowledgeAllRecordsProcessed();\n+    }\n+\n     @Override\n     public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n         this.isRegisteredAsAvailable = isRegisteredAvailable;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 803ab4a3d3b..01d08d5f53c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -106,11 +106,6 @@ class CreditBasedSequenceNumberingViewReader\n         numCreditsAvailable += creditDeltas;\n     }\n \n-    @Override\n-    public boolean needAnnounceBacklog() {\n-        return initialCredit == 0 && numCreditsAvailable == 0;\n-    }\n-\n     @Override\n     public void resumeConsumption() {\n         if (initialCredit == 0) {\n", "next_change": null}, {"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 803ab4a3d3b..01d08d5f53c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -118,10 +113,14 @@ class CreditBasedSequenceNumberingViewReader\n             // consumer side for all floating buffers must have been released\n             numCreditsAvailable = 0;\n         }\n-\n         subpartitionView.resumeConsumption();\n     }\n \n+    @Override\n+    public void acknowledgeAllRecordsProcessed() {\n+        subpartitionView.acknowledgeAllRecordsProcessed();\n+    }\n+\n     @Override\n     public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n         this.isRegisteredAsAvailable = isRegisteredAvailable;\n", "next_change": {"commit": "adf343c555d778983e6b5c58d66a29dba6c90a26", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 01d08d5f53c..ee553c436e6 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n", "chunk": "@@ -118,7 +118,7 @@ class CreditBasedSequenceNumberingViewReader\n \n     @Override\n     public void acknowledgeAllRecordsProcessed() {\n-        subpartitionView.acknowledgeAllRecordsProcessed();\n+        subpartitionView.acknowledgeAllDataProcessed();\n     }\n \n     @Override\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "ebbc8608f09e8329e49f27ab9ae87a736dcac7ed", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Notifying the subpartitions about the new received buffer size."}]}, {"oid": "c161aff32e5aed483ca0722e0504ec8493348947", "url": "https://github.com/apache/flink/commit/c161aff32e5aed483ca0722e0504ec8493348947", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-01T07:53:09Z", "type": "forcePushed"}, {"oid": "159596e8f11586211a5f54e6aaae2c9fdee532a2", "url": "https://github.com/apache/flink/commit/159596e8f11586211a5f54e6aaae2c9fdee532a2", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-02T02:08:29Z", "type": "forcePushed"}, {"oid": "1814aee57851711782cc2d922c4ef8f118a74c13", "url": "https://github.com/apache/flink/commit/1814aee57851711782cc2d922c4ef8f118a74c13", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T01:55:10Z", "type": "forcePushed"}, {"oid": "f28812c2d19b7109e851d4cce6cdb9df82868117", "url": "https://github.com/apache/flink/commit/f28812c2d19b7109e851d4cce6cdb9df82868117", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T07:02:25Z", "type": "forcePushed"}, {"oid": "048818bd8e4548d20febf9308b83e42146806b6e", "url": "https://github.com/apache/flink/commit/048818bd8e4548d20febf9308b83e42146806b6e", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T07:13:41Z", "type": "forcePushed"}, {"oid": "ae5a618edba91af4656de9bab058e4a372a01331", "url": "https://github.com/apache/flink/commit/ae5a618edba91af4656de9bab058e4a372a01331", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T08:17:11Z", "type": "forcePushed"}, {"oid": "109e1d36469b537f997a7c844e57e23729a1af21", "url": "https://github.com/apache/flink/commit/109e1d36469b537f997a7c844e57e23729a1af21", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T08:39:29Z", "type": "forcePushed"}, {"oid": "028f2185c0bb15c542006065550d04f69b0b06bd", "url": "https://github.com/apache/flink/commit/028f2185c0bb15c542006065550d04f69b0b06bd", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-06T04:02:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0NDA3Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664644076", "body": "Why is this an issue? Is this an independent optimisation or is it relate with the other parts of the PR?", "bodyText": "Why is this an issue? Is this an independent optimisation or is it relate with the other parts of the PR?", "bodyHTML": "<p dir=\"auto\">Why is this an issue? Is this an independent optimisation or is it relate with the other parts of the PR?</p>", "author": "pnowojski", "createdAt": "2021-07-06T15:08:46Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -433,8 +459,8 @@ public void operationComplete(ChannelFuture future) throws Exception {\n \n         @Override\n         public Object buildMessage() {\n-            return new AddCredit(\n-                    inputChannel.getAndResetUnannouncedCredit(), inputChannel.getInputChannelId());\n+            int credits = inputChannel.getAndResetUnannouncedCredit();\n+            return credits > 0 ? new AddCredit(credits, inputChannel.getInputChannelId()) : null;", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1MDU4Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664650587", "bodyText": "Secondly, return type of the buildMessage() is not annotated @Nullable, so if we need this code for correctness we need to add this annotation (but it would be better to avoid null here)", "author": "pnowojski", "createdAt": "2021-07-06T15:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0NDA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4MDE2NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665080164", "bodyText": "It is relevant to this PR, it is because we add the reset logic in RemoteInputChannel#resumeConsumption method.\n        if (initialCredit == 0) {\n            unannouncedCredit.set(0);\n        }", "author": "wsry", "createdAt": "2021-07-07T06:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0NDA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4MDQ5Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665080497", "bodyText": "I will add a @nullable annotation.", "author": "wsry", "createdAt": "2021-07-07T06:31:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0NDA3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex bb83e4aa2ec..c9a36959395 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n", "chunk": "@@ -459,8 +433,8 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n \n         @Override\n         public Object buildMessage() {\n-            int credits = inputChannel.getAndResetUnannouncedCredit();\n-            return credits > 0 ? new AddCredit(credits, inputChannel.getInputChannelId()) : null;\n+            return new AddCredit(\n+                    inputChannel.getAndResetUnannouncedCredit(), inputChannel.getInputChannelId());\n         }\n     }\n \n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex c9a36959395..41d91430e70 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n", "chunk": "@@ -433,8 +453,8 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n \n         @Override\n         public Object buildMessage() {\n-            return new AddCredit(\n-                    inputChannel.getAndResetUnannouncedCredit(), inputChannel.getInputChannelId());\n+            int credits = inputChannel.getAndResetUnannouncedCredit();\n+            return credits > 0 ? new AddCredit(credits, inputChannel.getInputChannelId()) : null;\n         }\n     }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "a36fac6fceff59a237e90e55965abf76b39e3127", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex bb83e4aa2ec..f8660e9053f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n", "chunk": "@@ -464,6 +469,20 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n         }\n     }\n \n+    private static class NewBufferSizeMessage extends ClientOutboundMessage {\n+        private final int bufferSize;\n+\n+        NewBufferSizeMessage(RemoteInputChannel inputChannel, int bufferSize) {\n+            super(checkNotNull(inputChannel));\n+            this.bufferSize = bufferSize;\n+        }\n+\n+        @Override\n+        public Object buildMessage() {\n+            return new NettyMessage.NewBufferSize(bufferSize, inputChannel.getInputChannelId());\n+        }\n+    }\n+\n     private static class ResumeConsumptionMessage extends ClientOutboundMessage {\n \n         ResumeConsumptionMessage(RemoteInputChannel inputChannel) {\n", "next_change": {"commit": "4648e8af115410b4d1a5aefed44cdb6bd9d07ebb", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex f8660e9053f..55ca906f529 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n", "chunk": "@@ -444,66 +394,4 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n             }\n         }\n     }\n-\n-    private abstract static class ClientOutboundMessage {\n-        protected final RemoteInputChannel inputChannel;\n-\n-        ClientOutboundMessage(RemoteInputChannel inputChannel) {\n-            this.inputChannel = inputChannel;\n-        }\n-\n-        @Nullable\n-        abstract Object buildMessage();\n-    }\n-\n-    private static class AddCreditMessage extends ClientOutboundMessage {\n-\n-        AddCreditMessage(RemoteInputChannel inputChannel) {\n-            super(checkNotNull(inputChannel));\n-        }\n-\n-        @Override\n-        public Object buildMessage() {\n-            int credits = inputChannel.getAndResetUnannouncedCredit();\n-            return credits > 0 ? new AddCredit(credits, inputChannel.getInputChannelId()) : null;\n-        }\n-    }\n-\n-    private static class NewBufferSizeMessage extends ClientOutboundMessage {\n-        private final int bufferSize;\n-\n-        NewBufferSizeMessage(RemoteInputChannel inputChannel, int bufferSize) {\n-            super(checkNotNull(inputChannel));\n-            this.bufferSize = bufferSize;\n-        }\n-\n-        @Override\n-        public Object buildMessage() {\n-            return new NettyMessage.NewBufferSize(bufferSize, inputChannel.getInputChannelId());\n-        }\n-    }\n-\n-    private static class ResumeConsumptionMessage extends ClientOutboundMessage {\n-\n-        ResumeConsumptionMessage(RemoteInputChannel inputChannel) {\n-            super(checkNotNull(inputChannel));\n-        }\n-\n-        @Override\n-        Object buildMessage() {\n-            return new ResumeConsumption(inputChannel.getInputChannelId());\n-        }\n-    }\n-\n-    private static class AcknowledgeAllRecordsProcessedMessage extends ClientOutboundMessage {\n-\n-        AcknowledgeAllRecordsProcessedMessage(RemoteInputChannel inputChannel) {\n-            super(checkNotNull(inputChannel));\n-        }\n-\n-        @Override\n-        Object buildMessage() {\n-            return new AckAllUserRecordsProcessed(inputChannel.getInputChannelId());\n-        }\n-    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "a36fac6fceff59a237e90e55965abf76b39e3127", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Message for notification about new buffer size(NewBufferSize) was added"}, {"oid": "4648e8af115410b4d1a5aefed44cdb6bd9d07ebb", "committedDate": "2021-10-21 17:37:16 +0200", "message": "[FLINK-24468][runtime] Moved the methods for sending messages from NetworkClientHandler to NettyPartitioonRequestClient since it is not responsibility of handler to send them"}, {"oid": "c0cca2e16430758950627068306c7bf6056c98c9", "committedDate": "2022-02-16 14:05:13 +0800", "message": "[hotfix][network] Remove the deduplication for CancelPartitionRequest."}, {"oid": "5be7d480dd3a54c17ef34d76b82b9f6a80ba8bf0", "committedDate": "2022-02-16 14:05:44 +0800", "message": "[FLINK-15455][network] Enabled tcp connection reuse across multi jobs."}, {"oid": "93c834be953f1336adb3ec5b5bf759a20e25eddf", "committedDate": "2022-11-18 10:40:25 +0800", "message": "[FLINK-29639] Print resourceId of remote taskmanager when encounter transport exception."}, {"oid": "4b10f422f20ca22661a1870eadc343cab4a44567", "committedDate": "2022-11-21 11:44:39 +0100", "message": "[FLINK-28695][hotfix][network] Remove some unused exceptions"}, {"oid": "e7854193816dc348086423b42d4dff12dca4a80e", "committedDate": "2022-11-21 11:44:39 +0100", "message": "[FLINK-28695][network] Fix the bug of old netty client isn't closed when netty server closes channel and no input channel"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1MTgwOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664651808", "body": "1. `@Nullable`\r\n2. Do we really need to support `null` here? Can not we return empty `Buffer`?", "bodyText": "@Nullable\nDo we really need to support null here? Can not we return empty Buffer?", "bodyHTML": "<ol dir=\"auto\">\n<li><code>@Nullable</code></li>\n<li>Do we really need to support <code>null</code> here? Can not we return empty <code>Buffer</code>?</li>\n</ol>", "author": "pnowojski", "createdAt": "2021-07-06T15:17:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java", "diffHunk": "@@ -69,6 +69,9 @@ Buffer allocatePooledNetworkBuffer(InputChannelID receiverId) {\n      * @return The un-pooled network buffer.\n      */\n     Buffer allocateUnPooledNetworkBuffer(int size, Buffer.DataType dataType) {\n+        if (size <= 0) {\n+            return null;\n+        }", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4MjY3OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665082678", "bodyText": "This method is used to allocate unpooled buffer for event, the size must be positive. I will replace it with a argument check.", "author": "wsry", "createdAt": "2021-07-07T06:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1MTgwOA=="}], "type": "inlineReview", "revised_code": {"commit": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\nindex 9c950b1fe9f..7011c1cbcbc 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\n", "chunk": "@@ -69,9 +70,7 @@ class NetworkBufferAllocator {\n      * @return The un-pooled network buffer.\n      */\n     Buffer allocateUnPooledNetworkBuffer(int size, Buffer.DataType dataType) {\n-        if (size <= 0) {\n-            return null;\n-        }\n+        checkArgument(size > 0, \"Illegal buffer size, must be positive.\");\n         byte[] byteArray = new byte[size];\n         MemorySegment memSeg = MemorySegmentFactory.wrap(byteArray);\n \n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\nindex 7011c1cbcbc..36367f41c5e 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\n", "chunk": "@@ -70,7 +69,6 @@ class NetworkBufferAllocator {\n      * @return The un-pooled network buffer.\n      */\n     Buffer allocateUnPooledNetworkBuffer(int size, Buffer.DataType dataType) {\n-        checkArgument(size > 0, \"Illegal buffer size, must be positive.\");\n         byte[] byteArray = new byte[size];\n         MemorySegment memSeg = MemorySegmentFactory.wrap(byteArray);\n \n", "next_change": {"commit": "941de53b0ae20ae40a820a1bb0e35c6d189a7221", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\nindex 36367f41c5e..7011c1cbcbc 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\n", "chunk": "@@ -69,6 +70,7 @@ class NetworkBufferAllocator {\n      * @return The un-pooled network buffer.\n      */\n     Buffer allocateUnPooledNetworkBuffer(int size, Buffer.DataType dataType) {\n+        checkArgument(size > 0, \"Illegal buffer size, must be positive.\");\n         byte[] byteArray = new byte[size];\n         MemorySegment memSeg = MemorySegmentFactory.wrap(byteArray);\n \n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\nindex 9c950b1fe9f..7011c1cbcbc 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\n", "chunk": "@@ -69,9 +70,7 @@ class NetworkBufferAllocator {\n      * @return The un-pooled network buffer.\n      */\n     Buffer allocateUnPooledNetworkBuffer(int size, Buffer.DataType dataType) {\n-        if (size <= 0) {\n-            return null;\n-        }\n+        checkArgument(size > 0, \"Illegal buffer size, must be positive.\");\n         byte[] byteArray = new byte[size];\n         MemorySegment memSeg = MemorySegmentFactory.wrap(byteArray);\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664659995", "body": "Instead of this check here, can not we add similar check outside of the `while (...)` loop? For example replace:\r\n\r\n```\r\nif (buffer == null) {\r\n    return null;\r\n}\r\n```\r\nwith something like:\r\n```\r\nif (buffer == null) {\r\n   if (buffersPerChannel == 0) {\r\n       return EMPTY_BUFFER;\r\n    }\r\n    else {\r\n       return null;\r\n    }\r\n}\r\n```\r\n?\r\nThat way, we would avoid sending empty buffer if there are still more buffers in the backlog that are already enqueued?\r\n", "bodyText": "Instead of this check here, can not we add similar check outside of the while (...) loop? For example replace:\nif (buffer == null) {\n    return null;\n}\n\nwith something like:\nif (buffer == null) {\n   if (buffersPerChannel == 0) {\n       return EMPTY_BUFFER;\n    }\n    else {\n       return null;\n    }\n}\n\n?\nThat way, we would avoid sending empty buffer if there are still more buffers in the backlog that are already enqueued?", "bodyHTML": "<p dir=\"auto\">Instead of this check here, can not we add similar check outside of the <code>while (...)</code> loop? For example replace:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (buffer == null) {\n    return null;\n}\n\"><pre><code>if (buffer == null) {\n    return null;\n}\n</code></pre></div>\n<p dir=\"auto\">with something like:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (buffer == null) {\n   if (buffersPerChannel == 0) {\n       return EMPTY_BUFFER;\n    }\n    else {\n       return null;\n    }\n}\n\"><pre><code>if (buffer == null) {\n   if (buffersPerChannel == 0) {\n       return EMPTY_BUFFER;\n    }\n    else {\n       return null;\n    }\n}\n</code></pre></div>\n<p dir=\"auto\">?<br>\nThat way, we would avoid sending empty buffer if there are still more buffers in the backlog that are already enqueued?</p>", "author": "pnowojski", "createdAt": "2021-07-06T15:27:16Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -315,6 +326,17 @@ BufferAndBacklog pollBuffer() {\n                 if (buffer.readableBytes() > 0) {\n                     break;\n                 }\n+\n+                // if we have an empty finished buffer and the exclusive credit is 0, we just return\n+                // the empty buffer so that the downstream task can release the allocated credit for\n+                // this empty buffer, this happens in two main scenarios currently:\n+                // 1. all data of a buffer builder has been read and after that the buffer builder\n+                // is finished\n+                // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n+                if (buffersPerChannel == 0 && bufferConsumer.isFinished()) {\n+                    break;\n+                }\n+", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4NDYyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665084629", "bodyText": "I am afraid we can not skip the empty buffer is the exclusive credit is 0, because we may already allocate the floating credit for it and we can not just release the floating credit because we may already announce the credit to the upstream.", "author": "wsry", "createdAt": "2021-07-07T06:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA5MjA4NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665092084", "bodyText": "I was not suggesting that. I was suggesting to:\n\nwe would avoid sending empty buffer if there are still more buffers in the backlog that are already enqueued", "author": "pnowojski", "createdAt": "2021-07-07T06:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTIyMjQ5Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665222497", "bodyText": "I guess I did not fully understand the comment, could you please explain a bit more? From my understand, even there are multiple buffers in the queue and the first is empty, if we do not send the first empty buffer out, how could we guarantee the downstream tasks are not allocating too many buffers if the exclusive credit is 0? For example, if there is two buffers, the first one is empty and the second one is an event, we may already announce 1 backlog to the downstream task and if we send the event directly, dose that mean we can not release the credit already allocated? Correct me if I am wrong.", "author": "wsry", "createdAt": "2021-07-07T09:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTM0MjA3NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665342075", "bodyText": "If there are two buffers, first is empty the second one can be:\n\nnon empty buffer\nempty buffer\nevent\n\nIn all cases, instead of sending this first empty buffer with the backlog information, as far as I understand, it should be possible to just send any of the above instead with the updated backlog information. From the downstream node perspective, it should make no difference if we hide this empty buffer. If this is 2nd or 3rd case, we should be able to release the floating buffer regardless of that, shouldn't we?", "author": "pnowojski", "createdAt": "2021-07-07T12:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTgyOTM4Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665829387", "bodyText": "Let's maybe focus on the 3rd case first and we assume that the exclusive credit is 0.\n\nThere are only one data buffer in the queue.\nFlush triggered.\nAll data of the first buffer is committed but the buffer is still not finished.\nAll data of the buffer is consumed by pollBuffer and the available credit becomes 0.\nThe first buffer is finished, the second event is added and the data available notification is triggered.\nThe upstream announces backlog to the downstream to request a credit.\nThe upstream receives available credit and start to pollBuffer.\nSkip the first empty buffer and send the second event.\nThe downstream receive the event but the event does not consume any credit.\n\nDo you mean we should change the current logic and release the floating buffer for event in some cases (including reduce the available credit by 1 at the upstream, currently the available credit is not decreased for event)? If there are multiple empty buffers, should we just skip the first one or should we skip all?", "author": "wsry", "createdAt": "2021-07-08T02:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "01b2bc58b30a2a3730895f7c50ff59099bd273d2", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex dd48214990a..bc1e5beb89c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -337,6 +333,9 @@ public class PipelinedSubpartition extends ResultSubpartition\n                     break;\n                 }\n \n+                if (buffer.readableBytes() > 0) {\n+                    break;\n+                }\n                 buffer.recycleBuffer();\n                 buffer = null;\n                 if (!bufferConsumer.isFinished()) {\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex bc1e5beb89c..134ef688b18 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -323,16 +312,6 @@ public class PipelinedSubpartition extends ResultSubpartition\n                     decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer());\n                 }\n \n-                // if we have an empty finished buffer and the exclusive credit is 0, we just return\n-                // the empty buffer so that the downstream task can release the allocated credit for\n-                // this empty buffer, this happens in two main scenarios currently:\n-                // 1. all data of a buffer builder has been read and after that the buffer builder\n-                // is finished\n-                // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n-                if (buffersPerChannel == 0 && bufferConsumer.isFinished()) {\n-                    break;\n-                }\n-\n                 if (buffer.readableBytes() > 0) {\n                     break;\n                 }\n", "next_change": {"commit": "941de53b0ae20ae40a820a1bb0e35c6d189a7221", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 134ef688b18..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -312,6 +325,16 @@ public class PipelinedSubpartition extends ResultSubpartition\n                     decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer());\n                 }\n \n+                // if we have an empty finished buffer and the exclusive credit is 0, we just return\n+                // the empty buffer so that the downstream task can release the allocated credit for\n+                // this empty buffer, this happens in two main scenarios currently:\n+                // 1. all data of a buffer builder has been read and after that the buffer builder\n+                // is finished\n+                // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n+                if (receiverExclusiveBuffersPerChannel == 0 && bufferConsumer.isFinished()) {\n+                    break;\n+                }\n+\n                 if (buffer.readableBytes() > 0) {\n                     break;\n                 }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex dd48214990a..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -323,20 +325,19 @@ public class PipelinedSubpartition extends ResultSubpartition\n                     decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer());\n                 }\n \n-                if (buffer.readableBytes() > 0) {\n-                    break;\n-                }\n-\n                 // if we have an empty finished buffer and the exclusive credit is 0, we just return\n                 // the empty buffer so that the downstream task can release the allocated credit for\n                 // this empty buffer, this happens in two main scenarios currently:\n                 // 1. all data of a buffer builder has been read and after that the buffer builder\n                 // is finished\n                 // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n-                if (buffersPerChannel == 0 && bufferConsumer.isFinished()) {\n+                if (receiverExclusiveBuffersPerChannel == 0 && bufferConsumer.isFinished()) {\n                     break;\n                 }\n \n+                if (buffer.readableBytes() > 0) {\n+                    break;\n+                }\n                 buffer.recycleBuffer();\n                 buffer = null;\n                 if (!bufferConsumer.isFinished()) {\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "088d16517126d7128e1f072d588b9ce0f4787ae6", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][refactor] Made a safe method for getting the number of buffers in the queue visible in the interface."}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "703662aa61a8f82d4df6de7e0518a568822f71db", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Subpartition is able to notify the desirable buffer size for input buffer consumer."}, {"oid": "60aa2ac29797df576fe14f5c888f09626351b774", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[refactor][runtime] Added postfix `unsafe` for methods ResultSubpartition#getTotalNumberOfBuffers and ResultSubpartition#getTotalNumberOfBytes"}, {"oid": "10b7afae7423d75f94f397699b09deb9fbbdaca5", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Refactor the barrier alignment timer and default priority sequence number"}, {"oid": "dd8f4e2603309493300099396568ffc681e76e80", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Timeout aligned to unaligned checkpoint barrier in the output buffers"}, {"oid": "5c5cc9dbcc1ce9e041ea3aee9ba32ad6a3e19689", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Add missing @GuardedBy annotation for SortMergeResultPartitionReadScheduler and PipelinedSubpartition."}, {"oid": "3b6816e0a6c578dbcbdcf3061ce6205ddb0f5e48", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Fix some typo and syntax mistakes."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY2MjE1Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664662153", "body": "`pollBuffer()` would be acquiring the lock twice, wouldn't it? If you really need to make this method `public` you should keep `private int getBuffersInBacklogUnsafe()` without any synchronisation.", "bodyText": "pollBuffer() would be acquiring the lock twice, wouldn't it? If you really need to make this method public you should keep private int getBuffersInBacklogUnsafe() without any synchronisation.", "bodyHTML": "<p dir=\"auto\"><code>pollBuffer()</code> would be acquiring the lock twice, wouldn't it? If you really need to make this method <code>public</code> you should keep <code>private int getBuffersInBacklogUnsafe()</code> without any synchronisation.</p>", "author": "pnowojski", "createdAt": "2021-07-06T15:29:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -517,19 +539,20 @@ private void increaseBuffersInBacklog(BufferConsumer buffer) {\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n+    /** Gets the number of non-event buffers in this subpartition. */\n     public int getBuffersInBacklog() {\n-        if (flushRequested || isFinished) {\n-            return buffersInBacklog;\n-        } else {\n-            return Math.max(buffersInBacklog - 1, 0);\n+        synchronized (buffers) {", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4NDg3Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665084877", "bodyText": "I will add a private int getBuffersInBacklogUnsafe() method", "author": "wsry", "createdAt": "2021-07-07T06:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY2MjE1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex dd48214990a..fef1387485a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -540,19 +540,24 @@ public class PipelinedSubpartition extends ResultSubpartition\n     }\n \n     /** Gets the number of non-event buffers in this subpartition. */\n+    @Override\n     public int getBuffersInBacklog() {\n         synchronized (buffers) {\n-            if (isBlocked || buffers.isEmpty()) {\n-                return 0;\n-            }\n+            return getBuffersInBacklogUnsafe();\n+        }\n+    }\n \n-            if (flushRequested\n-                    || isFinished\n-                    || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n-                return buffersInBacklog;\n-            } else {\n-                return Math.max(buffersInBacklog - 1, 0);\n-            }\n+    private int getBuffersInBacklogUnsafe() {\n+        if (isBlocked || buffers.isEmpty()) {\n+            return 0;\n+        }\n+\n+        if (flushRequested\n+                || isFinished\n+                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+            return buffersInBacklog;\n+        } else {\n+            return Math.max(buffersInBacklog - 1, 0);\n         }\n     }\n \n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex fef1387485a..134ef688b18 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -539,22 +516,16 @@ public class PipelinedSubpartition extends ResultSubpartition\n         }\n     }\n \n-    /** Gets the number of non-event buffers in this subpartition. */\n-    @Override\n+    /**\n+     * Gets the number of non-event buffers in this subpartition.\n+     *\n+     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n+     * scenarios since it does not make any concurrency guarantees.\n+     */\n+    @SuppressWarnings(\"FieldAccessNotGuarded\")\n+    @VisibleForTesting\n     public int getBuffersInBacklog() {\n-        synchronized (buffers) {\n-            return getBuffersInBacklogUnsafe();\n-        }\n-    }\n-\n-    private int getBuffersInBacklogUnsafe() {\n-        if (isBlocked || buffers.isEmpty()) {\n-            return 0;\n-        }\n-\n-        if (flushRequested\n-                || isFinished\n-                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+        if (flushRequested || isFinished) {\n             return buffersInBacklog;\n         } else {\n             return Math.max(buffersInBacklog - 1, 0);\n", "next_change": {"commit": "639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 134ef688b18..8088cb5d2e3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -516,16 +519,16 @@ public class PipelinedSubpartition extends ResultSubpartition\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n-    public int getBuffersInBacklog() {\n-        if (flushRequested || isFinished) {\n+    /** Gets the number of non-event buffers in this subpartition. */\n+    @Override\n+    public int getBuffersInBacklogUnsafe() {\n+        if (isBlocked || buffers.isEmpty()) {\n+            return 0;\n+        }\n+\n+        if (flushRequested\n+                || isFinished\n+                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n             return buffersInBacklog;\n         } else {\n             return Math.max(buffersInBacklog - 1, 0);\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex dd48214990a..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -540,19 +543,18 @@ public class PipelinedSubpartition extends ResultSubpartition\n     }\n \n     /** Gets the number of non-event buffers in this subpartition. */\n-    public int getBuffersInBacklog() {\n-        synchronized (buffers) {\n-            if (isBlocked || buffers.isEmpty()) {\n-                return 0;\n-            }\n+    @Override\n+    public int getBuffersInBacklogUnsafe() {\n+        if (isBlocked || buffers.isEmpty()) {\n+            return 0;\n+        }\n \n-            if (flushRequested\n-                    || isFinished\n-                    || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n-                return buffersInBacklog;\n-            } else {\n-                return Math.max(buffersInBacklog - 1, 0);\n-            }\n+        if (flushRequested\n+                || isFinished\n+                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+            return buffersInBacklog;\n+        } else {\n+            return Math.max(buffersInBacklog - 1, 0);\n         }\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "088d16517126d7128e1f072d588b9ce0f4787ae6", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][refactor] Made a safe method for getting the number of buffers in the queue visible in the interface."}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "703662aa61a8f82d4df6de7e0518a568822f71db", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Subpartition is able to notify the desirable buffer size for input buffer consumer."}, {"oid": "60aa2ac29797df576fe14f5c888f09626351b774", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[refactor][runtime] Added postfix `unsafe` for methods ResultSubpartition#getTotalNumberOfBuffers and ResultSubpartition#getTotalNumberOfBytes"}, {"oid": "10b7afae7423d75f94f397699b09deb9fbbdaca5", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Refactor the barrier alignment timer and default priority sequence number"}, {"oid": "dd8f4e2603309493300099396568ffc681e76e80", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Timeout aligned to unaligned checkpoint barrier in the output buffers"}, {"oid": "5c5cc9dbcc1ce9e041ea3aee9ba32ad6a3e19689", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Add missing @GuardedBy annotation for SortMergeResultPartitionReadScheduler and PipelinedSubpartition."}, {"oid": "3b6816e0a6c578dbcbdcf3061ce6205ddb0f5e48", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Fix some typo and syntax mistakes."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY3NTg2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664675867", "body": "add the `backlog` value to the error message?", "bodyText": "add the backlog value to the error message?", "bodyHTML": "<p dir=\"auto\">add the <code>backlog</code> value to the error message?</p>", "author": "pnowojski", "createdAt": "2021-07-06T15:46:08Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -468,6 +485,11 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n                 return;\n             }\n \n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+                checkArgument(backlog == 0, \"Illegal number of backlog.\");", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 4be0669defa..9e8e1d3cbcd 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -487,7 +487,7 @@ public class RemoteInputChannel extends InputChannel {\n \n             if (buffer.getDataType().isBlockingUpstream()) {\n                 onBlockingUpstream();\n-                checkArgument(backlog == 0, \"Illegal number of backlog.\");\n+                checkArgument(backlog == 0, \"Illegal number of backlog: %s, should be 0.\", backlog);\n             }\n \n             final boolean wasEmpty;\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 9e8e1d3cbcd..072db4723c5 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -485,11 +471,6 @@ public class RemoteInputChannel extends InputChannel {\n                 return;\n             }\n \n-            if (buffer.getDataType().isBlockingUpstream()) {\n-                onBlockingUpstream();\n-                checkArgument(backlog == 0, \"Illegal number of backlog: %s, should be 0.\", backlog);\n-            }\n-\n             final boolean wasEmpty;\n             boolean firstPriorityEvent = false;\n             synchronized (receivedBuffers) {\n", "next_change": {"commit": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 072db4723c5..4ff36b9a632 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -471,6 +489,11 @@ public class RemoteInputChannel extends InputChannel {\n                 return;\n             }\n \n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+                checkArgument(backlog == 0, \"Illegal number of backlog: %s, should be 0.\", backlog);\n+            }\n+\n             final boolean wasEmpty;\n             boolean firstPriorityEvent = false;\n             synchronized (receivedBuffers) {\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 4be0669defa..f9cedf71105 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n", "chunk": "@@ -487,7 +492,7 @@ public class RemoteInputChannel extends InputChannel {\n \n             if (buffer.getDataType().isBlockingUpstream()) {\n                 onBlockingUpstream();\n-                checkArgument(backlog == 0, \"Illegal number of backlog.\");\n+                checkArgument(backlog == 0, \"Illegal number of backlog: %s, should be 0.\", backlog);\n             }\n \n             final boolean wasEmpty;\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "b92fa30541c3ed29be5b1f9758d4bbb1b0724be4", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][runtime] Prepared Gates and Channels classes for either providing information for the calculation of buffer size and receiving the recalculated buffer size."}, {"oid": "0ee049db1ffe8a4a68bcd97608774ee488d02a21", "committedDate": "2021-09-03 08:19:32 +0200", "message": "[FLINK-23907] Use primitive functional interfaces"}, {"oid": "138e83e2bc6feb59ecd839b03491cd8f23ee1c66", "committedDate": "2021-11-08 08:56:34 +0100", "message": "[FLINK-24738][runtime] Ignoring buffer size announcement if the channel is released already"}, {"oid": "4eea7bc9352134a06d2b207c9a94dd46a01c6132", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[FLINK-24657][runtime] Added metric of the total real size of input/output buffers queue"}, {"oid": "f4fd4f8bb66867821cb0f171218d85f8386b0897", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] Move consumedSubpartitionIndex from SingleInputGate to InputChannel"}, {"oid": "5c2ec72982128fc1a30014677916e0dd21f9c1d2", "committedDate": "2022-01-27 16:42:23 +0800", "message": "[FLINK-25035][runtime] SingleInputGate supports consuming subpartition range"}, {"oid": "6398abcbff06b3e488a273144680f4838b4f1c92", "committedDate": "2023-06-09 22:48:37 +0800", "message": "[FLINK-31636][network] Introduce the NettyService framework"}]}, {"oid": "fb631b77700e2f05dcfdd50cd50cdea35e7cfb13", "url": "https://github.com/apache/flink/commit/fb631b77700e2f05dcfdd50cd50cdea35e7cfb13", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-07T02:10:53Z", "type": "forcePushed"}, {"oid": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "url": "https://github.com/apache/flink/commit/826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-07T08:46:21Z", "type": "forcePushed"}, {"oid": "01b2bc58b30a2a3730895f7c50ff59099bd273d2", "url": "https://github.com/apache/flink/commit/01b2bc58b30a2a3730895f7c50ff59099bd273d2", "message": "[FLINK-16641][network] (Part#6) Enable to set network buffers per channel to 0\n\nThis PR enables to set the number of network buffer per channel (taskmanager.network.memory.buffers-per-channel) to 0. Previously, the value can not be set to 0 because of dead lock, FLINK-16641 solves the problem and we can set it to 0 now.", "committedDate": "2021-07-08T12:39:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjMwMjY4MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666302680", "body": "nit: Rename to `getBuffersInBacklogUnsafe()` (previously it was a private method just made `@VisibleForTesting`)", "bodyText": "nit: Rename to getBuffersInBacklogUnsafe() (previously it was a private method just made @VisibleForTesting)", "bodyHTML": "<p dir=\"auto\">nit: Rename to <code>getBuffersInBacklogUnsafe()</code> (previously it was a private method just made <code>@VisibleForTesting</code>)</p>", "author": "pnowojski", "createdAt": "2021-07-08T15:31:22Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -517,16 +520,16 @@ private void increaseBuffersInBacklog(BufferConsumer buffer) {\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n+    /** Gets the number of non-event buffers in this subpartition. */\n+    @Override\n     public int getBuffersInBacklog() {", "originalCommit": "c9956bc098175364585e5661d5d4ca097b2fe876", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2792e1a43d72ffc013bb60bdea52a577316d933a", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 93e58ba27ec..bc588a1519d 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -522,7 +543,7 @@ public class PipelinedSubpartition extends ResultSubpartition\n \n     /** Gets the number of non-event buffers in this subpartition. */\n     @Override\n-    public int getBuffersInBacklog() {\n+    public int getBuffersInBacklogUnsafe() {\n         if (isBlocked || buffers.isEmpty()) {\n             return 0;\n         }\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex bc588a1519d..134ef688b18 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -541,16 +516,16 @@ public class PipelinedSubpartition extends ResultSubpartition\n         }\n     }\n \n-    /** Gets the number of non-event buffers in this subpartition. */\n-    @Override\n-    public int getBuffersInBacklogUnsafe() {\n-        if (isBlocked || buffers.isEmpty()) {\n-            return 0;\n-        }\n-\n-        if (flushRequested\n-                || isFinished\n-                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+    /**\n+     * Gets the number of non-event buffers in this subpartition.\n+     *\n+     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n+     * scenarios since it does not make any concurrency guarantees.\n+     */\n+    @SuppressWarnings(\"FieldAccessNotGuarded\")\n+    @VisibleForTesting\n+    public int getBuffersInBacklog() {\n+        if (flushRequested || isFinished) {\n             return buffersInBacklog;\n         } else {\n             return Math.max(buffersInBacklog - 1, 0);\n", "next_change": {"commit": "639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 134ef688b18..8088cb5d2e3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -516,16 +519,16 @@ public class PipelinedSubpartition extends ResultSubpartition\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n-    public int getBuffersInBacklog() {\n-        if (flushRequested || isFinished) {\n+    /** Gets the number of non-event buffers in this subpartition. */\n+    @Override\n+    public int getBuffersInBacklogUnsafe() {\n+        if (isBlocked || buffers.isEmpty()) {\n+            return 0;\n+        }\n+\n+        if (flushRequested\n+                || isFinished\n+                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n             return buffersInBacklog;\n         } else {\n             return Math.max(buffersInBacklog - 1, 0);\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 93e58ba27ec..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -522,7 +544,7 @@ public class PipelinedSubpartition extends ResultSubpartition\n \n     /** Gets the number of non-event buffers in this subpartition. */\n     @Override\n-    public int getBuffersInBacklog() {\n+    public int getBuffersInBacklogUnsafe() {\n         if (isBlocked || buffers.isEmpty()) {\n             return 0;\n         }\n", "next_change": {"commit": "5c5cc9dbcc1ce9e041ea3aee9ba32ad6a3e19689", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 38d8cf93158..28dca791ba4 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -543,6 +746,7 @@ public class PipelinedSubpartition extends ResultSubpartition\n     }\n \n     /** Gets the number of non-event buffers in this subpartition. */\n+    @SuppressWarnings(\"FieldAccessNotGuarded\")\n     @Override\n     public int getBuffersInBacklogUnsafe() {\n         if (isBlocked || buffers.isEmpty()) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "088d16517126d7128e1f072d588b9ce0f4787ae6", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][refactor] Made a safe method for getting the number of buffers in the queue visible in the interface."}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "703662aa61a8f82d4df6de7e0518a568822f71db", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Subpartition is able to notify the desirable buffer size for input buffer consumer."}, {"oid": "60aa2ac29797df576fe14f5c888f09626351b774", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[refactor][runtime] Added postfix `unsafe` for methods ResultSubpartition#getTotalNumberOfBuffers and ResultSubpartition#getTotalNumberOfBytes"}, {"oid": "10b7afae7423d75f94f397699b09deb9fbbdaca5", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Refactor the barrier alignment timer and default priority sequence number"}, {"oid": "dd8f4e2603309493300099396568ffc681e76e80", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Timeout aligned to unaligned checkpoint barrier in the output buffers"}, {"oid": "5c5cc9dbcc1ce9e041ea3aee9ba32ad6a3e19689", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Add missing @GuardedBy annotation for SortMergeResultPartitionReadScheduler and PipelinedSubpartition."}, {"oid": "3b6816e0a6c578dbcbdcf3061ce6205ddb0f5e48", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Fix some typo and syntax mistakes."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666340771", "body": "I can not seem to respond in the previous thread, so I need to start a new one.\r\n\r\n> Let's maybe focus on the 3rd case first and we assume that the exclusive credit is 0.\r\n>\r\n> 1. There are only one data buffer in the queue.\r\n> 2. Flush triggered.\r\n> 3. All data of the first buffer is committed but the buffer is still not finished.\r\n> 4. All data of the buffer is consumed by pollBuffer and the available credit becomes 0.\r\n> 5. The first buffer is finished, the second event is added and the data available notification is triggered.\r\n> 6. The upstream announces backlog to the downstream to request a credit.\r\n> 7. The upstream receives available credit and start to pollBuffer.\r\n> 8. Skip the first empty buffer and send the second event.\r\n> 9. The downstream receive the event but the event does not consume any credit.\r\n>\r\n> Do you mean we should change the current logic and release the floating buffer for event in some cases (including reduce the available credit by 1 at the upstream, currently the available credit is not decreased for event)?\r\n\r\nNo, but I think we could send this regardless if any is credit available or not as we are doing right now. I think we are also already attaching information about the backlog to such event. One thing to add (unless we are not doing it already) would be to use this backlog information, to maybe release floating buffers if backlog dropped to 0?\r\n\r\n> If there are multiple empty buffers, should we just skip the first one or should we skip all?\r\n\r\nWe could skip all of them, until we reach one of the three options:\r\n1. non empty data buffer\r\n2. event (check above)\r\n3. last empty buffer, without any events after it - here we would indeed need to send that empty buffer\r\n\r\n", "bodyText": "I can not seem to respond in the previous thread, so I need to start a new one.\n\nLet's maybe focus on the 3rd case first and we assume that the exclusive credit is 0.\n\nThere are only one data buffer in the queue.\nFlush triggered.\nAll data of the first buffer is committed but the buffer is still not finished.\nAll data of the buffer is consumed by pollBuffer and the available credit becomes 0.\nThe first buffer is finished, the second event is added and the data available notification is triggered.\nThe upstream announces backlog to the downstream to request a credit.\nThe upstream receives available credit and start to pollBuffer.\nSkip the first empty buffer and send the second event.\nThe downstream receive the event but the event does not consume any credit.\n\nDo you mean we should change the current logic and release the floating buffer for event in some cases (including reduce the available credit by 1 at the upstream, currently the available credit is not decreased for event)?\n\nNo, but I think we could send this regardless if any is credit available or not as we are doing right now. I think we are also already attaching information about the backlog to such event. One thing to add (unless we are not doing it already) would be to use this backlog information, to maybe release floating buffers if backlog dropped to 0?\n\nIf there are multiple empty buffers, should we just skip the first one or should we skip all?\n\nWe could skip all of them, until we reach one of the three options:\n\nnon empty data buffer\nevent (check above)\nlast empty buffer, without any events after it - here we would indeed need to send that empty buffer", "bodyHTML": "<p dir=\"auto\">I can not seem to respond in the previous thread, so I need to start a new one.</p>\n<blockquote>\n<p dir=\"auto\">Let's maybe focus on the 3rd case first and we assume that the exclusive credit is 0.</p>\n<ol dir=\"auto\">\n<li>There are only one data buffer in the queue.</li>\n<li>Flush triggered.</li>\n<li>All data of the first buffer is committed but the buffer is still not finished.</li>\n<li>All data of the buffer is consumed by pollBuffer and the available credit becomes 0.</li>\n<li>The first buffer is finished, the second event is added and the data available notification is triggered.</li>\n<li>The upstream announces backlog to the downstream to request a credit.</li>\n<li>The upstream receives available credit and start to pollBuffer.</li>\n<li>Skip the first empty buffer and send the second event.</li>\n<li>The downstream receive the event but the event does not consume any credit.</li>\n</ol>\n<p dir=\"auto\">Do you mean we should change the current logic and release the floating buffer for event in some cases (including reduce the available credit by 1 at the upstream, currently the available credit is not decreased for event)?</p>\n</blockquote>\n<p dir=\"auto\">No, but I think we could send this regardless if any is credit available or not as we are doing right now. I think we are also already attaching information about the backlog to such event. One thing to add (unless we are not doing it already) would be to use this backlog information, to maybe release floating buffers if backlog dropped to 0?</p>\n<blockquote>\n<p dir=\"auto\">If there are multiple empty buffers, should we just skip the first one or should we skip all?</p>\n</blockquote>\n<p dir=\"auto\">We could skip all of them, until we reach one of the three options:</p>\n<ol dir=\"auto\">\n<li>non empty data buffer</li>\n<li>event (check above)</li>\n<li>last empty buffer, without any events after it - here we would indeed need to send that empty buffer</li>\n</ol>", "author": "pnowojski", "createdAt": "2021-07-08T16:19:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -312,6 +323,16 @@ BufferAndBacklog pollBuffer() {\n                     decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer());\n                 }\n \n+                // if we have an empty finished buffer and the exclusive credit is 0, we just return\n+                // the empty buffer so that the downstream task can release the allocated credit for\n+                // this empty buffer, this happens in two main scenarios currently:\n+                // 1. all data of a buffer builder has been read and after that the buffer builder\n+                // is finished\n+                // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n+                if (buffersPerChannel == 0 && bufferConsumer.isFinished()) {\n+                    break;\n+                }\n+", "originalCommit": "faee760500feb1a2f793a6d691a1d061b1d17917", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjYyNjg4Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666626886", "bodyText": "One thing to add (unless we are not doing it already) would be to use this backlog information, to maybe release floating buffers if backlog dropped to 0?\n\nCurrently, we are not doing that. Actually, I think it is a little complicated to do so. Because we need to keep consistency between the sender side available credit and the receiver side floating buffers. If we just release the floating buffers at the receiver side, if the sender side available credit is not reset, then there is may data sent out without buffers at receiver side to receive them. If we also reset the available credit at the sender side when the backlog is 0, there is a possibility that some AddCredit messages are on the way and we are not resetting this part. Maybe one way is to not sending any data out after sending a buffer with 0 backlog at sender side, then the receivers clear all floating credits and send a reset message to the senders. Then the senders reset all available credits. This process is similar to the channel blocking and resumption. I think this is a little complicated and can incur extra overhead.\nWhat do you think? Or is there any simple way?", "author": "wsry", "createdAt": "2021-07-09T02:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjY3Nzk5Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666677997", "bodyText": "Yes, you are right. It wouldn't be that simple. In that case, how complicated would it be to optimise the code to skip the all of the empty buffers until:\n\nnon empty data buffer\nevent (then send empty buffer first)\nlast empty buffer, without any events after it - here we would indeed need to send that empty buffer\n\n?", "author": "pnowojski", "createdAt": "2021-07-09T05:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjcyMzU0Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666723543", "bodyText": "Currently, I can only come up with the following way, which depends on the downstream to reset the available credit of the upstream. This at least needs to add a special network message and propagating this message can incur extra overhead. If you think this is really important, I will spend some time to rethink about it and see if I can find a better way to solve it.\n\nMaybe one way is to not sending any data out after sending a buffer with 0 backlog at sender side, then the receivers clear all floating credits and send a reset message to the senders. Then the senders reset all available credits. This process is similar to the channel blocking and resumption.", "author": "wsry", "createdAt": "2021-07-09T07:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Njc1MjExMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666752113", "bodyText": "Ok, let's go with the current way for now, as with buffersPerChannel == 0 check it's not that critical. But it would be nice if you could spend a little time thinking if we can improve this.", "author": "pnowojski", "createdAt": "2021-07-09T07:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Njc2MTQzOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666761438", "bodyText": "OK, thanks a lot. I will spend some time thinking if we can improve it.", "author": "wsry", "createdAt": "2021-07-09T08:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "da81fde5fc9e110075cff4982048b7f7ee3a0d61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex bc1e5beb89c..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -329,7 +331,7 @@ public class PipelinedSubpartition extends ResultSubpartition\n                 // 1. all data of a buffer builder has been read and after that the buffer builder\n                 // is finished\n                 // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n-                if (buffersPerChannel == 0 && bufferConsumer.isFinished()) {\n+                if (receiverExclusiveBuffersPerChannel == 0 && bufferConsumer.isFinished()) {\n                     break;\n                 }\n \n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 38d8cf93158..134ef688b18 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -325,16 +312,6 @@ public class PipelinedSubpartition extends ResultSubpartition\n                     decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer());\n                 }\n \n-                // if we have an empty finished buffer and the exclusive credit is 0, we just return\n-                // the empty buffer so that the downstream task can release the allocated credit for\n-                // this empty buffer, this happens in two main scenarios currently:\n-                // 1. all data of a buffer builder has been read and after that the buffer builder\n-                // is finished\n-                // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n-                if (receiverExclusiveBuffersPerChannel == 0 && bufferConsumer.isFinished()) {\n-                    break;\n-                }\n-\n                 if (buffer.readableBytes() > 0) {\n                     break;\n                 }\n", "next_change": {"commit": "941de53b0ae20ae40a820a1bb0e35c6d189a7221", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 134ef688b18..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -312,6 +325,16 @@ public class PipelinedSubpartition extends ResultSubpartition\n                     decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer());\n                 }\n \n+                // if we have an empty finished buffer and the exclusive credit is 0, we just return\n+                // the empty buffer so that the downstream task can release the allocated credit for\n+                // this empty buffer, this happens in two main scenarios currently:\n+                // 1. all data of a buffer builder has been read and after that the buffer builder\n+                // is finished\n+                // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n+                if (receiverExclusiveBuffersPerChannel == 0 && bufferConsumer.isFinished()) {\n+                    break;\n+                }\n+\n                 if (buffer.readableBytes() > 0) {\n                     break;\n                 }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex bc1e5beb89c..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -329,7 +331,7 @@ public class PipelinedSubpartition extends ResultSubpartition\n                 // 1. all data of a buffer builder has been read and after that the buffer builder\n                 // is finished\n                 // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n-                if (buffersPerChannel == 0 && bufferConsumer.isFinished()) {\n+                if (receiverExclusiveBuffersPerChannel == 0 && bufferConsumer.isFinished()) {\n                     break;\n                 }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "088d16517126d7128e1f072d588b9ce0f4787ae6", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][refactor] Made a safe method for getting the number of buffers in the queue visible in the interface."}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "703662aa61a8f82d4df6de7e0518a568822f71db", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Subpartition is able to notify the desirable buffer size for input buffer consumer."}, {"oid": "60aa2ac29797df576fe14f5c888f09626351b774", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[refactor][runtime] Added postfix `unsafe` for methods ResultSubpartition#getTotalNumberOfBuffers and ResultSubpartition#getTotalNumberOfBytes"}, {"oid": "10b7afae7423d75f94f397699b09deb9fbbdaca5", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Refactor the barrier alignment timer and default priority sequence number"}, {"oid": "dd8f4e2603309493300099396568ffc681e76e80", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Timeout aligned to unaligned checkpoint barrier in the output buffers"}, {"oid": "5c5cc9dbcc1ce9e041ea3aee9ba32ad6a3e19689", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Add missing @GuardedBy annotation for SortMergeResultPartitionReadScheduler and PipelinedSubpartition."}, {"oid": "3b6816e0a6c578dbcbdcf3061ce6205ddb0f5e48", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Fix some typo and syntax mistakes."}]}, {"oid": "2792e1a43d72ffc013bb60bdea52a577316d933a", "url": "https://github.com/apache/flink/commit/2792e1a43d72ffc013bb60bdea52a577316d933a", "message": "Fixup", "committedDate": "2021-07-09T03:57:07Z", "type": "forcePushed"}, {"oid": "d4b35b61d395564b24dd98896b785e22c6e3ab30", "url": "https://github.com/apache/flink/commit/d4b35b61d395564b24dd98896b785e22c6e3ab30", "message": "Fixup", "committedDate": "2021-07-09T03:59:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Njc1NjI0MQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666756241", "body": "rename `networkBuffersPerChannel` -> `configuredNetworkBuffersPerChannel` to better reflect that we are actually overriding this value for the output?", "bodyText": "rename networkBuffersPerChannel -> configuredNetworkBuffersPerChannel to better reflect that we are actually overriding this value for the output?", "bodyHTML": "<p dir=\"auto\">rename <code>networkBuffersPerChannel</code> -&gt; <code>configuredNetworkBuffersPerChannel</code> to better reflect that we are actually overriding this value for the output?</p>", "author": "pnowojski", "createdAt": "2021-07-09T08:05:29Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java", "diffHunk": "@@ -156,15 +155,16 @@ public ResultPartition create(\n                             bufferCompressor,\n                             bufferPoolFactory);\n \n-            BiFunction<Integer, PipelinedResultPartition, PipelinedSubpartition> factory;\n-            if (type == ResultPartitionType.PIPELINED_APPROXIMATE) {\n-                factory = PipelinedApproximateSubpartition::new;\n-            } else {\n-                factory = PipelinedSubpartition::new;\n-            }\n-\n             for (int i = 0; i < subpartitions.length; i++) {\n-                subpartitions[i] = factory.apply(i, pipelinedPartition);\n+                if (type == ResultPartitionType.PIPELINED_APPROXIMATE) {\n+                    subpartitions[i] =\n+                            new PipelinedApproximateSubpartition(\n+                                    i, networkBuffersPerChannel, pipelinedPartition);", "originalCommit": "a3f6a9f67fcb3429ce0b086c3384f14ff4a31b29", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "da81fde5fc9e110075cff4982048b7f7ee3a0d61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\nindex 4336c9dbd30..aad174e22e4 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\n", "chunk": "@@ -159,11 +159,11 @@ public class ResultPartitionFactory {\n                 if (type == ResultPartitionType.PIPELINED_APPROXIMATE) {\n                     subpartitions[i] =\n                             new PipelinedApproximateSubpartition(\n-                                    i, networkBuffersPerChannel, pipelinedPartition);\n+                                    i, configuredNetworkBuffersPerChannel, pipelinedPartition);\n                 } else {\n                     subpartitions[i] =\n                             new PipelinedSubpartition(\n-                                    i, networkBuffersPerChannel, pipelinedPartition);\n+                                    i, configuredNetworkBuffersPerChannel, pipelinedPartition);\n                 }\n             }\n \n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\nindex aad174e22e4..2e6360fca91 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\n", "chunk": "@@ -155,16 +156,15 @@ public class ResultPartitionFactory {\n                             bufferCompressor,\n                             bufferPoolFactory);\n \n+            BiFunction<Integer, PipelinedResultPartition, PipelinedSubpartition> factory;\n+            if (type == ResultPartitionType.PIPELINED_APPROXIMATE) {\n+                factory = PipelinedApproximateSubpartition::new;\n+            } else {\n+                factory = PipelinedSubpartition::new;\n+            }\n+\n             for (int i = 0; i < subpartitions.length; i++) {\n-                if (type == ResultPartitionType.PIPELINED_APPROXIMATE) {\n-                    subpartitions[i] =\n-                            new PipelinedApproximateSubpartition(\n-                                    i, configuredNetworkBuffersPerChannel, pipelinedPartition);\n-                } else {\n-                    subpartitions[i] =\n-                            new PipelinedSubpartition(\n-                                    i, configuredNetworkBuffersPerChannel, pipelinedPartition);\n-                }\n+                subpartitions[i] = factory.apply(i, pipelinedPartition);\n             }\n \n             partition = pipelinedPartition;\n", "next_change": {"commit": "941de53b0ae20ae40a820a1bb0e35c6d189a7221", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\nindex 2e6360fca91..4336c9dbd30 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\n", "chunk": "@@ -156,15 +155,16 @@ public class ResultPartitionFactory {\n                             bufferCompressor,\n                             bufferPoolFactory);\n \n-            BiFunction<Integer, PipelinedResultPartition, PipelinedSubpartition> factory;\n-            if (type == ResultPartitionType.PIPELINED_APPROXIMATE) {\n-                factory = PipelinedApproximateSubpartition::new;\n-            } else {\n-                factory = PipelinedSubpartition::new;\n-            }\n-\n             for (int i = 0; i < subpartitions.length; i++) {\n-                subpartitions[i] = factory.apply(i, pipelinedPartition);\n+                if (type == ResultPartitionType.PIPELINED_APPROXIMATE) {\n+                    subpartitions[i] =\n+                            new PipelinedApproximateSubpartition(\n+                                    i, networkBuffersPerChannel, pipelinedPartition);\n+                } else {\n+                    subpartitions[i] =\n+                            new PipelinedSubpartition(\n+                                    i, networkBuffersPerChannel, pipelinedPartition);\n+                }\n             }\n \n             partition = pipelinedPartition;\n", "next_change": {"commit": "4609625eac16247f2d70d8c36c42b3e2dfec8768", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\nindex 4336c9dbd30..aad174e22e4 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\n", "chunk": "@@ -159,11 +159,11 @@ public class ResultPartitionFactory {\n                 if (type == ResultPartitionType.PIPELINED_APPROXIMATE) {\n                     subpartitions[i] =\n                             new PipelinedApproximateSubpartition(\n-                                    i, networkBuffersPerChannel, pipelinedPartition);\n+                                    i, configuredNetworkBuffersPerChannel, pipelinedPartition);\n                 } else {\n                     subpartitions[i] =\n                             new PipelinedSubpartition(\n-                                    i, networkBuffersPerChannel, pipelinedPartition);\n+                                    i, configuredNetworkBuffersPerChannel, pipelinedPartition);\n                 }\n             }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\nindex 4336c9dbd30..aad174e22e4 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\n", "chunk": "@@ -159,11 +159,11 @@ public class ResultPartitionFactory {\n                 if (type == ResultPartitionType.PIPELINED_APPROXIMATE) {\n                     subpartitions[i] =\n                             new PipelinedApproximateSubpartition(\n-                                    i, networkBuffersPerChannel, pipelinedPartition);\n+                                    i, configuredNetworkBuffersPerChannel, pipelinedPartition);\n                 } else {\n                     subpartitions[i] =\n                             new PipelinedSubpartition(\n-                                    i, networkBuffersPerChannel, pipelinedPartition);\n+                                    i, configuredNetworkBuffersPerChannel, pipelinedPartition);\n                 }\n             }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "ac870f925ac5fac7b7b93b238dcfb0307f6db4f1", "committedDate": "2022-06-08 15:55:26 +0800", "message": "[FLINK-27902][network] Introduce isBlockingOrBlockingPersistentResultPartition and replace all remaining isBlocking calls."}, {"oid": "0b60ee8e295baaade575d051e3fe9cc6a540cc5d", "committedDate": "2022-06-21 09:55:52 +0200", "message": "[FLINK-26762][network] Add the overdraft buffer in ResultPartition"}, {"oid": "4a2f3a15903ca365c14368b34b30a6234a51aa5e", "committedDate": "2022-08-02 09:56:30 +0800", "message": "[FLINK-27908] ResultPartitionFactory also supports HYBRID type."}, {"oid": "9f5d0c48f198ff69a175f630832687ba02cf4c3e", "committedDate": "2022-08-05 13:03:21 +0800", "message": "[FLINK-28781] Rename blockingShuffleCompressionEnabled to batchShuffleCompressionEnabled."}, {"oid": "2edc43c6e469a3e16ee01a1373cf52523eb96b01", "committedDate": "2022-08-05 13:03:25 +0800", "message": "[FLINK-28781] Hybrid Shuffle should support compression."}, {"oid": "bfe64603242833ad0c92aa4b6308a3a4f3564b9c", "committedDate": "2022-08-10 09:34:17 +0800", "message": "[FLINK-28701] Split HYBRID result partition type to HYBRID_FULL and HYBRID_SELECTIVE."}, {"oid": "b2c9e00d8a5038e2a50aae57cd38c2dbb8b21db1", "committedDate": "2022-08-18 23:08:45 +0800", "message": "[FLINK-28800][network] BatchShuffleReadIOExecutor using ScheduledExecutorService instead of ExecutorService."}, {"oid": "d11940c4a78c71548b5a06af50da2e5f9cb68918", "committedDate": "2022-10-31 11:32:29 +0800", "message": "[FLINK-28889] HsResultPartition support broadcast optimize"}, {"oid": "8e50e24797fbb154cdf7c484775f0fafa94cf34c", "committedDate": "2023-01-16 10:22:14 +0800", "message": "[FLINK-30332][network] HsFileDataIndex supports caching index entry and introduce config option to configure cache size."}, {"oid": "dabc3ba57776dc31f476d7882e7ebcd973f3909d", "committedDate": "2023-02-09 11:45:47 +0800", "message": "[FLINK-30392][runtime] Change broadcast hybrid selective result partition type to hybrid full in compile phase instead of partition create phase. In the previous implementation, we will force the broadcast hybrid selective edge to be of hybrid full(re-consumable) in the ResultPartitionTypeFactory. But this is not the correct phase to do this replacement, because for scheduling topology, the result is not changed still. This inconsistency will cause many problems, such as increasing the cost of fail-over."}, {"oid": "70c2ab65adeaa03af69b647ba2087ac6cc09e4b1", "committedDate": "2023-03-02 23:32:55 +0800", "message": "[FLINK-31288][runtime] Disable overdraft buffer for non pipelined result partition."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Njc1Njk5NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666756995", "body": "Can we rename this property to something like `receiverExclusiveBuffersPerChannel`?  Because actually this is not the number of `buffersPerChannel` for the sender.", "bodyText": "Can we rename this property to something like receiverExclusiveBuffersPerChannel?  Because actually this is not the number of buffersPerChannel for the sender.", "bodyHTML": "<p dir=\"auto\">Can we rename this property to something like <code>receiverExclusiveBuffersPerChannel</code>?  Because actually this is not the number of <code>buffersPerChannel</code> for the sender.</p>", "author": "pnowojski", "createdAt": "2021-07-09T08:06:49Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -112,8 +120,11 @@\n \n     // ------------------------------------------------------------------------\n \n-    PipelinedSubpartition(int index, ResultPartition parent) {\n+    PipelinedSubpartition(int index, int buffersPerChannel, ResultPartition parent) {\n         super(index, parent);\n+\n+        checkArgument(buffersPerChannel >= 0, \"Buffers per channel must be non-negative.\");\n+        this.buffersPerChannel = buffersPerChannel;", "originalCommit": "a3f6a9f67fcb3429ce0b086c3384f14ff4a31b29", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "da81fde5fc9e110075cff4982048b7f7ee3a0d61", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex bc1e5beb89c..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -120,11 +119,14 @@ public class PipelinedSubpartition extends ResultSubpartition\n \n     // ------------------------------------------------------------------------\n \n-    PipelinedSubpartition(int index, int buffersPerChannel, ResultPartition parent) {\n+    PipelinedSubpartition(\n+            int index, int receiverExclusiveBuffersPerChannel, ResultPartition parent) {\n         super(index, parent);\n \n-        checkArgument(buffersPerChannel >= 0, \"Buffers per channel must be non-negative.\");\n-        this.buffersPerChannel = buffersPerChannel;\n+        checkArgument(\n+                receiverExclusiveBuffersPerChannel >= 0,\n+                \"Buffers per channel must be non-negative.\");\n+        this.receiverExclusiveBuffersPerChannel = receiverExclusiveBuffersPerChannel;\n     }\n \n     @Override\n", "next_change": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 38d8cf93158..134ef688b18 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -119,14 +112,8 @@ public class PipelinedSubpartition extends ResultSubpartition\n \n     // ------------------------------------------------------------------------\n \n-    PipelinedSubpartition(\n-            int index, int receiverExclusiveBuffersPerChannel, ResultPartition parent) {\n+    PipelinedSubpartition(int index, ResultPartition parent) {\n         super(index, parent);\n-\n-        checkArgument(\n-                receiverExclusiveBuffersPerChannel >= 0,\n-                \"Buffers per channel must be non-negative.\");\n-        this.receiverExclusiveBuffersPerChannel = receiverExclusiveBuffersPerChannel;\n     }\n \n     @Override\n", "next_change": {"commit": "941de53b0ae20ae40a820a1bb0e35c6d189a7221", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 134ef688b18..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -112,8 +119,14 @@ public class PipelinedSubpartition extends ResultSubpartition\n \n     // ------------------------------------------------------------------------\n \n-    PipelinedSubpartition(int index, ResultPartition parent) {\n+    PipelinedSubpartition(\n+            int index, int receiverExclusiveBuffersPerChannel, ResultPartition parent) {\n         super(index, parent);\n+\n+        checkArgument(\n+                receiverExclusiveBuffersPerChannel >= 0,\n+                \"Buffers per channel must be non-negative.\");\n+        this.receiverExclusiveBuffersPerChannel = receiverExclusiveBuffersPerChannel;\n     }\n \n     @Override\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "changed_code": [{"header": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex bc1e5beb89c..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n", "chunk": "@@ -120,11 +119,14 @@ public class PipelinedSubpartition extends ResultSubpartition\n \n     // ------------------------------------------------------------------------\n \n-    PipelinedSubpartition(int index, int buffersPerChannel, ResultPartition parent) {\n+    PipelinedSubpartition(\n+            int index, int receiverExclusiveBuffersPerChannel, ResultPartition parent) {\n         super(index, parent);\n \n-        checkArgument(buffersPerChannel >= 0, \"Buffers per channel must be non-negative.\");\n-        this.buffersPerChannel = buffersPerChannel;\n+        checkArgument(\n+                receiverExclusiveBuffersPerChannel >= 0,\n+                \"Buffers per channel must be non-negative.\");\n+        this.receiverExclusiveBuffersPerChannel = receiverExclusiveBuffersPerChannel;\n     }\n \n     @Override\n", "next_change": null}]}, "commits_in_main": [{"oid": "60d015cfc65d9f4b1a5765916ae14100d5dac70c", "message": "Merge commit", "committedDate": null}, {"oid": "edac2adb9523adcb69e1dacc5fd4ea8f63480175", "committedDate": "2021-07-26 09:56:45 +0200", "message": "[FLINK-23329][build] Bump flink-shaded to 14.0"}, {"oid": "088d16517126d7128e1f072d588b9ce0f4787ae6", "committedDate": "2021-08-05 10:16:25 +0200", "message": "[FLINK-23453][refactor] Made a safe method for getting the number of buffers in the queue visible in the interface."}, {"oid": "adf343c555d778983e6b5c58d66a29dba6c90a26", "committedDate": "2021-08-10 08:34:49 +0200", "message": "[FLINK-23408] Rename EndOfUserRecords to EndOfData"}, {"oid": "703662aa61a8f82d4df6de7e0518a568822f71db", "committedDate": "2021-08-11 20:54:47 +0200", "message": "[FLINK-23454][runtime] Subpartition is able to notify the desirable buffer size for input buffer consumer."}, {"oid": "60aa2ac29797df576fe14f5c888f09626351b774", "committedDate": "2021-12-31 10:58:31 +0100", "message": "[refactor][runtime] Added postfix `unsafe` for methods ResultSubpartition#getTotalNumberOfBuffers and ResultSubpartition#getTotalNumberOfBytes"}, {"oid": "10b7afae7423d75f94f397699b09deb9fbbdaca5", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Refactor the barrier alignment timer and default priority sequence number"}, {"oid": "dd8f4e2603309493300099396568ffc681e76e80", "committedDate": "2022-05-25 08:32:07 +0200", "message": "[FLINK-27251][checkpoint] Timeout aligned to unaligned checkpoint barrier in the output buffers"}, {"oid": "5c5cc9dbcc1ce9e041ea3aee9ba32ad6a3e19689", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Add missing @GuardedBy annotation for SortMergeResultPartitionReadScheduler and PipelinedSubpartition."}, {"oid": "3b6816e0a6c578dbcbdcf3061ce6205ddb0f5e48", "committedDate": "2023-02-27 21:59:18 +0800", "message": "[hotfix] Fix some typo and syntax mistakes."}]}, {"oid": "da81fde5fc9e110075cff4982048b7f7ee3a0d61", "url": "https://github.com/apache/flink/commit/da81fde5fc9e110075cff4982048b7f7ee3a0d61", "message": "Fixup", "committedDate": "2021-07-10T10:18:42Z", "type": "forcePushed"}, {"oid": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "url": "https://github.com/apache/flink/commit/dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "message": "[hotfix] Remove redundant if condition in BufferManager\n\nThis closes #11877.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "29d20e309908eea85d077c9f96f9c337217ee89b", "url": "https://github.com/apache/flink/commit/29d20e309908eea85d077c9f96f9c337217ee89b", "message": "[hotfix] Remove outdated comments in UnionInputGate\n\nThis closes #11877.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "c3428a92d528b20b61d030429b9099347144256d", "url": "https://github.com/apache/flink/commit/c3428a92d528b20b61d030429b9099347144256d", "message": "[hotfix] Simplify RemoteInputChannel#onSenderBacklog and call the existing method directly\n\nThis closes #11877.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "b23c8f4778af071cb16b0f80b8357db4477ff812", "url": "https://github.com/apache/flink/commit/b23c8f4778af071cb16b0f80b8357db4477ff812", "message": "[hotfix] Fix typos in NettyShuffleUtils\n\nThis closes #11877.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "bede6d39163df06f22a1d64df440d1067408b2ec", "url": "https://github.com/apache/flink/commit/bede6d39163df06f22a1d64df440d1067408b2ec", "message": "[FLINK-16641][network] (Part#1) Introduce a new network message BacklogAnnouncement which can bring the upstream buffer backlog to the downstream", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "0ffa4e02e374cc5724552a4af8a15d03c8e31cca", "url": "https://github.com/apache/flink/commit/0ffa4e02e374cc5724552a4af8a15d03c8e31cca", "message": "[FLINK-16641][network] (Part#2) Distinguish data buffer and event buffer for BoundedBlockingSubpartitionDirectTransferReader\n\nCurrently, the BoundedBlockingSubpartitionDirectTransferReader does not distinguish data buffer and event buffer but it does not allocate floating credits for events, which means it relies on at least one exclusive credit to send the events. This patch changes the logic and distinguishes data buffer and event buffer for BoundedBlockingSubpartitionDirectTransferReader, after which the BoundedBlockingSubpartitionDirectTransferReader does not rely on the exclusive credits any more and we can set the exclusive credit to 0 after we finish FLINK-16641.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "url": "https://github.com/apache/flink/commit/639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "message": "[FLINK-16641][network] (Part#3) Support to announce the upstream backlog to the downstream tasks\n\nThis batch introduce the ability of announcing upstream backlog to the downstream tasks through the BacklogAnnouncement message when the exclusive credit is 0. This gives the upstream tasks the ability to actively allocate credits from the downstream tasks, which is needed by FLINK-16641.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "url": "https://github.com/apache/flink/commit/412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "message": "[FLINK-16641][network] (Part#4) Release all allocated floating buffers of RemoteInputChannel on receiving any channel blocking event if the exclusive credit is 0\n\nThis patch tries to release all allocated floating buffers of RemoteInputChannel on receiving any channel blocking event if the exclusive credit is 0 because a blocked channel does not need any credit and after that, these released credits can be used by other active channels. This can avoid the deadlock where credits are assigned to channels which do need them and those channels who need credits can not get any when the exclusive credit is 0.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "941de53b0ae20ae40a820a1bb0e35c6d189a7221", "url": "https://github.com/apache/flink/commit/941de53b0ae20ae40a820a1bb0e35c6d189a7221", "message": "[FLINK-16641][network] (Part#5) Send empty buffers to the downstream tasks to release the allocated credits if the exclusive credit is 0\n\nCurrently,the empty buffers are not sent to the downstream tasks. This patch changes the logic and sends empty buffers to the downstream tasks when the exclusive credit is 0 release the allocated floating credits. If we do not do that, the downstream task may allocate more credits than needed which may lead to dead lock without exclusive credits.", "committedDate": "2021-07-12T10:45:01Z", "type": "commit"}, {"oid": "4609625eac16247f2d70d8c36c42b3e2dfec8768", "url": "https://github.com/apache/flink/commit/4609625eac16247f2d70d8c36c42b3e2dfec8768", "message": "[FLINK-16641][network] (Part#6) Enable to set network buffers per channel to 0\n\nThis PR enables to set the number of network buffer per channel (taskmanager.network.memory.buffers-per-channel) to 0. Previously, the value can not be set to 0 because of dead lock, FLINK-16641 solves the problem and we can set it to 0 now.", "committedDate": "2021-07-12T11:16:21Z", "type": "commit"}, {"oid": "4609625eac16247f2d70d8c36c42b3e2dfec8768", "url": "https://github.com/apache/flink/commit/4609625eac16247f2d70d8c36c42b3e2dfec8768", "message": "[FLINK-16641][network] (Part#6) Enable to set network buffers per channel to 0\n\nThis PR enables to set the number of network buffer per channel (taskmanager.network.memory.buffers-per-channel) to 0. Previously, the value can not be set to 0 because of dead lock, FLINK-16641 solves the problem and we can set it to 0 now.", "committedDate": "2021-07-12T11:16:21Z", "type": "forcePushed"}]}