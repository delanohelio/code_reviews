{"pr_number": 1462, "pr_title": "fix deadlock situation in concurrent executions", "pr_author": "sarmbruster", "pr_createdAt": "2020-03-28T14:40:51Z", "pr_url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462", "merge_commit": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "timeline": [{"oid": "45245536ee01b783c033b4f1f6fff61808180ffa", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/45245536ee01b783c033b4f1f6fff61808180ffa", "message": "ensure tombstone is sent, adding `queueCapacity` parameter", "committedDate": "2020-03-19T16:38:15Z", "type": "commit"}, {"oid": "8414e6a750a3bbe6c91d50f1a0b84808f9b50501", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/8414e6a750a3bbe6c91d50f1a0b84808f9b50501", "message": "WIP - bookmark for delivered snapshot", "committedDate": "2020-03-24T19:35:35Z", "type": "commit"}, {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/0a16124b759d7511b6608ca769de5fb5ed764275", "message": "prevent QueueBasedSpliterator from waiting forever\n\nUsing a state variable QueueBasedSpliterator knows if it already has seen tombstone.", "committedDate": "2020-03-28T14:33:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjIyMA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866220", "body": "can this lead into being blocked forever? Shouldn't we take the timeout into account?\r\nint put and/or the whole method time?", "bodyText": "can this lead into being blocked forever? Shouldn't we take the timeout into account?\nint put and/or the whole method time?", "bodyHTML": "<p dir=\"auto\">can this lead into being blocked forever? Shouldn't we take the timeout into account?<br>\nint put and/or the whole method time?</p>", "author": "jexp", "createdAt": "2020-03-29T22:54:34Z", "path": "src/main/java/apoc/cypher/Cypher.java", "diffHunk": "@@ -95,26 +112,47 @@\n     public Stream<RowResult> runSchemaFiles(@Name(\"file\") List<String> fileNames, @Name(value = \"config\",defaultValue = \"{}\") Map<String,Object> config) {\n         boolean addStatistics = Util.toBoolean(config.getOrDefault(\"statistics\",true));\n         int timeout = Util.toInteger(config.getOrDefault(\"timeout\",10));\n+        int queueCapacity = Util.toInteger(config.getOrDefault(\"queueCapacity\",100));\n         List<RowResult> result = new ArrayList<>();\n         for (String f : fileNames) {\n-            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout).collect(Collectors.toList());\n+            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout, queueCapacity).collect(Collectors.toList());\n             result.addAll(rowResults);\n         }\n         return result.stream();\n     }\n \n-    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout) {\n-        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(100);\n-        Util.inThread(() -> {\n+    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout, int queueCapacity) {\n+        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(queueCapacity);\n+        runInSeparateThreadAndSendTombstone(() -> {\n             if (schemaOperation) {\n-                runSchemaStatementsInTx(reader, queue, params, addStatistics,timeout);\n+                runSchemaStatementsInTx(reader, queue, params, addStatistics, timeout);\n             } else {\n-                runDataStatementsInTx(reader, queue, params, addStatistics,timeout);\n+                runDataStatementsInTx(reader, queue, params, addStatistics, timeout);\n             }\n-            queue.put(RowResult.TOMBSTONE);\n-            return null;\n-        });\n-        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, timeout), false);\n+        }, queue, RowResult.TOMBSTONE);\n+        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard), false);\n+    }\n+\n+\n+    private <T> void runInSeparateThreadAndSendTombstone(Runnable action, BlockingQueue<T> queue, T tombstone) {\n+        /* NB: this must not be called via an existing thread pool - otherwise we could run into a deadlock\n+           other jobs using the same pool might completely exhaust at and the thread sending TOMBSTONE will\n+           wait in the pool's job queue.\n+         */\n+        new Thread(() -> {\n+            try {\n+                action.run();\n+            } finally {\n+                while (true) {  // ensure we send TOMBSTONE even if there's an InterruptedException\n+                    try {\n+                        queue.put(tombstone);\n+                        return;\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();", "originalCommit": "0a16124b759d7511b6608ca769de5fb5ed764275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwMzY2MA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404803660", "bodyText": "Blocking forever?", "author": "jexp", "createdAt": "2020-04-07T13:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjIyMA=="}], "type": "inlineReview", "revised_code": {"commit": "de07980676970f5c00cc04ed5cc0670cd0a793ac", "changed_code": [{"header": "diff --git a/src/main/java/apoc/cypher/Cypher.java b/src/main/java/apoc/cypher/Cypher.java\nindex 434848a08..ca1c386e2 100644\n--- a/src/main/java/apoc/cypher/Cypher.java\n+++ b/src/main/java/apoc/cypher/Cypher.java\n", "chunk": "@@ -122,26 +123,26 @@ public class Cypher {\n     }\n \n     private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout, int queueCapacity) {\n-        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(queueCapacity);\n-        runInSeparateThreadAndSendTombstone(() -> {\n+        BlockingQueue<RowResult> queue = runInSeparateThreadAndSendTombstone(queueCapacity, internalQueue -> {\n             if (schemaOperation) {\n-                runSchemaStatementsInTx(reader, queue, params, addStatistics, timeout);\n+                runSchemaStatementsInTx(reader, internalQueue, params, addStatistics, timeout);\n             } else {\n-                runDataStatementsInTx(reader, queue, params, addStatistics, timeout);\n+                runDataStatementsInTx(reader, internalQueue, params, addStatistics, timeout);\n             }\n-        }, queue, RowResult.TOMBSTONE);\n-        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard), false);\n+        }, RowResult.TOMBSTONE);\n+        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, Integer.MAX_VALUE), false);\n     }\n \n \n-    private <T> void runInSeparateThreadAndSendTombstone(Runnable action, BlockingQueue<T> queue, T tombstone) {\n+    private <T> BlockingQueue<T> runInSeparateThreadAndSendTombstone(int queueCapacity, Consumer<BlockingQueue<T>> action, T tombstone) {\n         /* NB: this must not be called via an existing thread pool - otherwise we could run into a deadlock\n            other jobs using the same pool might completely exhaust at and the thread sending TOMBSTONE will\n            wait in the pool's job queue.\n          */\n+        BlockingQueue<T> queue = new ArrayBlockingQueue<>(queueCapacity);\n         new Thread(() -> {\n             try {\n-                action.run();\n+                action.accept(queue);\n             } finally {\n                 while (true) {  // ensure we send TOMBSTONE even if there's an InterruptedException\n                     try {\n", "next_change": null}, {"header": "diff --git a/src/main/java/apoc/cypher/Cypher.java b/src/main/java/apoc/cypher/Cypher.java\nindex 434848a08..ca1c386e2 100644\n--- a/src/main/java/apoc/cypher/Cypher.java\n+++ b/src/main/java/apoc/cypher/Cypher.java\n", "chunk": "@@ -153,6 +154,7 @@ public class Cypher {\n                 }\n             }\n         }).start();\n+        return queue;\n     }\n \n     private void runDataStatementsInTx(Reader reader, BlockingQueue<RowResult> queue, Map<String, Object> params, boolean addStatistics, long timeout) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "changed_code": [{"header": "diff --git a/src/main/java/apoc/cypher/Cypher.java b/src/main/java/apoc/cypher/Cypher.java\nindex 434848a08..ca1c386e2 100644\n--- a/src/main/java/apoc/cypher/Cypher.java\n+++ b/src/main/java/apoc/cypher/Cypher.java\n", "chunk": "@@ -122,26 +123,26 @@ public class Cypher {\n     }\n \n     private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout, int queueCapacity) {\n-        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(queueCapacity);\n-        runInSeparateThreadAndSendTombstone(() -> {\n+        BlockingQueue<RowResult> queue = runInSeparateThreadAndSendTombstone(queueCapacity, internalQueue -> {\n             if (schemaOperation) {\n-                runSchemaStatementsInTx(reader, queue, params, addStatistics, timeout);\n+                runSchemaStatementsInTx(reader, internalQueue, params, addStatistics, timeout);\n             } else {\n-                runDataStatementsInTx(reader, queue, params, addStatistics, timeout);\n+                runDataStatementsInTx(reader, internalQueue, params, addStatistics, timeout);\n             }\n-        }, queue, RowResult.TOMBSTONE);\n-        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard), false);\n+        }, RowResult.TOMBSTONE);\n+        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, Integer.MAX_VALUE), false);\n     }\n \n \n-    private <T> void runInSeparateThreadAndSendTombstone(Runnable action, BlockingQueue<T> queue, T tombstone) {\n+    private <T> BlockingQueue<T> runInSeparateThreadAndSendTombstone(int queueCapacity, Consumer<BlockingQueue<T>> action, T tombstone) {\n         /* NB: this must not be called via an existing thread pool - otherwise we could run into a deadlock\n            other jobs using the same pool might completely exhaust at and the thread sending TOMBSTONE will\n            wait in the pool's job queue.\n          */\n+        BlockingQueue<T> queue = new ArrayBlockingQueue<>(queueCapacity);\n         new Thread(() -> {\n             try {\n-                action.run();\n+                action.accept(queue);\n             } finally {\n                 while (true) {  // ensure we send TOMBSTONE even if there's an InterruptedException\n                     try {\n", "next_change": {"commit": "7e6ad6337cd41034ed7534b6cd289cbcf0994266", "changed_code": [{"header": "diff --git a/src/main/java/apoc/cypher/Cypher.java b/src/main/java/apoc/cypher/Cypher.java\nindex ca1c386e2..7d0f70767 100644\n--- a/src/main/java/apoc/cypher/Cypher.java\n+++ b/src/main/java/apoc/cypher/Cypher.java\n", "chunk": "@@ -113,48 +95,26 @@ public class Cypher {\n     public Stream<RowResult> runSchemaFiles(@Name(\"file\") List<String> fileNames, @Name(value = \"config\",defaultValue = \"{}\") Map<String,Object> config) {\n         boolean addStatistics = Util.toBoolean(config.getOrDefault(\"statistics\",true));\n         int timeout = Util.toInteger(config.getOrDefault(\"timeout\",10));\n-        int queueCapacity = Util.toInteger(config.getOrDefault(\"queueCapacity\",100));\n         List<RowResult> result = new ArrayList<>();\n         for (String f : fileNames) {\n-            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout, queueCapacity).collect(Collectors.toList());\n+            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout).collect(Collectors.toList());\n             result.addAll(rowResults);\n         }\n         return result.stream();\n     }\n \n-    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout, int queueCapacity) {\n-        BlockingQueue<RowResult> queue = runInSeparateThreadAndSendTombstone(queueCapacity, internalQueue -> {\n+    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout) {\n+        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(100);\n+        Util.inThread(() -> {\n             if (schemaOperation) {\n-                runSchemaStatementsInTx(reader, internalQueue, params, addStatistics, timeout);\n+                runSchemaStatementsInTx(reader, queue, params, addStatistics,timeout);\n             } else {\n-                runDataStatementsInTx(reader, internalQueue, params, addStatistics, timeout);\n+                runDataStatementsInTx(reader, queue, params, addStatistics,timeout);\n             }\n-        }, RowResult.TOMBSTONE);\n-        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, Integer.MAX_VALUE), false);\n-    }\n-\n-\n-    private <T> BlockingQueue<T> runInSeparateThreadAndSendTombstone(int queueCapacity, Consumer<BlockingQueue<T>> action, T tombstone) {\n-        /* NB: this must not be called via an existing thread pool - otherwise we could run into a deadlock\n-           other jobs using the same pool might completely exhaust at and the thread sending TOMBSTONE will\n-           wait in the pool's job queue.\n-         */\n-        BlockingQueue<T> queue = new ArrayBlockingQueue<>(queueCapacity);\n-        new Thread(() -> {\n-            try {\n-                action.accept(queue);\n-            } finally {\n-                while (true) {  // ensure we send TOMBSTONE even if there's an InterruptedException\n-                    try {\n-                        queue.put(tombstone);\n-                        return;\n-                    } catch (InterruptedException e) {\n-                        Thread.currentThread().interrupt();\n-                    }\n-                }\n-            }\n-        }).start();\n-        return queue;\n+            queue.put(RowResult.TOMBSTONE);\n+            return null;\n+        });\n+        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, timeout), false);\n     }\n \n     private void runDataStatementsInTx(Reader reader, BlockingQueue<RowResult> queue, Map<String, Object> params, boolean addStatistics, long timeout) {\n", "next_change": {"commit": "53528dd19ba4a8dea0a15cdb8e8b88115462311f", "changed_code": [{"header": "diff --git a/src/main/java/apoc/cypher/Cypher.java b/src/main/java/apoc/cypher/Cypher.java\nindex 7d0f70767..b44e8be14 100644\n--- a/src/main/java/apoc/cypher/Cypher.java\n+++ b/src/main/java/apoc/cypher/Cypher.java\n", "chunk": "@@ -95,26 +114,48 @@ public class Cypher {\n     public Stream<RowResult> runSchemaFiles(@Name(\"file\") List<String> fileNames, @Name(value = \"config\",defaultValue = \"{}\") Map<String,Object> config) {\n         boolean addStatistics = Util.toBoolean(config.getOrDefault(\"statistics\",true));\n         int timeout = Util.toInteger(config.getOrDefault(\"timeout\",10));\n+        int queueCapacity = Util.toInteger(config.getOrDefault(\"queueCapacity\",100));\n         List<RowResult> result = new ArrayList<>();\n         for (String f : fileNames) {\n-            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout).collect(Collectors.toList());\n+            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout, queueCapacity).collect(Collectors.toList());\n             result.addAll(rowResults);\n         }\n         return result.stream();\n     }\n \n-    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout) {\n-        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(100);\n-        Util.inThread(() -> {\n+    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout, int queueCapacity) {\n+        BlockingQueue<RowResult> queue = runInSeparateThreadAndSendTombstone(queueCapacity, internalQueue -> {\n             if (schemaOperation) {\n-                runSchemaStatementsInTx(reader, queue, params, addStatistics,timeout);\n+                runSchemaStatementsInTx(reader, internalQueue, params, addStatistics, timeout);\n             } else {\n-                runDataStatementsInTx(reader, queue, params, addStatistics,timeout);\n+                runDataStatementsInTx(reader, internalQueue, params, addStatistics, timeout);\n             }\n-            queue.put(RowResult.TOMBSTONE);\n-            return null;\n-        });\n-        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, timeout), false);\n+        }, RowResult.TOMBSTONE);\n+        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, Integer.MAX_VALUE), false);\n+    }\n+\n+\n+    private <T> BlockingQueue<T> runInSeparateThreadAndSendTombstone(int queueCapacity, Consumer<BlockingQueue<T>> action, T tombstone) {\n+        /* NB: this must not be called via an existing thread pool - otherwise we could run into a deadlock\n+           other jobs using the same pool might completely exhaust at and the thread sending TOMBSTONE will\n+           wait in the pool's job queue.\n+         */\n+        BlockingQueue<T> queue = new ArrayBlockingQueue<>(queueCapacity);\n+        new Thread(() -> {\n+            try {\n+                action.accept(queue);\n+            } finally {\n+                while (true) {  // ensure we send TOMBSTONE even if there's an InterruptedException\n+                    try {\n+                        queue.put(tombstone);\n+                        return;\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();\n+                    }\n+                }\n+            }\n+        }).start();\n+        return queue;\n     }\n \n     private void runDataStatementsInTx(Reader reader, BlockingQueue<RowResult> queue, Map<String, Object> params, boolean addStatistics, long timeout) {\n", "next_change": null}]}}]}}, {"header": "diff --git a/src/main/java/apoc/cypher/Cypher.java b/src/main/java/apoc/cypher/Cypher.java\nindex 434848a08..ca1c386e2 100644\n--- a/src/main/java/apoc/cypher/Cypher.java\n+++ b/src/main/java/apoc/cypher/Cypher.java\n", "chunk": "@@ -153,6 +154,7 @@ public class Cypher {\n                 }\n             }\n         }).start();\n+        return queue;\n     }\n \n     private void runDataStatementsInTx(Reader reader, BlockingQueue<RowResult> queue, Map<String, Object> params, boolean addStatistics, long timeout) {\n", "next_change": {"commit": "7e6ad6337cd41034ed7534b6cd289cbcf0994266", "changed_code": [{"header": "diff --git a/src/main/java/apoc/cypher/Cypher.java b/src/main/java/apoc/cypher/Cypher.java\nindex ca1c386e2..7d0f70767 100644\n--- a/src/main/java/apoc/cypher/Cypher.java\n+++ b/src/main/java/apoc/cypher/Cypher.java\n", "chunk": "@@ -113,48 +95,26 @@ public class Cypher {\n     public Stream<RowResult> runSchemaFiles(@Name(\"file\") List<String> fileNames, @Name(value = \"config\",defaultValue = \"{}\") Map<String,Object> config) {\n         boolean addStatistics = Util.toBoolean(config.getOrDefault(\"statistics\",true));\n         int timeout = Util.toInteger(config.getOrDefault(\"timeout\",10));\n-        int queueCapacity = Util.toInteger(config.getOrDefault(\"queueCapacity\",100));\n         List<RowResult> result = new ArrayList<>();\n         for (String f : fileNames) {\n-            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout, queueCapacity).collect(Collectors.toList());\n+            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout).collect(Collectors.toList());\n             result.addAll(rowResults);\n         }\n         return result.stream();\n     }\n \n-    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout, int queueCapacity) {\n-        BlockingQueue<RowResult> queue = runInSeparateThreadAndSendTombstone(queueCapacity, internalQueue -> {\n+    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout) {\n+        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(100);\n+        Util.inThread(() -> {\n             if (schemaOperation) {\n-                runSchemaStatementsInTx(reader, internalQueue, params, addStatistics, timeout);\n+                runSchemaStatementsInTx(reader, queue, params, addStatistics,timeout);\n             } else {\n-                runDataStatementsInTx(reader, internalQueue, params, addStatistics, timeout);\n+                runDataStatementsInTx(reader, queue, params, addStatistics,timeout);\n             }\n-        }, RowResult.TOMBSTONE);\n-        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, Integer.MAX_VALUE), false);\n-    }\n-\n-\n-    private <T> BlockingQueue<T> runInSeparateThreadAndSendTombstone(int queueCapacity, Consumer<BlockingQueue<T>> action, T tombstone) {\n-        /* NB: this must not be called via an existing thread pool - otherwise we could run into a deadlock\n-           other jobs using the same pool might completely exhaust at and the thread sending TOMBSTONE will\n-           wait in the pool's job queue.\n-         */\n-        BlockingQueue<T> queue = new ArrayBlockingQueue<>(queueCapacity);\n-        new Thread(() -> {\n-            try {\n-                action.accept(queue);\n-            } finally {\n-                while (true) {  // ensure we send TOMBSTONE even if there's an InterruptedException\n-                    try {\n-                        queue.put(tombstone);\n-                        return;\n-                    } catch (InterruptedException e) {\n-                        Thread.currentThread().interrupt();\n-                    }\n-                }\n-            }\n-        }).start();\n-        return queue;\n+            queue.put(RowResult.TOMBSTONE);\n+            return null;\n+        });\n+        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, timeout), false);\n     }\n \n     private void runDataStatementsInTx(Reader reader, BlockingQueue<RowResult> queue, Map<String, Object> params, boolean addStatistics, long timeout) {\n", "next_change": {"commit": "53528dd19ba4a8dea0a15cdb8e8b88115462311f", "changed_code": [{"header": "diff --git a/src/main/java/apoc/cypher/Cypher.java b/src/main/java/apoc/cypher/Cypher.java\nindex 7d0f70767..b44e8be14 100644\n--- a/src/main/java/apoc/cypher/Cypher.java\n+++ b/src/main/java/apoc/cypher/Cypher.java\n", "chunk": "@@ -95,26 +114,48 @@ public class Cypher {\n     public Stream<RowResult> runSchemaFiles(@Name(\"file\") List<String> fileNames, @Name(value = \"config\",defaultValue = \"{}\") Map<String,Object> config) {\n         boolean addStatistics = Util.toBoolean(config.getOrDefault(\"statistics\",true));\n         int timeout = Util.toInteger(config.getOrDefault(\"timeout\",10));\n+        int queueCapacity = Util.toInteger(config.getOrDefault(\"queueCapacity\",100));\n         List<RowResult> result = new ArrayList<>();\n         for (String f : fileNames) {\n-            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout).collect(Collectors.toList());\n+            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout, queueCapacity).collect(Collectors.toList());\n             result.addAll(rowResults);\n         }\n         return result.stream();\n     }\n \n-    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout) {\n-        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(100);\n-        Util.inThread(() -> {\n+    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout, int queueCapacity) {\n+        BlockingQueue<RowResult> queue = runInSeparateThreadAndSendTombstone(queueCapacity, internalQueue -> {\n             if (schemaOperation) {\n-                runSchemaStatementsInTx(reader, queue, params, addStatistics,timeout);\n+                runSchemaStatementsInTx(reader, internalQueue, params, addStatistics, timeout);\n             } else {\n-                runDataStatementsInTx(reader, queue, params, addStatistics,timeout);\n+                runDataStatementsInTx(reader, internalQueue, params, addStatistics, timeout);\n             }\n-            queue.put(RowResult.TOMBSTONE);\n-            return null;\n-        });\n-        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, timeout), false);\n+        }, RowResult.TOMBSTONE);\n+        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, Integer.MAX_VALUE), false);\n+    }\n+\n+\n+    private <T> BlockingQueue<T> runInSeparateThreadAndSendTombstone(int queueCapacity, Consumer<BlockingQueue<T>> action, T tombstone) {\n+        /* NB: this must not be called via an existing thread pool - otherwise we could run into a deadlock\n+           other jobs using the same pool might completely exhaust at and the thread sending TOMBSTONE will\n+           wait in the pool's job queue.\n+         */\n+        BlockingQueue<T> queue = new ArrayBlockingQueue<>(queueCapacity);\n+        new Thread(() -> {\n+            try {\n+                action.accept(queue);\n+            } finally {\n+                while (true) {  // ensure we send TOMBSTONE even if there's an InterruptedException\n+                    try {\n+                        queue.put(tombstone);\n+                        return;\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();\n+                    }\n+                }\n+            }\n+        }).start();\n+        return queue;\n     }\n \n     private void runDataStatementsInTx(Reader reader, BlockingQueue<RowResult> queue, Map<String, Object> params, boolean addStatistics, long timeout) {\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "message": "Merge commit", "committedDate": null}, {"oid": "7e6ad6337cd41034ed7534b6cd289cbcf0994266", "committedDate": "2019-07-26 22:52:52 +0200", "message": "migrating to Neo4j 4.0: changed package names"}, {"oid": "e0d27c52f6cc4b1217f78b338f7687cb903d0323", "committedDate": "2019-07-30 11:23:32 +0200", "message": "migrating to Neo4j 4.0: use empty list/map instead of empty string for default values"}, {"oid": "15d177e3d03d3b6e8b4f0091d09bca223f8aa319", "committedDate": "2019-08-14 11:17:12 +0200", "message": "migrating to Neo4j 4.0: refactor Pools to not use static"}, {"oid": "6e206250a56459709540025989fd1e89f056756e", "committedDate": "2019-08-21 11:37:01 +0200", "message": "migrating to Neo4j 4.0: getting rid of static stuff"}, {"oid": "5ff1f90ab724fd159b0f5051719aa73afb081be0", "committedDate": "2019-08-30 19:22:02 +0200", "message": "migrating to Neo4j 4.0: refactor pools into a global extension"}, {"oid": "2ae604fb137d717333d17d2f17cff4dbb5f1af7a", "committedDate": "2019-09-22 21:07:42 +0200", "message": "adopting to core API changes since Neo4j 4.0.0-alpha08-mr02"}, {"oid": "b23fad24486f98432da29872fb0a7f081289b4a3", "committedDate": "2019-10-03 21:57:37 +0200", "message": "cypher params: use $param instead of {param}"}, {"oid": "83b4633e30ef1bbe0eca1fcfce50a6a7bb016a3d", "committedDate": "2019-10-14 21:18:43 +0800", "message": "apoc.cypher.runXXX deals gracefully with \"using periodic iterate\""}, {"oid": "73c2614e9ec88d33bf9c049db1cfefe953c18e68", "committedDate": "2019-10-18 11:13:25 +0800", "message": "run cypher in separate transactions to prevent ConcurrentModifactionException"}, {"oid": "989d2ddc58b83549c7952caf5d03fd97b2ffc4ce", "committedDate": "2019-11-03 22:49:06 +0100", "message": "cleanup"}, {"oid": "eca1b25922079a56ac509d8521673908c34d87fe", "committedDate": "2019-11-19 12:04:15 +0100", "message": "fixes #1262: apoc.cypher.runFile fails when there is a empty transaction (#1349)"}, {"oid": "53528dd19ba4a8dea0a15cdb8e8b88115462311f", "committedDate": "2020-04-15 09:29:56 +0100", "message": "fix deadlock situation in concurrent executions (#1462)"}, {"oid": "10e98ca0d730a007511a5c410dc20ee2fb8348c9", "committedDate": "2020-05-14 15:44:24 +0100", "message": "fixes #1163: apoc.cypher.parallel() procedures need tx termination guards (#1501)"}, {"oid": "8ca01d3a1113ef32969148b8a079303e11aa52b1", "committedDate": "2020-06-01 11:27:25 +0100", "message": "splitting repo into core and full"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjMzOA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866338", "body": "this is now blocking forever if the queue is full? \r\nexactly what we wanted to avoid with the timeout?\r\nthat was the reason we used offer in the first place ...", "bodyText": "this is now blocking forever if the queue is full?\nexactly what we wanted to avoid with the timeout?\nthat was the reason we used offer in the first place ...", "bodyHTML": "<p dir=\"auto\">this is now blocking forever if the queue is full?<br>\nexactly what we wanted to avoid with the timeout?<br>\nthat was the reason we used offer in the first place ...</p>", "author": "jexp", "createdAt": "2020-03-29T22:55:46Z", "path": "src/main/java/apoc/cypher/Cypher.java", "diffHunk": "@@ -163,7 +203,7 @@ private Object executeStatement(BlockingQueue<RowResult> queue, String stmt, Map\n                 queue.put(new RowResult(row++, result.next()));\n             }\n             if (addStatistics) {\n-                queue.offer(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)), timeout,TimeUnit.SECONDS);\n+                queue.put(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)));", "originalCommit": "0a16124b759d7511b6608ca769de5fb5ed764275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY3ODQ4Mg==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404678482", "bodyText": "Did you want to wrap this one too?", "author": "jexp", "createdAt": "2020-04-07T09:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjMzOA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "7e6ad6337cd41034ed7534b6cd289cbcf0994266", "changed_code": [{"header": "diff --git a/src/main/java/apoc/cypher/Cypher.java b/src/main/java/apoc/cypher/Cypher.java\nindex 434848a08..7d0f70767 100644\n--- a/src/main/java/apoc/cypher/Cypher.java\n+++ b/src/main/java/apoc/cypher/Cypher.java\n", "chunk": "@@ -203,7 +163,7 @@ public class Cypher {\n                 queue.put(new RowResult(row++, result.next()));\n             }\n             if (addStatistics) {\n-                queue.put(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)));\n+                queue.offer(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)), timeout,TimeUnit.SECONDS);\n             }\n             return row;\n         }\n", "next_change": {"commit": "2ae604fb137d717333d17d2f17cff4dbb5f1af7a", "changed_code": [{"header": "diff --git a/src/main/java/apoc/cypher/Cypher.java b/src/main/java/apoc/cypher/Cypher.java\nindex 7d0f70767..0effd50ff 100644\n--- a/src/main/java/apoc/cypher/Cypher.java\n+++ b/src/main/java/apoc/cypher/Cypher.java\n", "chunk": "@@ -166,6 +168,8 @@ public class Cypher {\n                 queue.offer(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)), timeout,TimeUnit.SECONDS);\n             }\n             return row;\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n         }\n     }\n \n", "next_change": {"commit": "83b4633e30ef1bbe0eca1fcfce50a6a7bb016a3d", "changed_code": [{"header": "diff --git a/src/main/java/apoc/cypher/Cypher.java b/src/main/java/apoc/cypher/Cypher.java\nindex 0effd50ff..4d5987b13 100644\n--- a/src/main/java/apoc/cypher/Cypher.java\n+++ b/src/main/java/apoc/cypher/Cypher.java\n", "chunk": "@@ -165,7 +176,7 @@ public class Cypher {\n                 queue.put(new RowResult(row++, result.next()));\n             }\n             if (addStatistics) {\n-                queue.offer(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)), timeout,TimeUnit.SECONDS);\n+                queue.offer(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)), timeout, TimeUnit.SECONDS);\n             }\n             return row;\n         } catch (InterruptedException e) {\n", "next_change": {"commit": "53528dd19ba4a8dea0a15cdb8e8b88115462311f", "changed_code": [{"header": "diff --git a/src/main/java/apoc/cypher/Cypher.java b/src/main/java/apoc/cypher/Cypher.java\nindex 4d5987b13..b44e8be14 100644\n--- a/src/main/java/apoc/cypher/Cypher.java\n+++ b/src/main/java/apoc/cypher/Cypher.java\n", "chunk": "@@ -176,7 +217,7 @@ public class Cypher {\n                 queue.put(new RowResult(row++, result.next()));\n             }\n             if (addStatistics) {\n-                queue.offer(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)), timeout, TimeUnit.SECONDS);\n+                queue.put(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)));\n             }\n             return row;\n         } catch (InterruptedException e) {\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "message": "Merge commit", "committedDate": null}, {"oid": "7e6ad6337cd41034ed7534b6cd289cbcf0994266", "committedDate": "2019-07-26 22:52:52 +0200", "message": "migrating to Neo4j 4.0: changed package names"}, {"oid": "e0d27c52f6cc4b1217f78b338f7687cb903d0323", "committedDate": "2019-07-30 11:23:32 +0200", "message": "migrating to Neo4j 4.0: use empty list/map instead of empty string for default values"}, {"oid": "15d177e3d03d3b6e8b4f0091d09bca223f8aa319", "committedDate": "2019-08-14 11:17:12 +0200", "message": "migrating to Neo4j 4.0: refactor Pools to not use static"}, {"oid": "6e206250a56459709540025989fd1e89f056756e", "committedDate": "2019-08-21 11:37:01 +0200", "message": "migrating to Neo4j 4.0: getting rid of static stuff"}, {"oid": "5ff1f90ab724fd159b0f5051719aa73afb081be0", "committedDate": "2019-08-30 19:22:02 +0200", "message": "migrating to Neo4j 4.0: refactor pools into a global extension"}, {"oid": "2ae604fb137d717333d17d2f17cff4dbb5f1af7a", "committedDate": "2019-09-22 21:07:42 +0200", "message": "adopting to core API changes since Neo4j 4.0.0-alpha08-mr02"}, {"oid": "b23fad24486f98432da29872fb0a7f081289b4a3", "committedDate": "2019-10-03 21:57:37 +0200", "message": "cypher params: use $param instead of {param}"}, {"oid": "83b4633e30ef1bbe0eca1fcfce50a6a7bb016a3d", "committedDate": "2019-10-14 21:18:43 +0800", "message": "apoc.cypher.runXXX deals gracefully with \"using periodic iterate\""}, {"oid": "73c2614e9ec88d33bf9c049db1cfefe953c18e68", "committedDate": "2019-10-18 11:13:25 +0800", "message": "run cypher in separate transactions to prevent ConcurrentModifactionException"}, {"oid": "989d2ddc58b83549c7952caf5d03fd97b2ffc4ce", "committedDate": "2019-11-03 22:49:06 +0100", "message": "cleanup"}, {"oid": "eca1b25922079a56ac509d8521673908c34d87fe", "committedDate": "2019-11-19 12:04:15 +0100", "message": "fixes #1262: apoc.cypher.runFile fails when there is a empty transaction (#1349)"}, {"oid": "53528dd19ba4a8dea0a15cdb8e8b88115462311f", "committedDate": "2020-04-15 09:29:56 +0100", "message": "fix deadlock situation in concurrent executions (#1462)"}, {"oid": "10e98ca0d730a007511a5c410dc20ee2fb8348c9", "committedDate": "2020-05-14 15:44:24 +0100", "message": "fixes #1163: apoc.cypher.parallel() procedures need tx termination guards (#1501)"}, {"oid": "8ca01d3a1113ef32969148b8a079303e11aa52b1", "committedDate": "2020-06-01 11:27:25 +0100", "message": "splitting repo into core and full"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjkwMA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866900", "body": "this will now potentially block forever ...", "bodyText": "this will now potentially block forever ...", "bodyHTML": "<p dir=\"auto\">this will now potentially block forever ...</p>", "author": "jexp", "createdAt": "2020-03-29T23:01:06Z", "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "diffHunk": "@@ -6,49 +6,35 @@\n import java.util.concurrent.BlockingQueue;\n import java.util.function.Consumer;\n \n-import static java.util.concurrent.TimeUnit.SECONDS;\n-\n /**\n  * @author mh\n  * @since 06.12.17\n  */\n public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n-    private T entry;\n     private TerminationGuard terminationGuard;\n-    private final long timeout;\n+    private boolean foundTombstone = false;\n \n     public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n-        this(queue, tombstone, terminationGuard, 10);\n-    }\n-\n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, long timeout) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n-        this.timeout = timeout;\n-        entry = poll();\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard)) return false;\n-        if (isEnd()) return false;\n-        action.accept(entry);\n-        entry = poll();\n-        return !isEnd();\n-    }\n-\n-    private boolean isEnd() {\n-        return entry == null || entry == tombstone;\n-    }\n-\n-    private T poll() {\n+        if (Util.transactionIsTerminated(terminationGuard) || foundTombstone) return false;\n         try {\n-            return queue.poll(timeout, SECONDS);\n+            T element = queue.take();", "originalCommit": "0a16124b759d7511b6608ca769de5fb5ed764275", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "de07980676970f5c00cc04ed5cc0670cd0a793ac", "changed_code": [{"header": "diff --git a/src/main/java/apoc/util/QueueBasedSpliterator.java b/src/main/java/apoc/util/QueueBasedSpliterator.java\nindex 3a50e7c99..440378df3 100644\n--- a/src/main/java/apoc/util/QueueBasedSpliterator.java\n+++ b/src/main/java/apoc/util/QueueBasedSpliterator.java\n", "chunk": "@@ -14,27 +14,27 @@ public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n     private TerminationGuard terminationGuard;\n-    private boolean foundTombstone = false;\n+    private volatile boolean foundTombstone = false;\n+    private final int timeoutSeconds;\n \n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n+    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, int timeoutSeconds) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n+        this.timeoutSeconds = timeoutSeconds;\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard) || foundTombstone) return false;\n-        try {\n-            T element = queue.take();\n-            if (element.equals(tombstone)) {\n-                foundTombstone = true;\n-            } else {\n-                action.accept(element);\n-            }\n+        if (foundTombstone) return false;\n+        terminationGuard.check();\n+        T element = QueueUtil.take(queue, timeoutSeconds, () -> terminationGuard.check());\n+        if (element.equals(tombstone)) {\n+            foundTombstone = true;\n+            return false;\n+        } else {\n+            action.accept(element);\n             return true;\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "changed_code": [{"header": "diff --git a/src/main/java/apoc/util/QueueBasedSpliterator.java b/src/main/java/apoc/util/QueueBasedSpliterator.java\nindex 3a50e7c99..440378df3 100644\n--- a/src/main/java/apoc/util/QueueBasedSpliterator.java\n+++ b/src/main/java/apoc/util/QueueBasedSpliterator.java\n", "chunk": "@@ -14,27 +14,27 @@ public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n     private TerminationGuard terminationGuard;\n-    private boolean foundTombstone = false;\n+    private volatile boolean foundTombstone = false;\n+    private final int timeoutSeconds;\n \n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n+    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, int timeoutSeconds) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n+        this.timeoutSeconds = timeoutSeconds;\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard) || foundTombstone) return false;\n-        try {\n-            T element = queue.take();\n-            if (element.equals(tombstone)) {\n-                foundTombstone = true;\n-            } else {\n-                action.accept(element);\n-            }\n+        if (foundTombstone) return false;\n+        terminationGuard.check();\n+        T element = QueueUtil.take(queue, timeoutSeconds, () -> terminationGuard.check());\n+        if (element.equals(tombstone)) {\n+            foundTombstone = true;\n+            return false;\n+        } else {\n+            action.accept(element);\n             return true;\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n         }\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "message": "Merge commit", "committedDate": null}, {"oid": "53528dd19ba4a8dea0a15cdb8e8b88115462311f", "committedDate": "2020-04-15 09:29:56 +0100", "message": "fix deadlock situation in concurrent executions (#1462)"}, {"oid": "8ca01d3a1113ef32969148b8a079303e11aa52b1", "committedDate": "2020-06-01 11:27:25 +0100", "message": "splitting repo into core and full"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2Njk1NQ==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866955", "body": "should this really return true if the tombstone was found?", "bodyText": "should this really return true if the tombstone was found?", "bodyHTML": "<p dir=\"auto\">should this really return true if the tombstone was found?</p>", "author": "jexp", "createdAt": "2020-03-29T23:01:40Z", "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "diffHunk": "@@ -6,49 +6,35 @@\n import java.util.concurrent.BlockingQueue;\n import java.util.function.Consumer;\n \n-import static java.util.concurrent.TimeUnit.SECONDS;\n-\n /**\n  * @author mh\n  * @since 06.12.17\n  */\n public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n-    private T entry;\n     private TerminationGuard terminationGuard;\n-    private final long timeout;\n+    private boolean foundTombstone = false;\n \n     public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n-        this(queue, tombstone, terminationGuard, 10);\n-    }\n-\n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, long timeout) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n-        this.timeout = timeout;\n-        entry = poll();\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard)) return false;\n-        if (isEnd()) return false;\n-        action.accept(entry);\n-        entry = poll();\n-        return !isEnd();\n-    }\n-\n-    private boolean isEnd() {\n-        return entry == null || entry == tombstone;\n-    }\n-\n-    private T poll() {\n+        if (Util.transactionIsTerminated(terminationGuard) || foundTombstone) return false;\n         try {\n-            return queue.poll(timeout, SECONDS);\n+            T element = queue.take();\n+            if (element.equals(tombstone)) {\n+                foundTombstone = true;\n+            } else {\n+                action.accept(element);\n+            }\n+            return true;", "originalCommit": "0a16124b759d7511b6608ca769de5fb5ed764275", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "de07980676970f5c00cc04ed5cc0670cd0a793ac", "changed_code": [{"header": "diff --git a/src/main/java/apoc/util/QueueBasedSpliterator.java b/src/main/java/apoc/util/QueueBasedSpliterator.java\nindex 3a50e7c99..440378df3 100644\n--- a/src/main/java/apoc/util/QueueBasedSpliterator.java\n+++ b/src/main/java/apoc/util/QueueBasedSpliterator.java\n", "chunk": "@@ -14,27 +14,27 @@ public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n     private TerminationGuard terminationGuard;\n-    private boolean foundTombstone = false;\n+    private volatile boolean foundTombstone = false;\n+    private final int timeoutSeconds;\n \n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n+    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, int timeoutSeconds) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n+        this.timeoutSeconds = timeoutSeconds;\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard) || foundTombstone) return false;\n-        try {\n-            T element = queue.take();\n-            if (element.equals(tombstone)) {\n-                foundTombstone = true;\n-            } else {\n-                action.accept(element);\n-            }\n+        if (foundTombstone) return false;\n+        terminationGuard.check();\n+        T element = QueueUtil.take(queue, timeoutSeconds, () -> terminationGuard.check());\n+        if (element.equals(tombstone)) {\n+            foundTombstone = true;\n+            return false;\n+        } else {\n+            action.accept(element);\n             return true;\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "changed_code": [{"header": "diff --git a/src/main/java/apoc/util/QueueBasedSpliterator.java b/src/main/java/apoc/util/QueueBasedSpliterator.java\nindex 3a50e7c99..440378df3 100644\n--- a/src/main/java/apoc/util/QueueBasedSpliterator.java\n+++ b/src/main/java/apoc/util/QueueBasedSpliterator.java\n", "chunk": "@@ -14,27 +14,27 @@ public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n     private TerminationGuard terminationGuard;\n-    private boolean foundTombstone = false;\n+    private volatile boolean foundTombstone = false;\n+    private final int timeoutSeconds;\n \n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n+    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, int timeoutSeconds) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n+        this.timeoutSeconds = timeoutSeconds;\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard) || foundTombstone) return false;\n-        try {\n-            T element = queue.take();\n-            if (element.equals(tombstone)) {\n-                foundTombstone = true;\n-            } else {\n-                action.accept(element);\n-            }\n+        if (foundTombstone) return false;\n+        terminationGuard.check();\n+        T element = QueueUtil.take(queue, timeoutSeconds, () -> terminationGuard.check());\n+        if (element.equals(tombstone)) {\n+            foundTombstone = true;\n+            return false;\n+        } else {\n+            action.accept(element);\n             return true;\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n         }\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "message": "Merge commit", "committedDate": null}, {"oid": "53528dd19ba4a8dea0a15cdb8e8b88115462311f", "committedDate": "2020-04-15 09:29:56 +0100", "message": "fix deadlock situation in concurrent executions (#1462)"}, {"oid": "8ca01d3a1113ef32969148b8a079303e11aa52b1", "committedDate": "2020-06-01 11:27:25 +0100", "message": "splitting repo into core and full"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NzEzMg==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399867132", "body": "it was null when the timeout hit, which now would block forever causing downstream processing being starved b/c the queue is no longer filled upstream ... (e.g. no threads available or other reasons)", "bodyText": "it was null when the timeout hit, which now would block forever causing downstream processing being starved b/c the queue is no longer filled upstream ... (e.g. no threads available or other reasons)", "bodyHTML": "<p dir=\"auto\">it was null when the timeout hit, which now would block forever causing downstream processing being starved b/c the queue is no longer filled upstream ... (e.g. no threads available or other reasons)</p>", "author": "jexp", "createdAt": "2020-03-29T23:03:23Z", "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "diffHunk": "@@ -6,49 +6,35 @@\n import java.util.concurrent.BlockingQueue;\n import java.util.function.Consumer;\n \n-import static java.util.concurrent.TimeUnit.SECONDS;\n-\n /**\n  * @author mh\n  * @since 06.12.17\n  */\n public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n-    private T entry;\n     private TerminationGuard terminationGuard;\n-    private final long timeout;\n+    private boolean foundTombstone = false;\n \n     public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n-        this(queue, tombstone, terminationGuard, 10);\n-    }\n-\n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, long timeout) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n-        this.timeout = timeout;\n-        entry = poll();\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard)) return false;\n-        if (isEnd()) return false;\n-        action.accept(entry);\n-        entry = poll();\n-        return !isEnd();\n-    }\n-\n-    private boolean isEnd() {\n-        return entry == null || entry == tombstone;", "originalCommit": "0a16124b759d7511b6608ca769de5fb5ed764275", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "de07980676970f5c00cc04ed5cc0670cd0a793ac", "changed_code": [{"header": "diff --git a/src/main/java/apoc/util/QueueBasedSpliterator.java b/src/main/java/apoc/util/QueueBasedSpliterator.java\nindex 3a50e7c99..440378df3 100644\n--- a/src/main/java/apoc/util/QueueBasedSpliterator.java\n+++ b/src/main/java/apoc/util/QueueBasedSpliterator.java\n", "chunk": "@@ -14,27 +14,27 @@ public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n     private TerminationGuard terminationGuard;\n-    private boolean foundTombstone = false;\n+    private volatile boolean foundTombstone = false;\n+    private final int timeoutSeconds;\n \n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n+    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, int timeoutSeconds) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n+        this.timeoutSeconds = timeoutSeconds;\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard) || foundTombstone) return false;\n-        try {\n-            T element = queue.take();\n-            if (element.equals(tombstone)) {\n-                foundTombstone = true;\n-            } else {\n-                action.accept(element);\n-            }\n+        if (foundTombstone) return false;\n+        terminationGuard.check();\n+        T element = QueueUtil.take(queue, timeoutSeconds, () -> terminationGuard.check());\n+        if (element.equals(tombstone)) {\n+            foundTombstone = true;\n+            return false;\n+        } else {\n+            action.accept(element);\n             return true;\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "changed_code": [{"header": "diff --git a/src/main/java/apoc/util/QueueBasedSpliterator.java b/src/main/java/apoc/util/QueueBasedSpliterator.java\nindex 3a50e7c99..440378df3 100644\n--- a/src/main/java/apoc/util/QueueBasedSpliterator.java\n+++ b/src/main/java/apoc/util/QueueBasedSpliterator.java\n", "chunk": "@@ -14,27 +14,27 @@ public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n     private TerminationGuard terminationGuard;\n-    private boolean foundTombstone = false;\n+    private volatile boolean foundTombstone = false;\n+    private final int timeoutSeconds;\n \n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n+    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, int timeoutSeconds) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n+        this.timeoutSeconds = timeoutSeconds;\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard) || foundTombstone) return false;\n-        try {\n-            T element = queue.take();\n-            if (element.equals(tombstone)) {\n-                foundTombstone = true;\n-            } else {\n-                action.accept(element);\n-            }\n+        if (foundTombstone) return false;\n+        terminationGuard.check();\n+        T element = QueueUtil.take(queue, timeoutSeconds, () -> terminationGuard.check());\n+        if (element.equals(tombstone)) {\n+            foundTombstone = true;\n+            return false;\n+        } else {\n+            action.accept(element);\n             return true;\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n         }\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "message": "Merge commit", "committedDate": null}, {"oid": "53528dd19ba4a8dea0a15cdb8e8b88115462311f", "committedDate": "2020-04-15 09:29:56 +0100", "message": "fix deadlock situation in concurrent executions (#1462)"}, {"oid": "8ca01d3a1113ef32969148b8a079303e11aa52b1", "committedDate": "2020-06-01 11:27:25 +0100", "message": "splitting repo into core and full"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NzQxNw==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399867417", "body": "does this have any data to run on?", "bodyText": "does this have any data to run on?", "bodyHTML": "<p dir=\"auto\">does this have any data to run on?</p>", "author": "jexp", "createdAt": "2020-03-29T23:05:36Z", "path": "src/test/java/apoc/cypher/CypherTest.java", "diffHunk": "@@ -463,4 +478,20 @@ public void testRunFileWithEmptyFile() throws Exception {\n         testResult(db, \"CALL apoc.cypher.runFile('src/test/resources/empty.cypher')\",\n                 r -> assertFalse(\"should be empty\", r.hasNext()));\n     }\n+\n+    @Test\n+    public void lengthyRunManyShouldTerminate() {\n+        String repetetiveStatement= \"CALL apoc.cypher.runFile(\\\"src/test/resources/enrollment-incremental.cypher\\\",{parameters: {SubID: \\\"218598584\\\", Account_Number: \\\"\\\", AccountType: \\\"\\\",Source: \\\"VerizonMASnapshot\\\", MDN: \\\"\\\", Offering: \\\"\\\", Enroll_Date: \\\"\\\", Product_SKU: \\\"\\\", Device_Model: \\\"\\\", Device_Make: \\\"\\\", First_Name: \\\"\\\", Last_Name: \\\"\\\",Email1: \\\"\\\", Email2: \\\"\\\", Email3: \\\"\\\", Postal_CD: \\\"\\\", City: \\\"\\\", State: \\\"\\\", BillingStatus: \\\"\\\", ActionType: \\\"Drop\\\", Text_Date : \\\"2020-03-11\\\"}}) yield result return sum(result.total) as total;\\n\" +", "originalCommit": "0a16124b759d7511b6608ca769de5fb5ed764275", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "fc9e0c6c8b7b025efd26b6c53edbd3ab859515d0", "changed_code": [{"header": "diff --git a/src/test/java/apoc/cypher/CypherTest.java b/src/test/java/apoc/cypher/CypherTest.java\nindex 29f30c7f4..49dba0447 100644\n--- a/src/test/java/apoc/cypher/CypherTest.java\n+++ b/src/test/java/apoc/cypher/CypherTest.java\n", "chunk": "@@ -472,26 +452,4 @@ public class CypherTest {\n                     assertEquals(\"C\", ((Map) r.get(\"value\")).get(\"cName\"));\n                 });\n     }\n-\n-    @Test\n-    public void testRunFileWithEmptyFile() throws Exception {\n-        testResult(db, \"CALL apoc.cypher.runFile('src/test/resources/empty.cypher')\",\n-                r -> assertFalse(\"should be empty\", r.hasNext()));\n-    }\n-\n-    @Test\n-    public void lengthyRunManyShouldTerminate() {\n-        String repetetiveStatement= \"CALL apoc.cypher.runFile(\\\"src/test/resources/enrollment-incremental.cypher\\\",{parameters: {SubID: \\\"218598584\\\", Account_Number: \\\"\\\", AccountType: \\\"\\\",Source: \\\"VerizonMASnapshot\\\", MDN: \\\"\\\", Offering: \\\"\\\", Enroll_Date: \\\"\\\", Product_SKU: \\\"\\\", Device_Model: \\\"\\\", Device_Make: \\\"\\\", First_Name: \\\"\\\", Last_Name: \\\"\\\",Email1: \\\"\\\", Email2: \\\"\\\", Email3: \\\"\\\", Postal_CD: \\\"\\\", City: \\\"\\\", State: \\\"\\\", BillingStatus: \\\"\\\", ActionType: \\\"Drop\\\", Text_Date : \\\"2020-03-11\\\"}}) yield result return sum(result.total) as total;\\n\" +\n-                \"CALL apoc.cypher.runFile(\\\"src/test/resources/enrollment-incremental.cypher\\\",{parameters: {SubID: \\\"7898935\\\", Account_Number: \\\"\\\", AccountType: \\\"\\\",Source: \\\"VerizonNorthSnapshot\\\", MDN: \\\"\\\", Offering: \\\"\\\", Enroll_Date: \\\"\\\", Product_SKU: \\\"\\\", Device_Model: \\\"\\\", Device_Make: \\\"\\\", First_Name: \\\"\\\", Last_Name: \\\"\\\",Email1: \\\"\\\", Email2: \\\"\\\", Email3: \\\"\\\", Postal_CD: \\\"\\\", City: \\\"\\\", State: \\\"\\\", BillingStatus: \\\"\\\", ActionType: \\\"Drop\\\", Text_Date : \\\"2020-03-11\\\"}}) yield result return sum(result.total) as total;\\n\";\n-\n-        String cypher = String.format(\"CALL apoc.cypher.runMany('%s',{statistics:true,timeout:60}) yield result return sum(result.total) as total;\",\n-                String.join(\"\", Collections.nCopies(25, repetetiveStatement)));\n-\n-        testResult(db, cypher,\n-                result -> {\n-                    Map<String, Object> single = Iterators.single(result);\n-                    assertEquals(50l, single.get(\"total\"));\n-                });\n-\n-    }\n }\n", "next_change": {"commit": "eca1b25922079a56ac509d8521673908c34d87fe", "changed_code": [{"header": "diff --git a/src/test/java/apoc/cypher/CypherTest.java b/src/test/java/apoc/cypher/CypherTest.java\nindex 49dba0447..c25294023 100644\n--- a/src/test/java/apoc/cypher/CypherTest.java\n+++ b/src/test/java/apoc/cypher/CypherTest.java\n", "chunk": "@@ -452,4 +453,10 @@ public class CypherTest {\n                     assertEquals(\"C\", ((Map) r.get(\"value\")).get(\"cName\"));\n                 });\n     }\n+\n+    @Test\n+    public void testRunFileWithEmptyFile() throws Exception {\n+        testResult(db, \"CALL apoc.cypher.runFile('src/test/resources/empty.cypher')\",\n+                r -> assertFalse(\"should be empty\", r.hasNext()));\n+    }\n }\n", "next_change": {"commit": "c20a9b388b8a7e91b467d0848356e1a66c138ceb", "changed_code": [{"header": "diff --git a/src/test/java/apoc/cypher/CypherTest.java b/src/test/java/apoc/cypher/CypherTest.java\nindex c25294023..6417f0825 100644\n--- a/src/test/java/apoc/cypher/CypherTest.java\n+++ b/src/test/java/apoc/cypher/CypherTest.java\n", "chunk": "@@ -456,7 +456,7 @@ public class CypherTest {\n \n     @Test\n     public void testRunFileWithEmptyFile() throws Exception {\n-        testResult(db, \"CALL apoc.cypher.runFile('src/test/resources/empty.cypher')\",\n+        testResult(db, \"CALL apoc.cypher.runFile('empty.cypher')\",\n                 r -> assertFalse(\"should be empty\", r.hasNext()));\n     }\n }\n", "next_change": {"commit": "53528dd19ba4a8dea0a15cdb8e8b88115462311f", "changed_code": [{"header": "diff --git a/src/test/java/apoc/cypher/CypherTest.java b/src/test/java/apoc/cypher/CypherTest.java\nindex 6417f0825..6b16d5147 100644\n--- a/src/test/java/apoc/cypher/CypherTest.java\n+++ b/src/test/java/apoc/cypher/CypherTest.java\n", "chunk": "@@ -459,4 +469,20 @@ public class CypherTest {\n         testResult(db, \"CALL apoc.cypher.runFile('empty.cypher')\",\n                 r -> assertFalse(\"should be empty\", r.hasNext()));\n     }\n+\n+    @Test\n+    public void lengthyRunManyShouldTerminate() {\n+        String repetetiveStatement= \"CALL apoc.cypher.runFile(\\\"enrollment-incremental.cypher\\\",{parameters: {SubID: \\\"218598584\\\", Account_Number: \\\"\\\", AccountType: \\\"\\\",Source: \\\"VerizonMASnapshot\\\", MDN: \\\"\\\", Offering: \\\"\\\", Enroll_Date: \\\"\\\", Product_SKU: \\\"\\\", Device_Model: \\\"\\\", Device_Make: \\\"\\\", First_Name: \\\"\\\", Last_Name: \\\"\\\",Email1: \\\"\\\", Email2: \\\"\\\", Email3: \\\"\\\", Postal_CD: \\\"\\\", City: \\\"\\\", State: \\\"\\\", BillingStatus: \\\"\\\", ActionType: \\\"Drop\\\", Text_Date : \\\"2020-03-11\\\"}}) yield result return sum(result.total) as total;\\n\" +\n+                \"CALL apoc.cypher.runFile(\\\"enrollment-incremental.cypher\\\",{parameters: {SubID: \\\"7898935\\\", Account_Number: \\\"\\\", AccountType: \\\"\\\",Source: \\\"VerizonNorthSnapshot\\\", MDN: \\\"\\\", Offering: \\\"\\\", Enroll_Date: \\\"\\\", Product_SKU: \\\"\\\", Device_Model: \\\"\\\", Device_Make: \\\"\\\", First_Name: \\\"\\\", Last_Name: \\\"\\\",Email1: \\\"\\\", Email2: \\\"\\\", Email3: \\\"\\\", Postal_CD: \\\"\\\", City: \\\"\\\", State: \\\"\\\", BillingStatus: \\\"\\\", ActionType: \\\"Drop\\\", Text_Date : \\\"2020-03-11\\\"}}) yield result return sum(result.total) as total;\\n\";\n+\n+        String cypher = String.format(\"CALL apoc.cypher.runMany('%s',{statistics:true,timeout:60}) yield result return sum(result.total) as total;\",\n+                String.join(\"\", Collections.nCopies(25, repetetiveStatement)));\n+\n+        testResult(db, cypher,\n+                result -> {\n+                    Map<String, Object> single = Iterators.single(result);\n+                    assertEquals(50l, single.get(\"total\"));\n+                });\n+\n+    }\n }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "message": "Merge commit", "committedDate": null}, {"oid": "fc9e0c6c8b7b025efd26b6c53edbd3ab859515d0", "committedDate": "2019-07-29 22:25:55 +0200", "message": "migrating to Neo4j 4.0: test classes do compile without error"}, {"oid": "8e56e11d5cc0a10b9f60ea2894ac6c54b2c37c3b", "committedDate": "2019-08-02 14:53:49 +0200", "message": "migrating to Neo4j 4.0: fixing tests"}, {"oid": "a415281ece1c2edbfdac56105912f4ba718a4ee0", "committedDate": "2019-08-10 11:32:15 +0200", "message": "migrating to Neo4j 4.0: fix tests"}, {"oid": "5b07b814c4cc8ba34b5dfae6876427ce2c19c764", "committedDate": "2019-10-02 19:59:58 +0200", "message": "migrating test code to latest upstream core API changes"}, {"oid": "4a8685c3b01af294190030a885dfd0fd99c7e4ce", "committedDate": "2019-10-03 20:30:27 +0200", "message": "upstream API changes: gds.schema() -> tx.schema()"}, {"oid": "b23fad24486f98432da29872fb0a7f081289b4a3", "committedDate": "2019-10-03 21:57:37 +0200", "message": "cypher params: use $param instead of {param}"}, {"oid": "56f59cdb43d889d513c15321004d2dfe5cdd15c1", "committedDate": "2019-10-03 22:31:35 +0200", "message": "use absolute paths for csv root"}, {"oid": "7360548a7137decc152923b151243abad4e69b41", "committedDate": "2019-10-04 19:04:51 +0200", "message": "cypher params: use $param instead of {param}"}, {"oid": "eca1b25922079a56ac509d8521673908c34d87fe", "committedDate": "2019-11-19 12:04:15 +0100", "message": "fixes #1262: apoc.cypher.runFile fails when there is a empty transaction (#1349)"}, {"oid": "c20a9b388b8a7e91b467d0848356e1a66c138ceb", "committedDate": "2019-11-21 15:49:28 +0000", "message": "fix relative path of file"}, {"oid": "53528dd19ba4a8dea0a15cdb8e8b88115462311f", "committedDate": "2020-04-15 09:29:56 +0100", "message": "fix deadlock situation in concurrent executions (#1462)"}, {"oid": "8ca01d3a1113ef32969148b8a079303e11aa52b1", "committedDate": "2020-06-01 11:27:25 +0100", "message": "splitting repo into core and full"}]}, {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/de07980676970f5c00cc04ed5cc0670cd0a793ac", "message": "using poll/offer instead of put/take for queues", "committedDate": "2020-03-30T18:56:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNjE4OA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404806188", "body": "we can compute  `started + timeoutSeconds * 1000` here (in both methods)", "bodyText": "we can compute  started + timeoutSeconds * 1000 here (in both methods)", "bodyHTML": "<p dir=\"auto\">we can compute  <code>started + timeoutSeconds * 1000</code> here (in both methods)</p>", "author": "jexp", "createdAt": "2020-04-07T13:25:33Z", "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();", "originalCommit": "de07980676970f5c00cc04ed5cc0670cd0a793ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "98af0330559d6668f877756fa06e5941d3a3bbd3", "changed_code": [{"header": "diff --git a/src/main/java/apoc/util/QueueUtil.java b/src/main/java/apoc/util/QueueUtil.java\nindex d36f06341..d4b3ffbfc 100644\n--- a/src/main/java/apoc/util/QueueUtil.java\n+++ b/src/main/java/apoc/util/QueueUtil.java\n", "chunk": "@@ -24,20 +24,22 @@ public class QueueUtil {\n      * @param <T>\n      */\n     public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n-        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n-            long started = System.currentTimeMillis();\n-            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+        try {\n+            long timeoutTimestamp = System.currentTimeMillis() + timeoutSeconds * 1000;\n+            while (true) {\n+                if (System.currentTimeMillis() > timeoutTimestamp) break;\n                 boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n                 if (success) {\n-                    return null;\n+                    return;\n                 }\n                 checkDuringOffering.run();\n             }\n             if (failWithExecption) {\n                 throw new RuntimeException(\"Error queuing item before timeout of \" + timeoutSeconds + \" seconds\");\n             }\n-            return null;\n-        });\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n     }\n \n     /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "changed_code": [{"header": "diff --git a/src/main/java/apoc/util/QueueUtil.java b/src/main/java/apoc/util/QueueUtil.java\nindex d36f06341..d4b3ffbfc 100644\n--- a/src/main/java/apoc/util/QueueUtil.java\n+++ b/src/main/java/apoc/util/QueueUtil.java\n", "chunk": "@@ -24,20 +24,22 @@ public class QueueUtil {\n      * @param <T>\n      */\n     public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n-        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n-            long started = System.currentTimeMillis();\n-            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+        try {\n+            long timeoutTimestamp = System.currentTimeMillis() + timeoutSeconds * 1000;\n+            while (true) {\n+                if (System.currentTimeMillis() > timeoutTimestamp) break;\n                 boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n                 if (success) {\n-                    return null;\n+                    return;\n                 }\n                 checkDuringOffering.run();\n             }\n             if (failWithExecption) {\n                 throw new RuntimeException(\"Error queuing item before timeout of \" + timeoutSeconds + \" seconds\");\n             }\n-            return null;\n-        });\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n     }\n \n     /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "message": "Merge commit", "committedDate": null}, {"oid": "53528dd19ba4a8dea0a15cdb8e8b88115462311f", "committedDate": "2020-04-15 09:29:56 +0100", "message": "fix deadlock situation in concurrent executions (#1462)"}, {"oid": "8ca01d3a1113ef32969148b8a079303e11aa52b1", "committedDate": "2020-06-01 11:27:25 +0100", "message": "splitting repo into core and full"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNjUzNA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404806534", "body": "do we have to return something from this method? or can it be just void?", "bodyText": "do we have to return something from this method? or can it be just void?", "bodyHTML": "<p dir=\"auto\">do we have to return something from this method? or can it be just void?</p>", "author": "jexp", "createdAt": "2020-04-07T13:26:00Z", "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n+                if (success) {\n+                    return null;", "originalCommit": "de07980676970f5c00cc04ed5cc0670cd0a793ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4MTExMA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r405081110", "bodyText": "BlockingQueue.put doesn't return anything, therefore I choose void for the method signature. Since withHandlingInterrupted is using a generic return type, I have to return something - null in this case.", "author": "sarmbruster", "createdAt": "2020-04-07T20:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNjUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NDgxMA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r405084810", "bodyText": "I'm inlining that indirection anyway, see comment below.", "author": "sarmbruster", "createdAt": "2020-04-07T20:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNjUzNA=="}], "type": "inlineReview", "revised_code": {"commit": "98af0330559d6668f877756fa06e5941d3a3bbd3", "changed_code": [{"header": "diff --git a/src/main/java/apoc/util/QueueUtil.java b/src/main/java/apoc/util/QueueUtil.java\nindex d36f06341..d4b3ffbfc 100644\n--- a/src/main/java/apoc/util/QueueUtil.java\n+++ b/src/main/java/apoc/util/QueueUtil.java\n", "chunk": "@@ -24,20 +24,22 @@ public class QueueUtil {\n      * @param <T>\n      */\n     public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n-        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n-            long started = System.currentTimeMillis();\n-            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+        try {\n+            long timeoutTimestamp = System.currentTimeMillis() + timeoutSeconds * 1000;\n+            while (true) {\n+                if (System.currentTimeMillis() > timeoutTimestamp) break;\n                 boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n                 if (success) {\n-                    return null;\n+                    return;\n                 }\n                 checkDuringOffering.run();\n             }\n             if (failWithExecption) {\n                 throw new RuntimeException(\"Error queuing item before timeout of \" + timeoutSeconds + \" seconds\");\n             }\n-            return null;\n-        });\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n     }\n \n     /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "changed_code": [{"header": "diff --git a/src/main/java/apoc/util/QueueUtil.java b/src/main/java/apoc/util/QueueUtil.java\nindex d36f06341..d4b3ffbfc 100644\n--- a/src/main/java/apoc/util/QueueUtil.java\n+++ b/src/main/java/apoc/util/QueueUtil.java\n", "chunk": "@@ -24,20 +24,22 @@ public class QueueUtil {\n      * @param <T>\n      */\n     public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n-        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n-            long started = System.currentTimeMillis();\n-            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+        try {\n+            long timeoutTimestamp = System.currentTimeMillis() + timeoutSeconds * 1000;\n+            while (true) {\n+                if (System.currentTimeMillis() > timeoutTimestamp) break;\n                 boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n                 if (success) {\n-                    return null;\n+                    return;\n                 }\n                 checkDuringOffering.run();\n             }\n             if (failWithExecption) {\n                 throw new RuntimeException(\"Error queuing item before timeout of \" + timeoutSeconds + \" seconds\");\n             }\n-            return null;\n-        });\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n     }\n \n     /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "message": "Merge commit", "committedDate": null}, {"oid": "53528dd19ba4a8dea0a15cdb8e8b88115462311f", "committedDate": "2020-04-15 09:29:56 +0100", "message": "fix deadlock situation in concurrent executions (#1462)"}, {"oid": "8ca01d3a1113ef32969148b8a079303e11aa52b1", "committedDate": "2020-06-01 11:27:25 +0100", "message": "splitting repo into core and full"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNzIzMg==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404807232", "body": "not sure it's worth the indirection.\r\n\r\nwhat about that Thread.currentThread().interrrupt() \r\n\r\nhandling? I always forget which one is right :)", "bodyText": "not sure it's worth the indirection.\nwhat about that Thread.currentThread().interrrupt()\nhandling? I always forget which one is right :)", "bodyHTML": "<p dir=\"auto\">not sure it's worth the indirection.</p>\n<p dir=\"auto\">what about that Thread.currentThread().interrrupt()</p>\n<p dir=\"auto\">handling? I always forget which one is right :)</p>", "author": "jexp", "createdAt": "2020-04-07T13:26:58Z", "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n+                if (success) {\n+                    return null;\n+                }\n+                checkDuringOffering.run();\n+            }\n+            if (failWithExecption) {\n+                throw new RuntimeException(\"Error queuing item before timeout of \" + timeoutSeconds + \" seconds\");\n+            }\n+            return null;\n+        });\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#take}\n+     * @param queue\n+     * @param timeoutSeconds\n+     * @param checkDuringPolling a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     * @return\n+     */\n+    public static <T> T take(BlockingQueue<T> queue, long timeoutSeconds, Runnable checkDuringPolling) {\n+        return withHandlingInterrupted(\"Queue poll interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                T polled = queue.poll(WAIT, WAIT_UNIT);\n+                if (polled != null) {\n+                    return polled;\n+                }\n+                checkDuringPolling.run();\n+            }\n+            throw new RuntimeException(\"Error polling, timeout of \" + timeoutSeconds + \" seconds reached.\");\n+        });\n+    }\n+\n+    public static <T> T withHandlingInterrupted(String msg, ThrowingSupplier<T, InterruptedException> consumer) {", "originalCommit": "de07980676970f5c00cc04ed5cc0670cd0a793ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NTMwOA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r405085308", "bodyText": "Gonna remove the indirection. I guess Thread.currentThread.interrupt() is not good here since I don't know what to return for take() in this case. So bubbling up the exception sounds more reasonable to me.", "author": "sarmbruster", "createdAt": "2020-04-07T20:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNzIzMg=="}], "type": "inlineReview", "revised_code": {"commit": "98af0330559d6668f877756fa06e5941d3a3bbd3", "changed_code": [{"header": "diff --git a/src/main/java/apoc/util/QueueUtil.java b/src/main/java/apoc/util/QueueUtil.java\nindex d36f06341..d4b3ffbfc 100644\n--- a/src/main/java/apoc/util/QueueUtil.java\n+++ b/src/main/java/apoc/util/QueueUtil.java\n", "chunk": "@@ -59,14 +61,8 @@ public class QueueUtil {\n                 checkDuringPolling.run();\n             }\n             throw new RuntimeException(\"Error polling, timeout of \" + timeoutSeconds + \" seconds reached.\");\n-        });\n-    }\n-\n-    public static <T> T withHandlingInterrupted(String msg, ThrowingSupplier<T, InterruptedException> consumer) {\n-        try {\n-            return consumer.get();\n         } catch (InterruptedException e) {\n-            throw new RuntimeException(msg, e);\n+            throw new RuntimeException(e);\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "changed_code": [{"header": "diff --git a/src/main/java/apoc/util/QueueUtil.java b/src/main/java/apoc/util/QueueUtil.java\nindex d36f06341..d4b3ffbfc 100644\n--- a/src/main/java/apoc/util/QueueUtil.java\n+++ b/src/main/java/apoc/util/QueueUtil.java\n", "chunk": "@@ -59,14 +61,8 @@ public class QueueUtil {\n                 checkDuringPolling.run();\n             }\n             throw new RuntimeException(\"Error polling, timeout of \" + timeoutSeconds + \" seconds reached.\");\n-        });\n-    }\n-\n-    public static <T> T withHandlingInterrupted(String msg, ThrowingSupplier<T, InterruptedException> consumer) {\n-        try {\n-            return consumer.get();\n         } catch (InterruptedException e) {\n-            throw new RuntimeException(msg, e);\n+            throw new RuntimeException(e);\n         }\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0", "message": "Merge commit", "committedDate": null}, {"oid": "53528dd19ba4a8dea0a15cdb8e8b88115462311f", "committedDate": "2020-04-15 09:29:56 +0100", "message": "fix deadlock situation in concurrent executions (#1462)"}, {"oid": "8ca01d3a1113ef32969148b8a079303e11aa52b1", "committedDate": "2020-06-01 11:27:25 +0100", "message": "splitting repo into core and full"}]}, {"oid": "98af0330559d6668f877756fa06e5941d3a3bbd3", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/98af0330559d6668f877756fa06e5941d3a3bbd3", "message": "code review request", "committedDate": "2020-04-07T20:20:23Z", "type": "commit"}]}