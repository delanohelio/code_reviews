{"pr_number": 9695, "pr_title": "KAFKA-10500: Remove thread", "pr_author": "wcarlson5", "pr_createdAt": "2020-12-04T20:08:09Z", "pr_url": "https://github.com/apache/kafka/pull/9695", "timeline": [{"oid": "2eb05bc3ff6aedc326cc61f57e138b6cee869509", "url": "https://github.com/apache/kafka/commit/2eb05bc3ff6aedc326cc61f57e138b6cee869509", "message": "init commit", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "c5c74960741998bd4867eaaecce4fff77716a31a", "url": "https://github.com/apache/kafka/commit/c5c74960741998bd4867eaaecce4fff77716a31a", "message": "fix wait", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "b22a31b4ff70b9e5e9ccb2b0673106499c648ffd", "url": "https://github.com/apache/kafka/commit/b22a31b4ff70b9e5e9ccb2b0673106499c648ffd", "message": "fix wait + add name tests", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "9f9d9e94fbba6ac2b022e9d7e1670cfd3d3db708", "url": "https://github.com/apache/kafka/commit/9f9d9e94fbba6ac2b022e9d7e1670cfd3d3db708", "message": "remove extra lines", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "27a9361d35a7bbe0a532607e4ef5f7a7d1eb9f06", "url": "https://github.com/apache/kafka/commit/27a9361d35a7bbe0a532607e4ef5f7a7d1eb9f06", "message": "javadoc fixes", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "d0c589c5b7bc3431d0611dd1a05840003d01c2ca", "url": "https://github.com/apache/kafka/commit/d0c589c5b7bc3431d0611dd1a05840003d01c2ca", "message": "respond to Sophie's comments", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "68b9da5f45dc46d93d5646417961229f5a5d976d", "url": "https://github.com/apache/kafka/commit/68b9da5f45dc46d93d5646417961229f5a5d976d", "message": "Bruno's comments", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "9eaf17d325e4428ba70e39ebe96be75b0724b46d", "url": "https://github.com/apache/kafka/commit/9eaf17d325e4428ba70e39ebe96be75b0724b46d", "message": "cleanup", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "1a7e48b66770a8a506a3a2e7c45a3e58aa5357ac", "url": "https://github.com/apache/kafka/commit/1a7e48b66770a8a506a3a2e7c45a3e58aa5357ac", "message": "cleanup", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "181f25835076b897aa13a7626c0d1590b7fd6043", "url": "https://github.com/apache/kafka/commit/181f25835076b897aa13a7626c0d1590b7fd6043", "message": "address comments", "committedDate": "2021-01-04T22:04:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553002043", "body": "I know Bruno brought this up already and maybe I just missed the resolution in the previous comments, but: should we allow a StreamThread to remove itself? Originally I was thinking \"no\" but I was just thinking about what be the expected behavior from this method when called from a StreamThread, and I actually think we should consider ONLY removing the calling thread.\r\nI get the sense that users will interpret `removeStreamThread()` when called from a Thread as essentially saying \"shutdown this thread\", not \"remove some random thread\". WDYT?", "bodyText": "I know Bruno brought this up already and maybe I just missed the resolution in the previous comments, but: should we allow a StreamThread to remove itself? Originally I was thinking \"no\" but I was just thinking about what be the expected behavior from this method when called from a StreamThread, and I actually think we should consider ONLY removing the calling thread.\nI get the sense that users will interpret removeStreamThread() when called from a Thread as essentially saying \"shutdown this thread\", not \"remove some random thread\". WDYT?", "bodyHTML": "<p dir=\"auto\">I know Bruno brought this up already and maybe I just missed the resolution in the previous comments, but: should we allow a StreamThread to remove itself? Originally I was thinking \"no\" but I was just thinking about what be the expected behavior from this method when called from a StreamThread, and I actually think we should consider ONLY removing the calling thread.<br>\nI get the sense that users will interpret <code>removeStreamThread()</code> when called from a Thread as essentially saying \"shutdown this thread\", not \"remove some random thread\". WDYT?</p>", "author": "ableegoldman", "createdAt": "2021-01-06T22:44:36Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -947,24 +948,65 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            synchronized (changeThreadCount) {\n+                for (final StreamThread streamThread : threads) {\n+                    if (streamThread.isAlive()) {\n                         streamThread.shutdown();\n+                        if (!streamThread.getName().equals(Thread.currentThread().getName())) {", "originalCommit": "181f25835076b897aa13a7626c0d1590b7fd6043", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMzA1Mw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553003053", "bodyText": "I think we should assert one or the other at least, ie we only ever remove the current thread or we only ever remove a different thread. And document this clearly of course \ud83d\ude42", "author": "ableegoldman", "createdAt": "2021-01-06T22:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNDc5MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553004791", "bodyText": "We want to avoid removing the calling thread because the idea is that the call will block until thread is gone. This is best for the cache resizing too. However I do not like the idea of not letting a thread remove itself because, if we have one stream thread left not letting that thread remove it self (maybe leaving a global thread) this seems incomplete. If we need to make this more structured maybe we only remove itself if is the only thread running? that should make the cache and blocking issue less of a problem. How does that sound?", "author": "wcarlson5", "createdAt": "2021-01-06T22:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNTY4NQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553005685", "bodyText": "@ableegoldman I don't know about only letting it remove its self. Not only stream threads can call this.", "author": "wcarlson5", "createdAt": "2021-01-06T22:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNzkwNw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553007907", "bodyText": "Sorry, my suggestion was vaguely worded. I meant that we should only let a StreamThread remove itself, if we detect that removeThread has been called by a StreamThread (which should be possible). If it's called by something else, then yes we should just pick a random thread to remove. I think that addresses your concern in the first sentence of your reply, but let me know if I'm misinterpreting it.\n\nI do not like the idea of not letting a thread remove itself because, if we have one stream thread left not letting that thread remove it self (maybe leaving a global thread) this seems incomplete.\n\nThat's a good point. In that case I would advocate for only letting a StreamThread remove itself. Do you see any problems with that?", "author": "ableegoldman", "createdAt": "2021-01-06T23:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAxMTg3Mg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553011872", "bodyText": "well there is the issue of the cache resize. Which we wait until thread is dead before changing the cache size. We can not do that when a thread removes itself which makes it possible for OOM. (#9695 (comment)) so it think it would be best to avoid removing itself if possible. unless it is the last thread", "author": "wcarlson5", "createdAt": "2021-01-06T23:14:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAxNjIxMQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553016211", "bodyText": "So we should try removing any other thread, if one exists, and only allow to remove the current thread if it's the last one? That sounds reasonable, let's go with that", "author": "ableegoldman", "createdAt": "2021-01-06T23:27:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAxNjgzOQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553016839", "bodyText": "cool I'll make those changes. Basically a thread can only remove itself if it is the only thread left", "author": "wcarlson5", "createdAt": "2021-01-06T23:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNTE4Ng==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553005186", "body": "Awesome, thanks for adding this test. One small suggestion would be to wait for the client to get back to RUNNING at the end, so we can verify that everything did go smoothly with the add/remove. I think this would be good to do in all of these tests, actually", "bodyText": "Awesome, thanks for adding this test. One small suggestion would be to wait for the client to get back to RUNNING at the end, so we can verify that everything did go smoothly with the add/remove. I think this would be good to do in all of these tests, actually", "bodyHTML": "<p dir=\"auto\">Awesome, thanks for adding this test. One small suggestion would be to wait for the client to get back to RUNNING at the end, so we can verify that everything did go smoothly with the add/remove. I think this would be good to do in all of these tests, actually</p>", "author": "ableegoldman", "createdAt": "2021-01-06T22:53:55Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -97,15 +99,132 @@ public void shouldAddStreamThread() throws Exception {\n \n             final Optional<String> name = kafkaStreams.addStreamThread();\n \n-            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            assertThat(name, not(Optional.empty()));\n             TestUtils.waitForCondition(\n                 () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n                         .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n                 \"Wait for the thread to be added\"\n             );\n             assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n-            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n-            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+            assertThat(\n+                kafkaStreams\n+                    .localThreadsMetadata()\n+                    .stream()\n+                    .map(t -> t.threadName().split(\"-StreamThread-\")[1])\n+                    .sorted().toArray(),\n+                equalTo(new String[] {\"1\", \"2\", \"3\"})\n+            );\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.state() == KafkaStreams.State.RUNNING,\n+                \"Kafka Streams client did not reach state RUNNING\"\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.removeStreamThread().get().split(\"-\")[0], equalTo(appId));\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveThreads() throws InterruptedException {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            final CountDownLatch latch = new CountDownLatch(2);\n+            final Thread one = adjustCountHelperThread(kafkaStreams, 4, latch);\n+            final Thread two = adjustCountHelperThread(kafkaStreams, 6, latch);\n+            two.start();\n+            one.start();\n+            latch.await(30, TimeUnit.SECONDS);\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount));\n+        }", "originalCommit": "181f25835076b897aa13a7626c0d1590b7fd6043", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNTcxNw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553005717", "bodyText": "good idea", "author": "wcarlson5", "createdAt": "2021-01-06T22:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNTE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNjE5MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553006191", "body": "One more corner case we should add test coverage for is what happens when we get down to 0 threads. Two things to verify  that I can think of are: (1) that the client stays in RUNNING, and (2) that we can add more threads again after we've been idling with zero threads for a short while (and as always, that it goes into REBALANCING --> RUNNING after adding the threads)", "bodyText": "One more corner case we should add test coverage for is what happens when we get down to 0 threads. Two things to verify  that I can think of are: (1) that the client stays in RUNNING, and (2) that we can add more threads again after we've been idling with zero threads for a short while (and as always, that it goes into REBALANCING --> RUNNING after adding the threads)", "bodyHTML": "<p dir=\"auto\">One more corner case we should add test coverage for is what happens when we get down to 0 threads. Two things to verify  that I can think of are: (1) that the client stays in RUNNING, and (2) that we can add more threads again after we've been idling with zero threads for a short while (and as always, that it goes into REBALANCING --&gt; RUNNING after adding the threads)</p>", "author": "ableegoldman", "createdAt": "2021-01-06T22:56:55Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -97,15 +99,132 @@ public void shouldAddStreamThread() throws Exception {\n \n             final Optional<String> name = kafkaStreams.addStreamThread();\n \n-            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            assertThat(name, not(Optional.empty()));\n             TestUtils.waitForCondition(\n                 () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n                         .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n                 \"Wait for the thread to be added\"\n             );\n             assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n-            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n-            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+            assertThat(\n+                kafkaStreams\n+                    .localThreadsMetadata()\n+                    .stream()\n+                    .map(t -> t.threadName().split(\"-StreamThread-\")[1])\n+                    .sorted().toArray(),\n+                equalTo(new String[] {\"1\", \"2\", \"3\"})\n+            );\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.state() == KafkaStreams.State.RUNNING,\n+                \"Kafka Streams client did not reach state RUNNING\"\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {", "originalCommit": "181f25835076b897aa13a7626c0d1590b7fd6043", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNzc3NA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553007774", "bodyText": "Well right now it would not stay in running until https://github.com/apache/kafka/pull/9720/files gets merged. So we can in a follow up PR get that corner case tested.", "author": "wcarlson5", "createdAt": "2021-01-06T23:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNjE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwODkzMw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553008933", "bodyText": "Ah, right. Would it make sense to add this test in the above PR instead? Or something in the middle, you could add the test in this PR and just leave out (1) for now, then add that check in the other PR.", "author": "ableegoldman", "createdAt": "2021-01-06T23:05:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNjE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAxNDE0NQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553014145", "bodyText": "the above PR doesn't have the remove as its in this PR. bit of a circular dependency :)\nWe do test that the client stays in running after shutting down some threads. We can add a test to add threads after we shut them down. However I would like to test it with remove thread anyways so if this get merged first I will update the above PR", "author": "wcarlson5", "createdAt": "2021-01-06T23:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNjE5MQ=="}], "type": "inlineReview"}, {"oid": "8e85b199a73557d3e6dcf4f2c8d26cc0b3bb04ae", "url": "https://github.com/apache/kafka/commit/8e85b199a73557d3e6dcf4f2c8d26cc0b3bb04ae", "message": "added wait for running in tests", "committedDate": "2021-01-06T23:42:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyMzY3NQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553023675", "body": "I guess technically this might not work if we have only one live thread left, but other dead threads still in the list -- in that case we might skip over the live thread when we really should have removed it. I'm not sure how much of a problem this would really be, just wanted to point it out.", "bodyText": "I guess technically this might not work if we have only one live thread left, but other dead threads still in the list -- in that case we might skip over the live thread when we really should have removed it. I'm not sure how much of a problem this would really be, just wanted to point it out.", "bodyHTML": "<p dir=\"auto\">I guess technically this might not work if we have only one live thread left, but other dead threads still in the list -- in that case we might skip over the live thread when we really should have removed it. I'm not sure how much of a problem this would really be, just wanted to point it out.</p>", "author": "ableegoldman", "createdAt": "2021-01-06T23:54:06Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -992,7 +992,7 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n         if (isRunningOrRebalancing()) {\n             synchronized (changeThreadCount) {\n                 for (final StreamThread streamThread : threads) {\n-                    if (streamThread.isAlive()) {\n+                    if (streamThread.isAlive() && (!streamThread.getName().equals(Thread.currentThread().getName()) || threads.size() == 1)) {", "originalCommit": "8e85b199a73557d3e6dcf4f2c8d26cc0b3bb04ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA0MjgwNQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553042805", "bodyText": "We don't keep the dead threads in this list. When a thread dies we remove it form the list and updated the number of dead threads metric.", "author": "wcarlson5", "createdAt": "2021-01-07T00:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyMzY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA3ODU4MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553078581", "bodyText": "Then why check isAlive() here at all? (I'm not necessarily requesting changes here, just trying to understand)", "author": "ableegoldman", "createdAt": "2021-01-07T02:44:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyMzY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEzODA3Nw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r555138077", "bodyText": "there is a very small window between when thread dies with the old handler and when it is removed from the the list. So we have to check to make sure for now", "author": "wcarlson5", "createdAt": "2021-01-11T15:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyMzY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyNDQ0Mw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553024443", "body": "Ah, sorry I didn't think of this/mention it before, but I think we actually need to wait for a _transition_ to RUNNING, and not just for it to be in the state itself. It probably takes a little while after removing a thread for the rebalance to occur, so it's probably already in RUNNING. Pretty sure there's some other integration test util that watches for the REBALANCING -> RUNNING transition, though", "bodyText": "Ah, sorry I didn't think of this/mention it before, but I think we actually need to wait for a transition to RUNNING, and not just for it to be in the state itself. It probably takes a little while after removing a thread for the rebalance to occur, so it's probably already in RUNNING. Pretty sure there's some other integration test util that watches for the REBALANCING -> RUNNING transition, though", "bodyHTML": "<p dir=\"auto\">Ah, sorry I didn't think of this/mention it before, but I think we actually need to wait for a <em>transition</em> to RUNNING, and not just for it to be in the state itself. It probably takes a little while after removing a thread for the rebalance to occur, so it's probably already in RUNNING. Pretty sure there's some other integration test util that watches for the REBALANCING -&gt; RUNNING transition, though</p>", "author": "ableegoldman", "createdAt": "2021-01-06T23:56:52Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -128,6 +133,7 @@ public void shouldRemoveStreamThread() throws Exception {\n             final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n             assertThat(kafkaStreams.removeStreamThread().get().split(\"-\")[0], equalTo(appId));\n             assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+            waitForApplicationState(Collections.singletonList(kafkaStreams), KafkaStreams.State.RUNNING, DEFAULT_DURATION);", "originalCommit": "8e85b199a73557d3e6dcf4f2c8d26cc0b3bb04ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA0MzczMQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553043731", "bodyText": "ah okay that makes sense", "author": "wcarlson5", "createdAt": "2021-01-07T00:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyNDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA0NzMwOA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553047308", "bodyText": "I didn't see that util but this should work", "author": "wcarlson5", "createdAt": "2021-01-07T00:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyNDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA3OTc5MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553079791", "bodyText": "Cool, what you did below (waitForApplicationState on REBALANCING before RUNNING) looks good. But I think you missed doing that here -- in fact we should probably do a similar thing in all the tests in this class. Can you just give the file a final pass and make sure we verify the REBALANCING -> RUNNING transition in all of the tests?", "author": "ableegoldman", "createdAt": "2021-01-07T02:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyNDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU2MTM1Mw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553561353", "bodyText": "added", "author": "wcarlson5", "createdAt": "2021-01-07T20:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyNDQ0Mw=="}], "type": "inlineReview"}, {"oid": "306a139fd0670f6f5fff7c225fc87a9c1063a29b", "url": "https://github.com/apache/kafka/commit/306a139fd0670f6f5fff7c225fc87a9c1063a29b", "message": "ensure at least one rebalance occures", "committedDate": "2021-01-07T00:48:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4MDUxMg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553380512", "body": "nit: Could you please rename the `createStreamThread()` to `createAndAddStreamThread()`. It is a bit weird that we have `threads.remove()` in this method but no `threads.add()`. The renaming would make it clearer.", "bodyText": "nit: Could you please rename the createStreamThread() to createAndAddStreamThread(). It is a bit weird that we have threads.remove() in this method but no threads.add(). The renaming would make it clearer.", "bodyHTML": "<p dir=\"auto\">nit: Could you please rename the <code>createStreamThread()</code> to <code>createAndAddStreamThread()</code>. It is a bit weird that we have <code>threads.remove()</code> in this method but no <code>threads.add()</code>. The renaming would make it clearer.</p>", "author": "cadonna", "createdAt": "2021-01-07T14:59:28Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -947,24 +948,65 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);", "originalCommit": "306a139fd0670f6f5fff7c225fc87a9c1063a29b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4NDA0OQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553384049", "body": "nit: To deduplicate code, you could also remove these two lines, because they are the same as the last two lines of the method.\r\n\r\nnit: Could you change `Cannot add a stream thread in state \" + state()` to `Cannot add a stream thread when Kafka Streams client is in state \" + state()`, or similar. Currently, it is not completely clear if the state belongs to the stream thread or to the client.", "bodyText": "nit: To deduplicate code, you could also remove these two lines, because they are the same as the last two lines of the method.\nnit: Could you change Cannot add a stream thread in state \" + state() to Cannot add a stream thread when Kafka Streams client is in state \" + state(), or similar. Currently, it is not completely clear if the state belongs to the stream thread or to the client.", "bodyHTML": "<p dir=\"auto\">nit: To deduplicate code, you could also remove these two lines, because they are the same as the last two lines of the method.</p>\n<p dir=\"auto\">nit: Could you change <code>Cannot add a stream thread in state \" + state()</code> to <code>Cannot add a stream thread when Kafka Streams client is in state \" + state()</code>, or similar. Currently, it is not completely clear if the state belongs to the stream thread or to the client.</p>", "author": "cadonna", "createdAt": "2021-01-07T15:05:03Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -947,24 +948,65 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();", "originalCommit": "306a139fd0670f6f5fff7c225fc87a9c1063a29b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4NjI5Mw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553386293", "body": "See my nit comment above. ", "bodyText": "See my nit comment above.", "bodyHTML": "<p dir=\"auto\">See my nit comment above.</p>", "author": "cadonna", "createdAt": "2021-01-07T15:08:39Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -947,24 +948,65 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            synchronized (changeThreadCount) {\n+                for (final StreamThread streamThread : threads) {\n+                    if (streamThread.isAlive() && (!streamThread.getName().equals(Thread.currentThread().getName()) || threads.size() == 1)) {\n                         streamThread.shutdown();\n+                        if (!streamThread.getName().equals(Thread.currentThread().getName())) {\n+                            streamThread.waitOnThreadState(StreamThread.State.DEAD);\n+                        }\n                         threads.remove(streamThread);\n-                        resizeThreadCache(getCacheSizePerThread(threads.size()));\n-                        return Optional.empty();\n+                        final long cacheSizePerThread = getCacheSizePerThread(threads.size());\n+                        resizeThreadCache(cacheSizePerThread);\n+                        return Optional.of(streamThread.getName());\n                     }\n                 }\n             }\n+            log.warn(\"There are no threads eligible for removal\");\n+        } else {\n+            log.warn(\"Cannot remove a stream thread in state \" + state());", "originalCommit": "306a139fd0670f6f5fff7c225fc87a9c1063a29b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM5ODIwOQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553398209", "body": "Do we not need to synchronize this block on the `changeThreadCount` to at least guarantee that the state is correct when the method returns? Otherwise between the `if` and `threadMetadata.add(thread.threadMetadata())` the stream thread might transit to `DEAD`. ", "bodyText": "Do we not need to synchronize this block on the changeThreadCount to at least guarantee that the state is correct when the method returns? Otherwise between the if and threadMetadata.add(thread.threadMetadata()) the stream thread might transit to DEAD.", "bodyHTML": "<p dir=\"auto\">Do we not need to synchronize this block on the <code>changeThreadCount</code> to at least guarantee that the state is correct when the method returns? Otherwise between the <code>if</code> and <code>threadMetadata.add(thread.threadMetadata())</code> the stream thread might transit to <code>DEAD</code>.</p>", "author": "cadonna", "createdAt": "2021-01-07T15:27:33Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -1432,7 +1480,9 @@ public void cleanUp() {\n         validateIsRunningOrRebalancing();\n         final Set<ThreadMetadata> threadMetadata = new HashSet<>();\n         for (final StreamThread thread : threads) {\n-            threadMetadata.add(thread.threadMetadata());\n+            if (thread.state() != StreamThread.State.DEAD) {\n+                threadMetadata.add(thread.threadMetadata());\n+            }\n         }\n         return threadMetadata;", "originalCommit": "306a139fd0670f6f5fff7c225fc87a9c1063a29b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5MDEyNw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553490127", "bodyText": "changeThreadCount  would not take care of that we need to sync on the thread state", "author": "wcarlson5", "createdAt": "2021-01-07T17:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM5ODIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4ODE3MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553988171", "bodyText": "Ah yes, you are right! The stream thread might be replaced or just normally shut down which would not be synchronized on the changeThreadCount lock. However, we still do not guarantee that the state is correct when the method returns, because the state could change after the lock is released but before the method returns. At this point with or without lock it doesn't matter. Either we find something that synchronizes the whole method or we can also remove the synchronisation on the stream thread state. And also if we find something that synchronizes the whole method, I am not sure if this guarantee is worth the hassle. WDYT?", "author": "cadonna", "createdAt": "2021-01-08T14:51:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM5ODIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE0MTU2Mw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r555141563", "bodyText": "since changing the thread metadata uses a copy once its is added to the list as not dead it insures that we won't return a dead thread. And after we and it to the list we don't need to care until method is called again", "author": "wcarlson5", "createdAt": "2021-01-11T15:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM5ODIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQxMjY4MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553412681", "body": "nit: My IDE says that the cast is not needed.", "bodyText": "nit: My IDE says that the cast is not needed.", "bodyHTML": "<p dir=\"auto\">nit: My IDE says that the cast is not needed.</p>", "author": "cadonna", "createdAt": "2021-01-07T15:49:01Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -424,6 +424,7 @@ public void setUncaughtExceptionHandler(final StreamsUncaughtExceptionHandler st\n \n     private void defaultStreamsUncaughtExceptionHandler(final Throwable throwable) {\n         if (oldHandler) {\n+            threads.remove((StreamThread) Thread.currentThread());", "originalCommit": "306a139fd0670f6f5fff7c225fc87a9c1063a29b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dab30d6e6d79c49ee9274730788cb8ba0a668fbc", "url": "https://github.com/apache/kafka/commit/dab30d6e6d79c49ee9274730788cb8ba0a668fbc", "message": "comments", "committedDate": "2021-01-07T18:25:02Z", "type": "commit"}, {"oid": "d0ebbdbc44ffe154d5bff5ef93ec3d16748b380c", "url": "https://github.com/apache/kafka/commit/d0ebbdbc44ffe154d5bff5ef93ec3d16748b380c", "message": "comments", "committedDate": "2021-01-07T20:08:26Z", "type": "commit"}]}