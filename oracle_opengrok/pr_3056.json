{"pr_number": 3056, "pr_title": "Annotation API", "pr_author": "vladak", "pr_createdAt": "2020-02-26T14:28:24Z", "pr_url": "https://github.com/oracle/opengrok/pull/3056", "merge_commit": "c4679defee8271b273806331f6fe9da0a43e63df", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0Mjc3Mg==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r384542772", "body": "I don't see this being used in this changeset, was it a missing import?", "bodyText": "I don't see this being used in this changeset, was it a missing import?", "bodyHTML": "<p dir=\"auto\">I don't see this being used in this changeset, was it a missing import?</p>", "author": "tulinkry", "createdAt": "2020-02-26T14:53:09Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/history/Annotation.java", "diffHunk": "@@ -24,6 +24,7 @@\n \n package org.opengrok.indexer.history;\n \n+import com.fasterxml.jackson.annotation.JsonProperty;", "originalCommit": "c74f3d552da703e568a8b4ff8259f0220463c10d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU3NTg1NA==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r384575854", "bodyText": "yes", "author": "vladak", "createdAt": "2020-02-26T15:40:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0Mjc3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/Annotation.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/Annotation.java\nindex b8224bc2827..fc6c6309a8b 100644\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/Annotation.java\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/Annotation.java\n", "chunk": "@@ -24,12 +24,10 @@\n \n package org.opengrok.indexer.history;\n \n-import com.fasterxml.jackson.annotation.JsonProperty;\n import org.opengrok.indexer.logger.LoggerFactory;\n import org.opengrok.indexer.util.Color;\n import org.opengrok.indexer.util.LazilyInstantiate;\n import org.opengrok.indexer.util.RainbowColorGenerator;\n-import org.opengrok.indexer.web.Util;\n \n import java.io.IOException;\n import java.io.StringWriter;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NjEyNw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r384546127", "body": "Could you refactor this function to throw related exceptions and map these exceptions in exception mapper? It would make it obvious and without side effects. If I imported this function from a library I would not know what it does ... it takes a path and a response for some reason and returning a file.\r\n\r\nAlso a javadoc on public util method would not hurt.", "bodyText": "Could you refactor this function to throw related exceptions and map these exceptions in exception mapper? It would make it obvious and without side effects. If I imported this function from a library I would not know what it does ... it takes a path and a response for some reason and returning a file.\nAlso a javadoc on public util method would not hurt.", "bodyHTML": "<p dir=\"auto\">Could you refactor this function to throw related exceptions and map these exceptions in exception mapper? It would make it obvious and without side effects. If I imported this function from a library I would not know what it does ... it takes a path and a response for some reason and returning a file.</p>\n<p dir=\"auto\">Also a javadoc on public util method would not hurt.</p>", "author": "tulinkry", "createdAt": "2020-02-26T14:58:00Z", "path": "opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.web.util;\n+\n+import org.opengrok.indexer.configuration.RuntimeEnvironment;\n+\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.File;\n+import java.io.IOException;\n+\n+public class FileUtil {\n+\n+    private static final RuntimeEnvironment env = RuntimeEnvironment.getInstance();\n+\n+    public static File getFile(String path, HttpServletResponse response) throws IOException {", "originalCommit": "c74f3d552da703e568a8b4ff8259f0220463c10d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1MDk2MA==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r385750960", "bodyText": "Makes sense, thanks for pointing out the existence of exception mappers.", "author": "vladak", "createdAt": "2020-02-28T15:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NjEyNw=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java b/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\nindex fa5b7105a53..bd24ef00d9e 100644\n--- a/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\n+++ b/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\n", "chunk": "@@ -25,28 +25,31 @@ package org.opengrok.web.util;\n \n import org.opengrok.indexer.configuration.RuntimeEnvironment;\n \n-import javax.servlet.http.HttpServletResponse;\n import java.io.File;\n-import java.io.IOException;\n+import java.io.FileNotFoundException;\n \n public class FileUtil {\n \n     private static final RuntimeEnvironment env = RuntimeEnvironment.getInstance();\n \n-    public static File getFile(String path, HttpServletResponse response) throws IOException {\n+    // private to enforce static\n+    private FileUtil() {\n+    }\n+\n+    /**\n+     * @param path path relative to source root\n+     * @return file object corresponding to the file under source root\n+     * @throws FileNotFoundException if the file constructed from the {@code path} parameter and source root does not exist\n+     * @throws NoPathParameterException if the {@code path} parameter is null\n+     */\n+    public static File toFile(String path) throws NoPathParameterException, FileNotFoundException {\n         if (path == null) {\n-            if (response != null) {\n-                response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE, \"Missing path parameter\");\n-            }\n-            return null;\n+            throw new NoPathParameterException(\"Missing path parameter\");\n         }\n \n         File file = new File(env.getSourceRootFile(), path);\n         if (!file.isFile()) {\n-            if (response != null) {\n-                response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found\");\n-            }\n-            return null;\n+            throw new FileNotFoundException(\"File \" + file.toString() + \"not found\");\n         }\n \n         return file;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4MTY1Ng==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r384881656", "body": "No big problem here but some food for thought:\r\n\r\n* `Executor.exec()` and `Executor.exec(boolean)` actually spool the entire output of a program into memory. Probably that's not a burdensome amount with this removal of `--max-count`, given this is a `rev-list` of a single file.\r\n* When the spooled bytes are read later at line 402, they are read with the default Java charset, which is locale dependent on the OS installation. For hashes of a `rev-list`, that is perhaps always OK \u2014 but I'm just remarking since elsewhere in `GitRepository`, specific effort is made to use a correct charset (see `newLogReader()`).\r\n* Technically when read later at line 402, a `BufferedReader` is overkill, given that the bytes are already fully spooled in-memory.\r\n* Indeed all the output of a `Process` (via `exec()`) must be read or else a deadlock could happen as one awaits the process exit value. The default spool does consume everything.\r\n\r\nI wonder if this is an opportunity to create a `HeadHandler` implementation of `Executor.StreamHandler` that is line-oriented (e.g. characters out of bytes), that demands a specified encoding instead of allowing the default Java charset, and that reads and stores a maximum number of lines and then just consumes and discards bytes (without bothering with character conversion) to exhaust the stream and avoid allocating heap.", "bodyText": "No big problem here but some food for thought:\n\nExecutor.exec() and Executor.exec(boolean) actually spool the entire output of a program into memory. Probably that's not a burdensome amount with this removal of --max-count, given this is a rev-list of a single file.\nWhen the spooled bytes are read later at line 402, they are read with the default Java charset, which is locale dependent on the OS installation. For hashes of a rev-list, that is perhaps always OK \u2014 but I'm just remarking since elsewhere in GitRepository, specific effort is made to use a correct charset (see newLogReader()).\nTechnically when read later at line 402, a BufferedReader is overkill, given that the bytes are already fully spooled in-memory.\nIndeed all the output of a Process (via exec()) must be read or else a deadlock could happen as one awaits the process exit value. The default spool does consume everything.\n\nI wonder if this is an opportunity to create a HeadHandler implementation of Executor.StreamHandler that is line-oriented (e.g. characters out of bytes), that demands a specified encoding instead of allowing the default Java charset, and that reads and stores a maximum number of lines and then just consumes and discards bytes (without bothering with character conversion) to exhaust the stream and avoid allocating heap.", "bodyHTML": "<p dir=\"auto\">No big problem here but some food for thought:</p>\n<ul dir=\"auto\">\n<li><code>Executor.exec()</code> and <code>Executor.exec(boolean)</code> actually spool the entire output of a program into memory. Probably that's not a burdensome amount with this removal of <code>--max-count</code>, given this is a <code>rev-list</code> of a single file.</li>\n<li>When the spooled bytes are read later at line 402, they are read with the default Java charset, which is locale dependent on the OS installation. For hashes of a <code>rev-list</code>, that is perhaps always OK \u2014 but I'm just remarking since elsewhere in <code>GitRepository</code>, specific effort is made to use a correct charset (see <code>newLogReader()</code>).</li>\n<li>Technically when read later at line 402, a <code>BufferedReader</code> is overkill, given that the bytes are already fully spooled in-memory.</li>\n<li>Indeed all the output of a <code>Process</code> (via <code>exec()</code>) must be read or else a deadlock could happen as one awaits the process exit value. The default spool does consume everything.</li>\n</ul>\n<p dir=\"auto\">I wonder if this is an opportunity to create a <code>HeadHandler</code> implementation of <code>Executor.StreamHandler</code> that is line-oriented (e.g. characters out of bytes), that demands a specified encoding instead of allowing the default Java charset, and that reads and stores a maximum number of lines and then just consumes and discards bytes (without bothering with character conversion) to exhaust the stream and avoid allocating heap.</p>", "author": "idodeclare", "createdAt": "2020-02-27T02:29:11Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java", "diffHunk": "@@ -389,7 +389,6 @@ private String getFirstRevision(String fullpath) throws IOException {\n                 ensureCommand(CMD_PROPERTY_KEY, CMD_FALLBACK),\n                 \"rev-list\",\n                 \"--reverse\",\n-                \"--max-count=1\",", "originalCommit": "01b9b774786bc4545231124bbf59829db6b601bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4MDE2Mg==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r385280162", "bodyText": "Definitely good idea, I'd go for LineHandler (or similar) and then derive the HeadHandler out of it. For simplicity a lot of code could benefit from this.", "author": "tulinkry", "createdAt": "2020-02-27T18:06:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4MTY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwMDQxNQ==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r385500415", "bodyText": "Thank you, @tulinkry .\nMaybe the reverse though: a LineHandler might be an unbounded HeadHandler. The latter would need to interact low-level with the stream in order to be able to read and dump bytes when a line limit is reached.", "author": "idodeclare", "createdAt": "2020-02-28T04:17:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4MTY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MTc4MQ==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r385771781", "bodyText": "Thanks guys. It occurred to me that this might be a problem but pushed the resolution aside. Will look into it.", "author": "vladak", "createdAt": "2020-02-28T15:49:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4MTY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk0MDYxOQ==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r387940619", "bodyText": "The latest changes have the basic HeadHandler (sans encoding).", "author": "vladak", "createdAt": "2020-03-04T21:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4MTY1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\nindex d539ed1e02e..98fdba28e76 100644\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\n", "chunk": "@@ -389,6 +389,7 @@ public class GitRepository extends Repository {\n                 ensureCommand(CMD_PROPERTY_KEY, CMD_FALLBACK),\n                 \"rev-list\",\n                 \"--reverse\",\n+                \"--max-count=1\",\n                 \"HEAD\",\n                 \"--\",\n                 fullpath\n", "next_change": {"commit": "487fed8f0e78236c7bc21f37a7a03c2755d1b4e2", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\nindex 98fdba28e76..d539ed1e02e 100644\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\n", "chunk": "@@ -389,7 +389,6 @@ public class GitRepository extends Repository {\n                 ensureCommand(CMD_PROPERTY_KEY, CMD_FALLBACK),\n                 \"rev-list\",\n                 \"--reverse\",\n-                \"--max-count=1\",\n                 \"HEAD\",\n                 \"--\",\n                 fullpath\n", "next_change": {"commit": "d1282d881cd3c66d40233cebd06c64b28ad0b528", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\nindex d539ed1e02e..1dbcb37789e 100644\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\n", "chunk": "@@ -396,23 +397,17 @@ public class GitRepository extends Repository {\n \n         Executor executor = new Executor(Arrays.asList(argv), new File(getDirectoryName()),\n                 RuntimeEnvironment.getInstance().getInteractiveCommandTimeout());\n-        int status = executor.exec();\n-\n-        try (BufferedReader in = new BufferedReader(\n-                new InputStreamReader(executor.getOutputStream()))) {\n-            String line;\n+        HeadHandler headHandler = new HeadHandler(1);\n+        int status = executor.exec(false, headHandler);\n \n-            if ((line = in.readLine()) != null) {\n-                return line.trim();\n-            }\n+        String line;\n+        if (headHandler.count() > 0 && (line = headHandler.get(0)) != null) {\n+            return line.trim();\n         }\n \n-        if (status != 0) {\n-            LOGGER.log(Level.WARNING,\n-                    \"Failed to get first revision for: \\\"{0}\\\" Exit code: {1}\",\n-                    new Object[]{fullpath, String.valueOf(status)});\n-            return null;\n-        }\n+        LOGGER.log(Level.WARNING,\n+                \"Failed to get first revision for: \\\"{0}\\\" Exit code: {1}\",\n+                new Object[]{fullpath, String.valueOf(status)});\n \n         return null;\n     }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4Mjc4Mw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r384882783", "body": "Should the constructor be made private for a static utility class?", "bodyText": "Should the constructor be made private for a static utility class?", "bodyHTML": "<p dir=\"auto\">Should the constructor be made private for a static utility class?</p>", "author": "idodeclare", "createdAt": "2020-02-27T02:33:26Z", "path": "opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.web.util;\n+\n+import org.opengrok.indexer.configuration.RuntimeEnvironment;\n+\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.File;\n+import java.io.IOException;\n+\n+public class FileUtil {", "originalCommit": "01b9b774786bc4545231124bbf59829db6b601bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyMjk2Nw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r385022967", "bodyText": "yep, actually the checkstyle complains about it.", "author": "vladak", "createdAt": "2020-02-27T09:59:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4Mjc4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java b/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\nindex fa5b7105a53..bd24ef00d9e 100644\n--- a/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\n+++ b/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\n", "chunk": "@@ -25,28 +25,31 @@ package org.opengrok.web.util;\n \n import org.opengrok.indexer.configuration.RuntimeEnvironment;\n \n-import javax.servlet.http.HttpServletResponse;\n import java.io.File;\n-import java.io.IOException;\n+import java.io.FileNotFoundException;\n \n public class FileUtil {\n \n     private static final RuntimeEnvironment env = RuntimeEnvironment.getInstance();\n \n-    public static File getFile(String path, HttpServletResponse response) throws IOException {\n+    // private to enforce static\n+    private FileUtil() {\n+    }\n+\n+    /**\n+     * @param path path relative to source root\n+     * @return file object corresponding to the file under source root\n+     * @throws FileNotFoundException if the file constructed from the {@code path} parameter and source root does not exist\n+     * @throws NoPathParameterException if the {@code path} parameter is null\n+     */\n+    public static File toFile(String path) throws NoPathParameterException, FileNotFoundException {\n         if (path == null) {\n-            if (response != null) {\n-                response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE, \"Missing path parameter\");\n-            }\n-            return null;\n+            throw new NoPathParameterException(\"Missing path parameter\");\n         }\n \n         File file = new File(env.getSourceRootFile(), path);\n         if (!file.isFile()) {\n-            if (response != null) {\n-                response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found\");\n-            }\n-            return null;\n+            throw new FileNotFoundException(\"File \" + file.toString() + \"not found\");\n         }\n \n         return file;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIxOTU5Mw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r385219593", "body": "There is already FileNotFound (or similar) in java core", "bodyText": "There is already FileNotFound (or similar) in java core", "bodyHTML": "<p dir=\"auto\">There is already FileNotFound (or similar) in java core</p>", "author": "tulinkry", "createdAt": "2020-02-27T16:25:14Z", "path": "opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.web.util;\n+\n+import org.opengrok.indexer.configuration.RuntimeEnvironment;\n+\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.File;\n+\n+public class FileUtil {\n+\n+    private static final RuntimeEnvironment env = RuntimeEnvironment.getInstance();\n+\n+    // private to enforce static\n+    private FileUtil() {\n+    }\n+\n+    public static class NoFileException extends Exception {\n+        private static final long serialVersionUID = 1L;\n+\n+        public NoFileException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    public static class NoPathException extends Exception {\n+        private static final long serialVersionUID = 1L;\n+\n+        public NoPathException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    /**\n+     * @param path path relative to source root\n+     * @return file object corresponding to the file under source root\n+     * @throws NoFileException\n+     * @throws NoPathException\n+     */\n+    public static File getFile(String path, HttpServletResponse response) throws NoPathException, NoFileException {\n+        if (path == null) {\n+            throw new NoPathException(\"Missing path parameter\");\n+        }\n+\n+        File file = new File(env.getSourceRootFile(), path);\n+        if (!file.isFile()) {\n+            throw new NoFileException(\"File not found\");", "originalCommit": "62bb464dc6a17fd1b4a76db542d77585f2fd9d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyMDg4NQ==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r385720885", "bodyText": "aha ! thanks.", "author": "vladak", "createdAt": "2020-02-28T14:21:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIxOTU5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java b/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\nindex 555f6e4e5cd..bd24ef00d9e 100644\n--- a/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\n+++ b/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\n", "chunk": "@@ -36,36 +36,20 @@ public class FileUtil {\n     private FileUtil() {\n     }\n \n-    public static class NoFileException extends Exception {\n-        private static final long serialVersionUID = 1L;\n-\n-        public NoFileException(String message) {\n-            super(message);\n-        }\n-    }\n-\n-    public static class NoPathException extends Exception {\n-        private static final long serialVersionUID = 1L;\n-\n-        public NoPathException(String message) {\n-            super(message);\n-        }\n-    }\n-\n     /**\n      * @param path path relative to source root\n      * @return file object corresponding to the file under source root\n-     * @throws NoFileException\n-     * @throws NoPathException\n+     * @throws FileNotFoundException if the file constructed from the {@code path} parameter and source root does not exist\n+     * @throws NoPathParameterException if the {@code path} parameter is null\n      */\n-    public static File getFile(String path, HttpServletResponse response) throws NoPathException, NoFileException {\n+    public static File toFile(String path) throws NoPathParameterException, FileNotFoundException {\n         if (path == null) {\n-            throw new NoPathException(\"Missing path parameter\");\n+            throw new NoPathParameterException(\"Missing path parameter\");\n         }\n \n         File file = new File(env.getSourceRootFile(), path);\n         if (!file.isFile()) {\n-            throw new NoFileException(\"File not found\");\n+            throw new FileNotFoundException(\"File \" + file.toString() + \"not found\");\n         }\n \n         return file;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyMDEyOQ==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r385220129", "body": "I think I wrote it somewhere else too, I'm little bit against this naming. But if you feel comfortable, you can disregard.", "bodyText": "I think I wrote it somewhere else too, I'm little bit against this naming. But if you feel comfortable, you can disregard.", "bodyHTML": "<p dir=\"auto\">I think I wrote it somewhere else too, I'm little bit against this naming. But if you feel comfortable, you can disregard.</p>", "author": "tulinkry", "createdAt": "2020-02-27T16:25:57Z", "path": "opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.web.util;\n+\n+import org.opengrok.indexer.configuration.RuntimeEnvironment;\n+\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.File;\n+\n+public class FileUtil {\n+\n+    private static final RuntimeEnvironment env = RuntimeEnvironment.getInstance();\n+\n+    // private to enforce static\n+    private FileUtil() {\n+    }\n+\n+    public static class NoFileException extends Exception {\n+        private static final long serialVersionUID = 1L;\n+\n+        public NoFileException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    public static class NoPathException extends Exception {\n+        private static final long serialVersionUID = 1L;\n+\n+        public NoPathException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    /**\n+     * @param path path relative to source root\n+     * @return file object corresponding to the file under source root\n+     * @throws NoFileException\n+     * @throws NoPathException\n+     */\n+    public static File getFile(String path, HttpServletResponse response) throws NoPathException, NoFileException {", "originalCommit": "62bb464dc6a17fd1b4a76db542d77585f2fd9d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyMDc2MA==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r385720760", "bodyText": "toFile() ?", "author": "vladak", "createdAt": "2020-02-28T14:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyMDEyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java b/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\nindex 555f6e4e5cd..bd24ef00d9e 100644\n--- a/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\n+++ b/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\n", "chunk": "@@ -36,36 +36,20 @@ public class FileUtil {\n     private FileUtil() {\n     }\n \n-    public static class NoFileException extends Exception {\n-        private static final long serialVersionUID = 1L;\n-\n-        public NoFileException(String message) {\n-            super(message);\n-        }\n-    }\n-\n-    public static class NoPathException extends Exception {\n-        private static final long serialVersionUID = 1L;\n-\n-        public NoPathException(String message) {\n-            super(message);\n-        }\n-    }\n-\n     /**\n      * @param path path relative to source root\n      * @return file object corresponding to the file under source root\n-     * @throws NoFileException\n-     * @throws NoPathException\n+     * @throws FileNotFoundException if the file constructed from the {@code path} parameter and source root does not exist\n+     * @throws NoPathParameterException if the {@code path} parameter is null\n      */\n-    public static File getFile(String path, HttpServletResponse response) throws NoPathException, NoFileException {\n+    public static File toFile(String path) throws NoPathParameterException, FileNotFoundException {\n         if (path == null) {\n-            throw new NoPathException(\"Missing path parameter\");\n+            throw new NoPathParameterException(\"Missing path parameter\");\n         }\n \n         File file = new File(env.getSourceRootFile(), path);\n         if (!file.isFile()) {\n-            throw new NoFileException(\"File not found\");\n+            throw new FileNotFoundException(\"File \" + file.toString() + \"not found\");\n         }\n \n         return file;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyMDQ4Nw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r385220487", "body": "response is not needed", "bodyText": "response is not needed", "bodyHTML": "<p dir=\"auto\">response is not needed</p>", "author": "tulinkry", "createdAt": "2020-02-27T16:26:27Z", "path": "opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.web.util;\n+\n+import org.opengrok.indexer.configuration.RuntimeEnvironment;\n+\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.File;\n+\n+public class FileUtil {\n+\n+    private static final RuntimeEnvironment env = RuntimeEnvironment.getInstance();\n+\n+    // private to enforce static\n+    private FileUtil() {\n+    }\n+\n+    public static class NoFileException extends Exception {\n+        private static final long serialVersionUID = 1L;\n+\n+        public NoFileException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    public static class NoPathException extends Exception {\n+        private static final long serialVersionUID = 1L;\n+\n+        public NoPathException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    /**\n+     * @param path path relative to source root\n+     * @return file object corresponding to the file under source root\n+     * @throws NoFileException\n+     * @throws NoPathException\n+     */\n+    public static File getFile(String path, HttpServletResponse response) throws NoPathException, NoFileException {", "originalCommit": "62bb464dc6a17fd1b4a76db542d77585f2fd9d9d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java b/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\nindex 555f6e4e5cd..bd24ef00d9e 100644\n--- a/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\n+++ b/opengrok-web/src/main/java/org/opengrok/web/util/FileUtil.java\n", "chunk": "@@ -36,36 +36,20 @@ public class FileUtil {\n     private FileUtil() {\n     }\n \n-    public static class NoFileException extends Exception {\n-        private static final long serialVersionUID = 1L;\n-\n-        public NoFileException(String message) {\n-            super(message);\n-        }\n-    }\n-\n-    public static class NoPathException extends Exception {\n-        private static final long serialVersionUID = 1L;\n-\n-        public NoPathException(String message) {\n-            super(message);\n-        }\n-    }\n-\n     /**\n      * @param path path relative to source root\n      * @return file object corresponding to the file under source root\n-     * @throws NoFileException\n-     * @throws NoPathException\n+     * @throws FileNotFoundException if the file constructed from the {@code path} parameter and source root does not exist\n+     * @throws NoPathParameterException if the {@code path} parameter is null\n      */\n-    public static File getFile(String path, HttpServletResponse response) throws NoPathException, NoFileException {\n+    public static File toFile(String path) throws NoPathParameterException, FileNotFoundException {\n         if (path == null) {\n-            throw new NoPathException(\"Missing path parameter\");\n+            throw new NoPathParameterException(\"Missing path parameter\");\n         }\n \n         File file = new File(env.getSourceRootFile(), path);\n         if (!file.isFile()) {\n-            throw new NoFileException(\"File not found\");\n+            throw new FileNotFoundException(\"File \" + file.toString() + \"not found\");\n         }\n \n         return file;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1ODAyMQ==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r385758021", "body": "https://github.com/oracle/opengrok/pull/3050#discussion_r383695289", "bodyText": "#3050 (comment)", "bodyHTML": "<p dir=\"auto\"><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"569790169\" data-permission-text=\"Title is private\" data-url=\"https://github.com/oracle/opengrok/issues/3050\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/oracle/opengrok/pull/3050/hovercard?comment_id=383695289&amp;comment_type=review_comment\" href=\"https://github.com/oracle/opengrok/pull/3050#discussion_r383695289\">#3050 (comment)</a></p>", "author": "tulinkry", "createdAt": "2020-02-28T15:27:26Z", "path": "opengrok-web/src/main/java/org/opengrok/web/api/v1/NoPathExceptionMapper.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.web.api.v1;\n+\n+import org.opengrok.web.util.NoPathParameterException;\n+\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.ext.ExceptionMapper;\n+import javax.ws.rs.ext.Provider;\n+\n+@Provider\n+public class NoPathExceptionMapper implements ExceptionMapper<NoPathParameterException> {\n+    @Override\n+    public Response toResponse(NoPathParameterException e) {\n+        return Response.status(Response.Status.NOT_ACCEPTABLE).build();", "originalCommit": "9002f387c7fe4e9d000993741323ea5c1f10c4a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-web/src/main/java/org/opengrok/web/api/v1/NoPathExceptionMapper.java b/opengrok-web/src/main/java/org/opengrok/web/api/v1/NoPathParameterExceptionMapper.java\nsimilarity index 86%\nrename from opengrok-web/src/main/java/org/opengrok/web/api/v1/NoPathExceptionMapper.java\nrename to opengrok-web/src/main/java/org/opengrok/web/api/v1/NoPathParameterExceptionMapper.java\nindex 659e71e4f8b..c375731f401 100644\n--- a/opengrok-web/src/main/java/org/opengrok/web/api/v1/NoPathExceptionMapper.java\n+++ b/opengrok-web/src/main/java/org/opengrok/web/api/v1/NoPathParameterExceptionMapper.java\n", "chunk": "@@ -30,9 +30,9 @@ import javax.ws.rs.ext.ExceptionMapper;\n import javax.ws.rs.ext.Provider;\n \n @Provider\n-public class NoPathExceptionMapper implements ExceptionMapper<NoPathParameterException> {\n+public class NoPathParameterExceptionMapper implements ExceptionMapper<NoPathParameterException> {\n     @Override\n     public Response toResponse(NoPathParameterException e) {\n-        return Response.status(Response.Status.NOT_ACCEPTABLE).build();\n+        return Response.status(Response.Status.BAD_REQUEST).build();\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzODIzNw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r386038237", "body": "Any possibility to make this class non-HTML aware and move the encoding to `-web` or `.web`?", "bodyText": "Any possibility to make this class non-HTML aware and move the encoding to -web or .web?", "bodyHTML": "<p dir=\"auto\">Any possibility to make this class non-HTML aware and move the encoding to <code>-web</code> or <code>.web</code>?</p>", "author": "idodeclare", "createdAt": "2020-02-29T16:17:26Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/history/Annotation.java", "diffHunk": "@@ -163,10 +163,14 @@ void addLine(String revision, String author, boolean enabled) {\n     }\n \n     void addDesc(String revision, String description) {\n-        desc.put(revision, Util.encode(description));\n+        desc.put(revision, description);\n     }\n \n     public String getDesc(String revision) {\n+        return Util.encode(desc.get(revision));\n+    }\n+\n+    public String getDescRaw(String revision) {", "originalCommit": "d442dbb76724f2a009e6df8be59bbf9ec37a373d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkwNDUwMg==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r386904502", "bodyText": "Sure; thought the getDesc() is used more widely.", "author": "vladak", "createdAt": "2020-03-03T09:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzODIzNw=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/Annotation.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/Annotation.java\nindex 0426e6339e1..fc6c6309a8b 100644\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/Annotation.java\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/Annotation.java\n", "chunk": "@@ -167,10 +166,6 @@ public class Annotation {\n     }\n \n     public String getDesc(String revision) {\n-        return Util.encode(desc.get(revision));\n-    }\n-\n-    public String getDescRaw(String revision) {\n         return desc.get(revision);\n     }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyMDc4Ng==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r387420786", "body": "Given the pre-existing `if (msg != null)` check nearby below, should perhaps the new `Util.encode()` be done in that if-block?", "bodyText": "Given the pre-existing if (msg != null) check nearby below, should perhaps the new Util.encode() be done in that if-block?", "bodyHTML": "<p dir=\"auto\">Given the pre-existing <code>if (msg != null)</code> check nearby below, should perhaps the new <code>Util.encode()</code> be done in that if-block?</p>", "author": "idodeclare", "createdAt": "2020-03-04T02:47:18Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/web/Util.java", "diffHunk": "@@ -713,82 +713,87 @@ public static void readableLine(int num, Writer out, Annotation annotation, Stri\n         out.write(closeQuotedTag);\n         out.write(snum);\n         out.write(anchorEnd);\n+\n         if (annotation != null) {\n-            String r = annotation.getRevision(num);\n-            boolean enabled = annotation.isEnabled(num);\n-            out.write(\"<span class=\\\"blame\\\">\");\n-            if (enabled) {\n-                out.write(anchorClassStart);\n-                out.write(\"r\");\n-                out.write(\"\\\" style=\\\"background-color: \");\n-                out.write(annotation.getColors().getOrDefault(r, \"inherit\"));\n-                out.write(\"\\\" href=\\\"\");\n-                out.write(URIEncode(annotation.getFilename()));\n-                out.write(\"?a=true&amp;r=\");\n-                out.write(URIEncode(r));\n-                String msg = annotation.getDesc(r);\n-                out.write(\"\\\" title=\\\"\");\n-                if (msg != null) {\n-                    out.write(msg);\n-                }\n-                if (annotation.getFileVersion(r) != 0) {\n-                    out.write(\"&lt;br/&gt;version: \" + annotation.getFileVersion(r) + \"/\"\n-                            + annotation.getRevisions().size());\n-                }\n-                out.write(closeQuotedTag);\n-            }\n-            StringBuilder buf = new StringBuilder();\n-            final boolean most_recent_revision = annotation.getFileVersion(r) == annotation.getRevisions().size();\n-            // print an asterisk for the most recent revision\n-            if (most_recent_revision) {\n-                buf.append(\"<span class=\\\"most_recent_revision\\\">\");\n-                buf.append('*');\n+            writeAnnotation(num, out, annotation, userPageLink, userPageSuffix, project);\n+        }\n+    }\n+\n+    private static void writeAnnotation(int num, Writer out, Annotation annotation, String userPageLink, String userPageSuffix, String project) throws IOException {\n+        String r = annotation.getRevision(num);\n+        boolean enabled = annotation.isEnabled(num);\n+        out.write(\"<span class=\\\"blame\\\">\");\n+        if (enabled) {\n+            out.write(anchorClassStart);\n+            out.write(\"r\");\n+            out.write(\"\\\" style=\\\"background-color: \");\n+            out.write(annotation.getColors().getOrDefault(r, \"inherit\"));\n+            out.write(\"\\\" href=\\\"\");\n+            out.write(URIEncode(annotation.getFilename()));\n+            out.write(\"?a=true&amp;r=\");\n+            out.write(URIEncode(r));\n+            String msg = Util.encode(annotation.getDesc(r));", "originalCommit": "76f343a7096e547628bc072c248219c358ad9e02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzUxMTQ2OQ==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r387511469", "bodyText": "definitely. Should have done the testing. Thanks.", "author": "vladak", "createdAt": "2020-03-04T08:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyMDc4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/web/Util.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/web/Util.java\nindex c5a602c758d..5275dacefee 100644\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/web/Util.java\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/web/Util.java\n", "chunk": "@@ -732,10 +733,10 @@ public final class Util {\n             out.write(URIEncode(annotation.getFilename()));\n             out.write(\"?a=true&amp;r=\");\n             out.write(URIEncode(r));\n-            String msg = Util.encode(annotation.getDesc(r));\n+            String msg = annotation.getDesc(r);\n             out.write(\"\\\" title=\\\"\");\n             if (msg != null) {\n-                out.write(msg);\n+                out.write(Util.encode(msg));\n             }\n             if (annotation.getFileVersion(r) != 0) {\n                 out.write(\"&lt;br/&gt;version: \" + annotation.getFileVersion(r) + \"/\"\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3MTkyNg==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r388071926", "body": "I recommend to avoid breaking encapsulation (though it's rampant in OpenGrok). E.g. rather than returning a private list, how about:\r\n\r\n```\r\npublic int count() {\r\n...\r\n}\r\n\r\npublic String get(int index) {\r\n...\r\n}\r\n```\r\n```", "bodyText": "I recommend to avoid breaking encapsulation (though it's rampant in OpenGrok). E.g. rather than returning a private list, how about:\npublic int count() {\n...\n}\n\npublic String get(int index) {\n...\n}", "bodyHTML": "<p dir=\"auto\">I recommend to avoid breaking encapsulation (though it's rampant in OpenGrok). E.g. rather than returning a private list, how about:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public int count() {\n...\n}\n\npublic String get(int index) {\n...\n}\"><pre><code>public int count() {\n...\n}\n\npublic String get(int index) {\n...\n}\n</code></pre></div>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\"><pre><code></code></pre></div>", "author": "idodeclare", "createdAt": "2020-03-05T04:23:57Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * The purpose of this class is to provide StreamHandler that limits the output\n+ * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n+ * limited amount of heap.\n+ */\n+public class HeadHandler implements Executor.StreamHandler {\n+    private int numlines;\n+\n+    private final List<String> lines = new ArrayList<>();\n+\n+    // TODO add encoding\n+    public HeadHandler(int numlines) {\n+        this.numlines = numlines;\n+    }\n+\n+    public List<String> getLines() {\n+        return lines;", "originalCommit": "a38cc58e2566e81970e2115372e4217a441f1198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE2NDgyMQ==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r388164821", "bodyText": "I must admit OpenGrok code base has been primary source of my Java programming influence :-)", "author": "vladak", "createdAt": "2020-03-05T09:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3MTkyNg=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\ndeleted file mode 100644\nindex a8c25da1cba..00000000000\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,73 +0,0 @@\n-/*\n- * CDDL HEADER START\n- *\n- * The contents of this file are subject to the terms of the\n- * Common Development and Distribution License (the \"License\").\n- * You may not use this file except in compliance with the License.\n- *\n- * See LICENSE.txt included in this distribution for the specific\n- * language governing permissions and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL HEADER in each\n- * file and include the License file at LICENSE.txt.\n- * If applicable, add the following below this CDDL HEADER, with the\n- * fields enclosed by brackets \"[]\" replaced with your own identifying\n- * information: Portions Copyright [yyyy] [name of copyright owner]\n- *\n- * CDDL HEADER END\n- */\n-\n-/*\n- * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n- */\n-\n-package org.opengrok.indexer.util;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-/**\n- * The purpose of this class is to provide StreamHandler that limits the output\n- * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n- * limited amount of heap.\n- */\n-public class HeadHandler implements Executor.StreamHandler {\n-    private int numlines;\n-\n-    private final List<String> lines = new ArrayList<>();\n-\n-    // TODO add encoding\n-    public HeadHandler(int numlines) {\n-        this.numlines = numlines;\n-    }\n-\n-    public List<String> getLines() {\n-        return lines;\n-    }\n-\n-    @Override\n-    public void processStream(InputStream input) throws IOException {\n-        // TODO specify encoding for InputStreamReader constructor\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n-        int linenum = 0;\n-        while (linenum < numlines) {\n-            // TODO encoding\n-            String line = reader.readLine();\n-            if (line == null) { // EOF\n-                return;\n-            }\n-            lines.add(line);\n-            linenum++;\n-        }\n-        // Read and forget the rest. Need to use read() since it is not guaranteed\n-        // that newline will ensue.\n-        // TODO: would readline() get the job done ?\n-        while (reader.read() != -1) {\n-            ;\n-        }\n-    }\n-}\n", "next_change": {"commit": "d1282d881cd3c66d40233cebd06c64b28ad0b528", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\nnew file mode 100644\nindex 00000000000..eea7079496e\n--- /dev/null\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\n", "chunk": "@@ -0,0 +1,109 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * The purpose of this class is to provide {@code StreamHandler} that limits the output\n+ * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n+ * limited amount of heap.\n+ */\n+public class HeadHandler implements Executor.StreamHandler {\n+    private final int maxLines;\n+\n+    private final List<String> lines = new ArrayList<>();\n+    private final Charset charset;\n+\n+    private static final int bufferedReaderSize = 200;\n+\n+    /**\n+     * Charset of the underlying reader is set to UTF-8.\n+     * @param maxLines maximum number of lines to store\n+     */\n+    public HeadHandler(int maxLines) {\n+        this.maxLines = maxLines;\n+        this.charset = StandardCharsets.UTF_8;\n+    }\n+\n+    /**\n+     * @param maxLines maximum number of lines to store\n+     * @param charset character set\n+     */\n+    public HeadHandler(int maxLines, Charset charset) {\n+        this.maxLines = maxLines;\n+        this.charset = charset;\n+    }\n+\n+    /**\n+     * @return number of lines read\n+     */\n+    public int count() {\n+        return lines.size();\n+    }\n+\n+    /**\n+     * @param index index\n+     * @return line at given index. Will be non {@code null} for valid index.\n+     */\n+    public String get(int index) {\n+        return lines.get(index);\n+    }\n+\n+    // for testing\n+    static int getBufferedReaderSize() {\n+        return bufferedReaderSize;\n+    }\n+\n+    @Override\n+    public void processStream(InputStream input) throws IOException {\n+        try (BufferedInputStream bufStream = new BufferedInputStream(input);\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(bufStream, this.charset),\n+                bufferedReaderSize)) {\n+            int lineNum = 0;\n+            while (lineNum < maxLines) {\n+                String line = reader.readLine();\n+                if (line == null) { // EOF\n+                    return;\n+                }\n+                lines.add(line);\n+                lineNum++;\n+            }\n+\n+            // Read and forget the rest.\n+            byte[] buf = new byte[1024];\n+            while ((bufStream.read(buf)) != -1) {\n+                ;\n+            }\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3NDgwMA==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r388074800", "body": "Technically this is doing needless `byte` to `char` conversion. E.g. were it a multi-byte encoding, then decoding is not worthwhile.\r\n\r\nMy original thinking on `HeadHandler` was to have the principal buffering at the byte-level. E.g. a `BufferedReader(InputStreamReader, /*tiny*/200)` atop a `BufferedInputStream`. Then when all the needed `readLine()` calls are done to just `read()` and discard from the `BufferedInputStream` \u2014 probably not a byte at a time but with say a very small `byte[1024]` buffer.\r\n\r\n(Using `readLine()` here would defeat the goal of avoiding needless heap allocation.)", "bodyText": "Technically this is doing needless byte to char conversion. E.g. were it a multi-byte encoding, then decoding is not worthwhile.\nMy original thinking on HeadHandler was to have the principal buffering at the byte-level. E.g. a BufferedReader(InputStreamReader, /*tiny*/200) atop a BufferedInputStream. Then when all the needed readLine() calls are done to just read() and discard from the BufferedInputStream \u2014 probably not a byte at a time but with say a very small byte[1024] buffer.\n(Using readLine() here would defeat the goal of avoiding needless heap allocation.)", "bodyHTML": "<p dir=\"auto\">Technically this is doing needless <code>byte</code> to <code>char</code> conversion. E.g. were it a multi-byte encoding, then decoding is not worthwhile.</p>\n<p dir=\"auto\">My original thinking on <code>HeadHandler</code> was to have the principal buffering at the byte-level. E.g. a <code>BufferedReader(InputStreamReader, /*tiny*/200)</code> atop a <code>BufferedInputStream</code>. Then when all the needed <code>readLine()</code> calls are done to just <code>read()</code> and discard from the <code>BufferedInputStream</code> \u2014 probably not a byte at a time but with say a very small <code>byte[1024]</code> buffer.</p>\n<p dir=\"auto\">(Using <code>readLine()</code> here would defeat the goal of avoiding needless heap allocation.)</p>", "author": "idodeclare", "createdAt": "2020-03-05T04:39:31Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * The purpose of this class is to provide StreamHandler that limits the output\n+ * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n+ * limited amount of heap.\n+ */\n+public class HeadHandler implements Executor.StreamHandler {\n+    private int numlines;\n+\n+    private final List<String> lines = new ArrayList<>();\n+\n+    // TODO add encoding\n+    public HeadHandler(int numlines) {\n+        this.numlines = numlines;\n+    }\n+\n+    public List<String> getLines() {\n+        return lines;\n+    }\n+\n+    @Override\n+    public void processStream(InputStream input) throws IOException {\n+        // TODO specify encoding for InputStreamReader constructor\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n+        int linenum = 0;\n+        while (linenum < numlines) {\n+            // TODO encoding\n+            String line = reader.readLine();\n+            if (line == null) { // EOF\n+                return;\n+            }\n+            lines.add(line);\n+            linenum++;\n+        }\n+        // Read and forget the rest. Need to use read() since it is not guaranteed\n+        // that newline will ensue.\n+        // TODO: would readline() get the job done ?\n+        while (reader.read() != -1) {", "originalCommit": "a38cc58e2566e81970e2115372e4217a441f1198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQyMjM4Ng==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r388422386", "bodyText": "I see. Now, BufferedReader.read() will not read a single byte from the underlying stream - it will call fill() to fill the internal buffer.", "author": "vladak", "createdAt": "2020-03-05T16:48:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3NDgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NTQ0MQ==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r388575441", "bodyText": "Anyhow, the suggested layering sounds good so I have implemented that, together with charset choice.", "author": "vladak", "createdAt": "2020-03-05T21:26:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3NDgwMA=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\ndeleted file mode 100644\nindex a8c25da1cba..00000000000\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,73 +0,0 @@\n-/*\n- * CDDL HEADER START\n- *\n- * The contents of this file are subject to the terms of the\n- * Common Development and Distribution License (the \"License\").\n- * You may not use this file except in compliance with the License.\n- *\n- * See LICENSE.txt included in this distribution for the specific\n- * language governing permissions and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL HEADER in each\n- * file and include the License file at LICENSE.txt.\n- * If applicable, add the following below this CDDL HEADER, with the\n- * fields enclosed by brackets \"[]\" replaced with your own identifying\n- * information: Portions Copyright [yyyy] [name of copyright owner]\n- *\n- * CDDL HEADER END\n- */\n-\n-/*\n- * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n- */\n-\n-package org.opengrok.indexer.util;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-/**\n- * The purpose of this class is to provide StreamHandler that limits the output\n- * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n- * limited amount of heap.\n- */\n-public class HeadHandler implements Executor.StreamHandler {\n-    private int numlines;\n-\n-    private final List<String> lines = new ArrayList<>();\n-\n-    // TODO add encoding\n-    public HeadHandler(int numlines) {\n-        this.numlines = numlines;\n-    }\n-\n-    public List<String> getLines() {\n-        return lines;\n-    }\n-\n-    @Override\n-    public void processStream(InputStream input) throws IOException {\n-        // TODO specify encoding for InputStreamReader constructor\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n-        int linenum = 0;\n-        while (linenum < numlines) {\n-            // TODO encoding\n-            String line = reader.readLine();\n-            if (line == null) { // EOF\n-                return;\n-            }\n-            lines.add(line);\n-            linenum++;\n-        }\n-        // Read and forget the rest. Need to use read() since it is not guaranteed\n-        // that newline will ensue.\n-        // TODO: would readline() get the job done ?\n-        while (reader.read() != -1) {\n-            ;\n-        }\n-    }\n-}\n", "next_change": {"commit": "d1282d881cd3c66d40233cebd06c64b28ad0b528", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\nnew file mode 100644\nindex 00000000000..eea7079496e\n--- /dev/null\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\n", "chunk": "@@ -0,0 +1,109 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * The purpose of this class is to provide {@code StreamHandler} that limits the output\n+ * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n+ * limited amount of heap.\n+ */\n+public class HeadHandler implements Executor.StreamHandler {\n+    private final int maxLines;\n+\n+    private final List<String> lines = new ArrayList<>();\n+    private final Charset charset;\n+\n+    private static final int bufferedReaderSize = 200;\n+\n+    /**\n+     * Charset of the underlying reader is set to UTF-8.\n+     * @param maxLines maximum number of lines to store\n+     */\n+    public HeadHandler(int maxLines) {\n+        this.maxLines = maxLines;\n+        this.charset = StandardCharsets.UTF_8;\n+    }\n+\n+    /**\n+     * @param maxLines maximum number of lines to store\n+     * @param charset character set\n+     */\n+    public HeadHandler(int maxLines, Charset charset) {\n+        this.maxLines = maxLines;\n+        this.charset = charset;\n+    }\n+\n+    /**\n+     * @return number of lines read\n+     */\n+    public int count() {\n+        return lines.size();\n+    }\n+\n+    /**\n+     * @param index index\n+     * @return line at given index. Will be non {@code null} for valid index.\n+     */\n+    public String get(int index) {\n+        return lines.get(index);\n+    }\n+\n+    // for testing\n+    static int getBufferedReaderSize() {\n+        return bufferedReaderSize;\n+    }\n+\n+    @Override\n+    public void processStream(InputStream input) throws IOException {\n+        try (BufferedInputStream bufStream = new BufferedInputStream(input);\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(bufStream, this.charset),\n+                bufferedReaderSize)) {\n+            int lineNum = 0;\n+            while (lineNum < maxLines) {\n+                String line = reader.readLine();\n+                if (line == null) { // EOF\n+                    return;\n+                }\n+                lines.add(line);\n+                lineNum++;\n+            }\n+\n+            // Read and forget the rest.\n+            byte[] buf = new byte[1024];\n+            while ((bufStream.read(buf)) != -1) {\n+                ;\n+            }\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5NzQ2MA==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r388297460", "body": "I think the API requires `if (headHandler.count() > 0) {`", "bodyText": "I think the API requires if (headHandler.count() > 0) {", "bodyHTML": "<p dir=\"auto\">I think the API requires <code>if (headHandler.count() &gt; 0) {</code></p>", "author": "idodeclare", "createdAt": "2020-03-05T13:38:59Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java", "diffHunk": "@@ -389,23 +390,19 @@ private String getFirstRevision(String fullpath) throws IOException {\n                 ensureCommand(CMD_PROPERTY_KEY, CMD_FALLBACK),\n                 \"rev-list\",\n                 \"--reverse\",\n-                \"--max-count=1\",\n                 \"HEAD\",\n                 \"--\",\n                 fullpath\n         };\n \n         Executor executor = new Executor(Arrays.asList(argv), new File(getDirectoryName()),\n                 RuntimeEnvironment.getInstance().getInteractiveCommandTimeout());\n-        int status = executor.exec();\n-\n-        try (BufferedReader in = new BufferedReader(\n-                new InputStreamReader(executor.getOutputStream()))) {\n-            String line;\n+        HeadHandler headHandler = new HeadHandler(1);\n+        int status = executor.exec(false, headHandler);\n \n-            if ((line = in.readLine()) != null) {\n-                return line.trim();\n-            }\n+        String line;\n+        if ((line = headHandler.get(0)) != null) {", "originalCommit": "da17ed53943a07aa81c302266528b2b44c573013", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMwMzg0Mw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r388303843", "bodyText": "I see, for some reason I thought it will return null.", "author": "vladak", "createdAt": "2020-03-05T13:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5NzQ2MA=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\nindex c1431614c19..98fdba28e76 100644\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\n", "chunk": "@@ -397,12 +397,15 @@ public class GitRepository extends Repository {\n \n         Executor executor = new Executor(Arrays.asList(argv), new File(getDirectoryName()),\n                 RuntimeEnvironment.getInstance().getInteractiveCommandTimeout());\n-        HeadHandler headHandler = new HeadHandler(1);\n-        int status = executor.exec(false, headHandler);\n+        int status = executor.exec();\n+\n+        try (BufferedReader in = new BufferedReader(\n+                new InputStreamReader(executor.getOutputStream()))) {\n+            String line;\n \n-        String line;\n-        if ((line = headHandler.get(0)) != null) {\n-            return line.trim();\n+            if ((line = in.readLine()) != null) {\n+                return line.trim();\n+            }\n         }\n \n         if (status != 0) {\n", "next_change": {"commit": "d1282d881cd3c66d40233cebd06c64b28ad0b528", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\nindex 98fdba28e76..1dbcb37789e 100644\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\n", "chunk": "@@ -397,23 +397,17 @@ public class GitRepository extends Repository {\n \n         Executor executor = new Executor(Arrays.asList(argv), new File(getDirectoryName()),\n                 RuntimeEnvironment.getInstance().getInteractiveCommandTimeout());\n-        int status = executor.exec();\n-\n-        try (BufferedReader in = new BufferedReader(\n-                new InputStreamReader(executor.getOutputStream()))) {\n-            String line;\n+        HeadHandler headHandler = new HeadHandler(1);\n+        int status = executor.exec(false, headHandler);\n \n-            if ((line = in.readLine()) != null) {\n-                return line.trim();\n-            }\n+        String line;\n+        if (headHandler.count() > 0 && (line = headHandler.get(0)) != null) {\n+            return line.trim();\n         }\n \n-        if (status != 0) {\n-            LOGGER.log(Level.WARNING,\n-                    \"Failed to get first revision for: \\\"{0}\\\" Exit code: {1}\",\n-                    new Object[]{fullpath, String.valueOf(status)});\n-            return null;\n-        }\n+        LOGGER.log(Level.WARNING,\n+                \"Failed to get first revision for: \\\"{0}\\\" Exit code: {1}\",\n+                new Object[]{fullpath, String.valueOf(status)});\n \n         return null;\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2MTM2MA==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r388561360", "body": "Shifting the offset into `buf` would shrink the available target space until possibly only 0-byte reads were done endlessly. I think this should just use the simpler `read(byte[])` to reuse the whole buffer each time.", "bodyText": "Shifting the offset into buf would shrink the available target space until possibly only 0-byte reads were done endlessly. I think this should just use the simpler read(byte[]) to reuse the whole buffer each time.", "bodyHTML": "<p dir=\"auto\">Shifting the offset into <code>buf</code> would shrink the available target space until possibly only 0-byte reads were done endlessly. I think this should just use the simpler <code>read(byte[])</code> to reuse the whole buffer each time.</p>", "author": "idodeclare", "createdAt": "2020-03-05T20:57:24Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * The purpose of this class is to provide {@code StreamHandler} that limits the output\n+ * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n+ * limited amount of heap.\n+ */\n+public class HeadHandler implements Executor.StreamHandler {\n+    private int numLines;\n+\n+    private final List<String> lines = new ArrayList<>();\n+    private Charset charset;\n+\n+    /**\n+     * Charset of the underlying reader is set to UTF-8.\n+     * @param numLines maximum number of lines to store\n+     */\n+    public HeadHandler(int numLines) {\n+        this.numLines = numLines;\n+        this.charset = StandardCharsets.UTF_8;\n+    }\n+\n+    public HeadHandler(int numLines, Charset charset) {\n+        this.numLines = numLines;\n+        this.charset = charset;\n+    }\n+\n+    /**\n+     * @return number of lines read\n+     */\n+    public int size() {\n+        return lines.size();\n+    }\n+\n+    /**\n+     * @param i index\n+     * @return line at given index\n+     */\n+    public String get(int i) {\n+        return lines.get(i);\n+    }\n+\n+    @Override\n+    public void processStream(InputStream input) throws IOException {\n+        BufferedInputStream bufStream = new BufferedInputStream(input);\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(bufStream, this.charset), 200);\n+        int lineNum = 0;\n+        while (lineNum < numLines) {\n+            String line = reader.readLine();\n+            if (line == null) { // EOF\n+                return;\n+            }\n+            lines.add(line);\n+            lineNum++;\n+        }\n+\n+        // Read and forget the rest.\n+        byte[] buf = new byte[1024];\n+        int off = 0;\n+        int len;\n+        while ((len = bufStream.read(buf, off, buf.length)) != -1) {", "originalCommit": "3a9e760d9b403133d998d842ef746b2c8fd3fd70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNTg4Mw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r388905883", "bodyText": "okay, sounds reasonable.", "author": "vladak", "createdAt": "2020-03-06T13:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2MTM2MA=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\ndeleted file mode 100644\nindex 7d381ceed9b..00000000000\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,98 +0,0 @@\n-/*\n- * CDDL HEADER START\n- *\n- * The contents of this file are subject to the terms of the\n- * Common Development and Distribution License (the \"License\").\n- * You may not use this file except in compliance with the License.\n- *\n- * See LICENSE.txt included in this distribution for the specific\n- * language governing permissions and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL HEADER in each\n- * file and include the License file at LICENSE.txt.\n- * If applicable, add the following below this CDDL HEADER, with the\n- * fields enclosed by brackets \"[]\" replaced with your own identifying\n- * information: Portions Copyright [yyyy] [name of copyright owner]\n- *\n- * CDDL HEADER END\n- */\n-\n-/*\n- * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n- */\n-\n-package org.opengrok.indexer.util;\n-\n-import java.io.BufferedInputStream;\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-/**\n- * The purpose of this class is to provide {@code StreamHandler} that limits the output\n- * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n- * limited amount of heap.\n- */\n-public class HeadHandler implements Executor.StreamHandler {\n-    private int numLines;\n-\n-    private final List<String> lines = new ArrayList<>();\n-    private Charset charset;\n-\n-    /**\n-     * Charset of the underlying reader is set to UTF-8.\n-     * @param numLines maximum number of lines to store\n-     */\n-    public HeadHandler(int numLines) {\n-        this.numLines = numLines;\n-        this.charset = StandardCharsets.UTF_8;\n-    }\n-\n-    public HeadHandler(int numLines, Charset charset) {\n-        this.numLines = numLines;\n-        this.charset = charset;\n-    }\n-\n-    /**\n-     * @return number of lines read\n-     */\n-    public int size() {\n-        return lines.size();\n-    }\n-\n-    /**\n-     * @param i index\n-     * @return line at given index\n-     */\n-    public String get(int i) {\n-        return lines.get(i);\n-    }\n-\n-    @Override\n-    public void processStream(InputStream input) throws IOException {\n-        BufferedInputStream bufStream = new BufferedInputStream(input);\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(bufStream, this.charset), 200);\n-        int lineNum = 0;\n-        while (lineNum < numLines) {\n-            String line = reader.readLine();\n-            if (line == null) { // EOF\n-                return;\n-            }\n-            lines.add(line);\n-            lineNum++;\n-        }\n-\n-        // Read and forget the rest.\n-        byte[] buf = new byte[1024];\n-        int off = 0;\n-        int len;\n-        while ((len = bufStream.read(buf, off, buf.length)) != -1) {\n-            off += len;\n-        }\n-    }\n-}\n", "next_change": {"commit": "d1282d881cd3c66d40233cebd06c64b28ad0b528", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\nnew file mode 100644\nindex 00000000000..eea7079496e\n--- /dev/null\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\n", "chunk": "@@ -0,0 +1,109 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * The purpose of this class is to provide {@code StreamHandler} that limits the output\n+ * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n+ * limited amount of heap.\n+ */\n+public class HeadHandler implements Executor.StreamHandler {\n+    private final int maxLines;\n+\n+    private final List<String> lines = new ArrayList<>();\n+    private final Charset charset;\n+\n+    private static final int bufferedReaderSize = 200;\n+\n+    /**\n+     * Charset of the underlying reader is set to UTF-8.\n+     * @param maxLines maximum number of lines to store\n+     */\n+    public HeadHandler(int maxLines) {\n+        this.maxLines = maxLines;\n+        this.charset = StandardCharsets.UTF_8;\n+    }\n+\n+    /**\n+     * @param maxLines maximum number of lines to store\n+     * @param charset character set\n+     */\n+    public HeadHandler(int maxLines, Charset charset) {\n+        this.maxLines = maxLines;\n+        this.charset = charset;\n+    }\n+\n+    /**\n+     * @return number of lines read\n+     */\n+    public int count() {\n+        return lines.size();\n+    }\n+\n+    /**\n+     * @param index index\n+     * @return line at given index. Will be non {@code null} for valid index.\n+     */\n+    public String get(int index) {\n+        return lines.get(index);\n+    }\n+\n+    // for testing\n+    static int getBufferedReaderSize() {\n+        return bufferedReaderSize;\n+    }\n+\n+    @Override\n+    public void processStream(InputStream input) throws IOException {\n+        try (BufferedInputStream bufStream = new BufferedInputStream(input);\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(bufStream, this.charset),\n+                bufferedReaderSize)) {\n+            int lineNum = 0;\n+            while (lineNum < maxLines) {\n+                String line = reader.readLine();\n+                if (line == null) { // EOF\n+                    return;\n+                }\n+                lines.add(line);\n+                lineNum++;\n+            }\n+\n+            // Read and forget the rest.\n+            byte[] buf = new byte[1024];\n+            while ((bufStream.read(buf)) != -1) {\n+                ;\n+            }\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2MTYyMQ==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r388561621", "body": "`final` possibly?", "bodyText": "final possibly?", "bodyHTML": "<p dir=\"auto\"><code>final</code> possibly?</p>", "author": "idodeclare", "createdAt": "2020-03-05T20:57:59Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * The purpose of this class is to provide {@code StreamHandler} that limits the output\n+ * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n+ * limited amount of heap.\n+ */\n+public class HeadHandler implements Executor.StreamHandler {\n+    private int numLines;\n+\n+    private final List<String> lines = new ArrayList<>();\n+    private Charset charset;", "originalCommit": "3a9e760d9b403133d998d842ef746b2c8fd3fd70", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\ndeleted file mode 100644\nindex 7d381ceed9b..00000000000\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,98 +0,0 @@\n-/*\n- * CDDL HEADER START\n- *\n- * The contents of this file are subject to the terms of the\n- * Common Development and Distribution License (the \"License\").\n- * You may not use this file except in compliance with the License.\n- *\n- * See LICENSE.txt included in this distribution for the specific\n- * language governing permissions and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL HEADER in each\n- * file and include the License file at LICENSE.txt.\n- * If applicable, add the following below this CDDL HEADER, with the\n- * fields enclosed by brackets \"[]\" replaced with your own identifying\n- * information: Portions Copyright [yyyy] [name of copyright owner]\n- *\n- * CDDL HEADER END\n- */\n-\n-/*\n- * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n- */\n-\n-package org.opengrok.indexer.util;\n-\n-import java.io.BufferedInputStream;\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-/**\n- * The purpose of this class is to provide {@code StreamHandler} that limits the output\n- * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n- * limited amount of heap.\n- */\n-public class HeadHandler implements Executor.StreamHandler {\n-    private int numLines;\n-\n-    private final List<String> lines = new ArrayList<>();\n-    private Charset charset;\n-\n-    /**\n-     * Charset of the underlying reader is set to UTF-8.\n-     * @param numLines maximum number of lines to store\n-     */\n-    public HeadHandler(int numLines) {\n-        this.numLines = numLines;\n-        this.charset = StandardCharsets.UTF_8;\n-    }\n-\n-    public HeadHandler(int numLines, Charset charset) {\n-        this.numLines = numLines;\n-        this.charset = charset;\n-    }\n-\n-    /**\n-     * @return number of lines read\n-     */\n-    public int size() {\n-        return lines.size();\n-    }\n-\n-    /**\n-     * @param i index\n-     * @return line at given index\n-     */\n-    public String get(int i) {\n-        return lines.get(i);\n-    }\n-\n-    @Override\n-    public void processStream(InputStream input) throws IOException {\n-        BufferedInputStream bufStream = new BufferedInputStream(input);\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(bufStream, this.charset), 200);\n-        int lineNum = 0;\n-        while (lineNum < numLines) {\n-            String line = reader.readLine();\n-            if (line == null) { // EOF\n-                return;\n-            }\n-            lines.add(line);\n-            lineNum++;\n-        }\n-\n-        // Read and forget the rest.\n-        byte[] buf = new byte[1024];\n-        int off = 0;\n-        int len;\n-        while ((len = bufStream.read(buf, off, buf.length)) != -1) {\n-            off += len;\n-        }\n-    }\n-}\n", "next_change": {"commit": "d1282d881cd3c66d40233cebd06c64b28ad0b528", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\nnew file mode 100644\nindex 00000000000..eea7079496e\n--- /dev/null\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\n", "chunk": "@@ -0,0 +1,109 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * The purpose of this class is to provide {@code StreamHandler} that limits the output\n+ * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n+ * limited amount of heap.\n+ */\n+public class HeadHandler implements Executor.StreamHandler {\n+    private final int maxLines;\n+\n+    private final List<String> lines = new ArrayList<>();\n+    private final Charset charset;\n+\n+    private static final int bufferedReaderSize = 200;\n+\n+    /**\n+     * Charset of the underlying reader is set to UTF-8.\n+     * @param maxLines maximum number of lines to store\n+     */\n+    public HeadHandler(int maxLines) {\n+        this.maxLines = maxLines;\n+        this.charset = StandardCharsets.UTF_8;\n+    }\n+\n+    /**\n+     * @param maxLines maximum number of lines to store\n+     * @param charset character set\n+     */\n+    public HeadHandler(int maxLines, Charset charset) {\n+        this.maxLines = maxLines;\n+        this.charset = charset;\n+    }\n+\n+    /**\n+     * @return number of lines read\n+     */\n+    public int count() {\n+        return lines.size();\n+    }\n+\n+    /**\n+     * @param index index\n+     * @return line at given index. Will be non {@code null} for valid index.\n+     */\n+    public String get(int index) {\n+        return lines.get(index);\n+    }\n+\n+    // for testing\n+    static int getBufferedReaderSize() {\n+        return bufferedReaderSize;\n+    }\n+\n+    @Override\n+    public void processStream(InputStream input) throws IOException {\n+        try (BufferedInputStream bufStream = new BufferedInputStream(input);\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(bufStream, this.charset),\n+                bufferedReaderSize)) {\n+            int lineNum = 0;\n+            while (lineNum < maxLines) {\n+                String line = reader.readLine();\n+                if (line == null) { // EOF\n+                    return;\n+                }\n+                lines.add(line);\n+                lineNum++;\n+            }\n+\n+            // Read and forget the rest.\n+            byte[] buf = new byte[1024];\n+            while ((bufStream.read(buf)) != -1) {\n+                ;\n+            }\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2Mjk4Nw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r388562987", "body": "Nit: I think your implementation does ensure non-null for a valid index. Maybe that could be stated firmly in the Javadoc?", "bodyText": "Nit: I think your implementation does ensure non-null for a valid index. Maybe that could be stated firmly in the Javadoc?", "bodyHTML": "<p dir=\"auto\">Nit: I think your implementation does ensure non-null for a valid index. Maybe that could be stated firmly in the Javadoc?</p>", "author": "idodeclare", "createdAt": "2020-03-05T21:00:55Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java", "diffHunk": "@@ -389,31 +390,24 @@ private String getFirstRevision(String fullpath) throws IOException {\n                 ensureCommand(CMD_PROPERTY_KEY, CMD_FALLBACK),\n                 \"rev-list\",\n                 \"--reverse\",\n-                \"--max-count=1\",\n                 \"HEAD\",\n                 \"--\",\n                 fullpath\n         };\n \n         Executor executor = new Executor(Arrays.asList(argv), new File(getDirectoryName()),\n                 RuntimeEnvironment.getInstance().getInteractiveCommandTimeout());\n-        int status = executor.exec();\n-\n-        try (BufferedReader in = new BufferedReader(\n-                new InputStreamReader(executor.getOutputStream()))) {\n-            String line;\n+        HeadHandler headHandler = new HeadHandler(1);\n+        int status = executor.exec(false, headHandler);\n \n-            if ((line = in.readLine()) != null) {\n-                return line.trim();\n-            }\n+        String line;\n+        if (headHandler.size() > 0 && (line = headHandler.get(0)) != null) {", "originalCommit": "3a9e760d9b403133d998d842ef746b2c8fd3fd70", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\nindex 0f6ebe8e937..98fdba28e76 100644\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\n", "chunk": "@@ -397,17 +397,23 @@ public class GitRepository extends Repository {\n \n         Executor executor = new Executor(Arrays.asList(argv), new File(getDirectoryName()),\n                 RuntimeEnvironment.getInstance().getInteractiveCommandTimeout());\n-        HeadHandler headHandler = new HeadHandler(1);\n-        int status = executor.exec(false, headHandler);\n+        int status = executor.exec();\n+\n+        try (BufferedReader in = new BufferedReader(\n+                new InputStreamReader(executor.getOutputStream()))) {\n+            String line;\n \n-        String line;\n-        if (headHandler.size() > 0 && (line = headHandler.get(0)) != null) {\n-            return line.trim();\n+            if ((line = in.readLine()) != null) {\n+                return line.trim();\n+            }\n         }\n \n-        LOGGER.log(Level.WARNING,\n-                \"Failed to get first revision for: \\\"{0}\\\" Exit code: {1}\",\n-                new Object[]{fullpath, String.valueOf(status)});\n+        if (status != 0) {\n+            LOGGER.log(Level.WARNING,\n+                    \"Failed to get first revision for: \\\"{0}\\\" Exit code: {1}\",\n+                    new Object[]{fullpath, String.valueOf(status)});\n+            return null;\n+        }\n \n         return null;\n     }\n", "next_change": {"commit": "d1282d881cd3c66d40233cebd06c64b28ad0b528", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\nindex 98fdba28e76..1dbcb37789e 100644\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/GitRepository.java\n", "chunk": "@@ -397,23 +397,17 @@ public class GitRepository extends Repository {\n \n         Executor executor = new Executor(Arrays.asList(argv), new File(getDirectoryName()),\n                 RuntimeEnvironment.getInstance().getInteractiveCommandTimeout());\n-        int status = executor.exec();\n-\n-        try (BufferedReader in = new BufferedReader(\n-                new InputStreamReader(executor.getOutputStream()))) {\n-            String line;\n+        HeadHandler headHandler = new HeadHandler(1);\n+        int status = executor.exec(false, headHandler);\n \n-            if ((line = in.readLine()) != null) {\n-                return line.trim();\n-            }\n+        String line;\n+        if (headHandler.count() > 0 && (line = headHandler.get(0)) != null) {\n+            return line.trim();\n         }\n \n-        if (status != 0) {\n-            LOGGER.log(Level.WARNING,\n-                    \"Failed to get first revision for: \\\"{0}\\\" Exit code: {1}\",\n-                    new Object[]{fullpath, String.valueOf(status)});\n-            return null;\n-        }\n+        LOGGER.log(Level.WARNING,\n+                \"Failed to get first revision for: \\\"{0}\\\" Exit code: {1}\",\n+                new Object[]{fullpath, String.valueOf(status)});\n \n         return null;\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyMTE5Nw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r388621197", "body": "Oh I forgot to ask: would try-with-resources be appropriate here?", "bodyText": "Oh I forgot to ask: would try-with-resources be appropriate here?", "bodyHTML": "<p dir=\"auto\">Oh I forgot to ask: would try-with-resources be appropriate here?</p>", "author": "idodeclare", "createdAt": "2020-03-05T23:15:06Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * The purpose of this class is to provide {@code StreamHandler} that limits the output\n+ * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n+ * limited amount of heap.\n+ */\n+public class HeadHandler implements Executor.StreamHandler {\n+    private int numLines;\n+\n+    private final List<String> lines = new ArrayList<>();\n+    private Charset charset;\n+\n+    /**\n+     * Charset of the underlying reader is set to UTF-8.\n+     * @param numLines maximum number of lines to store\n+     */\n+    public HeadHandler(int numLines) {\n+        this.numLines = numLines;\n+        this.charset = StandardCharsets.UTF_8;\n+    }\n+\n+    public HeadHandler(int numLines, Charset charset) {\n+        this.numLines = numLines;\n+        this.charset = charset;\n+    }\n+\n+    /**\n+     * @return number of lines read\n+     */\n+    public int size() {\n+        return lines.size();\n+    }\n+\n+    /**\n+     * @param i index\n+     * @return line at given index\n+     */\n+    public String get(int i) {\n+        return lines.get(i);\n+    }\n+\n+    @Override\n+    public void processStream(InputStream input) throws IOException {\n+        BufferedInputStream bufStream = new BufferedInputStream(input);\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(bufStream, this.charset), 200);", "originalCommit": "3a9e760d9b403133d998d842ef746b2c8fd3fd70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwMjM3Mw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r388902373", "bodyText": "definitely. Wanted to do it but then forgot.", "author": "vladak", "createdAt": "2020-03-06T13:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyMTE5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\ndeleted file mode 100644\nindex 7d381ceed9b..00000000000\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,98 +0,0 @@\n-/*\n- * CDDL HEADER START\n- *\n- * The contents of this file are subject to the terms of the\n- * Common Development and Distribution License (the \"License\").\n- * You may not use this file except in compliance with the License.\n- *\n- * See LICENSE.txt included in this distribution for the specific\n- * language governing permissions and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL HEADER in each\n- * file and include the License file at LICENSE.txt.\n- * If applicable, add the following below this CDDL HEADER, with the\n- * fields enclosed by brackets \"[]\" replaced with your own identifying\n- * information: Portions Copyright [yyyy] [name of copyright owner]\n- *\n- * CDDL HEADER END\n- */\n-\n-/*\n- * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n- */\n-\n-package org.opengrok.indexer.util;\n-\n-import java.io.BufferedInputStream;\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-/**\n- * The purpose of this class is to provide {@code StreamHandler} that limits the output\n- * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n- * limited amount of heap.\n- */\n-public class HeadHandler implements Executor.StreamHandler {\n-    private int numLines;\n-\n-    private final List<String> lines = new ArrayList<>();\n-    private Charset charset;\n-\n-    /**\n-     * Charset of the underlying reader is set to UTF-8.\n-     * @param numLines maximum number of lines to store\n-     */\n-    public HeadHandler(int numLines) {\n-        this.numLines = numLines;\n-        this.charset = StandardCharsets.UTF_8;\n-    }\n-\n-    public HeadHandler(int numLines, Charset charset) {\n-        this.numLines = numLines;\n-        this.charset = charset;\n-    }\n-\n-    /**\n-     * @return number of lines read\n-     */\n-    public int size() {\n-        return lines.size();\n-    }\n-\n-    /**\n-     * @param i index\n-     * @return line at given index\n-     */\n-    public String get(int i) {\n-        return lines.get(i);\n-    }\n-\n-    @Override\n-    public void processStream(InputStream input) throws IOException {\n-        BufferedInputStream bufStream = new BufferedInputStream(input);\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(bufStream, this.charset), 200);\n-        int lineNum = 0;\n-        while (lineNum < numLines) {\n-            String line = reader.readLine();\n-            if (line == null) { // EOF\n-                return;\n-            }\n-            lines.add(line);\n-            lineNum++;\n-        }\n-\n-        // Read and forget the rest.\n-        byte[] buf = new byte[1024];\n-        int off = 0;\n-        int len;\n-        while ((len = bufStream.read(buf, off, buf.length)) != -1) {\n-            off += len;\n-        }\n-    }\n-}\n", "next_change": {"commit": "d1282d881cd3c66d40233cebd06c64b28ad0b528", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\nnew file mode 100644\nindex 00000000000..eea7079496e\n--- /dev/null\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/util/HeadHandler.java\n", "chunk": "@@ -0,0 +1,109 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * The purpose of this class is to provide {@code StreamHandler} that limits the output\n+ * to specified number of lines. Compared to {@code SpoolHandler} it consumes\n+ * limited amount of heap.\n+ */\n+public class HeadHandler implements Executor.StreamHandler {\n+    private final int maxLines;\n+\n+    private final List<String> lines = new ArrayList<>();\n+    private final Charset charset;\n+\n+    private static final int bufferedReaderSize = 200;\n+\n+    /**\n+     * Charset of the underlying reader is set to UTF-8.\n+     * @param maxLines maximum number of lines to store\n+     */\n+    public HeadHandler(int maxLines) {\n+        this.maxLines = maxLines;\n+        this.charset = StandardCharsets.UTF_8;\n+    }\n+\n+    /**\n+     * @param maxLines maximum number of lines to store\n+     * @param charset character set\n+     */\n+    public HeadHandler(int maxLines, Charset charset) {\n+        this.maxLines = maxLines;\n+        this.charset = charset;\n+    }\n+\n+    /**\n+     * @return number of lines read\n+     */\n+    public int count() {\n+        return lines.size();\n+    }\n+\n+    /**\n+     * @param index index\n+     * @return line at given index. Will be non {@code null} for valid index.\n+     */\n+    public String get(int index) {\n+        return lines.get(index);\n+    }\n+\n+    // for testing\n+    static int getBufferedReaderSize() {\n+        return bufferedReaderSize;\n+    }\n+\n+    @Override\n+    public void processStream(InputStream input) throws IOException {\n+        try (BufferedInputStream bufStream = new BufferedInputStream(input);\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(bufStream, this.charset),\n+                bufferedReaderSize)) {\n+            int lineNum = 0;\n+            while (lineNum < maxLines) {\n+                String line = reader.readLine();\n+                if (line == null) { // EOF\n+                    return;\n+                }\n+                lines.add(line);\n+                lineNum++;\n+            }\n+\n+            // Read and forget the rest.\n+            byte[] buf = new byte[1024];\n+            while ((bufStream.read(buf)) != -1) {\n+                ;\n+            }\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyNDA2Mw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r389324063", "body": "Iterating in the conditional possibly miscounts since one last `read()` is done to get the `-1`. ", "bodyText": "Iterating in the conditional possibly miscounts since one last read() is done to get the -1.", "bodyHTML": "<p dir=\"auto\">Iterating in the conditional possibly miscounts since one last <code>read()</code> is done to get the <code>-1</code>.</p>", "author": "idodeclare", "createdAt": "2020-03-08T00:47:26Z", "path": "opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class HeadHandlerTest {\n+    private class RandomInputStream extends InputStream {\n+        private final int maxcount;\n+        private int count;\n+        private final int maxlines;\n+        private int lines;\n+\n+        private String letters;\n+\n+        public RandomInputStream(int count, int lines) {\n+            this.maxcount = count;\n+            this.count = 0;\n+            this.maxlines = lines;\n+            this.lines = 0;\n+\n+            letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+            letters = letters + letters.toLowerCase();\n+            letters = letters + \"0123456789\";\n+        }\n+\n+        public int getCount() {\n+            return count;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            if (++count < maxcount) {", "originalCommit": "f484af98af0ba0a2349ca04b8d3e694107b4cc54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQwNDU2NQ==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r390404565", "bodyText": "yes. was rough.", "author": "vladak", "createdAt": "2020-03-10T15:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyNDA2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java b/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\ndeleted file mode 100644\nindex dea40fdb21b..00000000000\n--- a/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\n+++ /dev/null\n", "chunk": "@@ -1,91 +0,0 @@\n-/*\n- * CDDL HEADER START\n- *\n- * The contents of this file are subject to the terms of the\n- * Common Development and Distribution License (the \"License\").\n- * You may not use this file except in compliance with the License.\n- *\n- * See LICENSE.txt included in this distribution for the specific\n- * language governing permissions and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL HEADER in each\n- * file and include the License file at LICENSE.txt.\n- * If applicable, add the following below this CDDL HEADER, with the\n- * fields enclosed by brackets \"[]\" replaced with your own identifying\n- * information: Portions Copyright [yyyy] [name of copyright owner]\n- *\n- * CDDL HEADER END\n- */\n-\n-/*\n- * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n- */\n-\n-package org.opengrok.indexer.util;\n-\n-import org.junit.Test;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class HeadHandlerTest {\n-    private class RandomInputStream extends InputStream {\n-        private final int maxcount;\n-        private int count;\n-        private final int maxlines;\n-        private int lines;\n-\n-        private String letters;\n-\n-        public RandomInputStream(int count, int lines) {\n-            this.maxcount = count;\n-            this.count = 0;\n-            this.maxlines = lines;\n-            this.lines = 0;\n-\n-            letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n-            letters = letters + letters.toLowerCase();\n-            letters = letters + \"0123456789\";\n-        }\n-\n-        public int getCount() {\n-            return count;\n-        }\n-\n-        @Override\n-        public int read() throws IOException {\n-            if (++count < maxcount) {\n-                // Want the newlines to appear within the first half.\n-                if (count % ((maxcount / 2) / maxlines) == 0) {\n-                    return '\\n';\n-                } else {\n-                    return letters.charAt((int) (Math.random() % letters.length()));\n-                }\n-            }\n-\n-            return -1;\n-        }\n-    }\n-\n-    @Test\n-    public void testHeadHandler() throws IOException {\n-        final int lines = 5;\n-        final int headLines = 3;\n-        int totalCount = 8192;\n-\n-        RandomInputStream rndStream = new RandomInputStream(totalCount, lines);\n-        HeadHandler handler = new HeadHandler(headLines);\n-        assertTrue(totalCount > handler.getBufferedReaderSize());\n-        handler.processStream(rndStream);\n-        assertEquals(headLines, handler.size());\n-        assertEquals(totalCount + 1, rndStream.getCount());\n-        int linesLen = 0;\n-        for (int i = 0; i < headLines; i++) {\n-            linesLen += handler.get(i).length();\n-        }\n-        assertTrue(linesLen < totalCount / 2);\n-    }\n-}\n", "next_change": {"commit": "d1282d881cd3c66d40233cebd06c64b28ad0b528", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java b/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\nnew file mode 100644\nindex 00000000000..32f6626330c\n--- /dev/null\n+++ b/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\n", "chunk": "@@ -0,0 +1,178 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.opengrok.indexer.logger.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test the behavior of the {@code HeadHandler} class. The main aspect to check is that the\n+ * input stream is read whole.\n+ */\n+@RunWith(Parameterized.class)\n+public class HeadHandlerTest {\n+    @Parameterized.Parameters\n+    public static Collection<Object[]> data() {\n+        List<Object[]> tests = new ArrayList<>();\n+        for (int i = 0; i < ThreadLocalRandom.current().nextInt(4, 8); i++) {\n+            tests.add(new Object[]{ThreadLocalRandom.current().nextInt(2, 10),\n+                    ThreadLocalRandom.current().nextInt(1, 10),\n+                    HeadHandler.getBufferedReaderSize() * ThreadLocalRandom.current().nextInt(1, 40)});\n+        }\n+        return tests;\n+    }\n+\n+    private int lineCnt;\n+    private int headLineCnt;\n+    private int totalCharCount;\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HeadHandlerTest.class);\n+\n+    /**\n+     * @param lineCnt number of lines to generate\n+     * @param headLineCnt maximum number of lines to get\n+     */\n+    public HeadHandlerTest(int lineCnt, int headLineCnt, int totalCharCount) {\n+        this.lineCnt = lineCnt;\n+        this.headLineCnt = headLineCnt;\n+        this.totalCharCount = totalCharCount;\n+    }\n+\n+    private static class RandomInputStream extends InputStream {\n+        private final int maxCharCount;\n+        private int charCount;\n+        private final int maxLines;\n+        private int lines;\n+\n+        private final String letters;\n+\n+        private static final String alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+        private static final String numbers = \"0123456789\";\n+\n+        private String result = \"\";\n+\n+        int[] lineBreaks;\n+\n+        /**\n+         * Generate alphanumeric characters.\n+         * @param maxCharCount number of characters to generate\n+         * @param maxLines number of lines to generate\n+         */\n+        public RandomInputStream(int maxCharCount, int maxLines) {\n+            if (maxLines > maxCharCount) {\n+                throw new IllegalArgumentException(\"maxLines must be smaller than or equal to maxCharCount\");\n+            }\n+\n+            if (maxCharCount <= 0) {\n+                throw new IllegalArgumentException(\"maxCharCount must be positive number\");\n+            }\n+\n+            if (maxLines <= 1) {\n+                throw new IllegalArgumentException(\"maxLines must be strictly bigger than 1\");\n+            }\n+\n+            this.maxCharCount = maxCharCount;\n+            this.charCount = 0;\n+            this.maxLines = maxLines;\n+            this.lines = 0;\n+\n+            letters = alpha + alpha.toLowerCase() + numbers;\n+\n+            // Want the newlines generally to appear within the first half of the generated data\n+            // so that the handler has significant amount of data to read after it is done reading the lines.\n+            lineBreaks = new int[maxLines - 1];\n+            for (int i = 0; i < lineBreaks.length; i++) {\n+                lineBreaks[i] = ThreadLocalRandom.current().nextInt(1, maxCharCount / 2);\n+            }\n+        }\n+\n+        int getCharCount() {\n+            return charCount;\n+        }\n+\n+        String getResult() {\n+            return result;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            int ret;\n+            if (charCount < maxCharCount) {\n+                if (charCount > 0 && lines < maxLines - 1 && charCount == lineBreaks[lines]) {\n+                    ret = '\\n';\n+                    lines++;\n+                } else {\n+                    ret = letters.charAt(ThreadLocalRandom.current().nextInt(0, letters.length()));\n+                }\n+                result += String.format(\"%c\", ret);\n+                charCount++;\n+                return ret;\n+            }\n+\n+            return -1;\n+        }\n+    }\n+\n+    @Test\n+    public void testHeadHandler() throws IOException {\n+        LOGGER.log(Level.INFO, \"testing HeadHandler with: {0}/{1}/{2}\",\n+                new Object[]{lineCnt, headLineCnt, totalCharCount});\n+\n+        RandomInputStream rndStream = new RandomInputStream(totalCharCount, lineCnt);\n+        HeadHandler handler = new HeadHandler(headLineCnt);\n+        assertTrue(totalCharCount >= HeadHandler.getBufferedReaderSize(),\n+                \"number of characters to generate must be bigger than \" +\n+                        \"HeadHandler internal buffer size\");\n+        handler.processStream(rndStream);\n+        assertTrue(handler.count() <= headLineCnt,\n+                \"HeadHandler should not get more lines than was asked to\");\n+        assertEquals(totalCharCount, rndStream.getCharCount(),\n+                \"HeadHandler should read all the characters from input stream\");\n+        String[] headLines = new String[handler.count()];\n+        for (int i = 0; i < handler.count(); i++) {\n+            String line = handler.get(i);\n+            LOGGER.log(Level.INFO, \"line [{0}]: {1}\", new Object[]{i, line});\n+            headLines[i] = line;\n+        }\n+        assertArrayEquals(headLines,\n+                Arrays.copyOfRange(rndStream.getResult().split(\"\\n\"), 0, handler.count()),\n+                \"the lines retrieved by HeadHandler needs to match the input\");\n+    }\n+}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyNDQyMA==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r389324420", "body": "Perhaps some randomness in line lengths?", "bodyText": "Perhaps some randomness in line lengths?", "bodyHTML": "<p dir=\"auto\">Perhaps some randomness in line lengths?</p>", "author": "idodeclare", "createdAt": "2020-03-08T00:55:36Z", "path": "opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class HeadHandlerTest {\n+    private class RandomInputStream extends InputStream {\n+        private final int maxcount;\n+        private int count;\n+        private final int maxlines;\n+        private int lines;\n+\n+        private String letters;\n+\n+        public RandomInputStream(int count, int lines) {\n+            this.maxcount = count;\n+            this.count = 0;\n+            this.maxlines = lines;\n+            this.lines = 0;\n+\n+            letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+            letters = letters + letters.toLowerCase();\n+            letters = letters + \"0123456789\";\n+        }\n+\n+        public int getCount() {\n+            return count;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            if (++count < maxcount) {\n+                // Want the newlines to appear within the first half.\n+                if (count % ((maxcount / 2) / maxlines) == 0) {", "originalCommit": "f484af98af0ba0a2349ca04b8d3e694107b4cc54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQxOTA5Ng==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r390419096", "bodyText": "good idea. I should randomize the test cases' parameters too.", "author": "vladak", "createdAt": "2020-03-10T15:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyNDQyMA=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java b/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\ndeleted file mode 100644\nindex dea40fdb21b..00000000000\n--- a/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\n+++ /dev/null\n", "chunk": "@@ -1,91 +0,0 @@\n-/*\n- * CDDL HEADER START\n- *\n- * The contents of this file are subject to the terms of the\n- * Common Development and Distribution License (the \"License\").\n- * You may not use this file except in compliance with the License.\n- *\n- * See LICENSE.txt included in this distribution for the specific\n- * language governing permissions and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL HEADER in each\n- * file and include the License file at LICENSE.txt.\n- * If applicable, add the following below this CDDL HEADER, with the\n- * fields enclosed by brackets \"[]\" replaced with your own identifying\n- * information: Portions Copyright [yyyy] [name of copyright owner]\n- *\n- * CDDL HEADER END\n- */\n-\n-/*\n- * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n- */\n-\n-package org.opengrok.indexer.util;\n-\n-import org.junit.Test;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class HeadHandlerTest {\n-    private class RandomInputStream extends InputStream {\n-        private final int maxcount;\n-        private int count;\n-        private final int maxlines;\n-        private int lines;\n-\n-        private String letters;\n-\n-        public RandomInputStream(int count, int lines) {\n-            this.maxcount = count;\n-            this.count = 0;\n-            this.maxlines = lines;\n-            this.lines = 0;\n-\n-            letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n-            letters = letters + letters.toLowerCase();\n-            letters = letters + \"0123456789\";\n-        }\n-\n-        public int getCount() {\n-            return count;\n-        }\n-\n-        @Override\n-        public int read() throws IOException {\n-            if (++count < maxcount) {\n-                // Want the newlines to appear within the first half.\n-                if (count % ((maxcount / 2) / maxlines) == 0) {\n-                    return '\\n';\n-                } else {\n-                    return letters.charAt((int) (Math.random() % letters.length()));\n-                }\n-            }\n-\n-            return -1;\n-        }\n-    }\n-\n-    @Test\n-    public void testHeadHandler() throws IOException {\n-        final int lines = 5;\n-        final int headLines = 3;\n-        int totalCount = 8192;\n-\n-        RandomInputStream rndStream = new RandomInputStream(totalCount, lines);\n-        HeadHandler handler = new HeadHandler(headLines);\n-        assertTrue(totalCount > handler.getBufferedReaderSize());\n-        handler.processStream(rndStream);\n-        assertEquals(headLines, handler.size());\n-        assertEquals(totalCount + 1, rndStream.getCount());\n-        int linesLen = 0;\n-        for (int i = 0; i < headLines; i++) {\n-            linesLen += handler.get(i).length();\n-        }\n-        assertTrue(linesLen < totalCount / 2);\n-    }\n-}\n", "next_change": {"commit": "d1282d881cd3c66d40233cebd06c64b28ad0b528", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java b/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\nnew file mode 100644\nindex 00000000000..32f6626330c\n--- /dev/null\n+++ b/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\n", "chunk": "@@ -0,0 +1,178 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.opengrok.indexer.logger.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test the behavior of the {@code HeadHandler} class. The main aspect to check is that the\n+ * input stream is read whole.\n+ */\n+@RunWith(Parameterized.class)\n+public class HeadHandlerTest {\n+    @Parameterized.Parameters\n+    public static Collection<Object[]> data() {\n+        List<Object[]> tests = new ArrayList<>();\n+        for (int i = 0; i < ThreadLocalRandom.current().nextInt(4, 8); i++) {\n+            tests.add(new Object[]{ThreadLocalRandom.current().nextInt(2, 10),\n+                    ThreadLocalRandom.current().nextInt(1, 10),\n+                    HeadHandler.getBufferedReaderSize() * ThreadLocalRandom.current().nextInt(1, 40)});\n+        }\n+        return tests;\n+    }\n+\n+    private int lineCnt;\n+    private int headLineCnt;\n+    private int totalCharCount;\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HeadHandlerTest.class);\n+\n+    /**\n+     * @param lineCnt number of lines to generate\n+     * @param headLineCnt maximum number of lines to get\n+     */\n+    public HeadHandlerTest(int lineCnt, int headLineCnt, int totalCharCount) {\n+        this.lineCnt = lineCnt;\n+        this.headLineCnt = headLineCnt;\n+        this.totalCharCount = totalCharCount;\n+    }\n+\n+    private static class RandomInputStream extends InputStream {\n+        private final int maxCharCount;\n+        private int charCount;\n+        private final int maxLines;\n+        private int lines;\n+\n+        private final String letters;\n+\n+        private static final String alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+        private static final String numbers = \"0123456789\";\n+\n+        private String result = \"\";\n+\n+        int[] lineBreaks;\n+\n+        /**\n+         * Generate alphanumeric characters.\n+         * @param maxCharCount number of characters to generate\n+         * @param maxLines number of lines to generate\n+         */\n+        public RandomInputStream(int maxCharCount, int maxLines) {\n+            if (maxLines > maxCharCount) {\n+                throw new IllegalArgumentException(\"maxLines must be smaller than or equal to maxCharCount\");\n+            }\n+\n+            if (maxCharCount <= 0) {\n+                throw new IllegalArgumentException(\"maxCharCount must be positive number\");\n+            }\n+\n+            if (maxLines <= 1) {\n+                throw new IllegalArgumentException(\"maxLines must be strictly bigger than 1\");\n+            }\n+\n+            this.maxCharCount = maxCharCount;\n+            this.charCount = 0;\n+            this.maxLines = maxLines;\n+            this.lines = 0;\n+\n+            letters = alpha + alpha.toLowerCase() + numbers;\n+\n+            // Want the newlines generally to appear within the first half of the generated data\n+            // so that the handler has significant amount of data to read after it is done reading the lines.\n+            lineBreaks = new int[maxLines - 1];\n+            for (int i = 0; i < lineBreaks.length; i++) {\n+                lineBreaks[i] = ThreadLocalRandom.current().nextInt(1, maxCharCount / 2);\n+            }\n+        }\n+\n+        int getCharCount() {\n+            return charCount;\n+        }\n+\n+        String getResult() {\n+            return result;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            int ret;\n+            if (charCount < maxCharCount) {\n+                if (charCount > 0 && lines < maxLines - 1 && charCount == lineBreaks[lines]) {\n+                    ret = '\\n';\n+                    lines++;\n+                } else {\n+                    ret = letters.charAt(ThreadLocalRandom.current().nextInt(0, letters.length()));\n+                }\n+                result += String.format(\"%c\", ret);\n+                charCount++;\n+                return ret;\n+            }\n+\n+            return -1;\n+        }\n+    }\n+\n+    @Test\n+    public void testHeadHandler() throws IOException {\n+        LOGGER.log(Level.INFO, \"testing HeadHandler with: {0}/{1}/{2}\",\n+                new Object[]{lineCnt, headLineCnt, totalCharCount});\n+\n+        RandomInputStream rndStream = new RandomInputStream(totalCharCount, lineCnt);\n+        HeadHandler handler = new HeadHandler(headLineCnt);\n+        assertTrue(totalCharCount >= HeadHandler.getBufferedReaderSize(),\n+                \"number of characters to generate must be bigger than \" +\n+                        \"HeadHandler internal buffer size\");\n+        handler.processStream(rndStream);\n+        assertTrue(handler.count() <= headLineCnt,\n+                \"HeadHandler should not get more lines than was asked to\");\n+        assertEquals(totalCharCount, rndStream.getCharCount(),\n+                \"HeadHandler should read all the characters from input stream\");\n+        String[] headLines = new String[handler.count()];\n+        for (int i = 0; i < handler.count(); i++) {\n+            String line = handler.get(i);\n+            LOGGER.log(Level.INFO, \"line [{0}]: {1}\", new Object[]{i, line});\n+            headLines[i] = line;\n+        }\n+        assertArrayEquals(headLines,\n+                Arrays.copyOfRange(rndStream.getResult().split(\"\\n\"), 0, handler.count()),\n+                \"the lines retrieved by HeadHandler needs to match the input\");\n+    }\n+}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyNDUxMw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r389324513", "body": "This might always result in 0 using `%`.", "bodyText": "This might always result in 0 using %.", "bodyHTML": "<p dir=\"auto\">This might always result in 0 using <code>%</code>.</p>", "author": "idodeclare", "createdAt": "2020-03-08T00:57:30Z", "path": "opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class HeadHandlerTest {\n+    private class RandomInputStream extends InputStream {\n+        private final int maxcount;\n+        private int count;\n+        private final int maxlines;\n+        private int lines;\n+\n+        private String letters;\n+\n+        public RandomInputStream(int count, int lines) {\n+            this.maxcount = count;\n+            this.count = 0;\n+            this.maxlines = lines;\n+            this.lines = 0;\n+\n+            letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+            letters = letters + letters.toLowerCase();\n+            letters = letters + \"0123456789\";\n+        }\n+\n+        public int getCount() {\n+            return count;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            if (++count < maxcount) {\n+                // Want the newlines to appear within the first half.\n+                if (count % ((maxcount / 2) / maxlines) == 0) {\n+                    return '\\n';\n+                } else {\n+                    return letters.charAt((int) (Math.random() % letters.length()));", "originalCommit": "f484af98af0ba0a2349ca04b8d3e694107b4cc54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java b/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\ndeleted file mode 100644\nindex dea40fdb21b..00000000000\n--- a/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\n+++ /dev/null\n", "chunk": "@@ -1,91 +0,0 @@\n-/*\n- * CDDL HEADER START\n- *\n- * The contents of this file are subject to the terms of the\n- * Common Development and Distribution License (the \"License\").\n- * You may not use this file except in compliance with the License.\n- *\n- * See LICENSE.txt included in this distribution for the specific\n- * language governing permissions and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL HEADER in each\n- * file and include the License file at LICENSE.txt.\n- * If applicable, add the following below this CDDL HEADER, with the\n- * fields enclosed by brackets \"[]\" replaced with your own identifying\n- * information: Portions Copyright [yyyy] [name of copyright owner]\n- *\n- * CDDL HEADER END\n- */\n-\n-/*\n- * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n- */\n-\n-package org.opengrok.indexer.util;\n-\n-import org.junit.Test;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class HeadHandlerTest {\n-    private class RandomInputStream extends InputStream {\n-        private final int maxcount;\n-        private int count;\n-        private final int maxlines;\n-        private int lines;\n-\n-        private String letters;\n-\n-        public RandomInputStream(int count, int lines) {\n-            this.maxcount = count;\n-            this.count = 0;\n-            this.maxlines = lines;\n-            this.lines = 0;\n-\n-            letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n-            letters = letters + letters.toLowerCase();\n-            letters = letters + \"0123456789\";\n-        }\n-\n-        public int getCount() {\n-            return count;\n-        }\n-\n-        @Override\n-        public int read() throws IOException {\n-            if (++count < maxcount) {\n-                // Want the newlines to appear within the first half.\n-                if (count % ((maxcount / 2) / maxlines) == 0) {\n-                    return '\\n';\n-                } else {\n-                    return letters.charAt((int) (Math.random() % letters.length()));\n-                }\n-            }\n-\n-            return -1;\n-        }\n-    }\n-\n-    @Test\n-    public void testHeadHandler() throws IOException {\n-        final int lines = 5;\n-        final int headLines = 3;\n-        int totalCount = 8192;\n-\n-        RandomInputStream rndStream = new RandomInputStream(totalCount, lines);\n-        HeadHandler handler = new HeadHandler(headLines);\n-        assertTrue(totalCount > handler.getBufferedReaderSize());\n-        handler.processStream(rndStream);\n-        assertEquals(headLines, handler.size());\n-        assertEquals(totalCount + 1, rndStream.getCount());\n-        int linesLen = 0;\n-        for (int i = 0; i < headLines; i++) {\n-            linesLen += handler.get(i).length();\n-        }\n-        assertTrue(linesLen < totalCount / 2);\n-    }\n-}\n", "next_change": {"commit": "d1282d881cd3c66d40233cebd06c64b28ad0b528", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java b/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\nnew file mode 100644\nindex 00000000000..32f6626330c\n--- /dev/null\n+++ b/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\n", "chunk": "@@ -0,0 +1,178 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.opengrok.indexer.logger.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test the behavior of the {@code HeadHandler} class. The main aspect to check is that the\n+ * input stream is read whole.\n+ */\n+@RunWith(Parameterized.class)\n+public class HeadHandlerTest {\n+    @Parameterized.Parameters\n+    public static Collection<Object[]> data() {\n+        List<Object[]> tests = new ArrayList<>();\n+        for (int i = 0; i < ThreadLocalRandom.current().nextInt(4, 8); i++) {\n+            tests.add(new Object[]{ThreadLocalRandom.current().nextInt(2, 10),\n+                    ThreadLocalRandom.current().nextInt(1, 10),\n+                    HeadHandler.getBufferedReaderSize() * ThreadLocalRandom.current().nextInt(1, 40)});\n+        }\n+        return tests;\n+    }\n+\n+    private int lineCnt;\n+    private int headLineCnt;\n+    private int totalCharCount;\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HeadHandlerTest.class);\n+\n+    /**\n+     * @param lineCnt number of lines to generate\n+     * @param headLineCnt maximum number of lines to get\n+     */\n+    public HeadHandlerTest(int lineCnt, int headLineCnt, int totalCharCount) {\n+        this.lineCnt = lineCnt;\n+        this.headLineCnt = headLineCnt;\n+        this.totalCharCount = totalCharCount;\n+    }\n+\n+    private static class RandomInputStream extends InputStream {\n+        private final int maxCharCount;\n+        private int charCount;\n+        private final int maxLines;\n+        private int lines;\n+\n+        private final String letters;\n+\n+        private static final String alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+        private static final String numbers = \"0123456789\";\n+\n+        private String result = \"\";\n+\n+        int[] lineBreaks;\n+\n+        /**\n+         * Generate alphanumeric characters.\n+         * @param maxCharCount number of characters to generate\n+         * @param maxLines number of lines to generate\n+         */\n+        public RandomInputStream(int maxCharCount, int maxLines) {\n+            if (maxLines > maxCharCount) {\n+                throw new IllegalArgumentException(\"maxLines must be smaller than or equal to maxCharCount\");\n+            }\n+\n+            if (maxCharCount <= 0) {\n+                throw new IllegalArgumentException(\"maxCharCount must be positive number\");\n+            }\n+\n+            if (maxLines <= 1) {\n+                throw new IllegalArgumentException(\"maxLines must be strictly bigger than 1\");\n+            }\n+\n+            this.maxCharCount = maxCharCount;\n+            this.charCount = 0;\n+            this.maxLines = maxLines;\n+            this.lines = 0;\n+\n+            letters = alpha + alpha.toLowerCase() + numbers;\n+\n+            // Want the newlines generally to appear within the first half of the generated data\n+            // so that the handler has significant amount of data to read after it is done reading the lines.\n+            lineBreaks = new int[maxLines - 1];\n+            for (int i = 0; i < lineBreaks.length; i++) {\n+                lineBreaks[i] = ThreadLocalRandom.current().nextInt(1, maxCharCount / 2);\n+            }\n+        }\n+\n+        int getCharCount() {\n+            return charCount;\n+        }\n+\n+        String getResult() {\n+            return result;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            int ret;\n+            if (charCount < maxCharCount) {\n+                if (charCount > 0 && lines < maxLines - 1 && charCount == lineBreaks[lines]) {\n+                    ret = '\\n';\n+                    lines++;\n+                } else {\n+                    ret = letters.charAt(ThreadLocalRandom.current().nextInt(0, letters.length()));\n+                }\n+                result += String.format(\"%c\", ret);\n+                charCount++;\n+                return ret;\n+            }\n+\n+            return -1;\n+        }\n+    }\n+\n+    @Test\n+    public void testHeadHandler() throws IOException {\n+        LOGGER.log(Level.INFO, \"testing HeadHandler with: {0}/{1}/{2}\",\n+                new Object[]{lineCnt, headLineCnt, totalCharCount});\n+\n+        RandomInputStream rndStream = new RandomInputStream(totalCharCount, lineCnt);\n+        HeadHandler handler = new HeadHandler(headLineCnt);\n+        assertTrue(totalCharCount >= HeadHandler.getBufferedReaderSize(),\n+                \"number of characters to generate must be bigger than \" +\n+                        \"HeadHandler internal buffer size\");\n+        handler.processStream(rndStream);\n+        assertTrue(handler.count() <= headLineCnt,\n+                \"HeadHandler should not get more lines than was asked to\");\n+        assertEquals(totalCharCount, rndStream.getCharCount(),\n+                \"HeadHandler should read all the characters from input stream\");\n+        String[] headLines = new String[handler.count()];\n+        for (int i = 0; i < handler.count(); i++) {\n+            String line = handler.get(i);\n+            LOGGER.log(Level.INFO, \"line [{0}]: {1}\", new Object[]{i, line});\n+            headLines[i] = line;\n+        }\n+        assertArrayEquals(headLines,\n+                Arrays.copyOfRange(rndStream.getResult().split(\"\\n\"), 0, handler.count()),\n+                \"the lines retrieved by HeadHandler needs to match the input\");\n+    }\n+}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyNDgzNw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r389324837", "body": "With this approach using randomness, I wonder if it would be informative to compare the line content to what was generated.", "bodyText": "With this approach using randomness, I wonder if it would be informative to compare the line content to what was generated.", "bodyHTML": "<p dir=\"auto\">With this approach using randomness, I wonder if it would be informative to compare the line content to what was generated.</p>", "author": "idodeclare", "createdAt": "2020-03-08T01:05:00Z", "path": "opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class HeadHandlerTest {\n+    private class RandomInputStream extends InputStream {\n+        private final int maxcount;\n+        private int count;\n+        private final int maxlines;\n+        private int lines;\n+\n+        private String letters;\n+\n+        public RandomInputStream(int count, int lines) {\n+            this.maxcount = count;\n+            this.count = 0;\n+            this.maxlines = lines;\n+            this.lines = 0;\n+\n+            letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+            letters = letters + letters.toLowerCase();\n+            letters = letters + \"0123456789\";\n+        }\n+\n+        public int getCount() {\n+            return count;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            if (++count < maxcount) {\n+                // Want the newlines to appear within the first half.\n+                if (count % ((maxcount / 2) / maxlines) == 0) {\n+                    return '\\n';\n+                } else {\n+                    return letters.charAt((int) (Math.random() % letters.length()));\n+                }\n+            }\n+\n+            return -1;\n+        }\n+    }\n+\n+    @Test\n+    public void testHeadHandler() throws IOException {\n+        final int lines = 5;\n+        final int headLines = 3;\n+        int totalCount = 8192;\n+\n+        RandomInputStream rndStream = new RandomInputStream(totalCount, lines);\n+        HeadHandler handler = new HeadHandler(headLines);\n+        assertTrue(totalCount > handler.getBufferedReaderSize());\n+        handler.processStream(rndStream);\n+        assertEquals(headLines, handler.size());\n+        assertEquals(totalCount + 1, rndStream.getCount());\n+        int linesLen = 0;\n+        for (int i = 0; i < headLines; i++) {\n+            linesLen += handler.get(i).length();", "originalCommit": "f484af98af0ba0a2349ca04b8d3e694107b4cc54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzNjUyNw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r389536527", "bodyText": "For me it seems a little much work for a test; I'd prepare some files as resources (perhaps with this generator) and assert the content.", "author": "tulinkry", "createdAt": "2020-03-09T09:14:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyNDgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1ODE5Nw==", "url": "https://github.com/oracle/opengrok/pull/3056#discussion_r389558197", "bodyText": "I wanted the test to adapt automatically based on changes to HeadHandler - in particular the internal buffer size.", "author": "vladak", "createdAt": "2020-03-09T09:56:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyNDgzNw=="}], "type": "inlineReview", "revised_code": {"commit": "c854253465724c0197b4cf4242c22c337345a0ee", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java b/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\ndeleted file mode 100644\nindex dea40fdb21b..00000000000\n--- a/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\n+++ /dev/null\n", "chunk": "@@ -1,91 +0,0 @@\n-/*\n- * CDDL HEADER START\n- *\n- * The contents of this file are subject to the terms of the\n- * Common Development and Distribution License (the \"License\").\n- * You may not use this file except in compliance with the License.\n- *\n- * See LICENSE.txt included in this distribution for the specific\n- * language governing permissions and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL HEADER in each\n- * file and include the License file at LICENSE.txt.\n- * If applicable, add the following below this CDDL HEADER, with the\n- * fields enclosed by brackets \"[]\" replaced with your own identifying\n- * information: Portions Copyright [yyyy] [name of copyright owner]\n- *\n- * CDDL HEADER END\n- */\n-\n-/*\n- * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n- */\n-\n-package org.opengrok.indexer.util;\n-\n-import org.junit.Test;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class HeadHandlerTest {\n-    private class RandomInputStream extends InputStream {\n-        private final int maxcount;\n-        private int count;\n-        private final int maxlines;\n-        private int lines;\n-\n-        private String letters;\n-\n-        public RandomInputStream(int count, int lines) {\n-            this.maxcount = count;\n-            this.count = 0;\n-            this.maxlines = lines;\n-            this.lines = 0;\n-\n-            letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n-            letters = letters + letters.toLowerCase();\n-            letters = letters + \"0123456789\";\n-        }\n-\n-        public int getCount() {\n-            return count;\n-        }\n-\n-        @Override\n-        public int read() throws IOException {\n-            if (++count < maxcount) {\n-                // Want the newlines to appear within the first half.\n-                if (count % ((maxcount / 2) / maxlines) == 0) {\n-                    return '\\n';\n-                } else {\n-                    return letters.charAt((int) (Math.random() % letters.length()));\n-                }\n-            }\n-\n-            return -1;\n-        }\n-    }\n-\n-    @Test\n-    public void testHeadHandler() throws IOException {\n-        final int lines = 5;\n-        final int headLines = 3;\n-        int totalCount = 8192;\n-\n-        RandomInputStream rndStream = new RandomInputStream(totalCount, lines);\n-        HeadHandler handler = new HeadHandler(headLines);\n-        assertTrue(totalCount > handler.getBufferedReaderSize());\n-        handler.processStream(rndStream);\n-        assertEquals(headLines, handler.size());\n-        assertEquals(totalCount + 1, rndStream.getCount());\n-        int linesLen = 0;\n-        for (int i = 0; i < headLines; i++) {\n-            linesLen += handler.get(i).length();\n-        }\n-        assertTrue(linesLen < totalCount / 2);\n-    }\n-}\n", "next_change": {"commit": "d1282d881cd3c66d40233cebd06c64b28ad0b528", "changed_code": [{"header": "diff --git a/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java b/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\nnew file mode 100644\nindex 00000000000..32f6626330c\n--- /dev/null\n+++ b/opengrok-indexer/src/test/java/org/opengrok/indexer/util/HeadHandlerTest.java\n", "chunk": "@@ -0,0 +1,178 @@\n+/*\n+ * CDDL HEADER START\n+ *\n+ * The contents of this file are subject to the terms of the\n+ * Common Development and Distribution License (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * See LICENSE.txt included in this distribution for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing Covered Code, include this CDDL HEADER in each\n+ * file and include the License file at LICENSE.txt.\n+ * If applicable, add the following below this CDDL HEADER, with the\n+ * fields enclosed by brackets \"[]\" replaced with your own identifying\n+ * information: Portions Copyright [yyyy] [name of copyright owner]\n+ *\n+ * CDDL HEADER END\n+ */\n+\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.opengrok.indexer.logger.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test the behavior of the {@code HeadHandler} class. The main aspect to check is that the\n+ * input stream is read whole.\n+ */\n+@RunWith(Parameterized.class)\n+public class HeadHandlerTest {\n+    @Parameterized.Parameters\n+    public static Collection<Object[]> data() {\n+        List<Object[]> tests = new ArrayList<>();\n+        for (int i = 0; i < ThreadLocalRandom.current().nextInt(4, 8); i++) {\n+            tests.add(new Object[]{ThreadLocalRandom.current().nextInt(2, 10),\n+                    ThreadLocalRandom.current().nextInt(1, 10),\n+                    HeadHandler.getBufferedReaderSize() * ThreadLocalRandom.current().nextInt(1, 40)});\n+        }\n+        return tests;\n+    }\n+\n+    private int lineCnt;\n+    private int headLineCnt;\n+    private int totalCharCount;\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HeadHandlerTest.class);\n+\n+    /**\n+     * @param lineCnt number of lines to generate\n+     * @param headLineCnt maximum number of lines to get\n+     */\n+    public HeadHandlerTest(int lineCnt, int headLineCnt, int totalCharCount) {\n+        this.lineCnt = lineCnt;\n+        this.headLineCnt = headLineCnt;\n+        this.totalCharCount = totalCharCount;\n+    }\n+\n+    private static class RandomInputStream extends InputStream {\n+        private final int maxCharCount;\n+        private int charCount;\n+        private final int maxLines;\n+        private int lines;\n+\n+        private final String letters;\n+\n+        private static final String alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+        private static final String numbers = \"0123456789\";\n+\n+        private String result = \"\";\n+\n+        int[] lineBreaks;\n+\n+        /**\n+         * Generate alphanumeric characters.\n+         * @param maxCharCount number of characters to generate\n+         * @param maxLines number of lines to generate\n+         */\n+        public RandomInputStream(int maxCharCount, int maxLines) {\n+            if (maxLines > maxCharCount) {\n+                throw new IllegalArgumentException(\"maxLines must be smaller than or equal to maxCharCount\");\n+            }\n+\n+            if (maxCharCount <= 0) {\n+                throw new IllegalArgumentException(\"maxCharCount must be positive number\");\n+            }\n+\n+            if (maxLines <= 1) {\n+                throw new IllegalArgumentException(\"maxLines must be strictly bigger than 1\");\n+            }\n+\n+            this.maxCharCount = maxCharCount;\n+            this.charCount = 0;\n+            this.maxLines = maxLines;\n+            this.lines = 0;\n+\n+            letters = alpha + alpha.toLowerCase() + numbers;\n+\n+            // Want the newlines generally to appear within the first half of the generated data\n+            // so that the handler has significant amount of data to read after it is done reading the lines.\n+            lineBreaks = new int[maxLines - 1];\n+            for (int i = 0; i < lineBreaks.length; i++) {\n+                lineBreaks[i] = ThreadLocalRandom.current().nextInt(1, maxCharCount / 2);\n+            }\n+        }\n+\n+        int getCharCount() {\n+            return charCount;\n+        }\n+\n+        String getResult() {\n+            return result;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            int ret;\n+            if (charCount < maxCharCount) {\n+                if (charCount > 0 && lines < maxLines - 1 && charCount == lineBreaks[lines]) {\n+                    ret = '\\n';\n+                    lines++;\n+                } else {\n+                    ret = letters.charAt(ThreadLocalRandom.current().nextInt(0, letters.length()));\n+                }\n+                result += String.format(\"%c\", ret);\n+                charCount++;\n+                return ret;\n+            }\n+\n+            return -1;\n+        }\n+    }\n+\n+    @Test\n+    public void testHeadHandler() throws IOException {\n+        LOGGER.log(Level.INFO, \"testing HeadHandler with: {0}/{1}/{2}\",\n+                new Object[]{lineCnt, headLineCnt, totalCharCount});\n+\n+        RandomInputStream rndStream = new RandomInputStream(totalCharCount, lineCnt);\n+        HeadHandler handler = new HeadHandler(headLineCnt);\n+        assertTrue(totalCharCount >= HeadHandler.getBufferedReaderSize(),\n+                \"number of characters to generate must be bigger than \" +\n+                        \"HeadHandler internal buffer size\");\n+        handler.processStream(rndStream);\n+        assertTrue(handler.count() <= headLineCnt,\n+                \"HeadHandler should not get more lines than was asked to\");\n+        assertEquals(totalCharCount, rndStream.getCharCount(),\n+                \"HeadHandler should read all the characters from input stream\");\n+        String[] headLines = new String[handler.count()];\n+        for (int i = 0; i < handler.count(); i++) {\n+            String line = handler.get(i);\n+            LOGGER.log(Level.INFO, \"line [{0}]: {1}\", new Object[]{i, line});\n+            headLines[i] = line;\n+        }\n+        assertArrayEquals(headLines,\n+                Arrays.copyOfRange(rndStream.getResult().split(\"\\n\"), 0, handler.count()),\n+                \"the lines retrieved by HeadHandler needs to match the input\");\n+    }\n+}\n", "next_change": null}]}}]}}, {"oid": "c854253465724c0197b4cf4242c22c337345a0ee", "url": "https://github.com/oracle/opengrok/commit/c854253465724c0197b4cf4242c22c337345a0ee", "message": "implement annotation API endpoint\n\nfixes #3046", "committedDate": "2020-03-12T13:39:46Z", "type": "commit"}, {"oid": "487fed8f0e78236c7bc21f37a7a03c2755d1b4e2", "url": "https://github.com/oracle/opengrok/commit/487fed8f0e78236c7bc21f37a7a03c2755d1b4e2", "message": "fix GitRepository#getFirstRevision()\n\n--max-count is applied before --reverse", "committedDate": "2020-03-12T13:39:46Z", "type": "commit"}, {"oid": "d1282d881cd3c66d40233cebd06c64b28ad0b528", "url": "https://github.com/oracle/opengrok/commit/d1282d881cd3c66d40233cebd06c64b28ad0b528", "message": "introduce HeadHandler, use it in GitRepository", "committedDate": "2020-03-12T13:41:35Z", "type": "commit"}, {"oid": "d1282d881cd3c66d40233cebd06c64b28ad0b528", "url": "https://github.com/oracle/opengrok/commit/d1282d881cd3c66d40233cebd06c64b28ad0b528", "message": "introduce HeadHandler, use it in GitRepository", "committedDate": "2020-03-12T13:41:35Z", "type": "forcePushed"}]}