{"pr_number": 11794, "pr_title": "[BEAM-9894] Add batch SnowflakeIO.Write to Java SDK", "pr_author": "purbanow", "pr_createdAt": "2020-05-22T08:04:56Z", "pr_url": "https://github.com/apache/beam/pull/11794", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEwNTI3NQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r429105275", "body": "Note: This file was moved to `services/SnowflakeServiceImpl.java`", "bodyText": "Note: This file was moved to services/SnowflakeServiceImpl.java", "bodyHTML": "<p dir=\"auto\">Note: This file was moved to <code>services/SnowflakeServiceImpl.java</code></p>", "author": "purbanow", "createdAt": "2020-05-22T08:11:05Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeServiceImpl.java", "diffHunk": "@@ -1,90 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.beam.sdk.io.snowflake;\n-\n-import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.function.Consumer;\n-import javax.sql.DataSource;\n-import org.apache.beam.sdk.transforms.SerializableFunction;\n-\n-/**\n- * Implemenation of {@link org.apache.beam.sdk.io.snowflake.SnowflakeService} used in production.\n- */\n-public class SnowflakeServiceImpl implements SnowflakeService {", "originalCommit": "2bb48aa16c1a579a5e39d1f464f410769e5143b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c845a2c9322dcdeab267beffc1eac707388eaa49", "url": "https://github.com/apache/beam/commit/c845a2c9322dcdeab267beffc1eac707388eaa49", "message": "[BEAM-9894] Add batch SnowflakeIO.Write to Java SDK", "committedDate": "2020-05-22T08:41:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMjE3Mg==", "url": "https://github.com/apache/beam/pull/11794#discussion_r430612172", "body": "I took only a very superficial look. Are you using CSV file imports to write to Snowflake? I would be concerned about types being properly encoded in the CSV (big integers, floats, bytes, date/time types, strings with newlines/quotes). Have you already considered how to deal with all types?", "bodyText": "I took only a very superficial look. Are you using CSV file imports to write to Snowflake? I would be concerned about types being properly encoded in the CSV (big integers, floats, bytes, date/time types, strings with newlines/quotes). Have you already considered how to deal with all types?", "bodyHTML": "<p dir=\"auto\">I took only a very superficial look. Are you using CSV file imports to write to Snowflake? I would be concerned about types being properly encoded in the CSV (big integers, floats, bytes, date/time types, strings with newlines/quotes). Have you already considered how to deal with all types?</p>", "author": "pabloem", "createdAt": "2020-05-26T18:14:11Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/CSVSink.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.snowflake;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.nio.channels.Channels;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Joiner;\n+\n+/** Implementation of {@link org.apache.beam.sdk.io.FileIO.Sink} for writing CSV. */\n+public class CSVSink implements FileIO.Sink<String> {", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4Njg4NQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r430886885", "bodyText": "Yes, we are using COPY INTO table with CSV format.\nCurrently, SnowflakeIO.write is constructed in a way that requires a particular table to exist in Snowflake before starting writing into Snowflake.\nIn one of the next Snowflake PR's we're planning to add the option for a user a possibility for passing table schema.", "author": "purbanow", "createdAt": "2020-05-27T06:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMjE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5NjUxMg==", "url": "https://github.com/apache/beam/pull/11794#discussion_r430996512", "bodyText": "Just a little nitpick!  This class really has nothing to do with CSV, other than writing a header line.  If you're going to add a schema (orient it towards Beam Row for example), you might want to swap it out for an Avro or Parquet file storage!\nThis would be a big change.  If you were to make this class private to your implementation, do you think it would be possible to swap it out for a schema-capable format transparently later?", "author": "RyanSkraba", "createdAt": "2020-05-27T09:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMjE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1Mjc5Mw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433652793", "bodyText": "Thanks for spotting this. I removed CSVSink class and start using .via(TextIO.sink()) .", "author": "purbanow", "createdAt": "2020-06-02T06:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMjE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczOTM2NA==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433739364", "bodyText": "In one of the PR's , we're planing to add create dispositions for tables  which is connected more with schema concept. Let's talk about it then :)", "author": "purbanow", "createdAt": "2020-06-02T09:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMjE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MzMwMA==", "url": "https://github.com/apache/beam/pull/11794#discussion_r430983300", "body": "Not backwards compatible on a non-`@Experimental` class.  Some of these would be easy to implement on top of `Location` with a  `@Deprecate` tag? \r\n\r\n(My personal opinion would be not to worry too much about it... put `@Experimental` on the SnowflakeIO?)\r\n\r\nThat being said, refactoring the two into a `Location` POJO doesn't really add a LOT of value and it might be more worthwhile to put it back to two separate configs.  Up to you!", "bodyText": "Not backwards compatible on a non-@Experimental class.  Some of these would be easy to implement on top of Location with a  @Deprecate tag?\n(My personal opinion would be not to worry too much about it... put @Experimental on the SnowflakeIO?)\nThat being said, refactoring the two into a Location POJO doesn't really add a LOT of value and it might be more worthwhile to put it back to two separate configs.  Up to you!", "bodyHTML": "<p dir=\"auto\">Not backwards compatible on a non-<code>@Experimental</code> class.  Some of these would be easy to implement on top of <code>Location</code> with a  <code>@Deprecate</code> tag?</p>\n<p dir=\"auto\">(My personal opinion would be not to worry too much about it... put <code>@Experimental</code> on the SnowflakeIO?)</p>\n<p dir=\"auto\">That being said, refactoring the two into a <code>Location</code> POJO doesn't really add a LOT of value and it might be more worthwhile to put it back to two separate configs.  Up to you!</p>", "author": "RyanSkraba", "createdAt": "2020-05-27T09:29:44Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -172,10 +230,7 @@\n     abstract String getTable();\n \n     @Nullable\n-    abstract String getIntegrationName();", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxODA3Ng==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433618076", "bodyText": "As you suggested I added @experimental annotation + removed Location class", "author": "purbanow", "createdAt": "2020-06-02T04:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MzMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NjM0Ng==", "url": "https://github.com/apache/beam/pull/11794#discussion_r430986346", "body": "The original `withStagingBucketName` and `withIntegrationName` had some useful javadoc and links!", "bodyText": "The original withStagingBucketName and withIntegrationName had some useful javadoc and links!", "bodyHTML": "<p dir=\"auto\">The original <code>withStagingBucketName</code> and <code>withIntegrationName</code> had some useful javadoc and links!</p>", "author": "RyanSkraba", "createdAt": "2020-05-27T09:34:38Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/Location.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.snowflake;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Used as one of the arguments for {@link org.apache.beam.sdk.io.snowflake.SnowflakeIO} write and\n+ * read operations. It keeps information about storage integration and staging bucket name.\n+ * Integration name is Snowflake storage integration object created according to Snowflake\n+ * documentation for the GCS bucket. Staging bucket name is Google Cloud Storage bucket which in the\n+ * case of writing operation will be used to save CSV files which will end up in Snowflake under\n+ * \u201cstaging_bucket_name/data\u201d path and in the case of reading operation will be used as a temporary\n+ * location for storing CSV files named `sf_copy_csv_DATE_TIME_RANDOMSUFFIX` which will be removed\n+ * automatically once Read operation finishes.\n+ */\n+public class Location implements Serializable {\n+  private String storageIntegrationName;\n+  private String stagingBucketName;\n+\n+  public static Location of(SnowflakePipelineOptions options) {\n+    return new Location(options.getStorageIntegrationName(), options.getStagingBucketName());\n+  }\n+\n+  public static Location of(String storageIntegrationName, String stagingBucketName) {", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQxMzUyMQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432413521", "bodyText": "I added removed link https://docs.snowflake.com/en/sql-reference/sql/create-storage-integration.html . Thanks", "author": "purbanow", "createdAt": "2020-05-29T11:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NjM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5NzMwNg==", "url": "https://github.com/apache/beam/pull/11794#discussion_r430997306", "body": "```suggestion\r\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/** Snowflake IO data types. */\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /** Snowflake IO data types. */\n          \n          \n            \n            /*\n          \n          \n            \n             * Licensed to the Apache Software Foundation (ASF) under one\n          \n          \n            \n             * or more contributor license agreements.  See the NOTICE file\n          \n          \n            \n             * distributed with this work for additional information\n          \n          \n            \n             * regarding copyright ownership.  The ASF licenses this file\n          \n          \n            \n             * to you under the Apache License, Version 2.0 (the\n          \n          \n            \n             * \"License\"); you may not use this file except in compliance\n          \n          \n            \n             * with the License.  You may obtain a copy of the License at\n          \n          \n            \n             *\n          \n          \n            \n             *     http://www.apache.org/licenses/LICENSE-2.0\n          \n          \n            \n             *\n          \n          \n            \n             * Unless required by applicable law or agreed to in writing, software\n          \n          \n            \n             * distributed under the License is distributed on an \"AS IS\" BASIS,\n          \n          \n            \n             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n          \n          \n            \n             * See the License for the specific language governing permissions and\n          \n          \n            \n             * limitations under the License.\n          \n          \n            \n             */\n          \n          \n            \n            \n          \n          \n            \n            /** Snowflake IO data types. */", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"19\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"pl-c\"><span class=\"pl-c\">/*</span><span class=\"x x-first\">* Snowflake IO data types. </span><span class=\"pl-c x x-last\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"19\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-c\"><span class=\"pl-c\">/*</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"20\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Licensed</span> to the <span class=\"pl-smi\">Apache</span> <span class=\"pl-smi\">Software</span> <span class=\"pl-smi\">Foundation</span> (<span class=\"pl-c1\">ASF</span>) under one</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"21\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> or more contributor license agreements.  <span class=\"pl-smi\">See</span> the <span class=\"pl-c1\">NOTICE</span> file</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"22\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> distributed with <span class=\"pl-c1\">this</span> work <span class=\"pl-k\">for</span> additional information</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"23\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> regarding copyright ownership.  <span class=\"pl-smi\">The</span> <span class=\"pl-c1\">ASF</span> licenses <span class=\"pl-c1\">this</span> file</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"24\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> to you under the <span class=\"pl-smi\">Apache</span> <span class=\"pl-smi\">License</span>, <span class=\"pl-smi\">Version</span> <span class=\"pl-c1\">2.0</span> (the</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"25\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>License<span class=\"pl-pds\">\"</span></span>); you may not use <span class=\"pl-c1\">this</span> file except in compliance</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"26\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> with the <span class=\"pl-smi\">License</span>.  <span class=\"pl-smi\">You</span> may obtain a copy of the <span class=\"pl-smi\">License</span> at</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"27\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"28\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span>     http<span class=\"pl-k\">:</span><span class=\"pl-c\"><span class=\"pl-c\">//</span>www.apache.org/licenses/LICENSE-2.0</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"29\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"30\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Unless</span> required by applicable law or agreed to in writing, software</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"31\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> distributed under the <span class=\"pl-smi\">License</span> is distributed on an <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>AS IS<span class=\"pl-pds\">\"</span></span> <span class=\"pl-c1\">BASIS</span>,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"32\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-c1\">WITHOUT</span> <span class=\"pl-c1\">WARRANTIES</span> <span class=\"pl-c1\">OR</span> <span class=\"pl-c1\">CONDITIONS</span> <span class=\"pl-c1\">OF</span> <span class=\"pl-c1\">ANY</span> <span class=\"pl-c1\">KIND</span>, either express or implied.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"33\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-smi\">See</span> the <span class=\"pl-smi\">License</span> <span class=\"pl-k\">for</span> the specific language governing permissions and</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"34\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> limitations under the <span class=\"pl-smi\">License</span>.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"35\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*/</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"36\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"37\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-c\"><span class=\"pl-c\">/*</span>* Snowflake IO data types. <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "RyanSkraba", "createdAt": "2020-05-27T09:53:27Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/enums/package-info.java", "diffHunk": "@@ -0,0 +1,2 @@\n+/** Snowflake IO data types. */", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQwNzg2Mg==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432407862", "bodyText": "Thanks for spotting this \ud83d\udc4d", "author": "purbanow", "createdAt": "2020-05-29T10:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5NzMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5NzU4Mw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r430997583", "body": "```suggestion\r\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/** Snowflake IO services and POJOs. */\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /** Snowflake IO services and POJOs. */\n          \n          \n            \n            /*\n          \n          \n            \n             * Licensed to the Apache Software Foundation (ASF) under one\n          \n          \n            \n             * or more contributor license agreements.  See the NOTICE file\n          \n          \n            \n             * distributed with this work for additional information\n          \n          \n            \n             * regarding copyright ownership.  The ASF licenses this file\n          \n          \n            \n             * to you under the Apache License, Version 2.0 (the\n          \n          \n            \n             * \"License\"); you may not use this file except in compliance\n          \n          \n            \n             * with the License.  You may obtain a copy of the License at\n          \n          \n            \n             *\n          \n          \n            \n             *     http://www.apache.org/licenses/LICENSE-2.0\n          \n          \n            \n             *\n          \n          \n            \n             * Unless required by applicable law or agreed to in writing, software\n          \n          \n            \n             * distributed under the License is distributed on an \"AS IS\" BASIS,\n          \n          \n            \n             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n          \n          \n            \n             * See the License for the specific language governing permissions and\n          \n          \n            \n             * limitations under the License.\n          \n          \n            \n             */\n          \n          \n            \n            \n          \n          \n            \n            /** Snowflake IO services and POJOs. */", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"19\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"pl-c\"><span class=\"pl-c\">/*</span><span class=\"x x-first\">* Snowflake IO services and POJOs. </span><span class=\"pl-c x x-last\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"19\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-c\"><span class=\"pl-c\">/*</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"20\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Licensed</span> to the <span class=\"pl-smi\">Apache</span> <span class=\"pl-smi\">Software</span> <span class=\"pl-smi\">Foundation</span> (<span class=\"pl-c1\">ASF</span>) under one</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"21\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> or more contributor license agreements.  <span class=\"pl-smi\">See</span> the <span class=\"pl-c1\">NOTICE</span> file</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"22\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> distributed with <span class=\"pl-c1\">this</span> work <span class=\"pl-k\">for</span> additional information</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"23\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> regarding copyright ownership.  <span class=\"pl-smi\">The</span> <span class=\"pl-c1\">ASF</span> licenses <span class=\"pl-c1\">this</span> file</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"24\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> to you under the <span class=\"pl-smi\">Apache</span> <span class=\"pl-smi\">License</span>, <span class=\"pl-smi\">Version</span> <span class=\"pl-c1\">2.0</span> (the</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"25\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>License<span class=\"pl-pds\">\"</span></span>); you may not use <span class=\"pl-c1\">this</span> file except in compliance</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"26\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> with the <span class=\"pl-smi\">License</span>.  <span class=\"pl-smi\">You</span> may obtain a copy of the <span class=\"pl-smi\">License</span> at</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"27\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"28\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span>     http<span class=\"pl-k\">:</span><span class=\"pl-c\"><span class=\"pl-c\">//</span>www.apache.org/licenses/LICENSE-2.0</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"29\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"30\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Unless</span> required by applicable law or agreed to in writing, software</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"31\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> distributed under the <span class=\"pl-smi\">License</span> is distributed on an <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>AS IS<span class=\"pl-pds\">\"</span></span> <span class=\"pl-c1\">BASIS</span>,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"32\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-c1\">WITHOUT</span> <span class=\"pl-c1\">WARRANTIES</span> <span class=\"pl-c1\">OR</span> <span class=\"pl-c1\">CONDITIONS</span> <span class=\"pl-c1\">OF</span> <span class=\"pl-c1\">ANY</span> <span class=\"pl-c1\">KIND</span>, either express or implied.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"33\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-smi\">See</span> the <span class=\"pl-smi\">License</span> <span class=\"pl-k\">for</span> the specific language governing permissions and</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"34\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> limitations under the <span class=\"pl-smi\">License</span>.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"35\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*/</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"36\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"37\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-c\"><span class=\"pl-c\">/*</span>* Snowflake IO services and POJOs. <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "RyanSkraba", "createdAt": "2020-05-27T09:54:00Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/services/package-info.java", "diffHunk": "@@ -0,0 +1,2 @@\n+/** Snowflake IO services and POJOs. */", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQwNzYzMQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432407631", "bodyText": "Thanks for spotting this.", "author": "purbanow", "createdAt": "2020-05-29T10:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5NzU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzNTE5OA==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431835198", "body": "It's not mandatory, but I've gotten used to seeing `@Nullable` annotations in Beam code!  This looks like it can be valid when null, but staging bucket doesn't.", "bodyText": "It's not mandatory, but I've gotten used to seeing @Nullable annotations in Beam code!  This looks like it can be valid when null, but staging bucket doesn't.", "bodyHTML": "<p dir=\"auto\">It's not mandatory, but I've gotten used to seeing <code>@Nullable</code> annotations in Beam code!  This looks like it can be valid when null, but staging bucket doesn't.</p>", "author": "RyanSkraba", "createdAt": "2020-05-28T13:30:06Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/Location.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.snowflake;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Used as one of the arguments for {@link org.apache.beam.sdk.io.snowflake.SnowflakeIO} write and\n+ * read operations. It keeps information about storage integration and staging bucket name.\n+ * Integration name is Snowflake storage integration object created according to Snowflake\n+ * documentation for the GCS bucket. Staging bucket name is Google Cloud Storage bucket which in the\n+ * case of writing operation will be used to save CSV files which will end up in Snowflake under\n+ * \u201cstaging_bucket_name/data\u201d path and in the case of reading operation will be used as a temporary\n+ * location for storing CSV files named `sf_copy_csv_DATE_TIME_RANDOMSUFFIX` which will be removed\n+ * automatically once Read operation finishes.\n+ */\n+public class Location implements Serializable {\n+  private String storageIntegrationName;", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ1MzUyNA==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432453524", "bodyText": "Yes, you're right. Thanks for spotting this.", "author": "purbanow", "createdAt": "2020-05-29T12:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzNTE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzODc0NQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431838745", "body": "I know we use `via` elsewhere in Beam code, but mostly for callback functions -- any reason why this wouldn't just be `withLocation` ?", "bodyText": "I know we use via elsewhere in Beam code, but mostly for callback functions -- any reason why this wouldn't just be withLocation ?", "bodyHTML": "<p dir=\"auto\">I know we use <code>via</code> elsewhere in Beam code, but mostly for callback functions -- any reason why this wouldn't just be <code>withLocation</code> ?</p>", "author": "RyanSkraba", "createdAt": "2020-05-28T13:35:19Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -257,23 +301,12 @@\n     }\n \n     /**\n-     * Name of the cloud bucket (GCS by now) to use as tmp location of CSVs during COPY statement.\n-     *\n-     * @param stagingBucketName - String with the name of the bucket.\n-     */\n-    public Read<T> withStagingBucketName(String stagingBucketName) {\n-      return toBuilder().setStagingBucketName(stagingBucketName).build();\n-    }\n-\n-    /**\n-     * Name of the Storage Integration in Snowflake to be used. See\n-     * https://docs.snowflake.com/en/sql-reference/sql/create-storage-integration.html for\n-     * reference.\n+     * A location object which contains connection config between Snowflake and GCP.\n      *\n-     * @param integrationName - String with the name of the Storage Integration.\n+     * @param location - an instance of {@link Location}.\n      */\n-    public Read<T> withIntegrationName(String integrationName) {\n-      return toBuilder().setIntegrationName(integrationName).build();\n+    public Read<T> via(Location location) {", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyMzY5NQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432423695", "bodyText": "No reason. I changed to withLocation  to be more consistent.", "author": "purbanow", "createdAt": "2020-05-29T11:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzODc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg0NTkxOA==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431845918", "body": "Hello!  Refactoring this part out into a separate method is odd -- the `loc` configuration is passed as a parameter while all the rest of the configurations are accessed as methods.  Were you going to reuse the location check at some point? As it is, it's inconsistent.\r\n\r\nAlso, storageIntegrationName must not be null.  Is that true?  Later, it's checked against null in `SnowflakeServiceImpl`", "bodyText": "Hello!  Refactoring this part out into a separate method is odd -- the loc configuration is passed as a parameter while all the rest of the configurations are accessed as methods.  Were you going to reuse the location check at some point? As it is, it's inconsistent.\nAlso, storageIntegrationName must not be null.  Is that true?  Later, it's checked against null in SnowflakeServiceImpl", "bodyHTML": "<p dir=\"auto\">Hello!  Refactoring this part out into a separate method is odd -- the <code>loc</code> configuration is passed as a parameter while all the rest of the configurations are accessed as methods.  Were you going to reuse the location check at some point? As it is, it's inconsistent.</p>\n<p dir=\"auto\">Also, storageIntegrationName must not be null.  Is that true?  Later, it's checked against null in <code>SnowflakeServiceImpl</code></p>", "author": "RyanSkraba", "createdAt": "2020-05-28T13:45:13Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -339,10 +360,31 @@\n       emptyCollection\n           .apply(Wait.on(output))\n           .apply(ParDo.of(new CleanTmpFilesFromGcsFn(stagingBucketDir)));\n-\n       return output;\n     }\n \n+    private void checkArguments(Location loc) {\n+      // Either table or query is required. If query is present, it's being used, table is used\n+      // otherwise\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ1NjgxMQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432456811", "bodyText": "I think it is more readable with separate method but i agree with you that is odd -- the loc configuration is passed as a parameter while all the rest of the configurations are accessed as methods. that's why I changed checkArguments method to stop accepting location as argument.\n\n\nSnowflakeIO.Read  requires storageIntegrationName  to be always set but SnowflakeIO.Write  doesn't require that.  The check against null in SnowflakeServiceImpl is corresponding to SnowflakeIO.Write  method", "author": "purbanow", "createdAt": "2020-05-29T12:43:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg0NTkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MTc0OA==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431851748", "body": "Likewise -- can this be nullable?", "bodyText": "Likewise -- can this be nullable?", "bodyHTML": "<p dir=\"auto\">Likewise -- can this be nullable?</p>", "author": "RyanSkraba", "createdAt": "2020-05-28T13:52:42Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ1ODQ3Nw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432458477", "bodyText": "Yes, it can be nullable for Write method. Thanks for spotting this :)", "author": "purbanow", "createdAt": "2020-05-29T12:46:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MTc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MzEyNg==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431853126", "body": "There's no `withTable()`  in Write, probably `to()`", "bodyText": "There's no withTable()  in Write, probably to()", "bodyHTML": "<p dir=\"auto\">There's no <code>withTable()</code>  in Write, probably <code>to()</code></p>", "author": "RyanSkraba", "createdAt": "2020-05-28T13:54:31Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");\n+      checkArgument(\n+          loc.getStagingBucketName() != null, \"location with stagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQzMjMwNg==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432432306", "bodyText": "Yes, you're right. I changed to() method to withTable() to be more consistent.", "author": "purbanow", "createdAt": "2020-05-29T11:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MzEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NTA3MA==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431855070", "body": "```suggestion\r\n    private PCollection write(PCollection<T> input, String stagingBucketDir) {\r\n```\r\nI'd consider collapsing this method into `expand` (the caller) or combining with `withFiles` below.  It doesn't add much by itself.", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private PCollection write(PCollection input, String stagingBucketDir) {\n          \n          \n            \n                private PCollection write(PCollection<T> input, String stagingBucketDir) {\n          \n      \n    \n    \n  \n\nI'd consider collapsing this method into expand (the caller) or combining with withFiles below.  It doesn't add much by itself.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">private</span> <span class=\"pl-smi\">PCollection</span> write(<span class=\"pl-smi\">PCollection</span> input, <span class=\"pl-smi\">String</span> stagingBucketDir) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">private</span> <span class=\"pl-smi\">PCollection</span> write(<span class=\"pl-k\">PCollection<span class=\"x x-first\">&lt;</span><span class=\"pl-smi x\">T</span><span class=\"x x-last\">&gt;</span></span> input, <span class=\"pl-smi\">String</span> stagingBucketDir) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">I'd consider collapsing this method into <code>expand</code> (the caller) or combining with <code>withFiles</code> below.  It doesn't add much by itself.</p>", "author": "RyanSkraba", "createdAt": "2020-05-28T13:56:59Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");\n+      checkArgument(\n+          loc.getStagingBucketName() != null, \"location with stagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");\n+    }\n+\n+    private PCollection write(PCollection input, String stagingBucketDir) {", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA1MDY5Ng==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433050696", "bodyText": "I wouldn't say that it doesn't add any value being like this as in my opinion makes code more readable.", "author": "purbanow", "createdAt": "2020-06-01T05:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NTA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NzUzMw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431857533", "body": "```suggestion\r\n      PCollection<String> mappedUserData =\r\n```\r\nAvoid raw types where possible!  This should be true throughout the code.", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  PCollection mappedUserData =\n          \n          \n            \n                  PCollection<String> mappedUserData =\n          \n      \n    \n    \n  \n\nAvoid raw types where possible!  This should be true throughout the code.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      <span class=\"pl-smi\">PCollection</span> mappedUserData <span class=\"pl-k\">=</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-k\">PCollection<span class=\"x x-first\">&lt;</span><span class=\"pl-smi x\">String</span><span class=\"x x-last\">&gt;</span></span> mappedUserData <span class=\"pl-k\">=</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">Avoid raw types where possible!  This should be true throughout the code.</p>", "author": "RyanSkraba", "createdAt": "2020-05-28T14:00:15Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");\n+      checkArgument(\n+          loc.getStagingBucketName() != null, \"location with stagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");\n+    }\n+\n+    private PCollection write(PCollection input, String stagingBucketDir) {\n+      SnowflakeService snowflakeService =\n+          getSnowflakeService() != null ? getSnowflakeService() : new SnowflakeServiceImpl();\n+\n+      PCollection files = writeFiles(input, stagingBucketDir);\n+\n+      files =\n+          (PCollection)\n+              files.apply(\"Create list of files to copy\", Combine.globally(new Concatenate()));\n+\n+      return (PCollection)\n+          files.apply(\"Copy files to table\", copyToTable(snowflakeService, stagingBucketDir));\n+    }\n+\n+    private PCollection writeFiles(PCollection<T> input, String stagingBucketDir) {\n+      class Parse extends DoFn<KV<T, String>, String> {\n+        @ProcessElement\n+        public void processElement(ProcessContext c) {\n+          c.output(c.element().getValue());\n+        }\n+      }\n+\n+      PCollection mappedUserData =", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyMDE2Ng==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433620166", "bodyText": "I checked whole code and I added missing types :)", "author": "purbanow", "createdAt": "2020-06-02T04:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NzUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2MjE5MQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431862191", "body": "It looks like you're re-implementing [Values.create()](https://beam.apache.org/releases/javadoc/2.21.0/org/apache/beam/sdk/transforms/Values.html)!  Consider using the existing transform.", "bodyText": "It looks like you're re-implementing Values.create()!  Consider using the existing transform.", "bodyHTML": "<p dir=\"auto\">It looks like you're re-implementing <a href=\"https://beam.apache.org/releases/javadoc/2.21.0/org/apache/beam/sdk/transforms/Values.html\" rel=\"nofollow\">Values.create()</a>!  Consider using the existing transform.</p>", "author": "RyanSkraba", "createdAt": "2020-05-28T14:06:52Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");\n+      checkArgument(\n+          loc.getStagingBucketName() != null, \"location with stagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");\n+    }\n+\n+    private PCollection write(PCollection input, String stagingBucketDir) {\n+      SnowflakeService snowflakeService =\n+          getSnowflakeService() != null ? getSnowflakeService() : new SnowflakeServiceImpl();\n+\n+      PCollection files = writeFiles(input, stagingBucketDir);\n+\n+      files =\n+          (PCollection)\n+              files.apply(\"Create list of files to copy\", Combine.globally(new Concatenate()));\n+\n+      return (PCollection)\n+          files.apply(\"Copy files to table\", copyToTable(snowflakeService, stagingBucketDir));\n+    }\n+\n+    private PCollection writeFiles(PCollection<T> input, String stagingBucketDir) {\n+      class Parse extends DoFn<KV<T, String>, String> {", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxMDMxMw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433610313", "bodyText": "Thanks for this tip :) I removed Parse class", "author": "purbanow", "createdAt": "2020-06-02T04:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2MjE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2NTUwMQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431865501", "body": "Consider reusing a `MapElements.via(t -> csvMapper.mapRow(t))` instead.", "bodyText": "Consider reusing a MapElements.via(t -> csvMapper.mapRow(t)) instead.", "bodyHTML": "<p dir=\"auto\">Consider reusing a <code>MapElements.via(t -&gt; csvMapper.mapRow(t))</code> instead.</p>", "author": "RyanSkraba", "createdAt": "2020-05-28T14:11:27Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");\n+      checkArgument(\n+          loc.getStagingBucketName() != null, \"location with stagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");\n+    }\n+\n+    private PCollection write(PCollection input, String stagingBucketDir) {\n+      SnowflakeService snowflakeService =\n+          getSnowflakeService() != null ? getSnowflakeService() : new SnowflakeServiceImpl();\n+\n+      PCollection files = writeFiles(input, stagingBucketDir);\n+\n+      files =\n+          (PCollection)\n+              files.apply(\"Create list of files to copy\", Combine.globally(new Concatenate()));\n+\n+      return (PCollection)\n+          files.apply(\"Copy files to table\", copyToTable(snowflakeService, stagingBucketDir));\n+    }\n+\n+    private PCollection writeFiles(PCollection<T> input, String stagingBucketDir) {\n+      class Parse extends DoFn<KV<T, String>, String> {\n+        @ProcessElement\n+        public void processElement(ProcessContext c) {\n+          c.output(c.element().getValue());\n+        }\n+      }\n+\n+      PCollection mappedUserData =\n+          input\n+              .apply(\n+                  \"Map user data to Objects array\",\n+                  ParDo.of(new MapUserDataObjectsArrayFn<T>(getUserDataMapper())))\n+              .apply(\"Map Objects array to CSV lines\", ParDo.of(new MapObjectsArrayToCsvFn()))\n+              .setCoder(StringUtf8Coder.of());\n+\n+      WriteFilesResult filesResult =\n+          (WriteFilesResult)\n+              mappedUserData.apply(\n+                  \"Write files to specified location\",\n+                  FileIO.write()\n+                      .via((FileIO.Sink) new CSVSink())\n+                      .to(stagingBucketDir)\n+                      .withPrefix(getFileNameTemplate())\n+                      .withSuffix(\".csv\")\n+                      .withPrefix(UUID.randomUUID().toString().subSequence(0, 8).toString())\n+                      .withCompression(Compression.GZIP));\n+\n+      return (PCollection)\n+          filesResult\n+              .getPerDestinationOutputFilenames()\n+              .apply(\"Parse KV filenames to Strings\", ParDo.of(new Parse()));\n+    }\n+\n+    private ParDo.SingleOutput<Object, Object> copyToTable(\n+        SnowflakeService snowflakeService, String stagingBucketDir) {\n+      return ParDo.of(\n+          new CopyToTableFn<>(\n+              getDataSourceProviderFn(),\n+              getTable(),\n+              getQuery(),\n+              stagingBucketDir,\n+              getLocation(),\n+              getWriteDisposition(),\n+              snowflakeService));\n+    }\n+  }\n+\n+  public static class Concatenate extends Combine.CombineFn<String, List<String>, List<String>> {\n+    @Override\n+    public List<String> createAccumulator() {\n+      return new ArrayList<>();\n+    }\n+\n+    @Override\n+    public List<String> addInput(List<String> mutableAccumulator, String input) {\n+      mutableAccumulator.add(String.format(\"'%s'\", input));\n+      return mutableAccumulator;\n+    }\n+\n+    @Override\n+    public List<String> mergeAccumulators(Iterable<List<String>> accumulators) {\n+      List<String> result = createAccumulator();\n+      for (List<String> accumulator : accumulators) {\n+        result.addAll(accumulator);\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public List<String> extractOutput(List<String> accumulator) {\n+      return accumulator;\n+    }\n+  }\n+\n+  private static class MapUserDataObjectsArrayFn<T> extends DoFn<T, Object[]> {", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExNDMxMQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433114311", "bodyText": "Thanks, I changed to MapElements.via with SimpleFunction", "author": "purbanow", "createdAt": "2020-06-01T08:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2NTUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTcyNw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431895727", "body": "Hmmmm -- a common pattern to process a small list of results is to treat it as a sideInput instead of collecting it into a singleton collection.  I have no really strong opinion about this, but someone might want to weigh in!", "bodyText": "Hmmmm -- a common pattern to process a small list of results is to treat it as a sideInput instead of collecting it into a singleton collection.  I have no really strong opinion about this, but someone might want to weigh in!", "bodyHTML": "<p dir=\"auto\">Hmmmm -- a common pattern to process a small list of results is to treat it as a sideInput instead of collecting it into a singleton collection.  I have no really strong opinion about this, but someone might want to weigh in!</p>", "author": "RyanSkraba", "createdAt": "2020-05-28T14:47:18Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");\n+      checkArgument(\n+          loc.getStagingBucketName() != null, \"location with stagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");\n+    }\n+\n+    private PCollection write(PCollection input, String stagingBucketDir) {\n+      SnowflakeService snowflakeService =\n+          getSnowflakeService() != null ? getSnowflakeService() : new SnowflakeServiceImpl();\n+\n+      PCollection files = writeFiles(input, stagingBucketDir);\n+\n+      files =\n+          (PCollection)\n+              files.apply(\"Create list of files to copy\", Combine.globally(new Concatenate()));\n+\n+      return (PCollection)\n+          files.apply(\"Copy files to table\", copyToTable(snowflakeService, stagingBucketDir));\n+    }\n+\n+    private PCollection writeFiles(PCollection<T> input, String stagingBucketDir) {\n+      class Parse extends DoFn<KV<T, String>, String> {\n+        @ProcessElement\n+        public void processElement(ProcessContext c) {\n+          c.output(c.element().getValue());\n+        }\n+      }\n+\n+      PCollection mappedUserData =\n+          input\n+              .apply(\n+                  \"Map user data to Objects array\",\n+                  ParDo.of(new MapUserDataObjectsArrayFn<T>(getUserDataMapper())))\n+              .apply(\"Map Objects array to CSV lines\", ParDo.of(new MapObjectsArrayToCsvFn()))\n+              .setCoder(StringUtf8Coder.of());\n+\n+      WriteFilesResult filesResult =\n+          (WriteFilesResult)\n+              mappedUserData.apply(\n+                  \"Write files to specified location\",\n+                  FileIO.write()\n+                      .via((FileIO.Sink) new CSVSink())\n+                      .to(stagingBucketDir)\n+                      .withPrefix(getFileNameTemplate())\n+                      .withSuffix(\".csv\")\n+                      .withPrefix(UUID.randomUUID().toString().subSequence(0, 8).toString())\n+                      .withCompression(Compression.GZIP));\n+\n+      return (PCollection)\n+          filesResult\n+              .getPerDestinationOutputFilenames()\n+              .apply(\"Parse KV filenames to Strings\", ParDo.of(new Parse()));\n+    }\n+\n+    private ParDo.SingleOutput<Object, Object> copyToTable(\n+        SnowflakeService snowflakeService, String stagingBucketDir) {\n+      return ParDo.of(\n+          new CopyToTableFn<>(\n+              getDataSourceProviderFn(),\n+              getTable(),\n+              getQuery(),\n+              stagingBucketDir,\n+              getLocation(),\n+              getWriteDisposition(),\n+              snowflakeService));\n+    }\n+  }\n+\n+  public static class Concatenate extends Combine.CombineFn<String, List<String>, List<String>> {", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4OTU4Ng==", "url": "https://github.com/apache/beam/pull/11794#discussion_r438289586", "bodyText": "Thank you @RyanSkraba - it was challenging but I think I managed to change it with Reify :) After testing it seems working as expected. Could you check is solution that you expected?", "author": "kkucharc", "createdAt": "2020-06-10T17:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwMzE2Mw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431903163", "body": "Oooooooo -- relying on the `toString()` representation of a Java instance is _almost_ always dangerous...  At this point, any non-String Object that contains a `'` or `,` is going to break the current line.\r\n\r\nIs there any Snowflake doc on the CSV format they're using?  All I could find was related to valid character encodings.", "bodyText": "Oooooooo -- relying on the toString() representation of a Java instance is almost always dangerous...  At this point, any non-String Object that contains a ' or , is going to break the current line.\nIs there any Snowflake doc on the CSV format they're using?  All I could find was related to valid character encodings.", "bodyHTML": "<p dir=\"auto\">Oooooooo -- relying on the <code>toString()</code> representation of a Java instance is <em>almost</em> always dangerous...  At this point, any non-String Object that contains a <code>'</code> or <code>,</code> is going to break the current line.</p>\n<p dir=\"auto\">Is there any Snowflake doc on the CSV format they're using?  All I could find was related to valid character encodings.</p>", "author": "RyanSkraba", "createdAt": "2020-05-28T14:56:44Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");\n+      checkArgument(\n+          loc.getStagingBucketName() != null, \"location with stagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");\n+    }\n+\n+    private PCollection write(PCollection input, String stagingBucketDir) {\n+      SnowflakeService snowflakeService =\n+          getSnowflakeService() != null ? getSnowflakeService() : new SnowflakeServiceImpl();\n+\n+      PCollection files = writeFiles(input, stagingBucketDir);\n+\n+      files =\n+          (PCollection)\n+              files.apply(\"Create list of files to copy\", Combine.globally(new Concatenate()));\n+\n+      return (PCollection)\n+          files.apply(\"Copy files to table\", copyToTable(snowflakeService, stagingBucketDir));\n+    }\n+\n+    private PCollection writeFiles(PCollection<T> input, String stagingBucketDir) {\n+      class Parse extends DoFn<KV<T, String>, String> {\n+        @ProcessElement\n+        public void processElement(ProcessContext c) {\n+          c.output(c.element().getValue());\n+        }\n+      }\n+\n+      PCollection mappedUserData =\n+          input\n+              .apply(\n+                  \"Map user data to Objects array\",\n+                  ParDo.of(new MapUserDataObjectsArrayFn<T>(getUserDataMapper())))\n+              .apply(\"Map Objects array to CSV lines\", ParDo.of(new MapObjectsArrayToCsvFn()))\n+              .setCoder(StringUtf8Coder.of());\n+\n+      WriteFilesResult filesResult =\n+          (WriteFilesResult)\n+              mappedUserData.apply(\n+                  \"Write files to specified location\",\n+                  FileIO.write()\n+                      .via((FileIO.Sink) new CSVSink())\n+                      .to(stagingBucketDir)\n+                      .withPrefix(getFileNameTemplate())\n+                      .withSuffix(\".csv\")\n+                      .withPrefix(UUID.randomUUID().toString().subSequence(0, 8).toString())\n+                      .withCompression(Compression.GZIP));\n+\n+      return (PCollection)\n+          filesResult\n+              .getPerDestinationOutputFilenames()\n+              .apply(\"Parse KV filenames to Strings\", ParDo.of(new Parse()));\n+    }\n+\n+    private ParDo.SingleOutput<Object, Object> copyToTable(\n+        SnowflakeService snowflakeService, String stagingBucketDir) {\n+      return ParDo.of(\n+          new CopyToTableFn<>(\n+              getDataSourceProviderFn(),\n+              getTable(),\n+              getQuery(),\n+              stagingBucketDir,\n+              getLocation(),\n+              getWriteDisposition(),\n+              snowflakeService));\n+    }\n+  }\n+\n+  public static class Concatenate extends Combine.CombineFn<String, List<String>, List<String>> {\n+    @Override\n+    public List<String> createAccumulator() {\n+      return new ArrayList<>();\n+    }\n+\n+    @Override\n+    public List<String> addInput(List<String> mutableAccumulator, String input) {\n+      mutableAccumulator.add(String.format(\"'%s'\", input));\n+      return mutableAccumulator;\n+    }\n+\n+    @Override\n+    public List<String> mergeAccumulators(Iterable<List<String>> accumulators) {\n+      List<String> result = createAccumulator();\n+      for (List<String> accumulator : accumulators) {\n+        result.addAll(accumulator);\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public List<String> extractOutput(List<String> accumulator) {\n+      return accumulator;\n+    }\n+  }\n+\n+  private static class MapUserDataObjectsArrayFn<T> extends DoFn<T, Object[]> {\n+    private final UserDataMapper<T> csvMapper;\n+\n+    public MapUserDataObjectsArrayFn(UserDataMapper<T> csvMapper) {\n+      this.csvMapper = csvMapper;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext context) throws Exception {\n+      context.output(csvMapper.mapRow(context.element()));\n+    }\n+  }\n+\n+  /**\n+   * Custom DoFn that maps {@link Object[]} into CSV line to be saved to Snowflake.\n+   *\n+   * <p>Adds Snowflake-specific quotations around strings.\n+   */\n+  private static class MapObjectsArrayToCsvFn extends DoFn<Object[], String> {\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext context) {\n+      List<Object> csvItems = new ArrayList<>();\n+      for (Object o : context.element()) {\n+        if (o instanceof String) {\n+          String field = (String) o;\n+          field = field.replace(\"'\", \"''\");\n+          field = quoteField(field);\n+\n+          csvItems.add(field);\n+        } else {\n+          csvItems.add(o);", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkxMjc1NQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431912755", "bodyText": "Ugh, found a reference: https://docs.snowflake.com/en/user-guide/data-load-considerations-prepare.html#preparing-delimited-text-files\n\nFields that contain delimiter characters should be enclosed in quotes (single or double). If the data contains single or double quotes, then those quotes must be escaped.\n\nCan you confirm that this means 'I can''t believe it.' or 'I can\\'t believe it' ?", "author": "RyanSkraba", "createdAt": "2020-05-28T15:09:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwMzE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNzY4Nw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433627687", "bodyText": "Based on  If the data contains single or double quotes, then those quotes must be escaped. proper is  'I can\\'t believe it'", "author": "purbanow", "createdAt": "2020-06-02T05:26:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwMzE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3OTU2OQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r443679569", "bodyText": "The line above field = field.replace(\"'\", \"''\"); ?  It looks like the '' style.  If you confirm it works with Snowflake, I'll trust you!", "author": "RyanSkraba", "createdAt": "2020-06-22T16:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwMzE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwNDkzNw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431904937", "body": "Just to be sure you're aware!  This breaks users that are passing this information from the command line using the `--stage` option.", "bodyText": "Just to be sure you're aware!  This breaks users that are passing this information from the command line using the --stage option.", "bodyHTML": "<p dir=\"auto\">Just to be sure you're aware!  This breaks users that are passing this information from the command line using the <code>--stage</code> option.</p>", "author": "RyanSkraba", "createdAt": "2020-05-28T14:59:06Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakePipelineOptions.java", "diffHunk": "@@ -111,23 +111,13 @@\n \n   void setLoginTimeout(String loginTimeout);\n \n-  @Description(\"External location name to connect to.\")\n-  String getExternalLocation();\n-\n-  void setExternalLocation(String externalLocation);\n-\n-  @Description(\"Temporary GCS bucket name\")\n+  @Description(\"Temporary GCS bucket name.\")\n   String getStagingBucketName();\n \n   void setStagingBucketName(String stagingBucketName);\n \n-  @Description(\"Storage integration - required in case the external stage is not specified.\")\n-  String getStorageIntegration();\n-\n-  void setStorageIntegration(String integration);\n-\n-  @Description(\"Stage name. Optional.\")\n-  String getStage();\n+  @Description(\"Storage integration name\")\n+  String getStorageIntegrationName();", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQwOTUxNw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432409517", "bodyText": "Yes. I'm totally aware of that. --stage option is not being used anywhere in the codebase.", "author": "purbanow", "createdAt": "2020-05-29T10:58:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwNDkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4NzEwMQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r443687101", "body": "This is where there's an implicit `.toString()` on the objects in the array -- this is still pretty dangerous for many non-primitive classes!\r\n\r\nI can think of a couple of solutions: (1) Use something other than CSV as the file for copying into Snowflake, (2) Add a warning to the data mapper doc that the toString's have to be coherent!\r\n\r\nFor example, if my data mapper function returns `new Object[] {Arrays.asList(1,',',\"\\n\")}` to insert, it's almost certainly going to break the function.\r\n\r\nI can see this happening, for example, if a user thinks that returning a JsonObject will insert the JSON as a string into that column.", "bodyText": "This is where there's an implicit .toString() on the objects in the array -- this is still pretty dangerous for many non-primitive classes!\nI can think of a couple of solutions: (1) Use something other than CSV as the file for copying into Snowflake, (2) Add a warning to the data mapper doc that the toString's have to be coherent!\nFor example, if my data mapper function returns new Object[] {Arrays.asList(1,',',\"\\n\")} to insert, it's almost certainly going to break the function.\nI can see this happening, for example, if a user thinks that returning a JsonObject will insert the JSON as a string into that column.", "bodyHTML": "<p dir=\"auto\">This is where there's an implicit <code>.toString()</code> on the objects in the array -- this is still pretty dangerous for many non-primitive classes!</p>\n<p dir=\"auto\">I can think of a couple of solutions: (1) Use something other than CSV as the file for copying into Snowflake, (2) Add a warning to the data mapper doc that the toString's have to be coherent!</p>\n<p dir=\"auto\">For example, if my data mapper function returns <code>new Object[] {Arrays.asList(1,',',\"\\n\")}</code> to insert, it's almost certainly going to break the function.</p>\n<p dir=\"auto\">I can see this happening, for example, if a user thinks that returning a JsonObject will insert the JSON as a string into that column.</p>", "author": "RyanSkraba", "createdAt": "2020-06-22T16:35:10Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +513,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getStorageIntegrationName();\n+\n+    @Nullable\n+    abstract String getStagingBucketName();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setStorageIntegrationName(String storageIntegrationName);\n+\n+      abstract Builder<T> setStagingBucketName(String stagingBucketName);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> withTable(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * Name of the cloud bucket (GCS by now) to use as tmp location of CSVs during COPY statement.\n+     *\n+     * @param stagingBucketName - String with the name of the bucket.\n+     */\n+    public Write<T> withStagingBucketName(String stagingBucketName) {\n+      return toBuilder().setStagingBucketName(stagingBucketName).build();\n+    }\n+\n+    /**\n+     * Name of the Storage Integration in Snowflake to be used. See\n+     * https://docs.snowflake.com/en/sql-reference/sql/create-storage-integration.html for\n+     * reference.\n+     *\n+     * @param integrationName - String with the name of the Storage Integration.\n+     */\n+    public Write<T> withStorageIntegrationName(String integrationName) {\n+      return toBuilder().setStorageIntegrationName(integrationName).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      checkArguments();\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection<String> out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments() {\n+      checkArgument(getStagingBucketName() != null, \"withStagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");\n+    }\n+\n+    private PCollection<String> write(PCollection<T> input, String stagingBucketDir) {\n+      SnowflakeService snowflakeService =\n+          getSnowflakeService() != null ? getSnowflakeService() : new SnowflakeServiceImpl();\n+\n+      PCollection<String> files = writeFiles(input, stagingBucketDir);\n+\n+      // Combining PCollection of files as a side input into one list of files\n+      ListCoder<String> coder = ListCoder.of(StringUtf8Coder.of());\n+      files =\n+          (PCollection)\n+              files\n+                  .getPipeline()\n+                  .apply(\n+                      Reify.viewInGlobalWindow(\n+                          (PCollectionView) files.apply(View.asList()), coder));\n+\n+      return (PCollection)\n+          files.apply(\"Copy files to table\", copyToTable(snowflakeService, stagingBucketDir));\n+    }\n+\n+    private PCollection<String> writeFiles(PCollection<T> input, String stagingBucketDir) {\n+\n+      PCollection<String> mappedUserData =\n+          input\n+              .apply(\n+                  MapElements.via(\n+                      new SimpleFunction<T, Object[]>() {\n+                        @Override\n+                        public Object[] apply(T element) {\n+                          return getUserDataMapper().mapRow(element);\n+                        }\n+                      }))\n+              .apply(\"Map Objects array to CSV lines\", ParDo.of(new MapObjectsArrayToCsvFn()))\n+              .setCoder(StringUtf8Coder.of());\n+\n+      WriteFilesResult filesResult =\n+          mappedUserData.apply(\n+              \"Write files to specified location\",\n+              FileIO.<String>write()\n+                  .via(TextIO.sink())\n+                  .to(stagingBucketDir)\n+                  .withPrefix(getFileNameTemplate())\n+                  .withSuffix(\".csv\")\n+                  .withCompression(Compression.GZIP));\n+\n+      return (PCollection)\n+          filesResult\n+              .getPerDestinationOutputFilenames()\n+              .apply(\"Parse KV filenames to Strings\", Values.<String>create());\n+    }\n+\n+    private ParDo.SingleOutput<Object, Object> copyToTable(\n+        SnowflakeService snowflakeService, String stagingBucketDir) {\n+      return ParDo.of(\n+          new CopyToTableFn<>(\n+              getDataSourceProviderFn(),\n+              getTable(),\n+              getQuery(),\n+              stagingBucketDir,\n+              getStorageIntegrationName(),\n+              getWriteDisposition(),\n+              snowflakeService));\n+    }\n+  }\n+\n+  public static class Concatenate extends Combine.CombineFn<String, List<String>, List<String>> {\n+    @Override\n+    public List<String> createAccumulator() {\n+      return new ArrayList<>();\n+    }\n+\n+    @Override\n+    public List<String> addInput(List<String> mutableAccumulator, String input) {\n+      mutableAccumulator.add(String.format(\"'%s'\", input));\n+      return mutableAccumulator;\n+    }\n+\n+    @Override\n+    public List<String> mergeAccumulators(Iterable<List<String>> accumulators) {\n+      List<String> result = createAccumulator();\n+      for (List<String> accumulator : accumulators) {\n+        result.addAll(accumulator);\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public List<String> extractOutput(List<String> accumulator) {\n+      return accumulator;\n+    }\n+  }\n+\n+  /**\n+   * Custom DoFn that maps {@link Object[]} into CSV line to be saved to Snowflake.\n+   *\n+   * <p>Adds Snowflake-specific quotations around strings.\n+   */\n+  private static class MapObjectsArrayToCsvFn extends DoFn<Object[], String> {\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext context) {\n+      List<Object> csvItems = new ArrayList<>();\n+      for (Object o : context.element()) {\n+        if (o instanceof String) {\n+          String field = (String) o;\n+          field = field.replace(\"'\", \"''\");\n+          field = quoteField(field);\n+\n+          csvItems.add(field);\n+        } else {\n+          csvItems.add(o);\n+        }\n+      }\n+      context.output(Joiner.on(\",\").useForNull(\"\").join(csvItems));", "originalCommit": "4ad146d41101aca5db3c2351f6232761fff8ebf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA1NTU3MQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r444055571", "bodyText": "Thanks for pointing this. We're going to add it to our feature improvement list.", "author": "purbanow", "createdAt": "2020-06-23T08:34:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4NzEwMQ=="}], "type": "inlineReview"}, {"oid": "0a643746208e0e422943726f5862d9a041acbbb5", "url": "https://github.com/apache/beam/commit/0a643746208e0e422943726f5862d9a041acbbb5", "message": "[BEAM-9894] Snowflake write - change Combine step into Reify", "committedDate": "2020-06-23T07:36:31Z", "type": "forcePushed"}, {"oid": "6375a925dd2987d3f0f38e7f76cbb47e222dfa50", "url": "https://github.com/apache/beam/commit/6375a925dd2987d3f0f38e7f76cbb47e222dfa50", "message": "[BEAM-9894] Add batch SnowflakeIO.Write to Java SDK", "committedDate": "2020-06-24T05:14:30Z", "type": "commit"}, {"oid": "73ef5dea01f4249c063c19429bc63f92e3069d3a", "url": "https://github.com/apache/beam/commit/73ef5dea01f4249c063c19429bc63f92e3069d3a", "message": "fix: add missing license headers", "committedDate": "2020-06-24T05:14:30Z", "type": "commit"}, {"oid": "0cb6328009f1b2ee4dff288556059b1f63ae2159", "url": "https://github.com/apache/beam/commit/0cb6328009f1b2ee4dff288556059b1f63ae2159", "message": "refactor: method names", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "515894c4b87797ff434a7211a74abcd1cb2ef3dd", "url": "https://github.com/apache/beam/commit/515894c4b87797ff434a7211a74abcd1cb2ef3dd", "message": "fix: make Location.storageIntegrationName as a nullable variable", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "c571a69c675b6e65a5f6cbd3cbc5ae67a15b76e9", "url": "https://github.com/apache/beam/commit/c571a69c675b6e65a5f6cbd3cbc5ae67a15b76e9", "message": "fix: remove MapUserDataObjectsArrayFn class", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "e4564cd8ee60d5bf96d68f0e25e55e587214b0df", "url": "https://github.com/apache/beam/commit/e4564cd8ee60d5bf96d68f0e25e55e587214b0df", "message": "fix(SnowFlakeIO): removed Parse class + add @Experimental annotation", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "44615d5eaaac8bb4e736330085647c326c0b0785", "url": "https://github.com/apache/beam/commit/44615d5eaaac8bb4e736330085647c326c0b0785", "message": "refactor(SnowFlakeIO): removed Location class", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "6bc58d7e87dd830d06beb9fe43ae155878c36723", "url": "https://github.com/apache/beam/commit/6bc58d7e87dd830d06beb9fe43ae155878c36723", "message": "fix(SnowFlakeIO): added missing types", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "1e44ed0db8940c6e3f3dce020261d17bbebebe0e", "url": "https://github.com/apache/beam/commit/1e44ed0db8940c6e3f3dce020261d17bbebebe0e", "message": "refactor(SnowFlakeIO): removed CSVSink class", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "14cf5aeb5b9b3ac663158fef9ca54d06963c6568", "url": "https://github.com/apache/beam/commit/14cf5aeb5b9b3ac663158fef9ca54d06963c6568", "message": "[BEAM-9894] Snowflake write - change Combine step into Reify", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "14cf5aeb5b9b3ac663158fef9ca54d06963c6568", "url": "https://github.com/apache/beam/commit/14cf5aeb5b9b3ac663158fef9ca54d06963c6568", "message": "[BEAM-9894] Snowflake write - change Combine step into Reify", "committedDate": "2020-06-24T05:14:31Z", "type": "forcePushed"}]}