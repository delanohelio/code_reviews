{"pr_number": 8210, "pr_title": "Allow `git` material to honor a refSpec as the branch name", "pr_author": "marques-work", "pr_createdAt": "2020-06-03T02:08:24Z", "pr_url": "https://github.com/gocd/gocd/pull/8210", "timeline": [{"oid": "e469c5e79207d181edb5945556e51ffe57771f9d", "url": "https://github.com/gocd/gocd/commit/e469c5e79207d181edb5945556e51ffe57771f9d", "message": "wip", "committedDate": "2020-06-03T19:11:27Z", "type": "forcePushed"}, {"oid": "7b3589199cfab68b94331d6e6df5b6523a65d1d5", "url": "https://github.com/gocd/gocd/commit/7b3589199cfab68b94331d6e6df5b6523a65d1d5", "message": "wip", "committedDate": "2020-06-09T19:23:49Z", "type": "forcePushed"}, {"oid": "fa980050d35c252700226f05dc775e7035592220", "url": "https://github.com/gocd/gocd/commit/fa980050d35c252700226f05dc775e7035592220", "message": "wip", "committedDate": "2020-06-09T19:24:49Z", "type": "forcePushed"}, {"oid": "f379b8e4ee576ea880e3c8be807416badaa9cf02", "url": "https://github.com/gocd/gocd/commit/f379b8e4ee576ea880e3c8be807416badaa9cf02", "message": "wip2", "committedDate": "2020-06-11T01:30:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5NTQ4Nw==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438495487", "body": "This is the heart of this change (adding convenience methods); the rest is IntelliJ IDEA regrouping `private` and `protected` methods together at the bottom.", "bodyText": "This is the heart of this change (adding convenience methods); the rest is IntelliJ IDEA regrouping private and protected methods together at the bottom.", "bodyHTML": "<p dir=\"auto\">This is the heart of this change (adding convenience methods); the rest is IntelliJ IDEA regrouping <code>private</code> and <code>protected</code> methods together at the bottom.</p>", "author": "marques-work", "createdAt": "2020-06-11T01:37:15Z", "path": "commandline/src/main/java/com/thoughtworks/go/util/command/CommandLine.java", "diffHunk": "@@ -319,6 +256,19 @@ public CommandLine withArgs(List<String> args) {\n         return this;\n     }\n \n+    public CommandLine when(boolean condition, Consumer<CommandLine> thenDo) {\n+        return this.tap((cmd) -> {\n+            if (condition) {\n+                thenDo.accept(cmd);\n+            }\n+        });\n+    }\n+\n+    public CommandLine tap(Consumer<CommandLine> thenDo) {\n+        thenDo.accept(this);\n+        return this;\n+    }\n+", "originalCommit": "f379b8e4ee576ea880e3c8be807416badaa9cf02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA2NTg3Mw==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r453065873", "bodyText": "@marques-work thanks for adding comments around the actual changes. Another option to consider is having a separate commit only for things like regrouping/refactoring.", "author": "maheshp", "createdAt": "2020-07-10T20:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5NTQ4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "cbca50d98d98b15a6581214cafc0e42674c1fa74", "changed_code": [{"header": "diff --git a/commandline/src/main/java/com/thoughtworks/go/util/command/CommandLine.java b/commandline/src/main/java/com/thoughtworks/go/util/command/CommandLine.java\nindex 841a06f900..18e040e8d0 100644\n--- a/commandline/src/main/java/com/thoughtworks/go/util/command/CommandLine.java\n+++ b/commandline/src/main/java/com/thoughtworks/go/util/command/CommandLine.java\n", "chunk": "@@ -256,19 +319,6 @@ public class CommandLine {\n         return this;\n     }\n \n-    public CommandLine when(boolean condition, Consumer<CommandLine> thenDo) {\n-        return this.tap((cmd) -> {\n-            if (condition) {\n-                thenDo.accept(cmd);\n-            }\n-        });\n-    }\n-\n-    public CommandLine tap(Consumer<CommandLine> thenDo) {\n-        thenDo.accept(this);\n-        return this;\n-    }\n-\n     public CommandLine argPassword(String password) {\n         arguments.add(new PasswordArgument(password));\n         return this;\n", "next_change": {"commit": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "changed_code": [{"header": "diff --git a/commandline/src/main/java/com/thoughtworks/go/util/command/CommandLine.java b/commandline/src/main/java/com/thoughtworks/go/util/command/CommandLine.java\nindex 18e040e8d0..841a06f900 100644\n--- a/commandline/src/main/java/com/thoughtworks/go/util/command/CommandLine.java\n+++ b/commandline/src/main/java/com/thoughtworks/go/util/command/CommandLine.java\n", "chunk": "@@ -319,6 +256,19 @@ public class CommandLine {\n         return this;\n     }\n \n+    public CommandLine when(boolean condition, Consumer<CommandLine> thenDo) {\n+        return this.tap((cmd) -> {\n+            if (condition) {\n+                thenDo.accept(cmd);\n+            }\n+        });\n+    }\n+\n+    public CommandLine tap(Consumer<CommandLine> thenDo) {\n+        thenDo.accept(this);\n+        return this;\n+    }\n+\n     public CommandLine argPassword(String password) {\n         arguments.add(new PasswordArgument(password));\n         return this;\n", "next_change": null}]}}]}}, {"oid": "1772ef1fcc5ea380496e95b826081fa0ebcfd23d", "url": "https://github.com/gocd/gocd/commit/1772ef1fcc5ea380496e95b826081fa0ebcfd23d", "message": "wip2", "committedDate": "2020-06-11T01:38:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5Njc4Ng==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438496786", "body": "Apologies for the messy diff;\r\n\r\nThe main bits here are adding the `RefSpec` and `RefSpecIntegration` `@Nested` tests. The rest is reorganizing the original tests under the `@Nested class Integration {}` tests.", "bodyText": "Apologies for the messy diff;\nThe main bits here are adding the RefSpec and RefSpecIntegration @Nested tests. The rest is reorganizing the original tests under the @Nested class Integration {} tests.", "bodyHTML": "<p dir=\"auto\">Apologies for the messy diff;</p>\n<p dir=\"auto\">The main bits here are adding the <code>RefSpec</code> and <code>RefSpecIntegration</code> <code>@Nested</code> tests. The rest is reorganizing the original tests under the <code>@Nested class Integration {}</code> tests.</p>", "author": "marques-work", "createdAt": "2020-06-11T01:42:40Z", "path": "common/src/test/java/com/thoughtworks/go/domain/materials/git/GitCommandTest.java", "diffHunk": "@@ -25,777 +25,879 @@\n import com.thoughtworks.go.mail.SysOutStreamConsumer;\n import com.thoughtworks.go.util.DateUtils;\n import com.thoughtworks.go.util.FileUtil;\n+import com.thoughtworks.go.util.NamedProcessTag;\n import com.thoughtworks.go.util.command.*;\n import org.apache.commons.io.FileUtils;\n import org.apache.commons.io.IOUtils;\n import org.junit.Rule;\n import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n import org.junit.jupiter.migrationsupport.rules.EnableRuleMigrationSupport;\n-import org.junit.rules.ExpectedException;\n import org.junit.rules.TemporaryFolder;\n import org.junit.rules.TestRule;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.nio.charset.Charset;\n import java.util.*;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import static com.thoughtworks.go.domain.materials.git.GitTestRepo.*;\n import static com.thoughtworks.go.util.DateUtils.parseRFC822;\n-import static com.thoughtworks.go.util.ReflectionUtil.getField;\n import static com.thoughtworks.go.util.command.ProcessOutputStreamConsumer.inMemoryConsumer;\n+import static java.lang.String.format;\n import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.regex.Pattern.compile;\n+import static java.util.regex.Pattern.quote;\n import static org.apache.commons.io.filefilter.FileFilterUtils.*;\n import static org.apache.commons.lang3.time.DateUtils.addDays;\n import static org.apache.commons.lang3.time.DateUtils.setMilliseconds;\n-import static org.assertj.core.api.Assertions.*;\n-import static org.mockito.MockitoAnnotations.initMocks;\n+import static org.junit.jupiter.api.Assertions.*;\n \n-@EnableRuleMigrationSupport\n public class GitCommandTest {\n-    private static final String BRANCH = \"foo\";\n-    private static final String SUBMODULE = \"submodule-1\";\n-\n-    private GitCommand git;\n-    private String repoUrl;\n-    private File repoLocation;\n-    private static final Date THREE_DAYS_FROM_NOW = setMilliseconds(addDays(new Date(), 3), 0);\n-    private GitTestRepo gitRepo;\n-    private File gitLocalRepoDir;\n-    private GitTestRepo gitFooBranchBundle;\n-\n-    @Rule\n-    public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-    @Rule\n-    public final TestRule restoreSystemProperties = new RestoreSystemProperties();\n-\n-    @Rule\n-    public final ExpectedException expectedException = ExpectedException.none();\n-\n-    @BeforeEach\n-    void setup() throws Exception {\n-        gitRepo = new GitTestRepo(temporaryFolder);\n-        gitLocalRepoDir = createTempWorkingDirectory();\n-        git = new GitCommand(null, gitLocalRepoDir, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        repoLocation = gitRepo.gitRepository();\n-        repoUrl = gitRepo.projectRepositoryUrl();\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-        int returnCode = git.cloneWithNoCheckout(outputStreamConsumer, repoUrl);\n-        if (returnCode > 0) {\n-            fail(outputStreamConsumer.getAllOutput());\n-        }\n-        gitFooBranchBundle = GitTestRepo.testRepoAtBranch(GIT_FOO_BRANCH_BUNDLE, BRANCH, temporaryFolder);\n-        initMocks(this);\n-    }\n+    private static GitCommand withBranch(String branch) {\n+        return new GitCommand(null, null, branch, false, null);\n+    }\n+\n+    private static GitCommand withBranch(String branch, File cwd) {\n+        return new GitCommand(null, cwd, branch, false, null);\n+    }\n+\n+    @Nested\n+    class RefSpec {", "originalCommit": "1772ef1fcc5ea380496e95b826081fa0ebcfd23d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cbca50d98d98b15a6581214cafc0e42674c1fa74", "changed_code": [{"header": "diff --git a/common/src/test/java/com/thoughtworks/go/domain/materials/git/GitCommandTest.java b/common/src/test/java/com/thoughtworks/go/domain/materials/git/GitCommandTest.java\nindex 222e61adfc..55d393a468 100644\n--- a/common/src/test/java/com/thoughtworks/go/domain/materials/git/GitCommandTest.java\n+++ b/common/src/test/java/com/thoughtworks/go/domain/materials/git/GitCommandTest.java\n", "chunk": "@@ -33,871 +32,770 @@ import org.junit.Rule;\n import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.io.TempDir;\n import org.junit.jupiter.migrationsupport.rules.EnableRuleMigrationSupport;\n+import org.junit.rules.ExpectedException;\n import org.junit.rules.TemporaryFolder;\n import org.junit.rules.TestRule;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.nio.charset.Charset;\n import java.util.*;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import static com.thoughtworks.go.domain.materials.git.GitTestRepo.*;\n import static com.thoughtworks.go.util.DateUtils.parseRFC822;\n+import static com.thoughtworks.go.util.ReflectionUtil.getField;\n import static com.thoughtworks.go.util.command.ProcessOutputStreamConsumer.inMemoryConsumer;\n-import static java.lang.String.format;\n import static java.nio.charset.StandardCharsets.UTF_8;\n-import static java.util.Objects.requireNonNull;\n-import static java.util.regex.Pattern.compile;\n-import static java.util.regex.Pattern.quote;\n import static org.apache.commons.io.filefilter.FileFilterUtils.*;\n import static org.apache.commons.lang3.time.DateUtils.addDays;\n import static org.apache.commons.lang3.time.DateUtils.setMilliseconds;\n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.assertj.core.api.Assertions.*;\n+import static org.mockito.MockitoAnnotations.initMocks;\n \n+@EnableRuleMigrationSupport\n public class GitCommandTest {\n-    private static GitCommand withBranch(String branch) {\n-        return new GitCommand(null, null, branch, false, null);\n-    }\n-\n-    private static GitCommand withBranch(String branch, File cwd) {\n-        return new GitCommand(null, cwd, branch, false, null);\n-    }\n-\n-    @Nested\n-    class RefSpec {\n-        @Test\n-        void extractsLocalBranchFromRefSpec() {\n-            assertEquals(\"whatever\", withBranch(\"whatever\").localBranch());\n-            assertEquals(\"whatever\", withBranch(\"refs/anything/goes:whatever\").localBranch());\n-            assertEquals(\"with/slashes\", withBranch(\"refs/anything/goes:with/slashes\").localBranch());\n-            assertEquals(\"whatever\", withBranch(\"refs/anything/goes:refs/heads/whatever\").localBranch());\n-            assertEquals(\"whatever\", withBranch(\"refs/anything/goes:refs/remotes/origin/whatever\").localBranch());\n-            assertEquals(\"whatever\", withBranch(\"refs/anything/goes:refs/remotes/upstream/whatever\").localBranch());\n-            assertEquals(\"refs/remotes/oops-did-not-specify-branch\", withBranch(\"refs/anything/goes:refs/remotes/oops-did-not-specify-branch\").localBranch());\n-            assertEquals(\"refs/full/location\", withBranch(\"refs/anything/goes:refs/full/location\").localBranch());\n-        }\n-\n-        @Test\n-        void extractsRemoteBranchFromRefSpec() {\n-            assertEquals(\"origin/anywhere\", withBranch(\"anywhere\").remoteBranch());\n-            assertEquals(\"refs/heads/whatever\", withBranch(\"refs/anything/goes:whatever\").remoteBranch());\n-            assertEquals(\"refs/heads/with/slashes\", withBranch(\"refs/anything/goes:with/slashes\").remoteBranch());\n-            assertEquals(\"refs/full/location\", withBranch(\"refs/anything/goes:refs/full/location\").remoteBranch());\n-            assertEquals(\"origin/any\", withBranch(\"refs/anything/goes:refs/remotes/origin/any\").remoteBranch());\n-            assertEquals(\"other/remote\", withBranch(\"refs/anything/goes:refs/remotes/other/remote\").remoteBranch());\n-            assertEquals(\"refs/remotes/oops-did-not-specify-branch\", withBranch(\"refs/anything/goes:refs/remotes/oops-did-not-specify-branch\").remoteBranch());\n-        }\n-\n-        @Test\n-        void fullUpstreamRefIsRefSpecAware() {\n-            assertEquals(\"refs/heads/dev\", withBranch(\"dev\").fullUpstreamRef());\n-            assertEquals(\"refs/anything/goes\", withBranch(\"refs/anything/goes:whatever\").fullUpstreamRef());\n-        }\n-\n-        @Test\n-        void expandRefSpecEnsuresAbsoluteDestination() {\n-            assertEquals(\"branch\", withBranch(\"branch\").expandRefSpec());\n-            assertEquals(\"refs/a/*:refs/remotes/origin/a-*\", withBranch(\"refs/a/*:a-*\").expandRefSpec());\n-            assertEquals(\"refs/a/*:refs/remotes/origin/a/b/c-*\", withBranch(\"refs/a/*:a/b/c-*\").expandRefSpec());\n-            assertEquals(\"refs/a/*:refs/b/*\", withBranch(\"refs/a/*:refs/b/*\").expandRefSpec());\n-            assertEquals(\"refs/a/*:refs/remotes/origin/a-*\", withBranch(\"refs/a/*:refs/remotes/origin/a-*\").expandRefSpec());\n-        }\n-\n-        @Test\n-        void defaultsToMasterWhenNoBranchIsSpecified() {\n-            assertEquals(\"master\", withBranch(null).localBranch());\n-            assertEquals(\"master\", withBranch(\" \").localBranch());\n-            assertEquals(\"master\", withBranch(\"master\").localBranch());\n-            assertEquals(\"branch\", withBranch(\"branch\").localBranch());\n-\n-            assertEquals(\"origin/master\", withBranch(null).remoteBranch());\n-            assertEquals(\"origin/master\", withBranch(\" \").remoteBranch());\n-            assertEquals(\"origin/master\", withBranch(\"master\").remoteBranch());\n-            assertEquals(\"origin/branch\", withBranch(\"branch\").remoteBranch());\n-\n-            assertEquals(\"refs/heads/master\", withBranch(null).fullUpstreamRef());\n-            assertEquals(\"refs/heads/master\", withBranch(\" \").fullUpstreamRef());\n-            assertEquals(\"refs/heads/master\", withBranch(\"master\").fullUpstreamRef());\n-            assertEquals(\"refs/heads/branch\", withBranch(\"branch\").fullUpstreamRef());\n-\n-            assertEquals(\"master\", withBranch(null).expandRefSpec());\n-            assertEquals(\"master\", withBranch(\" \").expandRefSpec());\n-            assertEquals(\"master\", withBranch(\"master\").expandRefSpec());\n-            assertEquals(\"branch\", withBranch(\"branch\").expandRefSpec());\n-        }\n+    private static final String BRANCH = \"foo\";\n+    private static final String SUBMODULE = \"submodule-1\";\n+\n+    private GitCommand git;\n+    private String repoUrl;\n+    private File repoLocation;\n+    private static final Date THREE_DAYS_FROM_NOW = setMilliseconds(addDays(new Date(), 3), 0);\n+    private GitTestRepo gitRepo;\n+    private File gitLocalRepoDir;\n+    private GitTestRepo gitFooBranchBundle;\n+\n+    @Rule\n+    public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+    @Rule\n+    public final TestRule restoreSystemProperties = new RestoreSystemProperties();\n+\n+    @Rule\n+    public final ExpectedException expectedException = ExpectedException.none();\n+\n+    @BeforeEach\n+    void setup() throws Exception {\n+        gitRepo = new GitTestRepo(temporaryFolder);\n+        gitLocalRepoDir = createTempWorkingDirectory();\n+        git = new GitCommand(null, gitLocalRepoDir, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+        repoLocation = gitRepo.gitRepository();\n+        repoUrl = gitRepo.projectRepositoryUrl();\n+        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+        int returnCode = git.cloneWithNoCheckout(outputStreamConsumer, repoUrl);\n+        if (returnCode > 0) {\n+            fail(outputStreamConsumer.getAllOutput());\n+        }\n+        gitFooBranchBundle = GitTestRepo.testRepoAtBranch(GIT_FOO_BRANCH_BUNDLE, BRANCH, temporaryFolder);\n+        initMocks(this);\n     }\n \n-    @Nested\n-    class RefSpecIntegration {\n-        @Test\n-        void clonedRepoReflectsDestinationRef(@TempDir File sandbox) {\n-            final String refSpec = \"refs/pull/1/head:refs/remotes/origin/pull/1/head\";\n-            final GitCommand git = withBranch(refSpec, sandbox);\n-\n-            final InMemoryStreamConsumer out = inMemoryConsumer();\n-            assertEquals(0, git.clone(out, GIT_CUSTOM_REFS_BUNDLE));\n-            assertEquals(\"pull/1/head\", git.getCurrentBranch());\n-\n-            git.fetch(out);\n-            assertEquals(\"+\" + git.expandRefSpec(), git.getConfigValue(\"remote.origin.fetch\"));\n-            assertEquals(git(sandbox, \"rev-parse\", \"HEAD\"), git(sandbox, \"rev-parse\", \"origin/pull/1/head\"));\n-            assertEquals(git(sandbox, \"ls-remote\", \"origin\", \"refs/pull/1/head\").split(\"\\\\s\")[0], git(sandbox, \"rev-parse\", \"HEAD\"));\n-        }\n-\n-        @Test\n-        void cloneNoCheckoutReflectsDestinationRef(@TempDir File sandbox) {\n-            final String refSpec = \"refs/random/things:refs/remotes/origin/randomness\";\n-            final GitCommand git = withBranch(refSpec, sandbox);\n-\n-            final InMemoryStreamConsumer out = inMemoryConsumer();\n-            assertEquals(0, git.cloneWithNoCheckout(out, GIT_CUSTOM_REFS_BUNDLE));\n-            assertEquals(\"randomness\", git.getCurrentBranch());\n-\n-            git.fetch(out);\n-            assertEquals(\"+\" + git.expandRefSpec(), git.getConfigValue(\"remote.origin.fetch\"));\n-            assertEquals(git(sandbox, \"rev-parse\", \"HEAD\"), git(sandbox, \"rev-parse\", \"origin/randomness\"));\n-            assertEquals(git(sandbox, \"ls-remote\", \"origin\", \"refs/random/things\").split(\"\\\\s\")[0], git(sandbox, \"rev-parse\", \"HEAD\"));\n-        }\n-\n-        private String git(File cwd, String... args) {\n-            return CommandLine.createCommandLine(\"git\").\n-                    withEncoding(\"UTF-8\").\n-                    withWorkingDir(cwd).\n-                    withArgs(args).runOrBomb(new NamedProcessTag(null)).outputAsString();\n-        }\n+    @AfterEach\n+    void teardown() throws Exception {\n+        unsetColoring();\n+        unsetLogDecoration();\n+        TestRepo.internalTearDown();\n     }\n \n-    @Nested\n-    @EnableRuleMigrationSupport\n-    class Integration {\n-        private static final String BRANCH = \"foo\";\n-        private static final String SUBMODULE = \"submodule-1\";\n-        @Rule\n-        public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n-        @Rule\n-        public final TestRule restoreSystemProperties = new RestoreSystemProperties();\n-        private final Date THREE_DAYS_FROM_NOW = setMilliseconds(addDays(new Date(), 3), 0);\n-        private GitCommand git;\n-        private String repoUrl;\n-        private File repoLocation;\n-        private GitTestRepo gitRepo;\n-        private File gitLocalRepoDir;\n-        private GitTestRepo gitFooBranchBundle;\n-\n-        @BeforeEach\n-        void setup() throws IOException {\n-            gitRepo = new GitTestRepo(temporaryFolder);\n-            gitLocalRepoDir = createTempWorkingDirectory();\n-            git = new GitCommand(null, gitLocalRepoDir, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-            repoLocation = gitRepo.gitRepository();\n-            repoUrl = gitRepo.projectRepositoryUrl();\n-            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-            int returnCode = git.cloneWithNoCheckout(outputStreamConsumer, repoUrl);\n-            if (returnCode > 0) {\n-                fail(outputStreamConsumer.getAllOutput());\n-            }\n-            gitFooBranchBundle = GitTestRepo.testRepoAtBranch(GIT_FOO_BRANCH_BUNDLE, BRANCH, temporaryFolder);\n-        }\n-\n-        @AfterEach\n-        void teardown() {\n-            unsetColoring();\n-            unsetLogDecoration();\n-            TestRepo.internalTearDown();\n-        }\n-\n-        @Test\n-        void shouldCloneFromMasterWhenNoBranchIsSpecified() {\n-            InMemoryStreamConsumer output = inMemoryConsumer();\n-            git.clone(output, repoUrl);\n-            CommandLine commandLine = CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"branch\").withWorkingDir(gitLocalRepoDir);\n-            commandLine.run(output, null);\n-            assertEquals(\"* master\", output.getStdOut());\n-        }\n+    @Test\n+    void shouldDefaultToMasterIfNoBranchIsSpecified() {\n+        assertThat(getField(new GitCommand(null, gitLocalRepoDir, null, false, null), \"branch\")).isEqualTo(\"master\");\n+        assertThat(getField(new GitCommand(null, gitLocalRepoDir, \" \", false, null), \"branch\")).isEqualTo(\"master\");\n+        assertThat(getField(new GitCommand(null, gitLocalRepoDir, \"master\", false, null), \"branch\")).isEqualTo(\"master\");\n+        assertThat(getField(new GitCommand(null, gitLocalRepoDir, \"branch\", false, null), \"branch\")).isEqualTo(\"branch\");\n+    }\n \n-        @Test\n-        void freshCloneDoesNotHaveWorkingCopy() {\n-            assertWorkingCopyNotCheckedOut();\n-        }\n+    @Test\n+    void shouldCloneFromMasterWhenNoBranchIsSpecified() {\n+        InMemoryStreamConsumer output = inMemoryConsumer();\n+        git.clone(output, repoUrl);\n+        CommandLine commandLine = CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"branch\").withWorkingDir(gitLocalRepoDir);\n+        commandLine.run(output, null);\n+        assertThat(output.getStdOut()).isEqualTo(\"* master\");\n+    }\n \n-        @Test\n-        void freshCloneOnAgentSideShouldHaveWorkingCopyCheckedOut() throws IOException {\n-            InMemoryStreamConsumer output = inMemoryConsumer();\n-            File workingDir = createTempWorkingDirectory();\n-            GitCommand git = new GitCommand(null, workingDir, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+    @Test\n+    void freshCloneDoesNotHaveWorkingCopy() {\n+        assertWorkingCopyNotCheckedOut();\n+    }\n \n-            git.clone(output, repoUrl);\n+    @Test\n+    void freshCloneOnAgentSideShouldHaveWorkingCopyCheckedOut() throws IOException {\n+        InMemoryStreamConsumer output = inMemoryConsumer();\n+        File workingDir = createTempWorkingDirectory();\n+        GitCommand git = new GitCommand(null, workingDir, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n \n-            assertWorkingCopyCheckedOut(workingDir);\n-        }\n+        git.clone(output, repoUrl);\n \n-        @Test\n-        void fullCloneIsNotShallow() {\n-            assertFalse(git.isShallow());\n-        }\n+        assertWorkingCopyCheckedOut(workingDir);\n+    }\n \n-        @Test\n-        void shouldOnlyCloneLimitedRevisionsIfDepthSpecified() {\n-            FileUtils.deleteQuietly(this.gitLocalRepoDir);\n-            git.clone(inMemoryConsumer(), repoUrl, 2);\n-            assertTrue(git.isShallow());\n-            assertTrue(git.containsRevisionInBranch(GitTestRepo.REVISION_4));\n-            assertTrue(git.containsRevisionInBranch(GitTestRepo.REVISION_3));\n-            // can not assert on revision_2, because on old version of git (1.7)\n-            // depth '2' actually clone 3 revisions\n-            assertFalse(git.containsRevisionInBranch(GitTestRepo.REVISION_1));\n-            assertFalse(git.containsRevisionInBranch(GitTestRepo.REVISION_0));\n+    @Test\n+    void fullCloneIsNotShallow() {\n+        assertThat(git.isShallow()).isFalse();\n+    }\n \n-        }\n+    @Test\n+    void shouldOnlyCloneLimitedRevisionsIfDepthSpecified() throws Exception {\n+        FileUtils.deleteQuietly(this.gitLocalRepoDir);\n+        git.clone(inMemoryConsumer(), repoUrl, 2);\n+        assertThat(git.isShallow()).isTrue();\n+        assertThat(git.containsRevisionInBranch(GitTestRepo.REVISION_4)).isTrue();\n+        assertThat(git.containsRevisionInBranch(GitTestRepo.REVISION_3)).isTrue();\n+        // can not assert on revision_2, because on old version of git (1.7)\n+        // depth '2' actually clone 3 revisions\n+        assertThat(git.containsRevisionInBranch(GitTestRepo.REVISION_1)).isFalse();\n+        assertThat(git.containsRevisionInBranch(GitTestRepo.REVISION_0)).isFalse();\n \n-        @Test\n-        void unshallowALocalRepoWithArbitraryDepth() {\n-            FileUtils.deleteQuietly(this.gitLocalRepoDir);\n-            git.clone(inMemoryConsumer(), repoUrl, 2);\n-            git.unshallow(inMemoryConsumer(), 3);\n-            assertTrue(git.isShallow());\n-            assertTrue(git.containsRevisionInBranch(GitTestRepo.REVISION_2));\n-            // can not assert on revision_1, because on old version of git (1.7)\n-            // depth '3' actually clone 4 revisions\n-            assertFalse(git.containsRevisionInBranch(GitTestRepo.REVISION_0));\n-\n-            git.unshallow(inMemoryConsumer(), Integer.MAX_VALUE);\n-            assertFalse(git.isShallow());\n-\n-            assertTrue(git.containsRevisionInBranch(GitTestRepo.REVISION_0));\n-        }\n+    }\n \n-        @Test\n-        void unshallowShouldNotResultInWorkingCopyCheckout() {\n-            FileUtils.deleteQuietly(this.gitLocalRepoDir);\n-            git.cloneWithNoCheckout(inMemoryConsumer(), repoUrl);\n-            git.unshallow(inMemoryConsumer(), 3);\n-            assertWorkingCopyNotCheckedOut();\n-        }\n+    @Test\n+    void unshallowALocalRepoWithArbitraryDepth() throws Exception {\n+        FileUtils.deleteQuietly(this.gitLocalRepoDir);\n+        git.clone(inMemoryConsumer(), repoUrl, 2);\n+        git.unshallow(inMemoryConsumer(), 3);\n+        assertThat(git.isShallow()).isTrue();\n+        assertThat(git.containsRevisionInBranch(GitTestRepo.REVISION_2)).isTrue();\n+        // can not assert on revision_1, because on old version of git (1.7)\n+        // depth '3' actually clone 4 revisions\n+        assertThat(git.containsRevisionInBranch(GitTestRepo.REVISION_0)).isFalse();\n+\n+        git.unshallow(inMemoryConsumer(), Integer.MAX_VALUE);\n+        assertThat(git.isShallow()).isFalse();\n+\n+        assertThat(git.containsRevisionInBranch(GitTestRepo.REVISION_0)).isTrue();\n+    }\n \n-        @Test\n-        void shouldCloneFromBranchWhenMaterialPointsToABranch() throws IOException {\n-            gitLocalRepoDir = createTempWorkingDirectory();\n-            git = new GitCommand(null, gitLocalRepoDir, BRANCH, false, null);\n-            GitCommand branchedGit = new GitCommand(null, gitLocalRepoDir, BRANCH, false, null);\n-            branchedGit.clone(inMemoryConsumer(), gitFooBranchBundle.projectRepositoryUrl());\n-            InMemoryStreamConsumer output = inMemoryConsumer();\n-            CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"branch\").withWorkingDir(gitLocalRepoDir).run(output, null);\n-            assertEquals(\"* foo\", output.getStdOut());\n-        }\n+    @Test\n+    void unshallowShouldNotResultInWorkingCopyCheckout() {\n+        FileUtils.deleteQuietly(this.gitLocalRepoDir);\n+        git.cloneWithNoCheckout(inMemoryConsumer(), repoUrl);\n+        git.unshallow(inMemoryConsumer(), 3);\n+        assertWorkingCopyNotCheckedOut();\n+    }\n \n-        @Test\n-        void shouldGetTheCurrentBranchForTheCheckedOutRepo() throws IOException {\n-            gitLocalRepoDir = createTempWorkingDirectory();\n-            CommandLine gitCloneCommand = CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"clone\");\n-            gitCloneCommand.withArg(\"--branch=\" + BRANCH).withArg(new UrlArgument(gitFooBranchBundle.projectRepositoryUrl())).withArg(gitLocalRepoDir.getAbsolutePath());\n-            gitCloneCommand.run(inMemoryConsumer(), null);\n-            git = new GitCommand(null, gitLocalRepoDir, BRANCH, false, null);\n-            assertEquals(BRANCH, git.getCurrentBranch());\n-        }\n+    @Test\n+    void shouldCloneFromBranchWhenMaterialPointsToABranch() throws IOException {\n+        gitLocalRepoDir = createTempWorkingDirectory();\n+        git = new GitCommand(null, gitLocalRepoDir, BRANCH, false, null);\n+        GitCommand branchedGit = new GitCommand(null, gitLocalRepoDir, BRANCH, false, null);\n+        branchedGit.clone(inMemoryConsumer(), gitFooBranchBundle.projectRepositoryUrl());\n+        InMemoryStreamConsumer output = inMemoryConsumer();\n+        CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"branch\").withWorkingDir(gitLocalRepoDir).run(output, null);\n+        assertThat(output.getStdOut()).isEqualTo(\"* foo\");\n+    }\n \n-        @Test\n-        void shouldBombForFetchFailure() {\n-            gitInRepo(\"remote\", \"rm\", \"origin\");\n-            gitInRepo(\"remote\", \"add\", \"origin\", \"git://user:secret@foo.bar/baz\");\n-            final String message = assertThrows(Exception.class, () -> git.fetch(inMemoryConsumer())).getMessage();\n-            assertEquals(\"git fetch failed for [git://user:******@foo.bar/baz]\", message);\n-        }\n+    @Test\n+    void shouldGetTheCurrentBranchForTheCheckedOutRepo() throws IOException {\n+        gitLocalRepoDir = createTempWorkingDirectory();\n+        CommandLine gitCloneCommand = CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"clone\");\n+        gitCloneCommand.withArg(\"--branch=\" + BRANCH).withArg(new UrlArgument(gitFooBranchBundle.projectRepositoryUrl())).withArg(gitLocalRepoDir.getAbsolutePath());\n+        gitCloneCommand.run(inMemoryConsumer(), null);\n+        git = new GitCommand(null, gitLocalRepoDir, BRANCH, false, null);\n+        assertThat(git.getCurrentBranch()).isEqualTo(BRANCH);\n+    }\n \n-        @Test\n-        void shouldBombForResettingFailure() {\n-            final String message = assertThrows(\n-                    Exception.class,\n-                    () -> git.resetWorkingDir(new SysOutStreamConsumer(), new StringRevision(\"abcdef\"), false)\n-            ).getMessage();\n-            assertEquals(format(\"git reset failed for [%s]\", gitLocalRepoDir), message);\n+    @Test\n+    void shouldBombForFetchFailure() throws IOException {\n+        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n+        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", \"git://user:secret@foo.bar/baz\");\n+        try {\n+            InMemoryStreamConsumer output = new InMemoryStreamConsumer();\n+            git.fetch(output);\n+            fail(\"should have failed for non 0 return code. Git output was:\\n \" + output.getAllOutput());\n+        } catch (Exception e) {\n+            assertThat(e.getMessage()).isEqualTo(\"git fetch failed for [git://user:******@foo.bar/baz]\");\n         }\n+    }\n \n-        @Test\n-        void shouldOutputSubmoduleRevisionsAfterUpdate() throws Exception {\n-            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-            submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n-            GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-            gitWithSubmodule.clone(inMemoryConsumer(), submoduleRepos.mainRepo().urlForCommandLine());\n-            InMemoryStreamConsumer outConsumer = new InMemoryStreamConsumer();\n-            gitWithSubmodule.resetWorkingDir(outConsumer, new StringRevision(\"HEAD\"), false);\n-            Matcher matcher = compile(\".*^\\\\s[a-f0-9A-F]{40} sub1 \\\\(heads/master\\\\)$.*\", Pattern.MULTILINE | Pattern.DOTALL).matcher(outConsumer.getAllOutput());\n-            assertTrue(matcher.matches());\n+    @Test\n+    void shouldBombForResettingFailure() throws IOException {\n+        try {\n+            git.resetWorkingDir(new SysOutStreamConsumer(), new StringRevision(\"abcdef\"), false);\n+            fail(\"should have failed for non 0 return code\");\n+        } catch (Exception e) {\n+            assertThat(e.getMessage()).isEqualTo(String.format(\"git reset failed for [%s]\", gitLocalRepoDir));\n         }\n+    }\n \n-        @Test\n-        void shouldBombForResetWorkingDirWhenSubmoduleUpdateFails() throws Exception {\n-            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-            File submoduleFolder = submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n-            GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-            gitWithSubmodule.clone(inMemoryConsumer(), submoduleRepos.mainRepo().urlForCommandLine());\n-            FileUtils.deleteDirectory(submoduleFolder);\n-\n-            assertFalse(submoduleFolder.exists());\n-\n-            final String message = assertThrows(\n-                    Exception.class,\n-                    () -> gitWithSubmodule.resetWorkingDir(new SysOutStreamConsumer(), new StringRevision(\"HEAD\"), false))\n-                    .getMessage();\n+    @Test\n+    void shouldOutputSubmoduleRevisionsAfterUpdate() throws Exception {\n+        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+        submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n+        GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+        gitWithSubmodule.clone(inMemoryConsumer(), submoduleRepos.mainRepo().getUrl());\n+        InMemoryStreamConsumer outConsumer = new InMemoryStreamConsumer();\n+        gitWithSubmodule.resetWorkingDir(outConsumer, new StringRevision(\"HEAD\"), false);\n+        Matcher matcher = Pattern.compile(\".*^\\\\s[a-f0-9A-F]{40} sub1 \\\\(heads/master\\\\)$.*\", Pattern.MULTILINE | Pattern.DOTALL).matcher(outConsumer.getAllOutput());\n+        assertThat(matcher.matches()).isTrue();\n+    }\n \n-            final String expectedError = format(\"[Cc]lone of '%s' into submodule path '((.*)[\\\\/])?sub1' failed\",\n-                    quote(FileUtil.toFileURI(submoduleFolder.getAbsolutePath()) + \"/\"));\n-            assertTrue(compile(expectedError).matcher(message).find());\n+    @Test\n+    void shouldBombForResetWorkingDirWhenSubmoduleUpdateFails() throws Exception {\n+        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+        File submoduleFolder = submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n+        GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+        gitWithSubmodule.clone(inMemoryConsumer(), submoduleRepos.mainRepo().getUrl());\n+        FileUtils.deleteDirectory(submoduleFolder);\n+\n+        assertThat(submoduleFolder.exists()).isFalse();\n+        try {\n+            gitWithSubmodule.resetWorkingDir(new SysOutStreamConsumer(), new StringRevision(\"HEAD\"), false);\n+            fail(\"should have failed for non 0 return code\");\n+        } catch (Exception e) {\n+            assertThat(e.getMessage()).containsPattern(\n+                    String.format(\"[Cc]lone of '%s' into submodule path '((.*)[\\\\/])?sub1' failed\",\n+                            Pattern.quote(FileUtil.toFileURI(submoduleFolder.getAbsolutePath()) + \"/\")));\n         }\n+    }\n \n-        @Test\n-        void shouldRetrieveLatestModification() {\n-            Modification mod = git.latestModification().get(0);\n-            assertEquals(\"Chris Turner <cturner@thoughtworks.com>\", mod.getUserName());\n-            assertEquals(\"Added 'run-till-file-exists' ant target\", mod.getComment());\n-            assertEquals(parseRFC822(\"Fri, 12 Feb 2010 16:12:04 -0800\"), mod.getModifiedTime());\n-            assertEquals(\"5def073a425dfe239aabd4bf8039ffe3b0e8856b\", mod.getRevision());\n-\n-            List<ModifiedFile> files = mod.getModifiedFiles();\n-            assertEquals(1, files.size());\n-            assertEquals(\"build.xml\", files.get(0).getFileName());\n-            assertEquals(ModifiedAction.modified, files.get(0).getAction());\n-        }\n+    @Test\n+    void shouldRetrieveLatestModification() throws Exception {\n+        Modification mod = git.latestModification().get(0);\n+        assertThat(mod.getUserName()).isEqualTo(\"Chris Turner <cturner@thoughtworks.com>\");\n+        assertThat(mod.getComment()).isEqualTo(\"Added 'run-till-file-exists' ant target\");\n+        assertThat(mod.getModifiedTime()).isEqualTo(parseRFC822(\"Fri, 12 Feb 2010 16:12:04 -0800\"));\n+        assertThat(mod.getRevision()).isEqualTo(\"5def073a425dfe239aabd4bf8039ffe3b0e8856b\");\n+\n+        List<ModifiedFile> files = mod.getModifiedFiles();\n+        assertThat(files.size()).isEqualTo(1);\n+        assertThat(files.get(0).getFileName()).isEqualTo(\"build.xml\");\n+        assertThat(files.get(0).getAction()).isEqualTo(ModifiedAction.modified);\n+    }\n \n-        @Test\n-        void shouldRetrieveLatestModificationWhenColoringIsSetToAlways() {\n-            setColoring();\n-            Modification mod = git.latestModification().get(0);\n-            assertEquals(\"Chris Turner <cturner@thoughtworks.com>\", mod.getUserName());\n-            assertEquals(\"Added 'run-till-file-exists' ant target\", mod.getComment());\n-            assertEquals(parseRFC822(\"Fri, 12 Feb 2010 16:12:04 -0800\"), mod.getModifiedTime());\n-            assertEquals(\"5def073a425dfe239aabd4bf8039ffe3b0e8856b\", mod.getRevision());\n-\n-            List<ModifiedFile> files = mod.getModifiedFiles();\n-            assertEquals(1, files.size());\n-            assertEquals(\"build.xml\", files.get(0).getFileName());\n-            assertEquals(ModifiedAction.modified, files.get(0).getAction());\n-        }\n+    @Test\n+    void shouldRetrieveLatestModificationWhenColoringIsSetToAlways() throws Exception {\n+        setColoring();\n+        Modification mod = git.latestModification().get(0);\n+        assertThat(mod.getUserName()).isEqualTo(\"Chris Turner <cturner@thoughtworks.com>\");\n+        assertThat(mod.getComment()).isEqualTo(\"Added 'run-till-file-exists' ant target\");\n+        assertThat(mod.getModifiedTime()).isEqualTo(parseRFC822(\"Fri, 12 Feb 2010 16:12:04 -0800\"));\n+        assertThat(mod.getRevision()).isEqualTo(\"5def073a425dfe239aabd4bf8039ffe3b0e8856b\");\n+\n+        List<ModifiedFile> files = mod.getModifiedFiles();\n+        assertThat(files.size()).isEqualTo(1);\n+        assertThat(files.get(0).getFileName()).isEqualTo(\"build.xml\");\n+        assertThat(files.get(0).getAction()).isEqualTo(ModifiedAction.modified);\n+    }\n \n-        @Test\n-        void shouldRetrieveLatestModificationWhenLogDecorationIsPresent() {\n-            setLogDecoration();\n-            Modification mod = git.latestModification().get(0);\n-            assertEquals(\"Chris Turner <cturner@thoughtworks.com>\", mod.getUserName());\n-            assertEquals(\"Added 'run-till-file-exists' ant target\", mod.getComment());\n-            assertEquals(parseRFC822(\"Fri, 12 Feb 2010 16:12:04 -0800\"), mod.getModifiedTime());\n-            assertEquals(\"5def073a425dfe239aabd4bf8039ffe3b0e8856b\", mod.getRevision());\n-\n-            List<ModifiedFile> files = mod.getModifiedFiles();\n-            assertEquals(1, files.size());\n-            assertEquals(\"build.xml\", files.get(0).getFileName());\n-            assertEquals(ModifiedAction.modified, files.get(0).getAction());\n-        }\n+    @Test\n+    void shouldRetrieveLatestModificationWhenLogDecorationIsPresent() throws Exception {\n+        setLogDecoration();\n+        Modification mod = git.latestModification().get(0);\n+        assertThat(mod.getUserName()).isEqualTo(\"Chris Turner <cturner@thoughtworks.com>\");\n+        assertThat(mod.getComment()).isEqualTo(\"Added 'run-till-file-exists' ant target\");\n+        assertThat(mod.getModifiedTime()).isEqualTo(parseRFC822(\"Fri, 12 Feb 2010 16:12:04 -0800\"));\n+        assertThat(mod.getRevision()).isEqualTo(\"5def073a425dfe239aabd4bf8039ffe3b0e8856b\");\n+\n+        List<ModifiedFile> files = mod.getModifiedFiles();\n+        assertThat(files.size()).isEqualTo(1);\n+        assertThat(files.get(0).getFileName()).isEqualTo(\"build.xml\");\n+        assertThat(files.get(0).getAction()).isEqualTo(ModifiedAction.modified);\n+    }\n \n-        @Test\n-        void retrieveLatestModificationShouldNotResultInWorkingCopyCheckOut() {\n-            git.latestModification();\n-            assertWorkingCopyNotCheckedOut();\n-        }\n+    @Test\n+    void retrieveLatestModificationShouldNotResultInWorkingCopyCheckOut() throws Exception {\n+        git.latestModification();\n+        assertWorkingCopyNotCheckedOut();\n+    }\n \n-        @Test\n-        void getModificationsSinceShouldNotResultInWorkingCopyCheckOut() {\n-            git.modificationsSince(GitTestRepo.REVISION_2);\n-            assertWorkingCopyNotCheckedOut();\n-        }\n+    @Test\n+    void getModificationsSinceShouldNotResultInWorkingCopyCheckOut() throws Exception {\n+        git.modificationsSince(GitTestRepo.REVISION_2);\n+        assertWorkingCopyNotCheckedOut();\n+    }\n \n-        @Test\n-        void shouldReturnNothingForModificationsSinceIfARebasedCommitSHAIsPassed() throws IOException {\n-            GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n-            gitInRepo(\"remote\", \"rm\", \"origin\");\n-            gitInRepo(\"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n-            GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n+    @Test\n+    void shouldReturnNothingForModificationsSinceIfARebasedCommitSHAIsPassed() throws IOException {\n+        GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n+        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n+        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n+        GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n \n-            Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n+        Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n \n-            assertTrue(command.modificationsSince(new StringRevision(modification.getRevision())).isEmpty());\n+        assertThat(command.modificationsSince(new StringRevision(modification.getRevision()))).isEmpty();\n \n-        }\n+    }\n \n-        @Test\n-        void shouldReturnTheRebasedCommitForModificationsSinceTheRevisionBeforeRebase() throws IOException {\n-            GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n-            gitInRepo(\"remote\", \"rm\", \"origin\");\n-            gitInRepo(\"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n-            GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n+    @Test\n+    void shouldReturnTheRebasedCommitForModificationsSinceTheRevisionBeforeRebase() throws IOException {\n+        GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n+        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n+        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n+        GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n \n-            Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n+        Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n \n-            assertEquals(modification, command.modificationsSince(REVISION_4).get(0));\n-        }\n+        assertThat(command.modificationsSince(REVISION_4).get(0)).isEqualTo(modification);\n+    }\n \n-        @Test\n-        void shouldReturnTheRebasedCommitForModificationsSinceTheRevisionBeforeRebaseWithColoringIsSetToAlways() throws IOException {\n-            GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n-            gitInRepo(\"remote\", \"rm\", \"origin\");\n-            gitInRepo(\"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n-            GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n+    @Test\n+    void shouldReturnTheRebasedCommitForModificationsSinceTheRevisionBeforeRebaseWithColoringIsSetToAlways() throws IOException {\n+        GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n+        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n+        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n+        GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n \n-            Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n-            setColoring();\n+        Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n+        setColoring();\n \n-            assertEquals(modification, command.modificationsSince(REVISION_4).get(0));\n-        }\n+        assertThat(command.modificationsSince(REVISION_4).get(0)).isEqualTo(modification);\n+    }\n \n-        @Test\n-        void shouldReturnTheRebasedCommitForModificationsSinceTheRevisionBeforeRebaseWithLogDecoration() throws IOException {\n-            GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n-            gitInRepo(\"remote\", \"rm\", \"origin\");\n-            gitInRepo(\"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n-            GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n+    @Test\n+    void shouldReturnTheRebasedCommitForModificationsSinceTheRevisionBeforeRebaseWithLogDecoration() throws IOException {\n+        GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n+        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n+        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n+        GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n \n-            Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n-            setLogDecoration();\n+        Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n+        setLogDecoration();\n \n-            assertEquals(modification, command.modificationsSince(REVISION_4).get(0));\n-        }\n+        assertThat(command.modificationsSince(REVISION_4).get(0)).isEqualTo(modification);\n+    }\n \n-        @Test\n-        void shouldBombIfCheckedForModificationsSinceWithASHAThatNoLongerExists() throws IOException {\n-            GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n-            gitInRepo(\"remote\", \"rm\", \"origin\");\n-            gitInRepo(\"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n-            GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n+    @Test\n+    void shouldBombIfCheckedForModificationsSinceWithASHAThatNoLongerExists() throws IOException {\n+        GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n+        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n+        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n+        GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n \n-            Modification modification = remoteRepo.checkInOneFile(\"foo\", \"Adding a commit\").get(0);\n-            remoteRepo.addFileAndAmend(\"bar\", \"amendedCommit\");\n+        Modification modification = remoteRepo.checkInOneFile(\"foo\", \"Adding a commit\").get(0);\n+        remoteRepo.addFileAndAmend(\"bar\", \"amendedCommit\");\n \n-            assertThrows(CommandLineException.class, () -> command.modificationsSince(new StringRevision(modification.getRevision())));\n-        }\n+        assertThatCode(() -> command.modificationsSince(new StringRevision(modification.getRevision())))\n+                .isInstanceOf(CommandLineException.class);\n+    }\n \n-        @Test\n-        void shouldBombIfCheckedForModificationsSinceWithANonExistentRef() throws IOException {\n-            GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n-            gitInRepo(\"remote\", \"rm\", \"origin\");\n-            gitInRepo(\"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n-            GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"non-existent-branch\", false, null);\n+    @Test\n+    void shouldBombIfCheckedForModificationsSinceWithANonExistentRef() throws IOException {\n+        GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n+        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n+        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n+        GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"non-existent-branch\", false, null);\n \n-            Modification modification = remoteRepo.checkInOneFile(\"foo\", \"Adding a commit\").get(0);\n+        Modification modification = remoteRepo.checkInOneFile(\"foo\", \"Adding a commit\").get(0);\n \n-            assertThrows(CommandLineException.class, () -> command.modificationsSince(new StringRevision(modification.getRevision())));\n-        }\n+        assertThatCode(() -> command.modificationsSince(new StringRevision(modification.getRevision())))\n+                .isInstanceOf(CommandLineException.class);\n+    }\n \n-        @Test\n-        void shouldBombWhileRetrievingLatestModificationFromANonExistentRef() throws IOException {\n-            GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n-            gitInRepo(\"remote\", \"rm\", \"origin\");\n-            gitInRepo(\"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n-            GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"non-existent-branch\", false, null);\n+    @Test\n+    void shouldBombWhileRetrievingLatestModificationFromANonExistentRef() throws IOException {\n+        expectedException.expect(CommandLineException.class);\n+        expectedException.expectMessage(\"ambiguous argument 'origin/non-existent-branch': unknown revision or path not in the working tree.\");\n+        GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n+        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n+        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n+        GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"non-existent-branch\", false, null);\n \n-            final String message = assertThrows(CommandLineException.class, command::latestModification).getMessage();\n-            assertTrue(message.contains(\"ambiguous argument 'origin/non-existent-branch': unknown revision or path not in the working tree.\"));\n-        }\n+        command.latestModification();\n+    }\n \n-        @Test\n-        void shouldReturnTrueIfTheGivenBranchContainsTheRevision() {\n-            assertTrue(git.containsRevisionInBranch(REVISION_4));\n-        }\n+    @Test\n+    void shouldReturnTrueIfTheGivenBranchContainsTheRevision() {\n+        assertThat(git.containsRevisionInBranch(REVISION_4)).isTrue();\n+    }\n \n-        @Test\n-        void shouldReturnFalseIfTheGivenBranchDoesNotContainTheRevision() {\n-            assertFalse(git.containsRevisionInBranch(NON_EXISTENT_REVISION));\n-        }\n+    @Test\n+    void shouldReturnFalseIfTheGivenBranchDoesNotContainTheRevision() {\n+        assertThat(git.containsRevisionInBranch(NON_EXISTENT_REVISION)).isFalse();\n+    }\n \n-        @Test\n-        void shouldRetrieveFilenameForInitialRevision() throws IOException {\n-            GitTestRepo testRepo = new GitTestRepo(GitTestRepo.GIT_SUBMODULE_REF_BUNDLE, temporaryFolder);\n-            GitCommand gitCommand = new GitCommand(null, testRepo.gitRepository(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-            Modification modification = gitCommand.latestModification().get(0);\n-            assertEquals(1, modification.getModifiedFiles().size());\n-            assertEquals(\"remote.txt\", modification.getModifiedFiles().get(0).getFileName());\n-        }\n+    @Test\n+    void shouldRetrieveFilenameForInitialRevision() throws IOException {\n+        GitTestRepo testRepo = new GitTestRepo(GitTestRepo.GIT_SUBMODULE_REF_BUNDLE, temporaryFolder);\n+        GitCommand gitCommand = new GitCommand(null, testRepo.gitRepository(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+        Modification modification = gitCommand.latestModification().get(0);\n+        assertThat(modification.getModifiedFiles()).hasSize(1);\n+        assertThat(modification.getModifiedFiles().get(0).getFileName()).isEqualTo(\"remote.txt\");\n+    }\n \n-        @Test\n-        void shouldRetrieveLatestModificationFromBranch() throws Exception {\n-            GitTestRepo branchedRepo = GitTestRepo.testRepoAtBranch(GIT_FOO_BRANCH_BUNDLE, BRANCH, temporaryFolder);\n-            GitCommand branchedGit = new GitCommand(null, createTempWorkingDirectory(), BRANCH, false, null);\n-            branchedGit.clone(inMemoryConsumer(), branchedRepo.projectRepositoryUrl());\n+    @Test\n+    void shouldRetrieveLatestModificationFromBranch() throws Exception {\n+        GitTestRepo branchedRepo = GitTestRepo.testRepoAtBranch(GIT_FOO_BRANCH_BUNDLE, BRANCH, temporaryFolder);\n+        GitCommand branchedGit = new GitCommand(null, createTempWorkingDirectory(), BRANCH, false, null);\n+        branchedGit.clone(inMemoryConsumer(), branchedRepo.projectRepositoryUrl());\n \n-            Modification mod = branchedGit.latestModification().get(0);\n+        Modification mod = branchedGit.latestModification().get(0);\n \n-            assertEquals(\"Chris Turner <cturner@thoughtworks.com>\", mod.getUserName());\n-            assertEquals(\"Started foo branch\", mod.getComment());\n-            assertEquals(parseRFC822(\"Tue, 05 Feb 2009 14:28:08 -0800\"), mod.getModifiedTime());\n-            assertEquals(\"b4fa7271c3cef91822f7fa502b999b2eab2a380d\", mod.getRevision());\n+        assertThat(mod.getUserName()).isEqualTo(\"Chris Turner <cturner@thoughtworks.com>\");\n+        assertThat(mod.getComment()).isEqualTo(\"Started foo branch\");\n+        assertThat(mod.getModifiedTime()).isEqualTo(parseRFC822(\"Tue, 05 Feb 2009 14:28:08 -0800\"));\n+        assertThat(mod.getRevision()).isEqualTo(\"b4fa7271c3cef91822f7fa502b999b2eab2a380d\");\n \n-            List<ModifiedFile> files = mod.getModifiedFiles();\n-            assertEquals(1, files.size());\n-            assertEquals(\"first.txt\", files.get(0).getFileName());\n-            assertEquals(ModifiedAction.modified, files.get(0).getAction());\n-        }\n+        List<ModifiedFile> files = mod.getModifiedFiles();\n+        assertThat(files).hasSize(1);\n+        assertThat(files.get(0).getFileName()).isEqualTo(\"first.txt\");\n+        assertThat(files.get(0).getAction()).isEqualTo(ModifiedAction.modified);\n+    }\n \n-        @Test\n-        void shouldRetrieveListOfSubmoduleFolders() throws Exception {\n-            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-            submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n-            GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-            gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().urlForCommandLine());\n-            gitWithSubmodule.fetchAndResetToHead(outputStreamConsumer, false);\n-            gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n-            List<String> folders = gitWithSubmodule.submoduleFolders();\n-            assertEquals(1, folders.size());\n-            assertEquals(\"sub1\", folders.get(0));\n-        }\n+    @Test\n+    void shouldRetrieveListOfSubmoduleFolders() throws Exception {\n+        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+        submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n+        GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+        gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().getUrl());\n+        gitWithSubmodule.fetchAndResetToHead(outputStreamConsumer);\n+        gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n+        List<String> folders = gitWithSubmodule.submoduleFolders();\n+        assertThat(folders).hasSize(1);\n+        assertThat(folders.get(0)).isEqualTo(\"sub1\");\n+    }\n \n-        @Test\n-        void shouldNotThrowErrorWhenConfigRemoveSectionFails() throws Exception {\n-            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-            submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n-            GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null) {\n-                //hack to reproduce synchronization issue\n-                @Override\n-                public Map<String, String> submoduleUrls() {\n-                    return Collections.singletonMap(\"submodule\", \"submodule\");\n-                }\n-            };\n-            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-            gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().urlForCommandLine());\n-\n-            gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n+    @Test\n+    void shouldNotThrowErrorWhenConfigRemoveSectionFails() throws Exception {\n+        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+        submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n+        GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null) {\n+            //hack to reproduce synchronization issue\n+            @Override\n+            public Map<String, String> submoduleUrls() {\n+                return Collections.singletonMap(\"submodule\", \"submodule\");\n+            }\n+        };\n+        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+        gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().getUrl());\n \n-        }\n+        gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n \n-        @Test\n-        void shouldNotFailIfUnableToRemoveSubmoduleEntryFromConfig() throws Exception {\n-            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-            submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n-            GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-            gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().urlForCommandLine());\n-            gitWithSubmodule.fetchAndResetToHead(outputStreamConsumer, false);\n-            gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n-            List<String> folders = gitWithSubmodule.submoduleFolders();\n-            assertEquals(1, folders.size());\n-            assertEquals(\"sub1\", folders.get(0));\n-        }\n+    }\n \n-        @Test\n-        void shouldRetrieveSubmoduleUrls() throws Exception {\n-            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-            File submodule = submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n-            GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-            gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().urlForCommandLine());\n-            gitWithSubmodule.fetchAndResetToHead(outputStreamConsumer, false);\n-\n-            gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n-            Map<String, String> urls = gitWithSubmodule.submoduleUrls();\n-            assertEquals(1, urls.size());\n-            assertTrue(urls.containsKey(\"sub1\"));\n-            assertEquals(FileUtil.toFileURI(submodule), urls.get(\"sub1\"));\n-        }\n+    @Test\n+    void shouldNotFailIfUnableToRemoveSubmoduleEntryFromConfig() throws Exception {\n+        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+        submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n+        GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+        gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().getUrl());\n+        gitWithSubmodule.fetchAndResetToHead(outputStreamConsumer);\n+        gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n+        List<String> folders = gitWithSubmodule.submoduleFolders();\n+        assertThat(folders).hasSize(1);\n+        assertThat(folders.get(0)).isEqualTo(\"sub1\");\n+    }\n \n-        @Test\n-        void shouldRetrieveZeroSubmoduleUrlsIfTheyAreNotConfigured() {\n-            Map<String, String> submoduleUrls = git.submoduleUrls();\n-            assertTrue(submoduleUrls.isEmpty());\n-        }\n+    @Test\n+    void shouldRetrieveSubmoduleUrls() throws Exception {\n+        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+        File submodule = submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n+        GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+        gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().getUrl());\n+        gitWithSubmodule.fetchAndResetToHead(outputStreamConsumer);\n+\n+        gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n+        Map<String, String> urls = gitWithSubmodule.submoduleUrls();\n+        assertThat(urls).hasSize(1);\n+        assertThat(urls.containsKey(\"sub1\")).isTrue();\n+        assertThat(urls.get(\"sub1\")).isEqualTo(FileUtil.toFileURI(submodule));\n+    }\n \n-        @Test\n-        void shouldRetrieveRemoteRepoValue() {\n-            assertTrue(git.workingRepositoryUrl().originalArgument().startsWith(repoUrl));\n-        }\n+    @Test\n+    void shouldRetrieveZeroSubmoduleUrlsIfTheyAreNotConfigured() {\n+        Map<String, String> submoduleUrls = git.submoduleUrls();\n+        assertThat(submoduleUrls).isEmpty();\n+    }\n \n-        @Test\n-        void shouldCheckIfRemoteRepoExists() {\n-            GitCommand gitCommand = withBranch(\"master\");\n-            gitCommand.checkConnection(git.workingRepositoryUrl());\n-        }\n+    @Test\n+    void shouldRetrieveRemoteRepoValue() {\n+        assertThat(git.workingRepositoryUrl().originalArgument()).startsWith(repoUrl);\n+    }\n \n-        @Test\n-        void shouldThrowExceptionWhenRepoNotExist() {\n-            GitCommand gitCommand = withBranch(\"master\");\n+    @Test\n+    void shouldCheckIfRemoteRepoExists() {\n+        GitCommand gitCommand = new GitCommand(null, null, null, false, null);\n+        gitCommand.checkConnection(git.workingRepositoryUrl(), \"master\");\n+    }\n \n-            assertThrows(Exception.class, () -> gitCommand.checkConnection(new UrlArgument(\"git://does.not.exist\")));\n-        }\n+    @Test\n+    void shouldThrowExceptionWhenRepoNotExist() {\n+        GitCommand gitCommand = new GitCommand(null, null, null, false, null);\n \n-        @Test\n-        void shouldThrowExceptionWhenRemoteBranchDoesNotExist() {\n-            GitCommand gitCommand = withBranch(\"Invalid_Branch\");\n+        assertThatCode(() -> gitCommand.checkConnection(new UrlArgument(\"git://somewhere.is.not.exist\"), \"master\"))\n+                .isInstanceOf(Exception.class);\n+    }\n \n-            assertThrows(Exception.class, () -> gitCommand.checkConnection(new UrlArgument(repoUrl)));\n-        }\n+    @Test\n+    void shouldThrowExceptionWhenRemoteBranchDoesNotExist() {\n+        GitCommand gitCommand = new GitCommand(null, null, null, false, null);\n \n+        assertThatCode(() -> gitCommand.checkConnection(new UrlArgument(gitRepo.projectRepositoryUrl()), \"Invalid_Branch\"))\n+                .isInstanceOf(Exception.class);\n+    }\n \n-        @Test\n-        void shouldIncludeNewChangesInModificationCheck() throws Exception {\n-            String originalNode = git.latestModification().get(0).getRevision();\n-            File testingFile = checkInNewRemoteFile();\n \n-            Modification modification = git.latestModification().get(0);\n-            assertNotEquals(originalNode, modification.getRevision());\n-            assertEquals(\"New checkin of \" + testingFile.getName(), modification.getComment());\n-            assertEquals(1, modification.getModifiedFiles().size());\n-            assertEquals(testingFile.getName(), modification.getModifiedFiles().get(0).getFileName());\n-        }\n+    @Test\n+    void shouldIncludeNewChangesInModificationCheck() throws Exception {\n+        String originalNode = git.latestModification().get(0).getRevision();\n+        File testingFile = checkInNewRemoteFile();\n \n-        @Test\n-        void shouldIncludeChangesFromTheFutureInModificationCheck() throws Exception {\n-            String originalNode = git.latestModification().get(0).getRevision();\n-            File testingFile = checkInNewRemoteFileInFuture(THREE_DAYS_FROM_NOW);\n+        Modification modification = git.latestModification().get(0);\n+        assertThat(modification.getRevision()).isNotEqualTo(originalNode);\n+        assertThat(modification.getComment()).isEqualTo(\"New checkin of \" + testingFile.getName());\n+        assertThat(modification.getModifiedFiles()).hasSize(1);\n+        assertThat(modification.getModifiedFiles().get(0).getFileName()).isEqualTo(testingFile.getName());\n+    }\n \n-            Modification modification = git.latestModification().get(0);\n-            assertNotEquals(originalNode, modification.getRevision());\n-            assertEquals(\"New checkin of \" + testingFile.getName(), modification.getComment());\n-            assertEquals(THREE_DAYS_FROM_NOW, modification.getModifiedTime());\n-        }\n+    @Test\n+    void shouldIncludeChangesFromTheFutureInModificationCheck() throws Exception {\n+        String originalNode = git.latestModification().get(0).getRevision();\n+        File testingFile = checkInNewRemoteFileInFuture(THREE_DAYS_FROM_NOW);\n \n-        @Test\n-        void shouldThrowExceptionIfRepoCanNotConnectWhenModificationCheck() {\n-            FileUtils.deleteQuietly(repoLocation);\n+        Modification modification = git.latestModification().get(0);\n+        assertThat(modification.getRevision()).isNotEqualTo(originalNode);\n+        assertThat(modification.getComment()).isEqualTo(\"New checkin of \" + testingFile.getName());\n+        assertThat(modification.getModifiedTime()).isEqualTo(THREE_DAYS_FROM_NOW);\n+    }\n \n-            final String message = assertThrows(Exception.class, git::latestModification).getMessage();\n-            assertTrue(\n-                    message.contains(\"The remote end hung up unexpectedly\") ||\n-                            message.contains(\"Could not read from remote repository\")\n-            );\n+    @Test\n+    void shouldThrowExceptionIfRepoCanNotConnectWhenModificationCheck() {\n+        FileUtils.deleteQuietly(repoLocation);\n+        try {\n+            git.latestModification();\n+            fail(\"Should throw exception when repo cannot connected\");\n+        } catch (Exception e) {\n+            assertThat(e.getMessage()).matches(str -> str.contains(\"The remote end hung up unexpectedly\") ||\n+                    str.contains(\"Could not read from remote repository\"));\n         }\n+    }\n \n-        @Test\n-        void shouldParseGitOutputCorrectly() throws IOException {\n-            List<String> stringList;\n-            try (InputStream resourceAsStream = getClass().getResourceAsStream(\"git_sample_output.text\")) {\n-                stringList = IOUtils.readLines(resourceAsStream, UTF_8);\n-            }\n-\n-            GitModificationParser parser = new GitModificationParser();\n-            List<Modification> mods = parser.parse(stringList);\n-            assertEquals(3, mods.size());\n-\n-            Modification mod = mods.get(2);\n-            assertEquals(\"46cceff864c830bbeab0a7aaa31707ae2302762f\", mod.getRevision());\n-            assertEquals(DateUtils.parseISO8601(\"2009-08-11 12:37:09 -0700\"), mod.getModifiedTime());\n-            assertEquals(\"Cruise Developer <cruise@cruise-sf3.(none)>\", mod.getUserDisplayName());\n-            final String expected = \"author:cruise <cceuser@CceDev01.(none)>\\n\"\n-                    + \"node:ecfab84dd4953105e3301c5992528c2d381c1b8a\\n\"\n-                    + \"date:2008-12-31 14:32:40 +0800\\n\"\n-                    + \"description:Moving rakefile to build subdirectory for #2266\\n\"\n-                    + \"\\n\"\n-                    + \"author:CceUser <cceuser@CceDev01.(none)>\\n\"\n-                    + \"node:fd16efeb70fcdbe63338c49995ce9ff7659e6e77\\n\"\n-                    + \"date:2008-12-31 14:17:06 +0800\\n\"\n-                    + \"description:Adding rakefile\";\n-            assertEquals(expected, mod.getComment());\n-        }\n+    @Test\n+    void shouldParseGitOutputCorrectly() throws IOException {\n+        List<String> stringList;\n+        try (InputStream resourceAsStream = getClass().getResourceAsStream(\"git_sample_output.text\")) {\n+            stringList = IOUtils.readLines(resourceAsStream, UTF_8);\n+        }\n+\n+        GitModificationParser parser = new GitModificationParser();\n+        List<Modification> mods = parser.parse(stringList);\n+        assertThat(mods).hasSize(3);\n+\n+        Modification mod = mods.get(2);\n+        assertThat(mod.getRevision()).isEqualTo(\"46cceff864c830bbeab0a7aaa31707ae2302762f\");\n+        assertThat(mod.getModifiedTime()).isEqualTo(DateUtils.parseISO8601(\"2009-08-11 12:37:09 -0700\"));\n+        assertThat(mod.getUserDisplayName()).isEqualTo(\"Cruise Developer <cruise@cruise-sf3.(none)>\");\n+        assertThat(mod.getComment()).isEqualTo(\"author:cruise <cceuser@CceDev01.(none)>\\n\"\n+                + \"node:ecfab84dd4953105e3301c5992528c2d381c1b8a\\n\"\n+                + \"date:2008-12-31 14:32:40 +0800\\n\"\n+                + \"description:Moving rakefile to build subdirectory for #2266\\n\"\n+                + \"\\n\"\n+                + \"author:CceUser <cceuser@CceDev01.(none)>\\n\"\n+                + \"node:fd16efeb70fcdbe63338c49995ce9ff7659e6e77\\n\"\n+                + \"date:2008-12-31 14:17:06 +0800\\n\"\n+                + \"description:Adding rakefile\");\n+    }\n \n-        @Test\n-        void shouldCleanUnversionedFilesInsideSubmodulesBeforeUpdating() throws Exception {\n-            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-            String submoduleDirectoryName = \"local-submodule\";\n-            submoduleRepos.addSubmodule(SUBMODULE, submoduleDirectoryName);\n-            File cloneDirectory = createTempWorkingDirectory();\n-            GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-            clonedCopy.clone(outputStreamConsumer, submoduleRepos.mainRepo().urlForCommandLine()); // Clone repository without submodules\n-            clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(\"HEAD\"), false);  // Pull submodules to working copy - Pipeline counter 1\n-            File unversionedFile = new File(new File(cloneDirectory, submoduleDirectoryName), \"unversioned_file.txt\");\n-            FileUtils.writeStringToFile(unversionedFile, \"this is an unversioned file. lets see you deleting me.. come on.. I dare you!!!!\", UTF_8);\n-\n-            clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(\"HEAD\"), false); // Should clean unversioned file on next fetch - Pipeline counter 2\n-\n-            assertFalse(unversionedFile.exists());\n-        }\n+    @Test\n+    void shouldCleanUnversionedFilesInsideSubmodulesBeforeUpdating() throws Exception {\n+        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+        String submoduleDirectoryName = \"local-submodule\";\n+        submoduleRepos.addSubmodule(SUBMODULE, submoduleDirectoryName);\n+        File cloneDirectory = createTempWorkingDirectory();\n+        GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+        clonedCopy.clone(outputStreamConsumer, submoduleRepos.mainRepo().getUrl()); // Clone repository without submodules\n+        clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(\"HEAD\"), false);  // Pull submodules to working copy - Pipeline counter 1\n+        File unversionedFile = new File(new File(cloneDirectory, submoduleDirectoryName), \"unversioned_file.txt\");\n+        FileUtils.writeStringToFile(unversionedFile, \"this is an unversioned file. lets see you deleting me.. come on.. I dare you!!!!\", UTF_8);\n+\n+        clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(\"HEAD\"), false); // Should clean unversioned file on next fetch - Pipeline counter 2\n+\n+        assertThat(unversionedFile.exists()).isFalse();\n+    }\n \n-        @Test\n-        void shouldRemoveChangesToModifiedFilesInsideSubmodulesBeforeUpdating() throws Exception {\n-            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-            String submoduleDirectoryName = \"local-submodule\";\n-            File cloneDirectory = createTempWorkingDirectory();\n+    @Test\n+    void shouldRemoveChangesToModifiedFilesInsideSubmodulesBeforeUpdating() throws Exception {\n+        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+        String submoduleDirectoryName = \"local-submodule\";\n+        File cloneDirectory = createTempWorkingDirectory();\n \n-            File remoteSubmoduleLocation = submoduleRepos.addSubmodule(SUBMODULE, submoduleDirectoryName);\n+        File remoteSubmoduleLocation = submoduleRepos.addSubmodule(SUBMODULE, submoduleDirectoryName);\n \n-            /* Simulate an agent checkout of code. */\n-            GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-            clonedCopy.clone(outputStreamConsumer, submoduleRepos.mainRepo().urlForCommandLine());\n-            clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(\"HEAD\"), false);\n+        /* Simulate an agent checkout of code. */\n+        GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+        clonedCopy.clone(outputStreamConsumer, submoduleRepos.mainRepo().getUrl());\n+        clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(\"HEAD\"), false);\n \n-            /* Simulate a local modification of file inside submodule, on agent side. */\n-            File fileInSubmodule = allFilesIn(new File(cloneDirectory, submoduleDirectoryName)).get(0);\n-            FileUtils.writeStringToFile(fileInSubmodule, \"Some other new content.\", UTF_8);\n+        /* Simulate a local modification of file inside submodule, on agent side. */\n+        File fileInSubmodule = allFilesIn(new File(cloneDirectory, submoduleDirectoryName), \"file-\").get(0);\n+        FileUtils.writeStringToFile(fileInSubmodule, \"Some other new content.\", UTF_8);\n \n-            /* Commit a change to the file on the repo. */\n-            List<Modification> modifications = submoduleRepos.modifyOneFileInSubmoduleAndUpdateMainRepo(\n-                    remoteSubmoduleLocation, submoduleDirectoryName, fileInSubmodule.getName(), \"NEW CONTENT OF FILE\");\n+        /* Commit a change to the file on the repo. */\n+        List<Modification> modifications = submoduleRepos.modifyOneFileInSubmoduleAndUpdateMainRepo(\n+                remoteSubmoduleLocation, submoduleDirectoryName, fileInSubmodule.getName(), \"NEW CONTENT OF FILE\");\n \n-            /* Simulate start of a new build on agent. */\n-            clonedCopy.fetch(outputStreamConsumer);\n-            clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(modifications.get(0).getRevision()), false);\n+        /* Simulate start of a new build on agent. */\n+        clonedCopy.fetch(outputStreamConsumer);\n+        clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(modifications.get(0).getRevision()), false);\n \n-            assertEquals(\"NEW CONTENT OF FILE\", FileUtils.readFileToString(fileInSubmodule, UTF_8));\n-        }\n+        assertThat(FileUtils.readFileToString(fileInSubmodule, UTF_8)).isEqualTo(\"NEW CONTENT OF FILE\");\n+    }\n \n-        @Test\n-        void shouldAllowSubmoduleUrlsToChange() throws Exception {\n-            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-            String submoduleDirectoryName = \"local-submodule\";\n-            File cloneDirectory = createTempWorkingDirectory();\n+    @Test\n+    void shouldAllowSubmoduleUrlsToChange() throws Exception {\n+        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+        String submoduleDirectoryName = \"local-submodule\";\n+        File cloneDirectory = createTempWorkingDirectory();\n \n-            submoduleRepos.addSubmodule(SUBMODULE, submoduleDirectoryName);\n+        submoduleRepos.addSubmodule(SUBMODULE, submoduleDirectoryName);\n \n-            GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-            clonedCopy.clone(outputStreamConsumer, submoduleRepos.mainRepo().urlForCommandLine());\n-            clonedCopy.fetchAndResetToHead(outputStreamConsumer, false);\n+        GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+        clonedCopy.clone(outputStreamConsumer, submoduleRepos.mainRepo().getUrl());\n+        clonedCopy.fetchAndResetToHead(outputStreamConsumer);\n \n-            submoduleRepos.changeSubmoduleUrl(submoduleDirectoryName);\n+        submoduleRepos.changeSubmoduleUrl(submoduleDirectoryName);\n \n-            clonedCopy.fetchAndResetToHead(outputStreamConsumer, false);\n-        }\n+        clonedCopy.fetchAndResetToHead(outputStreamConsumer);\n+    }\n \n-        @Test\n-        @EnabledOnGitVersions(from = \"2.10.0\")\n-        void shouldShallowCloneSubmodulesWhenSpecified() throws Exception {\n-            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-            GitRepoContainingSubmodule repoContainingSubmodule = new GitRepoContainingSubmodule(temporaryFolder);\n-            String submoduleDirectoryName = \"submoduleDir\";\n-            repoContainingSubmodule.addSubmodule(SUBMODULE, submoduleDirectoryName);\n-\n-            File cloneDirectory = createTempWorkingDirectory();\n-            GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-            clonedCopy.clone(outputStreamConsumer, FileUtil.toFileURI(repoContainingSubmodule.mainRepo().urlForCommandLine()), 1);\n-            clonedCopy.fetchAndResetToHead(outputStreamConsumer, true);\n-            ConsoleResult consoleResult = git_C(new File(cloneDirectory, submoduleDirectoryName),\n-                    \"rev-list\", \"--count\", \"master\");\n-            assertEquals(\"1\", consoleResult.outputAsString());\n-        }\n+    @Test\n+    @EnabledOnGitVersions(from = \"2.10.0\")\n+    void shouldShallowCloneSubmodulesWhenSpecified() throws Exception {\n+        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+        GitRepoContainingSubmodule repoContainingSubmodule = new GitRepoContainingSubmodule(temporaryFolder);\n+        String submoduleDirectoryName = \"submoduleDir\";\n+        repoContainingSubmodule.addSubmodule(SUBMODULE, submoduleDirectoryName);\n+\n+        File cloneDirectory = createTempWorkingDirectory();\n+        GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+        clonedCopy.clone(outputStreamConsumer, FileUtil.toFileURI(repoContainingSubmodule.mainRepo().getUrl()), 1);\n+        clonedCopy.fetchAndResetToHead(outputStreamConsumer, true);\n+        ConsoleResult consoleResult = executeOnDir(new File(cloneDirectory, submoduleDirectoryName),\n+                \"git\", \"rev-list\", \"--count\", \"master\");\n+        assertThat(consoleResult.outputAsString()).isEqualTo(\"1\");\n+    }\n \n-        @Test\n-        @EnabledOnGitVersions(from = \"2.10.0\", through = \"2.25.4\")\n-        void shouldUnshallowSubmodulesIfSubmoduleUpdateFails() throws Exception {\n-            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-            GitRepoContainingSubmodule repoContainingSubmodule = new GitRepoContainingSubmodule(temporaryFolder);\n-            String submoduleDirectoryName = \"submoduleDir\";\n-            repoContainingSubmodule.addSubmodule(SUBMODULE, submoduleDirectoryName);\n-            repoContainingSubmodule.goBackOneCommitInSubmoduleAndUpdateMainRepo(submoduleDirectoryName);\n-\n-            File cloneDirectory = createTempWorkingDirectory();\n-            GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-            clonedCopy.clone(outputStreamConsumer, FileUtil.toFileURI(repoContainingSubmodule.mainRepo().urlForCommandLine()), 1);\n-            clonedCopy.fetchAndResetToHead(outputStreamConsumer, true);\n-            ConsoleResult consoleResult = git_C(new File(cloneDirectory, submoduleDirectoryName),\n-                    \"rev-list\", \"--count\", \"master\");\n-            assertEquals(\"2\", consoleResult.outputAsString());\n-        }\n+    @Test\n+    @EnabledOnGitVersions(from = \"2.10.0\", through = \"2.25.4\")\n+    void shouldUnshallowSubmodulesIfSubmoduleUpdateFails() throws Exception {\n+        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+        GitRepoContainingSubmodule repoContainingSubmodule = new GitRepoContainingSubmodule(temporaryFolder);\n+        String submoduleDirectoryName = \"submoduleDir\";\n+        repoContainingSubmodule.addSubmodule(SUBMODULE, submoduleDirectoryName);\n+        repoContainingSubmodule.goBackOneCommitInSubmoduleAndUpdateMainRepo(submoduleDirectoryName);\n+\n+        File cloneDirectory = createTempWorkingDirectory();\n+        GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+        clonedCopy.clone(outputStreamConsumer, FileUtil.toFileURI(repoContainingSubmodule.mainRepo().getUrl()), 1);\n+        clonedCopy.fetchAndResetToHead(outputStreamConsumer, true);\n+        ConsoleResult consoleResult = executeOnDir(new File(cloneDirectory, submoduleDirectoryName),\n+                \"git\", \"rev-list\", \"--count\", \"master\");\n+        assertThat(consoleResult.outputAsString()).isEqualTo(\"2\");\n+    }\n \n-        @Test\n-        void shouldCleanIgnoredFilesIfToggleIsDisabled() throws IOException {\n-            InMemoryStreamConsumer output = inMemoryConsumer();\n-            File gitIgnoreFile = new File(repoLocation, \".gitignore\");\n-            FileUtils.writeStringToFile(gitIgnoreFile, \"*.foo\", UTF_8);\n-            gitRepo.addFileAndPush(gitIgnoreFile, \"added gitignore\");\n-            git.fetchAndResetToHead(output, false);\n-\n-            File ignoredFile = new File(gitLocalRepoDir, \"ignored.foo\");\n-            assertTrue(ignoredFile.createNewFile());\n-            git.fetchAndResetToHead(output, false);\n-            assertFalse(ignoredFile.exists());\n-        }\n+    @Test\n+    void shouldCleanIgnoredFilesIfToggleIsDisabled() throws IOException {\n+        InMemoryStreamConsumer output = inMemoryConsumer();\n+        File gitIgnoreFile = new File(repoLocation, \".gitignore\");\n+        FileUtils.writeStringToFile(gitIgnoreFile, \"*.foo\", UTF_8);\n+        gitRepo.addFileAndPush(gitIgnoreFile, \"added gitignore\");\n+        git.fetchAndResetToHead(output);\n+\n+        File ignoredFile = new File(gitLocalRepoDir, \"ignored.foo\");\n+        assertThat(ignoredFile.createNewFile()).isTrue();\n+        git.fetchAndResetToHead(output);\n+        assertThat(ignoredFile.exists()).isFalse();\n+    }\n \n-        @Test\n-        void shouldNotCleanIgnoredFilesIfToggleIsEnabled() throws IOException {\n-            System.setProperty(\"toggle.agent.git.clean.keep.ignored.files\", \"Y\");\n-            InMemoryStreamConsumer output = inMemoryConsumer();\n-            File gitIgnoreFile = new File(repoLocation, \".gitignore\");\n-            FileUtils.writeStringToFile(gitIgnoreFile, \"*.foo\", UTF_8);\n-            gitRepo.addFileAndPush(gitIgnoreFile, \"added gitignore\");\n-            git.fetchAndResetToHead(output, false);\n-\n-            File ignoredFile = new File(gitLocalRepoDir, \"ignored.foo\");\n-            assertTrue(ignoredFile.createNewFile());\n-            git.fetchAndResetToHead(output, false);\n-            assertTrue(ignoredFile.exists());\n-        }\n+    @Test\n+    void shouldNotCleanIgnoredFilesIfToggleIsEnabled() throws IOException {\n+        System.setProperty(\"toggle.agent.git.clean.keep.ignored.files\", \"Y\");\n+        InMemoryStreamConsumer output = inMemoryConsumer();\n+        File gitIgnoreFile = new File(repoLocation, \".gitignore\");\n+        FileUtils.writeStringToFile(gitIgnoreFile, \"*.foo\", UTF_8);\n+        gitRepo.addFileAndPush(gitIgnoreFile, \"added gitignore\");\n+        git.fetchAndResetToHead(output);\n+\n+        File ignoredFile = new File(gitLocalRepoDir, \"ignored.foo\");\n+        assertThat(ignoredFile.createNewFile()).isTrue();\n+        git.fetchAndResetToHead(output);\n+        assertThat(ignoredFile.exists()).isTrue();\n+    }\n \n-        @Test\n-        void shouldNotThrowExceptionWhenSubmoduleIsAddedWithACustomName() {\n-            git_C(gitLocalRepoDir, \"submodule\", \"add\", \"--name\", \"Custom\", gitFooBranchBundle.projectRepositoryUrl());\n-            git.fetchAndResetToHead(inMemoryConsumer(), false);\n-        }\n+    @Test\n+    void shouldNotThrowExceptionWhenSubmoduleIsAddedWithACustomName() {\n+        executeOnDir(gitLocalRepoDir, \"git\", \"submodule\", \"add\", \"--name\", \"Custom\", gitFooBranchBundle.projectRepositoryUrl());\n+        git.fetchAndResetToHead(inMemoryConsumer());\n+    }\n \n-        private List<File> allFilesIn(File directory) {\n-            return new ArrayList<>(FileUtils.listFiles(directory, and(fileFileFilter(), prefixFileFilter(\"file-\")), null));\n-        }\n+    private List<File> allFilesIn(File directory, String prefixOfFiles) {\n+        return new ArrayList<>(FileUtils.listFiles(directory, andFileFilter(fileFileFilter(), prefixFileFilter(prefixOfFiles)), null));\n+    }\n \n-        private File createTempWorkingDirectory() throws IOException {\n-            return temporaryFolder.newFolder(\"GitCommandTest\" + System.currentTimeMillis(), \"repo\");\n-        }\n+    private File createTempWorkingDirectory() throws IOException {\n+        return temporaryFolder.newFolder(\"GitCommandTest\" + System.currentTimeMillis(), \"repo\");\n+    }\n \n-        private File checkInNewRemoteFile() throws IOException {\n-            GitCommand remoteGit = new GitCommand(null, repoLocation, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-            File testingFile = new File(repoLocation, \"testing-file\" + System.currentTimeMillis() + \".txt\");\n-            //noinspection ResultOfMethodCallIgnored\n-            testingFile.createNewFile();\n-            remoteGit.add(testingFile);\n-            remoteGit.commit(\"New checkin of \" + testingFile.getName());\n-            return testingFile;\n-        }\n+    private File checkInNewRemoteFile() throws IOException {\n+        GitCommand remoteGit = new GitCommand(null, repoLocation, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+        File testingFile = new File(repoLocation, \"testing-file\" + System.currentTimeMillis() + \".txt\");\n+        testingFile.createNewFile();\n+        remoteGit.add(testingFile);\n+        remoteGit.commit(\"New checkin of \" + testingFile.getName());\n+        return testingFile;\n+    }\n \n-        private File checkInNewRemoteFileInFuture(Date checkinDate) throws IOException {\n-            GitCommand remoteGit = new GitCommand(null, repoLocation, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-            File testingFile = new File(repoLocation, \"testing-file\" + System.currentTimeMillis() + \".txt\");\n-            //noinspection ResultOfMethodCallIgnored\n-            testingFile.createNewFile();\n-            remoteGit.add(testingFile);\n-            remoteGit.commitOnDate(\"New checkin of \" + testingFile.getName(), checkinDate);\n-            return testingFile;\n-        }\n+    private File checkInNewRemoteFileInFuture(Date checkinDate) throws IOException {\n+        GitCommand remoteGit = new GitCommand(null, repoLocation, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+        File testingFile = new File(repoLocation, \"testing-file\" + System.currentTimeMillis() + \".txt\");\n+        testingFile.createNewFile();\n+        remoteGit.add(testingFile);\n+        remoteGit.commitOnDate(\"New checkin of \" + testingFile.getName(), checkinDate);\n+        return testingFile;\n+    }\n \n-        private void gitInRepo(String... args) {\n-            git_C(gitLocalRepoDir, args);\n-        }\n+    private void executeOnGitRepo(String command, String... args) {\n+        executeOnDir(gitLocalRepoDir, command, args);\n+    }\n \n-        /**\n-         * Like {@code git -C <dir> command [args...]}\n-         *\n-         * @param dir  the directory to set as CWD\n-         * @param args the args to pass to {@code git}\n-         * @return a {@link ConsoleResult}\n-         */\n-        private ConsoleResult git_C(File dir, String... args) {\n-            CommandLine commandLine = CommandLine.createCommandLine(\"git\");\n-            commandLine.withArgs(args);\n-            commandLine.withEncoding(\"utf-8\");\n-            assertTrue(dir.exists());\n-            commandLine.setWorkingDir(dir);\n-            return commandLine.runOrBomb(true, null);\n-        }\n+    private ConsoleResult executeOnDir(File dir, String command, String... args) {\n+        CommandLine commandLine = CommandLine.createCommandLine(command);\n+        commandLine.withArgs(args);\n+        commandLine.withEncoding(\"utf-8\");\n+        assertThat(dir.exists()).isTrue();\n+        commandLine.setWorkingDir(dir);\n+        return commandLine.runOrBomb(true, null);\n+    }\n \n-        private void setColoring() {\n-            gitInRepo(\"config\", \"color.diff\", \"always\");\n-            gitInRepo(\"config\", \"color.status\", \"always\");\n-            gitInRepo(\"config\", \"color.interactive\", \"always\");\n-            gitInRepo(\"config\", \"color.branch\", \"always\");\n-        }\n+    private void setColoring() {\n+        executeOnGitRepo(\"git\", \"config\", \"color.diff\", \"always\");\n+        executeOnGitRepo(\"git\", \"config\", \"color.status\", \"always\");\n+        executeOnGitRepo(\"git\", \"config\", \"color.interactive\", \"always\");\n+        executeOnGitRepo(\"git\", \"config\", \"color.branch\", \"always\");\n+    }\n \n-        private void setLogDecoration() {\n-            gitInRepo(\"config\", \"log.decorate\", \"true\");\n-        }\n+    private void setLogDecoration() throws IOException {\n+        executeOnGitRepo(\"git\", \"config\", \"log.decorate\", \"true\");\n+    }\n \n-        private void unsetLogDecoration() {\n-            gitInRepo(\"config\", \"log.decorate\", \"off\");\n-        }\n+    private void unsetLogDecoration() throws IOException {\n+        executeOnGitRepo(\"git\", \"config\", \"log.decorate\", \"off\");\n+    }\n \n-        private void unsetColoring() {\n-            gitInRepo(\"config\", \"color.diff\", \"auto\");\n-            gitInRepo(\"config\", \"color.status\", \"auto\");\n-            gitInRepo(\"config\", \"color.interactive\", \"auto\");\n-            gitInRepo(\"config\", \"color.branch\", \"auto\");\n-        }\n+    private void unsetColoring() {\n+        executeOnGitRepo(\"git\", \"config\", \"color.diff\", \"auto\");\n+        executeOnGitRepo(\"git\", \"config\", \"color.status\", \"auto\");\n+        executeOnGitRepo(\"git\", \"config\", \"color.interactive\", \"auto\");\n+        executeOnGitRepo(\"git\", \"config\", \"color.branch\", \"auto\");\n+    }\n \n-        private void assertWorkingCopyNotCheckedOut() {\n-            assertArrayEquals(new File[]{new File(gitLocalRepoDir, \".git\")}, gitLocalRepoDir.listFiles());\n-        }\n+    private void assertWorkingCopyNotCheckedOut() {\n+        assertThat(gitLocalRepoDir.listFiles()).isEqualTo(new File[]{new File(gitLocalRepoDir, \".git\")});\n+    }\n \n-        private void assertWorkingCopyCheckedOut(File workingDir) {\n-            assertTrue(requireNonNull(workingDir.listFiles()).length > 1);\n-        }\n+    private void assertWorkingCopyCheckedOut(File workingDir) {\n+        assertThat(workingDir.listFiles().length).isGreaterThan(1);\n     }\n }\n", "next_change": {"commit": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "changed_code": [{"header": "diff --git a/common/src/test/java/com/thoughtworks/go/domain/materials/git/GitCommandTest.java b/common/src/test/java/com/thoughtworks/go/domain/materials/git/GitCommandTest.java\nindex 55d393a468..4130b2a95c 100644\n--- a/common/src/test/java/com/thoughtworks/go/domain/materials/git/GitCommandTest.java\n+++ b/common/src/test/java/com/thoughtworks/go/domain/materials/git/GitCommandTest.java\n", "chunk": "@@ -32,770 +33,901 @@ import org.junit.Rule;\n import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n import org.junit.jupiter.migrationsupport.rules.EnableRuleMigrationSupport;\n-import org.junit.rules.ExpectedException;\n import org.junit.rules.TemporaryFolder;\n import org.junit.rules.TestRule;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.nio.charset.Charset;\n import java.util.*;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import static com.thoughtworks.go.domain.materials.git.GitTestRepo.*;\n import static com.thoughtworks.go.util.DateUtils.parseRFC822;\n-import static com.thoughtworks.go.util.ReflectionUtil.getField;\n import static com.thoughtworks.go.util.command.ProcessOutputStreamConsumer.inMemoryConsumer;\n+import static java.lang.String.format;\n import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.regex.Pattern.compile;\n+import static java.util.regex.Pattern.quote;\n import static org.apache.commons.io.filefilter.FileFilterUtils.*;\n import static org.apache.commons.lang3.time.DateUtils.addDays;\n import static org.apache.commons.lang3.time.DateUtils.setMilliseconds;\n-import static org.assertj.core.api.Assertions.*;\n-import static org.mockito.MockitoAnnotations.initMocks;\n+import static org.junit.jupiter.api.Assertions.*;\n \n-@EnableRuleMigrationSupport\n public class GitCommandTest {\n-    private static final String BRANCH = \"foo\";\n-    private static final String SUBMODULE = \"submodule-1\";\n-\n-    private GitCommand git;\n-    private String repoUrl;\n-    private File repoLocation;\n-    private static final Date THREE_DAYS_FROM_NOW = setMilliseconds(addDays(new Date(), 3), 0);\n-    private GitTestRepo gitRepo;\n-    private File gitLocalRepoDir;\n-    private GitTestRepo gitFooBranchBundle;\n-\n-    @Rule\n-    public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-    @Rule\n-    public final TestRule restoreSystemProperties = new RestoreSystemProperties();\n-\n-    @Rule\n-    public final ExpectedException expectedException = ExpectedException.none();\n-\n-    @BeforeEach\n-    void setup() throws Exception {\n-        gitRepo = new GitTestRepo(temporaryFolder);\n-        gitLocalRepoDir = createTempWorkingDirectory();\n-        git = new GitCommand(null, gitLocalRepoDir, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        repoLocation = gitRepo.gitRepository();\n-        repoUrl = gitRepo.projectRepositoryUrl();\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-        int returnCode = git.cloneWithNoCheckout(outputStreamConsumer, repoUrl);\n-        if (returnCode > 0) {\n-            fail(outputStreamConsumer.getAllOutput());\n-        }\n-        gitFooBranchBundle = GitTestRepo.testRepoAtBranch(GIT_FOO_BRANCH_BUNDLE, BRANCH, temporaryFolder);\n-        initMocks(this);\n-    }\n+    private static GitCommand withBranch(String branch) {\n+        return new GitCommand(null, null, branch, false, null);\n+    }\n+\n+    private static GitCommand withBranch(String branch, File cwd) {\n+        return new GitCommand(null, cwd, branch, false, null);\n+    }\n+\n+    @Nested\n+    class RefSpec {\n+        @Test\n+        void extractsLocalBranchFromRefSpec() {\n+            assertEquals(\"whatever\", withBranch(\"whatever\").localBranch());\n+            assertEquals(\"whatever\", withBranch(\"refs/anything/goes:whatever\").localBranch());\n+            assertEquals(\"with/slashes\", withBranch(\"refs/anything/goes:with/slashes\").localBranch());\n+            assertEquals(\"whatever\", withBranch(\"refs/anything/goes:refs/heads/whatever\").localBranch());\n+            assertEquals(\"whatever\", withBranch(\"refs/anything/goes:refs/remotes/origin/whatever\").localBranch());\n+            assertEquals(\"whatever\", withBranch(\"refs/anything/goes:refs/remotes/upstream/whatever\").localBranch());\n+            assertEquals(\"refs/remotes/oops-did-not-specify-branch\", withBranch(\"refs/anything/goes:refs/remotes/oops-did-not-specify-branch\").localBranch());\n+            assertEquals(\"refs/full/location\", withBranch(\"refs/anything/goes:refs/full/location\").localBranch());\n+        }\n \n-    @AfterEach\n-    void teardown() throws Exception {\n-        unsetColoring();\n-        unsetLogDecoration();\n-        TestRepo.internalTearDown();\n-    }\n+        @Test\n+        void extractsRemoteBranchFromRefSpec() {\n+            assertEquals(\"origin/anywhere\", withBranch(\"anywhere\").remoteBranch());\n+            assertEquals(\"origin/whatever\", withBranch(\"refs/anything/goes:whatever\").remoteBranch());\n+            assertEquals(\"refs/heads/with/slashes\", withBranch(\"refs/anything/goes:with/slashes\").remoteBranch());\n+            assertEquals(\"refs/full/location\", withBranch(\"refs/anything/goes:refs/full/location\").remoteBranch());\n+            assertEquals(\"origin/any\", withBranch(\"refs/anything/goes:refs/remotes/origin/any\").remoteBranch());\n+            assertEquals(\"other/remote\", withBranch(\"refs/anything/goes:refs/remotes/other/remote\").remoteBranch());\n+            assertEquals(\"refs/remotes/oops-did-not-specify-branch\", withBranch(\"refs/anything/goes:refs/remotes/oops-did-not-specify-branch\").remoteBranch());\n+        }\n \n-    @Test\n-    void shouldDefaultToMasterIfNoBranchIsSpecified() {\n-        assertThat(getField(new GitCommand(null, gitLocalRepoDir, null, false, null), \"branch\")).isEqualTo(\"master\");\n-        assertThat(getField(new GitCommand(null, gitLocalRepoDir, \" \", false, null), \"branch\")).isEqualTo(\"master\");\n-        assertThat(getField(new GitCommand(null, gitLocalRepoDir, \"master\", false, null), \"branch\")).isEqualTo(\"master\");\n-        assertThat(getField(new GitCommand(null, gitLocalRepoDir, \"branch\", false, null), \"branch\")).isEqualTo(\"branch\");\n-    }\n+        @Test\n+        void fullUpstreamRefIsRefSpecAware() {\n+            assertEquals(\"refs/heads/dev\", withBranch(\"dev\").fullUpstreamRef());\n+            assertEquals(\"refs/anything/goes\", withBranch(\"refs/anything/goes:whatever\").fullUpstreamRef());\n+        }\n \n-    @Test\n-    void shouldCloneFromMasterWhenNoBranchIsSpecified() {\n-        InMemoryStreamConsumer output = inMemoryConsumer();\n-        git.clone(output, repoUrl);\n-        CommandLine commandLine = CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"branch\").withWorkingDir(gitLocalRepoDir);\n-        commandLine.run(output, null);\n-        assertThat(output.getStdOut()).isEqualTo(\"* master\");\n-    }\n+        @Test\n+        void expandRefSpecEnsuresAbsoluteDestination() {\n+            assertEquals(\"branch\", withBranch(\"branch\").expandRefSpec());\n+            assertEquals(\"refs/a/*:refs/remotes/origin/a-*\", withBranch(\"refs/a/*:a-*\").expandRefSpec());\n+            assertEquals(\"refs/a/*:refs/remotes/origin/a/b/c-*\", withBranch(\"refs/a/*:a/b/c-*\").expandRefSpec());\n+            assertEquals(\"refs/a/*:refs/b/*\", withBranch(\"refs/a/*:refs/b/*\").expandRefSpec());\n+            assertEquals(\"refs/a/*:refs/remotes/origin/a-*\", withBranch(\"refs/a/*:refs/remotes/origin/a-*\").expandRefSpec());\n+        }\n \n-    @Test\n-    void freshCloneDoesNotHaveWorkingCopy() {\n-        assertWorkingCopyNotCheckedOut();\n+        @Test\n+        void defaultsToMasterWhenNoBranchIsSpecified() {\n+            assertEquals(\"master\", withBranch(null).localBranch());\n+            assertEquals(\"master\", withBranch(\" \").localBranch());\n+            assertEquals(\"master\", withBranch(\"master\").localBranch());\n+            assertEquals(\"branch\", withBranch(\"branch\").localBranch());\n+\n+            assertEquals(\"origin/master\", withBranch(null).remoteBranch());\n+            assertEquals(\"origin/master\", withBranch(\" \").remoteBranch());\n+            assertEquals(\"origin/master\", withBranch(\"master\").remoteBranch());\n+            assertEquals(\"origin/branch\", withBranch(\"branch\").remoteBranch());\n+\n+            assertEquals(\"refs/heads/master\", withBranch(null).fullUpstreamRef());\n+            assertEquals(\"refs/heads/master\", withBranch(\" \").fullUpstreamRef());\n+            assertEquals(\"refs/heads/master\", withBranch(\"master\").fullUpstreamRef());\n+            assertEquals(\"refs/heads/branch\", withBranch(\"branch\").fullUpstreamRef());\n+\n+            assertEquals(\"master\", withBranch(null).expandRefSpec());\n+            assertEquals(\"master\", withBranch(\" \").expandRefSpec());\n+            assertEquals(\"master\", withBranch(\"master\").expandRefSpec());\n+            assertEquals(\"branch\", withBranch(\"branch\").expandRefSpec());\n+        }\n     }\n \n-    @Test\n-    void freshCloneOnAgentSideShouldHaveWorkingCopyCheckedOut() throws IOException {\n-        InMemoryStreamConsumer output = inMemoryConsumer();\n-        File workingDir = createTempWorkingDirectory();\n-        GitCommand git = new GitCommand(null, workingDir, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+    @Nested\n+    class RefSpecIntegration {\n+        @Test\n+        void clonedRepoReflectsDestinationRef(@TempDir File sandbox) {\n+            final String refSpec = \"refs/pull/1/head:refs/remotes/origin/pull/1/head\";\n+            final GitCommand git = withBranch(refSpec, sandbox);\n \n-        git.clone(output, repoUrl);\n+            final InMemoryStreamConsumer out = inMemoryConsumer();\n+            assertEquals(0, git.clone(out, GIT_CUSTOM_REFS_BUNDLE), \"git clone failed with:\\n\" + out.getStdError());\n+            assertEquals(\"pull/1/head\", git.getCurrentBranch());\n \n-        assertWorkingCopyCheckedOut(workingDir);\n-    }\n+            assertDoesNotThrow(() -> git.fetch(out), () -> \"git fetch failed with:\\n\" + out.getStdError());\n+            assertEquals(\"+\" + git.expandRefSpec(), git.getConfigValue(\"remote.origin.fetch\"));\n+            assertEquals(git(sandbox, \"rev-parse\", \"HEAD\"), git(sandbox, \"rev-parse\", \"origin/pull/1/head\"));\n+            assertEquals(git(sandbox, \"ls-remote\", \"origin\", \"refs/pull/1/head\").split(\"\\\\s\")[0], git(sandbox, \"rev-parse\", \"HEAD\"));\n+        }\n \n-    @Test\n-    void fullCloneIsNotShallow() {\n-        assertThat(git.isShallow()).isFalse();\n-    }\n+        @Test\n+        void cloneNoCheckoutReflectsDestinationRef(@TempDir File sandbox) {\n+            final String refSpec = \"refs/random/things:refs/remotes/origin/randomness\";\n+            final GitCommand git = withBranch(refSpec, sandbox);\n \n-    @Test\n-    void shouldOnlyCloneLimitedRevisionsIfDepthSpecified() throws Exception {\n-        FileUtils.deleteQuietly(this.gitLocalRepoDir);\n-        git.clone(inMemoryConsumer(), repoUrl, 2);\n-        assertThat(git.isShallow()).isTrue();\n-        assertThat(git.containsRevisionInBranch(GitTestRepo.REVISION_4)).isTrue();\n-        assertThat(git.containsRevisionInBranch(GitTestRepo.REVISION_3)).isTrue();\n-        // can not assert on revision_2, because on old version of git (1.7)\n-        // depth '2' actually clone 3 revisions\n-        assertThat(git.containsRevisionInBranch(GitTestRepo.REVISION_1)).isFalse();\n-        assertThat(git.containsRevisionInBranch(GitTestRepo.REVISION_0)).isFalse();\n+            final InMemoryStreamConsumer out = inMemoryConsumer();\n+            assertEquals(0, git.cloneWithNoCheckout(out, GIT_CUSTOM_REFS_BUNDLE), \"git clone failed with:\\n\" + out.getStdError());\n+            assertEquals(\"randomness\", git.getCurrentBranch());\n \n-    }\n+            assertDoesNotThrow(() -> git.fetch(out), () -> \"git fetch failed with:\\n\" + out.getStdError());\n+            assertEquals(\"+\" + git.expandRefSpec(), git.getConfigValue(\"remote.origin.fetch\"));\n+            assertEquals(git(sandbox, \"rev-parse\", \"HEAD\"), git(sandbox, \"rev-parse\", \"origin/randomness\"));\n+            assertEquals(git(sandbox, \"ls-remote\", \"origin\", \"refs/random/things\").split(\"\\\\s\")[0], git(sandbox, \"rev-parse\", \"HEAD\"));\n+        }\n \n-    @Test\n-    void unshallowALocalRepoWithArbitraryDepth() throws Exception {\n-        FileUtils.deleteQuietly(this.gitLocalRepoDir);\n-        git.clone(inMemoryConsumer(), repoUrl, 2);\n-        git.unshallow(inMemoryConsumer(), 3);\n-        assertThat(git.isShallow()).isTrue();\n-        assertThat(git.containsRevisionInBranch(GitTestRepo.REVISION_2)).isTrue();\n-        // can not assert on revision_1, because on old version of git (1.7)\n-        // depth '3' actually clone 4 revisions\n-        assertThat(git.containsRevisionInBranch(GitTestRepo.REVISION_0)).isFalse();\n-\n-        git.unshallow(inMemoryConsumer(), Integer.MAX_VALUE);\n-        assertThat(git.isShallow()).isFalse();\n-\n-        assertThat(git.containsRevisionInBranch(GitTestRepo.REVISION_0)).isTrue();\n-    }\n+        @Test\n+        void clonedRepoReflectsShortDestinationRef(@TempDir File sandbox) {\n+            final String refSpec = \"refs/pull/1/head:pull/1/head\";\n+            final GitCommand git = withBranch(refSpec, sandbox);\n \n-    @Test\n-    void unshallowShouldNotResultInWorkingCopyCheckout() {\n-        FileUtils.deleteQuietly(this.gitLocalRepoDir);\n-        git.cloneWithNoCheckout(inMemoryConsumer(), repoUrl);\n-        git.unshallow(inMemoryConsumer(), 3);\n-        assertWorkingCopyNotCheckedOut();\n-    }\n+            final InMemoryStreamConsumer out = inMemoryConsumer();\n+            assertEquals(0, git.clone(out, GIT_CUSTOM_REFS_BUNDLE), \"git clone failed with:\\n\" + out.getStdError());\n+            assertEquals(\"pull/1/head\", git.getCurrentBranch());\n \n-    @Test\n-    void shouldCloneFromBranchWhenMaterialPointsToABranch() throws IOException {\n-        gitLocalRepoDir = createTempWorkingDirectory();\n-        git = new GitCommand(null, gitLocalRepoDir, BRANCH, false, null);\n-        GitCommand branchedGit = new GitCommand(null, gitLocalRepoDir, BRANCH, false, null);\n-        branchedGit.clone(inMemoryConsumer(), gitFooBranchBundle.projectRepositoryUrl());\n-        InMemoryStreamConsumer output = inMemoryConsumer();\n-        CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"branch\").withWorkingDir(gitLocalRepoDir).run(output, null);\n-        assertThat(output.getStdOut()).isEqualTo(\"* foo\");\n-    }\n+            assertDoesNotThrow(() -> git.fetch(out), () -> \"git fetch failed with:\\n\" + out.getStdError());\n+            assertEquals(\"+\" + git.expandRefSpec(), git.getConfigValue(\"remote.origin.fetch\"));\n+            assertEquals(git(sandbox, \"rev-parse\", \"HEAD\"), git(sandbox, \"rev-parse\", \"origin/pull/1/head\"));\n+            assertEquals(git(sandbox, \"ls-remote\", \"origin\", \"refs/pull/1/head\").split(\"\\\\s\")[0], git(sandbox, \"rev-parse\", \"HEAD\"));\n+        }\n \n-    @Test\n-    void shouldGetTheCurrentBranchForTheCheckedOutRepo() throws IOException {\n-        gitLocalRepoDir = createTempWorkingDirectory();\n-        CommandLine gitCloneCommand = CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"clone\");\n-        gitCloneCommand.withArg(\"--branch=\" + BRANCH).withArg(new UrlArgument(gitFooBranchBundle.projectRepositoryUrl())).withArg(gitLocalRepoDir.getAbsolutePath());\n-        gitCloneCommand.run(inMemoryConsumer(), null);\n-        git = new GitCommand(null, gitLocalRepoDir, BRANCH, false, null);\n-        assertThat(git.getCurrentBranch()).isEqualTo(BRANCH);\n-    }\n+        @Test\n+        void cloneNoCheckoutReflectsShortDestinationRef(@TempDir File sandbox) {\n+            final String refSpec = \"refs/random/things:randomness\";\n+            final GitCommand git = withBranch(refSpec, sandbox);\n+\n+            final InMemoryStreamConsumer out = inMemoryConsumer();\n+            assertEquals(0, git.cloneWithNoCheckout(out, GIT_CUSTOM_REFS_BUNDLE), \"git clone failed with:\\n\" + out.getStdError());\n+            assertEquals(\"randomness\", git.getCurrentBranch());\n \n-    @Test\n-    void shouldBombForFetchFailure() throws IOException {\n-        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n-        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", \"git://user:secret@foo.bar/baz\");\n-        try {\n-            InMemoryStreamConsumer output = new InMemoryStreamConsumer();\n-            git.fetch(output);\n-            fail(\"should have failed for non 0 return code. Git output was:\\n \" + output.getAllOutput());\n-        } catch (Exception e) {\n-            assertThat(e.getMessage()).isEqualTo(\"git fetch failed for [git://user:******@foo.bar/baz]\");\n+            assertDoesNotThrow(() -> git.fetch(out), () -> \"git fetch failed with:\\n\" + out.getStdError());\n+            assertEquals(\"+\" + git.expandRefSpec(), git.getConfigValue(\"remote.origin.fetch\"));\n+            assertEquals(git(sandbox, \"rev-parse\", \"HEAD\"), git(sandbox, \"rev-parse\", \"origin/randomness\"));\n+            assertEquals(git(sandbox, \"ls-remote\", \"origin\", \"refs/random/things\").split(\"\\\\s\")[0], git(sandbox, \"rev-parse\", \"HEAD\"));\n         }\n-    }\n \n-    @Test\n-    void shouldBombForResettingFailure() throws IOException {\n-        try {\n-            git.resetWorkingDir(new SysOutStreamConsumer(), new StringRevision(\"abcdef\"), false);\n-            fail(\"should have failed for non 0 return code\");\n-        } catch (Exception e) {\n-            assertThat(e.getMessage()).isEqualTo(String.format(\"git reset failed for [%s]\", gitLocalRepoDir));\n+        private String git(File cwd, String... args) {\n+            return CommandLine.createCommandLine(\"git\").\n+                    withEncoding(\"UTF-8\").\n+                    withWorkingDir(cwd).\n+                    withArgs(args).runOrBomb(new NamedProcessTag(null)).outputAsString();\n         }\n     }\n \n-    @Test\n-    void shouldOutputSubmoduleRevisionsAfterUpdate() throws Exception {\n-        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-        submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n-        GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        gitWithSubmodule.clone(inMemoryConsumer(), submoduleRepos.mainRepo().getUrl());\n-        InMemoryStreamConsumer outConsumer = new InMemoryStreamConsumer();\n-        gitWithSubmodule.resetWorkingDir(outConsumer, new StringRevision(\"HEAD\"), false);\n-        Matcher matcher = Pattern.compile(\".*^\\\\s[a-f0-9A-F]{40} sub1 \\\\(heads/master\\\\)$.*\", Pattern.MULTILINE | Pattern.DOTALL).matcher(outConsumer.getAllOutput());\n-        assertThat(matcher.matches()).isTrue();\n-    }\n+    @Nested\n+    @EnableRuleMigrationSupport\n+    class Integration {\n+        private static final String BRANCH = \"foo\";\n+        private static final String SUBMODULE = \"submodule-1\";\n+        @Rule\n+        public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+        @Rule\n+        public final TestRule restoreSystemProperties = new RestoreSystemProperties();\n+        private final Date THREE_DAYS_FROM_NOW = setMilliseconds(addDays(new Date(), 3), 0);\n+        private GitCommand git;\n+        private String repoUrl;\n+        private File repoLocation;\n+        private GitTestRepo gitRepo;\n+        private File gitLocalRepoDir;\n+        private GitTestRepo gitFooBranchBundle;\n+\n+        @BeforeEach\n+        void setup() throws IOException {\n+            gitRepo = new GitTestRepo(temporaryFolder);\n+            gitLocalRepoDir = createTempWorkingDirectory();\n+            git = new GitCommand(null, gitLocalRepoDir, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+            repoLocation = gitRepo.gitRepository();\n+            repoUrl = gitRepo.projectRepositoryUrl();\n+            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+            int returnCode = git.cloneWithNoCheckout(outputStreamConsumer, repoUrl);\n+            if (returnCode > 0) {\n+                fail(outputStreamConsumer.getAllOutput());\n+            }\n+            gitFooBranchBundle = GitTestRepo.testRepoAtBranch(GIT_FOO_BRANCH_BUNDLE, BRANCH, temporaryFolder);\n+        }\n \n-    @Test\n-    void shouldBombForResetWorkingDirWhenSubmoduleUpdateFails() throws Exception {\n-        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-        File submoduleFolder = submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n-        GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        gitWithSubmodule.clone(inMemoryConsumer(), submoduleRepos.mainRepo().getUrl());\n-        FileUtils.deleteDirectory(submoduleFolder);\n-\n-        assertThat(submoduleFolder.exists()).isFalse();\n-        try {\n-            gitWithSubmodule.resetWorkingDir(new SysOutStreamConsumer(), new StringRevision(\"HEAD\"), false);\n-            fail(\"should have failed for non 0 return code\");\n-        } catch (Exception e) {\n-            assertThat(e.getMessage()).containsPattern(\n-                    String.format(\"[Cc]lone of '%s' into submodule path '((.*)[\\\\/])?sub1' failed\",\n-                            Pattern.quote(FileUtil.toFileURI(submoduleFolder.getAbsolutePath()) + \"/\")));\n+        @AfterEach\n+        void teardown() {\n+            unsetColoring();\n+            unsetLogDecoration();\n+            TestRepo.internalTearDown();\n         }\n-    }\n \n-    @Test\n-    void shouldRetrieveLatestModification() throws Exception {\n-        Modification mod = git.latestModification().get(0);\n-        assertThat(mod.getUserName()).isEqualTo(\"Chris Turner <cturner@thoughtworks.com>\");\n-        assertThat(mod.getComment()).isEqualTo(\"Added 'run-till-file-exists' ant target\");\n-        assertThat(mod.getModifiedTime()).isEqualTo(parseRFC822(\"Fri, 12 Feb 2010 16:12:04 -0800\"));\n-        assertThat(mod.getRevision()).isEqualTo(\"5def073a425dfe239aabd4bf8039ffe3b0e8856b\");\n-\n-        List<ModifiedFile> files = mod.getModifiedFiles();\n-        assertThat(files.size()).isEqualTo(1);\n-        assertThat(files.get(0).getFileName()).isEqualTo(\"build.xml\");\n-        assertThat(files.get(0).getAction()).isEqualTo(ModifiedAction.modified);\n-    }\n+        @Test\n+        void shouldCloneFromMasterWhenNoBranchIsSpecified() {\n+            InMemoryStreamConsumer output = inMemoryConsumer();\n+            git.clone(output, repoUrl);\n+            CommandLine commandLine = CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"branch\").withWorkingDir(gitLocalRepoDir);\n+            commandLine.run(output, null);\n+            assertEquals(\"* master\", output.getStdOut());\n+        }\n \n-    @Test\n-    void shouldRetrieveLatestModificationWhenColoringIsSetToAlways() throws Exception {\n-        setColoring();\n-        Modification mod = git.latestModification().get(0);\n-        assertThat(mod.getUserName()).isEqualTo(\"Chris Turner <cturner@thoughtworks.com>\");\n-        assertThat(mod.getComment()).isEqualTo(\"Added 'run-till-file-exists' ant target\");\n-        assertThat(mod.getModifiedTime()).isEqualTo(parseRFC822(\"Fri, 12 Feb 2010 16:12:04 -0800\"));\n-        assertThat(mod.getRevision()).isEqualTo(\"5def073a425dfe239aabd4bf8039ffe3b0e8856b\");\n-\n-        List<ModifiedFile> files = mod.getModifiedFiles();\n-        assertThat(files.size()).isEqualTo(1);\n-        assertThat(files.get(0).getFileName()).isEqualTo(\"build.xml\");\n-        assertThat(files.get(0).getAction()).isEqualTo(ModifiedAction.modified);\n-    }\n+        @Test\n+        void freshCloneDoesNotHaveWorkingCopy() {\n+            assertWorkingCopyNotCheckedOut();\n+        }\n \n-    @Test\n-    void shouldRetrieveLatestModificationWhenLogDecorationIsPresent() throws Exception {\n-        setLogDecoration();\n-        Modification mod = git.latestModification().get(0);\n-        assertThat(mod.getUserName()).isEqualTo(\"Chris Turner <cturner@thoughtworks.com>\");\n-        assertThat(mod.getComment()).isEqualTo(\"Added 'run-till-file-exists' ant target\");\n-        assertThat(mod.getModifiedTime()).isEqualTo(parseRFC822(\"Fri, 12 Feb 2010 16:12:04 -0800\"));\n-        assertThat(mod.getRevision()).isEqualTo(\"5def073a425dfe239aabd4bf8039ffe3b0e8856b\");\n-\n-        List<ModifiedFile> files = mod.getModifiedFiles();\n-        assertThat(files.size()).isEqualTo(1);\n-        assertThat(files.get(0).getFileName()).isEqualTo(\"build.xml\");\n-        assertThat(files.get(0).getAction()).isEqualTo(ModifiedAction.modified);\n-    }\n+        @Test\n+        void freshCloneOnAgentSideShouldHaveWorkingCopyCheckedOut() throws IOException {\n+            InMemoryStreamConsumer output = inMemoryConsumer();\n+            File workingDir = createTempWorkingDirectory();\n+            GitCommand git = new GitCommand(null, workingDir, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n \n-    @Test\n-    void retrieveLatestModificationShouldNotResultInWorkingCopyCheckOut() throws Exception {\n-        git.latestModification();\n-        assertWorkingCopyNotCheckedOut();\n-    }\n+            git.clone(output, repoUrl);\n \n-    @Test\n-    void getModificationsSinceShouldNotResultInWorkingCopyCheckOut() throws Exception {\n-        git.modificationsSince(GitTestRepo.REVISION_2);\n-        assertWorkingCopyNotCheckedOut();\n-    }\n+            assertWorkingCopyCheckedOut(workingDir);\n+        }\n \n-    @Test\n-    void shouldReturnNothingForModificationsSinceIfARebasedCommitSHAIsPassed() throws IOException {\n-        GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n-        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n-        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n-        GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n+        @Test\n+        void fullCloneIsNotShallow() {\n+            assertFalse(git.isShallow());\n+        }\n \n-        Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n+        @Test\n+        void shouldOnlyCloneLimitedRevisionsIfDepthSpecified() {\n+            FileUtils.deleteQuietly(this.gitLocalRepoDir);\n+            git.clone(inMemoryConsumer(), repoUrl, 2);\n+            assertTrue(git.isShallow());\n+            assertTrue(git.containsRevisionInBranch(GitTestRepo.REVISION_4));\n+            assertTrue(git.containsRevisionInBranch(GitTestRepo.REVISION_3));\n+            // can not assert on revision_2, because on old version of git (1.7)\n+            // depth '2' actually clone 3 revisions\n+            assertFalse(git.containsRevisionInBranch(GitTestRepo.REVISION_1));\n+            assertFalse(git.containsRevisionInBranch(GitTestRepo.REVISION_0));\n \n-        assertThat(command.modificationsSince(new StringRevision(modification.getRevision()))).isEmpty();\n+        }\n \n-    }\n+        @Test\n+        void unshallowALocalRepoWithArbitraryDepth() {\n+            FileUtils.deleteQuietly(this.gitLocalRepoDir);\n+            git.clone(inMemoryConsumer(), repoUrl, 2);\n+            git.unshallow(inMemoryConsumer(), 3);\n+            assertTrue(git.isShallow());\n+            assertTrue(git.containsRevisionInBranch(GitTestRepo.REVISION_2));\n+            // can not assert on revision_1, because on old version of git (1.7)\n+            // depth '3' actually clone 4 revisions\n+            assertFalse(git.containsRevisionInBranch(GitTestRepo.REVISION_0));\n+\n+            git.unshallow(inMemoryConsumer(), Integer.MAX_VALUE);\n+            assertFalse(git.isShallow());\n+\n+            assertTrue(git.containsRevisionInBranch(GitTestRepo.REVISION_0));\n+        }\n \n-    @Test\n-    void shouldReturnTheRebasedCommitForModificationsSinceTheRevisionBeforeRebase() throws IOException {\n-        GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n-        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n-        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n-        GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n+        @Test\n+        void unshallowShouldNotResultInWorkingCopyCheckout() {\n+            FileUtils.deleteQuietly(this.gitLocalRepoDir);\n+            git.cloneWithNoCheckout(inMemoryConsumer(), repoUrl);\n+            git.unshallow(inMemoryConsumer(), 3);\n+            assertWorkingCopyNotCheckedOut();\n+        }\n \n-        Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n+        @Test\n+        void shouldCloneFromBranchWhenMaterialPointsToABranch() throws IOException {\n+            gitLocalRepoDir = createTempWorkingDirectory();\n+            git = new GitCommand(null, gitLocalRepoDir, BRANCH, false, null);\n+            GitCommand branchedGit = new GitCommand(null, gitLocalRepoDir, BRANCH, false, null);\n+            branchedGit.clone(inMemoryConsumer(), gitFooBranchBundle.projectRepositoryUrl());\n+            InMemoryStreamConsumer output = inMemoryConsumer();\n+            CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"branch\").withWorkingDir(gitLocalRepoDir).run(output, null);\n+            assertEquals(\"* foo\", output.getStdOut());\n+        }\n \n-        assertThat(command.modificationsSince(REVISION_4).get(0)).isEqualTo(modification);\n-    }\n+        @Test\n+        void shouldGetTheCurrentBranchForTheCheckedOutRepo() throws IOException {\n+            gitLocalRepoDir = createTempWorkingDirectory();\n+            CommandLine gitCloneCommand = CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"clone\");\n+            gitCloneCommand.withArg(\"--branch=\" + BRANCH).withArg(new UrlArgument(gitFooBranchBundle.projectRepositoryUrl())).withArg(gitLocalRepoDir.getAbsolutePath());\n+            gitCloneCommand.run(inMemoryConsumer(), null);\n+            git = new GitCommand(null, gitLocalRepoDir, BRANCH, false, null);\n+            assertEquals(BRANCH, git.getCurrentBranch());\n+        }\n \n-    @Test\n-    void shouldReturnTheRebasedCommitForModificationsSinceTheRevisionBeforeRebaseWithColoringIsSetToAlways() throws IOException {\n-        GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n-        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n-        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n-        GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n+        @Test\n+        void shouldBombForFetchFailure() {\n+            gitInRepo(\"remote\", \"rm\", \"origin\");\n+            gitInRepo(\"remote\", \"add\", \"origin\", \"git://user:secret@foo.bar/baz\");\n+            final String message = assertThrows(Exception.class, () -> git.fetch(inMemoryConsumer())).getMessage();\n+            assertEquals(\"git fetch failed for [git://user:******@foo.bar/baz]\", message);\n+        }\n \n-        Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n-        setColoring();\n+        @Test\n+        void shouldBombForResettingFailure() {\n+            final String message = assertThrows(\n+                    Exception.class,\n+                    () -> git.resetWorkingDir(new SysOutStreamConsumer(), new StringRevision(\"abcdef\"), false)\n+            ).getMessage();\n+            assertEquals(format(\"git reset failed for [%s]\", gitLocalRepoDir), message);\n+        }\n \n-        assertThat(command.modificationsSince(REVISION_4).get(0)).isEqualTo(modification);\n-    }\n+        @Test\n+        void shouldOutputSubmoduleRevisionsAfterUpdate() throws Exception {\n+            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+            submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n+            GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+            gitWithSubmodule.clone(inMemoryConsumer(), submoduleRepos.mainRepo().urlForCommandLine());\n+            InMemoryStreamConsumer outConsumer = new InMemoryStreamConsumer();\n+            gitWithSubmodule.resetWorkingDir(outConsumer, new StringRevision(\"HEAD\"), false);\n+            Matcher matcher = compile(\".*^\\\\s[a-f0-9A-F]{40} sub1 \\\\(heads/master\\\\)$.*\", Pattern.MULTILINE | Pattern.DOTALL).matcher(outConsumer.getAllOutput());\n+            assertTrue(matcher.matches());\n+        }\n \n-    @Test\n-    void shouldReturnTheRebasedCommitForModificationsSinceTheRevisionBeforeRebaseWithLogDecoration() throws IOException {\n-        GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n-        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n-        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n-        GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n+        @Test\n+        void shouldBombForResetWorkingDirWhenSubmoduleUpdateFails() throws Exception {\n+            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+            File submoduleFolder = submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n+            GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+            gitWithSubmodule.clone(inMemoryConsumer(), submoduleRepos.mainRepo().urlForCommandLine());\n+            FileUtils.deleteDirectory(submoduleFolder);\n \n-        Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n-        setLogDecoration();\n+            assertFalse(submoduleFolder.exists());\n \n-        assertThat(command.modificationsSince(REVISION_4).get(0)).isEqualTo(modification);\n-    }\n+            final String message = assertThrows(\n+                    Exception.class,\n+                    () -> gitWithSubmodule.resetWorkingDir(new SysOutStreamConsumer(), new StringRevision(\"HEAD\"), false))\n+                    .getMessage();\n \n-    @Test\n-    void shouldBombIfCheckedForModificationsSinceWithASHAThatNoLongerExists() throws IOException {\n-        GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n-        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n-        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n-        GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n+            final String expectedError = format(\"[Cc]lone of '%s' into submodule path '((.*)[\\\\/])?sub1' failed\",\n+                    quote(FileUtil.toFileURI(submoduleFolder.getAbsolutePath()) + \"/\"));\n+            assertTrue(compile(expectedError).matcher(message).find());\n+        }\n \n-        Modification modification = remoteRepo.checkInOneFile(\"foo\", \"Adding a commit\").get(0);\n-        remoteRepo.addFileAndAmend(\"bar\", \"amendedCommit\");\n+        @Test\n+        void shouldRetrieveLatestModification() {\n+            Modification mod = git.latestModification().get(0);\n+            assertEquals(\"Chris Turner <cturner@thoughtworks.com>\", mod.getUserName());\n+            assertEquals(\"Added 'run-till-file-exists' ant target\", mod.getComment());\n+            assertEquals(parseRFC822(\"Fri, 12 Feb 2010 16:12:04 -0800\"), mod.getModifiedTime());\n+            assertEquals(\"5def073a425dfe239aabd4bf8039ffe3b0e8856b\", mod.getRevision());\n+\n+            List<ModifiedFile> files = mod.getModifiedFiles();\n+            assertEquals(1, files.size());\n+            assertEquals(\"build.xml\", files.get(0).getFileName());\n+            assertEquals(ModifiedAction.modified, files.get(0).getAction());\n+        }\n \n-        assertThatCode(() -> command.modificationsSince(new StringRevision(modification.getRevision())))\n-                .isInstanceOf(CommandLineException.class);\n-    }\n+        @Test\n+        void shouldRetrieveLatestModificationWhenColoringIsSetToAlways() {\n+            setColoring();\n+            Modification mod = git.latestModification().get(0);\n+            assertEquals(\"Chris Turner <cturner@thoughtworks.com>\", mod.getUserName());\n+            assertEquals(\"Added 'run-till-file-exists' ant target\", mod.getComment());\n+            assertEquals(parseRFC822(\"Fri, 12 Feb 2010 16:12:04 -0800\"), mod.getModifiedTime());\n+            assertEquals(\"5def073a425dfe239aabd4bf8039ffe3b0e8856b\", mod.getRevision());\n+\n+            List<ModifiedFile> files = mod.getModifiedFiles();\n+            assertEquals(1, files.size());\n+            assertEquals(\"build.xml\", files.get(0).getFileName());\n+            assertEquals(ModifiedAction.modified, files.get(0).getAction());\n+        }\n \n-    @Test\n-    void shouldBombIfCheckedForModificationsSinceWithANonExistentRef() throws IOException {\n-        GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n-        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n-        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n-        GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"non-existent-branch\", false, null);\n+        @Test\n+        void shouldRetrieveLatestModificationWhenLogDecorationIsPresent() {\n+            setLogDecoration();\n+            Modification mod = git.latestModification().get(0);\n+            assertEquals(\"Chris Turner <cturner@thoughtworks.com>\", mod.getUserName());\n+            assertEquals(\"Added 'run-till-file-exists' ant target\", mod.getComment());\n+            assertEquals(parseRFC822(\"Fri, 12 Feb 2010 16:12:04 -0800\"), mod.getModifiedTime());\n+            assertEquals(\"5def073a425dfe239aabd4bf8039ffe3b0e8856b\", mod.getRevision());\n+\n+            List<ModifiedFile> files = mod.getModifiedFiles();\n+            assertEquals(1, files.size());\n+            assertEquals(\"build.xml\", files.get(0).getFileName());\n+            assertEquals(ModifiedAction.modified, files.get(0).getAction());\n+        }\n \n-        Modification modification = remoteRepo.checkInOneFile(\"foo\", \"Adding a commit\").get(0);\n+        @Test\n+        void retrieveLatestModificationShouldNotResultInWorkingCopyCheckOut() {\n+            git.latestModification();\n+            assertWorkingCopyNotCheckedOut();\n+        }\n \n-        assertThatCode(() -> command.modificationsSince(new StringRevision(modification.getRevision())))\n-                .isInstanceOf(CommandLineException.class);\n-    }\n+        @Test\n+        void getModificationsSinceShouldNotResultInWorkingCopyCheckOut() {\n+            git.modificationsSince(GitTestRepo.REVISION_2);\n+            assertWorkingCopyNotCheckedOut();\n+        }\n \n-    @Test\n-    void shouldBombWhileRetrievingLatestModificationFromANonExistentRef() throws IOException {\n-        expectedException.expect(CommandLineException.class);\n-        expectedException.expectMessage(\"ambiguous argument 'origin/non-existent-branch': unknown revision or path not in the working tree.\");\n-        GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n-        executeOnGitRepo(\"git\", \"remote\", \"rm\", \"origin\");\n-        executeOnGitRepo(\"git\", \"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n-        GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"non-existent-branch\", false, null);\n+        @Test\n+        void shouldReturnNothingForModificationsSinceIfARebasedCommitSHAIsPassed() throws IOException {\n+            GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n+            gitInRepo(\"remote\", \"rm\", \"origin\");\n+            gitInRepo(\"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n+            GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n \n-        command.latestModification();\n-    }\n+            Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n \n-    @Test\n-    void shouldReturnTrueIfTheGivenBranchContainsTheRevision() {\n-        assertThat(git.containsRevisionInBranch(REVISION_4)).isTrue();\n-    }\n+            assertTrue(command.modificationsSince(new StringRevision(modification.getRevision())).isEmpty());\n \n-    @Test\n-    void shouldReturnFalseIfTheGivenBranchDoesNotContainTheRevision() {\n-        assertThat(git.containsRevisionInBranch(NON_EXISTENT_REVISION)).isFalse();\n-    }\n+        }\n \n-    @Test\n-    void shouldRetrieveFilenameForInitialRevision() throws IOException {\n-        GitTestRepo testRepo = new GitTestRepo(GitTestRepo.GIT_SUBMODULE_REF_BUNDLE, temporaryFolder);\n-        GitCommand gitCommand = new GitCommand(null, testRepo.gitRepository(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        Modification modification = gitCommand.latestModification().get(0);\n-        assertThat(modification.getModifiedFiles()).hasSize(1);\n-        assertThat(modification.getModifiedFiles().get(0).getFileName()).isEqualTo(\"remote.txt\");\n-    }\n+        @Test\n+        void shouldReturnTheRebasedCommitForModificationsSinceTheRevisionBeforeRebase() throws IOException {\n+            GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n+            gitInRepo(\"remote\", \"rm\", \"origin\");\n+            gitInRepo(\"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n+            GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n \n-    @Test\n-    void shouldRetrieveLatestModificationFromBranch() throws Exception {\n-        GitTestRepo branchedRepo = GitTestRepo.testRepoAtBranch(GIT_FOO_BRANCH_BUNDLE, BRANCH, temporaryFolder);\n-        GitCommand branchedGit = new GitCommand(null, createTempWorkingDirectory(), BRANCH, false, null);\n-        branchedGit.clone(inMemoryConsumer(), branchedRepo.projectRepositoryUrl());\n+            Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n \n-        Modification mod = branchedGit.latestModification().get(0);\n+            assertEquals(modification, command.modificationsSince(REVISION_4).get(0));\n+        }\n \n-        assertThat(mod.getUserName()).isEqualTo(\"Chris Turner <cturner@thoughtworks.com>\");\n-        assertThat(mod.getComment()).isEqualTo(\"Started foo branch\");\n-        assertThat(mod.getModifiedTime()).isEqualTo(parseRFC822(\"Tue, 05 Feb 2009 14:28:08 -0800\"));\n-        assertThat(mod.getRevision()).isEqualTo(\"b4fa7271c3cef91822f7fa502b999b2eab2a380d\");\n+        @Test\n+        void shouldReturnTheRebasedCommitForModificationsSinceTheRevisionBeforeRebaseWithColoringIsSetToAlways() throws IOException {\n+            GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n+            gitInRepo(\"remote\", \"rm\", \"origin\");\n+            gitInRepo(\"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n+            GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n \n-        List<ModifiedFile> files = mod.getModifiedFiles();\n-        assertThat(files).hasSize(1);\n-        assertThat(files.get(0).getFileName()).isEqualTo(\"first.txt\");\n-        assertThat(files.get(0).getAction()).isEqualTo(ModifiedAction.modified);\n-    }\n+            Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n+            setColoring();\n \n-    @Test\n-    void shouldRetrieveListOfSubmoduleFolders() throws Exception {\n-        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-        submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n-        GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-        gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().getUrl());\n-        gitWithSubmodule.fetchAndResetToHead(outputStreamConsumer);\n-        gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n-        List<String> folders = gitWithSubmodule.submoduleFolders();\n-        assertThat(folders).hasSize(1);\n-        assertThat(folders.get(0)).isEqualTo(\"sub1\");\n-    }\n+            assertEquals(modification, command.modificationsSince(REVISION_4).get(0));\n+        }\n \n-    @Test\n-    void shouldNotThrowErrorWhenConfigRemoveSectionFails() throws Exception {\n-        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-        submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n-        GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null) {\n-            //hack to reproduce synchronization issue\n-            @Override\n-            public Map<String, String> submoduleUrls() {\n-                return Collections.singletonMap(\"submodule\", \"submodule\");\n-            }\n-        };\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-        gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().getUrl());\n+        @Test\n+        void shouldReturnTheRebasedCommitForModificationsSinceTheRevisionBeforeRebaseWithLogDecoration() throws IOException {\n+            GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n+            gitInRepo(\"remote\", \"rm\", \"origin\");\n+            gitInRepo(\"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n+            GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n \n-        gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n+            Modification modification = remoteRepo.addFileAndAmend(\"foo\", \"amendedCommit\").get(0);\n+            setLogDecoration();\n \n-    }\n+            assertEquals(modification, command.modificationsSince(REVISION_4).get(0));\n+        }\n \n-    @Test\n-    void shouldNotFailIfUnableToRemoveSubmoduleEntryFromConfig() throws Exception {\n-        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-        submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n-        GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-        gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().getUrl());\n-        gitWithSubmodule.fetchAndResetToHead(outputStreamConsumer);\n-        gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n-        List<String> folders = gitWithSubmodule.submoduleFolders();\n-        assertThat(folders).hasSize(1);\n-        assertThat(folders.get(0)).isEqualTo(\"sub1\");\n-    }\n+        @Test\n+        void shouldBombIfCheckedForModificationsSinceWithASHAThatNoLongerExists() throws IOException {\n+            GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n+            gitInRepo(\"remote\", \"rm\", \"origin\");\n+            gitInRepo(\"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n+            GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"master\", false, null);\n \n-    @Test\n-    void shouldRetrieveSubmoduleUrls() throws Exception {\n-        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-        File submodule = submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n-        GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-        gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().getUrl());\n-        gitWithSubmodule.fetchAndResetToHead(outputStreamConsumer);\n-\n-        gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n-        Map<String, String> urls = gitWithSubmodule.submoduleUrls();\n-        assertThat(urls).hasSize(1);\n-        assertThat(urls.containsKey(\"sub1\")).isTrue();\n-        assertThat(urls.get(\"sub1\")).isEqualTo(FileUtil.toFileURI(submodule));\n-    }\n+            Modification modification = remoteRepo.checkInOneFile(\"foo\", \"Adding a commit\").get(0);\n+            remoteRepo.addFileAndAmend(\"bar\", \"amendedCommit\");\n \n-    @Test\n-    void shouldRetrieveZeroSubmoduleUrlsIfTheyAreNotConfigured() {\n-        Map<String, String> submoduleUrls = git.submoduleUrls();\n-        assertThat(submoduleUrls).isEmpty();\n-    }\n+            assertThrows(CommandLineException.class, () -> command.modificationsSince(new StringRevision(modification.getRevision())));\n+        }\n \n-    @Test\n-    void shouldRetrieveRemoteRepoValue() {\n-        assertThat(git.workingRepositoryUrl().originalArgument()).startsWith(repoUrl);\n-    }\n+        @Test\n+        void shouldBombIfCheckedForModificationsSinceWithANonExistentRef() throws IOException {\n+            GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n+            gitInRepo(\"remote\", \"rm\", \"origin\");\n+            gitInRepo(\"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n+            GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"non-existent-branch\", false, null);\n \n-    @Test\n-    void shouldCheckIfRemoteRepoExists() {\n-        GitCommand gitCommand = new GitCommand(null, null, null, false, null);\n-        gitCommand.checkConnection(git.workingRepositoryUrl(), \"master\");\n-    }\n+            Modification modification = remoteRepo.checkInOneFile(\"foo\", \"Adding a commit\").get(0);\n \n-    @Test\n-    void shouldThrowExceptionWhenRepoNotExist() {\n-        GitCommand gitCommand = new GitCommand(null, null, null, false, null);\n+            assertThrows(CommandLineException.class, () -> command.modificationsSince(new StringRevision(modification.getRevision())));\n+        }\n \n-        assertThatCode(() -> gitCommand.checkConnection(new UrlArgument(\"git://somewhere.is.not.exist\"), \"master\"))\n-                .isInstanceOf(Exception.class);\n-    }\n+        @Test\n+        void shouldBombWhileRetrievingLatestModificationFromANonExistentRef() throws IOException {\n+            GitTestRepo remoteRepo = new GitTestRepo(temporaryFolder);\n+            gitInRepo(\"remote\", \"rm\", \"origin\");\n+            gitInRepo(\"remote\", \"add\", \"origin\", remoteRepo.projectRepositoryUrl());\n+            GitCommand command = new GitCommand(remoteRepo.createMaterial().getFingerprint(), gitLocalRepoDir, \"non-existent-branch\", false, null);\n \n-    @Test\n-    void shouldThrowExceptionWhenRemoteBranchDoesNotExist() {\n-        GitCommand gitCommand = new GitCommand(null, null, null, false, null);\n+            final String message = assertThrows(CommandLineException.class, command::latestModification).getMessage();\n+            assertTrue(message.contains(\"ambiguous argument 'origin/non-existent-branch': unknown revision or path not in the working tree.\"));\n+        }\n \n-        assertThatCode(() -> gitCommand.checkConnection(new UrlArgument(gitRepo.projectRepositoryUrl()), \"Invalid_Branch\"))\n-                .isInstanceOf(Exception.class);\n-    }\n+        @Test\n+        void shouldReturnTrueIfTheGivenBranchContainsTheRevision() {\n+            assertTrue(git.containsRevisionInBranch(REVISION_4));\n+        }\n+\n+        @Test\n+        void shouldReturnFalseIfTheGivenBranchDoesNotContainTheRevision() {\n+            assertFalse(git.containsRevisionInBranch(NON_EXISTENT_REVISION));\n+        }\n \n+        @Test\n+        void shouldRetrieveFilenameForInitialRevision() throws IOException {\n+            GitTestRepo testRepo = new GitTestRepo(GitTestRepo.GIT_SUBMODULE_REF_BUNDLE, temporaryFolder);\n+            GitCommand gitCommand = new GitCommand(null, testRepo.gitRepository(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+            Modification modification = gitCommand.latestModification().get(0);\n+            assertEquals(1, modification.getModifiedFiles().size());\n+            assertEquals(\"remote.txt\", modification.getModifiedFiles().get(0).getFileName());\n+        }\n \n-    @Test\n-    void shouldIncludeNewChangesInModificationCheck() throws Exception {\n-        String originalNode = git.latestModification().get(0).getRevision();\n-        File testingFile = checkInNewRemoteFile();\n+        @Test\n+        void shouldRetrieveLatestModificationFromBranch() throws Exception {\n+            GitTestRepo branchedRepo = GitTestRepo.testRepoAtBranch(GIT_FOO_BRANCH_BUNDLE, BRANCH, temporaryFolder);\n+            GitCommand branchedGit = new GitCommand(null, createTempWorkingDirectory(), BRANCH, false, null);\n+            branchedGit.clone(inMemoryConsumer(), branchedRepo.projectRepositoryUrl());\n \n-        Modification modification = git.latestModification().get(0);\n-        assertThat(modification.getRevision()).isNotEqualTo(originalNode);\n-        assertThat(modification.getComment()).isEqualTo(\"New checkin of \" + testingFile.getName());\n-        assertThat(modification.getModifiedFiles()).hasSize(1);\n-        assertThat(modification.getModifiedFiles().get(0).getFileName()).isEqualTo(testingFile.getName());\n-    }\n+            Modification mod = branchedGit.latestModification().get(0);\n \n-    @Test\n-    void shouldIncludeChangesFromTheFutureInModificationCheck() throws Exception {\n-        String originalNode = git.latestModification().get(0).getRevision();\n-        File testingFile = checkInNewRemoteFileInFuture(THREE_DAYS_FROM_NOW);\n+            assertEquals(\"Chris Turner <cturner@thoughtworks.com>\", mod.getUserName());\n+            assertEquals(\"Started foo branch\", mod.getComment());\n+            assertEquals(parseRFC822(\"Tue, 05 Feb 2009 14:28:08 -0800\"), mod.getModifiedTime());\n+            assertEquals(\"b4fa7271c3cef91822f7fa502b999b2eab2a380d\", mod.getRevision());\n \n-        Modification modification = git.latestModification().get(0);\n-        assertThat(modification.getRevision()).isNotEqualTo(originalNode);\n-        assertThat(modification.getComment()).isEqualTo(\"New checkin of \" + testingFile.getName());\n-        assertThat(modification.getModifiedTime()).isEqualTo(THREE_DAYS_FROM_NOW);\n-    }\n+            List<ModifiedFile> files = mod.getModifiedFiles();\n+            assertEquals(1, files.size());\n+            assertEquals(\"first.txt\", files.get(0).getFileName());\n+            assertEquals(ModifiedAction.modified, files.get(0).getAction());\n+        }\n \n-    @Test\n-    void shouldThrowExceptionIfRepoCanNotConnectWhenModificationCheck() {\n-        FileUtils.deleteQuietly(repoLocation);\n-        try {\n-            git.latestModification();\n-            fail(\"Should throw exception when repo cannot connected\");\n-        } catch (Exception e) {\n-            assertThat(e.getMessage()).matches(str -> str.contains(\"The remote end hung up unexpectedly\") ||\n-                    str.contains(\"Could not read from remote repository\"));\n+        @Test\n+        void shouldRetrieveListOfSubmoduleFolders() throws Exception {\n+            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+            submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n+            GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+            gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().urlForCommandLine());\n+            gitWithSubmodule.fetchAndResetToHead(outputStreamConsumer, false);\n+            gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n+            List<String> folders = gitWithSubmodule.submoduleFolders();\n+            assertEquals(1, folders.size());\n+            assertEquals(\"sub1\", folders.get(0));\n         }\n-    }\n \n-    @Test\n-    void shouldParseGitOutputCorrectly() throws IOException {\n-        List<String> stringList;\n-        try (InputStream resourceAsStream = getClass().getResourceAsStream(\"git_sample_output.text\")) {\n-            stringList = IOUtils.readLines(resourceAsStream, UTF_8);\n-        }\n-\n-        GitModificationParser parser = new GitModificationParser();\n-        List<Modification> mods = parser.parse(stringList);\n-        assertThat(mods).hasSize(3);\n-\n-        Modification mod = mods.get(2);\n-        assertThat(mod.getRevision()).isEqualTo(\"46cceff864c830bbeab0a7aaa31707ae2302762f\");\n-        assertThat(mod.getModifiedTime()).isEqualTo(DateUtils.parseISO8601(\"2009-08-11 12:37:09 -0700\"));\n-        assertThat(mod.getUserDisplayName()).isEqualTo(\"Cruise Developer <cruise@cruise-sf3.(none)>\");\n-        assertThat(mod.getComment()).isEqualTo(\"author:cruise <cceuser@CceDev01.(none)>\\n\"\n-                + \"node:ecfab84dd4953105e3301c5992528c2d381c1b8a\\n\"\n-                + \"date:2008-12-31 14:32:40 +0800\\n\"\n-                + \"description:Moving rakefile to build subdirectory for #2266\\n\"\n-                + \"\\n\"\n-                + \"author:CceUser <cceuser@CceDev01.(none)>\\n\"\n-                + \"node:fd16efeb70fcdbe63338c49995ce9ff7659e6e77\\n\"\n-                + \"date:2008-12-31 14:17:06 +0800\\n\"\n-                + \"description:Adding rakefile\");\n-    }\n+        @Test\n+        void shouldNotThrowErrorWhenConfigRemoveSectionFails() throws Exception {\n+            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+            submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n+            GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null) {\n+                //hack to reproduce synchronization issue\n+                @Override\n+                public Map<String, String> submoduleUrls() {\n+                    return Collections.singletonMap(\"submodule\", \"submodule\");\n+                }\n+            };\n+            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+            gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().urlForCommandLine());\n+\n+            gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n \n-    @Test\n-    void shouldCleanUnversionedFilesInsideSubmodulesBeforeUpdating() throws Exception {\n-        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-        String submoduleDirectoryName = \"local-submodule\";\n-        submoduleRepos.addSubmodule(SUBMODULE, submoduleDirectoryName);\n-        File cloneDirectory = createTempWorkingDirectory();\n-        GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-        clonedCopy.clone(outputStreamConsumer, submoduleRepos.mainRepo().getUrl()); // Clone repository without submodules\n-        clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(\"HEAD\"), false);  // Pull submodules to working copy - Pipeline counter 1\n-        File unversionedFile = new File(new File(cloneDirectory, submoduleDirectoryName), \"unversioned_file.txt\");\n-        FileUtils.writeStringToFile(unversionedFile, \"this is an unversioned file. lets see you deleting me.. come on.. I dare you!!!!\", UTF_8);\n-\n-        clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(\"HEAD\"), false); // Should clean unversioned file on next fetch - Pipeline counter 2\n-\n-        assertThat(unversionedFile.exists()).isFalse();\n-    }\n+        }\n \n-    @Test\n-    void shouldRemoveChangesToModifiedFilesInsideSubmodulesBeforeUpdating() throws Exception {\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-        String submoduleDirectoryName = \"local-submodule\";\n-        File cloneDirectory = createTempWorkingDirectory();\n+        @Test\n+        void shouldNotFailIfUnableToRemoveSubmoduleEntryFromConfig() throws Exception {\n+            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+            submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n+            GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+            gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().urlForCommandLine());\n+            gitWithSubmodule.fetchAndResetToHead(outputStreamConsumer, false);\n+            gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n+            List<String> folders = gitWithSubmodule.submoduleFolders();\n+            assertEquals(1, folders.size());\n+            assertEquals(\"sub1\", folders.get(0));\n+        }\n \n-        File remoteSubmoduleLocation = submoduleRepos.addSubmodule(SUBMODULE, submoduleDirectoryName);\n+        @Test\n+        void shouldRetrieveSubmoduleUrls() throws Exception {\n+            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+            File submodule = submoduleRepos.addSubmodule(SUBMODULE, \"sub1\");\n+            GitCommand gitWithSubmodule = new GitCommand(null, createTempWorkingDirectory(), GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+            gitWithSubmodule.clone(outputStreamConsumer, submoduleRepos.mainRepo().urlForCommandLine());\n+            gitWithSubmodule.fetchAndResetToHead(outputStreamConsumer, false);\n+\n+            gitWithSubmodule.updateSubmoduleWithInit(outputStreamConsumer, false);\n+            Map<String, String> urls = gitWithSubmodule.submoduleUrls();\n+            assertEquals(1, urls.size());\n+            assertTrue(urls.containsKey(\"sub1\"));\n+            assertEquals(FileUtil.toFileURI(submodule), urls.get(\"sub1\"));\n+        }\n \n-        /* Simulate an agent checkout of code. */\n-        GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        clonedCopy.clone(outputStreamConsumer, submoduleRepos.mainRepo().getUrl());\n-        clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(\"HEAD\"), false);\n+        @Test\n+        void shouldRetrieveZeroSubmoduleUrlsIfTheyAreNotConfigured() {\n+            Map<String, String> submoduleUrls = git.submoduleUrls();\n+            assertTrue(submoduleUrls.isEmpty());\n+        }\n \n-        /* Simulate a local modification of file inside submodule, on agent side. */\n-        File fileInSubmodule = allFilesIn(new File(cloneDirectory, submoduleDirectoryName), \"file-\").get(0);\n-        FileUtils.writeStringToFile(fileInSubmodule, \"Some other new content.\", UTF_8);\n+        @Test\n+        void shouldRetrieveRemoteRepoValue() {\n+            assertTrue(git.workingRepositoryUrl().originalArgument().startsWith(repoUrl));\n+        }\n \n-        /* Commit a change to the file on the repo. */\n-        List<Modification> modifications = submoduleRepos.modifyOneFileInSubmoduleAndUpdateMainRepo(\n-                remoteSubmoduleLocation, submoduleDirectoryName, fileInSubmodule.getName(), \"NEW CONTENT OF FILE\");\n+        @Test\n+        void shouldCheckIfRemoteRepoExists() {\n+            GitCommand gitCommand = withBranch(\"master\");\n+            gitCommand.checkConnection(git.workingRepositoryUrl());\n+        }\n \n-        /* Simulate start of a new build on agent. */\n-        clonedCopy.fetch(outputStreamConsumer);\n-        clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(modifications.get(0).getRevision()), false);\n+        @Test\n+        void shouldThrowExceptionWhenRepoNotExist() {\n+            GitCommand gitCommand = withBranch(\"master\");\n \n-        assertThat(FileUtils.readFileToString(fileInSubmodule, UTF_8)).isEqualTo(\"NEW CONTENT OF FILE\");\n-    }\n+            assertThrows(Exception.class, () -> gitCommand.checkConnection(new UrlArgument(\"git://does.not.exist\")));\n+        }\n \n-    @Test\n-    void shouldAllowSubmoduleUrlsToChange() throws Exception {\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-        GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n-        String submoduleDirectoryName = \"local-submodule\";\n-        File cloneDirectory = createTempWorkingDirectory();\n+        @Test\n+        void shouldThrowExceptionWhenRemoteBranchDoesNotExist() {\n+            GitCommand gitCommand = withBranch(\"Invalid_Branch\");\n \n-        submoduleRepos.addSubmodule(SUBMODULE, submoduleDirectoryName);\n+            assertThrows(Exception.class, () -> gitCommand.checkConnection(new UrlArgument(repoUrl)));\n+        }\n \n-        GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        clonedCopy.clone(outputStreamConsumer, submoduleRepos.mainRepo().getUrl());\n-        clonedCopy.fetchAndResetToHead(outputStreamConsumer);\n \n-        submoduleRepos.changeSubmoduleUrl(submoduleDirectoryName);\n+        @Test\n+        void shouldIncludeNewChangesInModificationCheck() throws Exception {\n+            String originalNode = git.latestModification().get(0).getRevision();\n+            File testingFile = checkInNewRemoteFile();\n \n-        clonedCopy.fetchAndResetToHead(outputStreamConsumer);\n-    }\n+            Modification modification = git.latestModification().get(0);\n+            assertNotEquals(originalNode, modification.getRevision());\n+            assertEquals(\"New checkin of \" + testingFile.getName(), modification.getComment());\n+            assertEquals(1, modification.getModifiedFiles().size());\n+            assertEquals(testingFile.getName(), modification.getModifiedFiles().get(0).getFileName());\n+        }\n \n-    @Test\n-    @EnabledOnGitVersions(from = \"2.10.0\")\n-    void shouldShallowCloneSubmodulesWhenSpecified() throws Exception {\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-        GitRepoContainingSubmodule repoContainingSubmodule = new GitRepoContainingSubmodule(temporaryFolder);\n-        String submoduleDirectoryName = \"submoduleDir\";\n-        repoContainingSubmodule.addSubmodule(SUBMODULE, submoduleDirectoryName);\n-\n-        File cloneDirectory = createTempWorkingDirectory();\n-        GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        clonedCopy.clone(outputStreamConsumer, FileUtil.toFileURI(repoContainingSubmodule.mainRepo().getUrl()), 1);\n-        clonedCopy.fetchAndResetToHead(outputStreamConsumer, true);\n-        ConsoleResult consoleResult = executeOnDir(new File(cloneDirectory, submoduleDirectoryName),\n-                \"git\", \"rev-list\", \"--count\", \"master\");\n-        assertThat(consoleResult.outputAsString()).isEqualTo(\"1\");\n-    }\n+        @Test\n+        void shouldIncludeChangesFromTheFutureInModificationCheck() throws Exception {\n+            String originalNode = git.latestModification().get(0).getRevision();\n+            File testingFile = checkInNewRemoteFileInFuture(THREE_DAYS_FROM_NOW);\n \n-    @Test\n-    @EnabledOnGitVersions(from = \"2.10.0\", through = \"2.25.4\")\n-    void shouldUnshallowSubmodulesIfSubmoduleUpdateFails() throws Exception {\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-        GitRepoContainingSubmodule repoContainingSubmodule = new GitRepoContainingSubmodule(temporaryFolder);\n-        String submoduleDirectoryName = \"submoduleDir\";\n-        repoContainingSubmodule.addSubmodule(SUBMODULE, submoduleDirectoryName);\n-        repoContainingSubmodule.goBackOneCommitInSubmoduleAndUpdateMainRepo(submoduleDirectoryName);\n-\n-        File cloneDirectory = createTempWorkingDirectory();\n-        GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        clonedCopy.clone(outputStreamConsumer, FileUtil.toFileURI(repoContainingSubmodule.mainRepo().getUrl()), 1);\n-        clonedCopy.fetchAndResetToHead(outputStreamConsumer, true);\n-        ConsoleResult consoleResult = executeOnDir(new File(cloneDirectory, submoduleDirectoryName),\n-                \"git\", \"rev-list\", \"--count\", \"master\");\n-        assertThat(consoleResult.outputAsString()).isEqualTo(\"2\");\n-    }\n+            Modification modification = git.latestModification().get(0);\n+            assertNotEquals(originalNode, modification.getRevision());\n+            assertEquals(\"New checkin of \" + testingFile.getName(), modification.getComment());\n+            assertEquals(THREE_DAYS_FROM_NOW, modification.getModifiedTime());\n+        }\n \n-    @Test\n-    void shouldCleanIgnoredFilesIfToggleIsDisabled() throws IOException {\n-        InMemoryStreamConsumer output = inMemoryConsumer();\n-        File gitIgnoreFile = new File(repoLocation, \".gitignore\");\n-        FileUtils.writeStringToFile(gitIgnoreFile, \"*.foo\", UTF_8);\n-        gitRepo.addFileAndPush(gitIgnoreFile, \"added gitignore\");\n-        git.fetchAndResetToHead(output);\n-\n-        File ignoredFile = new File(gitLocalRepoDir, \"ignored.foo\");\n-        assertThat(ignoredFile.createNewFile()).isTrue();\n-        git.fetchAndResetToHead(output);\n-        assertThat(ignoredFile.exists()).isFalse();\n-    }\n+        @Test\n+        void shouldThrowExceptionIfRepoCanNotConnectWhenModificationCheck() {\n+            FileUtils.deleteQuietly(repoLocation);\n \n-    @Test\n-    void shouldNotCleanIgnoredFilesIfToggleIsEnabled() throws IOException {\n-        System.setProperty(\"toggle.agent.git.clean.keep.ignored.files\", \"Y\");\n-        InMemoryStreamConsumer output = inMemoryConsumer();\n-        File gitIgnoreFile = new File(repoLocation, \".gitignore\");\n-        FileUtils.writeStringToFile(gitIgnoreFile, \"*.foo\", UTF_8);\n-        gitRepo.addFileAndPush(gitIgnoreFile, \"added gitignore\");\n-        git.fetchAndResetToHead(output);\n-\n-        File ignoredFile = new File(gitLocalRepoDir, \"ignored.foo\");\n-        assertThat(ignoredFile.createNewFile()).isTrue();\n-        git.fetchAndResetToHead(output);\n-        assertThat(ignoredFile.exists()).isTrue();\n-    }\n+            final String message = assertThrows(Exception.class, git::latestModification).getMessage();\n+            assertTrue(\n+                    message.contains(\"The remote end hung up unexpectedly\") ||\n+                            message.contains(\"Could not read from remote repository\")\n+            );\n+        }\n \n-    @Test\n-    void shouldNotThrowExceptionWhenSubmoduleIsAddedWithACustomName() {\n-        executeOnDir(gitLocalRepoDir, \"git\", \"submodule\", \"add\", \"--name\", \"Custom\", gitFooBranchBundle.projectRepositoryUrl());\n-        git.fetchAndResetToHead(inMemoryConsumer());\n-    }\n+        @Test\n+        void shouldParseGitOutputCorrectly() throws IOException {\n+            List<String> stringList;\n+            try (InputStream resourceAsStream = getClass().getResourceAsStream(\"git_sample_output.text\")) {\n+                stringList = IOUtils.readLines(resourceAsStream, UTF_8);\n+            }\n \n-    private List<File> allFilesIn(File directory, String prefixOfFiles) {\n-        return new ArrayList<>(FileUtils.listFiles(directory, andFileFilter(fileFileFilter(), prefixFileFilter(prefixOfFiles)), null));\n-    }\n+            GitModificationParser parser = new GitModificationParser();\n+            List<Modification> mods = parser.parse(stringList);\n+            assertEquals(3, mods.size());\n+\n+            Modification mod = mods.get(2);\n+            assertEquals(\"46cceff864c830bbeab0a7aaa31707ae2302762f\", mod.getRevision());\n+            assertEquals(DateUtils.parseISO8601(\"2009-08-11 12:37:09 -0700\"), mod.getModifiedTime());\n+            assertEquals(\"Cruise Developer <cruise@cruise-sf3.(none)>\", mod.getUserDisplayName());\n+            final String expected = \"author:cruise <cceuser@CceDev01.(none)>\\n\"\n+                    + \"node:ecfab84dd4953105e3301c5992528c2d381c1b8a\\n\"\n+                    + \"date:2008-12-31 14:32:40 +0800\\n\"\n+                    + \"description:Moving rakefile to build subdirectory for #2266\\n\"\n+                    + \"\\n\"\n+                    + \"author:CceUser <cceuser@CceDev01.(none)>\\n\"\n+                    + \"node:fd16efeb70fcdbe63338c49995ce9ff7659e6e77\\n\"\n+                    + \"date:2008-12-31 14:17:06 +0800\\n\"\n+                    + \"description:Adding rakefile\";\n+            assertEquals(expected, mod.getComment());\n+        }\n \n-    private File createTempWorkingDirectory() throws IOException {\n-        return temporaryFolder.newFolder(\"GitCommandTest\" + System.currentTimeMillis(), \"repo\");\n-    }\n+        @Test\n+        void shouldCleanUnversionedFilesInsideSubmodulesBeforeUpdating() throws Exception {\n+            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+            String submoduleDirectoryName = \"local-submodule\";\n+            submoduleRepos.addSubmodule(SUBMODULE, submoduleDirectoryName);\n+            File cloneDirectory = createTempWorkingDirectory();\n+            GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+            clonedCopy.clone(outputStreamConsumer, submoduleRepos.mainRepo().urlForCommandLine()); // Clone repository without submodules\n+            clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(\"HEAD\"), false);  // Pull submodules to working copy - Pipeline counter 1\n+            File unversionedFile = new File(new File(cloneDirectory, submoduleDirectoryName), \"unversioned_file.txt\");\n+            FileUtils.writeStringToFile(unversionedFile, \"this is an unversioned file. lets see you deleting me.. come on.. I dare you!!!!\", UTF_8);\n+\n+            clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(\"HEAD\"), false); // Should clean unversioned file on next fetch - Pipeline counter 2\n+\n+            assertFalse(unversionedFile.exists());\n+        }\n \n-    private File checkInNewRemoteFile() throws IOException {\n-        GitCommand remoteGit = new GitCommand(null, repoLocation, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        File testingFile = new File(repoLocation, \"testing-file\" + System.currentTimeMillis() + \".txt\");\n-        testingFile.createNewFile();\n-        remoteGit.add(testingFile);\n-        remoteGit.commit(\"New checkin of \" + testingFile.getName());\n-        return testingFile;\n-    }\n+        @Test\n+        void shouldRemoveChangesToModifiedFilesInsideSubmodulesBeforeUpdating() throws Exception {\n+            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+            String submoduleDirectoryName = \"local-submodule\";\n+            File cloneDirectory = createTempWorkingDirectory();\n \n-    private File checkInNewRemoteFileInFuture(Date checkinDate) throws IOException {\n-        GitCommand remoteGit = new GitCommand(null, repoLocation, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        File testingFile = new File(repoLocation, \"testing-file\" + System.currentTimeMillis() + \".txt\");\n-        testingFile.createNewFile();\n-        remoteGit.add(testingFile);\n-        remoteGit.commitOnDate(\"New checkin of \" + testingFile.getName(), checkinDate);\n-        return testingFile;\n-    }\n+            File remoteSubmoduleLocation = submoduleRepos.addSubmodule(SUBMODULE, submoduleDirectoryName);\n \n-    private void executeOnGitRepo(String command, String... args) {\n-        executeOnDir(gitLocalRepoDir, command, args);\n-    }\n+            /* Simulate an agent checkout of code. */\n+            GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+            clonedCopy.clone(outputStreamConsumer, submoduleRepos.mainRepo().urlForCommandLine());\n+            clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(\"HEAD\"), false);\n \n-    private ConsoleResult executeOnDir(File dir, String command, String... args) {\n-        CommandLine commandLine = CommandLine.createCommandLine(command);\n-        commandLine.withArgs(args);\n-        commandLine.withEncoding(\"utf-8\");\n-        assertThat(dir.exists()).isTrue();\n-        commandLine.setWorkingDir(dir);\n-        return commandLine.runOrBomb(true, null);\n-    }\n+            /* Simulate a local modification of file inside submodule, on agent side. */\n+            File fileInSubmodule = allFilesIn(new File(cloneDirectory, submoduleDirectoryName)).get(0);\n+            FileUtils.writeStringToFile(fileInSubmodule, \"Some other new content.\", UTF_8);\n \n-    private void setColoring() {\n-        executeOnGitRepo(\"git\", \"config\", \"color.diff\", \"always\");\n-        executeOnGitRepo(\"git\", \"config\", \"color.status\", \"always\");\n-        executeOnGitRepo(\"git\", \"config\", \"color.interactive\", \"always\");\n-        executeOnGitRepo(\"git\", \"config\", \"color.branch\", \"always\");\n-    }\n+            /* Commit a change to the file on the repo. */\n+            List<Modification> modifications = submoduleRepos.modifyOneFileInSubmoduleAndUpdateMainRepo(\n+                    remoteSubmoduleLocation, submoduleDirectoryName, fileInSubmodule.getName(), \"NEW CONTENT OF FILE\");\n \n-    private void setLogDecoration() throws IOException {\n-        executeOnGitRepo(\"git\", \"config\", \"log.decorate\", \"true\");\n-    }\n+            /* Simulate start of a new build on agent. */\n+            clonedCopy.fetch(outputStreamConsumer);\n+            clonedCopy.resetWorkingDir(outputStreamConsumer, new StringRevision(modifications.get(0).getRevision()), false);\n \n-    private void unsetLogDecoration() throws IOException {\n-        executeOnGitRepo(\"git\", \"config\", \"log.decorate\", \"off\");\n-    }\n+            assertEquals(\"NEW CONTENT OF FILE\", FileUtils.readFileToString(fileInSubmodule, UTF_8));\n+        }\n \n-    private void unsetColoring() {\n-        executeOnGitRepo(\"git\", \"config\", \"color.diff\", \"auto\");\n-        executeOnGitRepo(\"git\", \"config\", \"color.status\", \"auto\");\n-        executeOnGitRepo(\"git\", \"config\", \"color.interactive\", \"auto\");\n-        executeOnGitRepo(\"git\", \"config\", \"color.branch\", \"auto\");\n-    }\n+        @Test\n+        void shouldAllowSubmoduleUrlsToChange() throws Exception {\n+            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+            GitRepoContainingSubmodule submoduleRepos = new GitRepoContainingSubmodule(temporaryFolder);\n+            String submoduleDirectoryName = \"local-submodule\";\n+            File cloneDirectory = createTempWorkingDirectory();\n \n-    private void assertWorkingCopyNotCheckedOut() {\n-        assertThat(gitLocalRepoDir.listFiles()).isEqualTo(new File[]{new File(gitLocalRepoDir, \".git\")});\n-    }\n+            submoduleRepos.addSubmodule(SUBMODULE, submoduleDirectoryName);\n+\n+            GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+            clonedCopy.clone(outputStreamConsumer, submoduleRepos.mainRepo().urlForCommandLine());\n+            clonedCopy.fetchAndResetToHead(outputStreamConsumer, false);\n+\n+            submoduleRepos.changeSubmoduleUrl(submoduleDirectoryName);\n+\n+            clonedCopy.fetchAndResetToHead(outputStreamConsumer, false);\n+        }\n+\n+        @Test\n+        @EnabledOnGitVersions(from = \"2.10.0\")\n+        void shouldShallowCloneSubmodulesWhenSpecified() throws Exception {\n+            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+            GitRepoContainingSubmodule repoContainingSubmodule = new GitRepoContainingSubmodule(temporaryFolder);\n+            String submoduleDirectoryName = \"submoduleDir\";\n+            repoContainingSubmodule.addSubmodule(SUBMODULE, submoduleDirectoryName);\n+\n+            File cloneDirectory = createTempWorkingDirectory();\n+            GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+            clonedCopy.clone(outputStreamConsumer, FileUtil.toFileURI(repoContainingSubmodule.mainRepo().urlForCommandLine()), 1);\n+            clonedCopy.fetchAndResetToHead(outputStreamConsumer, true);\n+            ConsoleResult consoleResult = git_C(new File(cloneDirectory, submoduleDirectoryName),\n+                    \"rev-list\", \"--count\", \"master\");\n+            assertEquals(\"1\", consoleResult.outputAsString());\n+        }\n+\n+        @Test\n+        @EnabledOnGitVersions(from = \"2.10.0\", through = \"2.25.4\")\n+        void shouldUnshallowSubmodulesIfSubmoduleUpdateFails() throws Exception {\n+            InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+            GitRepoContainingSubmodule repoContainingSubmodule = new GitRepoContainingSubmodule(temporaryFolder);\n+            String submoduleDirectoryName = \"submoduleDir\";\n+            repoContainingSubmodule.addSubmodule(SUBMODULE, submoduleDirectoryName);\n+            repoContainingSubmodule.goBackOneCommitInSubmoduleAndUpdateMainRepo(submoduleDirectoryName);\n+\n+            File cloneDirectory = createTempWorkingDirectory();\n+            GitCommand clonedCopy = new GitCommand(null, cloneDirectory, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+            clonedCopy.clone(outputStreamConsumer, FileUtil.toFileURI(repoContainingSubmodule.mainRepo().urlForCommandLine()), 1);\n+            clonedCopy.fetchAndResetToHead(outputStreamConsumer, true);\n+            ConsoleResult consoleResult = git_C(new File(cloneDirectory, submoduleDirectoryName),\n+                    \"rev-list\", \"--count\", \"master\");\n+            assertEquals(\"2\", consoleResult.outputAsString());\n+        }\n+\n+        @Test\n+        void shouldCleanIgnoredFilesIfToggleIsDisabled() throws IOException {\n+            InMemoryStreamConsumer output = inMemoryConsumer();\n+            File gitIgnoreFile = new File(repoLocation, \".gitignore\");\n+            FileUtils.writeStringToFile(gitIgnoreFile, \"*.foo\", UTF_8);\n+            gitRepo.addFileAndPush(gitIgnoreFile, \"added gitignore\");\n+            git.fetchAndResetToHead(output, false);\n+\n+            File ignoredFile = new File(gitLocalRepoDir, \"ignored.foo\");\n+            assertTrue(ignoredFile.createNewFile());\n+            git.fetchAndResetToHead(output, false);\n+            assertFalse(ignoredFile.exists());\n+        }\n+\n+        @Test\n+        void shouldNotCleanIgnoredFilesIfToggleIsEnabled() throws IOException {\n+            System.setProperty(\"toggle.agent.git.clean.keep.ignored.files\", \"Y\");\n+            InMemoryStreamConsumer output = inMemoryConsumer();\n+            File gitIgnoreFile = new File(repoLocation, \".gitignore\");\n+            FileUtils.writeStringToFile(gitIgnoreFile, \"*.foo\", UTF_8);\n+            gitRepo.addFileAndPush(gitIgnoreFile, \"added gitignore\");\n+            git.fetchAndResetToHead(output, false);\n+\n+            File ignoredFile = new File(gitLocalRepoDir, \"ignored.foo\");\n+            assertTrue(ignoredFile.createNewFile());\n+            git.fetchAndResetToHead(output, false);\n+            assertTrue(ignoredFile.exists());\n+        }\n+\n+        @Test\n+        void shouldNotThrowExceptionWhenSubmoduleIsAddedWithACustomName() {\n+            git_C(gitLocalRepoDir, \"submodule\", \"add\", \"--name\", \"Custom\", gitFooBranchBundle.projectRepositoryUrl());\n+            git.fetchAndResetToHead(inMemoryConsumer(), false);\n+        }\n+\n+        private List<File> allFilesIn(File directory) {\n+            return new ArrayList<>(FileUtils.listFiles(directory, and(fileFileFilter(), prefixFileFilter(\"file-\")), null));\n+        }\n+\n+        private File createTempWorkingDirectory() throws IOException {\n+            return temporaryFolder.newFolder(\"GitCommandTest\" + System.currentTimeMillis(), \"repo\");\n+        }\n \n-    private void assertWorkingCopyCheckedOut(File workingDir) {\n-        assertThat(workingDir.listFiles().length).isGreaterThan(1);\n+        private File checkInNewRemoteFile() throws IOException {\n+            GitCommand remoteGit = new GitCommand(null, repoLocation, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+            File testingFile = new File(repoLocation, \"testing-file\" + System.currentTimeMillis() + \".txt\");\n+            //noinspection ResultOfMethodCallIgnored\n+            testingFile.createNewFile();\n+            remoteGit.add(testingFile);\n+            remoteGit.commit(\"New checkin of \" + testingFile.getName());\n+            return testingFile;\n+        }\n+\n+        private File checkInNewRemoteFileInFuture(Date checkinDate) throws IOException {\n+            GitCommand remoteGit = new GitCommand(null, repoLocation, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n+            File testingFile = new File(repoLocation, \"testing-file\" + System.currentTimeMillis() + \".txt\");\n+            //noinspection ResultOfMethodCallIgnored\n+            testingFile.createNewFile();\n+            remoteGit.add(testingFile);\n+            remoteGit.commitOnDate(\"New checkin of \" + testingFile.getName(), checkinDate);\n+            return testingFile;\n+        }\n+\n+        private void gitInRepo(String... args) {\n+            git_C(gitLocalRepoDir, args);\n+        }\n+\n+        /**\n+         * Like {@code git -C <dir> command [args...]}\n+         *\n+         * @param dir  the directory to set as CWD\n+         * @param args the args to pass to {@code git}\n+         * @return a {@link ConsoleResult}\n+         */\n+        private ConsoleResult git_C(File dir, String... args) {\n+            CommandLine commandLine = CommandLine.createCommandLine(\"git\");\n+            commandLine.withArgs(args);\n+            commandLine.withEncoding(\"utf-8\");\n+            assertTrue(dir.exists());\n+            commandLine.setWorkingDir(dir);\n+            return commandLine.runOrBomb(true, null);\n+        }\n+\n+        private void setColoring() {\n+            gitInRepo(\"config\", \"color.diff\", \"always\");\n+            gitInRepo(\"config\", \"color.status\", \"always\");\n+            gitInRepo(\"config\", \"color.interactive\", \"always\");\n+            gitInRepo(\"config\", \"color.branch\", \"always\");\n+        }\n+\n+        private void setLogDecoration() {\n+            gitInRepo(\"config\", \"log.decorate\", \"true\");\n+        }\n+\n+        private void unsetLogDecoration() {\n+            gitInRepo(\"config\", \"log.decorate\", \"off\");\n+        }\n+\n+        private void unsetColoring() {\n+            gitInRepo(\"config\", \"color.diff\", \"auto\");\n+            gitInRepo(\"config\", \"color.status\", \"auto\");\n+            gitInRepo(\"config\", \"color.interactive\", \"auto\");\n+            gitInRepo(\"config\", \"color.branch\", \"auto\");\n+        }\n+\n+        private void assertWorkingCopyNotCheckedOut() {\n+            assertArrayEquals(new File[]{new File(gitLocalRepoDir, \".git\")}, gitLocalRepoDir.listFiles());\n+        }\n+\n+        private void assertWorkingCopyCheckedOut(File workingDir) {\n+            assertTrue(requireNonNull(workingDir.listFiles()).length > 1);\n+        }\n     }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5NzQxNw==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438497417", "body": "Most of the changes here are IntelliJ IDEA cleanup; grouping non-public methods at the bottom and inlining some unchanging parameters.\r\n\r\nKeep scrolling for the main bits; I'll call out what the essence of this file's changes are.", "bodyText": "Most of the changes here are IntelliJ IDEA cleanup; grouping non-public methods at the bottom and inlining some unchanging parameters.\nKeep scrolling for the main bits; I'll call out what the essence of this file's changes are.", "bodyHTML": "<p dir=\"auto\">Most of the changes here are IntelliJ IDEA cleanup; grouping non-public methods at the bottom and inlining some unchanging parameters.</p>\n<p dir=\"auto\">Keep scrolling for the main bits; I'll call out what the essence of this file's changes are.</p>", "author": "marques-work", "createdAt": "2020-06-11T01:44:58Z", "path": "domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java", "diffHunk": "@@ -199,95 +185,6 @@ public ValidationBean handleException(Exception e, GitVersion gitVersion) {\n         }\n     }\n \n-    private GitCommand getGit(File workingdir, int preferredCloneDepth, SubprocessExecutionContext executionContext) {", "originalCommit": "1772ef1fcc5ea380496e95b826081fa0ebcfd23d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cbca50d98d98b15a6581214cafc0e42674c1fa74", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\nindex 41739352b7..f6c0875c7a 100644\n--- a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n+++ b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n", "chunk": "@@ -185,6 +199,95 @@ public class GitMaterial extends ScmMaterial implements PasswordAwareMaterial {\n         }\n     }\n \n+    private GitCommand getGit(File workingdir, int preferredCloneDepth, SubprocessExecutionContext executionContext) {\n+        InMemoryStreamConsumer output = inMemoryConsumer();\n+        try {\n+            return git(output, workingdir, preferredCloneDepth, executionContext);\n+        } catch (Exception e) {\n+            throw bomb(e.getMessage() + \" \" + output.getStdError(), e);\n+        }\n+    }\n+\n+    private GitCommand git(ConsoleOutputStreamConsumer outputStreamConsumer, final File workingFolder, int preferredCloneDepth, SubprocessExecutionContext executionContext) throws Exception {\n+        if (isSubmoduleFolder()) {\n+            return new GitCommand(getFingerprint(), new File(workingFolder.getPath()), GitMaterialConfig.DEFAULT_BRANCH, true, secrets());\n+        }\n+\n+        GitCommand gitCommand = new GitCommand(getFingerprint(), workingFolder, getBranch(), false, secrets());\n+        if (!isGitRepository(workingFolder) || isRepositoryChanged(gitCommand, workingFolder)) {\n+            LOG.debug(\"Invalid git working copy or repository changed. Delete folder: {}\", workingFolder);\n+            deleteDirectoryNoisily(workingFolder);\n+        }\n+        createParentFolderIfNotExist(workingFolder);\n+        if (!workingFolder.exists()) {\n+            TransactionSynchronizationManager txManager = new TransactionSynchronizationManager();\n+            if (txManager.isActualTransactionActive()) {\n+                txManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n+                    @Override\n+                    public void afterCompletion(int status) {\n+                        if (status != TransactionSynchronization.STATUS_COMMITTED) {\n+                            FileUtils.deleteQuietly(workingFolder);\n+                        }\n+                    }\n+                });\n+            }\n+            int cloneDepth = shallowClone ? preferredCloneDepth : Integer.MAX_VALUE;\n+            int returnValue;\n+            if (executionContext.isServer()) {\n+                returnValue = gitCommand.cloneWithNoCheckout(outputStreamConsumer, urlForCommandLine());\n+            } else {\n+                returnValue = gitCommand.clone(outputStreamConsumer, urlForCommandLine(), cloneDepth);\n+            }\n+            bombIfFailedToRunCommandLine(returnValue, \"Failed to run git clone command\");\n+        }\n+        return gitCommand;\n+    }\n+\n+    private List<SecretString> secrets() {\n+        SecretString secretSubstitution = line -> line.replace(urlForCommandLine(), getUriForDisplay());\n+        return Collections.singletonList(secretSubstitution);\n+    }\n+\n+    // Unshallow local repo to include a revision operating on via two step process:\n+    // First try to fetch forward 100 level with \"git fetch -depth 100\". If revision still missing,\n+    // unshallow the whole repo with \"git fetch --2147483647\".\n+    private void unshallowIfNeeded(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer, Revision revision, File workingDir) {\n+        if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n+            gitCommand.unshallow(streamConsumer, UNSHALLOW_TRYOUT_STEP);\n+\n+            if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n+                fullyUnshallow(gitCommand, streamConsumer);\n+            }\n+        }\n+    }\n+\n+    private void fullyUnshallow(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer) {\n+        if (gitCommand.isShallow()) {\n+            gitCommand.unshallow(streamConsumer, Integer.MAX_VALUE);\n+        }\n+    }\n+\n+    private boolean isSubmoduleFolder() {\n+        return getSubmoduleFolder() != null;\n+    }\n+\n+    private boolean isGitRepository(File workingFolder) {\n+        return new File(workingFolder, \".git\").isDirectory();\n+    }\n+\n+    private boolean isRepositoryChanged(GitCommand command, File workingDirectory) {\n+        UrlArgument currentWorkingUrl = command.workingRepositoryUrl();\n+        LOG.trace(\"Current repository url of [{}]: {}\", workingDirectory, currentWorkingUrl);\n+        LOG.trace(\"Target repository url: {}\", url);\n+        return !MaterialUrl.sameUrl(url.forDisplay(), currentWorkingUrl.forDisplay())\n+                || !isBranchEqual(command)\n+                || (!shallowClone && command.isShallow());\n+    }\n+\n+    private boolean isBranchEqual(GitCommand command) {\n+        return branchWithDefault().equals(command.getCurrentBranch());\n+    }\n+\n     /**\n      * @deprecated Breaks encapsulation really badly. But we need it for IBatis :-(\n      */\n", "next_change": {"commit": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\nindex f6c0875c7a..d2cc552c37 100644\n--- a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n+++ b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n", "chunk": "@@ -199,95 +185,6 @@ public class GitMaterial extends ScmMaterial implements PasswordAwareMaterial {\n         }\n     }\n \n-    private GitCommand getGit(File workingdir, int preferredCloneDepth, SubprocessExecutionContext executionContext) {\n-        InMemoryStreamConsumer output = inMemoryConsumer();\n-        try {\n-            return git(output, workingdir, preferredCloneDepth, executionContext);\n-        } catch (Exception e) {\n-            throw bomb(e.getMessage() + \" \" + output.getStdError(), e);\n-        }\n-    }\n-\n-    private GitCommand git(ConsoleOutputStreamConsumer outputStreamConsumer, final File workingFolder, int preferredCloneDepth, SubprocessExecutionContext executionContext) throws Exception {\n-        if (isSubmoduleFolder()) {\n-            return new GitCommand(getFingerprint(), new File(workingFolder.getPath()), GitMaterialConfig.DEFAULT_BRANCH, true, secrets());\n-        }\n-\n-        GitCommand gitCommand = new GitCommand(getFingerprint(), workingFolder, getBranch(), false, secrets());\n-        if (!isGitRepository(workingFolder) || isRepositoryChanged(gitCommand, workingFolder)) {\n-            LOG.debug(\"Invalid git working copy or repository changed. Delete folder: {}\", workingFolder);\n-            deleteDirectoryNoisily(workingFolder);\n-        }\n-        createParentFolderIfNotExist(workingFolder);\n-        if (!workingFolder.exists()) {\n-            TransactionSynchronizationManager txManager = new TransactionSynchronizationManager();\n-            if (txManager.isActualTransactionActive()) {\n-                txManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n-                    @Override\n-                    public void afterCompletion(int status) {\n-                        if (status != TransactionSynchronization.STATUS_COMMITTED) {\n-                            FileUtils.deleteQuietly(workingFolder);\n-                        }\n-                    }\n-                });\n-            }\n-            int cloneDepth = shallowClone ? preferredCloneDepth : Integer.MAX_VALUE;\n-            int returnValue;\n-            if (executionContext.isServer()) {\n-                returnValue = gitCommand.cloneWithNoCheckout(outputStreamConsumer, urlForCommandLine());\n-            } else {\n-                returnValue = gitCommand.clone(outputStreamConsumer, urlForCommandLine(), cloneDepth);\n-            }\n-            bombIfFailedToRunCommandLine(returnValue, \"Failed to run git clone command\");\n-        }\n-        return gitCommand;\n-    }\n-\n-    private List<SecretString> secrets() {\n-        SecretString secretSubstitution = line -> line.replace(urlForCommandLine(), getUriForDisplay());\n-        return Collections.singletonList(secretSubstitution);\n-    }\n-\n-    // Unshallow local repo to include a revision operating on via two step process:\n-    // First try to fetch forward 100 level with \"git fetch -depth 100\". If revision still missing,\n-    // unshallow the whole repo with \"git fetch --2147483647\".\n-    private void unshallowIfNeeded(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer, Revision revision, File workingDir) {\n-        if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n-            gitCommand.unshallow(streamConsumer, UNSHALLOW_TRYOUT_STEP);\n-\n-            if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n-                fullyUnshallow(gitCommand, streamConsumer);\n-            }\n-        }\n-    }\n-\n-    private void fullyUnshallow(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer) {\n-        if (gitCommand.isShallow()) {\n-            gitCommand.unshallow(streamConsumer, Integer.MAX_VALUE);\n-        }\n-    }\n-\n-    private boolean isSubmoduleFolder() {\n-        return getSubmoduleFolder() != null;\n-    }\n-\n-    private boolean isGitRepository(File workingFolder) {\n-        return new File(workingFolder, \".git\").isDirectory();\n-    }\n-\n-    private boolean isRepositoryChanged(GitCommand command, File workingDirectory) {\n-        UrlArgument currentWorkingUrl = command.workingRepositoryUrl();\n-        LOG.trace(\"Current repository url of [{}]: {}\", workingDirectory, currentWorkingUrl);\n-        LOG.trace(\"Target repository url: {}\", url);\n-        return !MaterialUrl.sameUrl(url.forDisplay(), currentWorkingUrl.forDisplay())\n-                || !isBranchEqual(command)\n-                || (!shallowClone && command.isShallow());\n-    }\n-\n-    private boolean isBranchEqual(GitCommand command) {\n-        return branchWithDefault().equals(command.getCurrentBranch());\n-    }\n-\n     /**\n      * @deprecated Breaks encapsulation really badly. But we need it for IBatis :-(\n      */\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5ODA0MA==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438498040", "body": "Renamed only the field so it's clear what it really points to and how it should be interpreted/treated. Did not rename the getter for fear of changing serialization or something.", "bodyText": "Renamed only the field so it's clear what it really points to and how it should be interpreted/treated. Did not rename the getter for fear of changing serialization or something.", "bodyHTML": "<p dir=\"auto\">Renamed only the field so it's clear what it really points to and how it should be interpreted/treated. Did not rename the getter for fear of changing serialization or something.</p>", "author": "marques-work", "createdAt": "2020-06-11T01:47:33Z", "path": "domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java", "diffHunk": "@@ -50,20 +51,18 @@\n import static org.apache.commons.lang3.StringUtils.isBlank;\n \n public class GitMaterial extends ScmMaterial implements PasswordAwareMaterial {\n-    private static final Logger LOG = LoggerFactory.getLogger(GitMaterial.class);\n     public static final int UNSHALLOW_TRYOUT_STEP = 100;\n     public static final int DEFAULT_SHALLOW_CLONE_DEPTH = 2;\n     public static final String GO_MATERIAL_BRANCH = \"GO_MATERIAL_BRANCH\";\n-\n-    private UrlArgument url;\n-    private String branch = GitMaterialConfig.DEFAULT_BRANCH;\n-    private boolean shallowClone = false;\n-    private String submoduleFolder;\n-\n     //TODO: use iBatis to set the type for us, and we can get rid of this field.\n     public static final String TYPE = \"GitMaterial\";\n-    private static final String ERR_GIT_NOT_FOUND = \"Failed to find 'git' on your PATH. Please ensure 'git' is executable by the Go Server and on the Go Agents where this material will be used.\";\n     public static final String ERR_GIT_OLD_VERSION = \"Please install Git-core 1.6 or above. \";\n+    private static final Logger LOG = LoggerFactory.getLogger(GitMaterial.class);\n+    private static final String ERR_GIT_NOT_FOUND = \"Failed to find 'git' on your PATH. Please ensure 'git' is executable by the Go Server and on the Go Agents where this material will be used.\";\n+    private final UrlArgument url;\n+    private String refSpecOrBranch = GitMaterialConfig.DEFAULT_BRANCH;", "originalCommit": "1772ef1fcc5ea380496e95b826081fa0ebcfd23d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cbca50d98d98b15a6581214cafc0e42674c1fa74", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\nindex 41739352b7..f6c0875c7a 100644\n--- a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n+++ b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n", "chunk": "@@ -51,18 +50,20 @@ import static org.apache.commons.lang3.StringUtils.isAllBlank;\n import static org.apache.commons.lang3.StringUtils.isBlank;\n \n public class GitMaterial extends ScmMaterial implements PasswordAwareMaterial {\n+    private static final Logger LOG = LoggerFactory.getLogger(GitMaterial.class);\n     public static final int UNSHALLOW_TRYOUT_STEP = 100;\n     public static final int DEFAULT_SHALLOW_CLONE_DEPTH = 2;\n     public static final String GO_MATERIAL_BRANCH = \"GO_MATERIAL_BRANCH\";\n+\n+    private UrlArgument url;\n+    private String branch = GitMaterialConfig.DEFAULT_BRANCH;\n+    private boolean shallowClone = false;\n+    private String submoduleFolder;\n+\n     //TODO: use iBatis to set the type for us, and we can get rid of this field.\n     public static final String TYPE = \"GitMaterial\";\n-    public static final String ERR_GIT_OLD_VERSION = \"Please install Git-core 1.6 or above. \";\n-    private static final Logger LOG = LoggerFactory.getLogger(GitMaterial.class);\n     private static final String ERR_GIT_NOT_FOUND = \"Failed to find 'git' on your PATH. Please ensure 'git' is executable by the Go Server and on the Go Agents where this material will be used.\";\n-    private final UrlArgument url;\n-    private String refSpecOrBranch = GitMaterialConfig.DEFAULT_BRANCH;\n-    private boolean shallowClone = false;\n-    private String submoduleFolder;\n+    public static final String ERR_GIT_OLD_VERSION = \"Please install Git-core 1.6 or above. \";\n \n     public GitMaterial(String url) {\n         super(TYPE, new GoCipher());\n", "next_change": {"commit": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\nindex f6c0875c7a..d2cc552c37 100644\n--- a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n+++ b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n", "chunk": "@@ -50,20 +51,18 @@ import static org.apache.commons.lang3.StringUtils.isAllBlank;\n import static org.apache.commons.lang3.StringUtils.isBlank;\n \n public class GitMaterial extends ScmMaterial implements PasswordAwareMaterial {\n-    private static final Logger LOG = LoggerFactory.getLogger(GitMaterial.class);\n     public static final int UNSHALLOW_TRYOUT_STEP = 100;\n     public static final int DEFAULT_SHALLOW_CLONE_DEPTH = 2;\n     public static final String GO_MATERIAL_BRANCH = \"GO_MATERIAL_BRANCH\";\n-\n-    private UrlArgument url;\n-    private String branch = GitMaterialConfig.DEFAULT_BRANCH;\n-    private boolean shallowClone = false;\n-    private String submoduleFolder;\n-\n     //TODO: use iBatis to set the type for us, and we can get rid of this field.\n     public static final String TYPE = \"GitMaterial\";\n-    private static final String ERR_GIT_NOT_FOUND = \"Failed to find 'git' on your PATH. Please ensure 'git' is executable by the Go Server and on the Go Agents where this material will be used.\";\n     public static final String ERR_GIT_OLD_VERSION = \"Please install Git-core 1.6 or above. \";\n+    private static final Logger LOG = LoggerFactory.getLogger(GitMaterial.class);\n+    private static final String ERR_GIT_NOT_FOUND = \"Failed to find 'git' on your PATH. Please ensure 'git' is executable by the Go Server and on the Go Agents where this material will be used.\";\n+    private final UrlArgument url;\n+    private String refSpecOrBranch = GitMaterialConfig.DEFAULT_BRANCH;\n+    private boolean shallowClone = false;\n+    private String submoduleFolder;\n \n     public GitMaterial(String url) {\n         super(TYPE, new GoCipher());\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5ODY5MQ==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438498691", "body": "One of the main bits changed here; it's important to return the local branch name and not the raw `refspec`. The comparison that references this expects this to be a real branch name.", "bodyText": "One of the main bits changed here; it's important to return the local branch name and not the raw refspec. The comparison that references this expects this to be a real branch name.", "bodyHTML": "<p dir=\"auto\">One of the main bits changed here; it's important to return the local branch name and not the raw <code>refspec</code>. The comparison that references this expects this to be a real branch name.</p>", "author": "marques-work", "createdAt": "2020-06-11T01:49:51Z", "path": "domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java", "diffHunk": "@@ -443,13 +314,136 @@ public GitMaterial withShallowClone(boolean value) {\n         return gitMaterial;\n     }\n \n-    public String branchWithDefault() {\n-        return isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n+    public String effectiveLocalBranch() {\n+        return localBranch(isBlank(refSpecOrBranch) ? GitMaterialConfig.DEFAULT_BRANCH : refSpecOrBranch);\n+    }", "originalCommit": "1772ef1fcc5ea380496e95b826081fa0ebcfd23d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cbca50d98d98b15a6581214cafc0e42674c1fa74", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\nindex 41739352b7..f6c0875c7a 100644\n--- a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n+++ b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n", "chunk": "@@ -314,136 +427,13 @@ public class GitMaterial extends ScmMaterial implements PasswordAwareMaterial {\n         return gitMaterial;\n     }\n \n-    public String effectiveLocalBranch() {\n-        return localBranch(isBlank(refSpecOrBranch) ? GitMaterialConfig.DEFAULT_BRANCH : refSpecOrBranch);\n-    }\n-\n-    @Override\n-    protected void appendCriteria(Map<String, Object> parameters) {\n-        parameters.put(ScmMaterialConfig.URL, url.originalArgument());\n-        parameters.put(\"branch\", refSpecOrBranch);\n-    }\n-\n-    @Override\n-    protected void appendAttributes(Map<String, Object> parameters) {\n-        parameters.put(\"url\", url);\n-        parameters.put(\"branch\", refSpecOrBranch);\n-        parameters.put(\"shallowClone\", shallowClone);\n-    }\n-\n-    @Override\n-    protected String getLocation() {\n-        return url.forDisplay();\n+    public String branchWithDefault() {\n+        return isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n     }\n \n     @Override\n     protected void setGoMaterialVariables(EnvironmentVariableContext environmentVariableContext) {\n         super.setGoMaterialVariables(environmentVariableContext);\n-        setVariableWithName(environmentVariableContext, effectiveLocalBranch(), GO_MATERIAL_BRANCH);\n-    }\n-\n-    private GitCommand getGit(File workingdir, SubprocessExecutionContext executionContext) {\n-        InMemoryStreamConsumer output = inMemoryConsumer();\n-        try {\n-            return git(output, workingdir, DEFAULT_SHALLOW_CLONE_DEPTH, executionContext);\n-        } catch (Exception e) {\n-            throw bomb(e.getMessage() + \" \" + output.getStdError(), e);\n-        }\n-    }\n-\n-    private GitCommand git(ConsoleOutputStreamConsumer outputStreamConsumer, final File workingFolder, int preferredCloneDepth, SubprocessExecutionContext executionContext) throws Exception {\n-        if (isSubmoduleFolder()) {\n-            return new GitCommand(getFingerprint(), new File(workingFolder.getPath()), GitMaterialConfig.DEFAULT_BRANCH, true, secrets());\n-        }\n-        System.out.printf(\"**** [%s] WorkingDir for %s: %s\\n\", executionContext.isServer() ? \"server\" : \"agent\", urlForCommandLine(), workingFolder.getPath());\n-        GitCommand gitCommand = new GitCommand(getFingerprint(), workingFolder, refSpecOrBranch, false, secrets());\n-        if (!isGitRepository(workingFolder) || isRepositoryChanged(gitCommand, workingFolder)) {\n-            LOG.debug(\"Invalid git working copy or repository changed. Delete folder: {}\", workingFolder);\n-            deleteDirectoryNoisily(workingFolder);\n-        }\n-        createParentFolderIfNotExist(workingFolder);\n-        if (!workingFolder.exists()) {\n-            TransactionSynchronizationManager txManager = new TransactionSynchronizationManager();\n-            if (txManager.isActualTransactionActive()) {\n-                txManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n-                    @Override\n-                    public void afterCompletion(int status) {\n-                        if (status != TransactionSynchronization.STATUS_COMMITTED) {\n-                            FileUtils.deleteQuietly(workingFolder);\n-                        }\n-                    }\n-                });\n-            }\n-            int cloneDepth = shallowClone ? preferredCloneDepth : Integer.MAX_VALUE;\n-            int returnValue;\n-            if (executionContext.isServer()) {\n-                returnValue = gitCommand.cloneWithNoCheckout(outputStreamConsumer, urlForCommandLine());\n-            } else {\n-                returnValue = gitCommand.clone(outputStreamConsumer, urlForCommandLine(), cloneDepth);\n-            }\n-            bombIfFailedToRunCommandLine(returnValue, \"Failed to run git clone command\");\n-        }\n-        return gitCommand;\n-    }\n-\n-    private List<SecretString> secrets() {\n-        SecretString secretSubstitution = line -> line.replace(urlForCommandLine(), getUriForDisplay());\n-        return Collections.singletonList(secretSubstitution);\n-    }\n-\n-    // Unshallow local repo to include a revision operating on via two step process:\n-    // First try to fetch forward 100 level with \"git fetch -depth 100\". If revision still missing,\n-    // unshallow the whole repo with \"git fetch --2147483647\".\n-    private void unshallowIfNeeded(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer, Revision revision) {\n-        if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n-            gitCommand.unshallow(streamConsumer, UNSHALLOW_TRYOUT_STEP);\n-\n-            if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n-                fullyUnshallow(gitCommand, streamConsumer);\n-            }\n-        }\n-    }\n-\n-    private void fullyUnshallow(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer) {\n-        if (gitCommand.isShallow()) {\n-            gitCommand.unshallow(streamConsumer, Integer.MAX_VALUE);\n-        }\n-    }\n-\n-    private boolean isSubmoduleFolder() {\n-        return getSubmoduleFolder() != null;\n-    }\n-\n-    private boolean isGitRepository(File workingFolder) {\n-        return new File(workingFolder, \".git\").isDirectory();\n-    }\n-\n-    private boolean isRepositoryChanged(GitCommand command, File workingDirectory) {\n-        UrlArgument currentWorkingUrl = command.workingRepositoryUrl();\n-        LOG.trace(\"Current repository url of [{}]: {}\", workingDirectory, currentWorkingUrl);\n-        LOG.trace(\"Target repository url: {}\", url);\n-        return !MaterialUrl.sameUrl(url.forDisplay(), currentWorkingUrl.forDisplay())\n-                || !isRemoteFetchConfigEqual(command)\n-                || !isBranchEqual(command)\n-                || (!shallowClone && command.isShallow());\n-    }\n-\n-    private boolean isRemoteFetchConfigEqual(GitCommand command) {\n-        if (command.hasRefSpec()) {\n-            try {\n-                return (\"+\" + command.expandRefSpec()).equals(command.getConfigValue(\"remote.origin.fetch\"));\n-            } catch (Throwable ignored) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private boolean isBranchEqual(GitCommand command) {\n-        return effectiveLocalBranch().equals(command.getCurrentBranch());\n-    }\n-\n-    private boolean credentialsAreNotProvided() {\n-        return isAllBlank(this.userName, this.getPassword());\n+        setVariableWithName(environmentVariableContext, branchWithDefault(), GO_MATERIAL_BRANCH);\n     }\n }\n", "next_change": {"commit": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\nindex f6c0875c7a..d2cc552c37 100644\n--- a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n+++ b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n", "chunk": "@@ -427,13 +314,136 @@ public class GitMaterial extends ScmMaterial implements PasswordAwareMaterial {\n         return gitMaterial;\n     }\n \n-    public String branchWithDefault() {\n-        return isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n+    public String effectiveLocalBranch() {\n+        return localBranch(isBlank(refSpecOrBranch) ? GitMaterialConfig.DEFAULT_BRANCH : refSpecOrBranch);\n+    }\n+\n+    @Override\n+    protected void appendCriteria(Map<String, Object> parameters) {\n+        parameters.put(ScmMaterialConfig.URL, url.originalArgument());\n+        parameters.put(\"branch\", refSpecOrBranch);\n+    }\n+\n+    @Override\n+    protected void appendAttributes(Map<String, Object> parameters) {\n+        parameters.put(\"url\", url);\n+        parameters.put(\"branch\", refSpecOrBranch);\n+        parameters.put(\"shallowClone\", shallowClone);\n+    }\n+\n+    @Override\n+    protected String getLocation() {\n+        return url.forDisplay();\n     }\n \n     @Override\n     protected void setGoMaterialVariables(EnvironmentVariableContext environmentVariableContext) {\n         super.setGoMaterialVariables(environmentVariableContext);\n-        setVariableWithName(environmentVariableContext, branchWithDefault(), GO_MATERIAL_BRANCH);\n+        setVariableWithName(environmentVariableContext, effectiveLocalBranch(), GO_MATERIAL_BRANCH);\n+    }\n+\n+    private GitCommand getGit(File workingdir, SubprocessExecutionContext executionContext) {\n+        InMemoryStreamConsumer output = inMemoryConsumer();\n+        try {\n+            return git(output, workingdir, DEFAULT_SHALLOW_CLONE_DEPTH, executionContext);\n+        } catch (Exception e) {\n+            throw bomb(e.getMessage() + \" \" + output.getStdError(), e);\n+        }\n+    }\n+\n+    private GitCommand git(ConsoleOutputStreamConsumer outputStreamConsumer, final File workingFolder, int preferredCloneDepth, SubprocessExecutionContext executionContext) throws Exception {\n+        if (isSubmoduleFolder()) {\n+            return new GitCommand(getFingerprint(), new File(workingFolder.getPath()), GitMaterialConfig.DEFAULT_BRANCH, true, secrets());\n+        }\n+        System.out.printf(\"**** [%s] WorkingDir for %s: %s\\n\", executionContext.isServer() ? \"server\" : \"agent\", urlForCommandLine(), workingFolder.getPath());\n+        GitCommand gitCommand = new GitCommand(getFingerprint(), workingFolder, refSpecOrBranch, false, secrets());\n+        if (!isGitRepository(workingFolder) || isRepositoryChanged(gitCommand, workingFolder)) {\n+            LOG.debug(\"Invalid git working copy or repository changed. Delete folder: {}\", workingFolder);\n+            deleteDirectoryNoisily(workingFolder);\n+        }\n+        createParentFolderIfNotExist(workingFolder);\n+        if (!workingFolder.exists()) {\n+            TransactionSynchronizationManager txManager = new TransactionSynchronizationManager();\n+            if (txManager.isActualTransactionActive()) {\n+                txManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n+                    @Override\n+                    public void afterCompletion(int status) {\n+                        if (status != TransactionSynchronization.STATUS_COMMITTED) {\n+                            FileUtils.deleteQuietly(workingFolder);\n+                        }\n+                    }\n+                });\n+            }\n+            int cloneDepth = shallowClone ? preferredCloneDepth : Integer.MAX_VALUE;\n+            int returnValue;\n+            if (executionContext.isServer()) {\n+                returnValue = gitCommand.cloneWithNoCheckout(outputStreamConsumer, urlForCommandLine());\n+            } else {\n+                returnValue = gitCommand.clone(outputStreamConsumer, urlForCommandLine(), cloneDepth);\n+            }\n+            bombIfFailedToRunCommandLine(returnValue, \"Failed to run git clone command\");\n+        }\n+        return gitCommand;\n+    }\n+\n+    private List<SecretString> secrets() {\n+        SecretString secretSubstitution = line -> line.replace(urlForCommandLine(), getUriForDisplay());\n+        return Collections.singletonList(secretSubstitution);\n+    }\n+\n+    // Unshallow local repo to include a revision operating on via two step process:\n+    // First try to fetch forward 100 level with \"git fetch -depth 100\". If revision still missing,\n+    // unshallow the whole repo with \"git fetch --2147483647\".\n+    private void unshallowIfNeeded(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer, Revision revision) {\n+        if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n+            gitCommand.unshallow(streamConsumer, UNSHALLOW_TRYOUT_STEP);\n+\n+            if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n+                fullyUnshallow(gitCommand, streamConsumer);\n+            }\n+        }\n+    }\n+\n+    private void fullyUnshallow(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer) {\n+        if (gitCommand.isShallow()) {\n+            gitCommand.unshallow(streamConsumer, Integer.MAX_VALUE);\n+        }\n+    }\n+\n+    private boolean isSubmoduleFolder() {\n+        return getSubmoduleFolder() != null;\n+    }\n+\n+    private boolean isGitRepository(File workingFolder) {\n+        return new File(workingFolder, \".git\").isDirectory();\n+    }\n+\n+    private boolean isRepositoryChanged(GitCommand command, File workingDirectory) {\n+        UrlArgument currentWorkingUrl = command.workingRepositoryUrl();\n+        LOG.trace(\"Current repository url of [{}]: {}\", workingDirectory, currentWorkingUrl);\n+        LOG.trace(\"Target repository url: {}\", url);\n+        return !MaterialUrl.sameUrl(url.forDisplay(), currentWorkingUrl.forDisplay())\n+                || !isRemoteFetchConfigEqual(command)\n+                || !isBranchEqual(command)\n+                || (!shallowClone && command.isShallow());\n+    }\n+\n+    private boolean isRemoteFetchConfigEqual(GitCommand command) {\n+        if (command.hasRefSpec()) {\n+            try {\n+                return (\"+\" + command.expandRefSpec()).equals(command.getConfigValue(\"remote.origin.fetch\"));\n+            } catch (Throwable ignored) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isBranchEqual(GitCommand command) {\n+        return effectiveLocalBranch().equals(command.getCurrentBranch());\n+    }\n+\n+    private boolean credentialsAreNotProvided() {\n+        return isAllBlank(this.userName, this.getPassword());\n     }\n }\n", "next_change": null}]}}]}}, {"oid": "15947872ae7ecd0e2db1ff30b861776551dc3cc8", "url": "https://github.com/gocd/gocd/commit/15947872ae7ecd0e2db1ff30b861776551dc3cc8", "message": "wip2", "committedDate": "2020-06-11T09:43:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxNDUzMA==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438714530", "body": "This is the last main bit (`isRemoteFetchConfigEqual()` \u261d\ud83c\udffc); essentially, we should verify that the fetch configuration is equivalent as well when testing `isRepositoryChanged()`.", "bodyText": "This is the last main bit (isRemoteFetchConfigEqual() \u261d\ud83c\udffc); essentially, we should verify that the fetch configuration is equivalent as well when testing isRepositoryChanged().", "bodyHTML": "<p dir=\"auto\">This is the last main bit (<code>isRemoteFetchConfigEqual()</code> \u261d\ud83c\udffc); essentially, we should verify that the fetch configuration is equivalent as well when testing <code>isRepositoryChanged()</code>.</p>", "author": "marques-work", "createdAt": "2020-06-11T11:21:04Z", "path": "domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java", "diffHunk": "@@ -443,13 +314,136 @@ public GitMaterial withShallowClone(boolean value) {\n         return gitMaterial;\n     }\n \n-    public String branchWithDefault() {\n-        return isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n+    public String effectiveLocalBranch() {\n+        return localBranch(isBlank(refSpecOrBranch) ? GitMaterialConfig.DEFAULT_BRANCH : refSpecOrBranch);\n+    }\n+\n+    @Override\n+    protected void appendCriteria(Map<String, Object> parameters) {\n+        parameters.put(ScmMaterialConfig.URL, url.originalArgument());\n+        parameters.put(\"branch\", refSpecOrBranch);\n+    }\n+\n+    @Override\n+    protected void appendAttributes(Map<String, Object> parameters) {\n+        parameters.put(\"url\", url);\n+        parameters.put(\"branch\", refSpecOrBranch);\n+        parameters.put(\"shallowClone\", shallowClone);\n+    }\n+\n+    @Override\n+    protected String getLocation() {\n+        return url.forDisplay();\n     }\n \n     @Override\n     protected void setGoMaterialVariables(EnvironmentVariableContext environmentVariableContext) {\n         super.setGoMaterialVariables(environmentVariableContext);\n-        setVariableWithName(environmentVariableContext, branchWithDefault(), GO_MATERIAL_BRANCH);\n+        setVariableWithName(environmentVariableContext, effectiveLocalBranch(), GO_MATERIAL_BRANCH);\n+    }\n+\n+    private GitCommand getGit(File workingdir, SubprocessExecutionContext executionContext) {\n+        InMemoryStreamConsumer output = inMemoryConsumer();\n+        try {\n+            return git(output, workingdir, DEFAULT_SHALLOW_CLONE_DEPTH, executionContext);\n+        } catch (Exception e) {\n+            throw bomb(e.getMessage() + \" \" + output.getStdError(), e);\n+        }\n+    }\n+\n+    private GitCommand git(ConsoleOutputStreamConsumer outputStreamConsumer, final File workingFolder, int preferredCloneDepth, SubprocessExecutionContext executionContext) throws Exception {\n+        if (isSubmoduleFolder()) {\n+            return new GitCommand(getFingerprint(), new File(workingFolder.getPath()), GitMaterialConfig.DEFAULT_BRANCH, true, secrets());\n+        }\n+        System.out.printf(\"**** [%s] WorkingDir for %s: %s\\n\", executionContext.isServer() ? \"server\" : \"agent\", urlForCommandLine(), workingFolder.getPath());\n+        GitCommand gitCommand = new GitCommand(getFingerprint(), workingFolder, refSpecOrBranch, false, secrets());\n+        if (!isGitRepository(workingFolder) || isRepositoryChanged(gitCommand, workingFolder)) {\n+            LOG.debug(\"Invalid git working copy or repository changed. Delete folder: {}\", workingFolder);\n+            deleteDirectoryNoisily(workingFolder);\n+        }\n+        createParentFolderIfNotExist(workingFolder);\n+        if (!workingFolder.exists()) {\n+            TransactionSynchronizationManager txManager = new TransactionSynchronizationManager();\n+            if (txManager.isActualTransactionActive()) {\n+                txManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n+                    @Override\n+                    public void afterCompletion(int status) {\n+                        if (status != TransactionSynchronization.STATUS_COMMITTED) {\n+                            FileUtils.deleteQuietly(workingFolder);\n+                        }\n+                    }\n+                });\n+            }\n+            int cloneDepth = shallowClone ? preferredCloneDepth : Integer.MAX_VALUE;\n+            int returnValue;\n+            if (executionContext.isServer()) {\n+                returnValue = gitCommand.cloneWithNoCheckout(outputStreamConsumer, urlForCommandLine());\n+            } else {\n+                returnValue = gitCommand.clone(outputStreamConsumer, urlForCommandLine(), cloneDepth);\n+            }\n+            bombIfFailedToRunCommandLine(returnValue, \"Failed to run git clone command\");\n+        }\n+        return gitCommand;\n+    }\n+\n+    private List<SecretString> secrets() {\n+        SecretString secretSubstitution = line -> line.replace(urlForCommandLine(), getUriForDisplay());\n+        return Collections.singletonList(secretSubstitution);\n+    }\n+\n+    // Unshallow local repo to include a revision operating on via two step process:\n+    // First try to fetch forward 100 level with \"git fetch -depth 100\". If revision still missing,\n+    // unshallow the whole repo with \"git fetch --2147483647\".\n+    private void unshallowIfNeeded(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer, Revision revision) {\n+        if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n+            gitCommand.unshallow(streamConsumer, UNSHALLOW_TRYOUT_STEP);\n+\n+            if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n+                fullyUnshallow(gitCommand, streamConsumer);\n+            }\n+        }\n+    }\n+\n+    private void fullyUnshallow(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer) {\n+        if (gitCommand.isShallow()) {\n+            gitCommand.unshallow(streamConsumer, Integer.MAX_VALUE);\n+        }\n+    }\n+\n+    private boolean isSubmoduleFolder() {\n+        return getSubmoduleFolder() != null;\n+    }\n+\n+    private boolean isGitRepository(File workingFolder) {\n+        return new File(workingFolder, \".git\").isDirectory();\n+    }\n+\n+    private boolean isRepositoryChanged(GitCommand command, File workingDirectory) {\n+        UrlArgument currentWorkingUrl = command.workingRepositoryUrl();\n+        LOG.trace(\"Current repository url of [{}]: {}\", workingDirectory, currentWorkingUrl);\n+        LOG.trace(\"Target repository url: {}\", url);\n+        return !MaterialUrl.sameUrl(url.forDisplay(), currentWorkingUrl.forDisplay())\n+                || !isRemoteFetchConfigEqual(command)\n+                || !isBranchEqual(command)\n+                || (!shallowClone && command.isShallow());\n+    }\n+\n+    private boolean isRemoteFetchConfigEqual(GitCommand command) {\n+        if (command.hasRefSpec()) {\n+            try {\n+                return (\"+\" + command.expandRefSpec()).equals(command.getConfigValue(\"remote.origin.fetch\"));\n+            } catch (Throwable ignored) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }", "originalCommit": "15947872ae7ecd0e2db1ff30b861776551dc3cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cbca50d98d98b15a6581214cafc0e42674c1fa74", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\nindex 41739352b7..f6c0875c7a 100644\n--- a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n+++ b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n", "chunk": "@@ -314,136 +427,13 @@ public class GitMaterial extends ScmMaterial implements PasswordAwareMaterial {\n         return gitMaterial;\n     }\n \n-    public String effectiveLocalBranch() {\n-        return localBranch(isBlank(refSpecOrBranch) ? GitMaterialConfig.DEFAULT_BRANCH : refSpecOrBranch);\n-    }\n-\n-    @Override\n-    protected void appendCriteria(Map<String, Object> parameters) {\n-        parameters.put(ScmMaterialConfig.URL, url.originalArgument());\n-        parameters.put(\"branch\", refSpecOrBranch);\n-    }\n-\n-    @Override\n-    protected void appendAttributes(Map<String, Object> parameters) {\n-        parameters.put(\"url\", url);\n-        parameters.put(\"branch\", refSpecOrBranch);\n-        parameters.put(\"shallowClone\", shallowClone);\n-    }\n-\n-    @Override\n-    protected String getLocation() {\n-        return url.forDisplay();\n+    public String branchWithDefault() {\n+        return isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n     }\n \n     @Override\n     protected void setGoMaterialVariables(EnvironmentVariableContext environmentVariableContext) {\n         super.setGoMaterialVariables(environmentVariableContext);\n-        setVariableWithName(environmentVariableContext, effectiveLocalBranch(), GO_MATERIAL_BRANCH);\n-    }\n-\n-    private GitCommand getGit(File workingdir, SubprocessExecutionContext executionContext) {\n-        InMemoryStreamConsumer output = inMemoryConsumer();\n-        try {\n-            return git(output, workingdir, DEFAULT_SHALLOW_CLONE_DEPTH, executionContext);\n-        } catch (Exception e) {\n-            throw bomb(e.getMessage() + \" \" + output.getStdError(), e);\n-        }\n-    }\n-\n-    private GitCommand git(ConsoleOutputStreamConsumer outputStreamConsumer, final File workingFolder, int preferredCloneDepth, SubprocessExecutionContext executionContext) throws Exception {\n-        if (isSubmoduleFolder()) {\n-            return new GitCommand(getFingerprint(), new File(workingFolder.getPath()), GitMaterialConfig.DEFAULT_BRANCH, true, secrets());\n-        }\n-        System.out.printf(\"**** [%s] WorkingDir for %s: %s\\n\", executionContext.isServer() ? \"server\" : \"agent\", urlForCommandLine(), workingFolder.getPath());\n-        GitCommand gitCommand = new GitCommand(getFingerprint(), workingFolder, refSpecOrBranch, false, secrets());\n-        if (!isGitRepository(workingFolder) || isRepositoryChanged(gitCommand, workingFolder)) {\n-            LOG.debug(\"Invalid git working copy or repository changed. Delete folder: {}\", workingFolder);\n-            deleteDirectoryNoisily(workingFolder);\n-        }\n-        createParentFolderIfNotExist(workingFolder);\n-        if (!workingFolder.exists()) {\n-            TransactionSynchronizationManager txManager = new TransactionSynchronizationManager();\n-            if (txManager.isActualTransactionActive()) {\n-                txManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n-                    @Override\n-                    public void afterCompletion(int status) {\n-                        if (status != TransactionSynchronization.STATUS_COMMITTED) {\n-                            FileUtils.deleteQuietly(workingFolder);\n-                        }\n-                    }\n-                });\n-            }\n-            int cloneDepth = shallowClone ? preferredCloneDepth : Integer.MAX_VALUE;\n-            int returnValue;\n-            if (executionContext.isServer()) {\n-                returnValue = gitCommand.cloneWithNoCheckout(outputStreamConsumer, urlForCommandLine());\n-            } else {\n-                returnValue = gitCommand.clone(outputStreamConsumer, urlForCommandLine(), cloneDepth);\n-            }\n-            bombIfFailedToRunCommandLine(returnValue, \"Failed to run git clone command\");\n-        }\n-        return gitCommand;\n-    }\n-\n-    private List<SecretString> secrets() {\n-        SecretString secretSubstitution = line -> line.replace(urlForCommandLine(), getUriForDisplay());\n-        return Collections.singletonList(secretSubstitution);\n-    }\n-\n-    // Unshallow local repo to include a revision operating on via two step process:\n-    // First try to fetch forward 100 level with \"git fetch -depth 100\". If revision still missing,\n-    // unshallow the whole repo with \"git fetch --2147483647\".\n-    private void unshallowIfNeeded(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer, Revision revision) {\n-        if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n-            gitCommand.unshallow(streamConsumer, UNSHALLOW_TRYOUT_STEP);\n-\n-            if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n-                fullyUnshallow(gitCommand, streamConsumer);\n-            }\n-        }\n-    }\n-\n-    private void fullyUnshallow(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer) {\n-        if (gitCommand.isShallow()) {\n-            gitCommand.unshallow(streamConsumer, Integer.MAX_VALUE);\n-        }\n-    }\n-\n-    private boolean isSubmoduleFolder() {\n-        return getSubmoduleFolder() != null;\n-    }\n-\n-    private boolean isGitRepository(File workingFolder) {\n-        return new File(workingFolder, \".git\").isDirectory();\n-    }\n-\n-    private boolean isRepositoryChanged(GitCommand command, File workingDirectory) {\n-        UrlArgument currentWorkingUrl = command.workingRepositoryUrl();\n-        LOG.trace(\"Current repository url of [{}]: {}\", workingDirectory, currentWorkingUrl);\n-        LOG.trace(\"Target repository url: {}\", url);\n-        return !MaterialUrl.sameUrl(url.forDisplay(), currentWorkingUrl.forDisplay())\n-                || !isRemoteFetchConfigEqual(command)\n-                || !isBranchEqual(command)\n-                || (!shallowClone && command.isShallow());\n-    }\n-\n-    private boolean isRemoteFetchConfigEqual(GitCommand command) {\n-        if (command.hasRefSpec()) {\n-            try {\n-                return (\"+\" + command.expandRefSpec()).equals(command.getConfigValue(\"remote.origin.fetch\"));\n-            } catch (Throwable ignored) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private boolean isBranchEqual(GitCommand command) {\n-        return effectiveLocalBranch().equals(command.getCurrentBranch());\n-    }\n-\n-    private boolean credentialsAreNotProvided() {\n-        return isAllBlank(this.userName, this.getPassword());\n+        setVariableWithName(environmentVariableContext, branchWithDefault(), GO_MATERIAL_BRANCH);\n     }\n }\n", "next_change": {"commit": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\nindex f6c0875c7a..d2cc552c37 100644\n--- a/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n+++ b/domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java\n", "chunk": "@@ -427,13 +314,136 @@ public class GitMaterial extends ScmMaterial implements PasswordAwareMaterial {\n         return gitMaterial;\n     }\n \n-    public String branchWithDefault() {\n-        return isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n+    public String effectiveLocalBranch() {\n+        return localBranch(isBlank(refSpecOrBranch) ? GitMaterialConfig.DEFAULT_BRANCH : refSpecOrBranch);\n+    }\n+\n+    @Override\n+    protected void appendCriteria(Map<String, Object> parameters) {\n+        parameters.put(ScmMaterialConfig.URL, url.originalArgument());\n+        parameters.put(\"branch\", refSpecOrBranch);\n+    }\n+\n+    @Override\n+    protected void appendAttributes(Map<String, Object> parameters) {\n+        parameters.put(\"url\", url);\n+        parameters.put(\"branch\", refSpecOrBranch);\n+        parameters.put(\"shallowClone\", shallowClone);\n+    }\n+\n+    @Override\n+    protected String getLocation() {\n+        return url.forDisplay();\n     }\n \n     @Override\n     protected void setGoMaterialVariables(EnvironmentVariableContext environmentVariableContext) {\n         super.setGoMaterialVariables(environmentVariableContext);\n-        setVariableWithName(environmentVariableContext, branchWithDefault(), GO_MATERIAL_BRANCH);\n+        setVariableWithName(environmentVariableContext, effectiveLocalBranch(), GO_MATERIAL_BRANCH);\n+    }\n+\n+    private GitCommand getGit(File workingdir, SubprocessExecutionContext executionContext) {\n+        InMemoryStreamConsumer output = inMemoryConsumer();\n+        try {\n+            return git(output, workingdir, DEFAULT_SHALLOW_CLONE_DEPTH, executionContext);\n+        } catch (Exception e) {\n+            throw bomb(e.getMessage() + \" \" + output.getStdError(), e);\n+        }\n+    }\n+\n+    private GitCommand git(ConsoleOutputStreamConsumer outputStreamConsumer, final File workingFolder, int preferredCloneDepth, SubprocessExecutionContext executionContext) throws Exception {\n+        if (isSubmoduleFolder()) {\n+            return new GitCommand(getFingerprint(), new File(workingFolder.getPath()), GitMaterialConfig.DEFAULT_BRANCH, true, secrets());\n+        }\n+        System.out.printf(\"**** [%s] WorkingDir for %s: %s\\n\", executionContext.isServer() ? \"server\" : \"agent\", urlForCommandLine(), workingFolder.getPath());\n+        GitCommand gitCommand = new GitCommand(getFingerprint(), workingFolder, refSpecOrBranch, false, secrets());\n+        if (!isGitRepository(workingFolder) || isRepositoryChanged(gitCommand, workingFolder)) {\n+            LOG.debug(\"Invalid git working copy or repository changed. Delete folder: {}\", workingFolder);\n+            deleteDirectoryNoisily(workingFolder);\n+        }\n+        createParentFolderIfNotExist(workingFolder);\n+        if (!workingFolder.exists()) {\n+            TransactionSynchronizationManager txManager = new TransactionSynchronizationManager();\n+            if (txManager.isActualTransactionActive()) {\n+                txManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n+                    @Override\n+                    public void afterCompletion(int status) {\n+                        if (status != TransactionSynchronization.STATUS_COMMITTED) {\n+                            FileUtils.deleteQuietly(workingFolder);\n+                        }\n+                    }\n+                });\n+            }\n+            int cloneDepth = shallowClone ? preferredCloneDepth : Integer.MAX_VALUE;\n+            int returnValue;\n+            if (executionContext.isServer()) {\n+                returnValue = gitCommand.cloneWithNoCheckout(outputStreamConsumer, urlForCommandLine());\n+            } else {\n+                returnValue = gitCommand.clone(outputStreamConsumer, urlForCommandLine(), cloneDepth);\n+            }\n+            bombIfFailedToRunCommandLine(returnValue, \"Failed to run git clone command\");\n+        }\n+        return gitCommand;\n+    }\n+\n+    private List<SecretString> secrets() {\n+        SecretString secretSubstitution = line -> line.replace(urlForCommandLine(), getUriForDisplay());\n+        return Collections.singletonList(secretSubstitution);\n+    }\n+\n+    // Unshallow local repo to include a revision operating on via two step process:\n+    // First try to fetch forward 100 level with \"git fetch -depth 100\". If revision still missing,\n+    // unshallow the whole repo with \"git fetch --2147483647\".\n+    private void unshallowIfNeeded(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer, Revision revision) {\n+        if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n+            gitCommand.unshallow(streamConsumer, UNSHALLOW_TRYOUT_STEP);\n+\n+            if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n+                fullyUnshallow(gitCommand, streamConsumer);\n+            }\n+        }\n+    }\n+\n+    private void fullyUnshallow(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer) {\n+        if (gitCommand.isShallow()) {\n+            gitCommand.unshallow(streamConsumer, Integer.MAX_VALUE);\n+        }\n+    }\n+\n+    private boolean isSubmoduleFolder() {\n+        return getSubmoduleFolder() != null;\n+    }\n+\n+    private boolean isGitRepository(File workingFolder) {\n+        return new File(workingFolder, \".git\").isDirectory();\n+    }\n+\n+    private boolean isRepositoryChanged(GitCommand command, File workingDirectory) {\n+        UrlArgument currentWorkingUrl = command.workingRepositoryUrl();\n+        LOG.trace(\"Current repository url of [{}]: {}\", workingDirectory, currentWorkingUrl);\n+        LOG.trace(\"Target repository url: {}\", url);\n+        return !MaterialUrl.sameUrl(url.forDisplay(), currentWorkingUrl.forDisplay())\n+                || !isRemoteFetchConfigEqual(command)\n+                || !isBranchEqual(command)\n+                || (!shallowClone && command.isShallow());\n+    }\n+\n+    private boolean isRemoteFetchConfigEqual(GitCommand command) {\n+        if (command.hasRefSpec()) {\n+            try {\n+                return (\"+\" + command.expandRefSpec()).equals(command.getConfigValue(\"remote.origin.fetch\"));\n+            } catch (Throwable ignored) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isBranchEqual(GitCommand command) {\n+        return effectiveLocalBranch().equals(command.getCurrentBranch());\n+    }\n+\n+    private boolean credentialsAreNotProvided() {\n+        return isAllBlank(this.userName, this.getPassword());\n     }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxNjAxOQ==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438716019", "body": "This is just some refactoring to get rid of `GitCommand#pull()`, which was a `@TestOnly` method. The rest is IDEA cleanup/method re-org. This is the only method I removed because I got too lazy to factor out the other `@TestOnly` methods. I also figured that effort is best saved for a separate PR.", "bodyText": "This is just some refactoring to get rid of GitCommand#pull(), which was a @TestOnly method. The rest is IDEA cleanup/method re-org. This is the only method I removed because I got too lazy to factor out the other @TestOnly methods. I also figured that effort is best saved for a separate PR.", "bodyHTML": "<p dir=\"auto\">This is just some refactoring to get rid of <code>GitCommand#pull()</code>, which was a <code>@TestOnly</code> method. The rest is IDEA cleanup/method re-org. This is the only method I removed because I got too lazy to factor out the other <code>@TestOnly</code> methods. I also figured that effort is best saved for a separate PR.</p>", "author": "marques-work", "createdAt": "2020-06-11T11:24:17Z", "path": "domain/src/test/java/com/thoughtworks/go/helper/GitRepoContainingSubmodule.java", "diffHunk": "@@ -131,7 +97,9 @@ public String projectRepositoryUrl() {\n         changeFile(remoteSubmoduleRepoLocation, fileName, newContentOfFile);\n         checkInOneFile(remoteSubmoduleRepoLocation, new File(fileName), comment);\n \n-        git(new File(remoteRepoDir, submoduleNameInRepo)).pull();\n+        CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"pull\").\n+                withWorkingDir(new File(remoteRepoDir, submoduleNameInRepo)).\n+                runOrBomb(new MaterialFingerprintTag(null));", "originalCommit": "15947872ae7ecd0e2db1ff30b861776551dc3cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cbca50d98d98b15a6581214cafc0e42674c1fa74", "changed_code": [{"header": "diff --git a/domain/src/test/java/com/thoughtworks/go/helper/GitRepoContainingSubmodule.java b/domain/src/test/java/com/thoughtworks/go/helper/GitRepoContainingSubmodule.java\nindex 787e76f476..c590f66c2f 100644\n--- a/domain/src/test/java/com/thoughtworks/go/helper/GitRepoContainingSubmodule.java\n+++ b/domain/src/test/java/com/thoughtworks/go/helper/GitRepoContainingSubmodule.java\n", "chunk": "@@ -97,9 +131,7 @@ public class GitRepoContainingSubmodule extends TestRepo {\n         changeFile(remoteSubmoduleRepoLocation, fileName, newContentOfFile);\n         checkInOneFile(remoteSubmoduleRepoLocation, new File(fileName), comment);\n \n-        CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"pull\").\n-                withWorkingDir(new File(remoteRepoDir, submoduleNameInRepo)).\n-                runOrBomb(new MaterialFingerprintTag(null));\n+        git(new File(remoteRepoDir, submoduleNameInRepo)).pull();\n         checkInOneFile(remoteRepoDir, new File(submoduleNameInRepo), comment);\n \n         return latestModification();\n", "next_change": {"commit": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "changed_code": [{"header": "diff --git a/domain/src/test/java/com/thoughtworks/go/helper/GitRepoContainingSubmodule.java b/domain/src/test/java/com/thoughtworks/go/helper/GitRepoContainingSubmodule.java\nindex c590f66c2f..787e76f476 100644\n--- a/domain/src/test/java/com/thoughtworks/go/helper/GitRepoContainingSubmodule.java\n+++ b/domain/src/test/java/com/thoughtworks/go/helper/GitRepoContainingSubmodule.java\n", "chunk": "@@ -131,7 +97,9 @@ public class GitRepoContainingSubmodule extends TestRepo {\n         changeFile(remoteSubmoduleRepoLocation, fileName, newContentOfFile);\n         checkInOneFile(remoteSubmoduleRepoLocation, new File(fileName), comment);\n \n-        git(new File(remoteRepoDir, submoduleNameInRepo)).pull();\n+        CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"pull\").\n+                withWorkingDir(new File(remoteRepoDir, submoduleNameInRepo)).\n+                runOrBomb(new MaterialFingerprintTag(null));\n         checkInOneFile(remoteRepoDir, new File(submoduleNameInRepo), comment);\n \n         return latestModification();\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxNzgwMw==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438717803", "body": "This and `clone()` are the main changes here (other parts are IDEA cleanup). Cloning to accommodate for refspecs is a multi-step process involving manually configuring fetch behavior and explicit branch creation and switching.", "bodyText": "This and clone() are the main changes here (other parts are IDEA cleanup). Cloning to accommodate for refspecs is a multi-step process involving manually configuring fetch behavior and explicit branch creation and switching.", "bodyHTML": "<p dir=\"auto\">This and <code>clone()</code> are the main changes here (other parts are IDEA cleanup). Cloning to accommodate for refspecs is a multi-step process involving manually configuring fetch behavior and explicit branch creation and switching.</p>", "author": "marques-work", "createdAt": "2020-06-11T11:28:13Z", "path": "domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java", "diffHunk": "@@ -56,95 +59,97 @@ public GitCommand(String materialFingerprint, File workingDir, String branch, bo\n         super(materialFingerprint);\n         this.workingDir = workingDir;\n         this.secrets = secrets != null ? secrets : new ArrayList<>();\n-        this.branch = StringUtils.isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n+        this.branch = StringUtils.defaultIfBlank(branch, GitMaterialConfig.DEFAULT_BRANCH);\n         this.isSubmodule = isSubmodule;\n     }\n \n-    public int cloneWithNoCheckout(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n-        CommandLine gitClone = cloneCommand().withArg(\"--no-checkout\");\n-\n-        gitClone.withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n+    private static boolean hasExactlyOneMatchingBranch(ConsoleResult branchList) {\n+        return branchList.output().size() == 1;\n+    }\n \n-        return run(gitClone, outputStreamConsumer);\n+    public String localBranch() {\n+        return RefSpecHelper.localBranch(branch);\n     }\n \n-    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n-        return clone(outputStreamConsumer, url, Integer.MAX_VALUE);\n+    public String remoteBranch() {\n+        return RefSpecHelper.remoteBranch(branch);\n     }\n \n-    // Clone repository from url with specified depth.\n-    // Special depth 2147483647 (Integer.MAX_VALUE) are treated as full clone\n-    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url, Integer depth) {\n-        CommandLine gitClone = cloneCommand();\n+    public String fullUpstreamRef() {\n+        return RefSpecHelper.fullUpstreamRef(branch);\n+    }\n \n-        if (depth < Integer.MAX_VALUE) {\n-            gitClone.withArg(String.format(\"--depth=%s\", depth));\n-        }\n-        gitClone.withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n+    public String expandRefSpec() {\n+        return RefSpecHelper.expandRefSpec(branch);\n+    }\n \n-        return run(gitClone, outputStreamConsumer);\n+    public boolean hasRefSpec() {\n+        return RefSpecHelper.hasRefSpec(branch);\n     }\n \n-    private CommandLine cloneCommand() {\n-        return git()\n-                .withArg(\"clone\")\n-                .withArg(String.format(\"--branch=%s\", branch));\n+    public String getConfigValue(String key) {\n+        return runOrBomb(git_C().withArgs(\"config\", \"--get-all\", key)).outputAsString();\n     }\n \n-    public List<Modification> latestModification() {\n-        return gitLog(\"-1\", \"--date=iso\", \"--no-decorate\", \"--pretty=medium\", \"--no-color\", remoteBranch());\n+    public int cloneWithNoCheckout(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n+        CommandLine gitClone = cloneCommand().\n+                when(!hasRefSpec(), git -> git.withArgs(\"--branch\", branch)).\n+                withArg(\"--no-checkout\").\n+                withArg(new UrlArgument(url)).\n+                withArg(workingDir.getAbsolutePath());\n+\n+        if (!hasRefSpec()) {\n+            return run(gitClone, outputStreamConsumer);\n+        }\n+\n+        final String abbrevBranch = localBranch();\n+        final String fullLocalRef = abbrevBranch.startsWith(\"refs/\") ? abbrevBranch : REFS_HEADS + abbrevBranch;\n \n+        return runCascade(outputStreamConsumer,\n+                gitClone,\n+                git_C().withArgs(\"config\", \"--replace-all\", \"remote.origin.fetch\", \"+\" + expandRefSpec()),\n+                git_C().withArgs(\"fetch\", \"--prune\", \"--recurse-submodules=no\"),\n+                // Important to create a \"real\" local branch and not just use `symbolic-ref`\n+                // to update HEAD in order to ensure that GitMaterial#isBranchEqual() passes;\n+                // failing this check will cause the working directory to be obliterated and we\n+                // will re-clone the given repository every time. Yikes!\n+                git_C().withArgs(\"branch\", \"-f\", abbrevBranch, remoteBranch()),\n+                git_C().withArgs(\"symbolic-ref\", \"HEAD\", fullLocalRef)\n+        );", "originalCommit": "15947872ae7ecd0e2db1ff30b861776551dc3cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cbca50d98d98b15a6581214cafc0e42674c1fa74", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java b/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\nindex 4fb05e8c4c..602628157e 100644\n--- a/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\n+++ b/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\n", "chunk": "@@ -59,97 +56,95 @@ public class GitCommand extends SCMCommand {\n         super(materialFingerprint);\n         this.workingDir = workingDir;\n         this.secrets = secrets != null ? secrets : new ArrayList<>();\n-        this.branch = StringUtils.defaultIfBlank(branch, GitMaterialConfig.DEFAULT_BRANCH);\n+        this.branch = StringUtils.isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n         this.isSubmodule = isSubmodule;\n     }\n \n-    private static boolean hasExactlyOneMatchingBranch(ConsoleResult branchList) {\n-        return branchList.output().size() == 1;\n-    }\n+    public int cloneWithNoCheckout(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n+        CommandLine gitClone = cloneCommand().withArg(\"--no-checkout\");\n \n-    public String localBranch() {\n-        return RefSpecHelper.localBranch(branch);\n-    }\n+        gitClone.withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n \n-    public String remoteBranch() {\n-        return RefSpecHelper.remoteBranch(branch);\n+        return run(gitClone, outputStreamConsumer);\n     }\n \n-    public String fullUpstreamRef() {\n-        return RefSpecHelper.fullUpstreamRef(branch);\n+    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n+        return clone(outputStreamConsumer, url, Integer.MAX_VALUE);\n     }\n \n-    public String expandRefSpec() {\n-        return RefSpecHelper.expandRefSpec(branch);\n-    }\n+    // Clone repository from url with specified depth.\n+    // Special depth 2147483647 (Integer.MAX_VALUE) are treated as full clone\n+    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url, Integer depth) {\n+        CommandLine gitClone = cloneCommand();\n \n-    public boolean hasRefSpec() {\n-        return RefSpecHelper.hasRefSpec(branch);\n-    }\n+        if (depth < Integer.MAX_VALUE) {\n+            gitClone.withArg(String.format(\"--depth=%s\", depth));\n+        }\n+        gitClone.withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n \n-    public String getConfigValue(String key) {\n-        return runOrBomb(git_C().withArgs(\"config\", \"--get-all\", key)).outputAsString();\n+        return run(gitClone, outputStreamConsumer);\n     }\n \n-    public int cloneWithNoCheckout(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n-        CommandLine gitClone = cloneCommand().\n-                when(!hasRefSpec(), git -> git.withArgs(\"--branch\", branch)).\n-                withArg(\"--no-checkout\").\n-                withArg(new UrlArgument(url)).\n-                withArg(workingDir.getAbsolutePath());\n-\n-        if (!hasRefSpec()) {\n-            return run(gitClone, outputStreamConsumer);\n-        }\n+    private CommandLine cloneCommand() {\n+        return git()\n+                .withArg(\"clone\")\n+                .withArg(String.format(\"--branch=%s\", branch));\n+    }\n \n-        final String abbrevBranch = localBranch();\n-        final String fullLocalRef = abbrevBranch.startsWith(\"refs/\") ? abbrevBranch : REFS_HEADS + abbrevBranch;\n+    public List<Modification> latestModification() {\n+        return gitLog(\"-1\", \"--date=iso\", \"--no-decorate\", \"--pretty=medium\", \"--no-color\", remoteBranch());\n \n-        return runCascade(outputStreamConsumer,\n-                gitClone,\n-                git_C().withArgs(\"config\", \"--replace-all\", \"remote.origin.fetch\", \"+\" + expandRefSpec()),\n-                git_C().withArgs(\"fetch\", \"--prune\", \"--recurse-submodules=no\"),\n-                // Important to create a \"real\" local branch and not just use `symbolic-ref`\n-                // to update HEAD in order to ensure that GitMaterial#isBranchEqual() passes;\n-                // failing this check will cause the working directory to be obliterated and we\n-                // will re-clone the given repository every time. Yikes!\n-                git_C().withArgs(\"branch\", \"-f\", abbrevBranch, remoteBranch()),\n-                git_C().withArgs(\"symbolic-ref\", \"HEAD\", fullLocalRef)\n-        );\n     }\n \n-    @TestOnly\n-    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n-        return clone(outputStreamConsumer, url, Integer.MAX_VALUE);\n+    public List<Modification> modificationsSince(Revision revision) {\n+        return gitLog(\"--date=iso\", \"--pretty=medium\", \"--no-decorate\", \"--no-color\", String.format(\"%s..%s\", revision.getRevision(), remoteBranch()));\n     }\n \n-    // Clone repository from url with specified depth.\n-    // Special depth 2147483647 (Integer.MAX_VALUE) are treated as full clone\n-    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url, Integer depth) {\n-        CommandLine gitClone = cloneCommand().\n-                when(!hasRefSpec(), git -> git.withArgs(\"--branch\", branch)).\n-                when(depth < Integer.MAX_VALUE, git -> git.withArg(format(\"--depth=%s\", depth))).\n-                withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n+    private List<Modification> gitLog(String... args) {\n+        // Git log will only show changes before the currently checked out revision\n+        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n \n-        if (!hasRefSpec()) {\n-            return run(gitClone, outputStreamConsumer);\n+        try {\n+            if (!isSubmodule) {\n+                fetch(outputStreamConsumer);\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(String.format(\"Working directory: %s\\n%s\", workingDir, outputStreamConsumer.getStdError()), e);\n         }\n \n-        return runCascade(outputStreamConsumer,\n-                gitClone,\n-                git_C().withArgs(\"config\", \"--replace-all\", \"remote.origin.fetch\", \"+\" + expandRefSpec()),\n-                git_C().withArgs(\"fetch\", \"--prune\", \"--recurse-submodules=no\"),\n-                git_C().withArgs(\"checkout\", \"-B\", localBranch(), remoteBranch())\n-        );\n+        CommandLine gitCmd = git().withArg(\"log\").withArgs(args).withWorkingDir(workingDir);\n+        ConsoleResult result = runOrBomb(gitCmd);\n+\n+        GitModificationParser parser = new GitModificationParser();\n+        List<Modification> mods = parser.parse(result.output());\n+        for (Modification mod : mods) {\n+            addModifiedFiles(mod);\n+        }\n+        return mods;\n     }\n \n-    public List<Modification> latestModification() {\n-        return gitLog(\"-1\", \"--date=iso\", \"--no-decorate\", \"--pretty=medium\", \"--no-color\", remoteBranch());\n+    private void addModifiedFiles(Modification mod) {\n+        ConsoleResult consoleResult = diffTree(mod.getRevision());\n+        List<String> result = consoleResult.output();\n \n+        for (String resultLine : result) {\n+            // First line is the node\n+            if (resultLine.equals(mod.getRevision())) {\n+                continue;\n+            }\n+\n+            Matcher m = matchResultLine(resultLine);\n+            if (!m.find()) {\n+                bomb(\"Unable to parse git-diff-tree output line: \" + consoleResult.replaceSecretInfo(resultLine) + \"\\n\"\n+                        + \"From output:\\n\"\n+                        + consoleResult.outputForDisplayAsString());\n+            }\n+            mod.createModifiedFile(m.group(2), null, parseGitAction(m.group(1).charAt(0)));\n+        }\n     }\n \n-    public List<Modification> modificationsSince(Revision revision) {\n-        return gitLog(\"--date=iso\", \"--pretty=medium\", \"--no-decorate\", \"--no-color\", format(\"%s..%s\", revision.getRevision(), remoteBranch()));\n+    private Matcher matchResultLine(String resultLine) {\n+        return GIT_DIFF_TREE_PATTERN.matcher(resultLine);\n     }\n \n     public void resetWorkingDir(ConsoleOutputStreamConsumer outputStreamConsumer, Revision revision, boolean shallow) {\n", "next_change": {"commit": "5e4c66a1db6f3945bc55fb850e5c6ff10cbaf6d8", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java b/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\nindex 602628157e..dda537d690 100644\n--- a/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\n+++ b/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\n", "chunk": "@@ -100,53 +98,6 @@ public class GitCommand extends SCMCommand {\n         return gitLog(\"--date=iso\", \"--pretty=medium\", \"--no-decorate\", \"--no-color\", String.format(\"%s..%s\", revision.getRevision(), remoteBranch()));\n     }\n \n-    private List<Modification> gitLog(String... args) {\n-        // Git log will only show changes before the currently checked out revision\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-\n-        try {\n-            if (!isSubmodule) {\n-                fetch(outputStreamConsumer);\n-            }\n-        } catch (Exception e) {\n-            throw new RuntimeException(String.format(\"Working directory: %s\\n%s\", workingDir, outputStreamConsumer.getStdError()), e);\n-        }\n-\n-        CommandLine gitCmd = git().withArg(\"log\").withArgs(args).withWorkingDir(workingDir);\n-        ConsoleResult result = runOrBomb(gitCmd);\n-\n-        GitModificationParser parser = new GitModificationParser();\n-        List<Modification> mods = parser.parse(result.output());\n-        for (Modification mod : mods) {\n-            addModifiedFiles(mod);\n-        }\n-        return mods;\n-    }\n-\n-    private void addModifiedFiles(Modification mod) {\n-        ConsoleResult consoleResult = diffTree(mod.getRevision());\n-        List<String> result = consoleResult.output();\n-\n-        for (String resultLine : result) {\n-            // First line is the node\n-            if (resultLine.equals(mod.getRevision())) {\n-                continue;\n-            }\n-\n-            Matcher m = matchResultLine(resultLine);\n-            if (!m.find()) {\n-                bomb(\"Unable to parse git-diff-tree output line: \" + consoleResult.replaceSecretInfo(resultLine) + \"\\n\"\n-                        + \"From output:\\n\"\n-                        + consoleResult.outputForDisplayAsString());\n-            }\n-            mod.createModifiedFile(m.group(2), null, parseGitAction(m.group(1).charAt(0)));\n-        }\n-    }\n-\n-    private Matcher matchResultLine(String resultLine) {\n-        return GIT_DIFF_TREE_PATTERN.matcher(resultLine);\n-    }\n-\n     public void resetWorkingDir(ConsoleOutputStreamConsumer outputStreamConsumer, Revision revision, boolean shallow) {\n         log(outputStreamConsumer, \"Reset working directory %s\", workingDir);\n         cleanAllUnversionedFiles(outputStreamConsumer);\n", "next_change": {"commit": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java b/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\nindex dda537d690..b16ceb4823 100644\n--- a/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\n+++ b/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\n", "chunk": "@@ -95,7 +150,7 @@ public class GitCommand extends SCMCommand {\n     }\n \n     public List<Modification> modificationsSince(Revision revision) {\n-        return gitLog(\"--date=iso\", \"--pretty=medium\", \"--no-decorate\", \"--no-color\", String.format(\"%s..%s\", revision.getRevision(), remoteBranch()));\n+        return gitLog(\"--date=iso\", \"--pretty=medium\", \"--no-decorate\", \"--no-color\", format(\"%s..%s\", revision.getRevision(), remoteBranch()));\n     }\n \n     public void resetWorkingDir(ConsoleOutputStreamConsumer outputStreamConsumer, Revision revision, boolean shallow) {\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxNzkzMQ==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438717931", "body": "Main changes in `clone()`", "bodyText": "Main changes in clone()", "bodyHTML": "<p dir=\"auto\">Main changes in <code>clone()</code></p>", "author": "marques-work", "createdAt": "2020-06-11T11:28:35Z", "path": "domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java", "diffHunk": "@@ -56,95 +59,97 @@ public GitCommand(String materialFingerprint, File workingDir, String branch, bo\n         super(materialFingerprint);\n         this.workingDir = workingDir;\n         this.secrets = secrets != null ? secrets : new ArrayList<>();\n-        this.branch = StringUtils.isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n+        this.branch = StringUtils.defaultIfBlank(branch, GitMaterialConfig.DEFAULT_BRANCH);\n         this.isSubmodule = isSubmodule;\n     }\n \n-    public int cloneWithNoCheckout(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n-        CommandLine gitClone = cloneCommand().withArg(\"--no-checkout\");\n-\n-        gitClone.withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n+    private static boolean hasExactlyOneMatchingBranch(ConsoleResult branchList) {\n+        return branchList.output().size() == 1;\n+    }\n \n-        return run(gitClone, outputStreamConsumer);\n+    public String localBranch() {\n+        return RefSpecHelper.localBranch(branch);\n     }\n \n-    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n-        return clone(outputStreamConsumer, url, Integer.MAX_VALUE);\n+    public String remoteBranch() {\n+        return RefSpecHelper.remoteBranch(branch);\n     }\n \n-    // Clone repository from url with specified depth.\n-    // Special depth 2147483647 (Integer.MAX_VALUE) are treated as full clone\n-    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url, Integer depth) {\n-        CommandLine gitClone = cloneCommand();\n+    public String fullUpstreamRef() {\n+        return RefSpecHelper.fullUpstreamRef(branch);\n+    }\n \n-        if (depth < Integer.MAX_VALUE) {\n-            gitClone.withArg(String.format(\"--depth=%s\", depth));\n-        }\n-        gitClone.withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n+    public String expandRefSpec() {\n+        return RefSpecHelper.expandRefSpec(branch);\n+    }\n \n-        return run(gitClone, outputStreamConsumer);\n+    public boolean hasRefSpec() {\n+        return RefSpecHelper.hasRefSpec(branch);\n     }\n \n-    private CommandLine cloneCommand() {\n-        return git()\n-                .withArg(\"clone\")\n-                .withArg(String.format(\"--branch=%s\", branch));\n+    public String getConfigValue(String key) {\n+        return runOrBomb(git_C().withArgs(\"config\", \"--get-all\", key)).outputAsString();\n     }\n \n-    public List<Modification> latestModification() {\n-        return gitLog(\"-1\", \"--date=iso\", \"--no-decorate\", \"--pretty=medium\", \"--no-color\", remoteBranch());\n+    public int cloneWithNoCheckout(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n+        CommandLine gitClone = cloneCommand().\n+                when(!hasRefSpec(), git -> git.withArgs(\"--branch\", branch)).\n+                withArg(\"--no-checkout\").\n+                withArg(new UrlArgument(url)).\n+                withArg(workingDir.getAbsolutePath());\n+\n+        if (!hasRefSpec()) {\n+            return run(gitClone, outputStreamConsumer);\n+        }\n+\n+        final String abbrevBranch = localBranch();\n+        final String fullLocalRef = abbrevBranch.startsWith(\"refs/\") ? abbrevBranch : REFS_HEADS + abbrevBranch;\n \n+        return runCascade(outputStreamConsumer,\n+                gitClone,\n+                git_C().withArgs(\"config\", \"--replace-all\", \"remote.origin.fetch\", \"+\" + expandRefSpec()),\n+                git_C().withArgs(\"fetch\", \"--prune\", \"--recurse-submodules=no\"),\n+                // Important to create a \"real\" local branch and not just use `symbolic-ref`\n+                // to update HEAD in order to ensure that GitMaterial#isBranchEqual() passes;\n+                // failing this check will cause the working directory to be obliterated and we\n+                // will re-clone the given repository every time. Yikes!\n+                git_C().withArgs(\"branch\", \"-f\", abbrevBranch, remoteBranch()),\n+                git_C().withArgs(\"symbolic-ref\", \"HEAD\", fullLocalRef)\n+        );\n     }\n \n-    public List<Modification> modificationsSince(Revision revision) {\n-        return gitLog(\"--date=iso\", \"--pretty=medium\", \"--no-decorate\", \"--no-color\", String.format(\"%s..%s\", revision.getRevision(), remoteBranch()));\n+    @TestOnly\n+    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n+        return clone(outputStreamConsumer, url, Integer.MAX_VALUE);\n     }\n \n-    private List<Modification> gitLog(String... args) {\n-        // Git log will only show changes before the currently checked out revision\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+    // Clone repository from url with specified depth.\n+    // Special depth 2147483647 (Integer.MAX_VALUE) are treated as full clone\n+    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url, Integer depth) {\n+        CommandLine gitClone = cloneCommand().\n+                when(!hasRefSpec(), git -> git.withArgs(\"--branch\", branch)).\n+                when(depth < Integer.MAX_VALUE, git -> git.withArg(format(\"--depth=%s\", depth))).\n+                withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n \n-        try {\n-            if (!isSubmodule) {\n-                fetch(outputStreamConsumer);\n-            }\n-        } catch (Exception e) {\n-            throw new RuntimeException(String.format(\"Working directory: %s\\n%s\", workingDir, outputStreamConsumer.getStdError()), e);\n+        if (!hasRefSpec()) {\n+            return run(gitClone, outputStreamConsumer);\n         }\n \n-        CommandLine gitCmd = git().withArg(\"log\").withArgs(args).withWorkingDir(workingDir);\n-        ConsoleResult result = runOrBomb(gitCmd);\n-\n-        GitModificationParser parser = new GitModificationParser();\n-        List<Modification> mods = parser.parse(result.output());\n-        for (Modification mod : mods) {\n-            addModifiedFiles(mod);\n-        }\n-        return mods;\n+        return runCascade(outputStreamConsumer,\n+                gitClone,\n+                git_C().withArgs(\"config\", \"--replace-all\", \"remote.origin.fetch\", \"+\" + expandRefSpec()),\n+                git_C().withArgs(\"fetch\", \"--prune\", \"--recurse-submodules=no\"),\n+                git_C().withArgs(\"checkout\", \"-B\", localBranch(), remoteBranch())\n+        );", "originalCommit": "15947872ae7ecd0e2db1ff30b861776551dc3cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cbca50d98d98b15a6581214cafc0e42674c1fa74", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java b/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\nindex 4fb05e8c4c..602628157e 100644\n--- a/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\n+++ b/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\n", "chunk": "@@ -59,97 +56,95 @@ public class GitCommand extends SCMCommand {\n         super(materialFingerprint);\n         this.workingDir = workingDir;\n         this.secrets = secrets != null ? secrets : new ArrayList<>();\n-        this.branch = StringUtils.defaultIfBlank(branch, GitMaterialConfig.DEFAULT_BRANCH);\n+        this.branch = StringUtils.isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n         this.isSubmodule = isSubmodule;\n     }\n \n-    private static boolean hasExactlyOneMatchingBranch(ConsoleResult branchList) {\n-        return branchList.output().size() == 1;\n-    }\n+    public int cloneWithNoCheckout(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n+        CommandLine gitClone = cloneCommand().withArg(\"--no-checkout\");\n \n-    public String localBranch() {\n-        return RefSpecHelper.localBranch(branch);\n-    }\n+        gitClone.withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n \n-    public String remoteBranch() {\n-        return RefSpecHelper.remoteBranch(branch);\n+        return run(gitClone, outputStreamConsumer);\n     }\n \n-    public String fullUpstreamRef() {\n-        return RefSpecHelper.fullUpstreamRef(branch);\n+    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n+        return clone(outputStreamConsumer, url, Integer.MAX_VALUE);\n     }\n \n-    public String expandRefSpec() {\n-        return RefSpecHelper.expandRefSpec(branch);\n-    }\n+    // Clone repository from url with specified depth.\n+    // Special depth 2147483647 (Integer.MAX_VALUE) are treated as full clone\n+    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url, Integer depth) {\n+        CommandLine gitClone = cloneCommand();\n \n-    public boolean hasRefSpec() {\n-        return RefSpecHelper.hasRefSpec(branch);\n-    }\n+        if (depth < Integer.MAX_VALUE) {\n+            gitClone.withArg(String.format(\"--depth=%s\", depth));\n+        }\n+        gitClone.withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n \n-    public String getConfigValue(String key) {\n-        return runOrBomb(git_C().withArgs(\"config\", \"--get-all\", key)).outputAsString();\n+        return run(gitClone, outputStreamConsumer);\n     }\n \n-    public int cloneWithNoCheckout(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n-        CommandLine gitClone = cloneCommand().\n-                when(!hasRefSpec(), git -> git.withArgs(\"--branch\", branch)).\n-                withArg(\"--no-checkout\").\n-                withArg(new UrlArgument(url)).\n-                withArg(workingDir.getAbsolutePath());\n-\n-        if (!hasRefSpec()) {\n-            return run(gitClone, outputStreamConsumer);\n-        }\n+    private CommandLine cloneCommand() {\n+        return git()\n+                .withArg(\"clone\")\n+                .withArg(String.format(\"--branch=%s\", branch));\n+    }\n \n-        final String abbrevBranch = localBranch();\n-        final String fullLocalRef = abbrevBranch.startsWith(\"refs/\") ? abbrevBranch : REFS_HEADS + abbrevBranch;\n+    public List<Modification> latestModification() {\n+        return gitLog(\"-1\", \"--date=iso\", \"--no-decorate\", \"--pretty=medium\", \"--no-color\", remoteBranch());\n \n-        return runCascade(outputStreamConsumer,\n-                gitClone,\n-                git_C().withArgs(\"config\", \"--replace-all\", \"remote.origin.fetch\", \"+\" + expandRefSpec()),\n-                git_C().withArgs(\"fetch\", \"--prune\", \"--recurse-submodules=no\"),\n-                // Important to create a \"real\" local branch and not just use `symbolic-ref`\n-                // to update HEAD in order to ensure that GitMaterial#isBranchEqual() passes;\n-                // failing this check will cause the working directory to be obliterated and we\n-                // will re-clone the given repository every time. Yikes!\n-                git_C().withArgs(\"branch\", \"-f\", abbrevBranch, remoteBranch()),\n-                git_C().withArgs(\"symbolic-ref\", \"HEAD\", fullLocalRef)\n-        );\n     }\n \n-    @TestOnly\n-    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n-        return clone(outputStreamConsumer, url, Integer.MAX_VALUE);\n+    public List<Modification> modificationsSince(Revision revision) {\n+        return gitLog(\"--date=iso\", \"--pretty=medium\", \"--no-decorate\", \"--no-color\", String.format(\"%s..%s\", revision.getRevision(), remoteBranch()));\n     }\n \n-    // Clone repository from url with specified depth.\n-    // Special depth 2147483647 (Integer.MAX_VALUE) are treated as full clone\n-    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url, Integer depth) {\n-        CommandLine gitClone = cloneCommand().\n-                when(!hasRefSpec(), git -> git.withArgs(\"--branch\", branch)).\n-                when(depth < Integer.MAX_VALUE, git -> git.withArg(format(\"--depth=%s\", depth))).\n-                withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n+    private List<Modification> gitLog(String... args) {\n+        // Git log will only show changes before the currently checked out revision\n+        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n \n-        if (!hasRefSpec()) {\n-            return run(gitClone, outputStreamConsumer);\n+        try {\n+            if (!isSubmodule) {\n+                fetch(outputStreamConsumer);\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(String.format(\"Working directory: %s\\n%s\", workingDir, outputStreamConsumer.getStdError()), e);\n         }\n \n-        return runCascade(outputStreamConsumer,\n-                gitClone,\n-                git_C().withArgs(\"config\", \"--replace-all\", \"remote.origin.fetch\", \"+\" + expandRefSpec()),\n-                git_C().withArgs(\"fetch\", \"--prune\", \"--recurse-submodules=no\"),\n-                git_C().withArgs(\"checkout\", \"-B\", localBranch(), remoteBranch())\n-        );\n+        CommandLine gitCmd = git().withArg(\"log\").withArgs(args).withWorkingDir(workingDir);\n+        ConsoleResult result = runOrBomb(gitCmd);\n+\n+        GitModificationParser parser = new GitModificationParser();\n+        List<Modification> mods = parser.parse(result.output());\n+        for (Modification mod : mods) {\n+            addModifiedFiles(mod);\n+        }\n+        return mods;\n     }\n \n-    public List<Modification> latestModification() {\n-        return gitLog(\"-1\", \"--date=iso\", \"--no-decorate\", \"--pretty=medium\", \"--no-color\", remoteBranch());\n+    private void addModifiedFiles(Modification mod) {\n+        ConsoleResult consoleResult = diffTree(mod.getRevision());\n+        List<String> result = consoleResult.output();\n \n+        for (String resultLine : result) {\n+            // First line is the node\n+            if (resultLine.equals(mod.getRevision())) {\n+                continue;\n+            }\n+\n+            Matcher m = matchResultLine(resultLine);\n+            if (!m.find()) {\n+                bomb(\"Unable to parse git-diff-tree output line: \" + consoleResult.replaceSecretInfo(resultLine) + \"\\n\"\n+                        + \"From output:\\n\"\n+                        + consoleResult.outputForDisplayAsString());\n+            }\n+            mod.createModifiedFile(m.group(2), null, parseGitAction(m.group(1).charAt(0)));\n+        }\n     }\n \n-    public List<Modification> modificationsSince(Revision revision) {\n-        return gitLog(\"--date=iso\", \"--pretty=medium\", \"--no-decorate\", \"--no-color\", format(\"%s..%s\", revision.getRevision(), remoteBranch()));\n+    private Matcher matchResultLine(String resultLine) {\n+        return GIT_DIFF_TREE_PATTERN.matcher(resultLine);\n     }\n \n     public void resetWorkingDir(ConsoleOutputStreamConsumer outputStreamConsumer, Revision revision, boolean shallow) {\n", "next_change": {"commit": "5e4c66a1db6f3945bc55fb850e5c6ff10cbaf6d8", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java b/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\nindex 602628157e..dda537d690 100644\n--- a/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\n+++ b/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\n", "chunk": "@@ -100,53 +98,6 @@ public class GitCommand extends SCMCommand {\n         return gitLog(\"--date=iso\", \"--pretty=medium\", \"--no-decorate\", \"--no-color\", String.format(\"%s..%s\", revision.getRevision(), remoteBranch()));\n     }\n \n-    private List<Modification> gitLog(String... args) {\n-        // Git log will only show changes before the currently checked out revision\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-\n-        try {\n-            if (!isSubmodule) {\n-                fetch(outputStreamConsumer);\n-            }\n-        } catch (Exception e) {\n-            throw new RuntimeException(String.format(\"Working directory: %s\\n%s\", workingDir, outputStreamConsumer.getStdError()), e);\n-        }\n-\n-        CommandLine gitCmd = git().withArg(\"log\").withArgs(args).withWorkingDir(workingDir);\n-        ConsoleResult result = runOrBomb(gitCmd);\n-\n-        GitModificationParser parser = new GitModificationParser();\n-        List<Modification> mods = parser.parse(result.output());\n-        for (Modification mod : mods) {\n-            addModifiedFiles(mod);\n-        }\n-        return mods;\n-    }\n-\n-    private void addModifiedFiles(Modification mod) {\n-        ConsoleResult consoleResult = diffTree(mod.getRevision());\n-        List<String> result = consoleResult.output();\n-\n-        for (String resultLine : result) {\n-            // First line is the node\n-            if (resultLine.equals(mod.getRevision())) {\n-                continue;\n-            }\n-\n-            Matcher m = matchResultLine(resultLine);\n-            if (!m.find()) {\n-                bomb(\"Unable to parse git-diff-tree output line: \" + consoleResult.replaceSecretInfo(resultLine) + \"\\n\"\n-                        + \"From output:\\n\"\n-                        + consoleResult.outputForDisplayAsString());\n-            }\n-            mod.createModifiedFile(m.group(2), null, parseGitAction(m.group(1).charAt(0)));\n-        }\n-    }\n-\n-    private Matcher matchResultLine(String resultLine) {\n-        return GIT_DIFF_TREE_PATTERN.matcher(resultLine);\n-    }\n-\n     public void resetWorkingDir(ConsoleOutputStreamConsumer outputStreamConsumer, Revision revision, boolean shallow) {\n         log(outputStreamConsumer, \"Reset working directory %s\", workingDir);\n         cleanAllUnversionedFiles(outputStreamConsumer);\n", "next_change": {"commit": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java b/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\nindex dda537d690..b16ceb4823 100644\n--- a/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\n+++ b/domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java\n", "chunk": "@@ -95,7 +150,7 @@ public class GitCommand extends SCMCommand {\n     }\n \n     public List<Modification> modificationsSince(Revision revision) {\n-        return gitLog(\"--date=iso\", \"--pretty=medium\", \"--no-decorate\", \"--no-color\", String.format(\"%s..%s\", revision.getRevision(), remoteBranch()));\n+        return gitLog(\"--date=iso\", \"--pretty=medium\", \"--no-decorate\", \"--no-color\", format(\"%s..%s\", revision.getRevision(), remoteBranch()));\n     }\n \n     public void resetWorkingDir(ConsoleOutputStreamConsumer outputStreamConsumer, Revision revision, boolean shallow) {\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxODc0Mw==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438718743", "body": "Adding this just makes for concise multi-step command invocations.", "bodyText": "Adding this just makes for concise multi-step command invocations.", "bodyHTML": "<p dir=\"auto\">Adding this just makes for concise multi-step command invocations.</p>", "author": "marques-work", "createdAt": "2020-06-11T11:30:36Z", "path": "domain/src/main/java/com/thoughtworks/go/domain/materials/SCMCommand.java", "diffHunk": "@@ -30,15 +30,39 @@ public SCMCommand(String materialFingerprint) {\n         this.materialFingerprint = materialFingerprint;\n     }\n \n-    protected int run(CommandLine commandLine, ConsoleOutputStreamConsumer outputStreamConsumer, String... input) {\n-        return commandLine.run(outputStreamConsumer, new MaterialFingerprintTag(materialFingerprint), input);\n-    }\n-\n     public ConsoleResult runOrBomb(CommandLine commandLine, boolean failOnNonZeroReturn, String... input) {\n         return commandLine.runOrBomb(failOnNonZeroReturn, new MaterialFingerprintTag(materialFingerprint), input);\n     }\n \n     public ConsoleResult runOrBomb(CommandLine commandLine, String... input) {\n         return commandLine.runOrBomb(new MaterialFingerprintTag(materialFingerprint), input);\n     }\n+\n+    protected int run(CommandLine commandLine, ConsoleOutputStreamConsumer outputStreamConsumer, String... input) {\n+        return commandLine.run(outputStreamConsumer, new MaterialFingerprintTag(materialFingerprint), input);\n+    }\n+\n+    /**\n+     * Conveniently runs commands sequentially on a given console, aborting on the first failure.\n+     *\n+     * @param console  collects console output\n+     * @param commands the set of sequential commands\n+     * @return the exit status of the last executed command\n+     */\n+    protected int runCascade(ConsoleOutputStreamConsumer console, CommandLine... commands) {\n+        int code = 0;\n+\n+        // Doing this via streams is awkward; it's hard to *both* collect the return code\n+        // *AND* exit iteration early. Curse Java for only giving us fake closures!\n+        //\n+        // My un-amusement is \"effectively final\" \ud83d\ude12.\n+        for (CommandLine cmd : commands) {\n+            code = run(cmd, console);\n+            if (0 != code) {\n+                break;\n+            }\n+        }\n+\n+        return code;\n+    }", "originalCommit": "15947872ae7ecd0e2db1ff30b861776551dc3cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cbca50d98d98b15a6581214cafc0e42674c1fa74", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/domain/materials/SCMCommand.java b/domain/src/main/java/com/thoughtworks/go/domain/materials/SCMCommand.java\nindex ae724790b8..cb4bcd2652 100644\n--- a/domain/src/main/java/com/thoughtworks/go/domain/materials/SCMCommand.java\n+++ b/domain/src/main/java/com/thoughtworks/go/domain/materials/SCMCommand.java\n", "chunk": "@@ -37,32 +41,4 @@ public abstract class SCMCommand {\n     public ConsoleResult runOrBomb(CommandLine commandLine, String... input) {\n         return commandLine.runOrBomb(new MaterialFingerprintTag(materialFingerprint), input);\n     }\n-\n-    protected int run(CommandLine commandLine, ConsoleOutputStreamConsumer outputStreamConsumer, String... input) {\n-        return commandLine.run(outputStreamConsumer, new MaterialFingerprintTag(materialFingerprint), input);\n-    }\n-\n-    /**\n-     * Conveniently runs commands sequentially on a given console, aborting on the first failure.\n-     *\n-     * @param console  collects console output\n-     * @param commands the set of sequential commands\n-     * @return the exit status of the last executed command\n-     */\n-    protected int runCascade(ConsoleOutputStreamConsumer console, CommandLine... commands) {\n-        int code = 0;\n-\n-        // Doing this via streams is awkward; it's hard to *both* collect the return code\n-        // *AND* exit iteration early. Curse Java for only giving us fake closures!\n-        //\n-        // My un-amusement is \"effectively final\" \ud83d\ude12.\n-        for (CommandLine cmd : commands) {\n-            code = run(cmd, console);\n-            if (0 != code) {\n-                break;\n-            }\n-        }\n-\n-        return code;\n-    }\n }\n", "next_change": {"commit": "5e4c66a1db6f3945bc55fb850e5c6ff10cbaf6d8", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/domain/materials/SCMCommand.java b/domain/src/main/java/com/thoughtworks/go/domain/materials/SCMCommand.java\nindex cb4bcd2652..bd9c75595a 100644\n--- a/domain/src/main/java/com/thoughtworks/go/domain/materials/SCMCommand.java\n+++ b/domain/src/main/java/com/thoughtworks/go/domain/materials/SCMCommand.java\n", "chunk": "@@ -41,4 +37,8 @@ public abstract class SCMCommand {\n     public ConsoleResult runOrBomb(CommandLine commandLine, String... input) {\n         return commandLine.runOrBomb(new MaterialFingerprintTag(materialFingerprint), input);\n     }\n+\n+    protected int run(CommandLine commandLine, ConsoleOutputStreamConsumer outputStreamConsumer, String... input) {\n+        return commandLine.run(outputStreamConsumer, new MaterialFingerprintTag(materialFingerprint), input);\n+    }\n }\n", "next_change": {"commit": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/domain/materials/SCMCommand.java b/domain/src/main/java/com/thoughtworks/go/domain/materials/SCMCommand.java\nindex bd9c75595a..ae724790b8 100644\n--- a/domain/src/main/java/com/thoughtworks/go/domain/materials/SCMCommand.java\n+++ b/domain/src/main/java/com/thoughtworks/go/domain/materials/SCMCommand.java\n", "chunk": "@@ -41,4 +41,28 @@ public abstract class SCMCommand {\n     protected int run(CommandLine commandLine, ConsoleOutputStreamConsumer outputStreamConsumer, String... input) {\n         return commandLine.run(outputStreamConsumer, new MaterialFingerprintTag(materialFingerprint), input);\n     }\n+\n+    /**\n+     * Conveniently runs commands sequentially on a given console, aborting on the first failure.\n+     *\n+     * @param console  collects console output\n+     * @param commands the set of sequential commands\n+     * @return the exit status of the last executed command\n+     */\n+    protected int runCascade(ConsoleOutputStreamConsumer console, CommandLine... commands) {\n+        int code = 0;\n+\n+        // Doing this via streams is awkward; it's hard to *both* collect the return code\n+        // *AND* exit iteration early. Curse Java for only giving us fake closures!\n+        //\n+        // My un-amusement is \"effectively final\" \ud83d\ude12.\n+        for (CommandLine cmd : commands) {\n+            code = run(cmd, console);\n+            if (0 != code) {\n+                break;\n+            }\n+        }\n+\n+        return code;\n+    }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyMTE2Ng==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438721166", "body": "This util class handles all the logic to extract meaningful source and destination refs from refspecs, as well as defaulting to old behaviors when provided just a plain branch.\r\n\r\nThis util class exists because the logic is shared between `GitMaterial` and `GitCommand`.", "bodyText": "This util class handles all the logic to extract meaningful source and destination refs from refspecs, as well as defaulting to old behaviors when provided just a plain branch.\nThis util class exists because the logic is shared between GitMaterial and GitCommand.", "bodyHTML": "<p dir=\"auto\">This util class handles all the logic to extract meaningful source and destination refs from refspecs, as well as defaulting to old behaviors when provided just a plain branch.</p>\n<p dir=\"auto\">This util class exists because the logic is shared between <code>GitMaterial</code> and <code>GitCommand</code>.</p>", "author": "marques-work", "createdAt": "2020-06-11T11:36:21Z", "path": "domain/src/main/java/com/thoughtworks/go/domain/materials/git/RefSpecHelper.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2020 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.domain.materials.git;\n+\n+import com.thoughtworks.go.util.command.UrlArgument;\n+\n+public class RefSpecHelper {", "originalCommit": "15947872ae7ecd0e2db1ff30b861776551dc3cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cc15f6098806685d3dae7c97d0a4e4364b59009d", "changed_code": [{"header": "diff --git a/domain/src/main/java/com/thoughtworks/go/domain/materials/git/RefSpecHelper.java b/config/config-api/src/main/java/com/thoughtworks/go/config/materials/git/RefSpecHelper.java\nsimilarity index 82%\nrename from domain/src/main/java/com/thoughtworks/go/domain/materials/git/RefSpecHelper.java\nrename to config/config-api/src/main/java/com/thoughtworks/go/config/materials/git/RefSpecHelper.java\nindex 07b116d349..2fe051e5b8 100644\n--- a/domain/src/main/java/com/thoughtworks/go/domain/materials/git/RefSpecHelper.java\n+++ b/config/config-api/src/main/java/com/thoughtworks/go/config/materials/git/RefSpecHelper.java\n", "chunk": "@@ -14,9 +14,7 @@\n  * limitations under the License.\n  */\n \n-package com.thoughtworks.go.domain.materials.git;\n-\n-import com.thoughtworks.go.util.command.UrlArgument;\n+package com.thoughtworks.go.config.materials.git;\n \n public class RefSpecHelper {\n     public static final String REFS_HEADS = \"refs/heads/\";\n", "next_change": null}]}}, {"oid": "55fcb11c514f73dba198e8a8be9227ab1430d07e", "url": "https://github.com/gocd/gocd/commit/55fcb11c514f73dba198e8a8be9227ab1430d07e", "message": "Git materials can checkout arbitrary refs\n\n  - GoCD's `git` layer knows how to handle refspecs provided in the branch field.\n  - Refspecs are assumed to be a non-wildcard; wildcards have not been tested\n    and aren't meaningful to the intent of use (i.e., updating a local agent\n    workspace).\n  - The main motivation behind this is to allow GoCD to support pull request\n    refs as a pipeline material for the branch support work.\n\nImplementation notes\n--------------------\n\n`RefSpecHelper` handles detection and parsing of a given branch or refspec. Mainly,\nthis utility class extracts source and destination components of the refspec and\nbuilds sensible values for local branch names and remote branch names. Also notably,\nit infers a full destination ref from a shorthand refspec. The logic for this is\nstraightforward:\n\n1. When given a shorthand refspec in the form: `refs/namespace/foo:bar`\n    - the refspec destination is expanded under the `origin` remote as\n      `refs/namespace/foo:refs/remotes/origin/bar`.\n\n2. When given a full refspec in the form: `refs/namespace/foo:refs/anything/bar`\n    - the refspec is interpreted as-is.\n\n`GitCommand#clone()` and `GitCommand#cloneWithNoCheckout()` have been adapted to\naccommodate refspecs; when a refspec is detected, the clone behaviors configure\nthe `git-fetch` configurations with the refspec instead of the implicit/default\n`+refs/heads/*:refs/remotes/origin/*` so that future `git fetch` operations update\nthe correct refs. This ensures that flyweights and agent sandboxes receive new\ncommits. The local branch is also explicitly created before switching the local\nrepo `HEAD` pointer.\n\n`GitMaterial` is also refspec aware and knows how to report the local branch name\nfrom the given refspec. Additionally, `GitMaterial#isRepositoryChanged()` performs\nadditional validation on the fetch configuration before reusing (or re-cloning) a\nflyweight or agent sandbox for a given material.\n\n`GitCommand` and `GitMaterial` delegate to `RefSpecHelper` for the detection and\ninterpretation of refspecs.\n\nThere were also some convenience methods added to `SCMCommand` and `CommandLine`\nin addition to miscellaneous code formatting, cleanup, and reorganization.", "committedDate": "2020-06-12T02:24:54Z", "type": "forcePushed"}, {"oid": "cc15f6098806685d3dae7c97d0a4e4364b59009d", "url": "https://github.com/gocd/gocd/commit/cc15f6098806685d3dae7c97d0a4e4364b59009d", "message": "wip", "committedDate": "2020-07-01T22:13:11Z", "type": "forcePushed"}, {"oid": "e1d97eaa46f8f3006c922c7b257cc4c85323291e", "url": "https://github.com/gocd/gocd/commit/e1d97eaa46f8f3006c922c7b257cc4c85323291e", "message": "wip", "committedDate": "2020-07-01T23:12:29Z", "type": "forcePushed"}, {"oid": "22db5320e1cd398cc87a47438bb8525e572a6dc2", "url": "https://github.com/gocd/gocd/commit/22db5320e1cd398cc87a47438bb8525e572a6dc2", "message": "wip", "committedDate": "2020-07-01T23:18:46Z", "type": "forcePushed"}, {"oid": "33f1376933b88a8f148ccbdbeea3199cb2984367", "url": "https://github.com/gocd/gocd/commit/33f1376933b88a8f148ccbdbeea3199cb2984367", "message": "Git materials can checkout arbitrary refs\n\n  - GoCD's `git` layer knows how to handle refspecs provided in the branch field.\n  - Refspecs _**must NOT**_ contain wildcards; they are not meaningful to how GoCD\n    will use materials (i.e., updating a local agent workspace).\n  - The main motivation behind this is to allow GoCD to support pull request\n    refs as a pipeline material for the branch support work.\n\nImplementation notes\n--------------------\n\n`RefSpecHelper` handles detection and parsing of a given branch or refspec. Mainly,\nthis utility class extracts source and destination components of the refspec and\nbuilds sensible values for local branch names and remote branch names. Also notably,\nit infers a full destination ref from a shorthand refspec. The logic for this is\nstraightforward:\n\n1. When given a shorthand refspec in the form: `refs/namespace/foo:bar`\n    - the refspec destination is expanded under the `origin` remote as\n      `refs/namespace/foo:refs/remotes/origin/bar`.\n\n2. When given a full refspec in the form: `refs/namespace/foo:refs/anything/bar`\n    - the refspec is interpreted as-is.\n\n`GitCommand#clone()` and `GitCommand#cloneWithNoCheckout()` have been adapted to\naccommodate refspecs; when a refspec is detected, the clone behaviors configure\nthe `git-fetch` configurations with the refspec instead of the implicit/default\n`+refs/heads/*:refs/remotes/origin/*` so that future `git fetch` operations update\nthe correct refs. This ensures that flyweights and agent sandboxes receive new\ncommits. The local branch is also explicitly created before switching the local\nrepo `HEAD` pointer.\n\n`GitMaterial` is also refspec aware and knows how to report the local branch name\nfrom the given refspec. Additionally, `GitMaterial#isRepositoryChanged()` performs\nadditional validation on the fetch configuration before reusing (or re-cloning) a\nflyweight or agent sandbox for a given material.\n\n`GitCommand` and `GitMaterial` delegate to `RefSpecHelper` for the detection and\ninterpretation of refspecs.\n\nThere were also some convenience methods added to `SCMCommand` and `CommandLine`\nin addition to miscellaneous code formatting, cleanup, and reorganization.", "committedDate": "2020-07-02T22:19:47Z", "type": "forcePushed"}, {"oid": "e325885e47e8fefc197be987889e3e8fc5460ded", "url": "https://github.com/gocd/gocd/commit/e325885e47e8fefc197be987889e3e8fc5460ded", "message": "Git materials can checkout arbitrary refs\n\n  - GoCD's `git` layer knows how to handle refspecs provided in the branch field.\n  - Refspecs _**must NOT**_ contain wildcards; they are not meaningful to how GoCD\n    will use materials (i.e., updating a local agent workspace).\n  - The main motivation behind this is to allow GoCD to support pull request\n    refs as a pipeline material for the branch support work.\n\nImplementation notes\n--------------------\n\n`RefSpecHelper` handles detection and parsing of a given branch or refspec. Mainly,\nthis utility class extracts source and destination components of the refspec and\nbuilds sensible values for local branch names and remote branch names. Also notably,\nit infers a full destination ref from a shorthand refspec. The logic for this is\nstraightforward:\n\n1. When given a shorthand refspec in the form: `refs/namespace/foo:bar`\n    - the refspec destination is expanded under the `origin` remote as\n      `refs/namespace/foo:refs/remotes/origin/bar`.\n\n2. When given a full refspec in the form: `refs/namespace/foo:refs/anything/bar`\n    - the refspec is interpreted as-is.\n\n`GitCommand#clone()` and `GitCommand#cloneWithNoCheckout()` have been adapted to\naccommodate refspecs; when a refspec is detected, the clone behaviors configure\nthe `git-fetch` configurations with the refspec instead of the implicit/default\n`+refs/heads/*:refs/remotes/origin/*` so that future `git fetch` operations update\nthe correct refs. This ensures that flyweights and agent sandboxes receive new\ncommits. The local branch is also explicitly created before switching the local\nrepo `HEAD` pointer.\n\n`GitMaterial` is also refspec aware and knows how to report the local branch name\nfrom the given refspec. Additionally, `GitMaterial#isRepositoryChanged()` performs\nadditional validation on the fetch configuration before reusing (or re-cloning) a\nflyweight or agent sandbox for a given material.\n\n`GitCommand` and `GitMaterial` delegate to `RefSpecHelper` for the detection and\ninterpretation of refspecs.\n\nThere were also some convenience methods added to `SCMCommand` and `CommandLine`\nin addition to miscellaneous code formatting, cleanup, and reorganization.", "committedDate": "2020-07-03T00:18:02Z", "type": "forcePushed"}, {"oid": "cbca50d98d98b15a6581214cafc0e42674c1fa74", "url": "https://github.com/gocd/gocd/commit/cbca50d98d98b15a6581214cafc0e42674c1fa74", "message": "Regenerate GitMaterial and GitMaterialConfig equals(), hashCode(), toString()", "committedDate": "2020-07-03T11:29:02Z", "type": "commit"}, {"oid": "5e4c66a1db6f3945bc55fb850e5c6ff10cbaf6d8", "url": "https://github.com/gocd/gocd/commit/5e4c66a1db6f3945bc55fb850e5c6ff10cbaf6d8", "message": "Rearrange `GitCommand` and `SCMCommand` methods by visibility to make the public API clearer", "committedDate": "2020-07-03T11:29:02Z", "type": "commit"}, {"oid": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "url": "https://github.com/gocd/gocd/commit/1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "message": "Git materials can checkout arbitrary refs\n\n  - GoCD's `git` layer knows how to handle refspecs provided in the branch field.\n  - Refspecs _**must NOT**_ contain wildcards; they are not meaningful to how GoCD\n    will use materials (i.e., updating a local agent workspace).\n  - The main motivation behind this is to allow GoCD to support pull request\n    refs as a pipeline material for the branch support work.\n\nImplementation notes\n--------------------\n\n`RefSpecHelper` handles detection and parsing of a given branch or refspec. Mainly,\nthis utility class extracts source and destination components of the refspec and\nbuilds sensible values for local branch names and remote branch names. Also notably,\nit infers a full destination ref from a shorthand refspec. The logic for this is\nstraightforward:\n\n1. When given a shorthand refspec in the form: `refs/namespace/foo:bar`\n    - the refspec destination is expanded under the `origin` remote as\n      `refs/namespace/foo:refs/remotes/origin/bar`.\n\n2. When given a full refspec in the form: `refs/namespace/foo:refs/anything/bar`\n    - the refspec is interpreted as-is.\n\n`GitCommand#clone()` and `GitCommand#cloneWithNoCheckout()` have been adapted to\naccommodate refspecs; when a refspec is detected, the clone behaviors configure\nthe `git-fetch` configurations with the refspec instead of the implicit/default\n`+refs/heads/*:refs/remotes/origin/*` so that future `git fetch` operations update\nthe correct refs. This ensures that flyweights and agent sandboxes receive new\ncommits. The local branch is also explicitly created before switching the local\nrepo `HEAD` pointer.\n\n`GitMaterial` is also refspec aware and knows how to report the local branch name\nfrom the given refspec. Additionally, `GitMaterial#isRepositoryChanged()` performs\nadditional validation on the fetch configuration before reusing (or re-cloning) a\nflyweight or agent sandbox for a given material.\n\n`GitCommand` and `GitMaterial` delegate to `RefSpecHelper` for the detection and\ninterpretation of refspecs.\n\nThere were also some convenience methods added to `SCMCommand` and `CommandLine`\nin addition to miscellaneous code formatting, cleanup, and reorganization.", "committedDate": "2020-07-03T11:29:02Z", "type": "commit"}, {"oid": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "url": "https://github.com/gocd/gocd/commit/1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "message": "Git materials can checkout arbitrary refs\n\n  - GoCD's `git` layer knows how to handle refspecs provided in the branch field.\n  - Refspecs _**must NOT**_ contain wildcards; they are not meaningful to how GoCD\n    will use materials (i.e., updating a local agent workspace).\n  - The main motivation behind this is to allow GoCD to support pull request\n    refs as a pipeline material for the branch support work.\n\nImplementation notes\n--------------------\n\n`RefSpecHelper` handles detection and parsing of a given branch or refspec. Mainly,\nthis utility class extracts source and destination components of the refspec and\nbuilds sensible values for local branch names and remote branch names. Also notably,\nit infers a full destination ref from a shorthand refspec. The logic for this is\nstraightforward:\n\n1. When given a shorthand refspec in the form: `refs/namespace/foo:bar`\n    - the refspec destination is expanded under the `origin` remote as\n      `refs/namespace/foo:refs/remotes/origin/bar`.\n\n2. When given a full refspec in the form: `refs/namespace/foo:refs/anything/bar`\n    - the refspec is interpreted as-is.\n\n`GitCommand#clone()` and `GitCommand#cloneWithNoCheckout()` have been adapted to\naccommodate refspecs; when a refspec is detected, the clone behaviors configure\nthe `git-fetch` configurations with the refspec instead of the implicit/default\n`+refs/heads/*:refs/remotes/origin/*` so that future `git fetch` operations update\nthe correct refs. This ensures that flyweights and agent sandboxes receive new\ncommits. The local branch is also explicitly created before switching the local\nrepo `HEAD` pointer.\n\n`GitMaterial` is also refspec aware and knows how to report the local branch name\nfrom the given refspec. Additionally, `GitMaterial#isRepositoryChanged()` performs\nadditional validation on the fetch configuration before reusing (or re-cloning) a\nflyweight or agent sandbox for a given material.\n\n`GitCommand` and `GitMaterial` delegate to `RefSpecHelper` for the detection and\ninterpretation of refspecs.\n\nThere were also some convenience methods added to `SCMCommand` and `CommandLine`\nin addition to miscellaneous code formatting, cleanup, and reorganization.", "committedDate": "2020-07-03T11:29:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU0NjA3OQ==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r449546079", "body": "Worth calling out this decision in `expandRefSpec()`", "bodyText": "Worth calling out this decision in expandRefSpec()", "bodyHTML": "<p dir=\"auto\">Worth calling out this decision in <code>expandRefSpec()</code></p>", "author": "marques-work", "createdAt": "2020-07-03T11:58:59Z", "path": "config/config-api/src/main/java/com/thoughtworks/go/config/materials/git/RefSpecHelper.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright 2020 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.config.materials.git;\n+\n+public class RefSpecHelper {\n+    public static final String REFS_HEADS = \"refs/heads/\";\n+    public static final String REFS_REMOTES = \"refs/remotes/\";\n+\n+    private RefSpecHelper() {\n+    }\n+\n+    public static String localBranch(String branch) {\n+        final String local = findDest(branch);\n+\n+        if (null == local) {\n+            return branch;\n+        }\n+\n+        if (local.startsWith(REFS_HEADS)) {\n+            return local.substring(REFS_HEADS.length());\n+        }\n+\n+        if (local.startsWith(REFS_REMOTES)) {\n+            final int bound = local.indexOf(\"/\", REFS_REMOTES.length());\n+            // If the user does not specify a branch under the remote, this is likely\n+            // a user error. As a failsafe, allow the condition to fall through, which\n+            // effectively returns `refs/remotes/<remote-name>` as this will be\n+            // resolvable in git.\n+            if (-1 != bound) {\n+                return local.substring(bound + 1);\n+            }\n+        }\n+\n+        return local;\n+    }\n+\n+    public static String remoteBranch(String branch) {\n+        final String local = findDest(branch);\n+\n+        if (null == local) {\n+            return \"origin/\" + branch;\n+        }\n+\n+        if (!local.startsWith(\"refs/\")) {\n+            return REFS_HEADS + local;\n+        }\n+\n+        if (local.startsWith(REFS_REMOTES)) {\n+            // If the user does not specify a branch under the remote, this is likely\n+            // a user error. As a failsafe, allow the condition to fall through, which\n+            // effectively returns `refs/remotes/<remote-name>` as this will be\n+            // resolvable in git.\n+            if (-1 != local.indexOf(\"/\", REFS_REMOTES.length())) {\n+                return local.substring(REFS_REMOTES.length());\n+            }\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Finds the full ref of the upstream branch; for refSpecs, this returns the source fragment.\n+     * <p>\n+     * This is mainly used for {@code git ls-remote} during git connection check.\n+     *\n+     * @return the full ref of the upstream branch or source fragment of the refSpec\n+     */\n+    public static String fullUpstreamRef(String branch) {\n+        final String source = findSource(branch);\n+        return null == source ? REFS_HEADS + branch : source;\n+    }\n+\n+    public static boolean hasRefSpec(String branch) {\n+        return -1 != refSpecBoundary(branch);\n+    }\n+\n+    /**\n+     * Ensures that the refSpec destination has an absolute path\n+     *\n+     * @return the absolute refSpec\n+     */\n+    public static String expandRefSpec(String branch) {\n+        final String source = findSource(branch);\n+\n+        if (null == source) { // equiv to hasRefSpec()\n+            return branch;\n+        }\n+\n+        final String dest = findDest(branch);\n+\n+        if (null == dest || dest.startsWith(\"refs/\")) {\n+            return branch;\n+        }\n+\n+        // NOTE: This behavior differs from the `git fetch <remote> <refSpec>` implicit, default\n+        // expansion, which effectively interprets `refs/a/b:c` as `refs/a/b:refs/heads/c`.\n+        //\n+        // Expanding the destination to be under `refs/remotes/origin/<dest>` is a more sensible\n+        // default for how GoCD works. As we actually create and _switch_ to the branch named\n+        // by the destination, `git fetch` would *fail* if the refSpec destination were to be\n+        // `refs/heads/<branchName>`; fetching directly to the current branch is illegal in `git`\n+        // (HEAD actually points to `refs/heads/<branchName>`).\n+        //\n+        // Fetching to `refs/remotes/origin/<branchName>` (and then merging, \u00e0 la \"pull\") works\n+        // perfectly fine from the current branch.\n+        //\n+        //   -- In case you were wondering. \ud83d\udd96\ud83c\udffc\n+        return source + \":\" + REFS_REMOTES + \"origin/\" + dest;", "originalCommit": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MDE3Ng==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r450160176", "body": "@marques-work - is this `System.out.printf` intentional?", "bodyText": "@marques-work - is this System.out.printf intentional?", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/marques-work/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/marques-work\">@marques-work</a> - is this <code>System.out.printf</code> intentional?</p>", "author": "GaneshSPatil", "createdAt": "2020-07-06T11:33:52Z", "path": "domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java", "diffHunk": "@@ -443,13 +314,136 @@ public GitMaterial withShallowClone(boolean value) {\n         return gitMaterial;\n     }\n \n-    public String branchWithDefault() {\n-        return isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n+    public String effectiveLocalBranch() {\n+        return localBranch(isBlank(refSpecOrBranch) ? GitMaterialConfig.DEFAULT_BRANCH : refSpecOrBranch);\n+    }\n+\n+    @Override\n+    protected void appendCriteria(Map<String, Object> parameters) {\n+        parameters.put(ScmMaterialConfig.URL, url.originalArgument());\n+        parameters.put(\"branch\", refSpecOrBranch);\n+    }\n+\n+    @Override\n+    protected void appendAttributes(Map<String, Object> parameters) {\n+        parameters.put(\"url\", url);\n+        parameters.put(\"branch\", refSpecOrBranch);\n+        parameters.put(\"shallowClone\", shallowClone);\n+    }\n+\n+    @Override\n+    protected String getLocation() {\n+        return url.forDisplay();\n     }\n \n     @Override\n     protected void setGoMaterialVariables(EnvironmentVariableContext environmentVariableContext) {\n         super.setGoMaterialVariables(environmentVariableContext);\n-        setVariableWithName(environmentVariableContext, branchWithDefault(), GO_MATERIAL_BRANCH);\n+        setVariableWithName(environmentVariableContext, effectiveLocalBranch(), GO_MATERIAL_BRANCH);\n+    }\n+\n+    private GitCommand getGit(File workingdir, SubprocessExecutionContext executionContext) {\n+        InMemoryStreamConsumer output = inMemoryConsumer();\n+        try {\n+            return git(output, workingdir, DEFAULT_SHALLOW_CLONE_DEPTH, executionContext);\n+        } catch (Exception e) {\n+            throw bomb(e.getMessage() + \" \" + output.getStdError(), e);\n+        }\n+    }\n+\n+    private GitCommand git(ConsoleOutputStreamConsumer outputStreamConsumer, final File workingFolder, int preferredCloneDepth, SubprocessExecutionContext executionContext) throws Exception {\n+        if (isSubmoduleFolder()) {\n+            return new GitCommand(getFingerprint(), new File(workingFolder.getPath()), GitMaterialConfig.DEFAULT_BRANCH, true, secrets());\n+        }\n+        System.out.printf(\"**** [%s] WorkingDir for %s: %s\\n\", executionContext.isServer() ? \"server\" : \"agent\", urlForCommandLine(), workingFolder.getPath());", "originalCommit": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwNjQyMg==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r450606422", "bodyText": "@GaneshSPatil oops! no, it is not.", "author": "marques-work", "createdAt": "2020-07-07T04:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MDE3Ng=="}], "type": "inlineReview", "revised_code": null}]}