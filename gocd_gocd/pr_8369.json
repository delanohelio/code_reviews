{"pr_number": 8369, "pr_title": "Fix config repository rules violation (#8368)", "pr_author": "GaneshSPatil", "pr_createdAt": "2020-07-22T14:06:20Z", "pr_url": "https://github.com/gocd/gocd/pull/8369", "timeline": [{"oid": "7bdbdf95c693da3e9f12163d223f71a2404abeaf", "url": "https://github.com/gocd/gocd/commit/7bdbdf95c693da3e9f12163d223f71a2404abeaf", "message": "Fix config repository rules violation (#8368)\n\n* Remove pipelines from config on rules failure.\n* Remove cached partial when merge fails.\n* Revalidate last valid partials with latest config repo rules.", "committedDate": "2020-07-22T15:05:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxMTg1Mg==", "url": "https://github.com/gocd/gocd/pull/8369#discussion_r459011852", "body": "if I understand right, the assumption made here is that if the current version is same as the last valid version, the config update is failed due to rules violation. If that is the case we that would be a wrong assumption now that we are adding support for branches/PR. For a same revision of the config repo material, the partials can differ based on the PRs/branches at the time of parse.\r\n\r\nLet me know if the below logic makes sense,\r\n```\r\nif (updateConfig(incoming, fingerprint, repoConfig)) {\r\n    cachedGoPartials.markAsValid(fingerprint, incoming);\r\n} else {\r\n    final PartialConfig previousValidPartial = cachedGoPartials.getValid(repoConfig.getRepo().getFingerprint());\r\n    if (violatesRules && previousValidPartial != null) {\r\n        // do not allow fallback to the last version of the partial if the current rules do not allow\r\n        cachedGoPartials.removeValidWithoutClearingServerHealthMessage(repoConfig.getRepo().getFingerprint());\r\n        goConfigService.updateConfig(cruiseConfig -> {\r\n            cruiseConfig.getPartials().remove(cachedGoPartials.findPartialByFingerprint(cruiseConfig, fingerprint));\r\n            return cruiseConfig;\r\n        });\r\n    }\r\n}\r\n```", "bodyText": "if I understand right, the assumption made here is that if the current version is same as the last valid version, the config update is failed due to rules violation. If that is the case we that would be a wrong assumption now that we are adding support for branches/PR. For a same revision of the config repo material, the partials can differ based on the PRs/branches at the time of parse.\nLet me know if the below logic makes sense,\nif (updateConfig(incoming, fingerprint, repoConfig)) {\n    cachedGoPartials.markAsValid(fingerprint, incoming);\n} else {\n    final PartialConfig previousValidPartial = cachedGoPartials.getValid(repoConfig.getRepo().getFingerprint());\n    if (violatesRules && previousValidPartial != null) {\n        // do not allow fallback to the last version of the partial if the current rules do not allow\n        cachedGoPartials.removeValidWithoutClearingServerHealthMessage(repoConfig.getRepo().getFingerprint());\n        goConfigService.updateConfig(cruiseConfig -> {\n            cruiseConfig.getPartials().remove(cachedGoPartials.findPartialByFingerprint(cruiseConfig, fingerprint));\n            return cruiseConfig;\n        });\n    }\n}", "bodyHTML": "<p dir=\"auto\">if I understand right, the assumption made here is that if the current version is same as the last valid version, the config update is failed due to rules violation. If that is the case we that would be a wrong assumption now that we are adding support for branches/PR. For a same revision of the config repo material, the partials can differ based on the PRs/branches at the time of parse.</p>\n<p dir=\"auto\">Let me know if the below logic makes sense,</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (updateConfig(incoming, fingerprint, repoConfig)) {\n    cachedGoPartials.markAsValid(fingerprint, incoming);\n} else {\n    final PartialConfig previousValidPartial = cachedGoPartials.getValid(repoConfig.getRepo().getFingerprint());\n    if (violatesRules &amp;&amp; previousValidPartial != null) {\n        // do not allow fallback to the last version of the partial if the current rules do not allow\n        cachedGoPartials.removeValidWithoutClearingServerHealthMessage(repoConfig.getRepo().getFingerprint());\n        goConfigService.updateConfig(cruiseConfig -&gt; {\n            cruiseConfig.getPartials().remove(cachedGoPartials.findPartialByFingerprint(cruiseConfig, fingerprint));\n            return cruiseConfig;\n        });\n    }\n}\"><pre><code>if (updateConfig(incoming, fingerprint, repoConfig)) {\n    cachedGoPartials.markAsValid(fingerprint, incoming);\n} else {\n    final PartialConfig previousValidPartial = cachedGoPartials.getValid(repoConfig.getRepo().getFingerprint());\n    if (violatesRules &amp;&amp; previousValidPartial != null) {\n        // do not allow fallback to the last version of the partial if the current rules do not allow\n        cachedGoPartials.removeValidWithoutClearingServerHealthMessage(repoConfig.getRepo().getFingerprint());\n        goConfigService.updateConfig(cruiseConfig -&gt; {\n            cruiseConfig.getPartials().remove(cachedGoPartials.findPartialByFingerprint(cruiseConfig, fingerprint));\n            return cruiseConfig;\n        });\n    }\n}\n</code></pre></div>", "author": "maheshp", "createdAt": "2020-07-22T18:52:54Z", "path": "server/src/main/java/com/thoughtworks/go/config/PartialConfigService.java", "diffHunk": "@@ -69,27 +70,57 @@ public void onSuccessPartialConfig(ConfigRepoConfig repoConfig, PartialConfig in\n \n         if (this.configWatchList.hasConfigRepoWithFingerprint(fingerprint)) {\n             if (shouldMergePartial(incoming, fingerprint, repoConfig)) {\n-                // validate rules before attempting updateConfig() so that\n-                // rule violations will be considered before accepting a merge;\n-                // updateConfig() only considers structural validity.\n-                final boolean violatesRules = hasRuleViolations(incoming);\n-\n+                // mark the fingerprint as last known\n                 cachedGoPartials.cacheAsLastKnown(fingerprint, incoming);\n \n-                if (updateConfig(incoming, fingerprint, repoConfig)) {\n+                //validate rules\n+                hasRuleViolations(incoming);\n+\n+                //validate config.\n+                // updateConfig will fail to update the configuration if there are validation errors.\n+                // Even in case of rules violation, the updateConfig method is required to populate a server health message of rule violation, which also will be shown on the config repo spa.\n+                final boolean isConfigUpdated = updateConfig(incoming, fingerprint, repoConfig);\n+\n+                if (isConfigUpdated) {\n+                    // mark the partial as valid when config is updated successfully for it.\n                     cachedGoPartials.markAsValid(fingerprint, incoming);\n                 } else {\n                     final PartialConfig previousValidPartial = cachedGoPartials.getValid(repoConfig.getRepo().getFingerprint());\n \n-                    if (violatesRules && hasRuleViolations(previousValidPartial)) {\n-                        // do not allow fallback to the last version of the partial if the current rules do not allow\n-                        cachedGoPartials.removeValid(repoConfig.getRepo().getFingerprint());\n+                    if (previousValidPartial != null) {\n+                        final boolean isSameRevisionAsOfPreviousValidPartial = ((RepoConfigOrigin) incoming.getOrigin()).getRevision().equals(((RepoConfigOrigin) previousValidPartial.getOrigin()).getRevision());\n+                        // In case of last valid partials are same as of incoming partials, config repo rules are changed causing the rule validation failure.\n+                        // in such case, remove the valid partials without clearing the server health message. Server health message is populated for the same fingerprint with the latest parse failure message.\n+                        if (isSameRevisionAsOfPreviousValidPartial) {", "originalCommit": "7bdbdf95c693da3e9f12163d223f71a2404abeaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxODA2Mg==", "url": "https://github.com/gocd/gocd/pull/8369#discussion_r459018062", "body": "I get your point why we need to check rules for last valid partial against the current rules. guess my previous comment has to change to something like,\r\n\r\n```\r\nif (updateConfig(incoming, fingerprint, repoConfig)) {\r\n    cachedGoPartials.markAsValid(fingerprint, incoming);\r\n} else {\r\n    final PartialConfig previousValidPartial = cachedGoPartials.getValid(repoConfig.getRepo().getFingerprint());\r\n    if (validPartialHasRuleViolations(previousValidPartial)) {\r\n        // do not allow fallback to the last version of the partial if the current rules do not allow\r\n        cachedGoPartials.removeValidWithoutClearingServerHealthMessage(repoConfig.getRepo().getFingerprint());\r\n        goConfigService.updateConfig(cruiseConfig -> {\r\n            cruiseConfig.getPartials().remove(cachedGoPartials.findPartialByFingerprint(cruiseConfig, fingerprint));\r\n            return cruiseConfig;\r\n        });\r\n    }\r\n}\r\n```", "bodyText": "I get your point why we need to check rules for last valid partial against the current rules. guess my previous comment has to change to something like,\nif (updateConfig(incoming, fingerprint, repoConfig)) {\n    cachedGoPartials.markAsValid(fingerprint, incoming);\n} else {\n    final PartialConfig previousValidPartial = cachedGoPartials.getValid(repoConfig.getRepo().getFingerprint());\n    if (validPartialHasRuleViolations(previousValidPartial)) {\n        // do not allow fallback to the last version of the partial if the current rules do not allow\n        cachedGoPartials.removeValidWithoutClearingServerHealthMessage(repoConfig.getRepo().getFingerprint());\n        goConfigService.updateConfig(cruiseConfig -> {\n            cruiseConfig.getPartials().remove(cachedGoPartials.findPartialByFingerprint(cruiseConfig, fingerprint));\n            return cruiseConfig;\n        });\n    }\n}", "bodyHTML": "<p dir=\"auto\">I get your point why we need to check rules for last valid partial against the current rules. guess my previous comment has to change to something like,</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (updateConfig(incoming, fingerprint, repoConfig)) {\n    cachedGoPartials.markAsValid(fingerprint, incoming);\n} else {\n    final PartialConfig previousValidPartial = cachedGoPartials.getValid(repoConfig.getRepo().getFingerprint());\n    if (validPartialHasRuleViolations(previousValidPartial)) {\n        // do not allow fallback to the last version of the partial if the current rules do not allow\n        cachedGoPartials.removeValidWithoutClearingServerHealthMessage(repoConfig.getRepo().getFingerprint());\n        goConfigService.updateConfig(cruiseConfig -&gt; {\n            cruiseConfig.getPartials().remove(cachedGoPartials.findPartialByFingerprint(cruiseConfig, fingerprint));\n            return cruiseConfig;\n        });\n    }\n}\"><pre><code>if (updateConfig(incoming, fingerprint, repoConfig)) {\n    cachedGoPartials.markAsValid(fingerprint, incoming);\n} else {\n    final PartialConfig previousValidPartial = cachedGoPartials.getValid(repoConfig.getRepo().getFingerprint());\n    if (validPartialHasRuleViolations(previousValidPartial)) {\n        // do not allow fallback to the last version of the partial if the current rules do not allow\n        cachedGoPartials.removeValidWithoutClearingServerHealthMessage(repoConfig.getRepo().getFingerprint());\n        goConfigService.updateConfig(cruiseConfig -&gt; {\n            cruiseConfig.getPartials().remove(cachedGoPartials.findPartialByFingerprint(cruiseConfig, fingerprint));\n            return cruiseConfig;\n        });\n    }\n}\n</code></pre></div>", "author": "maheshp", "createdAt": "2020-07-22T19:03:32Z", "path": "server/src/main/java/com/thoughtworks/go/config/PartialConfigService.java", "diffHunk": "@@ -69,27 +70,57 @@ public void onSuccessPartialConfig(ConfigRepoConfig repoConfig, PartialConfig in\n \n         if (this.configWatchList.hasConfigRepoWithFingerprint(fingerprint)) {\n             if (shouldMergePartial(incoming, fingerprint, repoConfig)) {\n-                // validate rules before attempting updateConfig() so that\n-                // rule violations will be considered before accepting a merge;\n-                // updateConfig() only considers structural validity.\n-                final boolean violatesRules = hasRuleViolations(incoming);\n-\n+                // mark the fingerprint as last known\n                 cachedGoPartials.cacheAsLastKnown(fingerprint, incoming);\n \n-                if (updateConfig(incoming, fingerprint, repoConfig)) {\n+                //validate rules\n+                hasRuleViolations(incoming);\n+\n+                //validate config.\n+                // updateConfig will fail to update the configuration if there are validation errors.\n+                // Even in case of rules violation, the updateConfig method is required to populate a server health message of rule violation, which also will be shown on the config repo spa.\n+                final boolean isConfigUpdated = updateConfig(incoming, fingerprint, repoConfig);\n+\n+                if (isConfigUpdated) {\n+                    // mark the partial as valid when config is updated successfully for it.\n                     cachedGoPartials.markAsValid(fingerprint, incoming);\n                 } else {\n                     final PartialConfig previousValidPartial = cachedGoPartials.getValid(repoConfig.getRepo().getFingerprint());\n \n-                    if (violatesRules && hasRuleViolations(previousValidPartial)) {\n-                        // do not allow fallback to the last version of the partial if the current rules do not allow\n-                        cachedGoPartials.removeValid(repoConfig.getRepo().getFingerprint());\n+                    if (previousValidPartial != null) {\n+                        final boolean isSameRevisionAsOfPreviousValidPartial = ((RepoConfigOrigin) incoming.getOrigin()).getRevision().equals(((RepoConfigOrigin) previousValidPartial.getOrigin()).getRevision());\n+                        // In case of last valid partials are same as of incoming partials, config repo rules are changed causing the rule validation failure.\n+                        // in such case, remove the valid partials without clearing the server health message. Server health message is populated for the same fingerprint with the latest parse failure message.\n+                        if (isSameRevisionAsOfPreviousValidPartial) {\n+                            removeCachedPartialsAndUpdateConfig(fingerprint);\n+                        } else {\n+                            // lets say the latest partial is invalid for the current config repo rules.\n+                            // in such cases, validate the previous valid partial with respect to current config repo rules.\n+                            // if the previous valid partials are valid - do nothing - as the error for the latest partial is already populated and config contains the last known partial\n+                            // and if the previous valid partials are invalid - remove those config without clearing the server health message. Server health message is populated for the same fingerprint with the latest parse failure message.\n+                            ((RepoConfigOrigin) previousValidPartial.getOrigin()).setConfigRepo(((RepoConfigOrigin) incoming.getOrigin()).getConfigRepo());\n+                            if (hasRuleViolations(previousValidPartial)) {", "originalCommit": "7bdbdf95c693da3e9f12163d223f71a2404abeaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "18463b8dbd635de151687d8ea0ce294a68ee9338", "url": "https://github.com/gocd/gocd/commit/18463b8dbd635de151687d8ea0ce294a68ee9338", "message": "Fix config repository rules violation (#8368)\n\n* Remove pipelines from config on rules failure.\n* Remove cached partial when merge fails.\n* Revalidate last valid partials with latest config repo rules.", "committedDate": "2020-07-23T03:48:51Z", "type": "commit"}, {"oid": "18463b8dbd635de151687d8ea0ce294a68ee9338", "url": "https://github.com/gocd/gocd/commit/18463b8dbd635de151687d8ea0ce294a68ee9338", "message": "Fix config repository rules violation (#8368)\n\n* Remove pipelines from config on rules failure.\n* Remove cached partial when merge fails.\n* Revalidate last valid partials with latest config repo rules.", "committedDate": "2020-07-23T03:48:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5MDk5Mw==", "url": "https://github.com/gocd/gocd/pull/8369#discussion_r459690993", "body": "@GaneshSPatil do we need to explicitly check for rules violation here? Wouldn't config update apply rules?", "bodyText": "@GaneshSPatil do we need to explicitly check for rules violation here? Wouldn't config update apply rules?", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/GaneshSPatil/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/GaneshSPatil\">@GaneshSPatil</a> do we need to explicitly check for rules violation here? Wouldn't config update apply rules?</p>", "author": "maheshp", "createdAt": "2020-07-23T19:53:22Z", "path": "server/src/main/java/com/thoughtworks/go/config/PartialConfigService.java", "diffHunk": "@@ -69,21 +70,40 @@ public void onSuccessPartialConfig(ConfigRepoConfig repoConfig, PartialConfig in\n \n         if (this.configWatchList.hasConfigRepoWithFingerprint(fingerprint)) {\n             if (shouldMergePartial(incoming, fingerprint, repoConfig)) {\n-                // validate rules before attempting updateConfig() so that\n-                // rule violations will be considered before accepting a merge;\n-                // updateConfig() only considers structural validity.\n-                final boolean violatesRules = hasRuleViolations(incoming);\n-\n+                // mark the fingerprint as last known\n                 cachedGoPartials.cacheAsLastKnown(fingerprint, incoming);\n \n-                if (updateConfig(incoming, fingerprint, repoConfig)) {\n+                //validate rules\n+                hasRuleViolations(incoming);", "originalCommit": "18463b8dbd635de151687d8ea0ce294a68ee9338", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b803c0f58b1a5ac660b3e836f9abcb3ccf381a81", "url": "https://github.com/gocd/gocd/commit/b803c0f58b1a5ac660b3e836f9abcb3ccf381a81", "message": "Check rule violation on last valid partials #8368\n\n* PartialConfigService#onFailedPartialConfig was a no-op earlier.\n  In cases where the config repo parse failed with the latest commit\n  but had a last valid partial, any rule changes were not applied till\n  the config repo parse was successful.\n  Now config_repo parse failures checks rule violation on last\n  valid partial.", "committedDate": "2020-07-24T03:55:18Z", "type": "commit"}]}