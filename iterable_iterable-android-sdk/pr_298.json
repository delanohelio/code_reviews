{"pr_number": 298, "pr_title": "[MOB-2411] - Offline flag in config", "pr_author": "Ayyanchira", "pr_createdAt": "2020-12-16T17:42:02Z", "pr_url": "https://github.com/Iterable/iterable-android-sdk/pull/298", "merge_commit": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU3MjQzNQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/298#discussion_r544572435", "body": "I think this is confusing.. `setRequestProcessor(true, context)` - for a setter, I'd expect it to take some kind of a `RequestProcessor` class.. What `true` means in this case isn't clear. And do we need to pass a `Context` here?", "bodyText": "I think this is confusing.. setRequestProcessor(true, context) - for a setter, I'd expect it to take some kind of a RequestProcessor class.. What true means in this case isn't clear. And do we need to pass a Context here?", "bodyHTML": "<p dir=\"auto\">I think this is confusing.. <code>setRequestProcessor(true, context)</code> - for a setter, I'd expect it to take some kind of a <code>RequestProcessor</code> class.. What <code>true</code> means in this case isn't clear. And do we need to pass a <code>Context</code> here?</p>", "author": "vbabenkoru", "createdAt": "2020-12-16T19:40:50Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -306,6 +306,9 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n             sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n+        if(sharedInstance.config.offlineProcessing) {\n+            apiClient.setRequestProcessor(true, context);", "originalCommit": "3e174aba83af38daa5b947715de70adfd6084f46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5c0a39a8c3c8f0d25ef158427269324c52d4f8d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 84685a40..ac6552d0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -307,7 +307,7 @@ private static final String TAG = \"IterableApi\";\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n         if(sharedInstance.config.offlineProcessing) {\n-            apiClient.setRequestProcessor(true, context);\n+            sharedInstance.apiClient.enableOfflineProcessing(true);\n         }\n         IterablePushActionReceiver.processPendingAction(context);\n     }\n", "next_change": {"commit": "c849c12181ecf68bfd6f36b291a3cacb0a03eac8", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex ac6552d0..18c7f23a 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -306,7 +306,7 @@ private static final String TAG = \"IterableApi\";\n             sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n-        if(sharedInstance.config.offlineProcessing) {\n+        if (sharedInstance.config.offlineProcessing) {\n             sharedInstance.apiClient.enableOfflineProcessing(true);\n         }\n         IterablePushActionReceiver.processPendingAction(context);\n", "next_change": {"commit": "0df1d13e97f4309ceeffaa44eced378bf1bbbea8", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 18c7f23a..2ac602db 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -306,9 +306,7 @@ private static final String TAG = \"IterableApi\";\n             sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n-        if (sharedInstance.config.offlineProcessing) {\n-            sharedInstance.apiClient.enableOfflineProcessing(true);\n-        }\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(true);\n         IterablePushActionReceiver.processPendingAction(context);\n     }\n \n", "next_change": {"commit": "2054682a3e1a1739799491e1a485e8eba2b3fe2c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 2ac602db..e085947f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -306,7 +306,7 @@ private static final String TAG = \"IterableApi\";\n             sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(true);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(sharedInstance.config.offlineProcessing);\n         IterablePushActionReceiver.processPendingAction(context);\n     }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 84685a40..e085947f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -306,9 +306,7 @@ private static final String TAG = \"IterableApi\";\n             sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n-        if(sharedInstance.config.offlineProcessing) {\n-            apiClient.setRequestProcessor(true, context);\n-        }\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(sharedInstance.config.offlineProcessing);\n         IterablePushActionReceiver.processPendingAction(context);\n     }\n \n", "next_change": {"commit": "cd6b41db6c9114d1b6a7bfb49b5ff4cb5b0771e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e085947f..be054798 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -310,6 +310,24 @@ private static final String TAG = \"IterableApi\";\n         IterablePushActionReceiver.processPendingAction(context);\n     }\n \n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                try {\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(data.getBoolean(\"offlineModeBeta\"));\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"OfflineMode parameter not found\");\n+                }\n+            }\n+        }, new IterableHelper.FailureHandler() {\n+            @Override\n+            public void onFailure(@NonNull String reason, @Nullable JSONObject data) {\n+                IterableLogger.e(TAG, \"Failed to fetch remote configuration. Default values will be used\");\n+            }\n+        });\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "19b2053245b7171ddffbc4046af8c2a6ab616443", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex be054798..2bb65119 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -311,20 +311,16 @@ private static final String TAG = \"IterableApi\";\n     }\n \n     void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.SuccessHandler() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n             @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n+            public void execute(@Nullable String data) {\n                 try {\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(data.getBoolean(\"offlineModeBeta\"));\n+                    JSONObject jsonData = new JSONObject(data);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(jsonData.getBoolean(\"offlineModeBeta\"));\n                 } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"OfflineMode parameter not found\");\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n                 }\n             }\n-        }, new IterableHelper.FailureHandler() {\n-            @Override\n-            public void onFailure(@NonNull String reason, @Nullable JSONObject data) {\n-                IterableLogger.e(TAG, \"Failed to fetch remote configuration. Default values will be used\");\n-            }\n         });\n     }\n \n", "next_change": {"commit": "1402e45e7e57cc21915beed35588ebd81ada1627", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 2bb65119..91797365 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -306,17 +306,28 @@ private static final String TAG = \"IterableApi\";\n             sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(sharedInstance.config.offlineProcessing);\n+        loadLastSavedConfiguration(context);\n         IterablePushActionReceiver.processPendingAction(context);\n     }\n \n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    }\n+\n     void fetchRemoteConfiguration() {\n         apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n             @Override\n             public void execute(@Nullable String data) {\n                 try {\n                     JSONObject jsonData = new JSONObject(data);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(jsonData.getBoolean(\"offlineModeBeta\"));\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, offlineConfiguration);\n+                    editor.apply();\n                 } catch (JSONException e) {\n                     IterableLogger.e(TAG, \"Failed to read remote configuration\");\n                 }\n", "next_change": {"commit": "2db97108c261008ed4b1d5f29c70eaa4318b1275", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 91797365..a15c5c9b 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -335,6 +339,10 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "3287dc085a83f1e75e09982baad3625fb6684b8c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex a15c5c9b..3c9e5cd9 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,10 +339,6 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "ea141c605aca86d0d85418a66a8f1296263454d5", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd9..882bb40d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,6 +339,10 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40d..45c33cc0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,10 +339,6 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "b7e917f87f001eb456bcefc0039751a451713647", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc0..ee7cf34b 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,6 +339,10 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "bd0594f237559bdcb0c0c15f8d1b2e38977c0972", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex ee7cf34b..fc9cbc43 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,10 +339,6 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "42ae0158572533f77068dc93e7c01807f61c29da", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex fc9cbc43..9e125a77 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,6 +339,10 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "0818f8d620d08706d7157875d42030ea55730fe4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9e125a77..129e8fae 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,10 +339,6 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 129e8fae..b03b5b15 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,149 +249,17 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n         boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && _userId.equals(userId)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b15..9b34a0d3 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d3..96f643f0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40d..45c33cc0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -350,6 +346,10 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n", "next_change": {"commit": "4100141101fdf973d456cd14e7c70478fe3b0024", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc0..baad2550 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -351,7 +351,9 @@ private static final String TAG = \"IterableApi\";\n     }\n \n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n         if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex baad2550..b03b5b15 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,155 +249,12 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n         boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n     private void checkAndUpdateAuthToken(@Nullable String authToken) {\n         // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n         if (config.authHandler != null && authToken != null && authToken != _authToken) {\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b15..9b34a0d3 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d3..96f643f0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd9..882bb40d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -346,7 +350,7 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n-    public void setEmail(@Nullable String email) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40d..45c33cc0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -350,6 +346,10 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n", "next_change": {"commit": "4100141101fdf973d456cd14e7c70478fe3b0024", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc0..baad2550 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -351,7 +351,9 @@ private static final String TAG = \"IterableApi\";\n     }\n \n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n         if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex baad2550..b03b5b15 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,155 +249,12 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n         boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n     private void checkAndUpdateAuthToken(@Nullable String authToken) {\n         // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n         if (config.authHandler != null && authToken != null && authToken != _authToken) {\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b15..9b34a0d3 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d3..96f643f0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex a15c5c9b..3c9e5cd9 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -350,7 +346,7 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+    public void setEmail(@Nullable String email) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "ea141c605aca86d0d85418a66a8f1296263454d5", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd9..882bb40d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -346,7 +350,7 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n-    public void setEmail(@Nullable String email) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40d..45c33cc0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -350,6 +346,10 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n", "next_change": {"commit": "4100141101fdf973d456cd14e7c70478fe3b0024", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc0..baad2550 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -351,7 +351,9 @@ private static final String TAG = \"IterableApi\";\n     }\n \n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n         if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex baad2550..b03b5b15 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,155 +249,12 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n         boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n     private void checkAndUpdateAuthToken(@Nullable String authToken) {\n         // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n         if (config.authHandler != null && authToken != null && authToken != _authToken) {\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b15..9b34a0d3 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d3..96f643f0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd9..882bb40d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -355,16 +359,13 @@ private static final String TAG = \"IterableApi\";\n             return;\n         }\n \n-        onLogOut();\n+        logoutPreviousUser();\n+\n         _email = email;\n         _userId = null;\n         storeAuthData();\n \n-        if (email != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40d..45c33cc0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,7 +365,11 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-        onLogin(authToken);\n+        if (email != null) {\n+            getAuthManager().requestNewAuthToken(false);\n+        } else {\n+            setAuthToken(null);\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "b6b77024af90a60aecb60d6f15264ab69f1b571b", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc0..6496d512 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,11 +365,13 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-        if (email != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+//        if (email != null) {\n+//            getAuthManager().requestNewAuthToken(false);\n+//        } else {\n+//            setAuthToken(null);\n+//        }\n+\n+        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "ae2dedfa1de5ec18c047fa1edb42c431570702af", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 6496d512..c0152305 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,12 +365,6 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-//        if (email != null) {\n-//            getAuthManager().requestNewAuthToken(false);\n-//        } else {\n-//            setAuthToken(null);\n-//        }\n-\n         onLogin(authToken);\n     }\n \n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex c0152305..b03b5b15 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,149 +249,17 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, false);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && _userId.equals(userId)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b15..9b34a0d3 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d3..96f643f0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "message": "Merge commit", "committedDate": null}, {"oid": "68888566277f1960bfe6dd8758af6ae0aed8fa61", "committedDate": "2020-12-22 16:51:00 -0800", "message": "[MOB - 2371] - Delete all tasks on log out"}, {"oid": "cd6b41db6c9114d1b6a7bfb49b5ff4cb5b0771e4", "committedDate": "2021-01-21 09:07:08 -0800", "message": "[MOB-2437] - Get Remote Configuration"}, {"oid": "19b2053245b7171ddffbc4046af8c2a6ab616443", "committedDate": "2021-01-24 20:54:50 -0800", "message": "Revision"}, {"oid": "1402e45e7e57cc21915beed35588ebd81ada1627", "committedDate": "2021-01-24 23:22:41 -0800", "message": "[MOB-2531] - Persist offline configuration"}, {"oid": "5e3325282a8ca0b7d616e74cd77b0f4e56808787", "committedDate": "2021-01-26 16:02:26 -0800", "message": "[MOB - 2541] - Remove offline configuration from IterableConfig"}, {"oid": "007de2da38292f32cdcb8428a1569c2a57dcfe39", "committedDate": "2021-03-30 21:29:22 -0700", "message": "Remove deprecated in-app methods"}, {"oid": "04755b525a3af290282635eb5b496be17799837e", "committedDate": "2021-06-15 18:36:27 +0530", "message": "[MOB-2971] - Set Context method"}, {"oid": "4d221c5296169c326474e265cc85cb52953a1f94", "committedDate": "2021-06-29 15:38:39 -0700", "message": "remove deferred deep linking leftover code"}, {"oid": "29f3fa8e0e7f0ea8178182d656f97af0e976d40f", "committedDate": "2021-07-07 11:28:56 -0700", "message": "remove unused imports"}, {"oid": "cd62e812fb99448f0f9de8a9fe8a7a62b196484d", "committedDate": "2021-07-21 15:36:47 -0700", "message": "add updateCart API and tests"}, {"oid": "e4bba683b7e9d9718551f6be2343f2c7bd74c0aa", "committedDate": "2021-07-26 17:23:15 -0700", "message": "remove top level dataFields"}, {"oid": "042aa82f4d7faeaf4cff15be7ed89eeced9d1a5a", "committedDate": "2021-11-02 16:47:02 -0700", "message": "add various comments to API"}, {"oid": "8710ccccfa2c65825ce37281c1b0ad654ac7e75e", "committedDate": "2021-11-02 16:48:35 -0700", "message": "comments + rearranging for clarity"}, {"oid": "b429250ccf99a17d245a4f6c208e16610611dd1c", "committedDate": "2021-11-02 16:49:32 -0700", "message": "move better"}, {"oid": "27640f08182c5b4b72e57a35abcdcd5a64389897", "committedDate": "2021-11-02 16:50:06 -0700", "message": "android studio spacing"}, {"oid": "8b0a852fd5abdb2bb830e6f544026aab5ff5a163", "committedDate": "2021-11-02 17:01:05 -0700", "message": "allow trackInAppClose to have a clickedUrl null"}, {"oid": "788e949c96e990b6f38bb4f3eecf6f495f6170f2", "committedDate": "2021-11-02 17:14:35 -0700", "message": "make trackInAppClose public"}, {"oid": "a25ec805df060991fb94eccc3c19958650866398", "committedDate": "2021-12-16 16:11:54 -0800", "message": "change deep link API to be instanced"}, {"oid": "d2ec0735f16292d4c6a2510eb819613dc274c5e4", "committedDate": "2021-12-16 17:55:22 -0800", "message": "implement protocol blocking"}, {"oid": "a278c7d773a62a1e356ac47263b4e12bea2373d7", "committedDate": "2021-12-20 09:33:01 -0800", "message": "try different empty array in config builder"}, {"oid": "d980fcec7d0e1978f7099aa08f73ba30b7849f02", "committedDate": "2021-12-22 11:02:34 -0800", "message": "Patch 1"}, {"oid": "00446867595361e4c3787247761bf5806acbdefe", "committedDate": "2021-12-22 13:37:09 -0800", "message": "Suggested modifications"}, {"oid": "2bfb786453bdc527544450f336e5a12990a98169", "committedDate": "2021-12-22 14:40:04 -0800", "message": "Remove allowedProtocols passing between modules"}, {"oid": "059e840ddedb21a50e7f1b0c270f56bf28ebc95b", "committedDate": "2022-01-10 08:36:20 -0800", "message": "Moving PushAction Receiver code to a common util function"}, {"oid": "bd1525fae2ba9f59c5ea3a545edb50c10aa4e8c8", "committedDate": "2022-02-22 08:54:16 -0800", "message": "[MOB-4068] - Reset jwtToken when logging out"}, {"oid": "edd7de3e2a5f38135e28628321cdb48ed5770739", "committedDate": "2022-04-04 10:56:15 -0700", "message": "[MOB-4266] - Make trackPushOpen Public"}, {"oid": "ad081e7d724ae238fc0347acee83fd692686a33c", "committedDate": "2022-05-25 11:32:00 -0700", "message": "add deprecation tags"}, {"oid": "ef1f3da25f7c66989ee1f39502506790f74362e4", "committedDate": "2022-05-25 11:35:29 -0700", "message": "add utility check of email or id existence"}, {"oid": "2db97108c261008ed4b1d5f29c70eaa4318b1275", "committedDate": "2022-05-25 14:20:53 -0700", "message": "match names to iOS and implement same JWT paths"}, {"oid": "8503911cd750598a56a98b1e8df4f0ed676cb388", "committedDate": "2022-05-25 16:50:35 -0700", "message": "remove unnecessary method"}, {"oid": "3287dc085a83f1e75e09982baad3625fb6684b8c", "committedDate": "2022-05-27 12:16:58 -0700", "message": "[MOB - 4260] - Check device token before disabling"}, {"oid": "ea141c605aca86d0d85418a66a8f1296263454d5", "committedDate": "2022-06-02 16:05:18 -0700", "message": "direct updateEmail to specific catch all call"}, {"oid": "a97b5c87477bf940a89ec91aef427ee2a1d44d44", "committedDate": "2022-06-06 15:34:16 -0700", "message": "syntax"}, {"oid": "5cca36845fcf0bb85893ba45507deb41a8debc81", "committedDate": "2022-06-08 16:30:06 -0700", "message": "add more user validity checks, add to userId"}, {"oid": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "committedDate": "2022-06-21 14:46:25 -0700", "message": "renames"}, {"oid": "b6b77024af90a60aecb60d6f15264ab69f1b571b", "committedDate": "2022-06-21 15:03:43 -0700", "message": "refactor post login actions"}, {"oid": "ae2dedfa1de5ec18c047fa1edb42c431570702af", "committedDate": "2022-06-22 13:20:39 -0700", "message": "pass along auth token on set"}, {"oid": "b7e917f87f001eb456bcefc0039751a451713647", "committedDate": "2022-06-30 17:35:25 -0700", "message": "Merge branch 'master' into jay/MOB-4439-update-email"}, {"oid": "bd0594f237559bdcb0c0c15f8d1b2e38977c0972", "committedDate": "2022-07-11 09:42:49 -0700", "message": "[MOB-4537] - Change from beta to SDKOfflineMode"}, {"oid": "b0e3f885090fc151951df5b0e7a6563ea9f797ee", "committedDate": "2022-07-11 13:38:51 -0700", "message": "Made recommended changes"}, {"oid": "5f7f0a10b5eed3b912ec1851ee4bc4c221a44cc4", "committedDate": "2022-07-13 16:26:20 -0700", "message": "Merge pull request #448 from Iterable/MOB-4260-check-device-token-before-disabling"}, {"oid": "42ae0158572533f77068dc93e7c01807f61c29da", "committedDate": "2022-07-15 11:40:29 -0700", "message": "Merge branch 'master' into jay/MOB-4439-update-email"}, {"oid": "0818f8d620d08706d7157875d42030ea55730fe4", "committedDate": "2022-07-18 16:15:56 -0700", "message": "fix merge error"}, {"oid": "1fba3863b456c7e54ef330f6f230172e20ac77d4", "committedDate": "2022-08-02 10:41:54 -0700", "message": "set by field"}, {"oid": "4100141101fdf973d456cd14e7c70478fe3b0024", "committedDate": "2022-08-03 09:48:16 -0700", "message": "SetEmail and SetUserID to accept new authToken"}, {"oid": "8439966304b76aba941564188db77be8bfc75047", "committedDate": "2022-08-09 12:44:26 -0700", "message": "Making setAuthToken public"}, {"oid": "25acec4bad334751cb3de23e5fe228afb2d1330d", "committedDate": "2022-08-25 16:02:29 -0700", "message": "initial reorg"}, {"oid": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "committedDate": "2022-08-25 16:15:13 -0700", "message": "part 2"}, {"oid": "4caf9d620d8e9e51ea51e5d0fd4085b4c323ad64", "committedDate": "2022-08-29 11:23:03 -0700", "message": "remove unused import"}, {"oid": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "committedDate": "2022-08-29 14:56:48 -0700", "message": "move private/internal to the top"}, {"oid": "746622f1ae432f695678552ded793886700e8391", "committedDate": "2022-08-29 15:13:06 -0700", "message": "move main instance to the top"}, {"oid": "e6c4349377a9bc31054035be5ee860fad9c6cc66", "committedDate": "2022-08-29 15:13:54 -0700", "message": "android studio auto spacing"}, {"oid": "c463f636c63ac87817cb106aea9304bc315c2328", "committedDate": "2023-02-26 13:53:10 -0800", "message": "Log warn instead of error"}, {"oid": "898f9e91c38f6911e9ef442bf7c43e825566ab25", "committedDate": "2023-03-16 22:05:34 +0530", "message": "For firetv call update user with device details upon initialization"}, {"oid": "6f55d7ffbb159f0da019022442ca49b4dec7607b", "committedDate": "2023-03-20 17:16:30 +0530", "message": "Fix firetv object structure"}, {"oid": "fb3870743b91925e02250bc2f039af1c90eb4eca", "committedDate": "2023-03-21 23:39:47 -0400", "message": "[MOB - 5873] - Public getters for Email UserID and Auth"}, {"oid": "cb0e4c36556bee6d9c7b6731398e88e290a35325", "committedDate": "2023-03-21 23:49:09 -0400", "message": "[MOB - 5874] - Schedule auth refresh when auth null"}, {"oid": "4aea9b25979421e60176a15d7b1b3b7761d0e2df", "committedDate": "2023-03-22 19:03:48 -0400", "message": "Merge pull request #534 from Iterable/MOB-5874-authToken-refresh-when-null"}, {"oid": "6c0a9a2cf75a3cf190afe0332616a983b061c09f", "committedDate": "2023-04-03 10:58:42 -0700", "message": "Merge branch 'master' into firetv-updateuser-fix"}, {"oid": "37f07c4f78e6ee8a6ded0b73596d9c936c550f4d", "committedDate": "2023-05-02 10:54:06 -0700", "message": "Merge pull request #474 from Iterable/jay/MOB-4666-in-apps-config-memory"}, {"oid": "e23204965fe605644365a5d4628262e8dd0b8059", "committedDate": "2023-05-10 20:12:24 -0700", "message": "Merge branch 'master' into firetv-updateuser-fix"}, {"oid": "62ac73eaa6930051118365734add3250e52185d2", "committedDate": "2023-05-17 13:50:41 -0700", "message": "[MOB-6055] - [OMNI CG] - Add callbacks to setting email/user id (#570)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU3Mzc0MA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/298#discussion_r544573740", "body": "This should be package-private for now, since it's not ready for production use yet.", "bodyText": "This should be package-private for now, since it's not ready for production use yet.", "bodyHTML": "<p dir=\"auto\">This should be package-private for now, since it's not ready for production use yet.</p>", "author": "vbabenkoru", "createdAt": "2020-12-16T19:42:39Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java", "diffHunk": "@@ -218,6 +224,16 @@ public Builder setExpiringAuthTokenRefreshPeriod(@NonNull Long period) {\n             return this;\n         }\n \n+        /**\n+         * When set to true, the SDK will capture events when the device goes offline.\n+         * @param offlineProcessing Auth handler provided by the app\n+         */\n+        @NonNull\n+        public Builder setOfflineProcessing(@NonNull boolean offlineProcessing) {", "originalCommit": "3e174aba83af38daa5b947715de70adfd6084f46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5c0a39a8c3c8f0d25ef158427269324c52d4f8d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\nindex 98d99b98..b04d6163 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\n", "chunk": "@@ -226,10 +226,10 @@ public class IterableConfig {\n \n         /**\n          * When set to true, the SDK will capture events when the device goes offline.\n-         * @param offlineProcessing Auth handler provided by the app\n+         * @param offlineProcessing boolean which will enable offline processing\n          */\n         @NonNull\n-        public Builder setOfflineProcessing(@NonNull boolean offlineProcessing) {\n+        Builder setOfflineProcessing(@NonNull boolean offlineProcessing) {\n             this.offlineProcessing = offlineProcessing;\n             return this;\n         }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\nindex 98d99b98..b04d6163 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\n", "chunk": "@@ -226,10 +226,10 @@ public class IterableConfig {\n \n         /**\n          * When set to true, the SDK will capture events when the device goes offline.\n-         * @param offlineProcessing Auth handler provided by the app\n+         * @param offlineProcessing boolean which will enable offline processing\n          */\n         @NonNull\n-        public Builder setOfflineProcessing(@NonNull boolean offlineProcessing) {\n+        Builder setOfflineProcessing(@NonNull boolean offlineProcessing) {\n             this.offlineProcessing = offlineProcessing;\n             return this;\n         }\n", "next_change": {"commit": "5e3325282a8ca0b7d616e74cd77b0f4e56808787", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\nindex b04d6163..bd5bc98d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\n", "chunk": "@@ -224,16 +217,6 @@ public class IterableConfig {\n             return this;\n         }\n \n-        /**\n-         * When set to true, the SDK will capture events when the device goes offline.\n-         * @param offlineProcessing boolean which will enable offline processing\n-         */\n-        @NonNull\n-        Builder setOfflineProcessing(@NonNull boolean offlineProcessing) {\n-            this.offlineProcessing = offlineProcessing;\n-            return this;\n-        }\n-\n         @NonNull\n         public IterableConfig build() {\n             return new IterableConfig(this);\n", "next_change": {"commit": "b69ef8ed527f29adb44b642e1611197b6a41f574", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\nindex bd5bc98d..582f1384 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\n", "chunk": "@@ -217,6 +206,12 @@ public class IterableConfig {\n             return this;\n         }\n \n+        @NonNull\n+        public Builder setAllowedProtocols(@NonNull String[] allowedProtocols) {\n+            this.allowedProtocols = allowedProtocols;\n+            return this;\n+        }\n+\n         @NonNull\n         public IterableConfig build() {\n             return new IterableConfig(this);\n", "next_change": {"commit": "37f07c4f78e6ee8a6ded0b73596d9c936c550f4d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\nindex 582f1384..78eaaf5c 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConfig.java\n", "chunk": "@@ -206,12 +216,27 @@ public class IterableConfig {\n             return this;\n         }\n \n+        /**\n+         * Set what URLs the SDK should allow to open (in addition to `https`)\n+         * @param allowedProtocols an array/list of protocols (e.g. `http`, `tel`)\n+         */\n         @NonNull\n         public Builder setAllowedProtocols(@NonNull String[] allowedProtocols) {\n             this.allowedProtocols = allowedProtocols;\n             return this;\n         }\n \n+        /**\n+         * Set whether the SDK should store in-apps only in memory, or in file storage\n+         * @param useInMemoryStorageForInApps `true` will have in-apps be only in memory\n+         */\n+\n+        @NonNull\n+        public Builder setUseInMemoryStorageForInApps(boolean useInMemoryStorageForInApps) {\n+            this.useInMemoryStorageForInApps = useInMemoryStorageForInApps;\n+            return this;\n+        }\n+\n         @NonNull\n         public IterableConfig build() {\n             return new IterableConfig(this);\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "message": "Merge commit", "committedDate": null}, {"oid": "5e3325282a8ca0b7d616e74cd77b0f4e56808787", "committedDate": "2021-01-26 16:02:26 -0800", "message": "[MOB - 2541] - Remove offline configuration from IterableConfig"}, {"oid": "d89c2e5f2fef316ee3c3d560ffdc77ffc85937ab", "committedDate": "2021-03-30 21:46:09 -0700", "message": "Remove legacyGCMSenderId"}, {"oid": "b69ef8ed527f29adb44b642e1611197b6a41f574", "committedDate": "2021-12-01 16:53:04 -0800", "message": "add allowedProtocols to config"}, {"oid": "8646cd02d97f579144210068faceb03199a83453", "committedDate": "2021-12-02 15:56:10 -0800", "message": "add comment doc for protocols in config"}, {"oid": "9e0a29fa278f674f23f3b72b92c55e1b3fd2e646", "committedDate": "2021-12-17 14:46:21 -0800", "message": "try different empty array in config builder"}, {"oid": "ad081e7d724ae238fc0347acee83fd692686a33c", "committedDate": "2022-05-25 11:32:00 -0700", "message": "add deprecation tags"}, {"oid": "37f07c4f78e6ee8a6ded0b73596d9c936c550f4d", "committedDate": "2023-05-02 10:54:06 -0700", "message": "Merge pull request #474 from Iterable/jay/MOB-4666-in-apps-config-memory"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU3NDQ3MA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/298#discussion_r544574470", "body": "Do we need to make this static?", "bodyText": "Do we need to make this static?", "bodyHTML": "<p dir=\"auto\">Do we need to make this static?</p>", "author": "vbabenkoru", "createdAt": "2020-12-16T19:43:52Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -48,7 +48,7 @@\n     private String _deviceId;\n     private boolean _firstForegroundHandled;\n \n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    static IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());", "originalCommit": "3e174aba83af38daa5b947715de70adfd6084f46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU4MDQ5Ng==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/298#discussion_r544580496", "bodyText": "Couldn't figure out a way around! \ud83d\ude15\nBecause initialize was a good place to setRequestProcessor; and because initialize was static, it was asking to make apiClient as static as well.", "author": "Ayyanchira", "createdAt": "2020-12-16T19:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU3NDQ3MA=="}], "type": "inlineReview", "revised_code": {"commit": "e5c0a39a8c3c8f0d25ef158427269324c52d4f8d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 84685a40..ac6552d0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -48,7 +48,7 @@ private static final String TAG = \"IterableApi\";\n     private String _deviceId;\n     private boolean _firstForegroundHandled;\n \n-    static IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n     private @Nullable IterableInAppManager inAppManager;\n     private String inboxSessionId;\n     private IterableAuthManager authManager;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 84685a40..e085947f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -48,7 +48,7 @@ private static final String TAG = \"IterableApi\";\n     private String _deviceId;\n     private boolean _firstForegroundHandled;\n \n-    static IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n     private @Nullable IterableInAppManager inAppManager;\n     private String inboxSessionId;\n     private IterableAuthManager authManager;\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e085947f..9b34a0d3 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -26,39 +23,43 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-\n-//region Variables\n+//region SDK initialization\n //---------------------------------------------------------------------------------------\n-private static final String TAG = \"IterableApi\";\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n+    }\n \n-    /**\n-     * {@link IterableApi} singleton instance\n-     */\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n+    }\n \n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n+        }\n \n-//---------------------------------------------------------------------------------------\n-//endregion\n+        sharedInstance.retrieveEmailAndUserId();\n \n-//region Constructor\n-//---------------------------------------------------------------------------------------\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n+\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n+    }\n+\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    }\n \n     IterableApi() {\n         config = new IterableConfig.Builder().build();\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d3..96f643f0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "message": "Merge commit", "committedDate": null}, {"oid": "68888566277f1960bfe6dd8758af6ae0aed8fa61", "committedDate": "2020-12-22 16:51:00 -0800", "message": "[MOB - 2371] - Delete all tasks on log out"}, {"oid": "cd6b41db6c9114d1b6a7bfb49b5ff4cb5b0771e4", "committedDate": "2021-01-21 09:07:08 -0800", "message": "[MOB-2437] - Get Remote Configuration"}, {"oid": "19b2053245b7171ddffbc4046af8c2a6ab616443", "committedDate": "2021-01-24 20:54:50 -0800", "message": "Revision"}, {"oid": "1402e45e7e57cc21915beed35588ebd81ada1627", "committedDate": "2021-01-24 23:22:41 -0800", "message": "[MOB-2531] - Persist offline configuration"}, {"oid": "5e3325282a8ca0b7d616e74cd77b0f4e56808787", "committedDate": "2021-01-26 16:02:26 -0800", "message": "[MOB - 2541] - Remove offline configuration from IterableConfig"}, {"oid": "007de2da38292f32cdcb8428a1569c2a57dcfe39", "committedDate": "2021-03-30 21:29:22 -0700", "message": "Remove deprecated in-app methods"}, {"oid": "04755b525a3af290282635eb5b496be17799837e", "committedDate": "2021-06-15 18:36:27 +0530", "message": "[MOB-2971] - Set Context method"}, {"oid": "4d221c5296169c326474e265cc85cb52953a1f94", "committedDate": "2021-06-29 15:38:39 -0700", "message": "remove deferred deep linking leftover code"}, {"oid": "29f3fa8e0e7f0ea8178182d656f97af0e976d40f", "committedDate": "2021-07-07 11:28:56 -0700", "message": "remove unused imports"}, {"oid": "cd62e812fb99448f0f9de8a9fe8a7a62b196484d", "committedDate": "2021-07-21 15:36:47 -0700", "message": "add updateCart API and tests"}, {"oid": "e4bba683b7e9d9718551f6be2343f2c7bd74c0aa", "committedDate": "2021-07-26 17:23:15 -0700", "message": "remove top level dataFields"}, {"oid": "042aa82f4d7faeaf4cff15be7ed89eeced9d1a5a", "committedDate": "2021-11-02 16:47:02 -0700", "message": "add various comments to API"}, {"oid": "8710ccccfa2c65825ce37281c1b0ad654ac7e75e", "committedDate": "2021-11-02 16:48:35 -0700", "message": "comments + rearranging for clarity"}, {"oid": "b429250ccf99a17d245a4f6c208e16610611dd1c", "committedDate": "2021-11-02 16:49:32 -0700", "message": "move better"}, {"oid": "27640f08182c5b4b72e57a35abcdcd5a64389897", "committedDate": "2021-11-02 16:50:06 -0700", "message": "android studio spacing"}, {"oid": "8b0a852fd5abdb2bb830e6f544026aab5ff5a163", "committedDate": "2021-11-02 17:01:05 -0700", "message": "allow trackInAppClose to have a clickedUrl null"}, {"oid": "788e949c96e990b6f38bb4f3eecf6f495f6170f2", "committedDate": "2021-11-02 17:14:35 -0700", "message": "make trackInAppClose public"}, {"oid": "a25ec805df060991fb94eccc3c19958650866398", "committedDate": "2021-12-16 16:11:54 -0800", "message": "change deep link API to be instanced"}, {"oid": "d2ec0735f16292d4c6a2510eb819613dc274c5e4", "committedDate": "2021-12-16 17:55:22 -0800", "message": "implement protocol blocking"}, {"oid": "a278c7d773a62a1e356ac47263b4e12bea2373d7", "committedDate": "2021-12-20 09:33:01 -0800", "message": "try different empty array in config builder"}, {"oid": "d980fcec7d0e1978f7099aa08f73ba30b7849f02", "committedDate": "2021-12-22 11:02:34 -0800", "message": "Patch 1"}, {"oid": "00446867595361e4c3787247761bf5806acbdefe", "committedDate": "2021-12-22 13:37:09 -0800", "message": "Suggested modifications"}, {"oid": "2bfb786453bdc527544450f336e5a12990a98169", "committedDate": "2021-12-22 14:40:04 -0800", "message": "Remove allowedProtocols passing between modules"}, {"oid": "059e840ddedb21a50e7f1b0c270f56bf28ebc95b", "committedDate": "2022-01-10 08:36:20 -0800", "message": "Moving PushAction Receiver code to a common util function"}, {"oid": "bd1525fae2ba9f59c5ea3a545edb50c10aa4e8c8", "committedDate": "2022-02-22 08:54:16 -0800", "message": "[MOB-4068] - Reset jwtToken when logging out"}, {"oid": "edd7de3e2a5f38135e28628321cdb48ed5770739", "committedDate": "2022-04-04 10:56:15 -0700", "message": "[MOB-4266] - Make trackPushOpen Public"}, {"oid": "ad081e7d724ae238fc0347acee83fd692686a33c", "committedDate": "2022-05-25 11:32:00 -0700", "message": "add deprecation tags"}, {"oid": "ef1f3da25f7c66989ee1f39502506790f74362e4", "committedDate": "2022-05-25 11:35:29 -0700", "message": "add utility check of email or id existence"}, {"oid": "2db97108c261008ed4b1d5f29c70eaa4318b1275", "committedDate": "2022-05-25 14:20:53 -0700", "message": "match names to iOS and implement same JWT paths"}, {"oid": "8503911cd750598a56a98b1e8df4f0ed676cb388", "committedDate": "2022-05-25 16:50:35 -0700", "message": "remove unnecessary method"}, {"oid": "3287dc085a83f1e75e09982baad3625fb6684b8c", "committedDate": "2022-05-27 12:16:58 -0700", "message": "[MOB - 4260] - Check device token before disabling"}, {"oid": "ea141c605aca86d0d85418a66a8f1296263454d5", "committedDate": "2022-06-02 16:05:18 -0700", "message": "direct updateEmail to specific catch all call"}, {"oid": "a97b5c87477bf940a89ec91aef427ee2a1d44d44", "committedDate": "2022-06-06 15:34:16 -0700", "message": "syntax"}, {"oid": "5cca36845fcf0bb85893ba45507deb41a8debc81", "committedDate": "2022-06-08 16:30:06 -0700", "message": "add more user validity checks, add to userId"}, {"oid": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "committedDate": "2022-06-21 14:46:25 -0700", "message": "renames"}, {"oid": "b6b77024af90a60aecb60d6f15264ab69f1b571b", "committedDate": "2022-06-21 15:03:43 -0700", "message": "refactor post login actions"}, {"oid": "ae2dedfa1de5ec18c047fa1edb42c431570702af", "committedDate": "2022-06-22 13:20:39 -0700", "message": "pass along auth token on set"}, {"oid": "b7e917f87f001eb456bcefc0039751a451713647", "committedDate": "2022-06-30 17:35:25 -0700", "message": "Merge branch 'master' into jay/MOB-4439-update-email"}, {"oid": "bd0594f237559bdcb0c0c15f8d1b2e38977c0972", "committedDate": "2022-07-11 09:42:49 -0700", "message": "[MOB-4537] - Change from beta to SDKOfflineMode"}, {"oid": "b0e3f885090fc151951df5b0e7a6563ea9f797ee", "committedDate": "2022-07-11 13:38:51 -0700", "message": "Made recommended changes"}, {"oid": "5f7f0a10b5eed3b912ec1851ee4bc4c221a44cc4", "committedDate": "2022-07-13 16:26:20 -0700", "message": "Merge pull request #448 from Iterable/MOB-4260-check-device-token-before-disabling"}, {"oid": "42ae0158572533f77068dc93e7c01807f61c29da", "committedDate": "2022-07-15 11:40:29 -0700", "message": "Merge branch 'master' into jay/MOB-4439-update-email"}, {"oid": "0818f8d620d08706d7157875d42030ea55730fe4", "committedDate": "2022-07-18 16:15:56 -0700", "message": "fix merge error"}, {"oid": "1fba3863b456c7e54ef330f6f230172e20ac77d4", "committedDate": "2022-08-02 10:41:54 -0700", "message": "set by field"}, {"oid": "4100141101fdf973d456cd14e7c70478fe3b0024", "committedDate": "2022-08-03 09:48:16 -0700", "message": "SetEmail and SetUserID to accept new authToken"}, {"oid": "8439966304b76aba941564188db77be8bfc75047", "committedDate": "2022-08-09 12:44:26 -0700", "message": "Making setAuthToken public"}, {"oid": "25acec4bad334751cb3de23e5fe228afb2d1330d", "committedDate": "2022-08-25 16:02:29 -0700", "message": "initial reorg"}, {"oid": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "committedDate": "2022-08-25 16:15:13 -0700", "message": "part 2"}, {"oid": "4caf9d620d8e9e51ea51e5d0fd4085b4c323ad64", "committedDate": "2022-08-29 11:23:03 -0700", "message": "remove unused import"}, {"oid": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "committedDate": "2022-08-29 14:56:48 -0700", "message": "move private/internal to the top"}, {"oid": "746622f1ae432f695678552ded793886700e8391", "committedDate": "2022-08-29 15:13:06 -0700", "message": "move main instance to the top"}, {"oid": "e6c4349377a9bc31054035be5ee860fad9c6cc66", "committedDate": "2022-08-29 15:13:54 -0700", "message": "android studio auto spacing"}, {"oid": "c463f636c63ac87817cb106aea9304bc315c2328", "committedDate": "2023-02-26 13:53:10 -0800", "message": "Log warn instead of error"}, {"oid": "898f9e91c38f6911e9ef442bf7c43e825566ab25", "committedDate": "2023-03-16 22:05:34 +0530", "message": "For firetv call update user with device details upon initialization"}, {"oid": "6f55d7ffbb159f0da019022442ca49b4dec7607b", "committedDate": "2023-03-20 17:16:30 +0530", "message": "Fix firetv object structure"}, {"oid": "fb3870743b91925e02250bc2f039af1c90eb4eca", "committedDate": "2023-03-21 23:39:47 -0400", "message": "[MOB - 5873] - Public getters for Email UserID and Auth"}, {"oid": "cb0e4c36556bee6d9c7b6731398e88e290a35325", "committedDate": "2023-03-21 23:49:09 -0400", "message": "[MOB - 5874] - Schedule auth refresh when auth null"}, {"oid": "4aea9b25979421e60176a15d7b1b3b7761d0e2df", "committedDate": "2023-03-22 19:03:48 -0400", "message": "Merge pull request #534 from Iterable/MOB-5874-authToken-refresh-when-null"}, {"oid": "6c0a9a2cf75a3cf190afe0332616a983b061c09f", "committedDate": "2023-04-03 10:58:42 -0700", "message": "Merge branch 'master' into firetv-updateuser-fix"}, {"oid": "37f07c4f78e6ee8a6ded0b73596d9c936c550f4d", "committedDate": "2023-05-02 10:54:06 -0700", "message": "Merge pull request #474 from Iterable/jay/MOB-4666-in-apps-config-memory"}, {"oid": "e23204965fe605644365a5d4628262e8dd0b8059", "committedDate": "2023-05-10 20:12:24 -0700", "message": "Merge branch 'master' into firetv-updateuser-fix"}, {"oid": "62ac73eaa6930051118365734add3250e52185d2", "committedDate": "2023-05-17 13:50:41 -0700", "message": "[MOB-6055] - [OMNI CG] - Add callbacks to setting email/user id (#570)"}]}, {"oid": "e5c0a39a8c3c8f0d25ef158427269324c52d4f8d", "url": "https://github.com/Iterable/iterable-android-sdk/commit/e5c0a39a8c3c8f0d25ef158427269324c52d4f8d", "message": "[MOB-2411] - Offline flag in config\n\nRevised PR:\n1.  Added offlineProcessing boolean flag in `IterableConfig` defaulted to false with package private method `setOfflineProcessing`\n2.  Added enableOfflineProcessing method in apiClient for IterableApi to be able to set offline mode after/during initializaiton.\n3.  In IterableAPI, if the flag is true, the method is called.\n\nupdate: Reverted to `non-static` for apiclient and authHandler", "committedDate": "2020-12-16T20:18:45Z", "type": "forcePushed"}, {"oid": "c849c12181ecf68bfd6f36b291a3cacb0a03eac8", "url": "https://github.com/Iterable/iterable-android-sdk/commit/c849c12181ecf68bfd6f36b291a3cacb0a03eac8", "message": "[MOB-2411] - Offline flag in config\n\nRevised PR:\n1.  Added offlineProcessing boolean flag in `IterableConfig` defaulted to false with package private method `setOfflineProcessing`\n2.  Added enableOfflineProcessing method in apiClient for IterableApi to be able to set offline mode after/during initializaiton.\n3.  In IterableAPI, if the flag is true, the method is called.\n\nupdate: Reverted to `non-static` for apiclient and authHandler", "committedDate": "2020-12-16T20:59:49Z", "type": "forcePushed"}, {"oid": "07f9118d3b98af774d858aea05a5fc6b6004ece5", "url": "https://github.com/Iterable/iterable-android-sdk/commit/07f9118d3b98af774d858aea05a5fc6b6004ece5", "message": "[MOB-2411] - Offline flag in config\n\nRevised PR:\n1.  Added offlineProcessing boolean flag in `IterableConfig` defaulted to false with package private method `setOfflineProcessing`\n2.  Added enableOfflineProcessing method in apiClient for IterableApi to be able to set offline mode after/during initializaiton.\n3.  In IterableAPI, if the flag is true, the method is called.\n\nupdate: Reverted to `non-static` for apiclient and authHandler", "committedDate": "2020-12-16T21:09:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY2ODA5OA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/298#discussion_r544668098", "body": "```suggestion\r\n            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.requestProcessor = new OfflineRequestProcessor(IterableApi.getInstance().getMainActivityContext());\n          \n          \n            \n                        this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>requestProcessor <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">OfflineRequestProcessor</span>(<span class=\"pl-smi x x-first\">IterableApi</span><span class=\"pl-k x\">.</span><span class=\"x\">getInstance()</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">getMainActivityContext</span>());</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>requestProcessor <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">OfflineRequestProcessor</span>(<span class=\"x x-first\">authProvider</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">getContext</span>());</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vbabenkoru", "createdAt": "2020-12-16T22:27:10Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java", "diffHunk": "@@ -46,6 +46,13 @@ private RequestProcessor getRequestProcessor() {\n         return requestProcessor;\n     }\n \n+    void enableOfflineProcessing(boolean offlineMode) {\n+        if (offlineMode) {\n+            this.requestProcessor = new OfflineRequestProcessor(IterableApi.getInstance().getMainActivityContext());", "originalCommit": "07f9118d3b98af774d858aea05a5fc6b6004ece5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0df1d13e97f4309ceeffaa44eced378bf1bbbea8", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex 9da3ba54..ca005131 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -46,11 +46,12 @@ class IterableApiClient {\n         return requestProcessor;\n     }\n \n-    void enableOfflineProcessing(boolean offlineMode) {\n+    void setOfflineProcessingEnabled(boolean offlineMode) {\n         if (offlineMode) {\n-            this.requestProcessor = new OfflineRequestProcessor(IterableApi.getInstance().getMainActivityContext());\n+            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+        } else {\n+            this.requestProcessor = new OnlineRequestProcessor();\n         }\n-        //TODO: if api has to reinitialize, say after logout -> login, should apiClient also reset? In that case, there should be an else here. Or ApiClient should be reset on logout or some place\n     }\n \n     public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex 9da3ba54..ca005131 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -46,11 +46,12 @@ class IterableApiClient {\n         return requestProcessor;\n     }\n \n-    void enableOfflineProcessing(boolean offlineMode) {\n+    void setOfflineProcessingEnabled(boolean offlineMode) {\n         if (offlineMode) {\n-            this.requestProcessor = new OfflineRequestProcessor(IterableApi.getInstance().getMainActivityContext());\n+            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+        } else {\n+            this.requestProcessor = new OnlineRequestProcessor();\n         }\n-        //TODO: if api has to reinitialize, say after logout -> login, should apiClient also reset? In that case, there should be an else here. Or ApiClient should be reset on logout or some place\n     }\n \n     public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n", "next_change": {"commit": "fcf4a43bfa68bc8a8465b8b25d76f1aa9d65d199", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex ca005131..fca2c47b 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -47,10 +47,12 @@ class IterableApiClient {\n     }\n \n     void setOfflineProcessingEnabled(boolean offlineMode) {\n-        if (offlineMode) {\n-            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n-        } else {\n-            this.requestProcessor = new OnlineRequestProcessor();\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+            if (offlineMode) {\n+                this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+            } else {\n+                this.requestProcessor = new OnlineRequestProcessor();\n+            }\n         }\n     }\n \n", "next_change": {"commit": "29e515a03708728d72f5560cc1492074fa344a08", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex fca2c47b..1e8ca210 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -47,12 +47,10 @@ class IterableApiClient {\n     }\n \n     void setOfflineProcessingEnabled(boolean offlineMode) {\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n-            if (offlineMode) {\n-                this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n-            } else {\n-                this.requestProcessor = new OnlineRequestProcessor();\n-            }\n+        if (offlineMode) {\n+            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+        } else {\n+            this.requestProcessor = new OnlineRequestProcessor();\n         }\n     }\n \n", "next_change": {"commit": "dabf649427ba5470fad2c0caa535f54fa1723a69", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex 1e8ca210..3abc2701 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -47,10 +47,12 @@ class IterableApiClient {\n     }\n \n     void setOfflineProcessingEnabled(boolean offlineMode) {\n-        if (offlineMode) {\n-            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n-        } else {\n-            this.requestProcessor = new OnlineRequestProcessor();\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+            if (offlineMode) {\n+                this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+            } else {\n+                this.requestProcessor = new OnlineRequestProcessor();\n+            }\n         }\n     }\n \n", "next_change": {"commit": "cd6b41db6c9114d1b6a7bfb49b5ff4cb5b0771e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex 3abc2701..d1db9ef9 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -49,13 +49,31 @@ class IterableApiClient {\n     void setOfflineProcessingEnabled(boolean offlineMode) {\n         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n             if (offlineMode) {\n-                this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+                if (this.requestProcessor == null || this.requestProcessor.getClass() != OfflineRequestProcessor.class) {\n+                    this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+                }\n             } else {\n-                this.requestProcessor = new OnlineRequestProcessor();\n+                if (this.requestProcessor == null || this.requestProcessor.getClass() != OnlineRequestProcessor.class) {\n+                    this.requestProcessor = new OnlineRequestProcessor();\n+                }\n             }\n         }\n     }\n \n+    void getRemoteConfiguration(IterableHelper.SuccessHandler successHandler, IterableHelper.FailureHandler failureHandler) {\n+        JSONObject requestJSON = new JSONObject();\n+        try {\n+            //TODO: Add data and make request\n+            requestJSON.putOpt(IterableConstants.KEY_PLATFORM, IterableConstants.ITBL_PLATFORM_ANDROID);\n+            requestJSON.putOpt(IterableConstants.DEVICE_APP_PACKAGE_NAME, authProvider.getContext().getPackageName());\n+            requestJSON.put(IterableConstants.ITBL_KEY_SDK_VERSION, IterableConstants.ITBL_KEY_SDK_VERSION_NUMBER);\n+            requestJSON.put(IterableConstants.ITBL_SYSTEM_VERSION, Build.VERSION.RELEASE);\n+            sendPostRequest(IterableConstants.ENDPOINT_GET_REMOTE_CONFIGURATION, requestJSON, successHandler, failureHandler);\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n     public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n         JSONObject requestJSON = new JSONObject();\n         try {\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "message": "Merge commit", "committedDate": null}, {"oid": "fcf4a43bfa68bc8a8465b8b25d76f1aa9d65d199", "committedDate": "2020-12-22 10:34:53 -0800", "message": "Modification 1"}, {"oid": "29e515a03708728d72f5560cc1492074fa344a08", "committedDate": "2020-12-22 13:13:32 -0800", "message": "[MOB-2285] - Add OS version to getMessagesAPI"}, {"oid": "dabf649427ba5470fad2c0caa535f54fa1723a69", "committedDate": "2020-12-28 14:49:46 -0800", "message": "Merge pull request #301 from Iterable/MOB-2152-Network-Monitor"}, {"oid": "cd6b41db6c9114d1b6a7bfb49b5ff4cb5b0771e4", "committedDate": "2021-01-21 09:07:08 -0800", "message": "[MOB-2437] - Get Remote Configuration"}, {"oid": "19b2053245b7171ddffbc4046af8c2a6ab616443", "committedDate": "2021-01-24 20:54:50 -0800", "message": "Revision"}, {"oid": "5e3325282a8ca0b7d616e74cd77b0f4e56808787", "committedDate": "2021-01-26 16:02:26 -0800", "message": "[MOB - 2541] - Remove offline configuration from IterableConfig"}, {"oid": "cd62e812fb99448f0f9de8a9fe8a7a62b196484d", "committedDate": "2021-07-21 15:36:47 -0700", "message": "add updateCart API and tests"}, {"oid": "e4bba683b7e9d9718551f6be2343f2c7bd74c0aa", "committedDate": "2021-07-26 17:23:15 -0700", "message": "remove top level dataFields"}, {"oid": "8b0a852fd5abdb2bb830e6f544026aab5ff5a163", "committedDate": "2021-11-02 17:01:05 -0700", "message": "allow trackInAppClose to have a clickedUrl null"}, {"oid": "cdfa7880d28d1cb38cee5baff2b722b1c3dce1c8", "committedDate": "2021-11-03 15:40:53 -0700", "message": "style check fix"}, {"oid": "bd1525fae2ba9f59c5ea3a545edb50c10aa4e8c8", "committedDate": "2022-02-22 08:54:16 -0800", "message": "[MOB-4068] - Reset jwtToken when logging out"}, {"oid": "6c7a367f95d5221bd69238953e63d8389083811b", "committedDate": "2022-07-25 16:25:51 -0700", "message": "[MOB-4628] - Remove ad id collection"}, {"oid": "124c04e1b8d2aa31359626823dd59a4e3f2b5401", "committedDate": "2023-03-15 19:30:15 +0530", "message": "Add firetv/ott support to getmessages call"}, {"oid": "898f9e91c38f6911e9ef442bf7c43e825566ab25", "committedDate": "2023-03-16 22:05:34 +0530", "message": "For firetv call update user with device details upon initialization"}, {"oid": "e3a277f99181d7302bfe7a303b9cde36de747141", "committedDate": "2023-03-16 23:49:46 +0530", "message": "Set DEVICE_NOTIFICATIONS_ENABLED key only when registering for push"}, {"oid": "62ac73eaa6930051118365734add3250e52185d2", "committedDate": "2023-05-17 13:50:41 -0700", "message": "[MOB-6055] - [OMNI CG] - Add callbacks to setting email/user id (#570)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcyMDkxNA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/298#discussion_r544720914", "body": "We don't need to reset apiClient on logout", "bodyText": "We don't need to reset apiClient on logout", "bodyHTML": "<p dir=\"auto\">We don't need to reset apiClient on logout</p>", "author": "vbabenkoru", "createdAt": "2020-12-17T00:28:12Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java", "diffHunk": "@@ -46,6 +46,13 @@ private RequestProcessor getRequestProcessor() {\n         return requestProcessor;\n     }\n \n+    void enableOfflineProcessing(boolean offlineMode) {\n+        if (offlineMode) {\n+            this.requestProcessor = new OfflineRequestProcessor(IterableApi.getInstance().getMainActivityContext());\n+        }\n+        //TODO: if api has to reinitialize, say after logout -> login, should apiClient also reset? In that case, there should be an else here. Or ApiClient should be reset on logout or some place", "originalCommit": "07f9118d3b98af774d858aea05a5fc6b6004ece5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0df1d13e97f4309ceeffaa44eced378bf1bbbea8", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex 9da3ba54..ca005131 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -46,11 +46,12 @@ class IterableApiClient {\n         return requestProcessor;\n     }\n \n-    void enableOfflineProcessing(boolean offlineMode) {\n+    void setOfflineProcessingEnabled(boolean offlineMode) {\n         if (offlineMode) {\n-            this.requestProcessor = new OfflineRequestProcessor(IterableApi.getInstance().getMainActivityContext());\n+            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+        } else {\n+            this.requestProcessor = new OnlineRequestProcessor();\n         }\n-        //TODO: if api has to reinitialize, say after logout -> login, should apiClient also reset? In that case, there should be an else here. Or ApiClient should be reset on logout or some place\n     }\n \n     public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex 9da3ba54..ca005131 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -46,11 +46,12 @@ class IterableApiClient {\n         return requestProcessor;\n     }\n \n-    void enableOfflineProcessing(boolean offlineMode) {\n+    void setOfflineProcessingEnabled(boolean offlineMode) {\n         if (offlineMode) {\n-            this.requestProcessor = new OfflineRequestProcessor(IterableApi.getInstance().getMainActivityContext());\n+            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+        } else {\n+            this.requestProcessor = new OnlineRequestProcessor();\n         }\n-        //TODO: if api has to reinitialize, say after logout -> login, should apiClient also reset? In that case, there should be an else here. Or ApiClient should be reset on logout or some place\n     }\n \n     public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n", "next_change": {"commit": "fcf4a43bfa68bc8a8465b8b25d76f1aa9d65d199", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex ca005131..fca2c47b 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -47,10 +47,12 @@ class IterableApiClient {\n     }\n \n     void setOfflineProcessingEnabled(boolean offlineMode) {\n-        if (offlineMode) {\n-            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n-        } else {\n-            this.requestProcessor = new OnlineRequestProcessor();\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+            if (offlineMode) {\n+                this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+            } else {\n+                this.requestProcessor = new OnlineRequestProcessor();\n+            }\n         }\n     }\n \n", "next_change": {"commit": "29e515a03708728d72f5560cc1492074fa344a08", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex fca2c47b..1e8ca210 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -47,12 +47,10 @@ class IterableApiClient {\n     }\n \n     void setOfflineProcessingEnabled(boolean offlineMode) {\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n-            if (offlineMode) {\n-                this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n-            } else {\n-                this.requestProcessor = new OnlineRequestProcessor();\n-            }\n+        if (offlineMode) {\n+            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+        } else {\n+            this.requestProcessor = new OnlineRequestProcessor();\n         }\n     }\n \n", "next_change": {"commit": "dabf649427ba5470fad2c0caa535f54fa1723a69", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex 1e8ca210..3abc2701 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -47,10 +47,12 @@ class IterableApiClient {\n     }\n \n     void setOfflineProcessingEnabled(boolean offlineMode) {\n-        if (offlineMode) {\n-            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n-        } else {\n-            this.requestProcessor = new OnlineRequestProcessor();\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+            if (offlineMode) {\n+                this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+            } else {\n+                this.requestProcessor = new OnlineRequestProcessor();\n+            }\n         }\n     }\n \n", "next_change": {"commit": "cd6b41db6c9114d1b6a7bfb49b5ff4cb5b0771e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex 3abc2701..d1db9ef9 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -49,13 +49,31 @@ class IterableApiClient {\n     void setOfflineProcessingEnabled(boolean offlineMode) {\n         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n             if (offlineMode) {\n-                this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+                if (this.requestProcessor == null || this.requestProcessor.getClass() != OfflineRequestProcessor.class) {\n+                    this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+                }\n             } else {\n-                this.requestProcessor = new OnlineRequestProcessor();\n+                if (this.requestProcessor == null || this.requestProcessor.getClass() != OnlineRequestProcessor.class) {\n+                    this.requestProcessor = new OnlineRequestProcessor();\n+                }\n             }\n         }\n     }\n \n+    void getRemoteConfiguration(IterableHelper.SuccessHandler successHandler, IterableHelper.FailureHandler failureHandler) {\n+        JSONObject requestJSON = new JSONObject();\n+        try {\n+            //TODO: Add data and make request\n+            requestJSON.putOpt(IterableConstants.KEY_PLATFORM, IterableConstants.ITBL_PLATFORM_ANDROID);\n+            requestJSON.putOpt(IterableConstants.DEVICE_APP_PACKAGE_NAME, authProvider.getContext().getPackageName());\n+            requestJSON.put(IterableConstants.ITBL_KEY_SDK_VERSION, IterableConstants.ITBL_KEY_SDK_VERSION_NUMBER);\n+            requestJSON.put(IterableConstants.ITBL_SYSTEM_VERSION, Build.VERSION.RELEASE);\n+            sendPostRequest(IterableConstants.ENDPOINT_GET_REMOTE_CONFIGURATION, requestJSON, successHandler, failureHandler);\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n     public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n         JSONObject requestJSON = new JSONObject();\n         try {\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "message": "Merge commit", "committedDate": null}, {"oid": "fcf4a43bfa68bc8a8465b8b25d76f1aa9d65d199", "committedDate": "2020-12-22 10:34:53 -0800", "message": "Modification 1"}, {"oid": "29e515a03708728d72f5560cc1492074fa344a08", "committedDate": "2020-12-22 13:13:32 -0800", "message": "[MOB-2285] - Add OS version to getMessagesAPI"}, {"oid": "dabf649427ba5470fad2c0caa535f54fa1723a69", "committedDate": "2020-12-28 14:49:46 -0800", "message": "Merge pull request #301 from Iterable/MOB-2152-Network-Monitor"}, {"oid": "cd6b41db6c9114d1b6a7bfb49b5ff4cb5b0771e4", "committedDate": "2021-01-21 09:07:08 -0800", "message": "[MOB-2437] - Get Remote Configuration"}, {"oid": "19b2053245b7171ddffbc4046af8c2a6ab616443", "committedDate": "2021-01-24 20:54:50 -0800", "message": "Revision"}, {"oid": "5e3325282a8ca0b7d616e74cd77b0f4e56808787", "committedDate": "2021-01-26 16:02:26 -0800", "message": "[MOB - 2541] - Remove offline configuration from IterableConfig"}, {"oid": "cd62e812fb99448f0f9de8a9fe8a7a62b196484d", "committedDate": "2021-07-21 15:36:47 -0700", "message": "add updateCart API and tests"}, {"oid": "e4bba683b7e9d9718551f6be2343f2c7bd74c0aa", "committedDate": "2021-07-26 17:23:15 -0700", "message": "remove top level dataFields"}, {"oid": "8b0a852fd5abdb2bb830e6f544026aab5ff5a163", "committedDate": "2021-11-02 17:01:05 -0700", "message": "allow trackInAppClose to have a clickedUrl null"}, {"oid": "cdfa7880d28d1cb38cee5baff2b722b1c3dce1c8", "committedDate": "2021-11-03 15:40:53 -0700", "message": "style check fix"}, {"oid": "bd1525fae2ba9f59c5ea3a545edb50c10aa4e8c8", "committedDate": "2022-02-22 08:54:16 -0800", "message": "[MOB-4068] - Reset jwtToken when logging out"}, {"oid": "6c7a367f95d5221bd69238953e63d8389083811b", "committedDate": "2022-07-25 16:25:51 -0700", "message": "[MOB-4628] - Remove ad id collection"}, {"oid": "124c04e1b8d2aa31359626823dd59a4e3f2b5401", "committedDate": "2023-03-15 19:30:15 +0530", "message": "Add firetv/ott support to getmessages call"}, {"oid": "898f9e91c38f6911e9ef442bf7c43e825566ab25", "committedDate": "2023-03-16 22:05:34 +0530", "message": "For firetv call update user with device details upon initialization"}, {"oid": "e3a277f99181d7302bfe7a303b9cde36de747141", "committedDate": "2023-03-16 23:49:46 +0530", "message": "Set DEVICE_NOTIFICATIONS_ENABLED key only when registering for push"}, {"oid": "62ac73eaa6930051118365734add3250e52185d2", "committedDate": "2023-05-17 13:50:41 -0700", "message": "[MOB-6055] - [OMNI CG] - Add callbacks to setting email/user id (#570)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcyMTE0MA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/298#discussion_r544721140", "body": "`setOfflineProcessingEnabled`?", "bodyText": "setOfflineProcessingEnabled?", "bodyHTML": "<p dir=\"auto\"><code>setOfflineProcessingEnabled</code>?</p>", "author": "vbabenkoru", "createdAt": "2020-12-17T00:28:52Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java", "diffHunk": "@@ -46,6 +46,13 @@ private RequestProcessor getRequestProcessor() {\n         return requestProcessor;\n     }\n \n+    void enableOfflineProcessing(boolean offlineMode) {", "originalCommit": "07f9118d3b98af774d858aea05a5fc6b6004ece5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0df1d13e97f4309ceeffaa44eced378bf1bbbea8", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex 9da3ba54..ca005131 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -46,11 +46,12 @@ class IterableApiClient {\n         return requestProcessor;\n     }\n \n-    void enableOfflineProcessing(boolean offlineMode) {\n+    void setOfflineProcessingEnabled(boolean offlineMode) {\n         if (offlineMode) {\n-            this.requestProcessor = new OfflineRequestProcessor(IterableApi.getInstance().getMainActivityContext());\n+            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+        } else {\n+            this.requestProcessor = new OnlineRequestProcessor();\n         }\n-        //TODO: if api has to reinitialize, say after logout -> login, should apiClient also reset? In that case, there should be an else here. Or ApiClient should be reset on logout or some place\n     }\n \n     public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex 9da3ba54..ca005131 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -46,11 +46,12 @@ class IterableApiClient {\n         return requestProcessor;\n     }\n \n-    void enableOfflineProcessing(boolean offlineMode) {\n+    void setOfflineProcessingEnabled(boolean offlineMode) {\n         if (offlineMode) {\n-            this.requestProcessor = new OfflineRequestProcessor(IterableApi.getInstance().getMainActivityContext());\n+            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+        } else {\n+            this.requestProcessor = new OnlineRequestProcessor();\n         }\n-        //TODO: if api has to reinitialize, say after logout -> login, should apiClient also reset? In that case, there should be an else here. Or ApiClient should be reset on logout or some place\n     }\n \n     public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n", "next_change": {"commit": "fcf4a43bfa68bc8a8465b8b25d76f1aa9d65d199", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex ca005131..fca2c47b 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -47,10 +47,12 @@ class IterableApiClient {\n     }\n \n     void setOfflineProcessingEnabled(boolean offlineMode) {\n-        if (offlineMode) {\n-            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n-        } else {\n-            this.requestProcessor = new OnlineRequestProcessor();\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+            if (offlineMode) {\n+                this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+            } else {\n+                this.requestProcessor = new OnlineRequestProcessor();\n+            }\n         }\n     }\n \n", "next_change": {"commit": "29e515a03708728d72f5560cc1492074fa344a08", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex fca2c47b..1e8ca210 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -47,12 +47,10 @@ class IterableApiClient {\n     }\n \n     void setOfflineProcessingEnabled(boolean offlineMode) {\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n-            if (offlineMode) {\n-                this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n-            } else {\n-                this.requestProcessor = new OnlineRequestProcessor();\n-            }\n+        if (offlineMode) {\n+            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+        } else {\n+            this.requestProcessor = new OnlineRequestProcessor();\n         }\n     }\n \n", "next_change": {"commit": "dabf649427ba5470fad2c0caa535f54fa1723a69", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex 1e8ca210..3abc2701 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -47,10 +47,12 @@ class IterableApiClient {\n     }\n \n     void setOfflineProcessingEnabled(boolean offlineMode) {\n-        if (offlineMode) {\n-            this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n-        } else {\n-            this.requestProcessor = new OnlineRequestProcessor();\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+            if (offlineMode) {\n+                this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+            } else {\n+                this.requestProcessor = new OnlineRequestProcessor();\n+            }\n         }\n     }\n \n", "next_change": {"commit": "cd6b41db6c9114d1b6a7bfb49b5ff4cb5b0771e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\nindex 3abc2701..d1db9ef9 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApiClient.java\n", "chunk": "@@ -49,13 +49,31 @@ class IterableApiClient {\n     void setOfflineProcessingEnabled(boolean offlineMode) {\n         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n             if (offlineMode) {\n-                this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+                if (this.requestProcessor == null || this.requestProcessor.getClass() != OfflineRequestProcessor.class) {\n+                    this.requestProcessor = new OfflineRequestProcessor(authProvider.getContext());\n+                }\n             } else {\n-                this.requestProcessor = new OnlineRequestProcessor();\n+                if (this.requestProcessor == null || this.requestProcessor.getClass() != OnlineRequestProcessor.class) {\n+                    this.requestProcessor = new OnlineRequestProcessor();\n+                }\n             }\n         }\n     }\n \n+    void getRemoteConfiguration(IterableHelper.SuccessHandler successHandler, IterableHelper.FailureHandler failureHandler) {\n+        JSONObject requestJSON = new JSONObject();\n+        try {\n+            //TODO: Add data and make request\n+            requestJSON.putOpt(IterableConstants.KEY_PLATFORM, IterableConstants.ITBL_PLATFORM_ANDROID);\n+            requestJSON.putOpt(IterableConstants.DEVICE_APP_PACKAGE_NAME, authProvider.getContext().getPackageName());\n+            requestJSON.put(IterableConstants.ITBL_KEY_SDK_VERSION, IterableConstants.ITBL_KEY_SDK_VERSION_NUMBER);\n+            requestJSON.put(IterableConstants.ITBL_SYSTEM_VERSION, Build.VERSION.RELEASE);\n+            sendPostRequest(IterableConstants.ENDPOINT_GET_REMOTE_CONFIGURATION, requestJSON, successHandler, failureHandler);\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n     public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n         JSONObject requestJSON = new JSONObject();\n         try {\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "message": "Merge commit", "committedDate": null}, {"oid": "fcf4a43bfa68bc8a8465b8b25d76f1aa9d65d199", "committedDate": "2020-12-22 10:34:53 -0800", "message": "Modification 1"}, {"oid": "29e515a03708728d72f5560cc1492074fa344a08", "committedDate": "2020-12-22 13:13:32 -0800", "message": "[MOB-2285] - Add OS version to getMessagesAPI"}, {"oid": "dabf649427ba5470fad2c0caa535f54fa1723a69", "committedDate": "2020-12-28 14:49:46 -0800", "message": "Merge pull request #301 from Iterable/MOB-2152-Network-Monitor"}, {"oid": "cd6b41db6c9114d1b6a7bfb49b5ff4cb5b0771e4", "committedDate": "2021-01-21 09:07:08 -0800", "message": "[MOB-2437] - Get Remote Configuration"}, {"oid": "19b2053245b7171ddffbc4046af8c2a6ab616443", "committedDate": "2021-01-24 20:54:50 -0800", "message": "Revision"}, {"oid": "5e3325282a8ca0b7d616e74cd77b0f4e56808787", "committedDate": "2021-01-26 16:02:26 -0800", "message": "[MOB - 2541] - Remove offline configuration from IterableConfig"}, {"oid": "cd62e812fb99448f0f9de8a9fe8a7a62b196484d", "committedDate": "2021-07-21 15:36:47 -0700", "message": "add updateCart API and tests"}, {"oid": "e4bba683b7e9d9718551f6be2343f2c7bd74c0aa", "committedDate": "2021-07-26 17:23:15 -0700", "message": "remove top level dataFields"}, {"oid": "8b0a852fd5abdb2bb830e6f544026aab5ff5a163", "committedDate": "2021-11-02 17:01:05 -0700", "message": "allow trackInAppClose to have a clickedUrl null"}, {"oid": "cdfa7880d28d1cb38cee5baff2b722b1c3dce1c8", "committedDate": "2021-11-03 15:40:53 -0700", "message": "style check fix"}, {"oid": "bd1525fae2ba9f59c5ea3a545edb50c10aa4e8c8", "committedDate": "2022-02-22 08:54:16 -0800", "message": "[MOB-4068] - Reset jwtToken when logging out"}, {"oid": "6c7a367f95d5221bd69238953e63d8389083811b", "committedDate": "2022-07-25 16:25:51 -0700", "message": "[MOB-4628] - Remove ad id collection"}, {"oid": "124c04e1b8d2aa31359626823dd59a4e3f2b5401", "committedDate": "2023-03-15 19:30:15 +0530", "message": "Add firetv/ott support to getmessages call"}, {"oid": "898f9e91c38f6911e9ef442bf7c43e825566ab25", "committedDate": "2023-03-16 22:05:34 +0530", "message": "For firetv call update user with device details upon initialization"}, {"oid": "e3a277f99181d7302bfe7a303b9cde36de747141", "committedDate": "2023-03-16 23:49:46 +0530", "message": "Set DEVICE_NOTIFICATIONS_ENABLED key only when registering for push"}, {"oid": "62ac73eaa6930051118365734add3250e52185d2", "committedDate": "2023-05-17 13:50:41 -0700", "message": "[MOB-6055] - [OMNI CG] - Add callbacks to setting email/user id (#570)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcyMTY2OQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/298#discussion_r544721669", "body": "The condition check is both here and inside `enableOfflineProcessing`. I think either the method should not have parameters, or we don't need the check here.", "bodyText": "The condition check is both here and inside enableOfflineProcessing. I think either the method should not have parameters, or we don't need the check here.", "bodyHTML": "<p dir=\"auto\">The condition check is both here and inside <code>enableOfflineProcessing</code>. I think either the method should not have parameters, or we don't need the check here.</p>", "author": "vbabenkoru", "createdAt": "2020-12-17T00:30:13Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -306,6 +306,9 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n             sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n+        if (sharedInstance.config.offlineProcessing) {", "originalCommit": "07f9118d3b98af774d858aea05a5fc6b6004ece5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0df1d13e97f4309ceeffaa44eced378bf1bbbea8", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 18c7f23a..2ac602db 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -306,9 +306,7 @@ private static final String TAG = \"IterableApi\";\n             sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n-        if (sharedInstance.config.offlineProcessing) {\n-            sharedInstance.apiClient.enableOfflineProcessing(true);\n-        }\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(true);\n         IterablePushActionReceiver.processPendingAction(context);\n     }\n \n", "next_change": {"commit": "2054682a3e1a1739799491e1a485e8eba2b3fe2c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 2ac602db..e085947f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -306,7 +306,7 @@ private static final String TAG = \"IterableApi\";\n             sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(true);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(sharedInstance.config.offlineProcessing);\n         IterablePushActionReceiver.processPendingAction(context);\n     }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 18c7f23a..e085947f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -306,9 +306,7 @@ private static final String TAG = \"IterableApi\";\n             sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n-        if (sharedInstance.config.offlineProcessing) {\n-            sharedInstance.apiClient.enableOfflineProcessing(true);\n-        }\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(sharedInstance.config.offlineProcessing);\n         IterablePushActionReceiver.processPendingAction(context);\n     }\n \n", "next_change": {"commit": "cd6b41db6c9114d1b6a7bfb49b5ff4cb5b0771e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e085947f..be054798 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -310,6 +310,24 @@ private static final String TAG = \"IterableApi\";\n         IterablePushActionReceiver.processPendingAction(context);\n     }\n \n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                try {\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(data.getBoolean(\"offlineModeBeta\"));\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"OfflineMode parameter not found\");\n+                }\n+            }\n+        }, new IterableHelper.FailureHandler() {\n+            @Override\n+            public void onFailure(@NonNull String reason, @Nullable JSONObject data) {\n+                IterableLogger.e(TAG, \"Failed to fetch remote configuration. Default values will be used\");\n+            }\n+        });\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "19b2053245b7171ddffbc4046af8c2a6ab616443", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex be054798..2bb65119 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -311,20 +311,16 @@ private static final String TAG = \"IterableApi\";\n     }\n \n     void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.SuccessHandler() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n             @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n+            public void execute(@Nullable String data) {\n                 try {\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(data.getBoolean(\"offlineModeBeta\"));\n+                    JSONObject jsonData = new JSONObject(data);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(jsonData.getBoolean(\"offlineModeBeta\"));\n                 } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"OfflineMode parameter not found\");\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n                 }\n             }\n-        }, new IterableHelper.FailureHandler() {\n-            @Override\n-            public void onFailure(@NonNull String reason, @Nullable JSONObject data) {\n-                IterableLogger.e(TAG, \"Failed to fetch remote configuration. Default values will be used\");\n-            }\n         });\n     }\n \n", "next_change": {"commit": "1402e45e7e57cc21915beed35588ebd81ada1627", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 2bb65119..91797365 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -306,17 +306,28 @@ private static final String TAG = \"IterableApi\";\n             sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(sharedInstance.config.offlineProcessing);\n+        loadLastSavedConfiguration(context);\n         IterablePushActionReceiver.processPendingAction(context);\n     }\n \n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    }\n+\n     void fetchRemoteConfiguration() {\n         apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n             @Override\n             public void execute(@Nullable String data) {\n                 try {\n                     JSONObject jsonData = new JSONObject(data);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(jsonData.getBoolean(\"offlineModeBeta\"));\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, offlineConfiguration);\n+                    editor.apply();\n                 } catch (JSONException e) {\n                     IterableLogger.e(TAG, \"Failed to read remote configuration\");\n                 }\n", "next_change": {"commit": "2db97108c261008ed4b1d5f29c70eaa4318b1275", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 91797365..a15c5c9b 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -335,6 +339,10 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "3287dc085a83f1e75e09982baad3625fb6684b8c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex a15c5c9b..3c9e5cd9 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,10 +339,6 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "ea141c605aca86d0d85418a66a8f1296263454d5", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd9..882bb40d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,6 +339,10 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40d..45c33cc0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,10 +339,6 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "b7e917f87f001eb456bcefc0039751a451713647", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc0..ee7cf34b 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,6 +339,10 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "bd0594f237559bdcb0c0c15f8d1b2e38977c0972", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex ee7cf34b..fc9cbc43 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,10 +339,6 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "42ae0158572533f77068dc93e7c01807f61c29da", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex fc9cbc43..9e125a77 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,6 +339,10 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "0818f8d620d08706d7157875d42030ea55730fe4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9e125a77..129e8fae 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,10 +339,6 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 129e8fae..b03b5b15 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,149 +249,17 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n         boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && _userId.equals(userId)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b15..9b34a0d3 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d3..96f643f0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40d..45c33cc0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -350,6 +346,10 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n", "next_change": {"commit": "4100141101fdf973d456cd14e7c70478fe3b0024", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc0..baad2550 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -351,7 +351,9 @@ private static final String TAG = \"IterableApi\";\n     }\n \n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n         if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex baad2550..b03b5b15 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,155 +249,12 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n         boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n     private void checkAndUpdateAuthToken(@Nullable String authToken) {\n         // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n         if (config.authHandler != null && authToken != null && authToken != _authToken) {\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b15..9b34a0d3 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d3..96f643f0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd9..882bb40d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -346,7 +350,7 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n-    public void setEmail(@Nullable String email) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40d..45c33cc0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -350,6 +346,10 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n", "next_change": {"commit": "4100141101fdf973d456cd14e7c70478fe3b0024", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc0..baad2550 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -351,7 +351,9 @@ private static final String TAG = \"IterableApi\";\n     }\n \n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n         if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex baad2550..b03b5b15 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,155 +249,12 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n         boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n     private void checkAndUpdateAuthToken(@Nullable String authToken) {\n         // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n         if (config.authHandler != null && authToken != null && authToken != _authToken) {\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b15..9b34a0d3 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d3..96f643f0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex a15c5c9b..3c9e5cd9 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -350,7 +346,7 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+    public void setEmail(@Nullable String email) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "ea141c605aca86d0d85418a66a8f1296263454d5", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd9..882bb40d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -346,7 +350,7 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n-    public void setEmail(@Nullable String email) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40d..45c33cc0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -350,6 +346,10 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n", "next_change": {"commit": "4100141101fdf973d456cd14e7c70478fe3b0024", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc0..baad2550 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -351,7 +351,9 @@ private static final String TAG = \"IterableApi\";\n     }\n \n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n         if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex baad2550..b03b5b15 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,155 +249,12 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n         boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n     private void checkAndUpdateAuthToken(@Nullable String authToken) {\n         // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n         if (config.authHandler != null && authToken != null && authToken != _authToken) {\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b15..9b34a0d3 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d3..96f643f0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd9..882bb40d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -355,16 +359,13 @@ private static final String TAG = \"IterableApi\";\n             return;\n         }\n \n-        onLogOut();\n+        logoutPreviousUser();\n+\n         _email = email;\n         _userId = null;\n         storeAuthData();\n \n-        if (email != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40d..45c33cc0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,7 +365,11 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-        onLogin(authToken);\n+        if (email != null) {\n+            getAuthManager().requestNewAuthToken(false);\n+        } else {\n+            setAuthToken(null);\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "b6b77024af90a60aecb60d6f15264ab69f1b571b", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc0..6496d512 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,11 +365,13 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-        if (email != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+//        if (email != null) {\n+//            getAuthManager().requestNewAuthToken(false);\n+//        } else {\n+//            setAuthToken(null);\n+//        }\n+\n+        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "ae2dedfa1de5ec18c047fa1edb42c431570702af", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 6496d512..c0152305 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,12 +365,6 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-//        if (email != null) {\n-//            getAuthManager().requestNewAuthToken(false);\n-//        } else {\n-//            setAuthToken(null);\n-//        }\n-\n         onLogin(authToken);\n     }\n \n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex c0152305..b03b5b15 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,149 +249,17 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, false);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && _userId.equals(userId)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b15..9b34a0d3 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d3..96f643f0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "message": "Merge commit", "committedDate": null}, {"oid": "68888566277f1960bfe6dd8758af6ae0aed8fa61", "committedDate": "2020-12-22 16:51:00 -0800", "message": "[MOB - 2371] - Delete all tasks on log out"}, {"oid": "cd6b41db6c9114d1b6a7bfb49b5ff4cb5b0771e4", "committedDate": "2021-01-21 09:07:08 -0800", "message": "[MOB-2437] - Get Remote Configuration"}, {"oid": "19b2053245b7171ddffbc4046af8c2a6ab616443", "committedDate": "2021-01-24 20:54:50 -0800", "message": "Revision"}, {"oid": "1402e45e7e57cc21915beed35588ebd81ada1627", "committedDate": "2021-01-24 23:22:41 -0800", "message": "[MOB-2531] - Persist offline configuration"}, {"oid": "5e3325282a8ca0b7d616e74cd77b0f4e56808787", "committedDate": "2021-01-26 16:02:26 -0800", "message": "[MOB - 2541] - Remove offline configuration from IterableConfig"}, {"oid": "007de2da38292f32cdcb8428a1569c2a57dcfe39", "committedDate": "2021-03-30 21:29:22 -0700", "message": "Remove deprecated in-app methods"}, {"oid": "04755b525a3af290282635eb5b496be17799837e", "committedDate": "2021-06-15 18:36:27 +0530", "message": "[MOB-2971] - Set Context method"}, {"oid": "4d221c5296169c326474e265cc85cb52953a1f94", "committedDate": "2021-06-29 15:38:39 -0700", "message": "remove deferred deep linking leftover code"}, {"oid": "29f3fa8e0e7f0ea8178182d656f97af0e976d40f", "committedDate": "2021-07-07 11:28:56 -0700", "message": "remove unused imports"}, {"oid": "cd62e812fb99448f0f9de8a9fe8a7a62b196484d", "committedDate": "2021-07-21 15:36:47 -0700", "message": "add updateCart API and tests"}, {"oid": "e4bba683b7e9d9718551f6be2343f2c7bd74c0aa", "committedDate": "2021-07-26 17:23:15 -0700", "message": "remove top level dataFields"}, {"oid": "042aa82f4d7faeaf4cff15be7ed89eeced9d1a5a", "committedDate": "2021-11-02 16:47:02 -0700", "message": "add various comments to API"}, {"oid": "8710ccccfa2c65825ce37281c1b0ad654ac7e75e", "committedDate": "2021-11-02 16:48:35 -0700", "message": "comments + rearranging for clarity"}, {"oid": "b429250ccf99a17d245a4f6c208e16610611dd1c", "committedDate": "2021-11-02 16:49:32 -0700", "message": "move better"}, {"oid": "27640f08182c5b4b72e57a35abcdcd5a64389897", "committedDate": "2021-11-02 16:50:06 -0700", "message": "android studio spacing"}, {"oid": "8b0a852fd5abdb2bb830e6f544026aab5ff5a163", "committedDate": "2021-11-02 17:01:05 -0700", "message": "allow trackInAppClose to have a clickedUrl null"}, {"oid": "788e949c96e990b6f38bb4f3eecf6f495f6170f2", "committedDate": "2021-11-02 17:14:35 -0700", "message": "make trackInAppClose public"}, {"oid": "a25ec805df060991fb94eccc3c19958650866398", "committedDate": "2021-12-16 16:11:54 -0800", "message": "change deep link API to be instanced"}, {"oid": "d2ec0735f16292d4c6a2510eb819613dc274c5e4", "committedDate": "2021-12-16 17:55:22 -0800", "message": "implement protocol blocking"}, {"oid": "a278c7d773a62a1e356ac47263b4e12bea2373d7", "committedDate": "2021-12-20 09:33:01 -0800", "message": "try different empty array in config builder"}, {"oid": "d980fcec7d0e1978f7099aa08f73ba30b7849f02", "committedDate": "2021-12-22 11:02:34 -0800", "message": "Patch 1"}, {"oid": "00446867595361e4c3787247761bf5806acbdefe", "committedDate": "2021-12-22 13:37:09 -0800", "message": "Suggested modifications"}, {"oid": "2bfb786453bdc527544450f336e5a12990a98169", "committedDate": "2021-12-22 14:40:04 -0800", "message": "Remove allowedProtocols passing between modules"}, {"oid": "059e840ddedb21a50e7f1b0c270f56bf28ebc95b", "committedDate": "2022-01-10 08:36:20 -0800", "message": "Moving PushAction Receiver code to a common util function"}, {"oid": "bd1525fae2ba9f59c5ea3a545edb50c10aa4e8c8", "committedDate": "2022-02-22 08:54:16 -0800", "message": "[MOB-4068] - Reset jwtToken when logging out"}, {"oid": "edd7de3e2a5f38135e28628321cdb48ed5770739", "committedDate": "2022-04-04 10:56:15 -0700", "message": "[MOB-4266] - Make trackPushOpen Public"}, {"oid": "ad081e7d724ae238fc0347acee83fd692686a33c", "committedDate": "2022-05-25 11:32:00 -0700", "message": "add deprecation tags"}, {"oid": "ef1f3da25f7c66989ee1f39502506790f74362e4", "committedDate": "2022-05-25 11:35:29 -0700", "message": "add utility check of email or id existence"}, {"oid": "2db97108c261008ed4b1d5f29c70eaa4318b1275", "committedDate": "2022-05-25 14:20:53 -0700", "message": "match names to iOS and implement same JWT paths"}, {"oid": "8503911cd750598a56a98b1e8df4f0ed676cb388", "committedDate": "2022-05-25 16:50:35 -0700", "message": "remove unnecessary method"}, {"oid": "3287dc085a83f1e75e09982baad3625fb6684b8c", "committedDate": "2022-05-27 12:16:58 -0700", "message": "[MOB - 4260] - Check device token before disabling"}, {"oid": "ea141c605aca86d0d85418a66a8f1296263454d5", "committedDate": "2022-06-02 16:05:18 -0700", "message": "direct updateEmail to specific catch all call"}, {"oid": "a97b5c87477bf940a89ec91aef427ee2a1d44d44", "committedDate": "2022-06-06 15:34:16 -0700", "message": "syntax"}, {"oid": "5cca36845fcf0bb85893ba45507deb41a8debc81", "committedDate": "2022-06-08 16:30:06 -0700", "message": "add more user validity checks, add to userId"}, {"oid": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "committedDate": "2022-06-21 14:46:25 -0700", "message": "renames"}, {"oid": "b6b77024af90a60aecb60d6f15264ab69f1b571b", "committedDate": "2022-06-21 15:03:43 -0700", "message": "refactor post login actions"}, {"oid": "ae2dedfa1de5ec18c047fa1edb42c431570702af", "committedDate": "2022-06-22 13:20:39 -0700", "message": "pass along auth token on set"}, {"oid": "b7e917f87f001eb456bcefc0039751a451713647", "committedDate": "2022-06-30 17:35:25 -0700", "message": "Merge branch 'master' into jay/MOB-4439-update-email"}, {"oid": "bd0594f237559bdcb0c0c15f8d1b2e38977c0972", "committedDate": "2022-07-11 09:42:49 -0700", "message": "[MOB-4537] - Change from beta to SDKOfflineMode"}, {"oid": "b0e3f885090fc151951df5b0e7a6563ea9f797ee", "committedDate": "2022-07-11 13:38:51 -0700", "message": "Made recommended changes"}, {"oid": "5f7f0a10b5eed3b912ec1851ee4bc4c221a44cc4", "committedDate": "2022-07-13 16:26:20 -0700", "message": "Merge pull request #448 from Iterable/MOB-4260-check-device-token-before-disabling"}, {"oid": "42ae0158572533f77068dc93e7c01807f61c29da", "committedDate": "2022-07-15 11:40:29 -0700", "message": "Merge branch 'master' into jay/MOB-4439-update-email"}, {"oid": "0818f8d620d08706d7157875d42030ea55730fe4", "committedDate": "2022-07-18 16:15:56 -0700", "message": "fix merge error"}, {"oid": "1fba3863b456c7e54ef330f6f230172e20ac77d4", "committedDate": "2022-08-02 10:41:54 -0700", "message": "set by field"}, {"oid": "4100141101fdf973d456cd14e7c70478fe3b0024", "committedDate": "2022-08-03 09:48:16 -0700", "message": "SetEmail and SetUserID to accept new authToken"}, {"oid": "8439966304b76aba941564188db77be8bfc75047", "committedDate": "2022-08-09 12:44:26 -0700", "message": "Making setAuthToken public"}, {"oid": "25acec4bad334751cb3de23e5fe228afb2d1330d", "committedDate": "2022-08-25 16:02:29 -0700", "message": "initial reorg"}, {"oid": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "committedDate": "2022-08-25 16:15:13 -0700", "message": "part 2"}, {"oid": "4caf9d620d8e9e51ea51e5d0fd4085b4c323ad64", "committedDate": "2022-08-29 11:23:03 -0700", "message": "remove unused import"}, {"oid": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "committedDate": "2022-08-29 14:56:48 -0700", "message": "move private/internal to the top"}, {"oid": "746622f1ae432f695678552ded793886700e8391", "committedDate": "2022-08-29 15:13:06 -0700", "message": "move main instance to the top"}, {"oid": "e6c4349377a9bc31054035be5ee860fad9c6cc66", "committedDate": "2022-08-29 15:13:54 -0700", "message": "android studio auto spacing"}, {"oid": "c463f636c63ac87817cb106aea9304bc315c2328", "committedDate": "2023-02-26 13:53:10 -0800", "message": "Log warn instead of error"}, {"oid": "898f9e91c38f6911e9ef442bf7c43e825566ab25", "committedDate": "2023-03-16 22:05:34 +0530", "message": "For firetv call update user with device details upon initialization"}, {"oid": "6f55d7ffbb159f0da019022442ca49b4dec7607b", "committedDate": "2023-03-20 17:16:30 +0530", "message": "Fix firetv object structure"}, {"oid": "fb3870743b91925e02250bc2f039af1c90eb4eca", "committedDate": "2023-03-21 23:39:47 -0400", "message": "[MOB - 5873] - Public getters for Email UserID and Auth"}, {"oid": "cb0e4c36556bee6d9c7b6731398e88e290a35325", "committedDate": "2023-03-21 23:49:09 -0400", "message": "[MOB - 5874] - Schedule auth refresh when auth null"}, {"oid": "4aea9b25979421e60176a15d7b1b3b7761d0e2df", "committedDate": "2023-03-22 19:03:48 -0400", "message": "Merge pull request #534 from Iterable/MOB-5874-authToken-refresh-when-null"}, {"oid": "6c0a9a2cf75a3cf190afe0332616a983b061c09f", "committedDate": "2023-04-03 10:58:42 -0700", "message": "Merge branch 'master' into firetv-updateuser-fix"}, {"oid": "37f07c4f78e6ee8a6ded0b73596d9c936c550f4d", "committedDate": "2023-05-02 10:54:06 -0700", "message": "Merge pull request #474 from Iterable/jay/MOB-4666-in-apps-config-memory"}, {"oid": "e23204965fe605644365a5d4628262e8dd0b8059", "committedDate": "2023-05-10 20:12:24 -0700", "message": "Merge branch 'master' into firetv-updateuser-fix"}, {"oid": "62ac73eaa6930051118365734add3250e52185d2", "committedDate": "2023-05-17 13:50:41 -0700", "message": "[MOB-6055] - [OMNI CG] - Add callbacks to setting email/user id (#570)"}]}, {"oid": "0df1d13e97f4309ceeffaa44eced378bf1bbbea8", "url": "https://github.com/Iterable/iterable-android-sdk/commit/0df1d13e97f4309ceeffaa44eced378bf1bbbea8", "message": "[MOB-2411] - Offline flag in config\n\nRevised PR:\n1.  Added offlineProcessing boolean flag in `IterableConfig` defaulted to false with package private method `setOfflineProcessing`\n2.  Added setOfflineProcessingEnabled method in apiClient for IterableApi to be able to set offline/online mode after/during initializaiton.\n3.  Based on flag true or false, online or offline requestProcessor is initialized. Any requestprocessor invocation before that will pass through onlineRequestProcessor\n\nupdate: Reverted to `non-static` for apiclient and authHandler", "committedDate": "2020-12-17T07:01:14Z", "type": "forcePushed"}, {"oid": "2054682a3e1a1739799491e1a485e8eba2b3fe2c", "url": "https://github.com/Iterable/iterable-android-sdk/commit/2054682a3e1a1739799491e1a485e8eba2b3fe2c", "message": "[MOB-2411] - Offline flag in config\n\nRevised PR:\n1.  Added offlineProcessing boolean flag in `IterableConfig` defaulted to false with package private method `setOfflineProcessing`\n2.  Added setOfflineProcessingEnabled method in apiClient for IterableApi to be able to set offline/online mode after/during initializaiton.\n3.  Based on flag true or false, online or offline requestProcessor is initialized. Any requestprocessor invocation before that will pass through onlineRequestProcessor\n\nupdate: Reverted to `non-static` for apiclient and authHandler", "committedDate": "2020-12-17T17:30:47Z", "type": "forcePushed"}, {"oid": "1c46dfd2cda0a545bec6e59f3ce6425f657a3309", "url": "https://github.com/Iterable/iterable-android-sdk/commit/1c46dfd2cda0a545bec6e59f3ce6425f657a3309", "message": "[MOB-2411] - Offline flag in config\n\nRevised PR:\n1.  Added offlineProcessing boolean flag in `IterableConfig` defaulted to false with package private method `setOfflineProcessing`\n2.  Added setOfflineProcessingEnabled method in apiClient for IterableApi to be able to set offline/online mode after/during initializaiton.\n3.  Based on flag true or false, online or offline requestProcessor is initialized. Any requestprocessor invocation before that will pass through onlineRequestProcessor\n\nupdate: Reverted to `non-static` for apiclient and authHandler", "committedDate": "2020-12-18T00:09:27Z", "type": "forcePushed"}, {"oid": "9564b3d7c0ed563ab9523cabca6036247a9cc55d", "url": "https://github.com/Iterable/iterable-android-sdk/commit/9564b3d7c0ed563ab9523cabca6036247a9cc55d", "message": "[MOB-2411] - Offline flag in config\n\nRevised PR:\n1.  Added offlineProcessing boolean flag in `IterableConfig` defaulted to false with package private method `setOfflineProcessing`\n2.  Added setOfflineProcessingEnabled method in apiClient for IterableApi to be able to set offline/online mode after/during initializaiton.\n3.  Based on flag true or false, online or offline requestProcessor is initialized. Any requestprocessor invocation before that will pass through onlineRequestProcessor\n\nupdate: Reverted to `non-static` for apiclient and authHandler", "committedDate": "2020-12-18T01:29:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3NDQ0OQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/298#discussion_r545574449", "body": "The test now checks for two things at the same time: that `setOfflineProcessingEnabled` was called and that no API requests are being made. I think ideally it shouldn't be explicitly checking for `setOfflineProcessingEnabled`.", "bodyText": "The test now checks for two things at the same time: that setOfflineProcessingEnabled was called and that no API requests are being made. I think ideally it shouldn't be explicitly checking for setOfflineProcessingEnabled.", "bodyHTML": "<p dir=\"auto\">The test now checks for two things at the same time: that <code>setOfflineProcessingEnabled</code> was called and that no API requests are being made. I think ideally it shouldn't be explicitly checking for <code>setOfflineProcessingEnabled</code>.</p>", "author": "vbabenkoru", "createdAt": "2020-12-18T05:02:30Z", "path": "iterableapi/src/test/java/com/iterable/iterableapi/IterableApiTest.java", "diffHunk": "@@ -81,9 +82,10 @@ private void reInitIterableApi() {\n \n     @Test\n     public void testSdkInitializedWithoutEmailOrUserId() throws Exception {\n-        IterableApi.initialize(getContext(), \"apiKey\");\n-        IterableApi.getInstance().setEmail(null);\n+        IterableApi.initialize(getContext(), \"testApiKey\");\n+        verify(mockApiClient, times(1)).setOfflineProcessingEnabled(anyBoolean());", "originalCommit": "9564b3d7c0ed563ab9523cabca6036247a9cc55d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY1ODYxMw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/298#discussion_r545658613", "bodyText": "Using clearInvocation \ud83d\udc4d", "author": "Ayyanchira", "createdAt": "2020-12-18T08:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3NDQ0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "9fe092b6653b709eb59e85092641549475ac901f", "changed_code": [{"header": "diff --git a/iterableapi/src/test/java/com/iterable/iterableapi/IterableApiTest.java b/iterableapi/src/test/java/com/iterable/iterableapi/IterableApiTest.java\nindex 76c5b36b..bb2a74d5 100644\n--- a/iterableapi/src/test/java/com/iterable/iterableapi/IterableApiTest.java\n+++ b/iterableapi/src/test/java/com/iterable/iterableapi/IterableApiTest.java\n", "chunk": "@@ -82,8 +82,8 @@ public class IterableApiTest extends BaseTest {\n \n     @Test\n     public void testSdkInitializedWithoutEmailOrUserId() throws Exception {\n-        IterableApi.initialize(getContext(), \"testApiKey\");\n-        verify(mockApiClient, times(1)).setOfflineProcessingEnabled(anyBoolean());\n+        IterableApi.initialize(getContext(), \"apiKey\");\n+        clearInvocations(mockApiClient);\n \n         IterableApi.getInstance().setEmail(null);\n         // Verify that none of the calls to the API result in a request\n", "next_change": null}]}, "revised_code_in_main": {"commit": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "changed_code": [{"header": "diff --git a/iterableapi/src/test/java/com/iterable/iterableapi/IterableApiTest.java b/iterableapi/src/test/java/com/iterable/iterableapi/IterableApiTest.java\nindex 76c5b36b..bb2a74d5 100644\n--- a/iterableapi/src/test/java/com/iterable/iterableapi/IterableApiTest.java\n+++ b/iterableapi/src/test/java/com/iterable/iterableapi/IterableApiTest.java\n", "chunk": "@@ -82,8 +82,8 @@ public class IterableApiTest extends BaseTest {\n \n     @Test\n     public void testSdkInitializedWithoutEmailOrUserId() throws Exception {\n-        IterableApi.initialize(getContext(), \"testApiKey\");\n-        verify(mockApiClient, times(1)).setOfflineProcessingEnabled(anyBoolean());\n+        IterableApi.initialize(getContext(), \"apiKey\");\n+        clearInvocations(mockApiClient);\n \n         IterableApi.getInstance().setEmail(null);\n         // Verify that none of the calls to the API result in a request\n", "next_change": null}]}, "commits_in_main": [{"oid": "4348e1070726cc408a9a9d7d1e6c84a3351d427c", "message": "Merge commit", "committedDate": null}, {"oid": "29e515a03708728d72f5560cc1492074fa344a08", "committedDate": "2020-12-22 13:13:32 -0800", "message": "[MOB-2285] - Add OS version to getMessagesAPI"}, {"oid": "68888566277f1960bfe6dd8758af6ae0aed8fa61", "committedDate": "2020-12-22 16:51:00 -0800", "message": "[MOB - 2371] - Delete all tasks on log out"}, {"oid": "ac66cca1fb9fa76addbe98334592ee12aeabbe99", "committedDate": "2020-12-28 14:50:01 -0800", "message": "Merge pull request #302 from Iterable/MOB-2371-Delete-all-tasks-on-logout"}, {"oid": "19b2053245b7171ddffbc4046af8c2a6ab616443", "committedDate": "2021-01-24 20:54:50 -0800", "message": "Revision"}, {"oid": "5e3325282a8ca0b7d616e74cd77b0f4e56808787", "committedDate": "2021-01-26 16:02:26 -0800", "message": "[MOB - 2541] - Remove offline configuration from IterableConfig"}, {"oid": "7525fb27a7da107bfa2c991764d94e3ba153e78c", "committedDate": "2021-05-25 21:49:11 +0530", "message": "Revision 3"}, {"oid": "4c858d368135eee9298837a5e0314cc13624006d", "committedDate": "2021-07-01 01:07:37 +0530", "message": "[MOB - 3087] - Remove link redirection test"}, {"oid": "a25ec805df060991fb94eccc3c19958650866398", "committedDate": "2021-12-16 16:11:54 -0800", "message": "change deep link API to be instanced"}, {"oid": "d3fc945eb3d381b89666f1c3bc792bf54380d76c", "committedDate": "2021-12-16 18:17:31 -0800", "message": "fix IterableInAppManager and some test links"}, {"oid": "d20923d28c8cff94e789a6a9a2b3a5ff9943e1a7", "committedDate": "2022-06-21 14:55:07 -0700", "message": "ignore now broken unit test"}, {"oid": "bd0594f237559bdcb0c0c15f8d1b2e38977c0972", "committedDate": "2022-07-11 09:42:49 -0700", "message": "[MOB-4537] - Change from beta to SDKOfflineMode"}, {"oid": "b0e3f885090fc151951df5b0e7a6563ea9f797ee", "committedDate": "2022-07-11 13:38:51 -0700", "message": "Made recommended changes"}, {"oid": "90902c206ea3a2b7d0630b820a26030e906f0675", "committedDate": "2023-04-14 18:00:11 +0530", "message": "update unit test"}, {"oid": "a287522854f5706c9799f83e6c5ac396048c78f4", "committedDate": "2023-04-18 21:10:25 +0530", "message": "Added import for DeviceInfoUtils"}, {"oid": "62ac73eaa6930051118365734add3250e52185d2", "committedDate": "2023-05-17 13:50:41 -0700", "message": "[MOB-6055] - [OMNI CG] - Add callbacks to setting email/user id (#570)"}]}, {"oid": "9fe092b6653b709eb59e85092641549475ac901f", "url": "https://github.com/Iterable/iterable-android-sdk/commit/9fe092b6653b709eb59e85092641549475ac901f", "message": "[MOB-2411] - Offline flag in config\n\nRevised PR:\n1.  Added offlineProcessing boolean flag in `IterableConfig` defaulted to false with package private method `setOfflineProcessing`\n2.  Added setOfflineProcessingEnabled method in apiClient for IterableApi to be able to set offline/online mode after/during initializaiton.\n3.  Based on flag true or false, online or offline requestProcessor is initialized. Any requestprocessor invocation before that will pass through onlineRequestProcessor\n\nupdate: Reverted to `non-static` for apiclient and authHandler", "committedDate": "2020-12-18T08:31:54Z", "type": "commit"}, {"oid": "9fe092b6653b709eb59e85092641549475ac901f", "url": "https://github.com/Iterable/iterable-android-sdk/commit/9fe092b6653b709eb59e85092641549475ac901f", "message": "[MOB-2411] - Offline flag in config\n\nRevised PR:\n1.  Added offlineProcessing boolean flag in `IterableConfig` defaulted to false with package private method `setOfflineProcessing`\n2.  Added setOfflineProcessingEnabled method in apiClient for IterableApi to be able to set offline/online mode after/during initializaiton.\n3.  Based on flag true or false, online or offline requestProcessor is initialized. Any requestprocessor invocation before that will pass through onlineRequestProcessor\n\nupdate: Reverted to `non-static` for apiclient and authHandler", "committedDate": "2020-12-18T08:31:54Z", "type": "forcePushed"}]}