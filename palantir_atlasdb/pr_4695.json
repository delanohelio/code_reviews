{"pr_number": 4695, "pr_title": "[Timelock Partitioning] Allow Switching to Batched Single Leader", "pr_author": "gmaretic", "pr_createdAt": "2020-04-02T19:46:45Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4695", "timeline": [{"oid": "35f361d365dfe9257ca0d6f469309e7180badc5f", "url": "https://github.com/palantir/atlasdb/commit/35f361d365dfe9257ca0d6f469309e7180badc5f", "message": "Wip", "committedDate": "2020-04-02T16:25:51Z", "type": "commit"}, {"oid": "f2249c8e1195b581317302c447500c5c4bfb3837", "url": "https://github.com/palantir/atlasdb/commit/f2249c8e1195b581317302c447500c5c4bfb3837", "message": "Refactor", "committedDate": "2020-04-02T16:30:43Z", "type": "commit"}, {"oid": "77f26eb4cf4eb1937911b4a13716136dd77b22ef", "url": "https://github.com/palantir/atlasdb/commit/77f26eb4cf4eb1937911b4a13716136dd77b22ef", "message": "Add file", "committedDate": "2020-04-02T16:31:36Z", "type": "commit"}, {"oid": "ca200850c96d12511f0f426d77e8b5b8abc50d9d", "url": "https://github.com/palantir/atlasdb/commit/ca200850c96d12511f0f426d77e8b5b8abc50d9d", "message": "Add tests", "committedDate": "2020-04-02T17:13:38Z", "type": "commit"}, {"oid": "f2d693784bad9bfd06f616fe852de57c07662efb", "url": "https://github.com/palantir/atlasdb/commit/f2d693784bad9bfd06f616fe852de57c07662efb", "message": "Fix tests and some small nits:", "committedDate": "2020-04-02T19:46:36Z", "type": "commit"}, {"oid": "2aaebee4d2ab0ffc623a4b214451c2e9d0b0cdaf", "url": "https://github.com/palantir/atlasdb/commit/2aaebee4d2ab0ffc623a4b214451c2e9d0b0cdaf", "message": "Fix other template", "committedDate": "2020-04-03T09:48:42Z", "type": "commit"}, {"oid": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "url": "https://github.com/palantir/atlasdb/commit/882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "message": "Add generated changelog entries", "committedDate": "2020-04-03T09:48:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3MDQ1Nw==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r404970457", "body": "uncertain: Might be better to use primitive `BooleanSupplier`, though I wouldn't block if you need `Supplier<T>` for something down the line.", "bodyText": "uncertain: Might be better to use primitive BooleanSupplier, though I wouldn't block if you need Supplier<T> for something down the line.", "bodyHTML": "<p dir=\"auto\">uncertain: Might be better to use primitive <code>BooleanSupplier</code>, though I wouldn't block if you need <code>Supplier&lt;T&gt;</code> for something down the line.</p>", "author": "jeremyk-91", "createdAt": "2020-04-07T17:04:01Z", "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/SingleLeaderNetworkClientFactories.java", "diffHunk": "@@ -26,21 +27,25 @@\n import com.palantir.paxos.PaxosLearnerNetworkClient;\n import com.palantir.paxos.SingleLeaderAcceptorNetworkClient;\n import com.palantir.paxos.SingleLeaderLearnerNetworkClient;\n-import com.palantir.timelock.paxos.TimelockPaxosAcceptorAdapter;\n-import com.palantir.timelock.paxos.TimelockPaxosLearnerAdapter;\n+import com.palantir.timelock.paxos.TimelockPaxosAcceptorAdapters;\n+import com.palantir.timelock.paxos.TimelockPaxosLearnerAdapters;\n \n @Value.Immutable\n abstract class SingleLeaderNetworkClientFactories implements\n         NetworkClientFactories, Dependencies.NetworkClientFactories {\n \n+    @Value.Default\n+    Supplier<Boolean> useBatchedEndpoints() {", "originalCommit": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkxMzIwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r408913205", "bodyText": "PredicateSwitchedProxy uses Supplier<Boolean> so just more consistent", "author": "gmaretic", "createdAt": "2020-04-15T15:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3MDQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3Nzc1MQ==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r404977751", "body": "Let's use an `AtomicLong` and `accumulateAndGet`: not _wrong_ because of how it's used, but there could be unwanted race conditions", "bodyText": "Let's use an AtomicLong and accumulateAndGet: not wrong because of how it's used, but there could be unwanted race conditions", "bodyHTML": "<p dir=\"auto\">Let's use an <code>AtomicLong</code> and <code>accumulateAndGet</code>: not <em>wrong</em> because of how it's used, but there could be unwanted race conditions</p>", "author": "jeremyk-91", "createdAt": "2020-04-07T17:15:11Z", "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.paxos;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n+import com.google.common.collect.Iterables;\n+import com.palantir.atlasdb.timelock.paxos.BatchPaxosLearnerRpcClient;\n+import com.palantir.atlasdb.timelock.paxos.Client;\n+import com.palantir.atlasdb.timelock.paxos.PaxosUseCase;\n+import com.palantir.atlasdb.timelock.paxos.WithSeq;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosValue;\n+\n+public class BatchTimelockPaxosLearnerAdapter implements PaxosLearner {\n+    private final PaxosUseCase paxosUseCase;\n+    private final Client client;\n+    private final BatchPaxosLearnerRpcClient rpcClient;\n+\n+    private volatile long lastKnownSequence = Long.MIN_VALUE;\n+\n+    public BatchTimelockPaxosLearnerAdapter(\n+            PaxosUseCase paxosUseCase,\n+            Client client,\n+            BatchPaxosLearnerRpcClient rpcClient) {\n+        this.paxosUseCase = paxosUseCase;\n+        this.client = client;\n+        this.rpcClient = rpcClient;\n+    }\n+\n+    public static PaxosLearner singleLeader(BatchPaxosLearnerRpcClient rpcClient) {\n+        return new BatchTimelockPaxosLearnerAdapter(\n+                PaxosUseCase.LEADER_FOR_ALL_CLIENTS,\n+                PaxosUseCase.PSEUDO_LEADERSHIP_CLIENT,\n+                rpcClient);\n+    }\n+\n+    @Override\n+    public void learn(long seq, PaxosValue val) {\n+        rpcClient.learn(paxosUseCase, ImmutableSetMultimap.of(client, val));\n+        updateLastKnownSequence(seq);\n+    }\n+\n+    @Override\n+    public Optional<PaxosValue> getLearnedValue(long seq) {\n+        Set<PaxosValue> result = rpcClient.getLearnedValues(paxosUseCase, ImmutableSet.of(WithSeq.of(client, seq)))\n+                .get(client);\n+        checkResult(result);\n+        if (result.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        updateLastKnownSequence(seq);\n+        return Optional.of(Iterables.getOnlyElement(result));\n+    }\n+\n+    @Override\n+    public Optional<PaxosValue> getGreatestLearnedValue() {\n+        Set<PaxosValue> result = rpcClient\n+                .getLearnedValuesSince(paxosUseCase, ImmutableMap.of(client, lastKnownSequence))\n+                .get(client);\n+        Optional<PaxosValue> greatestIfExists = result.stream()\n+                .reduce((fst, snd) -> fst.getRound() > snd.getRound() ? fst : snd);\n+        greatestIfExists.ifPresent(paxosValue -> updateLastKnownSequence(paxosValue.getRound()));\n+        return greatestIfExists;\n+    }\n+\n+    @Override\n+    public Collection<PaxosValue> getLearnedValuesSince(long seq) {\n+        Set<PaxosValue> result = rpcClient.getLearnedValuesSince(paxosUseCase, ImmutableMap.of(client, seq))\n+                .get(client);\n+        result.stream().map(PaxosValue::getRound).mapToLong(x -> x).max().ifPresent(this::updateLastKnownSequence);\n+        return result;\n+    }\n+\n+    private <T> void checkResult(Set<T> result) {\n+        Preconditions.checkState(result.size() <= 1,\n+                \"Unexpected result {} in a call for client {}.\",\n+                SafeArg.of(\"result\", result),\n+                SafeArg.of(\"client\", client));\n+    }\n+\n+    private void updateLastKnownSequence(long seq) {\n+        if (seq > lastKnownSequence) {\n+            lastKnownSequence = seq;\n+        }", "originalCommit": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3OTkxMQ==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r404979911", "body": "Nice! Many ways to go about this, and looks like you picked the one that touches the volatile/atomic thing as little as possible.", "bodyText": "Nice! Many ways to go about this, and looks like you picked the one that touches the volatile/atomic thing as little as possible.", "bodyHTML": "<p dir=\"auto\">Nice! Many ways to go about this, and looks like you picked the one that touches the volatile/atomic thing as little as possible.</p>", "author": "jeremyk-91", "createdAt": "2020-04-07T17:18:44Z", "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.paxos;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n+import com.google.common.collect.Iterables;\n+import com.palantir.atlasdb.timelock.paxos.BatchPaxosLearnerRpcClient;\n+import com.palantir.atlasdb.timelock.paxos.Client;\n+import com.palantir.atlasdb.timelock.paxos.PaxosUseCase;\n+import com.palantir.atlasdb.timelock.paxos.WithSeq;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosValue;\n+\n+public class BatchTimelockPaxosLearnerAdapter implements PaxosLearner {\n+    private final PaxosUseCase paxosUseCase;\n+    private final Client client;\n+    private final BatchPaxosLearnerRpcClient rpcClient;\n+\n+    private volatile long lastKnownSequence = Long.MIN_VALUE;\n+\n+    public BatchTimelockPaxosLearnerAdapter(\n+            PaxosUseCase paxosUseCase,\n+            Client client,\n+            BatchPaxosLearnerRpcClient rpcClient) {\n+        this.paxosUseCase = paxosUseCase;\n+        this.client = client;\n+        this.rpcClient = rpcClient;\n+    }\n+\n+    public static PaxosLearner singleLeader(BatchPaxosLearnerRpcClient rpcClient) {\n+        return new BatchTimelockPaxosLearnerAdapter(\n+                PaxosUseCase.LEADER_FOR_ALL_CLIENTS,\n+                PaxosUseCase.PSEUDO_LEADERSHIP_CLIENT,\n+                rpcClient);\n+    }\n+\n+    @Override\n+    public void learn(long seq, PaxosValue val) {\n+        rpcClient.learn(paxosUseCase, ImmutableSetMultimap.of(client, val));\n+        updateLastKnownSequence(seq);\n+    }\n+\n+    @Override\n+    public Optional<PaxosValue> getLearnedValue(long seq) {\n+        Set<PaxosValue> result = rpcClient.getLearnedValues(paxosUseCase, ImmutableSet.of(WithSeq.of(client, seq)))\n+                .get(client);\n+        checkResult(result);\n+        if (result.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        updateLastKnownSequence(seq);\n+        return Optional.of(Iterables.getOnlyElement(result));\n+    }\n+\n+    @Override\n+    public Optional<PaxosValue> getGreatestLearnedValue() {\n+        Set<PaxosValue> result = rpcClient\n+                .getLearnedValuesSince(paxosUseCase, ImmutableMap.of(client, lastKnownSequence))\n+                .get(client);\n+        Optional<PaxosValue> greatestIfExists = result.stream()\n+                .reduce((fst, snd) -> fst.getRound() > snd.getRound() ? fst : snd);\n+        greatestIfExists.ifPresent(paxosValue -> updateLastKnownSequence(paxosValue.getRound()));\n+        return greatestIfExists;\n+    }\n+\n+    @Override\n+    public Collection<PaxosValue> getLearnedValuesSince(long seq) {\n+        Set<PaxosValue> result = rpcClient.getLearnedValuesSince(paxosUseCase, ImmutableMap.of(client, seq))\n+                .get(client);\n+        result.stream().map(PaxosValue::getRound).mapToLong(x -> x).max().ifPresent(this::updateLastKnownSequence);", "originalCommit": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4MDk1Mw==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r404980953", "body": "Equivalent, but I think I like the readability of this better:\r\n\r\n```suggestion\r\n                .max(Comparator.comparingLong(PaxosValue::getRound));\r\n```", "bodyText": "Equivalent, but I think I like the readability of this better:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .reduce((fst, snd) -> fst.getRound() > snd.getRound() ? fst : snd);\n          \n          \n            \n                            .max(Comparator.comparingLong(PaxosValue::getRound));", "bodyHTML": "<p dir=\"auto\">Equivalent, but I think I like the readability of this better:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                .<span class=\"x x-first\">reduce((fst, snd) </span><span class=\"pl-k x\">-</span><span class=\"pl-k x\">&gt;</span><span class=\"x\"> fst</span><span class=\"pl-k x\">.</span><span class=\"x\">getRound() </span><span class=\"pl-k x\">&gt;</span><span class=\"x\"> snd</span><span class=\"pl-k x x-last\">.</span>getRound<span class=\"x x-first\">() </span><span class=\"pl-k x\">?</span><span class=\"x\"> fst </span><span class=\"pl-k x\">:</span><span class=\"x x-last\"> snd</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                .<span class=\"x x-first\">max(</span><span class=\"pl-smi x\">Comparator</span><span class=\"pl-k x\">.</span><span class=\"x\">comparingLong(</span><span class=\"pl-smi x\">PaxosValue</span><span class=\"pl-k x x-last\">::</span>getRound<span class=\"x x-first x-last\">)</span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "jeremyk-91", "createdAt": "2020-04-07T17:20:23Z", "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.paxos;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n+import com.google.common.collect.Iterables;\n+import com.palantir.atlasdb.timelock.paxos.BatchPaxosLearnerRpcClient;\n+import com.palantir.atlasdb.timelock.paxos.Client;\n+import com.palantir.atlasdb.timelock.paxos.PaxosUseCase;\n+import com.palantir.atlasdb.timelock.paxos.WithSeq;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosValue;\n+\n+public class BatchTimelockPaxosLearnerAdapter implements PaxosLearner {\n+    private final PaxosUseCase paxosUseCase;\n+    private final Client client;\n+    private final BatchPaxosLearnerRpcClient rpcClient;\n+\n+    private volatile long lastKnownSequence = Long.MIN_VALUE;\n+\n+    public BatchTimelockPaxosLearnerAdapter(\n+            PaxosUseCase paxosUseCase,\n+            Client client,\n+            BatchPaxosLearnerRpcClient rpcClient) {\n+        this.paxosUseCase = paxosUseCase;\n+        this.client = client;\n+        this.rpcClient = rpcClient;\n+    }\n+\n+    public static PaxosLearner singleLeader(BatchPaxosLearnerRpcClient rpcClient) {\n+        return new BatchTimelockPaxosLearnerAdapter(\n+                PaxosUseCase.LEADER_FOR_ALL_CLIENTS,\n+                PaxosUseCase.PSEUDO_LEADERSHIP_CLIENT,\n+                rpcClient);\n+    }\n+\n+    @Override\n+    public void learn(long seq, PaxosValue val) {\n+        rpcClient.learn(paxosUseCase, ImmutableSetMultimap.of(client, val));\n+        updateLastKnownSequence(seq);\n+    }\n+\n+    @Override\n+    public Optional<PaxosValue> getLearnedValue(long seq) {\n+        Set<PaxosValue> result = rpcClient.getLearnedValues(paxosUseCase, ImmutableSet.of(WithSeq.of(client, seq)))\n+                .get(client);\n+        checkResult(result);\n+        if (result.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        updateLastKnownSequence(seq);\n+        return Optional.of(Iterables.getOnlyElement(result));\n+    }\n+\n+    @Override\n+    public Optional<PaxosValue> getGreatestLearnedValue() {\n+        Set<PaxosValue> result = rpcClient\n+                .getLearnedValuesSince(paxosUseCase, ImmutableMap.of(client, lastKnownSequence))\n+                .get(client);\n+        Optional<PaxosValue> greatestIfExists = result.stream()\n+                .reduce((fst, snd) -> fst.getRound() > snd.getRound() ? fst : snd);", "originalCommit": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4NjQzMg==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r404986432", "body": "Discussed offline: Here, iteration order is very important. It's *essential* that we go through these in the same order - and while these are both lists, there is an underlying set and technically no guarantee that the iteration order is consistent. Thus, I'd suggest making `PaxosResourcesFactory#remoteUris` return a list rather than a set.", "bodyText": "Discussed offline: Here, iteration order is very important. It's essential that we go through these in the same order - and while these are both lists, there is an underlying set and technically no guarantee that the iteration order is consistent. Thus, I'd suggest making PaxosResourcesFactory#remoteUris return a list rather than a set.", "bodyHTML": "<p dir=\"auto\">Discussed offline: Here, iteration order is very important. It's <em>essential</em> that we go through these in the same order - and while these are both lists, there is an underlying set and technically no guarantee that the iteration order is consistent. Thus, I'd suggest making <code>PaxosResourcesFactory#remoteUris</code> return a list rather than a set.</p>", "author": "jeremyk-91", "createdAt": "2020-04-07T17:28:53Z", "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/TimelockPaxosAcceptorAdapters.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.paxos;\n+\n+import java.util.List;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.Streams;\n+import com.palantir.atlasdb.timelock.paxos.BatchPaxosAcceptorRpcClient;\n+import com.palantir.atlasdb.timelock.paxos.Client;\n+import com.palantir.atlasdb.timelock.paxos.PaxosRemoteClients;\n+import com.palantir.atlasdb.timelock.paxos.PaxosUseCase;\n+import com.palantir.common.proxy.PredicateSwitchedProxy;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+import com.palantir.paxos.PaxosAcceptor;\n+\n+public final class TimelockPaxosAcceptorAdapters {\n+    private TimelockPaxosAcceptorAdapters() {\n+        // pl0x n0\n+    }\n+\n+    public static List<PaxosAcceptor> create(\n+            PaxosUseCase paxosUseCase,\n+            PaxosRemoteClients remoteClients,\n+            Supplier<Boolean> useBatchedSingleLeader,\n+            Client client) {\n+        switch (paxosUseCase) {\n+            case LEADER_FOR_ALL_CLIENTS:\n+                return Streams.zip(\n+                        remoteClients.batchAcceptor().stream(),\n+                        remoteClients.singleLeaderAcceptor().stream(),", "originalCommit": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4Nzg1OQ==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r404987859", "body": "\ud83d\udcaf ", "bodyText": "\ud83d\udcaf", "bodyHTML": "<p dir=\"auto\"><g-emoji class=\"g-emoji\" alias=\"100\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f4af.png\">\ud83d\udcaf</g-emoji></p>", "author": "jeremyk-91", "createdAt": "2020-04-07T17:31:01Z", "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/TimelockPaxosLearnerAdapters.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.paxos;\n+\n+import java.util.List;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.Streams;\n+import com.palantir.atlasdb.timelock.paxos.BatchPaxosLearnerRpcClient;\n+import com.palantir.atlasdb.timelock.paxos.Client;\n+import com.palantir.atlasdb.timelock.paxos.PaxosRemoteClients;\n+import com.palantir.atlasdb.timelock.paxos.PaxosUseCase;\n+import com.palantir.common.proxy.PredicateSwitchedProxy;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+import com.palantir.paxos.PaxosLearner;\n+\n+public final class TimelockPaxosLearnerAdapters {\n+    private TimelockPaxosLearnerAdapters() {\n+        // how many times", "originalCommit": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5MDU0OA==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r404990548", "body": "These should be `9086` and `9092`, just because of wiremock we might actually use six ports, not three.", "bodyText": "These should be 9086 and 9092, just because of wiremock we might actually use six ports, not three.", "bodyHTML": "<p dir=\"auto\">These should be <code>9086</code> and <code>9092</code>, just because of wiremock we might actually use six ports, not three.</p>", "author": "jeremyk-91", "createdAt": "2020-04-07T17:35:13Z", "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/suite/SingleLeaderPaxosSuite.java", "diffHunk": "@@ -43,20 +43,29 @@\n             \"non-batched timestamp paxos single leader\",\n             \"paxosMultiServer.ftl\",\n             generateThreeNodeTimelockCluster(9080, builder ->\n-                    builder.clientPaxosBuilder(builder.clientPaxosBuilder().isUseBatchPaxos(false))\n+                    builder.clientPaxosBuilder(builder.clientPaxosBuilder().isUseBatchPaxosTimestamp(false))\n                             .leaderMode(PaxosLeaderMode.SINGLE_LEADER)));\n \n     public static final TestableTimelockCluster BATCHED_TIMESTAMP_PAXOS = new TestableTimelockCluster(\n             \"batched timestamp paxos single leader\",\n             \"paxosMultiServer.ftl\",\n             generateThreeNodeTimelockCluster(9083, builder ->", "originalCommit": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c1df9987b4512160b021b4e6fb7a7553893d081", "url": "https://github.com/palantir/atlasdb/commit/5c1df9987b4512160b021b4e6fb7a7553893d081", "message": "Address CR", "committedDate": "2020-04-15T15:26:07Z", "type": "commit"}, {"oid": "0fbd9073e2ae4f46f972e5d6ee536e32c74f0af2", "url": "https://github.com/palantir/atlasdb/commit/0fbd9073e2ae4f46f972e5d6ee536e32c74f0af2", "message": "Merge branch 'develop' of github.com:palantir/atlasdb into tp/allow-bsl", "committedDate": "2020-04-15T15:26:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNDU1Mg==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r409024552", "body": "I would have thought `containsExactly` (without the `inAnyOrder` bit) would have been enough?", "bodyText": "I would have thought containsExactly (without the inAnyOrder bit) would have been enough?", "bodyHTML": "<p dir=\"auto\">I would have thought <code>containsExactly</code> (without the <code>inAnyOrder</code> bit) would have been enough?</p>", "author": "jeremyk-91", "createdAt": "2020-04-15T17:49:09Z", "path": "timelock-agent/src/test/java/com/palantir/timelock/paxos/PaxosRemotingUtilsTest.java", "diffHunk": "@@ -141,14 +136,14 @@ public void addProtocolAddsHttpsIfSslPresent() {\n \n     @Test\n     public void addProtocolsAddsHttpIfSslNotPresent() {\n-        assertThat(PaxosRemotingUtils.addProtocols(NO_SSL_TIMELOCK, ImmutableSet.of(\"foo:1\", \"bar:2\")))\n-                .containsExactlyInAnyOrder(\"http://foo:1\", \"http://bar:2\");\n+        assertThat(PaxosRemotingUtils.addProtocols(NO_SSL_TIMELOCK, ImmutableList.of(\"foo:1\", \"bar:2\")))\n+                .isEqualTo(ImmutableList.of(\"http://foo:1\", \"http://bar:2\"));\n     }\n \n     @Test\n     public void addProtocolsAddsHttpsIfSslPresent() {\n-        assertThat(PaxosRemotingUtils.addProtocols(SSL_TIMELOCK, ImmutableSet.of(\"foo:1\", \"bar:2\")))\n-                .containsExactlyInAnyOrder(\"https://foo:1\", \"https://bar:2\");\n+        assertThat(PaxosRemotingUtils.addProtocols(SSL_TIMELOCK, ImmutableList.of(\"foo:1\", \"bar:2\")))\n+                .isEqualTo(ImmutableList.of(\"https://foo:1\", \"https://bar:2\"));", "originalCommit": "5c1df9987b4512160b021b4e6fb7a7553893d081", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}