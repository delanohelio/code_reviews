{"pr_number": 5089, "pr_title": "[TimeLock Corruption Detection] | Integration tests", "pr_createdAt": "2020-10-28T11:11:50Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5089", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5OTY0OA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513499648", "bodyText": "nit: final class?", "author": "Jolyon-S", "createdAt": "2020-10-28T14:41:26Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {", "originalCommit": "aa636be9a4844829b9d5aaad25c61428d1c701d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\ndeleted file mode 100644\nindex caa3d41e85..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,112 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.SetMultimap;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import java.util.List;\n-import java.util.stream.IntStream;\n-import org.junit.Test;\n-\n-/**\n- * This class performs integration tests by inducing and detecting corruption in one or more series.\n- * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n- */\n-public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n-\n-    @Test\n-    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n-        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1.\n-        writeLogsOnLocalAndRemote(1, 500);\n-        induceGreaterAcceptedValueCorruption(499);\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogSeqInLaterBatches() {\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(599);\n-\n-        // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n-\n-        // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n-        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(500);\n-\n-        // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n-\n-        // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        writeLogsOnLocalAndRemote(1, 400);\n-\n-        // No signs of corruption\n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n-\n-        induceGreaterAcceptedValueCorruption(250);\n-        // Detects signs of corruption in the now corrupt first batch of logs\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void detectCorruptionForMultipleCorruptSeries() {\n-        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n-        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n-\n-        assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n-    }\n-\n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n-    }\n-\n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n-    }\n-\n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nnew file mode 100644\nindex 0000000000..3f85cb00ab\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+// Note - All tests only induce and detect one type of corruption check violation ->\n+// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqInLaterBatches() {\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(599);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(500);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        writeLogsOnLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+\n+        induceGreaterAcceptedValueCorruption(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n+        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+\n+        assertDetectedViolations(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 3f85cb00ab..775bd9eee1 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -19,89 +19,97 @@ package com.palantir.timelock.corruption.detection;\n import static org.assertj.core.api.Assertions.assertThat;\n \n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n import com.google.common.collect.SetMultimap;\n import com.palantir.paxos.Client;\n import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n import java.util.List;\n import java.util.stream.IntStream;\n+import org.junit.Rule;\n import org.junit.Test;\n \n-// Note - All tests only induce and detect one type of corruption check violation ->\n-// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n-public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void detectCorruptionForLogAtSeqAtBatchEnd() {\n         // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1.\n-        writeLogsOnLocalAndRemote(1, 500);\n-        induceGreaterAcceptedValueCorruption(499);\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqInLaterBatches() {\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(599);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n \n         // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n         // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(500);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n \n         // No signs of corruption in the first batch\n         SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        writeLogsOnLocalAndRemote(1, 400);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n \n         // No signs of corruption\n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+        helper.assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n \n-        induceGreaterAcceptedValueCorruption(250);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n         // Detects signs of corruption in the now corrupt first batch of logs\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForMultipleCorruptSeries() {\n         // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n-        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        assertDetectedViolations(\n+        helper.assertDetectedViolations(\n                 ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n     private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n     private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n     private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 775bd9eee1..b9910e5b2d 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -95,24 +87,24 @@ public class CorruptionDetectionIntegrationTest {\n         IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n         IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        helper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+        helper.assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+    private void createSeriesWithPaxosLogs(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         helper.writeLogsOnLocalAndRemote(\n                 helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+    private void corruptSeries(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n         helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    private static NamespaceAndUseCase namespaceAndUseCaseForIndex(int index) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + index), \"client\");\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5OTkwOA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513499908", "bodyText": "nit: test name is hard to parse", "author": "Jolyon-S", "createdAt": "2020-10-28T14:41:45Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {", "originalCommit": "aa636be9a4844829b9d5aaad25c61428d1c701d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\ndeleted file mode 100644\nindex caa3d41e85..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,112 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.SetMultimap;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import java.util.List;\n-import java.util.stream.IntStream;\n-import org.junit.Test;\n-\n-/**\n- * This class performs integration tests by inducing and detecting corruption in one or more series.\n- * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n- */\n-public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n-\n-    @Test\n-    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n-        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1.\n-        writeLogsOnLocalAndRemote(1, 500);\n-        induceGreaterAcceptedValueCorruption(499);\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogSeqInLaterBatches() {\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(599);\n-\n-        // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n-\n-        // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n-        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(500);\n-\n-        // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n-\n-        // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        writeLogsOnLocalAndRemote(1, 400);\n-\n-        // No signs of corruption\n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n-\n-        induceGreaterAcceptedValueCorruption(250);\n-        // Detects signs of corruption in the now corrupt first batch of logs\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void detectCorruptionForMultipleCorruptSeries() {\n-        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n-        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n-\n-        assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n-    }\n-\n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n-    }\n-\n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n-    }\n-\n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nnew file mode 100644\nindex 0000000000..3f85cb00ab\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+// Note - All tests only induce and detect one type of corruption check violation ->\n+// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqInLaterBatches() {\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(599);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(500);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        writeLogsOnLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+\n+        induceGreaterAcceptedValueCorruption(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n+        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+\n+        assertDetectedViolations(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 3f85cb00ab..775bd9eee1 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -19,89 +19,97 @@ package com.palantir.timelock.corruption.detection;\n import static org.assertj.core.api.Assertions.assertThat;\n \n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n import com.google.common.collect.SetMultimap;\n import com.palantir.paxos.Client;\n import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n import java.util.List;\n import java.util.stream.IntStream;\n+import org.junit.Rule;\n import org.junit.Test;\n \n-// Note - All tests only induce and detect one type of corruption check violation ->\n-// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n-public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void detectCorruptionForLogAtSeqAtBatchEnd() {\n         // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1.\n-        writeLogsOnLocalAndRemote(1, 500);\n-        induceGreaterAcceptedValueCorruption(499);\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqInLaterBatches() {\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(599);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n \n         // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n         // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(500);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n \n         // No signs of corruption in the first batch\n         SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        writeLogsOnLocalAndRemote(1, 400);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n \n         // No signs of corruption\n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+        helper.assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n \n-        induceGreaterAcceptedValueCorruption(250);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n         // Detects signs of corruption in the now corrupt first batch of logs\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForMultipleCorruptSeries() {\n         // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n-        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        assertDetectedViolations(\n+        helper.assertDetectedViolations(\n                 ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n     private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n     private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n     private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 775bd9eee1..b9910e5b2d 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -95,24 +87,24 @@ public class CorruptionDetectionIntegrationTest {\n         IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n         IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        helper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+        helper.assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+    private void createSeriesWithPaxosLogs(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         helper.writeLogsOnLocalAndRemote(\n                 helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+    private void corruptSeries(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n         helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    private static NamespaceAndUseCase namespaceAndUseCaseForIndex(int index) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + index), \"client\");\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwNTY0NQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513505645", "bodyText": "prefer Multimap", "author": "Jolyon-S", "createdAt": "2020-10-28T14:48:32Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqInLaterBatches() {\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(599);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =", "originalCommit": "aa636be9a4844829b9d5aaad25c61428d1c701d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\ndeleted file mode 100644\nindex caa3d41e85..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,112 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.SetMultimap;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import java.util.List;\n-import java.util.stream.IntStream;\n-import org.junit.Test;\n-\n-/**\n- * This class performs integration tests by inducing and detecting corruption in one or more series.\n- * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n- */\n-public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n-\n-    @Test\n-    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n-        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1.\n-        writeLogsOnLocalAndRemote(1, 500);\n-        induceGreaterAcceptedValueCorruption(499);\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogSeqInLaterBatches() {\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(599);\n-\n-        // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n-\n-        // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n-        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(500);\n-\n-        // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n-\n-        // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        writeLogsOnLocalAndRemote(1, 400);\n-\n-        // No signs of corruption\n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n-\n-        induceGreaterAcceptedValueCorruption(250);\n-        // Detects signs of corruption in the now corrupt first batch of logs\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void detectCorruptionForMultipleCorruptSeries() {\n-        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n-        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n-\n-        assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n-    }\n-\n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n-    }\n-\n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n-    }\n-\n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nnew file mode 100644\nindex 0000000000..3f85cb00ab\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+// Note - All tests only induce and detect one type of corruption check violation ->\n+// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqInLaterBatches() {\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(599);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(500);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        writeLogsOnLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+\n+        induceGreaterAcceptedValueCorruption(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n+        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+\n+        assertDetectedViolations(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 3f85cb00ab..775bd9eee1 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -19,89 +19,97 @@ package com.palantir.timelock.corruption.detection;\n import static org.assertj.core.api.Assertions.assertThat;\n \n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n import com.google.common.collect.SetMultimap;\n import com.palantir.paxos.Client;\n import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n import java.util.List;\n import java.util.stream.IntStream;\n+import org.junit.Rule;\n import org.junit.Test;\n \n-// Note - All tests only induce and detect one type of corruption check violation ->\n-// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n-public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void detectCorruptionForLogAtSeqAtBatchEnd() {\n         // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1.\n-        writeLogsOnLocalAndRemote(1, 500);\n-        induceGreaterAcceptedValueCorruption(499);\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqInLaterBatches() {\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(599);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n \n         // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n         // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(500);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n \n         // No signs of corruption in the first batch\n         SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        writeLogsOnLocalAndRemote(1, 400);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n \n         // No signs of corruption\n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+        helper.assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n \n-        induceGreaterAcceptedValueCorruption(250);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n         // Detects signs of corruption in the now corrupt first batch of logs\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForMultipleCorruptSeries() {\n         // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n-        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        assertDetectedViolations(\n+        helper.assertDetectedViolations(\n                 ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n     private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n     private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n     private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 775bd9eee1..b9910e5b2d 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -95,24 +87,24 @@ public class CorruptionDetectionIntegrationTest {\n         IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n         IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        helper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+        helper.assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+    private void createSeriesWithPaxosLogs(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         helper.writeLogsOnLocalAndRemote(\n                 helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+    private void corruptSeries(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n         helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    private static NamespaceAndUseCase namespaceAndUseCaseForIndex(int index) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + index), \"client\");\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwNjI4NA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513506284", "bodyText": "minor nit: assertViolationsDetected", "author": "Jolyon-S", "createdAt": "2020-10-28T14:49:15Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));", "originalCommit": "aa636be9a4844829b9d5aaad25c61428d1c701d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwOTc1OQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513509759", "bodyText": "also, split into two methods: some violations (and maybe can be specific), or no violation.", "author": "Jolyon-S", "createdAt": "2020-10-28T14:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwNjI4NA=="}], "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\ndeleted file mode 100644\nindex caa3d41e85..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,112 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.SetMultimap;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import java.util.List;\n-import java.util.stream.IntStream;\n-import org.junit.Test;\n-\n-/**\n- * This class performs integration tests by inducing and detecting corruption in one or more series.\n- * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n- */\n-public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n-\n-    @Test\n-    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n-        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1.\n-        writeLogsOnLocalAndRemote(1, 500);\n-        induceGreaterAcceptedValueCorruption(499);\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogSeqInLaterBatches() {\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(599);\n-\n-        // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n-\n-        // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n-        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(500);\n-\n-        // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n-\n-        // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        writeLogsOnLocalAndRemote(1, 400);\n-\n-        // No signs of corruption\n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n-\n-        induceGreaterAcceptedValueCorruption(250);\n-        // Detects signs of corruption in the now corrupt first batch of logs\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n-    }\n-\n-    @Test\n-    public void detectCorruptionForMultipleCorruptSeries() {\n-        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n-        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n-\n-        assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n-    }\n-\n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n-    }\n-\n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n-    }\n-\n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nnew file mode 100644\nindex 0000000000..3f85cb00ab\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+// Note - All tests only induce and detect one type of corruption check violation ->\n+// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqInLaterBatches() {\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(599);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(500);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        writeLogsOnLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+\n+        induceGreaterAcceptedValueCorruption(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n+        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+\n+        assertDetectedViolations(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 3f85cb00ab..775bd9eee1 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -19,89 +19,97 @@ package com.palantir.timelock.corruption.detection;\n import static org.assertj.core.api.Assertions.assertThat;\n \n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n import com.google.common.collect.SetMultimap;\n import com.palantir.paxos.Client;\n import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n import java.util.List;\n import java.util.stream.IntStream;\n+import org.junit.Rule;\n import org.junit.Test;\n \n-// Note - All tests only induce and detect one type of corruption check violation ->\n-// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n-public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void detectCorruptionForLogAtSeqAtBatchEnd() {\n         // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1.\n-        writeLogsOnLocalAndRemote(1, 500);\n-        induceGreaterAcceptedValueCorruption(499);\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqInLaterBatches() {\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(599);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n \n         // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n         // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(500);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n \n         // No signs of corruption in the first batch\n         SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        writeLogsOnLocalAndRemote(1, 400);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n \n         // No signs of corruption\n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+        helper.assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n \n-        induceGreaterAcceptedValueCorruption(250);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n         // Detects signs of corruption in the now corrupt first batch of logs\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForMultipleCorruptSeries() {\n         // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n-        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        assertDetectedViolations(\n+        helper.assertDetectedViolations(\n                 ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n     private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n     private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n     private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 775bd9eee1..b9910e5b2d 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -95,24 +87,24 @@ public class CorruptionDetectionIntegrationTest {\n         IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n         IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        helper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+        helper.assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+    private void createSeriesWithPaxosLogs(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         helper.writeLogsOnLocalAndRemote(\n                 helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+    private void corruptSeries(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n         helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    private static NamespaceAndUseCase namespaceAndUseCaseForIndex(int index) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + index), \"client\");\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxMzIzNw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513513237", "bodyText": "chatted offline - I personally don't like this structure of using abstract classes; would prefer if this was a final class that you call methods on directly.", "author": "Jolyon-S", "createdAt": "2020-10-28T14:57:12Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {", "originalCommit": "aa636be9a4844829b9d5aaad25c61428d1c701d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\ndeleted file mode 100644\nindex d5c32b112a..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n+++ /dev/null\n", "chunk": "@@ -1,195 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.SetMultimap;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosAcceptorState;\n-import com.palantir.paxos.PaxosStateLog;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.paxos.SqliteConnections;\n-import com.palantir.paxos.SqlitePaxosStateLog;\n-import com.palantir.timelock.history.LocalHistoryLoader;\n-import com.palantir.timelock.history.PaxosLogHistoryProvider;\n-import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n-import com.palantir.timelock.history.models.AcceptorUseCase;\n-import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n-import com.palantir.timelock.history.models.LearnerUseCase;\n-import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n-import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import javax.sql.DataSource;\n-import org.immutables.value.Value;\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.rules.TemporaryFolder;\n-\n-public abstract class TimeLockCorruptionTestSetup {\n-    @Rule\n-    public TemporaryFolder tempFolder = new TemporaryFolder();\n-\n-    private static final Client CLIENT = Client.of(\"client\");\n-    private static final String USE_CASE = \"useCase\";\n-    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n-            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n-\n-    private DataSource localDataSource;\n-    private DataSource remoteDataSource1;\n-    private DataSource remoteDataSource2;\n-\n-    protected StateLogComponents localStateLogComponents;\n-    protected List<StateLogComponents> remoteStateLogComponents;\n-    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n-\n-    @Before\n-    public void setup() throws IOException {\n-        localDataSource = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile1\").toPath());\n-        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile2\").toPath());\n-        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile3\").toPath());\n-\n-        localStateLogComponents = createLogComponentsForServer(localDataSource);\n-        remoteStateLogComponents = ImmutableList.of(\n-                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n-        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n-                localStateLogComponents.dataSource(),\n-                remoteStateLogComponents.stream()\n-                        .map(StateLogComponents::serverHistoryProvider)\n-                        .collect(Collectors.toList()));\n-    }\n-\n-    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n-        return ImmutableList.of(\n-                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n-                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n-                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n-    }\n-\n-    // utils\n-    protected Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n-    }\n-\n-    protected StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n-        return createLogComponentsForServer(dataSource, NAMESPACE_AND_USE_CASE);\n-    }\n-\n-    protected StateLogComponents createLogComponentsForServer(\n-            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n-\n-        Client client = namespaceAndUseCase.namespace();\n-        String paxosUseCase = namespaceAndUseCase.useCase();\n-\n-        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n-                ImmutableNamespaceAndUseCase.of(\n-                        client,\n-                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n-                dataSource);\n-\n-        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n-                ImmutableNamespaceAndUseCase.of(\n-                        client,\n-                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n-                dataSource);\n-\n-        LocalHistoryLoader history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n-        TimeLockPaxosHistoryProvider serverHistoryProvider = TimeLockPaxosHistoryProviderResource.jersey(history);\n-        return StateLogComponents.builder()\n-                .dataSource(dataSource)\n-                .learnerLog(learnerLog)\n-                .acceptorLog(acceptorLog)\n-                .history(history)\n-                .serverHistoryProvider(serverHistoryProvider)\n-                .build();\n-    }\n-\n-    protected void induceGreaterAcceptedValueCorruption(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(localStateLogComponents, corruptSeq);\n-    }\n-\n-    protected void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n-    }\n-\n-    protected void writeLogsOnLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                ImmutableList.<StateLogComponents>builder()\n-                        .add(localStateLogComponents)\n-                        .addAll(remoteStateLogComponents)\n-                        .build(),\n-                startingLogSeq,\n-                latestLogSequence);\n-    }\n-\n-    protected void writeLogsOnLocalAndRemote(\n-            List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n-    }\n-\n-    protected SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n-    protected void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertDetectedViolations(detectedViolations, ImmutableSet.of(NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    protected void assertDetectedViolations(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n-        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n-    }\n-\n-    @Value.Immutable\n-    interface StateLogComponents {\n-        DataSource dataSource();\n-\n-        PaxosStateLog<PaxosValue> learnerLog();\n-\n-        PaxosStateLog<PaxosAcceptorState> acceptorLog();\n-\n-        LocalHistoryLoader history();\n-\n-        TimeLockPaxosHistoryProvider serverHistoryProvider();\n-\n-        static ImmutableStateLogComponents.Builder builder() {\n-            return ImmutableStateLogComponents.builder();\n-        }\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\nnew file mode 100644\nindex 0000000000..9d1bcc96ae\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n", "chunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n+            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n+\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+\n+    protected StateLogComponents localStateLogComponents;\n+    protected List<StateLogComponents> remoteStateLogComponents;\n+    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        localStateLogComponents = createLogComponentsForServer(localDataSource);\n+        remoteStateLogComponents = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n+                localStateLogComponents.dataSource(),\n+                remoteStateLogComponents.stream()\n+                        .map(StateLogComponents::serverHistoryProvider)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    // utils\n+    protected Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n+        return createLogComponentsForServer(dataSource, NAMESPACE_AND_USE_CASE);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(\n+            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n+\n+        Client client = namespaceAndUseCase.namespace();\n+        String paxosUseCase = namespaceAndUseCase.useCase();\n+\n+        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        LocalHistoryLoader history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+        TimeLockPaxosHistoryProvider serverHistoryProvider = TimeLockPaxosHistoryProviderResource.jersey(history);\n+        return StateLogComponents.builder()\n+                .dataSource(dataSource)\n+                .learnerLog(learnerLog)\n+                .acceptorLog(acceptorLog)\n+                .history(history)\n+                .serverHistoryProvider(serverHistoryProvider)\n+                .build();\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(localStateLogComponents, corruptSeq);\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                ImmutableList.<StateLogComponents>builder()\n+                        .add(localStateLogComponents)\n+                        .addAll(remoteStateLogComponents)\n+                        .build(),\n+                startingLogSeq,\n+                latestLogSequence);\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(\n+            List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    protected SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    protected void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    protected void assertDetectedViolations(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    @Value.Immutable\n+    interface StateLogComponents {\n+        DataSource dataSource();\n+\n+        PaxosStateLog<PaxosValue> learnerLog();\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog();\n+\n+        LocalHistoryLoader history();\n+\n+        TimeLockPaxosHistoryProvider serverHistoryProvider();\n+\n+        static ImmutableStateLogComponents.Builder builder() {\n+            return ImmutableStateLogComponents.builder();\n+        }\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\nindex 9d1bcc96ae..140572593b 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n", "chunk": "@@ -184,10 +157,6 @@ public abstract class TimeLockCorruptionTestSetup {\n \n         PaxosStateLog<PaxosAcceptorState> acceptorLog();\n \n-        LocalHistoryLoader history();\n-\n-        TimeLockPaxosHistoryProvider serverHistoryProvider();\n-\n         static ImmutableStateLogComponents.Builder builder() {\n             return ImmutableStateLogComponents.builder();\n         }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxNDUzNA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513514534", "bodyText": "please remove this", "author": "Jolyon-S", "createdAt": "2020-10-28T14:58:47Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n+            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n+\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+\n+    protected StateLogComponents localStateLogComponents;\n+    protected List<StateLogComponents> remoteStateLogComponents;\n+    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        localStateLogComponents = createLogComponentsForServer(localDataSource);\n+        remoteStateLogComponents = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n+                localStateLogComponents.dataSource(),\n+                remoteStateLogComponents.stream()\n+                        .map(StateLogComponents::serverHistoryProvider)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    // utils", "originalCommit": "aa636be9a4844829b9d5aaad25c61428d1c701d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\ndeleted file mode 100644\nindex d5c32b112a..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n+++ /dev/null\n", "chunk": "@@ -1,195 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.SetMultimap;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosAcceptorState;\n-import com.palantir.paxos.PaxosStateLog;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.paxos.SqliteConnections;\n-import com.palantir.paxos.SqlitePaxosStateLog;\n-import com.palantir.timelock.history.LocalHistoryLoader;\n-import com.palantir.timelock.history.PaxosLogHistoryProvider;\n-import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n-import com.palantir.timelock.history.models.AcceptorUseCase;\n-import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n-import com.palantir.timelock.history.models.LearnerUseCase;\n-import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n-import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import javax.sql.DataSource;\n-import org.immutables.value.Value;\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.rules.TemporaryFolder;\n-\n-public abstract class TimeLockCorruptionTestSetup {\n-    @Rule\n-    public TemporaryFolder tempFolder = new TemporaryFolder();\n-\n-    private static final Client CLIENT = Client.of(\"client\");\n-    private static final String USE_CASE = \"useCase\";\n-    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n-            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n-\n-    private DataSource localDataSource;\n-    private DataSource remoteDataSource1;\n-    private DataSource remoteDataSource2;\n-\n-    protected StateLogComponents localStateLogComponents;\n-    protected List<StateLogComponents> remoteStateLogComponents;\n-    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n-\n-    @Before\n-    public void setup() throws IOException {\n-        localDataSource = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile1\").toPath());\n-        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile2\").toPath());\n-        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile3\").toPath());\n-\n-        localStateLogComponents = createLogComponentsForServer(localDataSource);\n-        remoteStateLogComponents = ImmutableList.of(\n-                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n-        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n-                localStateLogComponents.dataSource(),\n-                remoteStateLogComponents.stream()\n-                        .map(StateLogComponents::serverHistoryProvider)\n-                        .collect(Collectors.toList()));\n-    }\n-\n-    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n-        return ImmutableList.of(\n-                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n-                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n-                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n-    }\n-\n-    // utils\n-    protected Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n-    }\n-\n-    protected StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n-        return createLogComponentsForServer(dataSource, NAMESPACE_AND_USE_CASE);\n-    }\n-\n-    protected StateLogComponents createLogComponentsForServer(\n-            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n-\n-        Client client = namespaceAndUseCase.namespace();\n-        String paxosUseCase = namespaceAndUseCase.useCase();\n-\n-        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n-                ImmutableNamespaceAndUseCase.of(\n-                        client,\n-                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n-                dataSource);\n-\n-        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n-                ImmutableNamespaceAndUseCase.of(\n-                        client,\n-                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n-                dataSource);\n-\n-        LocalHistoryLoader history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n-        TimeLockPaxosHistoryProvider serverHistoryProvider = TimeLockPaxosHistoryProviderResource.jersey(history);\n-        return StateLogComponents.builder()\n-                .dataSource(dataSource)\n-                .learnerLog(learnerLog)\n-                .acceptorLog(acceptorLog)\n-                .history(history)\n-                .serverHistoryProvider(serverHistoryProvider)\n-                .build();\n-    }\n-\n-    protected void induceGreaterAcceptedValueCorruption(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(localStateLogComponents, corruptSeq);\n-    }\n-\n-    protected void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n-    }\n-\n-    protected void writeLogsOnLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                ImmutableList.<StateLogComponents>builder()\n-                        .add(localStateLogComponents)\n-                        .addAll(remoteStateLogComponents)\n-                        .build(),\n-                startingLogSeq,\n-                latestLogSequence);\n-    }\n-\n-    protected void writeLogsOnLocalAndRemote(\n-            List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n-    }\n-\n-    protected SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n-    protected void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertDetectedViolations(detectedViolations, ImmutableSet.of(NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    protected void assertDetectedViolations(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n-        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n-    }\n-\n-    @Value.Immutable\n-    interface StateLogComponents {\n-        DataSource dataSource();\n-\n-        PaxosStateLog<PaxosValue> learnerLog();\n-\n-        PaxosStateLog<PaxosAcceptorState> acceptorLog();\n-\n-        LocalHistoryLoader history();\n-\n-        TimeLockPaxosHistoryProvider serverHistoryProvider();\n-\n-        static ImmutableStateLogComponents.Builder builder() {\n-            return ImmutableStateLogComponents.builder();\n-        }\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\nnew file mode 100644\nindex 0000000000..9d1bcc96ae\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n", "chunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n+            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n+\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+\n+    protected StateLogComponents localStateLogComponents;\n+    protected List<StateLogComponents> remoteStateLogComponents;\n+    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        localStateLogComponents = createLogComponentsForServer(localDataSource);\n+        remoteStateLogComponents = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n+                localStateLogComponents.dataSource(),\n+                remoteStateLogComponents.stream()\n+                        .map(StateLogComponents::serverHistoryProvider)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    // utils\n+    protected Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n+        return createLogComponentsForServer(dataSource, NAMESPACE_AND_USE_CASE);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(\n+            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n+\n+        Client client = namespaceAndUseCase.namespace();\n+        String paxosUseCase = namespaceAndUseCase.useCase();\n+\n+        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        LocalHistoryLoader history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+        TimeLockPaxosHistoryProvider serverHistoryProvider = TimeLockPaxosHistoryProviderResource.jersey(history);\n+        return StateLogComponents.builder()\n+                .dataSource(dataSource)\n+                .learnerLog(learnerLog)\n+                .acceptorLog(acceptorLog)\n+                .history(history)\n+                .serverHistoryProvider(serverHistoryProvider)\n+                .build();\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(localStateLogComponents, corruptSeq);\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                ImmutableList.<StateLogComponents>builder()\n+                        .add(localStateLogComponents)\n+                        .addAll(remoteStateLogComponents)\n+                        .build(),\n+                startingLogSeq,\n+                latestLogSequence);\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(\n+            List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    protected SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    protected void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    protected void assertDetectedViolations(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    @Value.Immutable\n+    interface StateLogComponents {\n+        DataSource dataSource();\n+\n+        PaxosStateLog<PaxosValue> learnerLog();\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog();\n+\n+        LocalHistoryLoader history();\n+\n+        TimeLockPaxosHistoryProvider serverHistoryProvider();\n+\n+        static ImmutableStateLogComponents.Builder builder() {\n+            return ImmutableStateLogComponents.builder();\n+        }\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\nindex 9d1bcc96ae..140572593b 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n", "chunk": "@@ -184,10 +157,6 @@ public abstract class TimeLockCorruptionTestSetup {\n \n         PaxosStateLog<PaxosAcceptorState> acceptorLog();\n \n-        LocalHistoryLoader history();\n-\n-        TimeLockPaxosHistoryProvider serverHistoryProvider();\n-\n         static ImmutableStateLogComponents.Builder builder() {\n             return ImmutableStateLogComponents.builder();\n         }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxNDkwMQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513514901", "bodyText": "IntelliJ is your friend; these probably? don't have to be protected", "author": "Jolyon-S", "createdAt": "2020-10-28T14:59:11Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n+            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n+\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+\n+    protected StateLogComponents localStateLogComponents;\n+    protected List<StateLogComponents> remoteStateLogComponents;\n+    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        localStateLogComponents = createLogComponentsForServer(localDataSource);\n+        remoteStateLogComponents = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n+                localStateLogComponents.dataSource(),\n+                remoteStateLogComponents.stream()\n+                        .map(StateLogComponents::serverHistoryProvider)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    // utils\n+    protected Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n+        return createLogComponentsForServer(dataSource, NAMESPACE_AND_USE_CASE);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(\n+            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n+\n+        Client client = namespaceAndUseCase.namespace();\n+        String paxosUseCase = namespaceAndUseCase.useCase();\n+\n+        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        LocalHistoryLoader history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+        TimeLockPaxosHistoryProvider serverHistoryProvider = TimeLockPaxosHistoryProviderResource.jersey(history);\n+        return StateLogComponents.builder()\n+                .dataSource(dataSource)\n+                .learnerLog(learnerLog)\n+                .acceptorLog(acceptorLog)\n+                .history(history)\n+                .serverHistoryProvider(serverHistoryProvider)\n+                .build();\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(localStateLogComponents, corruptSeq);\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                ImmutableList.<StateLogComponents>builder()\n+                        .add(localStateLogComponents)\n+                        .addAll(remoteStateLogComponents)\n+                        .build(),\n+                startingLogSeq,\n+                latestLogSequence);\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(\n+            List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    protected SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    protected void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    protected void assertDetectedViolations(", "originalCommit": "aa636be9a4844829b9d5aaad25c61428d1c701d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\ndeleted file mode 100644\nindex d5c32b112a..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n+++ /dev/null\n", "chunk": "@@ -1,195 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.SetMultimap;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosAcceptorState;\n-import com.palantir.paxos.PaxosStateLog;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.paxos.SqliteConnections;\n-import com.palantir.paxos.SqlitePaxosStateLog;\n-import com.palantir.timelock.history.LocalHistoryLoader;\n-import com.palantir.timelock.history.PaxosLogHistoryProvider;\n-import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n-import com.palantir.timelock.history.models.AcceptorUseCase;\n-import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n-import com.palantir.timelock.history.models.LearnerUseCase;\n-import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n-import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import javax.sql.DataSource;\n-import org.immutables.value.Value;\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.rules.TemporaryFolder;\n-\n-public abstract class TimeLockCorruptionTestSetup {\n-    @Rule\n-    public TemporaryFolder tempFolder = new TemporaryFolder();\n-\n-    private static final Client CLIENT = Client.of(\"client\");\n-    private static final String USE_CASE = \"useCase\";\n-    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n-            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n-\n-    private DataSource localDataSource;\n-    private DataSource remoteDataSource1;\n-    private DataSource remoteDataSource2;\n-\n-    protected StateLogComponents localStateLogComponents;\n-    protected List<StateLogComponents> remoteStateLogComponents;\n-    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n-\n-    @Before\n-    public void setup() throws IOException {\n-        localDataSource = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile1\").toPath());\n-        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile2\").toPath());\n-        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile3\").toPath());\n-\n-        localStateLogComponents = createLogComponentsForServer(localDataSource);\n-        remoteStateLogComponents = ImmutableList.of(\n-                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n-        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n-                localStateLogComponents.dataSource(),\n-                remoteStateLogComponents.stream()\n-                        .map(StateLogComponents::serverHistoryProvider)\n-                        .collect(Collectors.toList()));\n-    }\n-\n-    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n-        return ImmutableList.of(\n-                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n-                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n-                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n-    }\n-\n-    // utils\n-    protected Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n-    }\n-\n-    protected StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n-        return createLogComponentsForServer(dataSource, NAMESPACE_AND_USE_CASE);\n-    }\n-\n-    protected StateLogComponents createLogComponentsForServer(\n-            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n-\n-        Client client = namespaceAndUseCase.namespace();\n-        String paxosUseCase = namespaceAndUseCase.useCase();\n-\n-        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n-                ImmutableNamespaceAndUseCase.of(\n-                        client,\n-                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n-                dataSource);\n-\n-        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n-                ImmutableNamespaceAndUseCase.of(\n-                        client,\n-                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n-                dataSource);\n-\n-        LocalHistoryLoader history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n-        TimeLockPaxosHistoryProvider serverHistoryProvider = TimeLockPaxosHistoryProviderResource.jersey(history);\n-        return StateLogComponents.builder()\n-                .dataSource(dataSource)\n-                .learnerLog(learnerLog)\n-                .acceptorLog(acceptorLog)\n-                .history(history)\n-                .serverHistoryProvider(serverHistoryProvider)\n-                .build();\n-    }\n-\n-    protected void induceGreaterAcceptedValueCorruption(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(localStateLogComponents, corruptSeq);\n-    }\n-\n-    protected void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n-    }\n-\n-    protected void writeLogsOnLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                ImmutableList.<StateLogComponents>builder()\n-                        .add(localStateLogComponents)\n-                        .addAll(remoteStateLogComponents)\n-                        .build(),\n-                startingLogSeq,\n-                latestLogSequence);\n-    }\n-\n-    protected void writeLogsOnLocalAndRemote(\n-            List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n-    }\n-\n-    protected SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n-    protected void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertDetectedViolations(detectedViolations, ImmutableSet.of(NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    protected void assertDetectedViolations(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n-        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n-    }\n-\n-    @Value.Immutable\n-    interface StateLogComponents {\n-        DataSource dataSource();\n-\n-        PaxosStateLog<PaxosValue> learnerLog();\n-\n-        PaxosStateLog<PaxosAcceptorState> acceptorLog();\n-\n-        LocalHistoryLoader history();\n-\n-        TimeLockPaxosHistoryProvider serverHistoryProvider();\n-\n-        static ImmutableStateLogComponents.Builder builder() {\n-            return ImmutableStateLogComponents.builder();\n-        }\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\nnew file mode 100644\nindex 0000000000..9d1bcc96ae\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n", "chunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n+            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n+\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+\n+    protected StateLogComponents localStateLogComponents;\n+    protected List<StateLogComponents> remoteStateLogComponents;\n+    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        localStateLogComponents = createLogComponentsForServer(localDataSource);\n+        remoteStateLogComponents = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n+                localStateLogComponents.dataSource(),\n+                remoteStateLogComponents.stream()\n+                        .map(StateLogComponents::serverHistoryProvider)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    // utils\n+    protected Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n+        return createLogComponentsForServer(dataSource, NAMESPACE_AND_USE_CASE);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(\n+            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n+\n+        Client client = namespaceAndUseCase.namespace();\n+        String paxosUseCase = namespaceAndUseCase.useCase();\n+\n+        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        LocalHistoryLoader history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+        TimeLockPaxosHistoryProvider serverHistoryProvider = TimeLockPaxosHistoryProviderResource.jersey(history);\n+        return StateLogComponents.builder()\n+                .dataSource(dataSource)\n+                .learnerLog(learnerLog)\n+                .acceptorLog(acceptorLog)\n+                .history(history)\n+                .serverHistoryProvider(serverHistoryProvider)\n+                .build();\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(localStateLogComponents, corruptSeq);\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                ImmutableList.<StateLogComponents>builder()\n+                        .add(localStateLogComponents)\n+                        .addAll(remoteStateLogComponents)\n+                        .build(),\n+                startingLogSeq,\n+                latestLogSequence);\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(\n+            List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    protected SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    protected void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    protected void assertDetectedViolations(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    @Value.Immutable\n+    interface StateLogComponents {\n+        DataSource dataSource();\n+\n+        PaxosStateLog<PaxosValue> learnerLog();\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog();\n+\n+        LocalHistoryLoader history();\n+\n+        TimeLockPaxosHistoryProvider serverHistoryProvider();\n+\n+        static ImmutableStateLogComponents.Builder builder() {\n+            return ImmutableStateLogComponents.builder();\n+        }\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\nindex 9d1bcc96ae..140572593b 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n", "chunk": "@@ -184,10 +157,6 @@ public abstract class TimeLockCorruptionTestSetup {\n \n         PaxosStateLog<PaxosAcceptorState> acceptorLog();\n \n-        LocalHistoryLoader history();\n-\n-        TimeLockPaxosHistoryProvider serverHistoryProvider();\n-\n         static ImmutableStateLogComponents.Builder builder() {\n             return ImmutableStateLogComponents.builder();\n         }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5NjM1OA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515096358", "bodyText": "nit: can we call this TimelockCorruptionTestConstants or similar? I know it is in the test project, but I'm wary of such a generic name here", "author": "Jolyon-S", "createdAt": "2020-10-30T13:28:49Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/Constants.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock;\n+\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+\n+public class Constants {", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/Constants.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/Constants.java\ndeleted file mode 100644\nindex c504a00bb8..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/Constants.java\n+++ /dev/null\n", "chunk": "@@ -1,28 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock;\n-\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-\n-public class Constants {\n-    public static final String DEFAULT_USE_CASE = \"useCase\";\n-    public static final Client DEFAULT_CLIENT = Client.of(\"client\");\n-    public static final NamespaceAndUseCase DEFAULT_NAMESPACE_AND_USE_CASE =\n-            ImmutableNamespaceAndUseCase.of(DEFAULT_CLIENT, DEFAULT_USE_CASE);\n-}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/Constants.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/Constants.java\nnew file mode 100644\nindex 0000000000..c504a00bb8\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/Constants.java\n", "chunk": "@@ -0,0 +1,28 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock;\n+\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+\n+public class Constants {\n+    public static final String DEFAULT_USE_CASE = \"useCase\";\n+    public static final Client DEFAULT_CLIENT = Client.of(\"client\");\n+    public static final NamespaceAndUseCase DEFAULT_NAMESPACE_AND_USE_CASE =\n+            ImmutableNamespaceAndUseCase.of(DEFAULT_CLIENT, DEFAULT_USE_CASE);\n+}\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/Constants.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/TimelockCorruptionTestConstants.java\nsimilarity index 95%\nrename from timelock-corruption-detection/src/test/java/com/palantir/timelock/Constants.java\nrename to timelock-corruption-detection/src/test/java/com/palantir/timelock/TimelockCorruptionTestConstants.java\nindex c504a00bb8..67fd3a7b40 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/Constants.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/TimelockCorruptionTestConstants.java\n", "chunk": "@@ -20,7 +20,7 @@ import com.palantir.paxos.Client;\n import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n \n-public class Constants {\n+public class TimelockCorruptionTestConstants {\n     public static final String DEFAULT_USE_CASE = \"useCase\";\n     public static final Client DEFAULT_CLIENT = Client.of(\"client\");\n     public static final NamespaceAndUseCase DEFAULT_NAMESPACE_AND_USE_CASE =\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5ODY3NQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515098675", "bodyText": "the javadoc is a note, of sorts. I'd recommend refactoring this line as follows:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n          \n          \n            \n             * All tests only induce and detect ACCEPTED_VALUE_GREATER_THAN_LEARNED corruption.", "author": "Jolyon-S", "createdAt": "2020-10-30T13:32:25Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\ndeleted file mode 100644\nindex d35bcf058d..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,110 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n-import java.util.List;\n-import java.util.stream.IntStream;\n-import org.junit.Rule;\n-import org.junit.Test;\n-\n-/**\n- * This class performs integration tests by inducing and detecting corruption in one or more series.\n- * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n- */\n-public final class CorruptionDetectionIntegrationTest {\n-    @Rule\n-    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n-\n-    @Test\n-    public void detectCorruptionForLogAtBatchEnd() {\n-        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1.\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogInLaterBatches() {\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n-\n-        // No signs of corruption in the first batch\n-        helper.assertNoCorruptionViolations();\n-\n-        // Detects signs of corruption in the second batch\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogAtStartOfSecondBatch() {\n-        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n-\n-        // No signs of corruption in the first batch\n-        helper.assertNoCorruptionViolations();\n-\n-        // Detects signs of corruption in the second batch\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n-\n-        // No signs of corruption\n-        helper.assertNoCorruptionViolations();\n-\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n-        // Detects signs of corruption in the now corrupt first batch of logs\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForMultipleCorruptSeries() {\n-        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n-        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n-\n-        helper.assertViolationsDetectedForNamespaceAndUseCases(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n-    }\n-\n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        helper.writeLogsOnLocalAndRemote(\n-                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n-    }\n-\n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n-    }\n-\n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nnew file mode 100644\nindex 0000000000..3f85cb00ab\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+// Note - All tests only induce and detect one type of corruption check violation ->\n+// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqInLaterBatches() {\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(599);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(500);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        writeLogsOnLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+\n+        induceGreaterAcceptedValueCorruption(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n+        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+\n+        assertDetectedViolations(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 3f85cb00ab..775bd9eee1 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -19,89 +19,97 @@ package com.palantir.timelock.corruption.detection;\n import static org.assertj.core.api.Assertions.assertThat;\n \n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n import com.google.common.collect.SetMultimap;\n import com.palantir.paxos.Client;\n import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n import java.util.List;\n import java.util.stream.IntStream;\n+import org.junit.Rule;\n import org.junit.Test;\n \n-// Note - All tests only induce and detect one type of corruption check violation ->\n-// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n-public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void detectCorruptionForLogAtSeqAtBatchEnd() {\n         // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1.\n-        writeLogsOnLocalAndRemote(1, 500);\n-        induceGreaterAcceptedValueCorruption(499);\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqInLaterBatches() {\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(599);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n \n         // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n         // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(500);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n \n         // No signs of corruption in the first batch\n         SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        writeLogsOnLocalAndRemote(1, 400);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n \n         // No signs of corruption\n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+        helper.assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n \n-        induceGreaterAcceptedValueCorruption(250);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n         // Detects signs of corruption in the now corrupt first batch of logs\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForMultipleCorruptSeries() {\n         // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n-        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        assertDetectedViolations(\n+        helper.assertDetectedViolations(\n                 ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n     private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n     private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n     private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 775bd9eee1..b9910e5b2d 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -95,24 +87,24 @@ public class CorruptionDetectionIntegrationTest {\n         IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n         IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        helper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+        helper.assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+    private void createSeriesWithPaxosLogs(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         helper.writeLogsOnLocalAndRemote(\n                 helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+    private void corruptSeries(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n         helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    private static NamespaceAndUseCase namespaceAndUseCaseForIndex(int index) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + index), \"client\");\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5OTA3NA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515099074", "bodyText": "nit: no need to hyphenate here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n          \n          \n            \n                    // We write logs in range [1, 500]. The first range of sequences for corruption detection = [0, 499] since", "author": "Jolyon-S", "createdAt": "2020-10-30T13:33:07Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\ndeleted file mode 100644\nindex d35bcf058d..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,110 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n-import java.util.List;\n-import java.util.stream.IntStream;\n-import org.junit.Rule;\n-import org.junit.Test;\n-\n-/**\n- * This class performs integration tests by inducing and detecting corruption in one or more series.\n- * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n- */\n-public final class CorruptionDetectionIntegrationTest {\n-    @Rule\n-    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n-\n-    @Test\n-    public void detectCorruptionForLogAtBatchEnd() {\n-        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1.\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogInLaterBatches() {\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n-\n-        // No signs of corruption in the first batch\n-        helper.assertNoCorruptionViolations();\n-\n-        // Detects signs of corruption in the second batch\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogAtStartOfSecondBatch() {\n-        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n-\n-        // No signs of corruption in the first batch\n-        helper.assertNoCorruptionViolations();\n-\n-        // Detects signs of corruption in the second batch\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n-\n-        // No signs of corruption\n-        helper.assertNoCorruptionViolations();\n-\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n-        // Detects signs of corruption in the now corrupt first batch of logs\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForMultipleCorruptSeries() {\n-        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n-        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n-\n-        helper.assertViolationsDetectedForNamespaceAndUseCases(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n-    }\n-\n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        helper.writeLogsOnLocalAndRemote(\n-                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n-    }\n-\n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n-    }\n-\n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nnew file mode 100644\nindex 0000000000..3f85cb00ab\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+// Note - All tests only induce and detect one type of corruption check violation ->\n+// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqInLaterBatches() {\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(599);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(500);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        writeLogsOnLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+\n+        induceGreaterAcceptedValueCorruption(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n+        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+\n+        assertDetectedViolations(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 3f85cb00ab..775bd9eee1 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -19,89 +19,97 @@ package com.palantir.timelock.corruption.detection;\n import static org.assertj.core.api.Assertions.assertThat;\n \n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n import com.google.common.collect.SetMultimap;\n import com.palantir.paxos.Client;\n import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n import java.util.List;\n import java.util.stream.IntStream;\n+import org.junit.Rule;\n import org.junit.Test;\n \n-// Note - All tests only induce and detect one type of corruption check violation ->\n-// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n-public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void detectCorruptionForLogAtSeqAtBatchEnd() {\n         // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1.\n-        writeLogsOnLocalAndRemote(1, 500);\n-        induceGreaterAcceptedValueCorruption(499);\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqInLaterBatches() {\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(599);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n \n         // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n         // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(500);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n \n         // No signs of corruption in the first batch\n         SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        writeLogsOnLocalAndRemote(1, 400);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n \n         // No signs of corruption\n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+        helper.assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n \n-        induceGreaterAcceptedValueCorruption(250);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n         // Detects signs of corruption in the now corrupt first batch of logs\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForMultipleCorruptSeries() {\n         // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n-        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        assertDetectedViolations(\n+        helper.assertDetectedViolations(\n                 ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n     private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n     private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n     private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 775bd9eee1..b9910e5b2d 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -95,24 +87,24 @@ public class CorruptionDetectionIntegrationTest {\n         IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n         IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        helper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+        helper.assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+    private void createSeriesWithPaxosLogs(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         helper.writeLogsOnLocalAndRemote(\n                 helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+    private void corruptSeries(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n         helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    private static NamespaceAndUseCase namespaceAndUseCaseForIndex(int index) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + index), \"client\");\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMTk3Mg==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515101972", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n          \n          \n            \n                private static NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {", "author": "Jolyon-S", "createdAt": "2020-10-30T13:36:37Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogInLaterBatches() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        helper.assertNoCorruptionViolations();\n+\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n+\n+        helper.assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\ndeleted file mode 100644\nindex d35bcf058d..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,110 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n-import java.util.List;\n-import java.util.stream.IntStream;\n-import org.junit.Rule;\n-import org.junit.Test;\n-\n-/**\n- * This class performs integration tests by inducing and detecting corruption in one or more series.\n- * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n- */\n-public final class CorruptionDetectionIntegrationTest {\n-    @Rule\n-    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n-\n-    @Test\n-    public void detectCorruptionForLogAtBatchEnd() {\n-        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1.\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogInLaterBatches() {\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n-\n-        // No signs of corruption in the first batch\n-        helper.assertNoCorruptionViolations();\n-\n-        // Detects signs of corruption in the second batch\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogAtStartOfSecondBatch() {\n-        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n-\n-        // No signs of corruption in the first batch\n-        helper.assertNoCorruptionViolations();\n-\n-        // Detects signs of corruption in the second batch\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n-\n-        // No signs of corruption\n-        helper.assertNoCorruptionViolations();\n-\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n-        // Detects signs of corruption in the now corrupt first batch of logs\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForMultipleCorruptSeries() {\n-        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n-        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n-\n-        helper.assertViolationsDetectedForNamespaceAndUseCases(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n-    }\n-\n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        helper.writeLogsOnLocalAndRemote(\n-                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n-    }\n-\n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n-    }\n-\n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nnew file mode 100644\nindex 0000000000..3f85cb00ab\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+// Note - All tests only induce and detect one type of corruption check violation ->\n+// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqInLaterBatches() {\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(599);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(500);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        writeLogsOnLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+\n+        induceGreaterAcceptedValueCorruption(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n+        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+\n+        assertDetectedViolations(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 3f85cb00ab..775bd9eee1 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -19,89 +19,97 @@ package com.palantir.timelock.corruption.detection;\n import static org.assertj.core.api.Assertions.assertThat;\n \n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n import com.google.common.collect.SetMultimap;\n import com.palantir.paxos.Client;\n import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n import java.util.List;\n import java.util.stream.IntStream;\n+import org.junit.Rule;\n import org.junit.Test;\n \n-// Note - All tests only induce and detect one type of corruption check violation ->\n-// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n-public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void detectCorruptionForLogAtSeqAtBatchEnd() {\n         // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1.\n-        writeLogsOnLocalAndRemote(1, 500);\n-        induceGreaterAcceptedValueCorruption(499);\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqInLaterBatches() {\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(599);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n \n         // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n         // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(500);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n \n         // No signs of corruption in the first batch\n         SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        writeLogsOnLocalAndRemote(1, 400);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n \n         // No signs of corruption\n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+        helper.assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n \n-        induceGreaterAcceptedValueCorruption(250);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n         // Detects signs of corruption in the now corrupt first batch of logs\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForMultipleCorruptSeries() {\n         // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n-        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        assertDetectedViolations(\n+        helper.assertDetectedViolations(\n                 ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n     private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n     private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n     private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 775bd9eee1..b9910e5b2d 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -95,24 +87,24 @@ public class CorruptionDetectionIntegrationTest {\n         IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n         IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        helper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+        helper.assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+    private void createSeriesWithPaxosLogs(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         helper.writeLogsOnLocalAndRemote(\n                 helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+    private void corruptSeries(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n         helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    private static NamespaceAndUseCase namespaceAndUseCaseForIndex(int index) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + index), \"client\");\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjE4Mw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515102183", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n          \n          \n            \n                private NamespaceAndUseCase namespaceAndUseCaseForIndex(int index) {", "author": "Jolyon-S", "createdAt": "2020-10-30T13:36:56Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogInLaterBatches() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        helper.assertNoCorruptionViolations();\n+\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n+\n+        helper.assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\ndeleted file mode 100644\nindex d35bcf058d..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,110 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n-import java.util.List;\n-import java.util.stream.IntStream;\n-import org.junit.Rule;\n-import org.junit.Test;\n-\n-/**\n- * This class performs integration tests by inducing and detecting corruption in one or more series.\n- * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n- */\n-public final class CorruptionDetectionIntegrationTest {\n-    @Rule\n-    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n-\n-    @Test\n-    public void detectCorruptionForLogAtBatchEnd() {\n-        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1.\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogInLaterBatches() {\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n-\n-        // No signs of corruption in the first batch\n-        helper.assertNoCorruptionViolations();\n-\n-        // Detects signs of corruption in the second batch\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogAtStartOfSecondBatch() {\n-        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n-\n-        // No signs of corruption in the first batch\n-        helper.assertNoCorruptionViolations();\n-\n-        // Detects signs of corruption in the second batch\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n-\n-        // No signs of corruption\n-        helper.assertNoCorruptionViolations();\n-\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n-        // Detects signs of corruption in the now corrupt first batch of logs\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForMultipleCorruptSeries() {\n-        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n-        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n-\n-        helper.assertViolationsDetectedForNamespaceAndUseCases(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n-    }\n-\n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        helper.writeLogsOnLocalAndRemote(\n-                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n-    }\n-\n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n-    }\n-\n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nnew file mode 100644\nindex 0000000000..3f85cb00ab\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+// Note - All tests only induce and detect one type of corruption check violation ->\n+// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqInLaterBatches() {\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(599);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(500);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        writeLogsOnLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+\n+        induceGreaterAcceptedValueCorruption(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n+        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+\n+        assertDetectedViolations(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 3f85cb00ab..775bd9eee1 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -19,89 +19,97 @@ package com.palantir.timelock.corruption.detection;\n import static org.assertj.core.api.Assertions.assertThat;\n \n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n import com.google.common.collect.SetMultimap;\n import com.palantir.paxos.Client;\n import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n import java.util.List;\n import java.util.stream.IntStream;\n+import org.junit.Rule;\n import org.junit.Test;\n \n-// Note - All tests only induce and detect one type of corruption check violation ->\n-// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n-public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void detectCorruptionForLogAtSeqAtBatchEnd() {\n         // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1.\n-        writeLogsOnLocalAndRemote(1, 500);\n-        induceGreaterAcceptedValueCorruption(499);\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqInLaterBatches() {\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(599);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n \n         // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n         // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(500);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n \n         // No signs of corruption in the first batch\n         SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        writeLogsOnLocalAndRemote(1, 400);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n \n         // No signs of corruption\n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+        helper.assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n \n-        induceGreaterAcceptedValueCorruption(250);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n         // Detects signs of corruption in the now corrupt first batch of logs\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForMultipleCorruptSeries() {\n         // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n-        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        assertDetectedViolations(\n+        helper.assertDetectedViolations(\n                 ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n     private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n     private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n     private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 775bd9eee1..b9910e5b2d 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -95,24 +87,24 @@ public class CorruptionDetectionIntegrationTest {\n         IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n         IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        helper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+        helper.assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+    private void createSeriesWithPaxosLogs(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         helper.writeLogsOnLocalAndRemote(\n                 helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+    private void corruptSeries(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n         helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    private static NamespaceAndUseCase namespaceAndUseCaseForIndex(int index) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + index), \"client\");\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjI5Nw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515102297", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n          \n          \n            \n                private void corruptSeries(int namespaceAndUseCaseIndex) {", "author": "Jolyon-S", "createdAt": "2020-10-30T13:37:09Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogInLaterBatches() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        helper.assertNoCorruptionViolations();\n+\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n+\n+        helper.assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\ndeleted file mode 100644\nindex d35bcf058d..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,110 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n-import java.util.List;\n-import java.util.stream.IntStream;\n-import org.junit.Rule;\n-import org.junit.Test;\n-\n-/**\n- * This class performs integration tests by inducing and detecting corruption in one or more series.\n- * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n- */\n-public final class CorruptionDetectionIntegrationTest {\n-    @Rule\n-    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n-\n-    @Test\n-    public void detectCorruptionForLogAtBatchEnd() {\n-        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1.\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogInLaterBatches() {\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n-\n-        // No signs of corruption in the first batch\n-        helper.assertNoCorruptionViolations();\n-\n-        // Detects signs of corruption in the second batch\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogAtStartOfSecondBatch() {\n-        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n-\n-        // No signs of corruption in the first batch\n-        helper.assertNoCorruptionViolations();\n-\n-        // Detects signs of corruption in the second batch\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n-\n-        // No signs of corruption\n-        helper.assertNoCorruptionViolations();\n-\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n-        // Detects signs of corruption in the now corrupt first batch of logs\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForMultipleCorruptSeries() {\n-        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n-        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n-\n-        helper.assertViolationsDetectedForNamespaceAndUseCases(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n-    }\n-\n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        helper.writeLogsOnLocalAndRemote(\n-                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n-    }\n-\n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n-    }\n-\n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nnew file mode 100644\nindex 0000000000..3f85cb00ab\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+// Note - All tests only induce and detect one type of corruption check violation ->\n+// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqInLaterBatches() {\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(599);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(500);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        writeLogsOnLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+\n+        induceGreaterAcceptedValueCorruption(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n+        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+\n+        assertDetectedViolations(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 3f85cb00ab..775bd9eee1 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -19,89 +19,97 @@ package com.palantir.timelock.corruption.detection;\n import static org.assertj.core.api.Assertions.assertThat;\n \n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n import com.google.common.collect.SetMultimap;\n import com.palantir.paxos.Client;\n import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n import java.util.List;\n import java.util.stream.IntStream;\n+import org.junit.Rule;\n import org.junit.Test;\n \n-// Note - All tests only induce and detect one type of corruption check violation ->\n-// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n-public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void detectCorruptionForLogAtSeqAtBatchEnd() {\n         // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1.\n-        writeLogsOnLocalAndRemote(1, 500);\n-        induceGreaterAcceptedValueCorruption(499);\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqInLaterBatches() {\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(599);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n \n         // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n         // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(500);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n \n         // No signs of corruption in the first batch\n         SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        writeLogsOnLocalAndRemote(1, 400);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n \n         // No signs of corruption\n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+        helper.assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n \n-        induceGreaterAcceptedValueCorruption(250);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n         // Detects signs of corruption in the now corrupt first batch of logs\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForMultipleCorruptSeries() {\n         // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n-        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        assertDetectedViolations(\n+        helper.assertDetectedViolations(\n                 ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n     private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n     private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n     private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 775bd9eee1..b9910e5b2d 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -95,24 +87,24 @@ public class CorruptionDetectionIntegrationTest {\n         IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n         IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        helper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+        helper.assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+    private void createSeriesWithPaxosLogs(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         helper.writeLogsOnLocalAndRemote(\n                 helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+    private void corruptSeries(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n         helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    private static NamespaceAndUseCase namespaceAndUseCaseForIndex(int index) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + index), \"client\");\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjM5OQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515102399", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n          \n          \n            \n                private void createSeriesWithPaxosLogs(int namespaceAndUseCaseIndex) {", "author": "Jolyon-S", "createdAt": "2020-10-30T13:37:17Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogInLaterBatches() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        helper.assertNoCorruptionViolations();\n+\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n+\n+        helper.assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\ndeleted file mode 100644\nindex d35bcf058d..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,110 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n-import java.util.List;\n-import java.util.stream.IntStream;\n-import org.junit.Rule;\n-import org.junit.Test;\n-\n-/**\n- * This class performs integration tests by inducing and detecting corruption in one or more series.\n- * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n- */\n-public final class CorruptionDetectionIntegrationTest {\n-    @Rule\n-    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n-\n-    @Test\n-    public void detectCorruptionForLogAtBatchEnd() {\n-        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1.\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogInLaterBatches() {\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n-\n-        // No signs of corruption in the first batch\n-        helper.assertNoCorruptionViolations();\n-\n-        // Detects signs of corruption in the second batch\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForLogAtStartOfSecondBatch() {\n-        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n-        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n-\n-        // No signs of corruption in the first batch\n-        helper.assertNoCorruptionViolations();\n-\n-        // Detects signs of corruption in the second batch\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n-\n-        // No signs of corruption\n-        helper.assertNoCorruptionViolations();\n-\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n-        // Detects signs of corruption in the now corrupt first batch of logs\n-        helper.assertAcceptedValueGreaterThanLearnedValue();\n-    }\n-\n-    @Test\n-    public void detectCorruptionForMultipleCorruptSeries() {\n-        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n-        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n-\n-        helper.assertViolationsDetectedForNamespaceAndUseCases(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n-    }\n-\n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        helper.writeLogsOnLocalAndRemote(\n-                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n-    }\n-\n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n-        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n-    }\n-\n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nnew file mode 100644\nindex 0000000000..3f85cb00ab\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+// Note - All tests only induce and detect one type of corruption check violation ->\n+// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqInLaterBatches() {\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(599);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(500);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n+\n+        // Detects signs of corruption in the second batch\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        writeLogsOnLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+\n+        induceGreaterAcceptedValueCorruption(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n+        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+\n+        assertDetectedViolations(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 3f85cb00ab..775bd9eee1 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -19,89 +19,97 @@ package com.palantir.timelock.corruption.detection;\n import static org.assertj.core.api.Assertions.assertThat;\n \n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n import com.google.common.collect.SetMultimap;\n import com.palantir.paxos.Client;\n import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n import java.util.List;\n import java.util.stream.IntStream;\n+import org.junit.Rule;\n import org.junit.Test;\n \n-// Note - All tests only induce and detect one type of corruption check violation ->\n-// CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED\n-public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void detectCorruptionForLogAtSeqAtBatchEnd() {\n         // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1.\n-        writeLogsOnLocalAndRemote(1, 500);\n-        induceGreaterAcceptedValueCorruption(499);\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqInLaterBatches() {\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(599);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n \n         // No signs of corruption in the first batch\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForLogSeqAtStartOfSecondBatch() {\n         // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n         // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n-        writeLogsOnLocalAndRemote(1, 1000);\n-        induceGreaterAcceptedValueCorruption(500);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n \n         // No signs of corruption in the first batch\n         SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n+                helper.getViolationsToNamespaceToUseCaseMultimap();\n         assertThat(violationsToNamespaceToUseCaseMultimap.isEmpty()).isTrue();\n \n         // Detects signs of corruption in the second batch\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n-        writeLogsOnLocalAndRemote(1, 400);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n \n         // No signs of corruption\n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+        helper.assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n \n-        induceGreaterAcceptedValueCorruption(250);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n         // Detects signs of corruption in the now corrupt first batch of logs\n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n \n     @Test\n     public void detectCorruptionForMultipleCorruptSeries() {\n         // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n-        IntStream.rangeClosed(1, 7).boxed().forEach(ind -> createSeriesWithPaxosLogs(ind));\n-        IntStream.rangeClosed(6, 7).boxed().forEach(ind -> corruptSeries(ind));\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        assertDetectedViolations(\n+        helper.assertDetectedViolations(\n                 ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n     private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        writeLogsOnLocalAndRemote(createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n     private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n-        List<StateLogComponents> components = createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-        induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n     private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\nindex 775bd9eee1..b9910e5b2d 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java\n", "chunk": "@@ -95,24 +87,24 @@ public class CorruptionDetectionIntegrationTest {\n         IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n         IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n \n-        helper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+        helper.assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n                 ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n     }\n \n-    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+    private void createSeriesWithPaxosLogs(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         helper.writeLogsOnLocalAndRemote(\n                 helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n     }\n \n-    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+    private void corruptSeries(int namespaceAndUseCaseIndex) {\n         NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n         List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n         helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n     }\n \n-    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n-        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + ind), \"client\");\n+    private static NamespaceAndUseCase namespaceAndUseCaseForIndex(int index) {\n+        return ImmutableNamespaceAndUseCase.of(Client.of(\"client_\" + index), \"client\");\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTA0Mw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515105043", "bodyText": "nit: remove empty line\n\n  \n    \n      \n        Suggested change", "author": "Jolyon-S", "createdAt": "2020-10-30T13:41:14Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    }\n+\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n+        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n+    }\n+\n+    void assertNoCorruptionViolations() {\n+        assertViolationsDetectedForNamespaceAndUseCases(ImmutableSet.of(), ImmutableSet.of());\n+    }\n+\n+    void assertAcceptedValueGreaterThanLearnedValue() {\n+        assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    void assertViolationsDetected(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertViolationsDetectedForNamespaceAndUseCases(\n+                detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    void assertViolationsDetectedForNamespaceAndUseCases(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTkxOA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515105918", "bodyText": "With this method, either 1 or 0 detected violations are passed, which I'm not a fan of at all. I'd prefer if you separate out to two methods: one that takes a single violation and confirms it is there, and a second where the logic is essentially:\nassertThat(getViolationsToNamespaceToUseCaseMultimap()).isEmpty();", "author": "Jolyon-S", "createdAt": "2020-10-30T13:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTA0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\ndeleted file mode 100644\nindex 2239461aef..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,120 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Multimap;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.timelock.Constants;\n-import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n-import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n-import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import org.junit.rules.TestRule;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class TimeLockCorruptionDetectionHelper implements TestRule {\n-    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n-\n-    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n-        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n-    }\n-\n-    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n-    }\n-\n-    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n-    }\n-\n-    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n-    }\n-\n-    StateLogComponents getDefaultLocalServer() {\n-        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n-    }\n-\n-    List<StateLogComponents> getDefaultRemoteServerList() {\n-        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n-    }\n-\n-    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n-    }\n-\n-    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n-    }\n-\n-    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n-    }\n-\n-    void assertNoCorruptionViolations() {\n-        assertViolationsDetectedForNamespaceAndUseCases(ImmutableSet.of(), ImmutableSet.of());\n-    }\n-\n-    void assertAcceptedValueGreaterThanLearnedValue() {\n-        assertViolationsDetectedForNamespaceAndUseCases(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    void assertViolationsDetected(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertViolationsDetectedForNamespaceAndUseCases(\n-                detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    void assertViolationsDetectedForNamespaceAndUseCases(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-\n-        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n-        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n-    }\n-\n-    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n-        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-    }\n-\n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return timeLockCorruptionTestSetup.apply(base, description);\n-    }\n-}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nnew file mode 100644\nindex 0000000000..e3ae0e4bfe\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -0,0 +1,107 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.Rule;\n+import org.junit.rules.ExternalResource;\n+\n+public class TimeLockCorruptionDetectionHelper extends ExternalResource {\n+    @Rule\n+    public TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    @Override\n+    public void before() throws Throwable {\n+        timeLockCorruptionTestSetup.before();\n+    }\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n+        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n+    }\n+\n+    void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    }\n+\n+    void assertDetectedViolations(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+    }\n+}\n", "next_change": {"commit": "67dbd02bb499a4ea0649e81ba3640d65df882458", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex e3ae0e4bfe..5c7544ee63 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -104,4 +99,9 @@ public class TimeLockCorruptionDetectionHelper extends ExternalResource {\n             NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return timeLockCorruptionTestSetup.apply(base, description);\n+    }\n }\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 5c7544ee63..5a31ab2d76 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -33,71 +33,82 @@ import org.junit.rules.TestRule;\n import org.junit.runner.Description;\n import org.junit.runners.model.Statement;\n \n-public class TimeLockCorruptionDetectionHelper implements TestRule {\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n     private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n \n-    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n-        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int startInclusive, int endInclusive) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), startInclusive, endInclusive);\n     }\n \n-    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n     }\n \n-    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    private Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n     }\n \n-    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.wqqqq:riteAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n     }\n \n-    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n     }\n \n-    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n     }\n \n-    SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n     }\n \n     List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n         return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n     }\n \n-    void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertDetectedViolations(detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    void assertNoCorruptionViolations() {\n+        assertThat(getViolationsToNamespaceToUseCaseMultimap().isEmpty()).isTrue();\n     }\n \n-    List<StateLogComponents> getDefaultRemoteServerList() {\n-        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    void assertAcceptedValueGreaterThanLearnedValue() {\n+        assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n+                ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n     }\n \n-    StateLogComponents getDefaultLocalServer() {\n-        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    void assertViolationDetected(CorruptionCheckViolation expectedViolation) {\n+        assertViolationDetectedForNamespaceAndUseCases(\n+                expectedViolation, ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n     }\n \n-    void assertDetectedViolations(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+    void assertViolationDetectedForNamespaceAndUseCases(\n+            CorruptionCheckViolation expectedViolation,\n+            Set<NamespaceAndUseCase> expectedNamespaceAndUseCasesWithViolation) {\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n                 getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).isEqualTo(expectedViolation);\n         assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+                .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n \n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n             NamespaceAndUseCase namespaceAndUseCase) {\n-        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n     @Override\n", "next_change": {"commit": "21a1acd5e84c211f30877a7064485062039d0d3f", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 5a31ab2d76..68e2a36f8e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -106,8 +105,7 @@ public final class TimeLockCorruptionDetectionHelper implements TestRule {\n         return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n \n-    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n+    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n", "next_change": {"commit": "84cfdc115b2317a6c62c7dae6eb0f2cb35567be2", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 68e2a36f8e..efaf7fee3e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -101,16 +101,16 @@ public final class TimeLockCorruptionDetectionHelper implements TestRule {\n                 .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n     }\n \n-    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n     List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return timeLockCorruptionTestSetup.apply(base, description);\n+    private static void writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n+        PaxosSerializationTestUtils.writeToLogs(\n+                server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNjIzOQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515106239", "bodyText": "you can inline this variable - the method call is actually shorter than the variable!", "author": "Jolyon-S", "createdAt": "2020-10-30T13:43:16Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    }\n+\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n+        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n+    }\n+\n+    void assertNoCorruptionViolations() {\n+        assertViolationsDetectedForNamespaceAndUseCases(ImmutableSet.of(), ImmutableSet.of());\n+    }\n+\n+    void assertAcceptedValueGreaterThanLearnedValue() {\n+        assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    void assertViolationsDetected(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertViolationsDetectedForNamespaceAndUseCases(\n+                detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    void assertViolationsDetectedForNamespaceAndUseCases(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\ndeleted file mode 100644\nindex 2239461aef..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,120 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Multimap;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.timelock.Constants;\n-import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n-import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n-import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import org.junit.rules.TestRule;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class TimeLockCorruptionDetectionHelper implements TestRule {\n-    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n-\n-    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n-        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n-    }\n-\n-    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n-    }\n-\n-    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n-    }\n-\n-    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n-    }\n-\n-    StateLogComponents getDefaultLocalServer() {\n-        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n-    }\n-\n-    List<StateLogComponents> getDefaultRemoteServerList() {\n-        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n-    }\n-\n-    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n-    }\n-\n-    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n-    }\n-\n-    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n-    }\n-\n-    void assertNoCorruptionViolations() {\n-        assertViolationsDetectedForNamespaceAndUseCases(ImmutableSet.of(), ImmutableSet.of());\n-    }\n-\n-    void assertAcceptedValueGreaterThanLearnedValue() {\n-        assertViolationsDetectedForNamespaceAndUseCases(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    void assertViolationsDetected(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertViolationsDetectedForNamespaceAndUseCases(\n-                detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    void assertViolationsDetectedForNamespaceAndUseCases(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-\n-        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n-        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n-    }\n-\n-    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n-        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-    }\n-\n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return timeLockCorruptionTestSetup.apply(base, description);\n-    }\n-}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nnew file mode 100644\nindex 0000000000..e3ae0e4bfe\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -0,0 +1,107 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.Rule;\n+import org.junit.rules.ExternalResource;\n+\n+public class TimeLockCorruptionDetectionHelper extends ExternalResource {\n+    @Rule\n+    public TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    @Override\n+    public void before() throws Throwable {\n+        timeLockCorruptionTestSetup.before();\n+    }\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n+        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n+    }\n+\n+    void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    }\n+\n+    void assertDetectedViolations(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+    }\n+}\n", "next_change": {"commit": "67dbd02bb499a4ea0649e81ba3640d65df882458", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex e3ae0e4bfe..5c7544ee63 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -104,4 +99,9 @@ public class TimeLockCorruptionDetectionHelper extends ExternalResource {\n             NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return timeLockCorruptionTestSetup.apply(base, description);\n+    }\n }\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 5c7544ee63..5a31ab2d76 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -33,71 +33,82 @@ import org.junit.rules.TestRule;\n import org.junit.runner.Description;\n import org.junit.runners.model.Statement;\n \n-public class TimeLockCorruptionDetectionHelper implements TestRule {\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n     private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n \n-    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n-        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int startInclusive, int endInclusive) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), startInclusive, endInclusive);\n     }\n \n-    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n     }\n \n-    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    private Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n     }\n \n-    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.wqqqq:riteAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n     }\n \n-    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n     }\n \n-    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n     }\n \n-    SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n     }\n \n     List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n         return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n     }\n \n-    void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertDetectedViolations(detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    void assertNoCorruptionViolations() {\n+        assertThat(getViolationsToNamespaceToUseCaseMultimap().isEmpty()).isTrue();\n     }\n \n-    List<StateLogComponents> getDefaultRemoteServerList() {\n-        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    void assertAcceptedValueGreaterThanLearnedValue() {\n+        assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n+                ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n     }\n \n-    StateLogComponents getDefaultLocalServer() {\n-        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    void assertViolationDetected(CorruptionCheckViolation expectedViolation) {\n+        assertViolationDetectedForNamespaceAndUseCases(\n+                expectedViolation, ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n     }\n \n-    void assertDetectedViolations(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+    void assertViolationDetectedForNamespaceAndUseCases(\n+            CorruptionCheckViolation expectedViolation,\n+            Set<NamespaceAndUseCase> expectedNamespaceAndUseCasesWithViolation) {\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n                 getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).isEqualTo(expectedViolation);\n         assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+                .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n \n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n             NamespaceAndUseCase namespaceAndUseCase) {\n-        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n     @Override\n", "next_change": {"commit": "21a1acd5e84c211f30877a7064485062039d0d3f", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 5a31ab2d76..68e2a36f8e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -106,8 +105,7 @@ public final class TimeLockCorruptionDetectionHelper implements TestRule {\n         return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n \n-    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n+    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n", "next_change": {"commit": "84cfdc115b2317a6c62c7dae6eb0f2cb35567be2", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 68e2a36f8e..efaf7fee3e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -101,16 +101,16 @@ public final class TimeLockCorruptionDetectionHelper implements TestRule {\n                 .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n     }\n \n-    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n     List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return timeLockCorruptionTestSetup.apply(base, description);\n+    private static void writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n+        PaxosSerializationTestUtils.writeToLogs(\n+                server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNzEzOA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515107138", "bodyText": "IntelliJ tells me that there are a number of methods that can be private - please make them private, then re-order so that they are after the non-private ones.\nAlso, there are definitely some methods that can be static - for example writeLogsOnServer. Please make static the methods that can be.", "author": "Jolyon-S", "createdAt": "2020-10-30T13:44:41Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwNDUxNQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515904515", "bodyText": "Made the methods package-private.\nDone.", "author": "sudiksha27", "createdAt": "2020-11-02T11:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNzEzOA=="}], "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\ndeleted file mode 100644\nindex 2239461aef..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,120 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Multimap;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.timelock.Constants;\n-import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n-import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n-import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import org.junit.rules.TestRule;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class TimeLockCorruptionDetectionHelper implements TestRule {\n-    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n-\n-    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n-        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n-    }\n-\n-    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n-    }\n-\n-    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n-    }\n-\n-    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n-    }\n-\n-    StateLogComponents getDefaultLocalServer() {\n-        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n-    }\n-\n-    List<StateLogComponents> getDefaultRemoteServerList() {\n-        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n-    }\n-\n-    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n-    }\n-\n-    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n-    }\n-\n-    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n-    }\n-\n-    void assertNoCorruptionViolations() {\n-        assertViolationsDetectedForNamespaceAndUseCases(ImmutableSet.of(), ImmutableSet.of());\n-    }\n-\n-    void assertAcceptedValueGreaterThanLearnedValue() {\n-        assertViolationsDetectedForNamespaceAndUseCases(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    void assertViolationsDetected(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertViolationsDetectedForNamespaceAndUseCases(\n-                detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    void assertViolationsDetectedForNamespaceAndUseCases(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-\n-        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n-        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n-    }\n-\n-    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n-        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-    }\n-\n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return timeLockCorruptionTestSetup.apply(base, description);\n-    }\n-}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nnew file mode 100644\nindex 0000000000..e3ae0e4bfe\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -0,0 +1,107 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.Rule;\n+import org.junit.rules.ExternalResource;\n+\n+public class TimeLockCorruptionDetectionHelper extends ExternalResource {\n+    @Rule\n+    public TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    @Override\n+    public void before() throws Throwable {\n+        timeLockCorruptionTestSetup.before();\n+    }\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n+        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n+    }\n+\n+    void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    }\n+\n+    void assertDetectedViolations(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+    }\n+}\n", "next_change": {"commit": "67dbd02bb499a4ea0649e81ba3640d65df882458", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex e3ae0e4bfe..5c7544ee63 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -104,4 +99,9 @@ public class TimeLockCorruptionDetectionHelper extends ExternalResource {\n             NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return timeLockCorruptionTestSetup.apply(base, description);\n+    }\n }\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 5c7544ee63..5a31ab2d76 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -33,71 +33,82 @@ import org.junit.rules.TestRule;\n import org.junit.runner.Description;\n import org.junit.runners.model.Statement;\n \n-public class TimeLockCorruptionDetectionHelper implements TestRule {\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n     private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n \n-    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n-        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int startInclusive, int endInclusive) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), startInclusive, endInclusive);\n     }\n \n-    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n     }\n \n-    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    private Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n     }\n \n-    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.wqqqq:riteAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n     }\n \n-    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n     }\n \n-    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n     }\n \n-    SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n     }\n \n     List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n         return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n     }\n \n-    void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertDetectedViolations(detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    void assertNoCorruptionViolations() {\n+        assertThat(getViolationsToNamespaceToUseCaseMultimap().isEmpty()).isTrue();\n     }\n \n-    List<StateLogComponents> getDefaultRemoteServerList() {\n-        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    void assertAcceptedValueGreaterThanLearnedValue() {\n+        assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n+                ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n     }\n \n-    StateLogComponents getDefaultLocalServer() {\n-        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    void assertViolationDetected(CorruptionCheckViolation expectedViolation) {\n+        assertViolationDetectedForNamespaceAndUseCases(\n+                expectedViolation, ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n     }\n \n-    void assertDetectedViolations(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+    void assertViolationDetectedForNamespaceAndUseCases(\n+            CorruptionCheckViolation expectedViolation,\n+            Set<NamespaceAndUseCase> expectedNamespaceAndUseCasesWithViolation) {\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n                 getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).isEqualTo(expectedViolation);\n         assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+                .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n \n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n             NamespaceAndUseCase namespaceAndUseCase) {\n-        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n     @Override\n", "next_change": {"commit": "21a1acd5e84c211f30877a7064485062039d0d3f", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 5a31ab2d76..68e2a36f8e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -106,8 +105,7 @@ public final class TimeLockCorruptionDetectionHelper implements TestRule {\n         return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n \n-    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n+    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n", "next_change": {"commit": "84cfdc115b2317a6c62c7dae6eb0f2cb35567be2", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 68e2a36f8e..efaf7fee3e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -101,16 +101,16 @@ public final class TimeLockCorruptionDetectionHelper implements TestRule {\n                 .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n     }\n \n-    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n     List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return timeLockCorruptionTestSetup.apply(base, description);\n+    private static void writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n+        PaxosSerializationTestUtils.writeToLogs(\n+                server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNzMwMw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515107303", "bodyText": "We discussed - remove stream()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n          \n          \n            \n                    servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));", "author": "Jolyon-S", "createdAt": "2020-10-30T13:44:58Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\ndeleted file mode 100644\nindex 2239461aef..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,120 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Multimap;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.timelock.Constants;\n-import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n-import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n-import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import org.junit.rules.TestRule;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class TimeLockCorruptionDetectionHelper implements TestRule {\n-    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n-\n-    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n-        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n-    }\n-\n-    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n-    }\n-\n-    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n-    }\n-\n-    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n-    }\n-\n-    StateLogComponents getDefaultLocalServer() {\n-        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n-    }\n-\n-    List<StateLogComponents> getDefaultRemoteServerList() {\n-        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n-    }\n-\n-    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n-    }\n-\n-    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n-    }\n-\n-    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n-    }\n-\n-    void assertNoCorruptionViolations() {\n-        assertViolationsDetectedForNamespaceAndUseCases(ImmutableSet.of(), ImmutableSet.of());\n-    }\n-\n-    void assertAcceptedValueGreaterThanLearnedValue() {\n-        assertViolationsDetectedForNamespaceAndUseCases(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    void assertViolationsDetected(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertViolationsDetectedForNamespaceAndUseCases(\n-                detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    void assertViolationsDetectedForNamespaceAndUseCases(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-\n-        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n-        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n-    }\n-\n-    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n-        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-    }\n-\n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return timeLockCorruptionTestSetup.apply(base, description);\n-    }\n-}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nnew file mode 100644\nindex 0000000000..e3ae0e4bfe\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -0,0 +1,107 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.Rule;\n+import org.junit.rules.ExternalResource;\n+\n+public class TimeLockCorruptionDetectionHelper extends ExternalResource {\n+    @Rule\n+    public TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    @Override\n+    public void before() throws Throwable {\n+        timeLockCorruptionTestSetup.before();\n+    }\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n+        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n+    }\n+\n+    void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    }\n+\n+    void assertDetectedViolations(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+    }\n+}\n", "next_change": {"commit": "67dbd02bb499a4ea0649e81ba3640d65df882458", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex e3ae0e4bfe..5c7544ee63 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -104,4 +99,9 @@ public class TimeLockCorruptionDetectionHelper extends ExternalResource {\n             NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return timeLockCorruptionTestSetup.apply(base, description);\n+    }\n }\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 5c7544ee63..5a31ab2d76 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -33,71 +33,82 @@ import org.junit.rules.TestRule;\n import org.junit.runner.Description;\n import org.junit.runners.model.Statement;\n \n-public class TimeLockCorruptionDetectionHelper implements TestRule {\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n     private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n \n-    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n-        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int startInclusive, int endInclusive) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), startInclusive, endInclusive);\n     }\n \n-    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n     }\n \n-    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    private Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n     }\n \n-    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.wqqqq:riteAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n     }\n \n-    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n     }\n \n-    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n     }\n \n-    SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n     }\n \n     List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n         return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n     }\n \n-    void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertDetectedViolations(detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    void assertNoCorruptionViolations() {\n+        assertThat(getViolationsToNamespaceToUseCaseMultimap().isEmpty()).isTrue();\n     }\n \n-    List<StateLogComponents> getDefaultRemoteServerList() {\n-        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    void assertAcceptedValueGreaterThanLearnedValue() {\n+        assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n+                ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n     }\n \n-    StateLogComponents getDefaultLocalServer() {\n-        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    void assertViolationDetected(CorruptionCheckViolation expectedViolation) {\n+        assertViolationDetectedForNamespaceAndUseCases(\n+                expectedViolation, ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n     }\n \n-    void assertDetectedViolations(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+    void assertViolationDetectedForNamespaceAndUseCases(\n+            CorruptionCheckViolation expectedViolation,\n+            Set<NamespaceAndUseCase> expectedNamespaceAndUseCasesWithViolation) {\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n                 getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).isEqualTo(expectedViolation);\n         assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+                .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n \n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n             NamespaceAndUseCase namespaceAndUseCase) {\n-        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n     @Override\n", "next_change": {"commit": "21a1acd5e84c211f30877a7064485062039d0d3f", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 5a31ab2d76..68e2a36f8e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -106,8 +105,7 @@ public final class TimeLockCorruptionDetectionHelper implements TestRule {\n         return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n \n-    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n+    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n", "next_change": {"commit": "84cfdc115b2317a6c62c7dae6eb0f2cb35567be2", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 68e2a36f8e..efaf7fee3e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -101,16 +101,16 @@ public final class TimeLockCorruptionDetectionHelper implements TestRule {\n                 .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n     }\n \n-    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n     List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return timeLockCorruptionTestSetup.apply(base, description);\n+    private static void writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n+        PaxosSerializationTestUtils.writeToLogs(\n+                server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwODA3NQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515108075", "bodyText": "Interesting - if we get an exception on startup, we don't want to do anything? I'd have thought we'd do:\nthrow new RuntimeException(throwable, \"failed on startup\");", "author": "Jolyon-S", "createdAt": "2020-10-30T13:46:03Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionTestSetup implements TestRule {\n+    private TemporaryFolder tempFolder = new TemporaryFolder();\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    private StateLogComponents defaultLocalServer;\n+    private List<StateLogComponents> defaultRemoteServerList;\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return RuleChain.outerRule(tempFolder)\n+                .around(new ExternalResource() {\n+                    @Override\n+                    protected void before() {\n+                        try {\n+                            setup();\n+                        } catch (Throwable throwable) {\n+                            // no op", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\ndeleted file mode 100644\nindex f66294ced3..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n+++ /dev/null\n", "chunk": "@@ -1,174 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosAcceptorState;\n-import com.palantir.paxos.PaxosStateLog;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.paxos.SqliteConnections;\n-import com.palantir.paxos.SqlitePaxosStateLog;\n-import com.palantir.timelock.Constants;\n-import com.palantir.timelock.history.LocalHistoryLoader;\n-import com.palantir.timelock.history.PaxosLogHistoryProvider;\n-import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n-import com.palantir.timelock.history.models.AcceptorUseCase;\n-import com.palantir.timelock.history.models.LearnerUseCase;\n-import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-import javax.sql.DataSource;\n-import org.immutables.value.Value;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.RuleChain;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.rules.TestRule;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class TimeLockCorruptionTestSetup implements TestRule {\n-    private TemporaryFolder tempFolder = new TemporaryFolder();\n-    private DataSource localDataSource;\n-    private DataSource remoteDataSource1;\n-    private DataSource remoteDataSource2;\n-    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n-\n-    private StateLogComponents defaultLocalServer;\n-    private List<StateLogComponents> defaultRemoteServerList;\n-\n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return RuleChain.outerRule(tempFolder)\n-                .around(new ExternalResource() {\n-                    @Override\n-                    protected void before() {\n-                        try {\n-                            setup();\n-                        } catch (Throwable throwable) {\n-                            // no op\n-                        }\n-                    }\n-\n-                    @Override\n-                    protected void after() {\n-                        // no op\n-                    }\n-                })\n-                .apply(base, description);\n-    }\n-\n-    private void setup() throws Throwable {\n-        localDataSource = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile1\").toPath());\n-        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile2\").toPath());\n-        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile3\").toPath());\n-\n-        defaultLocalServer = createLogComponentsForServer(localDataSource);\n-        defaultRemoteServerList = ImmutableList.of(\n-                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n-        paxosLogHistoryProvider = paxosLogHistoryProvider();\n-    }\n-\n-    private PaxosLogHistoryProvider paxosLogHistoryProvider() {\n-        return new PaxosLogHistoryProvider(\n-                localDataSource,\n-                defaultRemoteServerList.stream()\n-                        .map(StateLogComponents::dataSource)\n-                        .map(this::getHistoryProviderResource)\n-                        .collect(Collectors.toList()));\n-    }\n-\n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n-        return ImmutableList.of(\n-                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n-                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n-                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n-    }\n-\n-    public List<StateLogComponents> getDefaultServerList() {\n-        return ImmutableList.<StateLogComponents>builder()\n-                .add(defaultLocalServer)\n-                .addAll(defaultRemoteServerList)\n-                .build();\n-    }\n-\n-    public PaxosLogHistoryProvider getPaxosLogHistoryProvider() {\n-        return paxosLogHistoryProvider;\n-    }\n-\n-    public StateLogComponents getDefaultLocalServer() {\n-        return defaultLocalServer;\n-    }\n-\n-    public List<StateLogComponents> getDefaultRemoteServerList() {\n-        return defaultRemoteServerList;\n-    }\n-\n-    private StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n-        return createLogComponentsForServer(dataSource, Constants.DEFAULT_NAMESPACE_AND_USE_CASE);\n-    }\n-\n-    private StateLogComponents createLogComponentsForServer(\n-            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n-\n-        Client client = namespaceAndUseCase.namespace();\n-        String paxosUseCase = namespaceAndUseCase.useCase();\n-\n-        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n-                ImmutableNamespaceAndUseCase.of(\n-                        client,\n-                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n-                dataSource);\n-\n-        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n-                ImmutableNamespaceAndUseCase.of(\n-                        client,\n-                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n-                dataSource);\n-\n-        return StateLogComponents.builder()\n-                .dataSource(dataSource)\n-                .learnerLog(learnerLog)\n-                .acceptorLog(acceptorLog)\n-                .build();\n-    }\n-\n-    private TimeLockPaxosHistoryProvider getHistoryProviderResource(DataSource dataSource) {\n-        return TimeLockPaxosHistoryProviderResource.jersey(\n-                LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource)));\n-    }\n-\n-    @Value.Immutable\n-    interface StateLogComponents {\n-        DataSource dataSource();\n-\n-        PaxosStateLog<PaxosValue> learnerLog();\n-\n-        PaxosStateLog<PaxosAcceptorState> acceptorLog();\n-\n-        static ImmutableStateLogComponents.Builder builder() {\n-            return ImmutableStateLogComponents.builder();\n-        }\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\nnew file mode 100644\nindex 0000000000..9d1bcc96ae\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n", "chunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n+            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n+\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+\n+    protected StateLogComponents localStateLogComponents;\n+    protected List<StateLogComponents> remoteStateLogComponents;\n+    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        localStateLogComponents = createLogComponentsForServer(localDataSource);\n+        remoteStateLogComponents = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n+                localStateLogComponents.dataSource(),\n+                remoteStateLogComponents.stream()\n+                        .map(StateLogComponents::serverHistoryProvider)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    // utils\n+    protected Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n+        return createLogComponentsForServer(dataSource, NAMESPACE_AND_USE_CASE);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(\n+            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n+\n+        Client client = namespaceAndUseCase.namespace();\n+        String paxosUseCase = namespaceAndUseCase.useCase();\n+\n+        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        LocalHistoryLoader history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+        TimeLockPaxosHistoryProvider serverHistoryProvider = TimeLockPaxosHistoryProviderResource.jersey(history);\n+        return StateLogComponents.builder()\n+                .dataSource(dataSource)\n+                .learnerLog(learnerLog)\n+                .acceptorLog(acceptorLog)\n+                .history(history)\n+                .serverHistoryProvider(serverHistoryProvider)\n+                .build();\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(localStateLogComponents, corruptSeq);\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                ImmutableList.<StateLogComponents>builder()\n+                        .add(localStateLogComponents)\n+                        .addAll(remoteStateLogComponents)\n+                        .build(),\n+                startingLogSeq,\n+                latestLogSequence);\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(\n+            List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    protected SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    protected void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    protected void assertDetectedViolations(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    @Value.Immutable\n+    interface StateLogComponents {\n+        DataSource dataSource();\n+\n+        PaxosStateLog<PaxosValue> learnerLog();\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog();\n+\n+        LocalHistoryLoader history();\n+\n+        TimeLockPaxosHistoryProvider serverHistoryProvider();\n+\n+        static ImmutableStateLogComponents.Builder builder() {\n+            return ImmutableStateLogComponents.builder();\n+        }\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\nindex 9d1bcc96ae..140572593b 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n", "chunk": "@@ -184,10 +157,6 @@ public abstract class TimeLockCorruptionTestSetup {\n \n         PaxosStateLog<PaxosAcceptorState> acceptorLog();\n \n-        LocalHistoryLoader history();\n-\n-        TimeLockPaxosHistoryProvider serverHistoryProvider();\n-\n         static ImmutableStateLogComponents.Builder builder() {\n             return ImmutableStateLogComponents.builder();\n         }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwODc5NA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515108794", "bodyText": "Same as elsewhere: this and other methods don't need to be public.", "author": "Jolyon-S", "createdAt": "2020-10-30T13:47:08Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionTestSetup implements TestRule {\n+    private TemporaryFolder tempFolder = new TemporaryFolder();\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    private StateLogComponents defaultLocalServer;\n+    private List<StateLogComponents> defaultRemoteServerList;\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return RuleChain.outerRule(tempFolder)\n+                .around(new ExternalResource() {\n+                    @Override\n+                    protected void before() {\n+                        try {\n+                            setup();\n+                        } catch (Throwable throwable) {\n+                            // no op\n+                        }\n+                    }\n+\n+                    @Override\n+                    protected void after() {\n+                        // no op\n+                    }\n+                })\n+                .apply(base, description);\n+    }\n+\n+    private void setup() throws Throwable {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        defaultLocalServer = createLogComponentsForServer(localDataSource);\n+        defaultRemoteServerList = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = paxosLogHistoryProvider();\n+    }\n+\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider() {\n+        return new PaxosLogHistoryProvider(\n+                localDataSource,\n+                defaultRemoteServerList.stream()\n+                        .map(StateLogComponents::dataSource)\n+                        .map(this::getHistoryProviderResource)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE1OTI4Mw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515159283", "bodyText": "also: StatLog?", "author": "jeremyk-91", "createdAt": "2020-10-30T14:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwODc5NA=="}], "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\ndeleted file mode 100644\nindex f66294ced3..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n+++ /dev/null\n", "chunk": "@@ -1,174 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosAcceptorState;\n-import com.palantir.paxos.PaxosStateLog;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.paxos.SqliteConnections;\n-import com.palantir.paxos.SqlitePaxosStateLog;\n-import com.palantir.timelock.Constants;\n-import com.palantir.timelock.history.LocalHistoryLoader;\n-import com.palantir.timelock.history.PaxosLogHistoryProvider;\n-import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n-import com.palantir.timelock.history.models.AcceptorUseCase;\n-import com.palantir.timelock.history.models.LearnerUseCase;\n-import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-import javax.sql.DataSource;\n-import org.immutables.value.Value;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.RuleChain;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.rules.TestRule;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class TimeLockCorruptionTestSetup implements TestRule {\n-    private TemporaryFolder tempFolder = new TemporaryFolder();\n-    private DataSource localDataSource;\n-    private DataSource remoteDataSource1;\n-    private DataSource remoteDataSource2;\n-    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n-\n-    private StateLogComponents defaultLocalServer;\n-    private List<StateLogComponents> defaultRemoteServerList;\n-\n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return RuleChain.outerRule(tempFolder)\n-                .around(new ExternalResource() {\n-                    @Override\n-                    protected void before() {\n-                        try {\n-                            setup();\n-                        } catch (Throwable throwable) {\n-                            // no op\n-                        }\n-                    }\n-\n-                    @Override\n-                    protected void after() {\n-                        // no op\n-                    }\n-                })\n-                .apply(base, description);\n-    }\n-\n-    private void setup() throws Throwable {\n-        localDataSource = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile1\").toPath());\n-        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile2\").toPath());\n-        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile3\").toPath());\n-\n-        defaultLocalServer = createLogComponentsForServer(localDataSource);\n-        defaultRemoteServerList = ImmutableList.of(\n-                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n-        paxosLogHistoryProvider = paxosLogHistoryProvider();\n-    }\n-\n-    private PaxosLogHistoryProvider paxosLogHistoryProvider() {\n-        return new PaxosLogHistoryProvider(\n-                localDataSource,\n-                defaultRemoteServerList.stream()\n-                        .map(StateLogComponents::dataSource)\n-                        .map(this::getHistoryProviderResource)\n-                        .collect(Collectors.toList()));\n-    }\n-\n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n-        return ImmutableList.of(\n-                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n-                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n-                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n-    }\n-\n-    public List<StateLogComponents> getDefaultServerList() {\n-        return ImmutableList.<StateLogComponents>builder()\n-                .add(defaultLocalServer)\n-                .addAll(defaultRemoteServerList)\n-                .build();\n-    }\n-\n-    public PaxosLogHistoryProvider getPaxosLogHistoryProvider() {\n-        return paxosLogHistoryProvider;\n-    }\n-\n-    public StateLogComponents getDefaultLocalServer() {\n-        return defaultLocalServer;\n-    }\n-\n-    public List<StateLogComponents> getDefaultRemoteServerList() {\n-        return defaultRemoteServerList;\n-    }\n-\n-    private StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n-        return createLogComponentsForServer(dataSource, Constants.DEFAULT_NAMESPACE_AND_USE_CASE);\n-    }\n-\n-    private StateLogComponents createLogComponentsForServer(\n-            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n-\n-        Client client = namespaceAndUseCase.namespace();\n-        String paxosUseCase = namespaceAndUseCase.useCase();\n-\n-        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n-                ImmutableNamespaceAndUseCase.of(\n-                        client,\n-                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n-                dataSource);\n-\n-        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n-                ImmutableNamespaceAndUseCase.of(\n-                        client,\n-                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n-                dataSource);\n-\n-        return StateLogComponents.builder()\n-                .dataSource(dataSource)\n-                .learnerLog(learnerLog)\n-                .acceptorLog(acceptorLog)\n-                .build();\n-    }\n-\n-    private TimeLockPaxosHistoryProvider getHistoryProviderResource(DataSource dataSource) {\n-        return TimeLockPaxosHistoryProviderResource.jersey(\n-                LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource)));\n-    }\n-\n-    @Value.Immutable\n-    interface StateLogComponents {\n-        DataSource dataSource();\n-\n-        PaxosStateLog<PaxosValue> learnerLog();\n-\n-        PaxosStateLog<PaxosAcceptorState> acceptorLog();\n-\n-        static ImmutableStateLogComponents.Builder builder() {\n-            return ImmutableStateLogComponents.builder();\n-        }\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\nnew file mode 100644\nindex 0000000000..9d1bcc96ae\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n", "chunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n+            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n+\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+\n+    protected StateLogComponents localStateLogComponents;\n+    protected List<StateLogComponents> remoteStateLogComponents;\n+    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        localStateLogComponents = createLogComponentsForServer(localDataSource);\n+        remoteStateLogComponents = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n+                localStateLogComponents.dataSource(),\n+                remoteStateLogComponents.stream()\n+                        .map(StateLogComponents::serverHistoryProvider)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    // utils\n+    protected Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n+        return createLogComponentsForServer(dataSource, NAMESPACE_AND_USE_CASE);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(\n+            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n+\n+        Client client = namespaceAndUseCase.namespace();\n+        String paxosUseCase = namespaceAndUseCase.useCase();\n+\n+        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        LocalHistoryLoader history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+        TimeLockPaxosHistoryProvider serverHistoryProvider = TimeLockPaxosHistoryProviderResource.jersey(history);\n+        return StateLogComponents.builder()\n+                .dataSource(dataSource)\n+                .learnerLog(learnerLog)\n+                .acceptorLog(acceptorLog)\n+                .history(history)\n+                .serverHistoryProvider(serverHistoryProvider)\n+                .build();\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(localStateLogComponents, corruptSeq);\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                ImmutableList.<StateLogComponents>builder()\n+                        .add(localStateLogComponents)\n+                        .addAll(remoteStateLogComponents)\n+                        .build(),\n+                startingLogSeq,\n+                latestLogSequence);\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(\n+            List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    protected SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    protected void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    protected void assertDetectedViolations(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    @Value.Immutable\n+    interface StateLogComponents {\n+        DataSource dataSource();\n+\n+        PaxosStateLog<PaxosValue> learnerLog();\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog();\n+\n+        LocalHistoryLoader history();\n+\n+        TimeLockPaxosHistoryProvider serverHistoryProvider();\n+\n+        static ImmutableStateLogComponents.Builder builder() {\n+            return ImmutableStateLogComponents.builder();\n+        }\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\nindex 9d1bcc96ae..140572593b 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n", "chunk": "@@ -184,10 +157,6 @@ public abstract class TimeLockCorruptionTestSetup {\n \n         PaxosStateLog<PaxosAcceptorState> acceptorLog();\n \n-        LocalHistoryLoader history();\n-\n-        TimeLockPaxosHistoryProvider serverHistoryProvider();\n-\n         static ImmutableStateLogComponents.Builder builder() {\n             return ImmutableStateLogComponents.builder();\n         }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwOTA2OQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515109069", "bodyText": "nit: static?", "author": "Jolyon-S", "createdAt": "2020-10-30T13:47:39Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionTestSetup implements TestRule {\n+    private TemporaryFolder tempFolder = new TemporaryFolder();\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    private StateLogComponents defaultLocalServer;\n+    private List<StateLogComponents> defaultRemoteServerList;\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return RuleChain.outerRule(tempFolder)\n+                .around(new ExternalResource() {\n+                    @Override\n+                    protected void before() {\n+                        try {\n+                            setup();\n+                        } catch (Throwable throwable) {\n+                            // no op\n+                        }\n+                    }\n+\n+                    @Override\n+                    protected void after() {\n+                        // no op\n+                    }\n+                })\n+                .apply(base, description);\n+    }\n+\n+    private void setup() throws Throwable {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        defaultLocalServer = createLogComponentsForServer(localDataSource);\n+        defaultRemoteServerList = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = paxosLogHistoryProvider();\n+    }\n+\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider() {\n+        return new PaxosLogHistoryProvider(\n+                localDataSource,\n+                defaultRemoteServerList.stream()\n+                        .map(StateLogComponents::dataSource)\n+                        .map(this::getHistoryProviderResource)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    public List<StateLogComponents> getDefaultServerList() {\n+        return ImmutableList.<StateLogComponents>builder()\n+                .add(defaultLocalServer)\n+                .addAll(defaultRemoteServerList)\n+                .build();\n+    }\n+\n+    public PaxosLogHistoryProvider getPaxosLogHistoryProvider() {\n+        return paxosLogHistoryProvider;\n+    }\n+\n+    public StateLogComponents getDefaultLocalServer() {\n+        return defaultLocalServer;\n+    }\n+\n+    public List<StateLogComponents> getDefaultRemoteServerList() {\n+        return defaultRemoteServerList;\n+    }\n+\n+    private StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n+        return createLogComponentsForServer(dataSource, Constants.DEFAULT_NAMESPACE_AND_USE_CASE);\n+    }\n+\n+    private StateLogComponents createLogComponentsForServer(", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwOTE3Nw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515109177", "bodyText": "there are others in this class too", "author": "Jolyon-S", "createdAt": "2020-10-30T13:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwOTA2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\ndeleted file mode 100644\nindex f66294ced3..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n+++ /dev/null\n", "chunk": "@@ -1,174 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosAcceptorState;\n-import com.palantir.paxos.PaxosStateLog;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.paxos.SqliteConnections;\n-import com.palantir.paxos.SqlitePaxosStateLog;\n-import com.palantir.timelock.Constants;\n-import com.palantir.timelock.history.LocalHistoryLoader;\n-import com.palantir.timelock.history.PaxosLogHistoryProvider;\n-import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n-import com.palantir.timelock.history.models.AcceptorUseCase;\n-import com.palantir.timelock.history.models.LearnerUseCase;\n-import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-import javax.sql.DataSource;\n-import org.immutables.value.Value;\n-import org.junit.rules.ExternalResource;\n-import org.junit.rules.RuleChain;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.rules.TestRule;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class TimeLockCorruptionTestSetup implements TestRule {\n-    private TemporaryFolder tempFolder = new TemporaryFolder();\n-    private DataSource localDataSource;\n-    private DataSource remoteDataSource1;\n-    private DataSource remoteDataSource2;\n-    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n-\n-    private StateLogComponents defaultLocalServer;\n-    private List<StateLogComponents> defaultRemoteServerList;\n-\n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return RuleChain.outerRule(tempFolder)\n-                .around(new ExternalResource() {\n-                    @Override\n-                    protected void before() {\n-                        try {\n-                            setup();\n-                        } catch (Throwable throwable) {\n-                            // no op\n-                        }\n-                    }\n-\n-                    @Override\n-                    protected void after() {\n-                        // no op\n-                    }\n-                })\n-                .apply(base, description);\n-    }\n-\n-    private void setup() throws Throwable {\n-        localDataSource = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile1\").toPath());\n-        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile2\").toPath());\n-        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n-                tempFolder.newFolder(\"randomFile3\").toPath());\n-\n-        defaultLocalServer = createLogComponentsForServer(localDataSource);\n-        defaultRemoteServerList = ImmutableList.of(\n-                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n-        paxosLogHistoryProvider = paxosLogHistoryProvider();\n-    }\n-\n-    private PaxosLogHistoryProvider paxosLogHistoryProvider() {\n-        return new PaxosLogHistoryProvider(\n-                localDataSource,\n-                defaultRemoteServerList.stream()\n-                        .map(StateLogComponents::dataSource)\n-                        .map(this::getHistoryProviderResource)\n-                        .collect(Collectors.toList()));\n-    }\n-\n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n-        return ImmutableList.of(\n-                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n-                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n-                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n-    }\n-\n-    public List<StateLogComponents> getDefaultServerList() {\n-        return ImmutableList.<StateLogComponents>builder()\n-                .add(defaultLocalServer)\n-                .addAll(defaultRemoteServerList)\n-                .build();\n-    }\n-\n-    public PaxosLogHistoryProvider getPaxosLogHistoryProvider() {\n-        return paxosLogHistoryProvider;\n-    }\n-\n-    public StateLogComponents getDefaultLocalServer() {\n-        return defaultLocalServer;\n-    }\n-\n-    public List<StateLogComponents> getDefaultRemoteServerList() {\n-        return defaultRemoteServerList;\n-    }\n-\n-    private StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n-        return createLogComponentsForServer(dataSource, Constants.DEFAULT_NAMESPACE_AND_USE_CASE);\n-    }\n-\n-    private StateLogComponents createLogComponentsForServer(\n-            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n-\n-        Client client = namespaceAndUseCase.namespace();\n-        String paxosUseCase = namespaceAndUseCase.useCase();\n-\n-        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n-                ImmutableNamespaceAndUseCase.of(\n-                        client,\n-                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n-                dataSource);\n-\n-        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n-                ImmutableNamespaceAndUseCase.of(\n-                        client,\n-                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n-                dataSource);\n-\n-        return StateLogComponents.builder()\n-                .dataSource(dataSource)\n-                .learnerLog(learnerLog)\n-                .acceptorLog(acceptorLog)\n-                .build();\n-    }\n-\n-    private TimeLockPaxosHistoryProvider getHistoryProviderResource(DataSource dataSource) {\n-        return TimeLockPaxosHistoryProviderResource.jersey(\n-                LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource)));\n-    }\n-\n-    @Value.Immutable\n-    interface StateLogComponents {\n-        DataSource dataSource();\n-\n-        PaxosStateLog<PaxosValue> learnerLog();\n-\n-        PaxosStateLog<PaxosAcceptorState> acceptorLog();\n-\n-        static ImmutableStateLogComponents.Builder builder() {\n-            return ImmutableStateLogComponents.builder();\n-        }\n-    }\n-}\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\nnew file mode 100644\nindex 0000000000..9d1bcc96ae\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n", "chunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n+            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n+\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+\n+    protected StateLogComponents localStateLogComponents;\n+    protected List<StateLogComponents> remoteStateLogComponents;\n+    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        localStateLogComponents = createLogComponentsForServer(localDataSource);\n+        remoteStateLogComponents = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n+                localStateLogComponents.dataSource(),\n+                remoteStateLogComponents.stream()\n+                        .map(StateLogComponents::serverHistoryProvider)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    // utils\n+    protected Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n+        return createLogComponentsForServer(dataSource, NAMESPACE_AND_USE_CASE);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(\n+            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n+\n+        Client client = namespaceAndUseCase.namespace();\n+        String paxosUseCase = namespaceAndUseCase.useCase();\n+\n+        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        LocalHistoryLoader history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+        TimeLockPaxosHistoryProvider serverHistoryProvider = TimeLockPaxosHistoryProviderResource.jersey(history);\n+        return StateLogComponents.builder()\n+                .dataSource(dataSource)\n+                .learnerLog(learnerLog)\n+                .acceptorLog(acceptorLog)\n+                .history(history)\n+                .serverHistoryProvider(serverHistoryProvider)\n+                .build();\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(localStateLogComponents, corruptSeq);\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                ImmutableList.<StateLogComponents>builder()\n+                        .add(localStateLogComponents)\n+                        .addAll(remoteStateLogComponents)\n+                        .build(),\n+                startingLogSeq,\n+                latestLogSequence);\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(\n+            List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    protected SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    protected void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    protected void assertDetectedViolations(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    @Value.Immutable\n+    interface StateLogComponents {\n+        DataSource dataSource();\n+\n+        PaxosStateLog<PaxosValue> learnerLog();\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog();\n+\n+        LocalHistoryLoader history();\n+\n+        TimeLockPaxosHistoryProvider serverHistoryProvider();\n+\n+        static ImmutableStateLogComponents.Builder builder() {\n+            return ImmutableStateLogComponents.builder();\n+        }\n+    }\n+}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\nindex 9d1bcc96ae..140572593b 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java\n", "chunk": "@@ -184,10 +157,6 @@ public abstract class TimeLockCorruptionTestSetup {\n \n         PaxosStateLog<PaxosAcceptorState> acceptorLog();\n \n-        LocalHistoryLoader history();\n-\n-        TimeLockPaxosHistoryProvider serverHistoryProvider();\n-\n         static ImmutableStateLogComponents.Builder builder() {\n             return ImmutableStateLogComponents.builder();\n         }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE1OTM1Nw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515159357", "bodyText": "name - add 'inclusive'", "author": "sudiksha27", "createdAt": "2020-10-30T14:55:52Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\ndeleted file mode 100644\nindex 2239461aef..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,120 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Multimap;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.timelock.Constants;\n-import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n-import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n-import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import org.junit.rules.TestRule;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class TimeLockCorruptionDetectionHelper implements TestRule {\n-    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n-\n-    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n-        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n-    }\n-\n-    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n-    }\n-\n-    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n-    }\n-\n-    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n-    }\n-\n-    StateLogComponents getDefaultLocalServer() {\n-        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n-    }\n-\n-    List<StateLogComponents> getDefaultRemoteServerList() {\n-        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n-    }\n-\n-    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n-    }\n-\n-    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n-    }\n-\n-    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n-    }\n-\n-    void assertNoCorruptionViolations() {\n-        assertViolationsDetectedForNamespaceAndUseCases(ImmutableSet.of(), ImmutableSet.of());\n-    }\n-\n-    void assertAcceptedValueGreaterThanLearnedValue() {\n-        assertViolationsDetectedForNamespaceAndUseCases(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n-                ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    void assertViolationsDetected(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertViolationsDetectedForNamespaceAndUseCases(\n-                detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    void assertViolationsDetectedForNamespaceAndUseCases(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-\n-        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n-        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n-    }\n-\n-    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n-        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n-    }\n-\n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return timeLockCorruptionTestSetup.apply(base, description);\n-    }\n-}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nnew file mode 100644\nindex 0000000000..e3ae0e4bfe\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -0,0 +1,107 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.Rule;\n+import org.junit.rules.ExternalResource;\n+\n+public class TimeLockCorruptionDetectionHelper extends ExternalResource {\n+    @Rule\n+    public TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    @Override\n+    public void before() throws Throwable {\n+        timeLockCorruptionTestSetup.before();\n+    }\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n+        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n+    }\n+\n+    void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    }\n+\n+    void assertDetectedViolations(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+    }\n+}\n", "next_change": {"commit": "67dbd02bb499a4ea0649e81ba3640d65df882458", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex e3ae0e4bfe..5c7544ee63 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -104,4 +99,9 @@ public class TimeLockCorruptionDetectionHelper extends ExternalResource {\n             NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return timeLockCorruptionTestSetup.apply(base, description);\n+    }\n }\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 5c7544ee63..5a31ab2d76 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -33,71 +33,82 @@ import org.junit.rules.TestRule;\n import org.junit.runner.Description;\n import org.junit.runners.model.Statement;\n \n-public class TimeLockCorruptionDetectionHelper implements TestRule {\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n     private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n \n-    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n-        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int startInclusive, int endInclusive) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), startInclusive, endInclusive);\n     }\n \n-    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n     }\n \n-    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    private Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n     }\n \n-    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.wqqqq:riteAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n     }\n \n-    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n     }\n \n-    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n     }\n \n-    SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n     }\n \n     List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n         return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n     }\n \n-    void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertDetectedViolations(detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    void assertNoCorruptionViolations() {\n+        assertThat(getViolationsToNamespaceToUseCaseMultimap().isEmpty()).isTrue();\n     }\n \n-    List<StateLogComponents> getDefaultRemoteServerList() {\n-        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    void assertAcceptedValueGreaterThanLearnedValue() {\n+        assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n+                ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n     }\n \n-    StateLogComponents getDefaultLocalServer() {\n-        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    void assertViolationDetected(CorruptionCheckViolation expectedViolation) {\n+        assertViolationDetectedForNamespaceAndUseCases(\n+                expectedViolation, ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n     }\n \n-    void assertDetectedViolations(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+    void assertViolationDetectedForNamespaceAndUseCases(\n+            CorruptionCheckViolation expectedViolation,\n+            Set<NamespaceAndUseCase> expectedNamespaceAndUseCasesWithViolation) {\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n                 getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).isEqualTo(expectedViolation);\n         assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+                .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n \n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n             NamespaceAndUseCase namespaceAndUseCase) {\n-        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n     @Override\n", "next_change": {"commit": "21a1acd5e84c211f30877a7064485062039d0d3f", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 5a31ab2d76..68e2a36f8e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -106,8 +105,7 @@ public final class TimeLockCorruptionDetectionHelper implements TestRule {\n         return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n \n-    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n+    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n", "next_change": {"commit": "84cfdc115b2317a6c62c7dae6eb0f2cb35567be2", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 68e2a36f8e..efaf7fee3e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -101,16 +101,16 @@ public final class TimeLockCorruptionDetectionHelper implements TestRule {\n                 .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n     }\n \n-    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n     List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return timeLockCorruptionTestSetup.apply(base, description);\n+    private static void writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n+        PaxosSerializationTestUtils.writeToLogs(\n+                server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwMTcxNQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515901715", "bodyText": "It is only used in one place but I think this signature makes sense.", "author": "sudiksha27", "createdAt": "2020-11-02T11:13:50Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.TimelockCorruptionTestConstants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    void writeLogsOnDefaultLocalServer(int startInclusive, int endInclusive) {\n+        writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), startInclusive, endInclusive);", "originalCommit": "57c98a19528671d72189cb240ffd3fb9cd2e9de1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\ndeleted file mode 100644\nindex 68e2a36f8e..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,116 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Multimap;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.TimelockCorruptionTestConstants;\n-import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n-import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n-import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import org.junit.rules.TestRule;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class TimeLockCorruptionDetectionHelper implements TestRule {\n-    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n-\n-    void writeLogsOnDefaultLocalServer(int startInclusive, int endInclusive) {\n-        writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), startInclusive, endInclusive);\n-    }\n-\n-    void writeLogsOnDefaultLocalAndRemote(int startInclusive, int endInclusive) {\n-        writeLogsOnLocalAndRemote(timeLockCorruptionTestSetup.getDefaultServerList(), startInclusive, endInclusive);\n-    }\n-\n-    private void writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n-        PaxosSerializationTestUtils.writeToLogs(\n-                server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n-    }\n-\n-    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n-    }\n-\n-    StateLogComponents getDefaultLocalServer() {\n-        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n-    }\n-\n-    List<StateLogComponents> getDefaultRemoteServerList() {\n-        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n-    }\n-\n-    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n-    }\n-\n-    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n-    }\n-\n-    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n-    }\n-\n-    void assertNoCorruptionViolations() {\n-        assertThat(getViolationsToNamespaceToUseCaseMultimap().isEmpty()).isTrue();\n-    }\n-\n-    void assertAcceptedValueGreaterThanLearnedValue() {\n-        assertViolationDetectedForNamespaceAndUseCases(\n-                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n-                ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    void assertViolationDetected(CorruptionCheckViolation expectedViolation) {\n-        assertViolationDetectedForNamespaceAndUseCases(\n-                expectedViolation, ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    void assertViolationDetectedForNamespaceAndUseCases(\n-            CorruptionCheckViolation expectedViolation,\n-            Set<NamespaceAndUseCase> expectedNamespaceAndUseCasesWithViolation) {\n-        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).containsExactly(expectedViolation);\n-        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n-    }\n-\n-    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n-    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n-        return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n-    }\n-\n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return timeLockCorruptionTestSetup.apply(base, description);\n-    }\n-}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nnew file mode 100644\nindex 0000000000..e3ae0e4bfe\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -0,0 +1,107 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.Rule;\n+import org.junit.rules.ExternalResource;\n+\n+public class TimeLockCorruptionDetectionHelper extends ExternalResource {\n+    @Rule\n+    public TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    @Override\n+    public void before() throws Throwable {\n+        timeLockCorruptionTestSetup.before();\n+    }\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n+        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n+    }\n+\n+    void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    }\n+\n+    void assertDetectedViolations(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+    }\n+}\n", "next_change": {"commit": "67dbd02bb499a4ea0649e81ba3640d65df882458", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex e3ae0e4bfe..5c7544ee63 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -104,4 +99,9 @@ public class TimeLockCorruptionDetectionHelper extends ExternalResource {\n             NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return timeLockCorruptionTestSetup.apply(base, description);\n+    }\n }\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 5c7544ee63..5a31ab2d76 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -33,71 +33,82 @@ import org.junit.rules.TestRule;\n import org.junit.runner.Description;\n import org.junit.runners.model.Statement;\n \n-public class TimeLockCorruptionDetectionHelper implements TestRule {\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n     private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n \n-    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n-        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int startInclusive, int endInclusive) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), startInclusive, endInclusive);\n     }\n \n-    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n     }\n \n-    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    private Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n     }\n \n-    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.wqqqq:riteAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n     }\n \n-    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n     }\n \n-    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n     }\n \n-    SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n     }\n \n     List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n         return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n     }\n \n-    void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertDetectedViolations(detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    void assertNoCorruptionViolations() {\n+        assertThat(getViolationsToNamespaceToUseCaseMultimap().isEmpty()).isTrue();\n     }\n \n-    List<StateLogComponents> getDefaultRemoteServerList() {\n-        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    void assertAcceptedValueGreaterThanLearnedValue() {\n+        assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n+                ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n     }\n \n-    StateLogComponents getDefaultLocalServer() {\n-        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    void assertViolationDetected(CorruptionCheckViolation expectedViolation) {\n+        assertViolationDetectedForNamespaceAndUseCases(\n+                expectedViolation, ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n     }\n \n-    void assertDetectedViolations(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+    void assertViolationDetectedForNamespaceAndUseCases(\n+            CorruptionCheckViolation expectedViolation,\n+            Set<NamespaceAndUseCase> expectedNamespaceAndUseCasesWithViolation) {\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n                 getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).isEqualTo(expectedViolation);\n         assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+                .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n \n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n             NamespaceAndUseCase namespaceAndUseCase) {\n-        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n     @Override\n", "next_change": {"commit": "21a1acd5e84c211f30877a7064485062039d0d3f", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 5a31ab2d76..68e2a36f8e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -106,8 +105,7 @@ public final class TimeLockCorruptionDetectionHelper implements TestRule {\n         return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n \n-    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n+    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n", "next_change": {"commit": "84cfdc115b2317a6c62c7dae6eb0f2cb35567be2", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 68e2a36f8e..efaf7fee3e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -101,16 +101,16 @@ public final class TimeLockCorruptionDetectionHelper implements TestRule {\n                 .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n     }\n \n-    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n     List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return timeLockCorruptionTestSetup.apply(base, description);\n+    private static void writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n+        PaxosSerializationTestUtils.writeToLogs(\n+                server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNTUxMg==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515915512", "bodyText": "As far as I can tell, every test uses the params 1, 10. Perhaps you should mix this up a bit? Can these numbers be large (e.g. 10k)? Might help to catch any funny errors to have at least one test with large numbers - if that makes sense in prod.", "author": "Jolyon-S", "createdAt": "2020-11-02T11:41:21Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java", "diffHunk": "@@ -18,178 +18,72 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n-import com.google.common.collect.SetMultimap;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosAcceptorState;\n-import com.palantir.paxos.PaxosStateLog;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.paxos.SqliteConnections;\n-import com.palantir.paxos.SqlitePaxosStateLog;\n-import com.palantir.timelock.history.LocalHistoryLoader;\n-import com.palantir.timelock.history.PaxosLogHistoryProvider;\n-import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n-import com.palantir.timelock.history.models.AcceptorUseCase;\n import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n-import com.palantir.timelock.history.models.LearnerUseCase;\n-import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n-import java.io.IOException;\n import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import javax.sql.DataSource;\n-import org.immutables.value.Value;\n-import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.TemporaryFolder;\n \n-public class HistoryAnalyzerTest {\n+public final class HistoryAnalyzerTest {\n     @Rule\n-    public TemporaryFolder tempFolder = new TemporaryFolder();\n-\n-    private static final Client CLIENT = Client.of(\"client\");\n-    private static final String USE_CASE = \"useCase\";\n-    private static final String USE_CASE_LEARNER =\n-            LearnerUseCase.createLearnerUseCase(USE_CASE).value();\n-    private static final String USE_CASE_ACCEPTOR =\n-            AcceptorUseCase.createAcceptorUseCase(USE_CASE).value();\n-\n-    private StateLogComponents localStateLogComponents;\n-    private List<StateLogComponents> remoteStateLogComponents;\n-    PaxosLogHistoryProvider paxosLogHistoryProvider;\n-\n-    @Before\n-    public void setup() throws IOException {\n-        localStateLogComponents = createLogComponentsForServer(\"randomFile1\");\n-        remoteStateLogComponents = ImmutableList.of(\n-                createLogComponentsForServer(\"randomFile2\"), createLogComponentsForServer(\"randomFile3\"));\n-        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n-                localStateLogComponents.dataSource(),\n-                remoteStateLogComponents.stream()\n-                        .map(StateLogComponents::serverHistoryProvider)\n-                        .collect(Collectors.toList()));\n-    }\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void correctlyPassesIfThereIsNotCorruption() {\n-        writeLogsOnServer(localStateLogComponents, 1, 10);\n-        remoteStateLogComponents.forEach(server -> writeLogsOnServer(server, 1, 10));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 10);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n \n         assertThat(HistoryAnalyzer.corruptionCheckViolationLevelForNamespaceAndUseCase(\n                         Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n \n-        assertThat(HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n-                        .violatingStatusesToNamespaceAndUseCase()\n-                        .isEmpty())\n-                .isTrue();\n+        helper.assertNoCorruptionViolations();\n     }\n \n     @Test\n     public void detectCorruptionIfDifferentValuesAreLearnedInSameRound() {\n         PaxosSerializationTestUtils.writePaxosValue(\n-                localStateLogComponents.learnerLog(),\n+                helper.getDefaultLocalServer().learnerLog(),\n                 1,\n                 PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 1));\n-        remoteStateLogComponents.forEach(server -> PaxosSerializationTestUtils.writePaxosValue(\n-                server.learnerLog(), 1, PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 5)));\n-\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        helper.getDefaultRemoteServerList()\n+                .forEach(server -> PaxosSerializationTestUtils.writePaxosValue(\n+                        server.learnerLog(), 1, PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 5)));\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.DIVERGED_LEARNERS);\n \n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> setMultimap =\n-                HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n-                        .violatingStatusesToNamespaceAndUseCase();\n-        assertThat(setMultimap.keySet()).containsExactly(CorruptionCheckViolation.DIVERGED_LEARNERS);\n+        helper.assertViolationDetected(CorruptionCheckViolation.DIVERGED_LEARNERS);\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotAcceptedByQuorum() {\n-        writeLogsOnServer(localStateLogComponents, 1, 10);\n+        helper.writeLogsOnDefaultLocalServer(1, 10);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n         assertThat(HistoryAnalyzer.learnedValueWithoutQuorum(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n \n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> setMultimap =\n-                HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n-                        .violatingStatusesToNamespaceAndUseCase();\n-        assertThat(setMultimap.keySet()).containsExactly(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n+        helper.assertViolationDetected(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotTheGreatestAcceptedValue() {\n-        writeLogsOnServer(localStateLogComponents, 1, 5);\n-        remoteStateLogComponents.forEach(server -> writeLogsOnServer(server, 1, 5));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 10);", "originalCommit": "43c3a14899679cf2d29c838fad2a3dd01ca51529", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0MjU0OQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515942549", "bodyText": "First part is done. For the second part I can add a (stress?) test in CorruptionDetectionIntegrationTest.", "author": "sudiksha27", "createdAt": "2020-11-02T12:38:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNTUxMg=="}], "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex b36a092810..58a6ef6eca 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -19,64 +19,73 @@ package com.palantir.timelock.corruption.detection;\n import static org.assertj.core.api.Assertions.assertThat;\n \n import com.google.common.collect.Iterables;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n import java.util.List;\n-import org.junit.Rule;\n import org.junit.Test;\n \n-public final class HistoryAnalyzerTest {\n-    @Rule\n-    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+public class HistoryAnalyzerTest extends CorruptionDetectionEteSetup {\n \n     @Test\n     public void correctlyPassesIfThereIsNotCorruption() {\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 10);\n+        writeLogsOnServer(localStateLogComponents, 1, 10);\n+        remoteStateLogComponents.forEach(server -> writeLogsOnServer(server, 1, 10));\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n \n         assertThat(HistoryAnalyzer.corruptionCheckViolationLevelForNamespaceAndUseCase(\n                         Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n \n-        helper.assertNoCorruptionViolations();\n+        assertThat(HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n+                        .violatingStatusesToNamespaceAndUseCase()\n+                        .isEmpty())\n+                .isTrue();\n     }\n \n     @Test\n     public void detectCorruptionIfDifferentValuesAreLearnedInSameRound() {\n         PaxosSerializationTestUtils.writePaxosValue(\n-                helper.getDefaultLocalServer().learnerLog(),\n+                localStateLogComponents.learnerLog(),\n                 1,\n                 PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 1));\n-        helper.getDefaultRemoteServerList()\n-                .forEach(server -> PaxosSerializationTestUtils.writePaxosValue(\n-                        server.learnerLog(), 1, PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 5)));\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n+        remoteStateLogComponents.forEach(server -> PaxosSerializationTestUtils.writePaxosValue(\n+                server.learnerLog(), 1, PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 5)));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.DIVERGED_LEARNERS);\n \n-        helper.assertViolationDetected(CorruptionCheckViolation.DIVERGED_LEARNERS);\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> setMultimap =\n+                HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n+                        .violatingStatusesToNamespaceAndUseCase();\n+        assertThat(setMultimap.keySet()).containsExactly(CorruptionCheckViolation.DIVERGED_LEARNERS);\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotAcceptedByQuorum() {\n-        helper.writeLogsOnDefaultLocalServer(1, 10);\n+        writeLogsOnServer(localStateLogComponents, 1, 10);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n         assertThat(HistoryAnalyzer.learnedValueWithoutQuorum(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n \n-        helper.assertViolationDetected(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> setMultimap =\n+                HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n+                        .violatingStatusesToNamespaceAndUseCase();\n+        assertThat(setMultimap.keySet()).containsExactly(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotTheGreatestAcceptedValue() {\n-        helper.writeLogsOnDefaultLocalAndRemote(1, 10);\n-        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(5);\n+        induceGreaterAcceptedValueCorruption(1, 5, 5);\n+\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n         assertThat(HistoryAnalyzer.learnedValueWithoutQuorum(Iterables.getOnlyElement(historyForAll)))\n", "next_change": {"commit": "1367a6893b144b8531ef08442e73c1263d7cc176", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex 58a6ef6eca..5f5d925ea4 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -74,15 +67,13 @@ public class HistoryAnalyzerTest extends CorruptionDetectionEteSetup {\n         assertThat(HistoryAnalyzer.learnedValueWithoutQuorum(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n \n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> setMultimap =\n-                HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n-                        .violatingStatusesToNamespaceAndUseCase();\n-        assertThat(setMultimap.keySet()).containsExactly(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM));\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotTheGreatestAcceptedValue() {\n-        induceGreaterAcceptedValueCorruption(1, 5, 5);\n+        writeLogsOnLocalAndRemote(1, 10);\n+        induceGreaterAcceptedValueCorruption(localStateLogComponents, 5);\n \n \n         List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n", "next_change": {"commit": "e33480aede204f39ca097e96c3008dcfbcadcfc8", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex 5f5d925ea4..5cd187efd5 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -75,7 +75,6 @@ public class HistoryAnalyzerTest extends TimeLockCorruptionTestSetup {\n         writeLogsOnLocalAndRemote(1, 10);\n         induceGreaterAcceptedValueCorruption(localStateLogComponents, 5);\n \n-\n         List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex 5cd187efd5..b91862f1be 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -23,59 +23,64 @@ import com.google.common.collect.Iterables;\n import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n import java.util.List;\n+import org.junit.Rule;\n import org.junit.Test;\n \n-public class HistoryAnalyzerTest extends TimeLockCorruptionTestSetup {\n+public class HistoryAnalyzerTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper timeLockCorruptionDetectionHelper =\n+            new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void correctlyPassesIfThereIsNotCorruption() {\n-        writeLogsOnServer(localStateLogComponents, 1, 10);\n-        remoteStateLogComponents.forEach(server -> writeLogsOnServer(server, 1, 10));\n+        timeLockCorruptionDetectionHelper.writeLogsOnDefaultLocalAndRemote(1, 10);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = timeLockCorruptionDetectionHelper.getHistory();\n \n         assertThat(HistoryAnalyzer.corruptionCheckViolationLevelForNamespaceAndUseCase(\n                         Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n \n-        assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+        timeLockCorruptionDetectionHelper.assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n     }\n \n     @Test\n     public void detectCorruptionIfDifferentValuesAreLearnedInSameRound() {\n         PaxosSerializationTestUtils.writePaxosValue(\n-                localStateLogComponents.learnerLog(),\n+                timeLockCorruptionDetectionHelper.getDefaultLocalServer().learnerLog(),\n                 1,\n                 PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 1));\n-        remoteStateLogComponents.forEach(server -> PaxosSerializationTestUtils.writePaxosValue(\n-                server.learnerLog(), 1, PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 5)));\n-\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        timeLockCorruptionDetectionHelper.getDefaultRemoteServerList().stream()\n+                .forEach(server -> PaxosSerializationTestUtils.writePaxosValue(\n+                        server.learnerLog(), 1, PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 5)));\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = timeLockCorruptionDetectionHelper.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.DIVERGED_LEARNERS);\n \n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.DIVERGED_LEARNERS));\n+        timeLockCorruptionDetectionHelper.assertDetectedViolations(\n+                ImmutableSet.of(CorruptionCheckViolation.DIVERGED_LEARNERS));\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotAcceptedByQuorum() {\n-        writeLogsOnServer(localStateLogComponents, 1, 10);\n+        timeLockCorruptionDetectionHelper.writeLogsOnDefaultLocalServer(1, 10);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = timeLockCorruptionDetectionHelper.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n         assertThat(HistoryAnalyzer.learnedValueWithoutQuorum(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n \n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM));\n+        timeLockCorruptionDetectionHelper.assertDetectedViolations(\n+                ImmutableSet.of(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM));\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotTheGreatestAcceptedValue() {\n-        writeLogsOnLocalAndRemote(1, 10);\n-        induceGreaterAcceptedValueCorruption(localStateLogComponents, 5);\n+        timeLockCorruptionDetectionHelper.writeLogsOnDefaultLocalAndRemote(1, 10);\n+        timeLockCorruptionDetectionHelper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(5);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = timeLockCorruptionDetectionHelper.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n         assertThat(HistoryAnalyzer.learnedValueWithoutQuorum(Iterables.getOnlyElement(historyForAll)))\n", "next_change": {"commit": "439dbf8391f3c2a7291c7ad83ace39a0da432e80", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex b91862f1be..1e9ae62714 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -26,61 +26,58 @@ import java.util.List;\n import org.junit.Rule;\n import org.junit.Test;\n \n-public class HistoryAnalyzerTest {\n+public final class HistoryAnalyzerTest {\n     @Rule\n-    public TimeLockCorruptionDetectionHelper timeLockCorruptionDetectionHelper =\n-            new TimeLockCorruptionDetectionHelper();\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void correctlyPassesIfThereIsNotCorruption() {\n-        timeLockCorruptionDetectionHelper.writeLogsOnDefaultLocalAndRemote(1, 10);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 10);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = timeLockCorruptionDetectionHelper.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n \n         assertThat(HistoryAnalyzer.corruptionCheckViolationLevelForNamespaceAndUseCase(\n                         Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n \n-        timeLockCorruptionDetectionHelper.assertDetectedViolations(ImmutableSet.of(), ImmutableSet.of());\n+        helper.assertViolationsDetectedForNamespaceAndUsecases(ImmutableSet.of(), ImmutableSet.of());\n     }\n \n     @Test\n     public void detectCorruptionIfDifferentValuesAreLearnedInSameRound() {\n         PaxosSerializationTestUtils.writePaxosValue(\n-                timeLockCorruptionDetectionHelper.getDefaultLocalServer().learnerLog(),\n+                helper.getDefaultLocalServer().learnerLog(),\n                 1,\n                 PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 1));\n-        timeLockCorruptionDetectionHelper.getDefaultRemoteServerList().stream()\n+        helper.getDefaultRemoteServerList().stream()\n                 .forEach(server -> PaxosSerializationTestUtils.writePaxosValue(\n                         server.learnerLog(), 1, PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 5)));\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = timeLockCorruptionDetectionHelper.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.DIVERGED_LEARNERS);\n \n-        timeLockCorruptionDetectionHelper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.DIVERGED_LEARNERS));\n+        helper.assertViolationsDetected(ImmutableSet.of(CorruptionCheckViolation.DIVERGED_LEARNERS));\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotAcceptedByQuorum() {\n-        timeLockCorruptionDetectionHelper.writeLogsOnDefaultLocalServer(1, 10);\n+        helper.writeLogsOnDefaultLocalServer(1, 10);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = timeLockCorruptionDetectionHelper.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n         assertThat(HistoryAnalyzer.learnedValueWithoutQuorum(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n \n-        timeLockCorruptionDetectionHelper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM));\n+        helper.assertViolationsDetected(ImmutableSet.of(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM));\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotTheGreatestAcceptedValue() {\n-        timeLockCorruptionDetectionHelper.writeLogsOnDefaultLocalAndRemote(1, 10);\n-        timeLockCorruptionDetectionHelper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(5);\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 10);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(5);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = timeLockCorruptionDetectionHelper.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n         assertThat(HistoryAnalyzer.learnedValueWithoutQuorum(Iterables.getOnlyElement(historyForAll)))\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex 1e9ae62714..b36a092810 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -85,6 +84,6 @@ public final class HistoryAnalyzerTest {\n         assertThat(HistoryAnalyzer.greatestAcceptedValueNotLearned(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n \n-        helper.assertViolationsDetected(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertViolationDetected(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n     }\n }\n", "next_change": null}]}}, {"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex b91862f1be..1e9ae62714 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -88,7 +85,6 @@ public class HistoryAnalyzerTest {\n         assertThat(HistoryAnalyzer.greatestAcceptedValueNotLearned(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n \n-        timeLockCorruptionDetectionHelper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertViolationsDetected(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n }\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex 1e9ae62714..b36a092810 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -85,6 +84,6 @@ public final class HistoryAnalyzerTest {\n         assertThat(HistoryAnalyzer.greatestAcceptedValueNotLearned(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n \n-        helper.assertViolationsDetected(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertViolationDetected(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n     }\n }\n", "next_change": null}]}}]}}, {"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex 5cd187efd5..b91862f1be 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -83,6 +88,7 @@ public class HistoryAnalyzerTest extends TimeLockCorruptionTestSetup {\n         assertThat(HistoryAnalyzer.greatestAcceptedValueNotLearned(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n \n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        timeLockCorruptionDetectionHelper.assertDetectedViolations(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n }\n", "next_change": {"commit": "439dbf8391f3c2a7291c7ad83ace39a0da432e80", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex b91862f1be..1e9ae62714 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -88,7 +85,6 @@ public class HistoryAnalyzerTest {\n         assertThat(HistoryAnalyzer.greatestAcceptedValueNotLearned(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n \n-        timeLockCorruptionDetectionHelper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertViolationsDetected(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n }\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex 1e9ae62714..b36a092810 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -85,6 +84,6 @@ public final class HistoryAnalyzerTest {\n         assertThat(HistoryAnalyzer.greatestAcceptedValueNotLearned(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n \n-        helper.assertViolationsDetected(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertViolationDetected(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex 58a6ef6eca..5f5d925ea4 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -93,9 +84,6 @@ public class HistoryAnalyzerTest extends CorruptionDetectionEteSetup {\n         assertThat(HistoryAnalyzer.greatestAcceptedValueNotLearned(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n \n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> setMultimap =\n-                HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n-                        .violatingStatusesToNamespaceAndUseCase();\n-        assertThat(setMultimap.keySet()).containsExactly(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n }\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex 5f5d925ea4..b91862f1be 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -84,6 +88,7 @@ public class HistoryAnalyzerTest extends TimeLockCorruptionTestSetup {\n         assertThat(HistoryAnalyzer.greatestAcceptedValueNotLearned(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n \n-        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        timeLockCorruptionDetectionHelper.assertDetectedViolations(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n }\n", "next_change": {"commit": "439dbf8391f3c2a7291c7ad83ace39a0da432e80", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex b91862f1be..1e9ae62714 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -88,7 +85,6 @@ public class HistoryAnalyzerTest {\n         assertThat(HistoryAnalyzer.greatestAcceptedValueNotLearned(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n \n-        timeLockCorruptionDetectionHelper.assertDetectedViolations(\n-                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertViolationsDetected(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n     }\n }\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex 1e9ae62714..b36a092810 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n", "chunk": "@@ -85,6 +84,6 @@ public final class HistoryAnalyzerTest {\n         assertThat(HistoryAnalyzer.greatestAcceptedValueNotLearned(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n \n-        helper.assertViolationsDetected(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+        helper.assertViolationDetected(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED);\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNjA0MA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515916040", "bodyText": "nit: reorder the methods so that public is at the top, private at the bottom (and if it makes sense to group static methods, feel free to do that too).", "author": "Jolyon-S", "createdAt": "2020-11-02T11:42:19Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.TimelockCorruptionTestConstants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {", "originalCommit": "43c3a14899679cf2d29c838fad2a3dd01ca51529", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\ndeleted file mode 100644\nindex e97d15f43d..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,116 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.corruption.detection;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Multimap;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.TimelockCorruptionTestConstants;\n-import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n-import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n-import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import org.junit.rules.TestRule;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n-\n-public final class TimeLockCorruptionDetectionHelper implements TestRule {\n-    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n-\n-    void writeLogsOnDefaultLocalServer(int startInclusive, int endInclusive) {\n-        writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), startInclusive, endInclusive);\n-    }\n-\n-    void writeLogsOnDefaultLocalAndRemote(int startInclusive, int endInclusive) {\n-        writeLogsOnLocalAndRemote(timeLockCorruptionTestSetup.getDefaultServerList(), startInclusive, endInclusive);\n-    }\n-\n-    static void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n-    }\n-\n-    StateLogComponents getDefaultLocalServer() {\n-        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n-    }\n-\n-    List<StateLogComponents> getDefaultRemoteServerList() {\n-        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n-    }\n-\n-    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n-    }\n-\n-    static void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n-    }\n-\n-    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n-    }\n-\n-    void assertNoCorruptionViolations() {\n-        assertThat(getViolationsToNamespaceToUseCaseMultimap().isEmpty()).isTrue();\n-    }\n-\n-    void assertAcceptedValueGreaterThanLearnedValue() {\n-        assertViolationDetectedForNamespaceAndUseCases(\n-                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n-                ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    void assertViolationDetected(CorruptionCheckViolation expectedViolation) {\n-        assertViolationDetectedForNamespaceAndUseCases(\n-                expectedViolation, ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n-    }\n-\n-    void assertViolationDetectedForNamespaceAndUseCases(\n-            CorruptionCheckViolation expectedViolation,\n-            Set<NamespaceAndUseCase> expectedNamespaceAndUseCasesWithViolation) {\n-        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n-                getViolationsToNamespaceToUseCaseMultimap();\n-\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).containsExactly(expectedViolation);\n-        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n-    }\n-\n-    private static void writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n-        PaxosSerializationTestUtils.writeToLogs(\n-                server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n-    }\n-\n-    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n-    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n-        return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n-    }\n-\n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return timeLockCorruptionTestSetup.apply(base, description);\n-    }\n-}\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nnew file mode 100644\nindex 0000000000..e3ae0e4bfe\n--- /dev/null\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -0,0 +1,107 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.Rule;\n+import org.junit.rules.ExternalResource;\n+\n+public class TimeLockCorruptionDetectionHelper extends ExternalResource {\n+    @Rule\n+    public TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    @Override\n+    public void before() throws Throwable {\n+        timeLockCorruptionTestSetup.before();\n+    }\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n+        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n+    }\n+\n+    void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    }\n+\n+    void assertDetectedViolations(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+    }\n+}\n", "next_change": {"commit": "67dbd02bb499a4ea0649e81ba3640d65df882458", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex e3ae0e4bfe..5c7544ee63 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -104,4 +99,9 @@ public class TimeLockCorruptionDetectionHelper extends ExternalResource {\n             NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return timeLockCorruptionTestSetup.apply(base, description);\n+    }\n }\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 5c7544ee63..5a31ab2d76 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -33,71 +33,82 @@ import org.junit.rules.TestRule;\n import org.junit.runner.Description;\n import org.junit.runners.model.Statement;\n \n-public class TimeLockCorruptionDetectionHelper implements TestRule {\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n     private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n \n-    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n-        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int startInclusive, int endInclusive) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), startInclusive, endInclusive);\n     }\n \n-    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n-        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n     }\n \n-    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n-        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    private Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n     }\n \n-    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n-        PaxosSerializationTestUtils.wqqqq:riteAcceptorStateForLogAndRound(\n-                server.acceptorLog(),\n-                corruptSeq,\n-                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n     }\n \n-    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n-        writeLogsOnLocalAndRemote(\n-                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n     }\n \n-    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n-        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n     }\n \n-    SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n     }\n \n     List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n         return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n     }\n \n-    void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n-        assertDetectedViolations(detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    void assertNoCorruptionViolations() {\n+        assertThat(getViolationsToNamespaceToUseCaseMultimap().isEmpty()).isTrue();\n     }\n \n-    List<StateLogComponents> getDefaultRemoteServerList() {\n-        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    void assertAcceptedValueGreaterThanLearnedValue() {\n+        assertViolationDetectedForNamespaceAndUseCases(\n+                CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED,\n+                ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n     }\n \n-    StateLogComponents getDefaultLocalServer() {\n-        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    void assertViolationDetected(CorruptionCheckViolation expectedViolation) {\n+        assertViolationDetectedForNamespaceAndUseCases(\n+                expectedViolation, ImmutableSet.of(TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE));\n     }\n \n-    void assertDetectedViolations(\n-            Set<CorruptionCheckViolation> detectedViolations,\n-            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+    void assertViolationDetectedForNamespaceAndUseCases(\n+            CorruptionCheckViolation expectedViolation,\n+            Set<NamespaceAndUseCase> expectedNamespaceAndUseCasesWithViolation) {\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n                 getViolationsToNamespaceToUseCaseMultimap();\n-        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).isEqualTo(expectedViolation);\n         assertThat(violationsToNamespaceToUseCaseMultimap.values())\n-                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+                .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n \n-    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n             NamespaceAndUseCase namespaceAndUseCase) {\n-        return timeLockCorruptionTestSetup.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n     @Override\n", "next_change": {"commit": "21a1acd5e84c211f30877a7064485062039d0d3f", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 5a31ab2d76..68e2a36f8e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -106,8 +105,7 @@ public final class TimeLockCorruptionDetectionHelper implements TestRule {\n         return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n \n-    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase) {\n+    List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n", "next_change": {"commit": "84cfdc115b2317a6c62c7dae6eb0f2cb35567be2", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\nindex 68e2a36f8e..efaf7fee3e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java\n", "chunk": "@@ -101,16 +101,16 @@ public final class TimeLockCorruptionDetectionHelper implements TestRule {\n                 .hasSameElementsAs(expectedNamespaceAndUseCasesWithViolation);\n     }\n \n-    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n-        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n-    }\n-\n     List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n-    @Override\n-    public Statement apply(Statement base, Description description) {\n-        return timeLockCorruptionTestSetup.apply(base, description);\n+    private static void writeLogsOnServer(StateLogComponents server, int startInclusive, int endInclusive) {\n+        PaxosSerializationTestUtils.writeToLogs(\n+                server.acceptorLog(), server.learnerLog(), startInclusive, endInclusive);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(getHistory()).violatingStatusesToNamespaceAndUseCase();\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNjU4Mw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515916583", "bodyText": "nit: In other tests, you statically imported this. Either do the same here, or remove the static imports elsewhere.", "author": "Jolyon-S", "createdAt": "2020-11-02T11:43:25Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java", "diffHunk": "@@ -16,20 +16,16 @@\n \n package com.palantir.timelock.history.utils;\n \n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.TimelockCorruptionTestConstants;\n import com.palantir.timelock.history.HistoryQuery;\n import com.palantir.timelock.history.HistoryQuerySequenceBounds;\n \n public class HistoryQueries {\n-    public static final Client DEFAULT_CLIENT = Client.of(\"client\");\n-    public static final String DEFAULT_USE_CASE = \"useCase\";\n-    public static final NamespaceAndUseCase DEFAULT_NAMESPACE_AND_USE_CASE =\n-            ImmutableNamespaceAndUseCase.of(DEFAULT_CLIENT, DEFAULT_USE_CASE);\n \n     public static HistoryQuery unboundedHistoryQuerySinceSeq(long seqLowerBound) {\n-        return unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);\n+        return unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(\n+                TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);", "originalCommit": "43c3a14899679cf2d29c838fad2a3dd01ca51529", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "006d25f1dbdaedf262567163d35ae825be4be542", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java\nindex 76e43876b4..99fdbd6211 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java\n", "chunk": "@@ -16,16 +16,20 @@\n \n package com.palantir.timelock.history.utils;\n \n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.TimelockCorruptionTestConstants;\n import com.palantir.timelock.history.HistoryQuery;\n import com.palantir.timelock.history.HistoryQuerySequenceBounds;\n \n public class HistoryQueries {\n+    public static final Client DEFAULT_CLIENT = Client.of(\"client\");\n+    public static final String DEFAULT_USE_CASE = \"useCase\";\n+    public static final NamespaceAndUseCase DEFAULT_NAMESPACE_AND_USE_CASE =\n+            ImmutableNamespaceAndUseCase.of(DEFAULT_CLIENT, DEFAULT_USE_CASE);\n \n     public static HistoryQuery unboundedHistoryQuerySinceSeq(long seqLowerBound) {\n-        return unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(\n-                TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);\n+        return unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);\n     }\n \n     public static HistoryQuery unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(\n", "next_change": {"commit": "d6640eab25595c27a2a30597f371629342223768", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java\nindex 99fdbd6211..8ac02d8961 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java\n", "chunk": "@@ -16,20 +16,16 @@\n \n package com.palantir.timelock.history.utils;\n \n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.Constants;\n import com.palantir.timelock.history.HistoryQuery;\n import com.palantir.timelock.history.HistoryQuerySequenceBounds;\n \n public class HistoryQueries {\n-    public static final Client DEFAULT_CLIENT = Client.of(\"client\");\n-    public static final String DEFAULT_USE_CASE = \"useCase\";\n-    public static final NamespaceAndUseCase DEFAULT_NAMESPACE_AND_USE_CASE =\n-            ImmutableNamespaceAndUseCase.of(DEFAULT_CLIENT, DEFAULT_USE_CASE);\n \n     public static HistoryQuery unboundedHistoryQuerySinceSeq(long seqLowerBound) {\n-        return unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);\n+        return unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(\n+                Constants.DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);\n     }\n \n     public static HistoryQuery unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(\n", "next_change": {"commit": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java\nindex 8ac02d8961..76e43876b4 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java\n", "chunk": "@@ -25,7 +25,7 @@ public class HistoryQueries {\n \n     public static HistoryQuery unboundedHistoryQuerySinceSeq(long seqLowerBound) {\n         return unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(\n-                Constants.DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);\n+                TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);\n     }\n \n     public static HistoryQuery unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(\n", "next_change": {"commit": "84cfdc115b2317a6c62c7dae6eb0f2cb35567be2", "changed_code": [{"header": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java\nindex 76e43876b4..4e318ecbc2 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java\n", "chunk": "@@ -16,16 +16,16 @@\n \n package com.palantir.timelock.history.utils;\n \n+import static com.palantir.timelock.TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE;\n+\n import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.TimelockCorruptionTestConstants;\n import com.palantir.timelock.history.HistoryQuery;\n import com.palantir.timelock.history.HistoryQuerySequenceBounds;\n \n public class HistoryQueries {\n \n     public static HistoryQuery unboundedHistoryQuerySinceSeq(long seqLowerBound) {\n-        return unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(\n-                TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);\n+        return unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);\n     }\n \n     public static HistoryQuery unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(\n", "next_change": null}]}}]}}]}}]}}, {"oid": "006d25f1dbdaedf262567163d35ae825be4be542", "url": "https://github.com/palantir/atlasdb/commit/006d25f1dbdaedf262567163d35ae825be4be542", "message": "Basic tests", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "1367a6893b144b8531ef08442e73c1263d7cc176", "url": "https://github.com/palantir/atlasdb/commit/1367a6893b144b8531ef08442e73c1263d7cc176", "message": "Integration tests", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "0d91aab12ed0bbae121a1c61a4d7ce146eab0db8", "url": "https://github.com/palantir/atlasdb/commit/0d91aab12ed0bbae121a1c61a4d7ce146eab0db8", "message": "Minor | Modify java doc", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "e33480aede204f39ca097e96c3008dcfbcadcfc8", "url": "https://github.com/palantir/atlasdb/commit/e33480aede204f39ca097e96c3008dcfbcadcfc8", "message": "Fix build + spotless", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "d6640eab25595c27a2a30597f371629342223768", "url": "https://github.com/palantir/atlasdb/commit/d6640eab25595c27a2a30597f371629342223768", "message": "WIP", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "67dbd02bb499a4ea0649e81ba3640d65df882458", "url": "https://github.com/palantir/atlasdb/commit/67dbd02bb499a4ea0649e81ba3640d65df882458", "message": "Experimental", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "439dbf8391f3c2a7291c7ad83ace39a0da432e80", "url": "https://github.com/palantir/atlasdb/commit/439dbf8391f3c2a7291c7ad83ace39a0da432e80", "message": "Address comments", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "d883b794d2150a79989b76c4cda9bd9dbd2ecd65", "url": "https://github.com/palantir/atlasdb/commit/d883b794d2150a79989b76c4cda9bd9dbd2ecd65", "message": "Cleanup", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "url": "https://github.com/palantir/atlasdb/commit/3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "message": "Lets write clean code", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "21a1acd5e84c211f30877a7064485062039d0d3f", "url": "https://github.com/palantir/atlasdb/commit/21a1acd5e84c211f30877a7064485062039d0d3f", "message": "Fix access modifiers", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "bb339d2c6bc6d3c1d83f806f01c386e6ba7399dd", "url": "https://github.com/palantir/atlasdb/commit/bb339d2c6bc6d3c1d83f806f01c386e6ba7399dd", "message": "Do no push wrong changes", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "1765bdaa5ac4d040e297ec993e9ab6f795c74eae", "url": "https://github.com/palantir/atlasdb/commit/1765bdaa5ac4d040e297ec993e9ab6f795c74eae", "message": "Make util methods static", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "3a58088437769c0ee4ca1378f5b1da5274dbd96c", "url": "https://github.com/palantir/atlasdb/commit/3a58088437769c0ee4ca1378f5b1da5274dbd96c", "message": "Cleanup", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "84cfdc115b2317a6c62c7dae6eb0f2cb35567be2", "url": "https://github.com/palantir/atlasdb/commit/84cfdc115b2317a6c62c7dae6eb0f2cb35567be2", "message": "Address nits", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "677d85042c39a424a7317848bf90bd00152535ab", "url": "https://github.com/palantir/atlasdb/commit/677d85042c39a424a7317848bf90bd00152535ab", "message": "Stress test", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "677d85042c39a424a7317848bf90bd00152535ab", "url": "https://github.com/palantir/atlasdb/commit/677d85042c39a424a7317848bf90bd00152535ab", "message": "Stress test", "committedDate": "2020-11-03T12:31:54Z", "type": "forcePushed"}]}