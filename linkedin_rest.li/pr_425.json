{"pr_number": 425, "pr_title": "Add checkPegasusSchemaSnapshotTask", "pr_author": "nickibi", "pr_createdAt": "2020-09-24T03:43:29Z", "pr_url": "https://github.com/linkedin/rest.li/pull/425", "merge_commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "timeline": [{"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa", "url": "https://github.com/linkedin/rest.li/commit/849f5a16a92eb014628d6e9085f5293301e2a3aa", "message": "Add checkPegasusSchemaSnapshotTask", "committedDate": "2020-09-24T15:34:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MTcxOQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494751719", "body": "Is it worth to also add CompatibilityLevel.OFF and CompatibilityLevel.IGNORE?", "bodyText": "Is it worth to also add CompatibilityLevel.OFF and CompatibilityLevel.IGNORE?", "bodyHTML": "<p dir=\"auto\">Is it worth to also add CompatibilityLevel.OFF and CompatibilityLevel.IGNORE?</p>", "author": "BrianPin", "createdAt": "2020-09-25T05:14:58Z", "path": "restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityInfo;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestPegasusSchemaSnapshotCompatibilityChecker\n+{\n+  private final String FS = File.separator;\n+  private String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  private String snapshotDir = testDir + FS + \"pegasusSchemaSnapshot\";\n+\n+  @Test\n+  public void testCompatiblePegasusSchemaSnapshot()\n+  {\n+    PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"compatibleSchemaSnapshot/BirthInfo.pdl\",\n+        CompatibilityLevel.EQUIVALENT, CompatibilityOptions.Mode.DATA);", "originalCommit": "849f5a16a92eb014628d6e9085f5293301e2a3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM3MzQxMA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495373410", "bodyText": "OFF should not do the compatibility check\nAdd an assertion in incompatibleTest for IGNORE.", "author": "nickibi", "createdAt": "2020-09-26T01:49:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYzNjEyMg==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496636122", "bodyText": "here, CompatibilityLevel.OFF should also not parse the schemas. can we add assert on method calls?", "author": "aman1309", "createdAt": "2020-09-29T11:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgzOTU3MA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496839570", "bodyText": "based on the way we trigger the checkPegasuSchemaSnapshotTask, the PegasusSchemaSnapshotCompatibilityChecker will not even be triggered if CompatibilityLevel.OFF.\nWe could add some check in PegasusSchemaSnapshotCompatibilityChecker if CompatibilityLevel.OFF do nothing. But that's redundant check, since we do the check even before executing the task.\nTherefore adding CompatibilityLevel.OFF test in TestPegasusSchemaSnapshotCompatibilityChecker is not applicable.", "author": "nickibi", "createdAt": "2020-09-29T15:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MTcxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "65a379ceaed8dde2e093cc2997848e715b99c139", "changed_code": [{"header": "diff --git a/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java\nindex 2241fe72a..fb97f89e5 100644\n--- a/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -33,45 +34,34 @@ public class TestPegasusSchemaSnapshotCompatibilityChecker\n   private String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n   private String snapshotDir = testDir + FS + \"pegasusSchemaSnapshot\";\n \n-  @Test\n-  public void testCompatiblePegasusSchemaSnapshot()\n+  @Test(dataProvider = \"compatibleInputFiles\")\n+  public void testCompatiblePegasusSchemaSnapshot(String prevSchema, String currSchema)\n   {\n     PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"compatibleSchemaSnapshot/BirthInfo.pdl\",\n+    CompatibilityInfoMap infoMap = checker.checkPegasusSchemaCompatibility(snapshotDir + FS + prevSchema, snapshotDir + FS + currSchema,\n         CompatibilityLevel.EQUIVALENT, CompatibilityOptions.Mode.DATA);\n-    CompatibilityInfoMap infoMap = checker.getInfoMap();\n     Assert.assertTrue(infoMap.isModelCompatible(CompatibilityLevel.EQUIVALENT));\n   }\n \n-  @Test\n-  public void testIncompatiblePegasusSchemaSnapshot()\n+  @Test(dataProvider = \"incompatibleInputFiles\")\n+  public void testIncompatiblePegasusSchemaSnapshot(String prevSchema, String currSchema,\n+      Collection<CompatibilityInfo> expectedIncompatibilityErrors, Collection<CompatibilityInfo> expectedCompatibilityDiffs )\n   {\n-    final Collection<CompatibilityInfo> incompatibilityErrors = new HashSet<CompatibilityInfo>();\n-    final Collection<CompatibilityInfo> compatibilityDiffs = new HashSet<CompatibilityInfo>();\n-    incompatibilityErrors.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\"),\n-        CompatibilityInfo.Type.TYPE_BREAKS_NEW_READER, \"new record added required fields name\"));\n-    incompatibilityErrors.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\"),\n-        CompatibilityInfo.Type.TYPE_BREAKS_OLD_READER, \"new record removed required fields year\"));\n-    incompatibilityErrors.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\", \"day\", \"string\"),\n-        CompatibilityInfo.Type.TYPE_BREAKS_NEW_AND_OLD_READERS, \"schema type changed from int to string\"));\n-   compatibilityDiffs.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\", \"month\", \"long\"),\n-        CompatibilityInfo.Type.TYPE_INFO, \"numeric type promoted from int to long\"));\n-\n     PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"incompatibleSchemaSnapshot/BirthInfo.pdl\",\n+    CompatibilityInfoMap infoMap = checker.checkPegasusSchemaCompatibility(snapshotDir + FS + prevSchema, snapshotDir + FS + currSchema,\n         CompatibilityLevel.BACKWARDS, CompatibilityOptions.Mode.DATA);\n-    CompatibilityInfoMap infoMap = checker.getInfoMap();\n     Assert.assertFalse(infoMap.isModelCompatible(CompatibilityLevel.BACKWARDS));\n+    Assert.assertTrue(infoMap.isModelCompatible(CompatibilityLevel.IGNORE));\n \n     final Collection<CompatibilityInfo> modelIncompatibles = infoMap.getModelIncompatibles();\n     final Collection<CompatibilityInfo> modelCompatibles = infoMap.getModelCompatibles();\n \n-    for (CompatibilityInfo error : incompatibilityErrors)\n+    for (CompatibilityInfo error : expectedIncompatibilityErrors)\n     {\n       Assert.assertTrue(modelIncompatibles.contains(error), \"Reported model incompatibles should contain: \" + error.toString());\n       modelIncompatibles.remove(error);\n     }\n-    for (CompatibilityInfo diff : compatibilityDiffs)\n+    for (CompatibilityInfo diff : expectedCompatibilityDiffs)\n     {\n       Assert.assertTrue(modelCompatibles.contains(diff), \"Reported model compatibles should contain: \" + diff.toString());\n       modelCompatibles.remove(diff);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java\nindex 2241fe72a..151669934 100644\n--- a/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -33,45 +37,35 @@ public class TestPegasusSchemaSnapshotCompatibilityChecker\n   private String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n   private String snapshotDir = testDir + FS + \"pegasusSchemaSnapshot\";\n \n-  @Test\n-  public void testCompatiblePegasusSchemaSnapshot()\n+  @Test(dataProvider = \"compatibleInputFiles\")\n+  public void testCompatiblePegasusSchemaSnapshot(String prevSchema, String currSchema)\n   {\n     PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"compatibleSchemaSnapshot/BirthInfo.pdl\",\n-        CompatibilityLevel.EQUIVALENT, CompatibilityOptions.Mode.DATA);\n-    CompatibilityInfoMap infoMap = checker.getInfoMap();\n+    CompatibilityInfoMap infoMap = checker.checkPegasusSchemaCompatibility(snapshotDir + FS + prevSchema, snapshotDir + FS + currSchema,\n+        CompatibilityOptions.Mode.DATA);\n     Assert.assertTrue(infoMap.isModelCompatible(CompatibilityLevel.EQUIVALENT));\n   }\n \n-  @Test\n-  public void testIncompatiblePegasusSchemaSnapshot()\n+  @Test(dataProvider = \"incompatibleInputFiles\")\n+  public void testIncompatiblePegasusSchemaSnapshot(String prevSchema, String currSchema,\n+      Collection<CompatibilityInfo> expectedIncompatibilityErrors, Collection<CompatibilityInfo> expectedCompatibilityDiffs )\n   {\n-    final Collection<CompatibilityInfo> incompatibilityErrors = new HashSet<CompatibilityInfo>();\n-    final Collection<CompatibilityInfo> compatibilityDiffs = new HashSet<CompatibilityInfo>();\n-    incompatibilityErrors.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\"),\n-        CompatibilityInfo.Type.TYPE_BREAKS_NEW_READER, \"new record added required fields name\"));\n-    incompatibilityErrors.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\"),\n-        CompatibilityInfo.Type.TYPE_BREAKS_OLD_READER, \"new record removed required fields year\"));\n-    incompatibilityErrors.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\", \"day\", \"string\"),\n-        CompatibilityInfo.Type.TYPE_BREAKS_NEW_AND_OLD_READERS, \"schema type changed from int to string\"));\n-   compatibilityDiffs.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\", \"month\", \"long\"),\n-        CompatibilityInfo.Type.TYPE_INFO, \"numeric type promoted from int to long\"));\n-\n     PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"incompatibleSchemaSnapshot/BirthInfo.pdl\",\n-        CompatibilityLevel.BACKWARDS, CompatibilityOptions.Mode.DATA);\n-    CompatibilityInfoMap infoMap = checker.getInfoMap();\n+    CompatibilityInfoMap infoMap = checker.checkPegasusSchemaCompatibility(snapshotDir + FS + prevSchema, snapshotDir + FS + currSchema,\n+        CompatibilityOptions.Mode.DATA);\n     Assert.assertFalse(infoMap.isModelCompatible(CompatibilityLevel.BACKWARDS));\n+    Assert.assertFalse(infoMap.isModelCompatible(CompatibilityLevel.EQUIVALENT));\n+    Assert.assertTrue(infoMap.isModelCompatible(CompatibilityLevel.IGNORE));\n \n     final Collection<CompatibilityInfo> modelIncompatibles = infoMap.getModelIncompatibles();\n     final Collection<CompatibilityInfo> modelCompatibles = infoMap.getModelCompatibles();\n \n-    for (CompatibilityInfo error : incompatibilityErrors)\n+    for (CompatibilityInfo error : expectedIncompatibilityErrors)\n     {\n       Assert.assertTrue(modelIncompatibles.contains(error), \"Reported model incompatibles should contain: \" + error.toString());\n       modelIncompatibles.remove(error);\n     }\n-    for (CompatibilityInfo diff : compatibilityDiffs)\n+    for (CompatibilityInfo diff : expectedCompatibilityDiffs)\n     {\n       Assert.assertTrue(modelCompatibles.contains(diff), \"Reported model compatibles should contain: \" + diff.toString());\n       modelCompatibles.remove(diff);\n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "231162de5d9dda9bcf8c5f4de184674ea6cf639f", "committedDate": "2020-11-09 23:37:29 -0800", "message": "Adding required record field is allowed and should be considered as backward compatible change in extension schemas (#475)"}, {"oid": "b8fadffc4b9d7369ef0da31dd93fab4a527665db", "committedDate": "2021-06-24 15:32:28 -0700", "message": "Use the Java 7 diamond operator everywhere. (#643)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MjQ1OQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494752459", "body": "I think it might be better to abstract test input out from the test logic.\r\nOne example is the \"BirthInfo\" ", "bodyText": "I think it might be better to abstract test input out from the test logic.\nOne example is the \"BirthInfo\"", "bodyHTML": "<p dir=\"auto\">I think it might be better to abstract test input out from the test logic.<br>\nOne example is the \"BirthInfo\"</p>", "author": "BrianPin", "createdAt": "2020-09-25T05:17:58Z", "path": "restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityInfo;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestPegasusSchemaSnapshotCompatibilityChecker\n+{\n+  private final String FS = File.separator;\n+  private String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  private String snapshotDir = testDir + FS + \"pegasusSchemaSnapshot\";\n+\n+  @Test\n+  public void testCompatiblePegasusSchemaSnapshot()\n+  {\n+    PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"compatibleSchemaSnapshot/BirthInfo.pdl\",\n+        CompatibilityLevel.EQUIVALENT, CompatibilityOptions.Mode.DATA);\n+    CompatibilityInfoMap infoMap = checker.getInfoMap();\n+    Assert.assertTrue(infoMap.isModelCompatible(CompatibilityLevel.EQUIVALENT));\n+  }\n+\n+  @Test\n+  public void testIncompatiblePegasusSchemaSnapshot()", "originalCommit": "849f5a16a92eb014628d6e9085f5293301e2a3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM3MzIxNQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495373215", "bodyText": "Used DataProvider instead", "author": "nickibi", "createdAt": "2020-09-26T01:49:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MjQ1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "65a379ceaed8dde2e093cc2997848e715b99c139", "changed_code": [{"header": "diff --git a/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java\nindex 2241fe72a..fb97f89e5 100644\n--- a/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -33,45 +34,34 @@ public class TestPegasusSchemaSnapshotCompatibilityChecker\n   private String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n   private String snapshotDir = testDir + FS + \"pegasusSchemaSnapshot\";\n \n-  @Test\n-  public void testCompatiblePegasusSchemaSnapshot()\n+  @Test(dataProvider = \"compatibleInputFiles\")\n+  public void testCompatiblePegasusSchemaSnapshot(String prevSchema, String currSchema)\n   {\n     PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"compatibleSchemaSnapshot/BirthInfo.pdl\",\n+    CompatibilityInfoMap infoMap = checker.checkPegasusSchemaCompatibility(snapshotDir + FS + prevSchema, snapshotDir + FS + currSchema,\n         CompatibilityLevel.EQUIVALENT, CompatibilityOptions.Mode.DATA);\n-    CompatibilityInfoMap infoMap = checker.getInfoMap();\n     Assert.assertTrue(infoMap.isModelCompatible(CompatibilityLevel.EQUIVALENT));\n   }\n \n-  @Test\n-  public void testIncompatiblePegasusSchemaSnapshot()\n+  @Test(dataProvider = \"incompatibleInputFiles\")\n+  public void testIncompatiblePegasusSchemaSnapshot(String prevSchema, String currSchema,\n+      Collection<CompatibilityInfo> expectedIncompatibilityErrors, Collection<CompatibilityInfo> expectedCompatibilityDiffs )\n   {\n-    final Collection<CompatibilityInfo> incompatibilityErrors = new HashSet<CompatibilityInfo>();\n-    final Collection<CompatibilityInfo> compatibilityDiffs = new HashSet<CompatibilityInfo>();\n-    incompatibilityErrors.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\"),\n-        CompatibilityInfo.Type.TYPE_BREAKS_NEW_READER, \"new record added required fields name\"));\n-    incompatibilityErrors.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\"),\n-        CompatibilityInfo.Type.TYPE_BREAKS_OLD_READER, \"new record removed required fields year\"));\n-    incompatibilityErrors.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\", \"day\", \"string\"),\n-        CompatibilityInfo.Type.TYPE_BREAKS_NEW_AND_OLD_READERS, \"schema type changed from int to string\"));\n-   compatibilityDiffs.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\", \"month\", \"long\"),\n-        CompatibilityInfo.Type.TYPE_INFO, \"numeric type promoted from int to long\"));\n-\n     PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"incompatibleSchemaSnapshot/BirthInfo.pdl\",\n+    CompatibilityInfoMap infoMap = checker.checkPegasusSchemaCompatibility(snapshotDir + FS + prevSchema, snapshotDir + FS + currSchema,\n         CompatibilityLevel.BACKWARDS, CompatibilityOptions.Mode.DATA);\n-    CompatibilityInfoMap infoMap = checker.getInfoMap();\n     Assert.assertFalse(infoMap.isModelCompatible(CompatibilityLevel.BACKWARDS));\n+    Assert.assertTrue(infoMap.isModelCompatible(CompatibilityLevel.IGNORE));\n \n     final Collection<CompatibilityInfo> modelIncompatibles = infoMap.getModelIncompatibles();\n     final Collection<CompatibilityInfo> modelCompatibles = infoMap.getModelCompatibles();\n \n-    for (CompatibilityInfo error : incompatibilityErrors)\n+    for (CompatibilityInfo error : expectedIncompatibilityErrors)\n     {\n       Assert.assertTrue(modelIncompatibles.contains(error), \"Reported model incompatibles should contain: \" + error.toString());\n       modelIncompatibles.remove(error);\n     }\n-    for (CompatibilityInfo diff : compatibilityDiffs)\n+    for (CompatibilityInfo diff : expectedCompatibilityDiffs)\n     {\n       Assert.assertTrue(modelCompatibles.contains(diff), \"Reported model compatibles should contain: \" + diff.toString());\n       modelCompatibles.remove(diff);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java\nindex 2241fe72a..151669934 100644\n--- a/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -33,45 +37,35 @@ public class TestPegasusSchemaSnapshotCompatibilityChecker\n   private String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n   private String snapshotDir = testDir + FS + \"pegasusSchemaSnapshot\";\n \n-  @Test\n-  public void testCompatiblePegasusSchemaSnapshot()\n+  @Test(dataProvider = \"compatibleInputFiles\")\n+  public void testCompatiblePegasusSchemaSnapshot(String prevSchema, String currSchema)\n   {\n     PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"compatibleSchemaSnapshot/BirthInfo.pdl\",\n-        CompatibilityLevel.EQUIVALENT, CompatibilityOptions.Mode.DATA);\n-    CompatibilityInfoMap infoMap = checker.getInfoMap();\n+    CompatibilityInfoMap infoMap = checker.checkPegasusSchemaCompatibility(snapshotDir + FS + prevSchema, snapshotDir + FS + currSchema,\n+        CompatibilityOptions.Mode.DATA);\n     Assert.assertTrue(infoMap.isModelCompatible(CompatibilityLevel.EQUIVALENT));\n   }\n \n-  @Test\n-  public void testIncompatiblePegasusSchemaSnapshot()\n+  @Test(dataProvider = \"incompatibleInputFiles\")\n+  public void testIncompatiblePegasusSchemaSnapshot(String prevSchema, String currSchema,\n+      Collection<CompatibilityInfo> expectedIncompatibilityErrors, Collection<CompatibilityInfo> expectedCompatibilityDiffs )\n   {\n-    final Collection<CompatibilityInfo> incompatibilityErrors = new HashSet<CompatibilityInfo>();\n-    final Collection<CompatibilityInfo> compatibilityDiffs = new HashSet<CompatibilityInfo>();\n-    incompatibilityErrors.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\"),\n-        CompatibilityInfo.Type.TYPE_BREAKS_NEW_READER, \"new record added required fields name\"));\n-    incompatibilityErrors.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\"),\n-        CompatibilityInfo.Type.TYPE_BREAKS_OLD_READER, \"new record removed required fields year\"));\n-    incompatibilityErrors.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\", \"day\", \"string\"),\n-        CompatibilityInfo.Type.TYPE_BREAKS_NEW_AND_OLD_READERS, \"schema type changed from int to string\"));\n-   compatibilityDiffs.add(new CompatibilityInfo(Arrays.<Object>asList(\"BirthInfo\", \"month\", \"long\"),\n-        CompatibilityInfo.Type.TYPE_INFO, \"numeric type promoted from int to long\"));\n-\n     PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"incompatibleSchemaSnapshot/BirthInfo.pdl\",\n-        CompatibilityLevel.BACKWARDS, CompatibilityOptions.Mode.DATA);\n-    CompatibilityInfoMap infoMap = checker.getInfoMap();\n+    CompatibilityInfoMap infoMap = checker.checkPegasusSchemaCompatibility(snapshotDir + FS + prevSchema, snapshotDir + FS + currSchema,\n+        CompatibilityOptions.Mode.DATA);\n     Assert.assertFalse(infoMap.isModelCompatible(CompatibilityLevel.BACKWARDS));\n+    Assert.assertFalse(infoMap.isModelCompatible(CompatibilityLevel.EQUIVALENT));\n+    Assert.assertTrue(infoMap.isModelCompatible(CompatibilityLevel.IGNORE));\n \n     final Collection<CompatibilityInfo> modelIncompatibles = infoMap.getModelIncompatibles();\n     final Collection<CompatibilityInfo> modelCompatibles = infoMap.getModelCompatibles();\n \n-    for (CompatibilityInfo error : incompatibilityErrors)\n+    for (CompatibilityInfo error : expectedIncompatibilityErrors)\n     {\n       Assert.assertTrue(modelIncompatibles.contains(error), \"Reported model incompatibles should contain: \" + error.toString());\n       modelIncompatibles.remove(error);\n     }\n-    for (CompatibilityInfo diff : compatibilityDiffs)\n+    for (CompatibilityInfo diff : expectedCompatibilityDiffs)\n     {\n       Assert.assertTrue(modelCompatibles.contains(diff), \"Reported model compatibles should contain: \" + diff.toString());\n       modelCompatibles.remove(diff);\n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "231162de5d9dda9bcf8c5f4de184674ea6cf639f", "committedDate": "2020-11-09 23:37:29 -0800", "message": "Adding required record field is allowed and should be considered as backward compatible change in extension schemas (#475)"}, {"oid": "b8fadffc4b9d7369ef0da31dd93fab4a527665db", "committedDate": "2021-06-24 15:32:28 -0700", "message": "Use the Java 7 diamond operator everywhere. (#643)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MzQxOA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494753418", "body": "How about just `final String compatableLevel`", "bodyText": "How about just final String compatableLevel", "bodyHTML": "<p dir=\"auto\">How about just <code>final String compatableLevel</code></p>", "author": "BrianPin", "createdAt": "2020-09-25T05:21:24Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    final String compatLevelValue;", "originalCommit": "849f5a16a92eb014628d6e9085f5293301e2a3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM3MzE0Nw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495373147", "bodyText": "Fixed", "author": "nickibi", "createdAt": "2020-09-26T01:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MzQxOA=="}], "type": "inlineReview", "revised_code": {"commit": "65a379ceaed8dde2e093cc2997848e715b99c139", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 748eda81a..e46aa58a9 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -96,49 +99,43 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n       System.exit(1);\n     }\n \n-    final String compatLevelValue;\n+    CompatibilityLevel compatLevel = null;\n     if (cl.hasOption(\"cl\"))\n     {\n-      compatLevelValue = cl.getOptionValue(\"cl\");\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n     }\n     else\n     {\n-      compatLevelValue = CompatibilityLevel.DEFAULT.name();\n+      compatLevel = CompatibilityLevel.DEFAULT;\n     }\n \n-    CompatibilityLevel compatLevel = null;\n-    try\n-    {\n-      compatLevel = CompatibilityLevel.valueOf(compatLevelValue.toUpperCase());\n-    }\n-    catch (IllegalArgumentException e)\n-    {\n-      _logger.error(\"Invalid compatibilityLevel\");\n-      help();\n-      System.exit(1);\n-    }\n-\n-    String compatModeValue;\n+    CompatibilityOptions.Mode compatMode = null;\n     if (cl.hasOption(\"cm\"))\n     {\n-      compatModeValue = cl.getOptionValue(\"cm\");\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n     }\n     else\n     {\n-      compatModeValue = CompatibilityOptions.Mode.SCHEMA.name();\n-    }\n-    CompatibilityOptions.Mode compatMode = null;\n-    try\n-    {\n-      compatMode = CompatibilityOptions.Mode.valueOf(compatModeValue.toUpperCase());\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n     }\n-    catch (IllegalArgumentException e)\n-    {\n-      _logger.error(\"Invalid compatibilityOption Mode\");\n-      help();\n-      System.exit(1);\n-    }\n-\n \n     try\n     {\n", "next_change": {"commit": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex e46aa58a9..62ac2ed38 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -137,34 +150,19 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n       compatMode = CompatibilityOptions.Mode.SCHEMA;\n     }\n \n-    try\n-    {\n-      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n-    }\n-    catch (IOException e)\n-    {\n-      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n-      System.exit(1);\n-    }\n-\n     PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    for (int i = 1; i < cliArgs.length; i += 2)\n+    for (int i = 1; i < prevSnapshotAndCurrSnapshotPairs.size(); i += 2)\n     {\n-      String prevSnapshot = cliArgs[i-1];\n-      String currentSnapshot = cliArgs[i];\n+      String prevSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i-1);\n+      String currentSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i);\n       compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n     }\n \n-    String summary = compatibilityChecker._infoMap.createSummary();\n-\n-    if (summary.length() > 0)\n-    {\n-      _logger.info(summary);\n-    }\n-\n     if (cl.hasOption(\"report\"))\n     {\n-      _logger.info(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      File reportFile = new File(cl.getOptionValue(\"report\"));\n+      String compatibilityReport = new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport();\n+      Files.write(reportFile.toPath(), compatibilityReport.getBytes(StandardCharsets.UTF_8));\n       System.exit(0);\n     }\n \n", "next_change": {"commit": "02a5f62be184d2095e9036247e3532f365edeb34", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 62ac2ed38..8e641866d 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -166,7 +166,7 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n       System.exit(0);\n     }\n \n-    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+    System.exit(compatibilityChecker._infoMap.isModelCompatible(compatLevel) ? 0 : 1);\n   }\n \n   /**\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 748eda81a..5964f3464 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -89,137 +103,123 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n \n     String[] cliArgs = cl.getArgs();\n \n-    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    if (cliArgs.length != 2)\n     {\n-      _logger.error(\"Invalid arguments\");\n+      _logger.error(\"Invalid arguments!\");\n       help();\n       System.exit(1);\n     }\n \n-    final String compatLevelValue;\n-    if (cl.hasOption(\"cl\"))\n-    {\n-      compatLevelValue = cl.getOptionValue(\"cl\");\n-    }\n-    else\n-    {\n-      compatLevelValue = CompatibilityLevel.DEFAULT.name();\n-    }\n+    String prevSnapshotDir = cliArgs[0];\n+    String currSnapshotDir = cliArgs[1];\n+\n+    List<String> prevSnapshotAndCurrSnapshotPairs = getMatchingPrevAndCurrSnapshotPairs(prevSnapshotDir, currSnapshotDir);\n \n     CompatibilityLevel compatLevel = null;\n-    try\n+    if (cl.hasOption(\"cl\"))\n     {\n-      compatLevel = CompatibilityLevel.valueOf(compatLevelValue.toUpperCase());\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel: \" + cl.getOptionValue(\"cl\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n     }\n-    catch (IllegalArgumentException e)\n+    else\n     {\n-      _logger.error(\"Invalid compatibilityLevel\");\n-      help();\n-      System.exit(1);\n+      compatLevel = CompatibilityLevel.DEFAULT;\n     }\n \n-    String compatModeValue;\n+    CompatibilityOptions.Mode compatMode = null;\n     if (cl.hasOption(\"cm\"))\n     {\n-      compatModeValue = cl.getOptionValue(\"cm\");\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode: \" + cl.getOptionValue(\"cm\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n     }\n     else\n     {\n-      compatModeValue = CompatibilityOptions.Mode.SCHEMA.name();\n-    }\n-    CompatibilityOptions.Mode compatMode = null;\n-    try\n-    {\n-      compatMode = CompatibilityOptions.Mode.valueOf(compatModeValue.toUpperCase());\n-    }\n-    catch (IllegalArgumentException e)\n-    {\n-      _logger.error(\"Invalid compatibilityOption Mode\");\n-      help();\n-      System.exit(1);\n-    }\n-\n-\n-    try\n-    {\n-      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n-    }\n-    catch (IOException e)\n-    {\n-      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n-      System.exit(1);\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n     }\n \n     PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    for (int i = 1; i < cliArgs.length; i += 2)\n+    for (int i = 1; i < prevSnapshotAndCurrSnapshotPairs.size(); i += 2)\n     {\n-      String prevSnapshot = cliArgs[i-1];\n-      String currentSnapshot = cliArgs[i];\n-      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n-    }\n-\n-    String summary = compatibilityChecker.getInfoMap().createSummary();\n-\n-    if (compatLevel != CompatibilityLevel.OFF && summary.length() > 0)\n-    {\n-      _logger.info(summary);\n+      String prevSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i-1);\n+      String currentSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i);\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatMode);\n     }\n \n     if (cl.hasOption(\"report\"))\n     {\n-      _logger.info(new CompatibilityReport(compatibilityChecker.getInfoMap(), compatLevel).createReport());\n+      File reportFile = new File(cl.getOptionValue(\"report\"));\n+      String compatibilityReport = new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport();\n+      Files.write(reportFile.toPath(), compatibilityReport.getBytes(StandardCharsets.UTF_8));\n       System.exit(0);\n     }\n \n-    System.exit(compatibilityChecker.getInfoMap().isCompatible(compatLevel) ? 0 : 1);\n-  }\n-\n-  public CompatibilityInfoMap getInfoMap()\n-  {\n-    return _infoMap;\n+    System.exit(compatibilityChecker._infoMap.isModelCompatible(compatLevel) ? 0 : 1);\n   }\n \n   /**\n    * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n    *\n-   * @param prevPegasusSchemaPath previously existing idl file\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n    * @param currentPegasusSchemaPath current snapshot file\n-   * @param compatibilityLevel compatibility level\n    * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n    */\n-  public void checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n-      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityOptions.Mode compatMode)\n   {\n-    _infoMap.isCompatible(compatibilityLevel);\n-\n-    File preSchemaFile = new File(prevPegasusSchemaPath);\n-    File currSchemaFile = new File(currentPegasusSchemaPath);\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n \n     DataSchema preSchema = null;\n     try\n     {\n-      preSchema = parseSchema(preSchemaFile);\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n-          \"New schema %s is created.\", currentPegasusSchemaPath);\n+      newSchemaCreated = true;\n     }\n \n     DataSchema currSchema = null;\n     try\n     {\n-      currSchema = parseSchema(currSchemaFile);\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n           \"Schema %s is removed.\", prevPegasusSchemaPath);\n     }\n \n     if (preSchema == null || currSchema == null)\n     {\n-      return;\n+      return _infoMap;\n     }\n \n     CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}, {"oid": "d13138ec6ae83fb805cc599ff396a33fa28cb031", "committedDate": "2020-10-19 20:07:58 -0700", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check (#445)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NDI1NA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494754254", "body": "Would it be cleaner if the action `checkPegasusSchemaCompatibility` return the `InfoMap` directly?\r\nI mean : not use the check to have another call to get the info.\r\n\r\nThe reason being, if we not return info map directly, they are sort of internal state in the checker, that means you will need to get the info map before you can use the check to check again. \r\n", "bodyText": "Would it be cleaner if the action checkPegasusSchemaCompatibility return the InfoMap directly?\nI mean : not use the check to have another call to get the info.\nThe reason being, if we not return info map directly, they are sort of internal state in the checker, that means you will need to get the info map before you can use the check to check again.", "bodyHTML": "<p dir=\"auto\">Would it be cleaner if the action <code>checkPegasusSchemaCompatibility</code> return the <code>InfoMap</code> directly?<br>\nI mean : not use the check to have another call to get the info.</p>\n<p dir=\"auto\">The reason being, if we not return info map directly, they are sort of internal state in the checker, that means you will need to get the info map before you can use the check to check again.</p>", "author": "BrianPin", "createdAt": "2020-09-25T05:24:38Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    final String compatLevelValue;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      compatLevelValue = cl.getOptionValue(\"cl\");\n+    }\n+    else\n+    {\n+      compatLevelValue = CompatibilityLevel.DEFAULT.name();\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    try\n+    {\n+      compatLevel = CompatibilityLevel.valueOf(compatLevelValue.toUpperCase());\n+    }\n+    catch (IllegalArgumentException e)\n+    {\n+      _logger.error(\"Invalid compatibilityLevel\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String compatModeValue;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      compatModeValue = cl.getOptionValue(\"cm\");\n+    }\n+    else\n+    {\n+      compatModeValue = CompatibilityOptions.Mode.SCHEMA.name();\n+    }\n+    CompatibilityOptions.Mode compatMode = null;\n+    try\n+    {\n+      compatMode = CompatibilityOptions.Mode.valueOf(compatModeValue.toUpperCase());\n+    }\n+    catch (IllegalArgumentException e)\n+    {\n+      _logger.error(\"Invalid compatibilityOption Mode\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);", "originalCommit": "849f5a16a92eb014628d6e9085f5293301e2a3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM3MzExNQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495373115", "bodyText": "Updated based on the suggestion", "author": "nickibi", "createdAt": "2020-09-26T01:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NDI1NA=="}], "type": "inlineReview", "revised_code": {"commit": "65a379ceaed8dde2e093cc2997848e715b99c139", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 748eda81a..e46aa58a9 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -158,36 +155,32 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n       compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n     }\n \n-    String summary = compatibilityChecker.getInfoMap().createSummary();\n+    String summary = compatibilityChecker._infoMap.createSummary();\n \n-    if (compatLevel != CompatibilityLevel.OFF && summary.length() > 0)\n+    if (summary.length() > 0)\n     {\n       _logger.info(summary);\n     }\n \n     if (cl.hasOption(\"report\"))\n     {\n-      _logger.info(new CompatibilityReport(compatibilityChecker.getInfoMap(), compatLevel).createReport());\n+      _logger.info(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n       System.exit(0);\n     }\n \n-    System.exit(compatibilityChecker.getInfoMap().isCompatible(compatLevel) ? 0 : 1);\n-  }\n-\n-  public CompatibilityInfoMap getInfoMap()\n-  {\n-    return _infoMap;\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n   }\n \n   /**\n    * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n    *\n-   * @param prevPegasusSchemaPath previously existing idl file\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n    * @param currentPegasusSchemaPath current snapshot file\n    * @param compatibilityLevel compatibility level\n    * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n    */\n-  public void checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n       CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n   {\n     _infoMap.isCompatible(compatibilityLevel);\n", "next_change": {"commit": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex e46aa58a9..62ac2ed38 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -185,28 +183,37 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n   {\n     _infoMap.isCompatible(compatibilityLevel);\n \n-    File preSchemaFile = new File(prevPegasusSchemaPath);\n-    File currSchemaFile = new File(currentPegasusSchemaPath);\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n \n     DataSchema preSchema = null;\n     try\n     {\n-      preSchema = parseSchema(preSchemaFile);\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n-          \"New schema %s is created.\", currentPegasusSchemaPath);\n+      newSchemaCreated = true;\n     }\n \n     DataSchema currSchema = null;\n     try\n     {\n-      currSchema = parseSchema(currSchemaFile);\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n           \"Schema %s is removed.\", prevPegasusSchemaPath);\n     }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 748eda81a..5964f3464 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -89,137 +103,123 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n \n     String[] cliArgs = cl.getArgs();\n \n-    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    if (cliArgs.length != 2)\n     {\n-      _logger.error(\"Invalid arguments\");\n+      _logger.error(\"Invalid arguments!\");\n       help();\n       System.exit(1);\n     }\n \n-    final String compatLevelValue;\n-    if (cl.hasOption(\"cl\"))\n-    {\n-      compatLevelValue = cl.getOptionValue(\"cl\");\n-    }\n-    else\n-    {\n-      compatLevelValue = CompatibilityLevel.DEFAULT.name();\n-    }\n+    String prevSnapshotDir = cliArgs[0];\n+    String currSnapshotDir = cliArgs[1];\n+\n+    List<String> prevSnapshotAndCurrSnapshotPairs = getMatchingPrevAndCurrSnapshotPairs(prevSnapshotDir, currSnapshotDir);\n \n     CompatibilityLevel compatLevel = null;\n-    try\n+    if (cl.hasOption(\"cl\"))\n     {\n-      compatLevel = CompatibilityLevel.valueOf(compatLevelValue.toUpperCase());\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel: \" + cl.getOptionValue(\"cl\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n     }\n-    catch (IllegalArgumentException e)\n+    else\n     {\n-      _logger.error(\"Invalid compatibilityLevel\");\n-      help();\n-      System.exit(1);\n+      compatLevel = CompatibilityLevel.DEFAULT;\n     }\n \n-    String compatModeValue;\n+    CompatibilityOptions.Mode compatMode = null;\n     if (cl.hasOption(\"cm\"))\n     {\n-      compatModeValue = cl.getOptionValue(\"cm\");\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode: \" + cl.getOptionValue(\"cm\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n     }\n     else\n     {\n-      compatModeValue = CompatibilityOptions.Mode.SCHEMA.name();\n-    }\n-    CompatibilityOptions.Mode compatMode = null;\n-    try\n-    {\n-      compatMode = CompatibilityOptions.Mode.valueOf(compatModeValue.toUpperCase());\n-    }\n-    catch (IllegalArgumentException e)\n-    {\n-      _logger.error(\"Invalid compatibilityOption Mode\");\n-      help();\n-      System.exit(1);\n-    }\n-\n-\n-    try\n-    {\n-      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n-    }\n-    catch (IOException e)\n-    {\n-      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n-      System.exit(1);\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n     }\n \n     PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    for (int i = 1; i < cliArgs.length; i += 2)\n+    for (int i = 1; i < prevSnapshotAndCurrSnapshotPairs.size(); i += 2)\n     {\n-      String prevSnapshot = cliArgs[i-1];\n-      String currentSnapshot = cliArgs[i];\n-      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n-    }\n-\n-    String summary = compatibilityChecker.getInfoMap().createSummary();\n-\n-    if (compatLevel != CompatibilityLevel.OFF && summary.length() > 0)\n-    {\n-      _logger.info(summary);\n+      String prevSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i-1);\n+      String currentSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i);\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatMode);\n     }\n \n     if (cl.hasOption(\"report\"))\n     {\n-      _logger.info(new CompatibilityReport(compatibilityChecker.getInfoMap(), compatLevel).createReport());\n+      File reportFile = new File(cl.getOptionValue(\"report\"));\n+      String compatibilityReport = new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport();\n+      Files.write(reportFile.toPath(), compatibilityReport.getBytes(StandardCharsets.UTF_8));\n       System.exit(0);\n     }\n \n-    System.exit(compatibilityChecker.getInfoMap().isCompatible(compatLevel) ? 0 : 1);\n-  }\n-\n-  public CompatibilityInfoMap getInfoMap()\n-  {\n-    return _infoMap;\n+    System.exit(compatibilityChecker._infoMap.isModelCompatible(compatLevel) ? 0 : 1);\n   }\n \n   /**\n    * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n    *\n-   * @param prevPegasusSchemaPath previously existing idl file\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n    * @param currentPegasusSchemaPath current snapshot file\n-   * @param compatibilityLevel compatibility level\n    * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n    */\n-  public void checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n-      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityOptions.Mode compatMode)\n   {\n-    _infoMap.isCompatible(compatibilityLevel);\n-\n-    File preSchemaFile = new File(prevPegasusSchemaPath);\n-    File currSchemaFile = new File(currentPegasusSchemaPath);\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n \n     DataSchema preSchema = null;\n     try\n     {\n-      preSchema = parseSchema(preSchemaFile);\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n-          \"New schema %s is created.\", currentPegasusSchemaPath);\n+      newSchemaCreated = true;\n     }\n \n     DataSchema currSchema = null;\n     try\n     {\n-      currSchema = parseSchema(currSchemaFile);\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n           \"Schema %s is removed.\", prevPegasusSchemaPath);\n     }\n \n     if (preSchema == null || currSchema == null)\n     {\n-      return;\n+      return _infoMap;\n     }\n \n     CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}, {"oid": "d13138ec6ae83fb805cc599ff396a33fa28cb031", "committedDate": "2020-10-19 20:07:58 -0700", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check (#445)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NTY4NQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494755685", "body": "We can try to use StringJoiner to replace StringBuilder, that will make this code a bit cleaner because we don't have to add delimiter every time when a element is appended.\r\n\r\nYou can have it this way\r\n```\r\nStringJoiner joiner = new StringJoiner(\"|\", \"<\", \">\");\r\nStream.of(CompatibilityOptions.Mode.values()).forEach(elem -> joiner.add(elem));\r\nreturn joiner.toString();\r\n```", "bodyText": "We can try to use StringJoiner to replace StringBuilder, that will make this code a bit cleaner because we don't have to add delimiter every time when a element is appended.\nYou can have it this way\nStringJoiner joiner = new StringJoiner(\"|\", \"<\", \">\");\nStream.of(CompatibilityOptions.Mode.values()).forEach(elem -> joiner.add(elem));\nreturn joiner.toString();", "bodyHTML": "<p dir=\"auto\">We can try to use StringJoiner to replace StringBuilder, that will make this code a bit cleaner because we don't have to add delimiter every time when a element is appended.</p>\n<p dir=\"auto\">You can have it this way</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"StringJoiner joiner = new StringJoiner(&quot;|&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;);\nStream.of(CompatibilityOptions.Mode.values()).forEach(elem -&gt; joiner.add(elem));\nreturn joiner.toString();\"><pre><code>StringJoiner joiner = new StringJoiner(\"|\", \"&lt;\", \"&gt;\");\nStream.of(CompatibilityOptions.Mode.values()).forEach(elem -&gt; joiner.add(elem));\nreturn joiner.toString();\n</code></pre></div>", "author": "BrianPin", "createdAt": "2020-09-25T05:29:41Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    final String compatLevelValue;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      compatLevelValue = cl.getOptionValue(\"cl\");\n+    }\n+    else\n+    {\n+      compatLevelValue = CompatibilityLevel.DEFAULT.name();\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    try\n+    {\n+      compatLevel = CompatibilityLevel.valueOf(compatLevelValue.toUpperCase());\n+    }\n+    catch (IllegalArgumentException e)\n+    {\n+      _logger.error(\"Invalid compatibilityLevel\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String compatModeValue;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      compatModeValue = cl.getOptionValue(\"cm\");\n+    }\n+    else\n+    {\n+      compatModeValue = CompatibilityOptions.Mode.SCHEMA.name();\n+    }\n+    CompatibilityOptions.Mode compatMode = null;\n+    try\n+    {\n+      compatMode = CompatibilityOptions.Mode.valueOf(compatModeValue.toUpperCase());\n+    }\n+    catch (IllegalArgumentException e)\n+    {\n+      _logger.error(\"Invalid compatibilityOption Mode\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker.getInfoMap().createSummary();\n+\n+    if (compatLevel != CompatibilityLevel.OFF && summary.length() > 0)\n+    {\n+      _logger.info(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      _logger.info(new CompatibilityReport(compatibilityChecker.getInfoMap(), compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker.getInfoMap().isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  public CompatibilityInfoMap getInfoMap()\n+  {\n+    return _infoMap;\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing idl file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   */\n+  public void checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(currSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    DataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n+    PdlSchemaParser parser = new PdlSchemaParser(resolver);\n+    parser.parse(new FileInputStream(schemaFile));\n+    if (parser.hasError())\n+    {\n+      throw new RuntimeException(parser.errorMessage() + \" Error while parsing file: \" + schemaFile.toString());\n+    }\n+\n+    List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+    if (topLevelDataSchemas.size() != 1)\n+    {\n+      throw new RuntimeException(\"Could not parse schema : \" + schemaFile.getAbsolutePath() + \" The size of top level schemas is not 1.\");\n+    }\n+    DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+    if (!(topLevelDataSchema instanceof NamedDataSchema))\n+    {\n+      throw new RuntimeException(\"Invalid schema : \" + schemaFile.getAbsolutePath() + \", the schema is not a named schema.\");\n+    }\n+    return topLevelDataSchema;\n+  }\n+\n+  private static String listCompatLevelOptions()\n+  {\n+    final StringBuilder options = new StringBuilder(\"<\");\n+    for (CompatibilityLevel compatLevel : CompatibilityLevel.values())\n+    {\n+      options.append(compatLevel.name().toLowerCase()).append(\"|\");\n+    }\n+    options.replace(options.length() - 1, options.length(), \">\");\n+\n+    return options.toString();\n+  }\n+\n+  private static String listCompatModeOptions()\n+  {\n+    final StringBuilder options = new StringBuilder(\"<\");", "originalCommit": "849f5a16a92eb014628d6e9085f5293301e2a3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM3MzA0OA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495373048", "bodyText": "Updated based on the suggestion", "author": "nickibi", "createdAt": "2020-09-26T01:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NTY4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "65a379ceaed8dde2e093cc2997848e715b99c139", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 748eda81a..e46aa58a9 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -262,26 +257,16 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n \n   private static String listCompatLevelOptions()\n   {\n-    final StringBuilder options = new StringBuilder(\"<\");\n-    for (CompatibilityLevel compatLevel : CompatibilityLevel.values())\n-    {\n-      options.append(compatLevel.name().toLowerCase()).append(\"|\");\n-    }\n-    options.replace(options.length() - 1, options.length(), \">\");\n-\n-    return options.toString();\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityLevel.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n   }\n \n   private static String listCompatModeOptions()\n   {\n-    final StringBuilder options = new StringBuilder(\"<\");\n-    for (CompatibilityOptions.Mode mode : CompatibilityOptions.Mode.values())\n-    {\n-      options.append(mode.name().toLowerCase()).append(\"|\");\n-    }\n-    options.replace(options.length() - 1, options.length(), \">\");\n-\n-    return options.toString();\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityOptions.Mode.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n   }\n \n   private static void help()\n", "next_change": {"commit": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex e46aa58a9..62ac2ed38 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -274,9 +280,69 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n     final HelpFormatter formatter = new HelpFormatter();\n     formatter.printHelp(120,\n         PegasusSchemaSnapshotCompatibilityChecker.class.getSimpleName(),\n-        \"[compatibility_level], [compatibilityOption_mode], [report]\",\n+        \"[compatibility_level], [compatibilityOption_mode], [report], [prevSnapshotDir], [currSnapshotDir]\",\n         _options,\n         \"\",\n         true);\n   }\n+\n+  /**\n+   * Generate a file pair list, the same snapshot names of prevSnapshot and currSnapshot will be grouped together.\n+   *\n+   * @param prevSnapshotDir\n+   * @param currSnapshotDir\n+   * @return filePairList List<String>\n+   */\n+  private static List<String> getMatchingPrevAndCurrSnapshotPairs(String prevSnapshotDir, String currSnapshotDir)\n+  {\n+    Map<String, String> prevFilesMap = createMapFromFiles(prevSnapshotDir);\n+    Map<String, String> currFilesMap = createMapFromFiles(currSnapshotDir);\n+    List<String> filePairs = new ArrayList<>();\n+\n+    currFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      if (currFilesMap.containsKey(filename))\n+      {\n+        filePairs.add(prevFilesMap.get(filename));\n+        filePairs.add(absolutePath);\n+        prevFilesMap.remove(filename);\n+      }\n+      else\n+      {\n+        filePairs.add(\"\");\n+        filePairs.add(absolutePath);\n+      }\n+    });\n+\n+    prevFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      filePairs.add(absolutePath);\n+      filePairs.add(\"\");\n+    });\n+\n+    return filePairs;\n+  }\n+\n+  /**\n+   * Create a map for all the files under snapshot directory.\n+   * The key is the file name, the value is the absolutePath of the file\n+   * @param snapshotFileDir\n+   * @return filesMap Map<String, String>\n+   */\n+  private static Map<String, String> createMapFromFiles(String snapshotFileDir)\n+  {\n+    try (Stream<Path> paths = Files.walk(Paths.get(snapshotFileDir)))\n+    {\n+      return paths\n+          .filter(path -> path.toString().endsWith(PDL))\n+          .map(path -> path.toFile())\n+          .collect(Collectors.toMap(File::getName, File:: getAbsolutePath, (first, second) -> first));\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error (\"Error while reading snapshot directory: \" + snapshotFileDir);\n+      System.exit(1);\n+    }\n+    return null;\n+  }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 748eda81a..5964f3464 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -262,26 +263,16 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n \n   private static String listCompatLevelOptions()\n   {\n-    final StringBuilder options = new StringBuilder(\"<\");\n-    for (CompatibilityLevel compatLevel : CompatibilityLevel.values())\n-    {\n-      options.append(compatLevel.name().toLowerCase()).append(\"|\");\n-    }\n-    options.replace(options.length() - 1, options.length(), \">\");\n-\n-    return options.toString();\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityLevel.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n   }\n \n   private static String listCompatModeOptions()\n   {\n-    final StringBuilder options = new StringBuilder(\"<\");\n-    for (CompatibilityOptions.Mode mode : CompatibilityOptions.Mode.values())\n-    {\n-      options.append(mode.name().toLowerCase()).append(\"|\");\n-    }\n-    options.replace(options.length() - 1, options.length(), \">\");\n-\n-    return options.toString();\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityOptions.Mode.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n   }\n \n   private static void help()\n", "next_change": {"commit": "74121d54a156824aa2c7db15ade34e8852b1ea08", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 5964f3464..beedc000a 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -280,7 +338,8 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n     final HelpFormatter formatter = new HelpFormatter();\n     formatter.printHelp(120,\n         PegasusSchemaSnapshotCompatibilityChecker.class.getSimpleName(),\n-        \"[compatibility_level], [compatibilityOption_mode], [report], [prevSnapshotDir], [currSnapshotDir]\",\n+        \"[compatibility_level], [compatibilityOption_mode], [report], [prevSnapshotDir], [currSnapshotDir], \"\n+            + \"[annotation_handler_jarPaths], [handler-classNames], [extensionSchema]\",\n         _options,\n         \"\",\n         true);\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}, {"oid": "d13138ec6ae83fb805cc599ff396a33fa28cb031", "committedDate": "2020-10-19 20:07:58 -0700", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check (#445)"}]}, {"oid": "65a379ceaed8dde2e093cc2997848e715b99c139", "url": "https://github.com/linkedin/rest.li/commit/65a379ceaed8dde2e093cc2997848e715b99c139", "message": "Add checkPegasusSchemaSnapshotTask", "committedDate": "2020-09-26T01:31:11Z", "type": "forcePushed"}, {"oid": "c39cd375d947a7f098acc730cfba3b4eb67e5fbf", "url": "https://github.com/linkedin/rest.li/commit/c39cd375d947a7f098acc730cfba3b4eb67e5fbf", "message": "Add checkPegasusSchemaSnapshotTask", "committedDate": "2020-09-26T04:07:23Z", "type": "forcePushed"}, {"oid": "678478fea424515a1a53489198c7036c9262d441", "url": "https://github.com/linkedin/rest.li/commit/678478fea424515a1a53489198c7036c9262d441", "message": "Add checkPegasusSchemaSnapshotTask", "committedDate": "2020-09-27T23:43:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYzNzk1MQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495637951", "body": "Please add a one line comment on what each of these constants are used for.", "bodyText": "Please add a one line comment on what each of these constants are used for.", "bodyHTML": "<p dir=\"auto\">Please add a one line comment on what each of these constants are used for.</p>", "author": "karthikbalasub", "createdAt": "2020-09-28T00:21:51Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java", "diffHunk": "@@ -538,6 +541,9 @@\n   public static final String SNAPSHOT_FILE_SUFFIX = \".snapshot.json\";\n   public static final String SNAPSHOT_COMPAT_REQUIREMENT = \"rest.model.compatibility\";\n   public static final String IDL_COMPAT_REQUIREMENT = \"rest.idl.compatibility\";\n+  public static final String PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusExtensionSchema.compatibility\";\n+  public static final String PEGASUS_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusSchema.compatibility\";\n+  private static final String PEGASUS_COMPATIBILITY_MODE = \"pegasusPlugin.pegasusSchemaCompatibilityCheckMode\";", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI1MzgzNA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496253834", "bodyText": "Added comments", "author": "nickibi", "createdAt": "2020-09-28T21:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYzNzk1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex 7cab9de3f..b99dd31ed 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -541,8 +539,11 @@ public class PegasusPlugin implements Plugin<Project>\n   public static final String SNAPSHOT_FILE_SUFFIX = \".snapshot.json\";\n   public static final String SNAPSHOT_COMPAT_REQUIREMENT = \"rest.model.compatibility\";\n   public static final String IDL_COMPAT_REQUIREMENT = \"rest.idl.compatibility\";\n+  // Pegasus extension schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n   public static final String PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusExtensionSchema.compatibility\";\n+  // Pegasus schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n   public static final String PEGASUS_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusSchema.compatibility\";\n+  // CompatibilityOptions Mode configuration, which is used to define the {@link CompatibilityOptions#Mode} in the compatibility checker.\n   private static final String PEGASUS_COMPATIBILITY_MODE = \"pegasusPlugin.pegasusSchemaCompatibilityCheckMode\";\n \n   private static final Pattern TEST_DIR_REGEX = Pattern.compile(\"^(integ)?[Tt]est\");\n", "next_change": {"commit": "7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex b99dd31ed..e63d204a6 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -539,8 +539,6 @@ public class PegasusPlugin implements Plugin<Project>\n   public static final String SNAPSHOT_FILE_SUFFIX = \".snapshot.json\";\n   public static final String SNAPSHOT_COMPAT_REQUIREMENT = \"rest.model.compatibility\";\n   public static final String IDL_COMPAT_REQUIREMENT = \"rest.idl.compatibility\";\n-  // Pegasus extension schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n-  public static final String PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusExtensionSchema.compatibility\";\n   // Pegasus schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n   public static final String PEGASUS_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusSchema.compatibility\";\n   // CompatibilityOptions Mode configuration, which is used to define the {@link CompatibilityOptions#Mode} in the compatibility checker.\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex 7cab9de3f..e63d204a6 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -541,8 +539,9 @@ public class PegasusPlugin implements Plugin<Project>\n   public static final String SNAPSHOT_FILE_SUFFIX = \".snapshot.json\";\n   public static final String SNAPSHOT_COMPAT_REQUIREMENT = \"rest.model.compatibility\";\n   public static final String IDL_COMPAT_REQUIREMENT = \"rest.idl.compatibility\";\n-  public static final String PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusExtensionSchema.compatibility\";\n+  // Pegasus schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n   public static final String PEGASUS_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusSchema.compatibility\";\n+  // CompatibilityOptions Mode configuration, which is used to define the {@link CompatibilityOptions#Mode} in the compatibility checker.\n   private static final String PEGASUS_COMPATIBILITY_MODE = \"pegasusPlugin.pegasusSchemaCompatibilityCheckMode\";\n \n   private static final Pattern TEST_DIR_REGEX = Pattern.compile(\"^(integ)?[Tt]est\");\n", "next_change": {"commit": "834d1e7ef0c6cda29d2aee85cbad556d9da0e446", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex e63d204a6..3fd5b6e91 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -541,6 +554,8 @@ public class PegasusPlugin implements Plugin<Project>\n   public static final String IDL_COMPAT_REQUIREMENT = \"rest.idl.compatibility\";\n   // Pegasus schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n   public static final String PEGASUS_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusSchema.compatibility\";\n+  // Pegasus extension schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}\n+  public static final String PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.extensionSchema.compatibility\";\n   // CompatibilityOptions Mode configuration, which is used to define the {@link CompatibilityOptions#Mode} in the compatibility checker.\n   private static final String PEGASUS_COMPATIBILITY_MODE = \"pegasusPlugin.pegasusSchemaCompatibilityCheckMode\";\n \n", "next_change": {"commit": "5411abcb832c90205a44908ee857cd98fc6bf55e", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex 3fd5b6e91..ef0135f91 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -561,7 +561,9 @@ public class PegasusPlugin implements Plugin<Project>\n \n   private static final Pattern TEST_DIR_REGEX = Pattern.compile(\"^(integ)?[Tt]est\");\n   private static final String SNAPSHOT_NO_PUBLISH = \"rest.model.noPublish\";\n+  private static final String SNAPSHOT_FORCE_PUBLISH = \"rest.model.forcePublish\";\n   private static final String IDL_NO_PUBLISH = \"rest.idl.noPublish\";\n+  private static final String IDL_FORCE_PUBLISH = \"rest.idl.forcePublish\";\n   private static final String SKIP_IDL_CHECK = \"rest.idl.skipCheck\";\n   // gradle property to skip running GenerateRestModel task.\n   // Note it affects GenerateRestModel task only, and does not skip tasks depends on GenerateRestModel.\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "5895576ce1cdd9090d97c3016bebee6e4c514333", "committedDate": "2020-10-01 13:38:14 -0700", "message": "Fix task caching issue by using the output file to decide if models and spec are equivalent. (#431)"}, {"oid": "a1801028f8a070333a31414a7fc895369ee644c4", "committedDate": "2020-10-16 10:37:44 -0700", "message": "Clear the generated rest client java directory before generating the files. (#449)"}, {"oid": "11cb7e3d42e667aef49d5617ab02f310913e8326", "committedDate": "2020-10-19 21:37:07 -0700", "message": "Set source compatibility on data templiate compile task. (#452)"}, {"oid": "a9aaabbf10a39e7f41fb50db105c75f690f9ee3d", "committedDate": "2020-11-05 14:37:18 -0800", "message": "Check whether schemas exist or not before running pegasusSchemaSnapshotCheck task (#470)"}, {"oid": "d24b12cb08349c860fd152231941fbcea3c00bbf", "committedDate": "2020-11-06 17:55:15 -0800", "message": "Fix bug: if there is no input schema, do not run pegasusSchemaSnapshotCheck. The check statement was wrong. (#471)"}, {"oid": "231162de5d9dda9bcf8c5f4de184674ea6cf639f", "committedDate": "2020-11-09 23:37:29 -0800", "message": "Adding required record field is allowed and should be considered as backward compatible change in extension schemas (#475)"}, {"oid": "51a219f19c4c85336af825f6cc410b5fe44389a9", "committedDate": "2020-12-11 09:56:22 -0800", "message": "Setup the base infra for generating new fluent api client bindings. (#492)"}, {"oid": "91a5399587da5cb4b07cdb69c30d2232b84af667", "committedDate": "2021-01-25 13:14:42 -0800", "message": "Prevent eager resolution of UNUSED_CONFIGURATIONS values (#512)"}, {"oid": "c93e06775a2332ab397a3440e2e8434803500fb7", "committedDate": "2021-04-22 02:28:58 -0700", "message": "Add Fluent API support for FINDER and BATCH_FINDER methods. (#599)"}, {"oid": "292349f9b172183d959fabfe32be029494501317", "committedDate": "2021-04-30 22:09:48 -0700", "message": "Check Gradle version against min required/suggested versions (#614)"}, {"oid": "896c103daf96c66625eab29fa23a2d9f32d0699d", "committedDate": "2021-05-06 14:54:44 -0700", "message": "Use runtimeClasspath instead of runtime config. (#597)"}, {"oid": "87f9382e1ea0dd1e1fdbcbd7be3c18ef7c529025", "committedDate": "2021-05-24 14:24:24 -0700", "message": "Initial support for ivy-publish and feature variants (capabilities) (#568)"}, {"oid": "f2a316e971fa5b79c029bfc899088b0e786de074", "committedDate": "2021-05-27 11:01:24 -0700", "message": "Remove one more \"runtime\" configuration reference. (#631)"}, {"oid": "ec076d8ce64cca0b631eb56bbe4eb03972aa1251", "committedDate": "2021-06-22 18:18:55 -0700", "message": "More changes for Gradle 7 compatibility. (#634)"}, {"oid": "96f40573946ed9c5a27615c178e8455f508b3e9d", "committedDate": "2021-06-23 22:40:29 -0700", "message": "Do not apply Idea and Eclipse plugins. (#640)"}, {"oid": "b8fadffc4b9d7369ef0da31dd93fab4a527665db", "committedDate": "2021-06-24 15:32:28 -0700", "message": "Use the Java 7 diamond operator everywhere. (#643)"}, {"oid": "834d1e7ef0c6cda29d2aee85cbad556d9da0e446", "committedDate": "2021-07-20 16:50:15 -0700", "message": "Add compatibility level config for extension schema compatibility check (#656)"}, {"oid": "7bb4fd8d417334eb59441fcb96a8b64ae1a0bd66", "committedDate": "2021-09-13 10:49:35 -0700", "message": "Add a pegasus plugin config to use case sensitive path in datetemplate generation and rest client generation (#689)"}, {"oid": "af3a6a15d77535ec8a7289e0389a18c93486442d", "committedDate": "2021-09-14 13:05:03 -0700", "message": "Mark the 'extensions' directory as the resource root (#690)"}, {"oid": "7e57ec5cefb54c7777e9a64f5bcd7315917d9451", "committedDate": "2021-10-08 12:43:57 -0700", "message": "Make PegasusPlugin#getDataSchemaPath public. (#701)"}, {"oid": "eb9e0f48162ee2017b40cbcc5f0798dc1848df19", "committedDate": "2021-12-02 09:32:29 -0800", "message": "Add file existence check before performing compatibility report check (#736)"}, {"oid": "7a4a54775c29a2fa73276e2ccddd67b103b42fd7", "committedDate": "2022-11-16 11:15:24 -0800", "message": "Fix the deprecated configuration name used in the PegasusPlugin (#865)"}, {"oid": "5833e46592e3d00a6f3a3d3a5c11aee75b3d2ec3", "committedDate": "2022-12-12 13:54:48 -0800", "message": "Make ivy publication configuration optional (#870)"}, {"oid": "59b1c3430b0b9a6090b68112affb4258cd6c823e", "committedDate": "2022-12-20 10:32:18 -0800", "message": "Replace the API call getArchivePath() with getArchiveFile() on Gradle 7 in the Pegasus Plugin (#872)"}, {"oid": "5411abcb832c90205a44908ee857cd98fc6bf55e", "committedDate": "2023-01-03 15:00:07 -0800", "message": "add property option to force publish idl and snapshot (#878)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDM1NA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495640354", "body": "Is this java process expecting the list of files to compare as the input? If so, please add to the help message.", "bodyText": "Is this java process expecting the list of files to compare as the input? If so, please add to the help message.", "bodyHTML": "<p dir=\"auto\">Is this java process expecting the list of files to compare as the input? If so, please add to the help message.</p>", "author": "karthikbalasub", "createdAt": "2020-09-28T00:41:12Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(currSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return _infoMap;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+\n+    return _infoMap;\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    DataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n+    PdlSchemaParser parser = new PdlSchemaParser(resolver);\n+    parser.parse(new FileInputStream(schemaFile));\n+    if (parser.hasError())\n+    {\n+      throw new RuntimeException(parser.errorMessage() + \" Error while parsing file: \" + schemaFile.toString());\n+    }\n+\n+    List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+    if (topLevelDataSchemas.size() != 1)\n+    {\n+      throw new RuntimeException(\"Could not parse schema : \" + schemaFile.getAbsolutePath() + \" The size of top level schemas is not 1.\");\n+    }\n+    DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+    if (!(topLevelDataSchema instanceof NamedDataSchema))\n+    {\n+      throw new RuntimeException(\"Invalid schema : \" + schemaFile.getAbsolutePath() + \", the schema is not a named schema.\");\n+    }\n+    return topLevelDataSchema;\n+  }\n+\n+  private static String listCompatLevelOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityLevel.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static String listCompatModeOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityOptions.Mode.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static void help()", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0NTc0NQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496245745", "bodyText": "Updated to use directory as input instead of list of files.\nUpdated the help message accordingly.", "author": "nickibi", "createdAt": "2020-09-28T21:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDM1NA=="}], "type": "inlineReview", "revised_code": {"commit": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex c432dd8c0..62ac2ed38 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -274,9 +280,69 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n     final HelpFormatter formatter = new HelpFormatter();\n     formatter.printHelp(120,\n         PegasusSchemaSnapshotCompatibilityChecker.class.getSimpleName(),\n-        \"[compatibility_level], [compatibilityOption_mode], [report]\",\n+        \"[compatibility_level], [compatibilityOption_mode], [report], [prevSnapshotDir], [currSnapshotDir]\",\n         _options,\n         \"\",\n         true);\n   }\n+\n+  /**\n+   * Generate a file pair list, the same snapshot names of prevSnapshot and currSnapshot will be grouped together.\n+   *\n+   * @param prevSnapshotDir\n+   * @param currSnapshotDir\n+   * @return filePairList List<String>\n+   */\n+  private static List<String> getMatchingPrevAndCurrSnapshotPairs(String prevSnapshotDir, String currSnapshotDir)\n+  {\n+    Map<String, String> prevFilesMap = createMapFromFiles(prevSnapshotDir);\n+    Map<String, String> currFilesMap = createMapFromFiles(currSnapshotDir);\n+    List<String> filePairs = new ArrayList<>();\n+\n+    currFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      if (currFilesMap.containsKey(filename))\n+      {\n+        filePairs.add(prevFilesMap.get(filename));\n+        filePairs.add(absolutePath);\n+        prevFilesMap.remove(filename);\n+      }\n+      else\n+      {\n+        filePairs.add(\"\");\n+        filePairs.add(absolutePath);\n+      }\n+    });\n+\n+    prevFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      filePairs.add(absolutePath);\n+      filePairs.add(\"\");\n+    });\n+\n+    return filePairs;\n+  }\n+\n+  /**\n+   * Create a map for all the files under snapshot directory.\n+   * The key is the file name, the value is the absolutePath of the file\n+   * @param snapshotFileDir\n+   * @return filesMap Map<String, String>\n+   */\n+  private static Map<String, String> createMapFromFiles(String snapshotFileDir)\n+  {\n+    try (Stream<Path> paths = Files.walk(Paths.get(snapshotFileDir)))\n+    {\n+      return paths\n+          .filter(path -> path.toString().endsWith(PDL))\n+          .map(path -> path.toFile())\n+          .collect(Collectors.toMap(File::getName, File:: getAbsolutePath, (first, second) -> first));\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error (\"Error while reading snapshot directory: \" + snapshotFileDir);\n+      System.exit(1);\n+    }\n+    return null;\n+  }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex c432dd8c0..5964f3464 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -274,9 +280,69 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n     final HelpFormatter formatter = new HelpFormatter();\n     formatter.printHelp(120,\n         PegasusSchemaSnapshotCompatibilityChecker.class.getSimpleName(),\n-        \"[compatibility_level], [compatibilityOption_mode], [report]\",\n+        \"[compatibility_level], [compatibilityOption_mode], [report], [prevSnapshotDir], [currSnapshotDir]\",\n         _options,\n         \"\",\n         true);\n   }\n+\n+  /**\n+   * Generate a file pair list, the same snapshot names of prevSnapshot and currSnapshot will be grouped together.\n+   *\n+   * @param prevSnapshotDir\n+   * @param currSnapshotDir\n+   * @return filePairList List<String>\n+   */\n+  static List<String> getMatchingPrevAndCurrSnapshotPairs(String prevSnapshotDir, String currSnapshotDir)\n+  {\n+    Map<String, String> prevFilesMap = createMapFromFiles(prevSnapshotDir);\n+    Map<String, String> currFilesMap = createMapFromFiles(currSnapshotDir);\n+    List<String> filePairs = new ArrayList<>();\n+\n+    currFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      if (prevFilesMap.containsKey(filename))\n+      {\n+        filePairs.add(prevFilesMap.get(filename));\n+        filePairs.add(absolutePath);\n+        prevFilesMap.remove(filename);\n+      }\n+      else\n+      {\n+        filePairs.add(\"\");\n+        filePairs.add(absolutePath);\n+      }\n+    });\n+\n+    prevFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      filePairs.add(absolutePath);\n+      filePairs.add(\"\");\n+    });\n+\n+    return filePairs;\n+  }\n+\n+  /**\n+   * Create a map for all the files under snapshot directory.\n+   * The key is the file name, the value is the absolutePath of the file\n+   * @param snapshotFileDir\n+   * @return filesMap Map<String, String>\n+   */\n+  static Map<String, String> createMapFromFiles(String snapshotFileDir)\n+  {\n+    try (Stream<Path> paths = Files.walk(Paths.get(snapshotFileDir)))\n+    {\n+      return paths\n+          .filter(path -> path.toString().endsWith(PDL))\n+          .map(path -> path.toFile())\n+          .collect(Collectors.toMap(File::getName, File:: getAbsolutePath, (first, second) -> first));\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error (\"Error while reading snapshot directory: \" + snapshotFileDir);\n+      System.exit(1);\n+    }\n+    return null;\n+  }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}, {"oid": "d13138ec6ae83fb805cc599ff396a33fa28cb031", "committedDate": "2020-10-19 20:07:58 -0700", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check (#445)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDY3Mw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495640673", "body": "Why should we print the summary twice if \"report\" is enabled?\r\n\r\nIs printing to stdout the best option? Can we write this to a file instead?", "bodyText": "Why should we print the summary twice if \"report\" is enabled?\nIs printing to stdout the best option? Can we write this to a file instead?", "bodyHTML": "<p dir=\"auto\">Why should we print the summary twice if \"report\" is enabled?</p>\n<p dir=\"auto\">Is printing to stdout the best option? Can we write this to a file instead?</p>", "author": "karthikbalasub", "createdAt": "2020-09-28T00:43:41Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY4MjIzMw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495682233", "bodyText": "Umm, printing similar contents of reports is unnecessary. Summary should be good enough for report here.\nI used stdout to leverage the existed \"CompatibilityLogChecker\" class to generate report.\nIn CheckPegasusSnapshotTask, we write the report into a summary file. Writing into a file here seems like redundant.\nMaybe we could remove \"report\" in the cmd line app?", "author": "nickibi", "createdAt": "2020-09-28T04:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NDQ4MQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496264481", "bodyText": "Discussed offline.\nWrite the report into a file.\nIn CheckPegasusSchemaSnapshotTask, use CompatibilityLogChecker to check the report file for the compatibility info.", "author": "nickibi", "createdAt": "2020-09-28T22:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDY3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex c432dd8c0..62ac2ed38 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -137,34 +150,19 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n       compatMode = CompatibilityOptions.Mode.SCHEMA;\n     }\n \n-    try\n-    {\n-      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n-    }\n-    catch (IOException e)\n-    {\n-      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n-      System.exit(1);\n-    }\n-\n     PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    for (int i = 1; i < cliArgs.length; i += 2)\n+    for (int i = 1; i < prevSnapshotAndCurrSnapshotPairs.size(); i += 2)\n     {\n-      String prevSnapshot = cliArgs[i-1];\n-      String currentSnapshot = cliArgs[i];\n+      String prevSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i-1);\n+      String currentSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i);\n       compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n     }\n \n-    String summary = compatibilityChecker._infoMap.createSummary();\n-\n-    if (summary.length() > 0)\n-    {\n-      System.out.println(summary);\n-    }\n-\n     if (cl.hasOption(\"report\"))\n     {\n-      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      File reportFile = new File(cl.getOptionValue(\"report\"));\n+      String compatibilityReport = new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport();\n+      Files.write(reportFile.toPath(), compatibilityReport.getBytes(StandardCharsets.UTF_8));\n       System.exit(0);\n     }\n \n", "next_change": {"commit": "02a5f62be184d2095e9036247e3532f365edeb34", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 62ac2ed38..8e641866d 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -166,7 +166,7 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n       System.exit(0);\n     }\n \n-    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+    System.exit(compatibilityChecker._infoMap.isModelCompatible(compatLevel) ? 0 : 1);\n   }\n \n   /**\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex c432dd8c0..5964f3464 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -137,38 +153,23 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n       compatMode = CompatibilityOptions.Mode.SCHEMA;\n     }\n \n-    try\n-    {\n-      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n-    }\n-    catch (IOException e)\n-    {\n-      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n-      System.exit(1);\n-    }\n-\n     PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    for (int i = 1; i < cliArgs.length; i += 2)\n+    for (int i = 1; i < prevSnapshotAndCurrSnapshotPairs.size(); i += 2)\n     {\n-      String prevSnapshot = cliArgs[i-1];\n-      String currentSnapshot = cliArgs[i];\n-      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n-    }\n-\n-    String summary = compatibilityChecker._infoMap.createSummary();\n-\n-    if (summary.length() > 0)\n-    {\n-      System.out.println(summary);\n+      String prevSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i-1);\n+      String currentSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i);\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatMode);\n     }\n \n     if (cl.hasOption(\"report\"))\n     {\n-      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      File reportFile = new File(cl.getOptionValue(\"report\"));\n+      String compatibilityReport = new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport();\n+      Files.write(reportFile.toPath(), compatibilityReport.getBytes(StandardCharsets.UTF_8));\n       System.exit(0);\n     }\n \n-    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+    System.exit(compatibilityChecker._infoMap.isModelCompatible(compatLevel) ? 0 : 1);\n   }\n \n   /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}, {"oid": "d13138ec6ae83fb805cc599ff396a33fa28cb031", "committedDate": "2020-10-19 20:07:58 -0700", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check (#445)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDkwMQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495640901", "body": "Is this the best way to take inputs for this checker? Can we just take the root directory and iterate over the files?\r\n\r\nThe reason I'm asking is that for PDL files, the number of files is going to be large and would exceed the cmd line limit. ", "bodyText": "Is this the best way to take inputs for this checker? Can we just take the root directory and iterate over the files?\nThe reason I'm asking is that for PDL files, the number of files is going to be large and would exceed the cmd line limit.", "bodyHTML": "<p dir=\"auto\">Is this the best way to take inputs for this checker? Can we just take the root directory and iterate over the files?</p>\n<p dir=\"auto\">The reason I'm asking is that for PDL files, the number of files is going to be large and would exceed the cmd line limit.</p>", "author": "karthikbalasub", "createdAt": "2020-09-28T00:45:16Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcwNTYxMQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495705611", "bodyText": "That's a good point, I will update to use the root directory instead.", "author": "nickibi", "createdAt": "2020-09-28T06:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2MzgwNA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496263804", "bodyText": "Updated", "author": "nickibi", "createdAt": "2020-09-28T22:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDkwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex c432dd8c0..62ac2ed38 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -137,34 +150,19 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n       compatMode = CompatibilityOptions.Mode.SCHEMA;\n     }\n \n-    try\n-    {\n-      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n-    }\n-    catch (IOException e)\n-    {\n-      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n-      System.exit(1);\n-    }\n-\n     PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    for (int i = 1; i < cliArgs.length; i += 2)\n+    for (int i = 1; i < prevSnapshotAndCurrSnapshotPairs.size(); i += 2)\n     {\n-      String prevSnapshot = cliArgs[i-1];\n-      String currentSnapshot = cliArgs[i];\n+      String prevSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i-1);\n+      String currentSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i);\n       compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n     }\n \n-    String summary = compatibilityChecker._infoMap.createSummary();\n-\n-    if (summary.length() > 0)\n-    {\n-      System.out.println(summary);\n-    }\n-\n     if (cl.hasOption(\"report\"))\n     {\n-      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      File reportFile = new File(cl.getOptionValue(\"report\"));\n+      String compatibilityReport = new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport();\n+      Files.write(reportFile.toPath(), compatibilityReport.getBytes(StandardCharsets.UTF_8));\n       System.exit(0);\n     }\n \n", "next_change": {"commit": "02a5f62be184d2095e9036247e3532f365edeb34", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 62ac2ed38..8e641866d 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -166,7 +166,7 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n       System.exit(0);\n     }\n \n-    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+    System.exit(compatibilityChecker._infoMap.isModelCompatible(compatLevel) ? 0 : 1);\n   }\n \n   /**\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex c432dd8c0..5964f3464 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -137,38 +153,23 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n       compatMode = CompatibilityOptions.Mode.SCHEMA;\n     }\n \n-    try\n-    {\n-      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n-    }\n-    catch (IOException e)\n-    {\n-      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n-      System.exit(1);\n-    }\n-\n     PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n-    for (int i = 1; i < cliArgs.length; i += 2)\n+    for (int i = 1; i < prevSnapshotAndCurrSnapshotPairs.size(); i += 2)\n     {\n-      String prevSnapshot = cliArgs[i-1];\n-      String currentSnapshot = cliArgs[i];\n-      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n-    }\n-\n-    String summary = compatibilityChecker._infoMap.createSummary();\n-\n-    if (summary.length() > 0)\n-    {\n-      System.out.println(summary);\n+      String prevSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i-1);\n+      String currentSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i);\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatMode);\n     }\n \n     if (cl.hasOption(\"report\"))\n     {\n-      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      File reportFile = new File(cl.getOptionValue(\"report\"));\n+      String compatibilityReport = new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport();\n+      Files.write(reportFile.toPath(), compatibilityReport.getBytes(StandardCharsets.UTF_8));\n       System.exit(0);\n     }\n \n-    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+    System.exit(compatibilityChecker._infoMap.isModelCompatible(compatLevel) ? 0 : 1);\n   }\n \n   /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}, {"oid": "d13138ec6ae83fb805cc599ff396a33fa28cb031", "committedDate": "2020-10-19 20:07:58 -0700", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check (#445)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MTAzNA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495641034", "body": "nit: previousSchema or prevSchema", "bodyText": "nit: previousSchema or prevSchema", "bodyHTML": "<p dir=\"auto\">nit: previousSchema or prevSchema</p>", "author": "karthikbalasub", "createdAt": "2020-09-28T00:46:13Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI1NzY2Mg==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496257662", "bodyText": "Following we need to parse pdl file to DataSchema, for the DataSchema I called it prevSchema. So I used \"prevSchemaFile\" to distinguish those two objects.\nI could remove this local variable, just pass 'new File(prevPegasusSchemaPath)' into the parseSchema method to get DataSchema.", "author": "nickibi", "createdAt": "2020-09-28T21:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MTAzNA=="}], "type": "inlineReview", "revised_code": {"commit": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex c432dd8c0..62ac2ed38 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -185,28 +183,37 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n   {\n     _infoMap.isCompatible(compatibilityLevel);\n \n-    File preSchemaFile = new File(prevPegasusSchemaPath);\n-    File currSchemaFile = new File(currentPegasusSchemaPath);\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n \n     DataSchema preSchema = null;\n     try\n     {\n-      preSchema = parseSchema(preSchemaFile);\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n-          \"New schema %s is created.\", currentPegasusSchemaPath);\n+      newSchemaCreated = true;\n     }\n \n     DataSchema currSchema = null;\n     try\n     {\n-      currSchema = parseSchema(currSchemaFile);\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n           \"Schema %s is removed.\", prevPegasusSchemaPath);\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex c432dd8c0..5964f3464 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -176,37 +177,43 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n    *\n    * @param prevPegasusSchemaPath previously existing snapshot file\n    * @param currentPegasusSchemaPath current snapshot file\n-   * @param compatibilityLevel compatibility level\n    * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n    * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n    */\n   public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n-      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+      CompatibilityOptions.Mode compatMode)\n   {\n-    _infoMap.isCompatible(compatibilityLevel);\n-\n-    File preSchemaFile = new File(prevPegasusSchemaPath);\n-    File currSchemaFile = new File(currentPegasusSchemaPath);\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n \n     DataSchema preSchema = null;\n     try\n     {\n-      preSchema = parseSchema(preSchemaFile);\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n-          \"New schema %s is created.\", currentPegasusSchemaPath);\n+      newSchemaCreated = true;\n     }\n \n     DataSchema currSchema = null;\n     try\n     {\n-      currSchema = parseSchema(currSchemaFile);\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n           \"Schema %s is removed.\", prevPegasusSchemaPath);\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}, {"oid": "d13138ec6ae83fb805cc599ff396a33fa28cb031", "committedDate": "2020-10-19 20:07:58 -0700", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check (#445)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MTk0NA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495641944", "body": "I don't think this is the correct impact. We just have to these files as added. Similar to how the `ChangedFileReportTask` works. \r\n\r\nAlso, add this only after current schema is parsed correctly?", "bodyText": "I don't think this is the correct impact. We just have to these files as added. Similar to how the ChangedFileReportTask works.\nAlso, add this only after current schema is parsed correctly?", "bodyHTML": "<p dir=\"auto\">I don't think this is the correct impact. We just have to these files as added. Similar to how the <code>ChangedFileReportTask</code> works.</p>\n<p dir=\"auto\">Also, add this only after current schema is parsed correctly?</p>", "author": "karthikbalasub", "createdAt": "2020-09-28T00:51:51Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2MzYwMQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496263601", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-09-28T22:08:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MTk0NA=="}], "type": "inlineReview", "revised_code": {"commit": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex c432dd8c0..62ac2ed38 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -185,28 +183,37 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n   {\n     _infoMap.isCompatible(compatibilityLevel);\n \n-    File preSchemaFile = new File(prevPegasusSchemaPath);\n-    File currSchemaFile = new File(currentPegasusSchemaPath);\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n \n     DataSchema preSchema = null;\n     try\n     {\n-      preSchema = parseSchema(preSchemaFile);\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n-          \"New schema %s is created.\", currentPegasusSchemaPath);\n+      newSchemaCreated = true;\n     }\n \n     DataSchema currSchema = null;\n     try\n     {\n-      currSchema = parseSchema(currSchemaFile);\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n           \"Schema %s is removed.\", prevPegasusSchemaPath);\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex c432dd8c0..5964f3464 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -176,37 +177,43 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n    *\n    * @param prevPegasusSchemaPath previously existing snapshot file\n    * @param currentPegasusSchemaPath current snapshot file\n-   * @param compatibilityLevel compatibility level\n    * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n    * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n    */\n   public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n-      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+      CompatibilityOptions.Mode compatMode)\n   {\n-    _infoMap.isCompatible(compatibilityLevel);\n-\n-    File preSchemaFile = new File(prevPegasusSchemaPath);\n-    File currSchemaFile = new File(currentPegasusSchemaPath);\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n \n     DataSchema preSchema = null;\n     try\n     {\n-      preSchema = parseSchema(preSchemaFile);\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n-          \"New schema %s is created.\", currentPegasusSchemaPath);\n+      newSchemaCreated = true;\n     }\n \n     DataSchema currSchema = null;\n     try\n     {\n-      currSchema = parseSchema(currSchemaFile);\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n           \"Schema %s is removed.\", prevPegasusSchemaPath);\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}, {"oid": "d13138ec6ae83fb805cc599ff396a33fa28cb031", "committedDate": "2020-10-19 20:07:58 -0700", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check (#445)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MjMzMA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495642330", "body": "Again, this is just a backwards incompatible change. It can break any client using this schema at build time, not just old readers. \r\n\r\n", "bodyText": "Again, this is just a backwards incompatible change. It can break any client using this schema at build time, not just old readers.", "bodyHTML": "<p dir=\"auto\">Again, this is just a backwards incompatible change. It can break any client using this schema at build time, not just old readers.</p>", "author": "karthikbalasub", "createdAt": "2020-09-28T00:54:25Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(currSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2MzY2MQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496263661", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-09-28T22:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MjMzMA=="}], "type": "inlineReview", "revised_code": {"commit": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex c432dd8c0..62ac2ed38 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -185,28 +183,37 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n   {\n     _infoMap.isCompatible(compatibilityLevel);\n \n-    File preSchemaFile = new File(prevPegasusSchemaPath);\n-    File currSchemaFile = new File(currentPegasusSchemaPath);\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n \n     DataSchema preSchema = null;\n     try\n     {\n-      preSchema = parseSchema(preSchemaFile);\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n-          \"New schema %s is created.\", currentPegasusSchemaPath);\n+      newSchemaCreated = true;\n     }\n \n     DataSchema currSchema = null;\n     try\n     {\n-      currSchema = parseSchema(currSchemaFile);\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n           \"Schema %s is removed.\", prevPegasusSchemaPath);\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex c432dd8c0..5964f3464 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -176,37 +177,43 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n    *\n    * @param prevPegasusSchemaPath previously existing snapshot file\n    * @param currentPegasusSchemaPath current snapshot file\n-   * @param compatibilityLevel compatibility level\n    * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n    * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n    */\n   public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n-      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+      CompatibilityOptions.Mode compatMode)\n   {\n-    _infoMap.isCompatible(compatibilityLevel);\n-\n-    File preSchemaFile = new File(prevPegasusSchemaPath);\n-    File currSchemaFile = new File(currentPegasusSchemaPath);\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n \n     DataSchema preSchema = null;\n     try\n     {\n-      preSchema = parseSchema(preSchemaFile);\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n-          \"New schema %s is created.\", currentPegasusSchemaPath);\n+      newSchemaCreated = true;\n     }\n \n     DataSchema currSchema = null;\n     try\n     {\n-      currSchema = parseSchema(currSchemaFile);\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n     }\n     catch(FileNotFoundException e)\n     {\n-      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n           \"Schema %s is removed.\", prevPegasusSchemaPath);\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}, {"oid": "d13138ec6ae83fb805cc599ff396a33fa28cb031", "committedDate": "2020-10-19 20:07:58 -0700", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check (#445)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MzgyMQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495643821", "body": "It seems odd that you need to create a resolver for each file. Do you want to process the same schema multiple times if it is referenced by other schemas? Consider this scenario:\r\n\r\nPrev:\r\nA.pdl:\r\nrecord A {\r\n  b: B\r\n}\r\nB.pdl:\r\nrecord B {\r\n  f1: int\r\n  f2: float\r\n}\r\n\r\nCurrent:\r\nA.pdl:\r\nrecord A {\r\n  b: B\r\n}\r\nB.pdl:\r\nrecord B {\r\n  f1: int\r\n  // f2 deleted\r\n}\r\n\r\nNow will the error be reported once for B.pdl or twice, for both A.pdl and B.pdl?\r\nI know we report the error multiple times for resource compatibility checking, but do you think that is the best options for schema checker also? \r\n", "bodyText": "It seems odd that you need to create a resolver for each file. Do you want to process the same schema multiple times if it is referenced by other schemas? Consider this scenario:\nPrev:\nA.pdl:\nrecord A {\nb: B\n}\nB.pdl:\nrecord B {\nf1: int\nf2: float\n}\nCurrent:\nA.pdl:\nrecord A {\nb: B\n}\nB.pdl:\nrecord B {\nf1: int\n// f2 deleted\n}\nNow will the error be reported once for B.pdl or twice, for both A.pdl and B.pdl?\nI know we report the error multiple times for resource compatibility checking, but do you think that is the best options for schema checker also?", "bodyHTML": "<p dir=\"auto\">It seems odd that you need to create a resolver for each file. Do you want to process the same schema multiple times if it is referenced by other schemas? Consider this scenario:</p>\n<p dir=\"auto\">Prev:<br>\nA.pdl:<br>\nrecord A {<br>\nb: B<br>\n}<br>\nB.pdl:<br>\nrecord B {<br>\nf1: int<br>\nf2: float<br>\n}</p>\n<p dir=\"auto\">Current:<br>\nA.pdl:<br>\nrecord A {<br>\nb: B<br>\n}<br>\nB.pdl:<br>\nrecord B {<br>\nf1: int<br>\n// f2 deleted<br>\n}</p>\n<p dir=\"auto\">Now will the error be reported once for B.pdl or twice, for both A.pdl and B.pdl?<br>\nI know we report the error multiple times for resource compatibility checking, but do you think that is the best options for schema checker also?</p>", "author": "karthikbalasub", "createdAt": "2020-09-28T01:05:03Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(currSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return _infoMap;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+\n+    return _infoMap;\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    DataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n+    PdlSchemaParser parser = new PdlSchemaParser(resolver);\n+    parser.parse(new FileInputStream(schemaFile));", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY4NDg4Mg==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495684882", "bodyText": "Umm, I think based on the way we generated snapshot pdl we have to parse each file.\nAll the referenced schemas are constructed as inline records in the snapshot.\nFor example:\nsnapshot: A.pdl will be look like following\nrecord A {\nb: record B {\nf1: int\nf2: float\n}\n}\nI don't think we could avoid it.\nActually, since we do not need resolver path here. I could use DefaultDataSchemaResolver instead. I will the code.", "author": "nickibi", "createdAt": "2020-09-28T04:37:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MzgyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex c432dd8c0..62ac2ed38 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -234,8 +241,7 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n \n   private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n   {\n-    DataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n-    PdlSchemaParser parser = new PdlSchemaParser(resolver);\n+    PdlSchemaParser parser = new PdlSchemaParser(new DefaultDataSchemaResolver());\n     parser.parse(new FileInputStream(schemaFile));\n     if (parser.hasError())\n     {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex c432dd8c0..5964f3464 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -234,8 +241,7 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n \n   private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n   {\n-    DataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n-    PdlSchemaParser parser = new PdlSchemaParser(resolver);\n+    PdlSchemaParser parser = new PdlSchemaParser(new DefaultDataSchemaResolver());\n     parser.parse(new FileInputStream(schemaFile));\n     if (parser.hasError())\n     {\n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}, {"oid": "d13138ec6ae83fb805cc599ff396a33fa28cb031", "committedDate": "2020-10-19 20:07:58 -0700", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check (#445)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0NTI0MA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495645240", "body": "Not used anywhere?", "bodyText": "Not used anywhere?", "bodyHTML": "<p dir=\"auto\">Not used anywhere?</p>", "author": "karthikbalasub", "createdAt": "2020-09-28T01:13:52Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityInfoMap.java", "diffHunk": "@@ -166,6 +166,21 @@ public String createSummary()\n     return summaryMessage.toString();\n   }\n \n+  public String createPegasusSchemaSummary()", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY3NzMxOQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495677319", "bodyText": "It is supposed to use to create summary report. When I edited code, we accidentally removed the usage.\nUpdated.", "author": "nickibi", "createdAt": "2020-09-28T03:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0NTI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0NjAwNg==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496246006", "bodyText": "No more usage, deleted.", "author": "nickibi", "createdAt": "2020-09-28T21:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0NTI0MA=="}], "type": "inlineReview", "revised_code": {"commit": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityInfoMap.java b/restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityInfoMap.java\nindex daf56a5a8..103ec4980 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityInfoMap.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityInfoMap.java\n", "chunk": "@@ -166,21 +166,6 @@ public class CompatibilityInfoMap\n     return summaryMessage.toString();\n   }\n \n-  public String createPegasusSchemaSummary()\n-  {\n-    final StringBuilder summaryMessage = new StringBuilder();\n-\n-    createSummaryForInfo(getIncompatibles(), \"Incompatible changes\", summaryMessage);\n-    createSummaryForInfo(getCompatibles(), \"Compatible changes\", summaryMessage);\n-\n-    if (summaryMessage.length() != 0)\n-    {\n-      summaryMessage.insert(0, \"\\npegasus schema compatibility report:\\n\");\n-    }\n-\n-    return summaryMessage.toString();\n-  }\n-\n   private static void createSummaryForInfo(Collection<CompatibilityInfo> info,\n                                            String description,\n                                            StringBuilder summaryMessage)\n", "next_change": null}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityInfoMap.java b/restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityInfoMap.java\nindex daf56a5a8..103ec4980 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityInfoMap.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityInfoMap.java\n", "chunk": "@@ -166,21 +166,6 @@ public class CompatibilityInfoMap\n     return summaryMessage.toString();\n   }\n \n-  public String createPegasusSchemaSummary()\n-  {\n-    final StringBuilder summaryMessage = new StringBuilder();\n-\n-    createSummaryForInfo(getIncompatibles(), \"Incompatible changes\", summaryMessage);\n-    createSummaryForInfo(getCompatibles(), \"Compatible changes\", summaryMessage);\n-\n-    if (summaryMessage.length() != 0)\n-    {\n-      summaryMessage.insert(0, \"\\npegasus schema compatibility report:\\n\");\n-    }\n-\n-    return summaryMessage.toString();\n-  }\n-\n   private static void createSummaryForInfo(Collection<CompatibilityInfo> info,\n                                            String description,\n                                            StringBuilder summaryMessage)\n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}, {"oid": "b8fadffc4b9d7369ef0da31dd93fab4a527665db", "committedDate": "2021-06-24 15:32:28 -0700", "message": "Use the Java 7 diamond operator everywhere. (#643)"}, {"oid": "834d1e7ef0c6cda29d2aee85cbad556d9da0e446", "committedDate": "2021-07-20 16:50:15 -0700", "message": "Add compatibility level config for extension schema compatibility check (#656)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0NTYxMw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495645613", "body": "unused?", "bodyText": "unused?", "bodyHTML": "<p dir=\"auto\">unused?</p>", "author": "karthikbalasub", "createdAt": "2020-09-28T01:15:53Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java", "diffHunk": "@@ -1,32 +1,176 @@\n /*\n-   Copyright (c) 2020 LinkedIn Corp.\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-*/\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package com.linkedin.pegasus.gradle.tasks;\n \n+import com.linkedin.pegasus.gradle.IOUtil;\n+import com.linkedin.pegasus.gradle.PathingJarUtil;\n+import com.linkedin.pegasus.gradle.PegasusPlugin;\n+import com.linkedin.pegasus.gradle.SharedFileUtils;\n+import com.linkedin.pegasus.gradle.internal.CompatibilityLogChecker;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.file.FileCollection;\n import org.gradle.api.tasks.CacheableTask;\n+import org.gradle.api.tasks.Classpath;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputDirectory;\n+import org.gradle.api.tasks.PathSensitive;\n+import org.gradle.api.tasks.PathSensitivity;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n import org.gradle.api.tasks.TaskAction;\n \n \n @CacheableTask\n public class CheckPegasusSnapshotTask extends DefaultTask\n {\n+  private File _currentSnapshotDirectory;\n+  private File _previousSnapshotDirectory;\n+  private String _compatibilityLevel;\n+  private FileCollection _codegenClasspath;\n+  private String _compatibilityMode;\n+  private FileCollection _handlerJarPath;\n+  private boolean _isExtensionSchema = false;\n+  private File _summaryTarget = new File(getProject().getBuildDir(), \"reports/checkPegasusSchema/summary.txt\");\n+\n   @TaskAction\n   public void checkPegasusSnapshot()\n   {\n-    // TODO: implement CheckPegasusSnapshotTask\n+    getLogger().info(\"Checking pegasus schema compatibility ...\");\n+    List<String> argFiles = new ArrayList<>();\n+    argFiles.addAll(SharedFileUtils.findMatchingFiles(PegasusPlugin.PDL_FILE_SUFFIX,\n+        getProject().fileTree(_currentSnapshotDirectory), getProject().fileTree(_previousSnapshotDirectory), false));\n+    if (argFiles.isEmpty())\n+    {\n+      return;\n+    }\n+\n+    FileCollection pathedCodegenClasspath;\n+    try\n+    {\n+      pathedCodegenClasspath = PathingJarUtil.generatePathingJar(getProject(), getName(),\n+          _codegenClasspath, false);\n+    }\n+    catch (IOException e)\n+    {\n+      throw new GradleException(\"Error occurred generating pathing JAR.\", e);\n+    }\n+\n+    CompatibilityLogChecker logChecker = new CompatibilityLogChecker();\n+    getProject().javaexec(javaExecSpec ->\n+    {\n+      javaExecSpec.setMain(\"com.linkedin.restli.tools.snapshot.check.PegasusSchemaSnapshotCompatibilityChecker\");\n+      javaExecSpec.setClasspath(pathedCodegenClasspath);\n+      javaExecSpec.args(\"--compatLevel\", _compatibilityLevel);\n+      javaExecSpec.args(\"--compatMode\", _compatibilityMode);\n+      javaExecSpec.args(\"--report\");\n+      javaExecSpec.args(argFiles);\n+      javaExecSpec.setStandardOutput(logChecker);\n+    });\n+\n+    IOUtil.writeText(_summaryTarget, logChecker.getWholeText());\n+\n+    if (!logChecker.isModelCompatible())\n+    {\n+      throw new GradleException(\"See output for \" + getPath() + \". Summary written to \"\n+          + _summaryTarget.getAbsolutePath());\n+    }\n+  }\n+\n+  @InputDirectory\n+  @SkipWhenEmpty\n+  @PathSensitive(PathSensitivity.RELATIVE)\n+  public File getCurrentSnapshotDirectory()\n+  {\n+    return _currentSnapshotDirectory;\n   }\n \n+  public void setCurrentSnapshotDirectory(File currentSnapshotDirectory)\n+  {\n+    _currentSnapshotDirectory = currentSnapshotDirectory;\n+  }\n+\n+  @InputDirectory\n+  @SkipWhenEmpty\n+  @PathSensitive(PathSensitivity.RELATIVE)\n+  public File getPreviousSnapshotDirectory()\n+  {\n+    return _previousSnapshotDirectory;\n+  }\n+\n+  public void setPreviousSnapshotDirectory(File previousSnapshotDirectory)\n+  {\n+    _previousSnapshotDirectory = previousSnapshotDirectory;\n+  }\n+\n+  @Input\n+  public String getCompatibilityLevel()\n+  {\n+    return _compatibilityLevel;\n+  }\n+\n+  public void setCompatibilityLevel(String compatibilityLevel)\n+  {\n+    _compatibilityLevel = compatibilityLevel;\n+  }\n+\n+  @Input\n+  public String getCompatibilityMode()\n+  {\n+    return _compatibilityMode;\n+  }\n+\n+  public void setCompatibilityMode(String compatibilityMode)\n+  {\n+    _compatibilityMode = compatibilityMode;\n+  }\n+\n+  @Classpath\n+  public FileCollection getCodegenClasspath()\n+  {\n+    return _codegenClasspath;\n+  }\n+\n+  public void setCodegenClasspath(FileCollection codegenClasspath)\n+  {\n+    _codegenClasspath = codegenClasspath;\n+  }\n+\n+  @Input\n+  public boolean isExtensionSchema()\n+  {\n+    return _isExtensionSchema;\n+  }\n+\n+  public void setExtensionSchema(boolean isExtensionSchema)\n+  {\n+    _isExtensionSchema = isExtensionSchema;\n+  }\n+\n+  @Classpath\n+  public FileCollection getHandlerJarPath()\n+  {\n+    return _handlerJarPath;", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY3NzUzMg==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495677532", "bodyText": "It will be used to in the following PR. I created it as for a place holder.", "author": "nickibi", "createdAt": "2020-09-28T03:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0NTYxMw=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "5895576ce1cdd9090d97c3016bebee6e4c514333", "committedDate": "2020-10-01 13:38:14 -0700", "message": "Fix task caching issue by using the output file to decide if models and spec are equivalent. (#431)"}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}]}, {"oid": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "url": "https://github.com/linkedin/rest.li/commit/18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "message": "Add checkPegasusSchemaSnapshotTask", "committedDate": "2020-09-28T22:07:18Z", "type": "forcePushed"}, {"oid": "e8cff132df27dc0936309023946b483d09cf9112", "url": "https://github.com/linkedin/rest.li/commit/e8cff132df27dc0936309023946b483d09cf9112", "message": "Add checkPegasusSchemaSnapshotTask", "committedDate": "2020-09-28T22:16:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwNjY1Nw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496606657", "body": "Suggestion: would be good to refactor this and move these config constants to FileCompatibilityType(String configName) Enum", "bodyText": "Suggestion: would be good to refactor this and move these config constants to FileCompatibilityType(String configName) Enum", "bodyHTML": "<p dir=\"auto\">Suggestion: would be good to refactor this and move these config constants to FileCompatibilityType(String configName) Enum</p>", "author": "aman1309", "createdAt": "2020-09-29T10:22:10Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java", "diffHunk": "@@ -538,6 +539,12 @@\n   public static final String SNAPSHOT_FILE_SUFFIX = \".snapshot.json\";\n   public static final String SNAPSHOT_COMPAT_REQUIREMENT = \"rest.model.compatibility\";\n   public static final String IDL_COMPAT_REQUIREMENT = \"rest.idl.compatibility\";\n+  // Pegasus extension schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n+  public static final String PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusExtensionSchema.compatibility\";\n+  // Pegasus schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n+  public static final String PEGASUS_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusSchema.compatibility\";\n+  // CompatibilityOptions Mode configuration, which is used to define the {@link CompatibilityOptions#Mode} in the compatibility checker.\n+  private static final String PEGASUS_COMPATIBILITY_MODE = \"pegasusPlugin.pegasusSchemaCompatibilityCheckMode\";", "originalCommit": "e8cff132df27dc0936309023946b483d09cf9112", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwNjU0Ng==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496806546", "bodyText": "All those configurations are optional to provide different configurations. I don't think adding them into a enum is the right solution here.\nI just reconsidered the usage of PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT. The extension schema is not going to be consumed by rest.li end user. It will be consumed by GQL, backward incompatible change should not be allowed. Therefore, removed this configuration.", "author": "nickibi", "createdAt": "2020-09-29T15:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwNjY1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex b99dd31ed..e63d204a6 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -539,8 +539,6 @@ public class PegasusPlugin implements Plugin<Project>\n   public static final String SNAPSHOT_FILE_SUFFIX = \".snapshot.json\";\n   public static final String SNAPSHOT_COMPAT_REQUIREMENT = \"rest.model.compatibility\";\n   public static final String IDL_COMPAT_REQUIREMENT = \"rest.idl.compatibility\";\n-  // Pegasus extension schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n-  public static final String PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusExtensionSchema.compatibility\";\n   // Pegasus schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n   public static final String PEGASUS_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusSchema.compatibility\";\n   // CompatibilityOptions Mode configuration, which is used to define the {@link CompatibilityOptions#Mode} in the compatibility checker.\n", "next_change": null}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex b99dd31ed..e63d204a6 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -539,8 +539,6 @@ public class PegasusPlugin implements Plugin<Project>\n   public static final String SNAPSHOT_FILE_SUFFIX = \".snapshot.json\";\n   public static final String SNAPSHOT_COMPAT_REQUIREMENT = \"rest.model.compatibility\";\n   public static final String IDL_COMPAT_REQUIREMENT = \"rest.idl.compatibility\";\n-  // Pegasus extension schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n-  public static final String PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusExtensionSchema.compatibility\";\n   // Pegasus schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n   public static final String PEGASUS_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusSchema.compatibility\";\n   // CompatibilityOptions Mode configuration, which is used to define the {@link CompatibilityOptions#Mode} in the compatibility checker.\n", "next_change": {"commit": "834d1e7ef0c6cda29d2aee85cbad556d9da0e446", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex e63d204a6..3fd5b6e91 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -541,6 +554,8 @@ public class PegasusPlugin implements Plugin<Project>\n   public static final String IDL_COMPAT_REQUIREMENT = \"rest.idl.compatibility\";\n   // Pegasus schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n   public static final String PEGASUS_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusSchema.compatibility\";\n+  // Pegasus extension schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}\n+  public static final String PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.extensionSchema.compatibility\";\n   // CompatibilityOptions Mode configuration, which is used to define the {@link CompatibilityOptions#Mode} in the compatibility checker.\n   private static final String PEGASUS_COMPATIBILITY_MODE = \"pegasusPlugin.pegasusSchemaCompatibilityCheckMode\";\n \n", "next_change": {"commit": "5411abcb832c90205a44908ee857cd98fc6bf55e", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex 3fd5b6e91..ef0135f91 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -561,7 +561,9 @@ public class PegasusPlugin implements Plugin<Project>\n \n   private static final Pattern TEST_DIR_REGEX = Pattern.compile(\"^(integ)?[Tt]est\");\n   private static final String SNAPSHOT_NO_PUBLISH = \"rest.model.noPublish\";\n+  private static final String SNAPSHOT_FORCE_PUBLISH = \"rest.model.forcePublish\";\n   private static final String IDL_NO_PUBLISH = \"rest.idl.noPublish\";\n+  private static final String IDL_FORCE_PUBLISH = \"rest.idl.forcePublish\";\n   private static final String SKIP_IDL_CHECK = \"rest.idl.skipCheck\";\n   // gradle property to skip running GenerateRestModel task.\n   // Note it affects GenerateRestModel task only, and does not skip tasks depends on GenerateRestModel.\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "5895576ce1cdd9090d97c3016bebee6e4c514333", "committedDate": "2020-10-01 13:38:14 -0700", "message": "Fix task caching issue by using the output file to decide if models and spec are equivalent. (#431)"}, {"oid": "a1801028f8a070333a31414a7fc895369ee644c4", "committedDate": "2020-10-16 10:37:44 -0700", "message": "Clear the generated rest client java directory before generating the files. (#449)"}, {"oid": "11cb7e3d42e667aef49d5617ab02f310913e8326", "committedDate": "2020-10-19 21:37:07 -0700", "message": "Set source compatibility on data templiate compile task. (#452)"}, {"oid": "a9aaabbf10a39e7f41fb50db105c75f690f9ee3d", "committedDate": "2020-11-05 14:37:18 -0800", "message": "Check whether schemas exist or not before running pegasusSchemaSnapshotCheck task (#470)"}, {"oid": "d24b12cb08349c860fd152231941fbcea3c00bbf", "committedDate": "2020-11-06 17:55:15 -0800", "message": "Fix bug: if there is no input schema, do not run pegasusSchemaSnapshotCheck. The check statement was wrong. (#471)"}, {"oid": "231162de5d9dda9bcf8c5f4de184674ea6cf639f", "committedDate": "2020-11-09 23:37:29 -0800", "message": "Adding required record field is allowed and should be considered as backward compatible change in extension schemas (#475)"}, {"oid": "51a219f19c4c85336af825f6cc410b5fe44389a9", "committedDate": "2020-12-11 09:56:22 -0800", "message": "Setup the base infra for generating new fluent api client bindings. (#492)"}, {"oid": "91a5399587da5cb4b07cdb69c30d2232b84af667", "committedDate": "2021-01-25 13:14:42 -0800", "message": "Prevent eager resolution of UNUSED_CONFIGURATIONS values (#512)"}, {"oid": "c93e06775a2332ab397a3440e2e8434803500fb7", "committedDate": "2021-04-22 02:28:58 -0700", "message": "Add Fluent API support for FINDER and BATCH_FINDER methods. (#599)"}, {"oid": "292349f9b172183d959fabfe32be029494501317", "committedDate": "2021-04-30 22:09:48 -0700", "message": "Check Gradle version against min required/suggested versions (#614)"}, {"oid": "896c103daf96c66625eab29fa23a2d9f32d0699d", "committedDate": "2021-05-06 14:54:44 -0700", "message": "Use runtimeClasspath instead of runtime config. (#597)"}, {"oid": "87f9382e1ea0dd1e1fdbcbd7be3c18ef7c529025", "committedDate": "2021-05-24 14:24:24 -0700", "message": "Initial support for ivy-publish and feature variants (capabilities) (#568)"}, {"oid": "f2a316e971fa5b79c029bfc899088b0e786de074", "committedDate": "2021-05-27 11:01:24 -0700", "message": "Remove one more \"runtime\" configuration reference. (#631)"}, {"oid": "ec076d8ce64cca0b631eb56bbe4eb03972aa1251", "committedDate": "2021-06-22 18:18:55 -0700", "message": "More changes for Gradle 7 compatibility. (#634)"}, {"oid": "96f40573946ed9c5a27615c178e8455f508b3e9d", "committedDate": "2021-06-23 22:40:29 -0700", "message": "Do not apply Idea and Eclipse plugins. (#640)"}, {"oid": "b8fadffc4b9d7369ef0da31dd93fab4a527665db", "committedDate": "2021-06-24 15:32:28 -0700", "message": "Use the Java 7 diamond operator everywhere. (#643)"}, {"oid": "834d1e7ef0c6cda29d2aee85cbad556d9da0e446", "committedDate": "2021-07-20 16:50:15 -0700", "message": "Add compatibility level config for extension schema compatibility check (#656)"}, {"oid": "7bb4fd8d417334eb59441fcb96a8b64ae1a0bd66", "committedDate": "2021-09-13 10:49:35 -0700", "message": "Add a pegasus plugin config to use case sensitive path in datetemplate generation and rest client generation (#689)"}, {"oid": "af3a6a15d77535ec8a7289e0389a18c93486442d", "committedDate": "2021-09-14 13:05:03 -0700", "message": "Mark the 'extensions' directory as the resource root (#690)"}, {"oid": "7e57ec5cefb54c7777e9a64f5bcd7315917d9451", "committedDate": "2021-10-08 12:43:57 -0700", "message": "Make PegasusPlugin#getDataSchemaPath public. (#701)"}, {"oid": "eb9e0f48162ee2017b40cbcc5f0798dc1848df19", "committedDate": "2021-12-02 09:32:29 -0800", "message": "Add file existence check before performing compatibility report check (#736)"}, {"oid": "7a4a54775c29a2fa73276e2ccddd67b103b42fd7", "committedDate": "2022-11-16 11:15:24 -0800", "message": "Fix the deprecated configuration name used in the PegasusPlugin (#865)"}, {"oid": "5833e46592e3d00a6f3a3d3a5c11aee75b3d2ec3", "committedDate": "2022-12-12 13:54:48 -0800", "message": "Make ivy publication configuration optional (#870)"}, {"oid": "59b1c3430b0b9a6090b68112affb4258cd6c823e", "committedDate": "2022-12-20 10:32:18 -0800", "message": "Replace the API call getArchivePath() with getArchiveFile() on Gradle 7 in the Pegasus Plugin (#872)"}, {"oid": "5411abcb832c90205a44908ee857cd98fc6bf55e", "committedDate": "2023-01-03 15:00:07 -0800", "message": "add property option to force publish idl and snapshot (#878)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYyODk2Ng==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496628966", "body": "since we might use pdl for idl's in 3.0 or for any other future usecase, recommend using 'FileCompatibilityType' instead of boolean flag.", "bodyText": "since we might use pdl for idl's in 3.0 or for any other future usecase, recommend using 'FileCompatibilityType' instead of boolean flag.", "bodyHTML": "<p dir=\"auto\">since we might use pdl for idl's in 3.0 or for any other future usecase, recommend using 'FileCompatibilityType' instead of boolean flag.</p>", "author": "aman1309", "createdAt": "2020-09-29T11:03:26Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java", "diffHunk": "@@ -1,32 +1,176 @@\n /*\n-   Copyright (c) 2020 LinkedIn Corp.\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-*/\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package com.linkedin.pegasus.gradle.tasks;\n \n+\n+import com.linkedin.pegasus.gradle.PathingJarUtil;\n+import com.linkedin.pegasus.gradle.internal.CompatibilityLogChecker;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.file.FileCollection;\n import org.gradle.api.tasks.CacheableTask;\n+import org.gradle.api.tasks.Classpath;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputDirectory;\n+import org.gradle.api.tasks.PathSensitive;\n+import org.gradle.api.tasks.PathSensitivity;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n import org.gradle.api.tasks.TaskAction;\n \n \n @CacheableTask\n public class CheckPegasusSnapshotTask extends DefaultTask\n {\n+  private File _currentSnapshotDirectory;\n+  private File _previousSnapshotDirectory;\n+  private String _compatibilityLevel;\n+  private FileCollection _codegenClasspath;\n+  private String _compatibilityMode;\n+  private FileCollection _handlerJarPath;\n+  private boolean _isExtensionSchema = false;", "originalCommit": "e8cff132df27dc0936309023946b483d09cf9112", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwMzEzMQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496803131", "bodyText": "I don't think using Enum instead of a boolean is appropriate here. No matter how many use cases of pdl in the future, it is unrelated to the usage of this boolean flag here. isExtensionSchema boolean not only is used to detect input but also is used for annotation check in the following PR.", "author": "nickibi", "createdAt": "2020-09-29T15:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYyODk2Ng=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "74121d54a156824aa2c7db15ade34e8852b1ea08", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java\nindex 0330dd997..82ae0b145 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java\n", "chunk": "@@ -43,6 +50,7 @@ public class CheckPegasusSnapshotTask extends DefaultTask\n   private FileCollection _codegenClasspath;\n   private String _compatibilityMode;\n   private FileCollection _handlerJarPath;\n+  private List<String> _handlerClassNames;\n   private boolean _isExtensionSchema = false;\n   private static String PEGASUS_SCHEMA_COMPATIBILITY_SUMMARY_FILE = \"reports/checkPegasusSchema/compatibilityReport.txt\";\n   private static String PEGASUS_EXTENSION_SCHEMA_COMPATIBILITY_SUMMARY_FILE = \"reports/checkPegasusExtensionSchema/compatibilityReport.txt\";\n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "5895576ce1cdd9090d97c3016bebee6e4c514333", "committedDate": "2020-10-01 13:38:14 -0700", "message": "Fix task caching issue by using the output file to decide if models and spec are equivalent. (#431)"}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYzMDMxMw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496630313", "body": "can we unit test for gradle tasks?", "bodyText": "can we unit test for gradle tasks?", "bodyHTML": "<p dir=\"auto\">can we unit test for gradle tasks?</p>", "author": "aman1309", "createdAt": "2020-09-29T11:05:54Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java", "diffHunk": "@@ -1449,23 +1460,43 @@ protected void configurePegasusSchemaSnapshotGeneration(Project project, SourceS\n   {\n     File schemaDir = isExtensionSchema? project.file(getExtensionSchemaPath(project, sourceSet))\n         : project.file(getDataSchemaPath(project, sourceSet));\n+\n     Path publishablePegasusSchemaSnapshotDir = project.getBuildDir().toPath().resolve(sourceSet.getName() +\n             (isExtensionSchema ? PEGASUS_EXTENSION_SCHEMA_SNAPSHOT: PEGASUS_SCHEMA_SNAPSHOT));\n \n     Task generatePegasusSchemaSnapshot = generatePegasusSchemaSnapshot(project, sourceSet,\n         isExtensionSchema ? PEGASUS_EXTENSION_SCHEMA_SNAPSHOT: PEGASUS_SCHEMA_SNAPSHOT, schemaDir,\n         publishablePegasusSchemaSnapshotDir.toFile(), isExtensionSchema);\n \n+    File pegasusSchemaSnapshotDir = project.file(isExtensionSchema ? getPegasusExtensionSchemaSnapshotPath(project, sourceSet)\n+        : getPegasusSchemaSnapshotPath(project, sourceSet));\n+    pegasusSchemaSnapshotDir.mkdirs();\n+\n     Task checkSchemaSnapshot = project.getTasks().create(sourceSet.getTaskName(\"check\",\n         isExtensionSchema ? PEGASUS_EXTENSION_SCHEMA_SNAPSHOT: PEGASUS_SCHEMA_SNAPSHOT),\n         CheckPegasusSnapshotTask.class, task ->\n         {\n           task.dependsOn(generatePegasusSchemaSnapshot);\n-          // TODO: update CheckPegasusSnapshotTask\n-        });\n+          task.setCurrentSnapshotDirectory(publishablePegasusSchemaSnapshotDir.toFile());\n+          task.setPreviousSnapshotDirectory(pegasusSchemaSnapshotDir);\n+          task.setCodegenClasspath(project.getConfigurations() .getByName(SCHEMA_ANNOTATION_HANDLER_CONFIGURATION)\n+              .plus(project.getConfigurations().getByName(PEGASUS_PLUGIN_CONFIGURATION))\n+              .plus(project.getConfigurations().getByName(JavaPlatformPlugin.RUNTIME_CONFIGURATION_NAME)));\n+          task.setCompatibilityLevel(isExtensionSchema ?\n+              PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_EXTENSION_SCHEMA_SNAPSHOT)\n+              :PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_SCHEMA_SNAPSHOT));\n+          task.setCompatibilityMode(isExtensionSchema ? COMPATIBILITY_OPTIONS_MODE_DATA :\n+              PropertyUtil.findCompatMode(project, PEGASUS_COMPATIBILITY_MODE));\n+          task.setExtensionSchema(isExtensionSchema);\n+          task.setHandlerJarPath(project.getConfigurations() .getByName(SCHEMA_ANNOTATION_HANDLER_CONFIGURATION));\n \n-    File pegasusSchemaSnapshotDir = new File(isExtensionSchema ? getPegasusExtensionSchemaSnapshotPath(project, sourceSet)\n-        : getPegasusSchemaSnapshotPath(project, sourceSet));\n+          task.onlyIf(t ->", "originalCommit": "e8cff132df27dc0936309023946b483d09cf9112", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex b99dd31ed..e63d204a6 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -1482,8 +1482,7 @@ public class PegasusPlugin implements Plugin<Project>\n           task.setCodegenClasspath(project.getConfigurations() .getByName(SCHEMA_ANNOTATION_HANDLER_CONFIGURATION)\n               .plus(project.getConfigurations().getByName(PEGASUS_PLUGIN_CONFIGURATION))\n               .plus(project.getConfigurations().getByName(JavaPlatformPlugin.RUNTIME_CONFIGURATION_NAME)));\n-          task.setCompatibilityLevel(isExtensionSchema ?\n-              PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_EXTENSION_SCHEMA_SNAPSHOT)\n+          task.setCompatibilityLevel(isExtensionSchema ? COMPATIBILITY_LEVEL_BACKWARDS\n               :PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_SCHEMA_SNAPSHOT));\n           task.setCompatibilityMode(isExtensionSchema ? COMPATIBILITY_OPTIONS_MODE_DATA :\n               PropertyUtil.findCompatMode(project, PEGASUS_COMPATIBILITY_MODE));\n", "next_change": null}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex b99dd31ed..e63d204a6 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -1482,8 +1482,7 @@ public class PegasusPlugin implements Plugin<Project>\n           task.setCodegenClasspath(project.getConfigurations() .getByName(SCHEMA_ANNOTATION_HANDLER_CONFIGURATION)\n               .plus(project.getConfigurations().getByName(PEGASUS_PLUGIN_CONFIGURATION))\n               .plus(project.getConfigurations().getByName(JavaPlatformPlugin.RUNTIME_CONFIGURATION_NAME)));\n-          task.setCompatibilityLevel(isExtensionSchema ?\n-              PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_EXTENSION_SCHEMA_SNAPSHOT)\n+          task.setCompatibilityLevel(isExtensionSchema ? COMPATIBILITY_LEVEL_BACKWARDS\n               :PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_SCHEMA_SNAPSHOT));\n           task.setCompatibilityMode(isExtensionSchema ? COMPATIBILITY_OPTIONS_MODE_DATA :\n               PropertyUtil.findCompatMode(project, PEGASUS_COMPATIBILITY_MODE));\n", "next_change": {"commit": "a9aaabbf10a39e7f41fb50db105c75f690f9ee3d", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex e63d204a6..1694a7763 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -1479,8 +1447,8 @@ public class PegasusPlugin implements Plugin<Project>\n           task.dependsOn(generatePegasusSchemaSnapshot);\n           task.setCurrentSnapshotDirectory(publishablePegasusSchemaSnapshotDir.toFile());\n           task.setPreviousSnapshotDirectory(pegasusSchemaSnapshotDir);\n-          task.setCodegenClasspath(project.getConfigurations() .getByName(SCHEMA_ANNOTATION_HANDLER_CONFIGURATION)\n-              .plus(project.getConfigurations().getByName(PEGASUS_PLUGIN_CONFIGURATION))\n+          task.setCodegenClasspath(project.getConfigurations().getByName(PEGASUS_PLUGIN_CONFIGURATION)\n+              .plus(project.getConfigurations().getByName(SCHEMA_ANNOTATION_HANDLER_CONFIGURATION))\n               .plus(project.getConfigurations().getByName(JavaPlatformPlugin.RUNTIME_CONFIGURATION_NAME)));\n           task.setCompatibilityLevel(isExtensionSchema ? COMPATIBILITY_LEVEL_BACKWARDS\n               :PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_SCHEMA_SNAPSHOT));\n", "next_change": {"commit": "231162de5d9dda9bcf8c5f4de184674ea6cf639f", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex 1694a7763..cb833e46e 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -1452,7 +1452,7 @@ public class PegasusPlugin implements Plugin<Project>\n               .plus(project.getConfigurations().getByName(JavaPlatformPlugin.RUNTIME_CONFIGURATION_NAME)));\n           task.setCompatibilityLevel(isExtensionSchema ? COMPATIBILITY_LEVEL_BACKWARDS\n               :PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_SCHEMA_SNAPSHOT));\n-          task.setCompatibilityMode(isExtensionSchema ? COMPATIBILITY_OPTIONS_MODE_DATA :\n+          task.setCompatibilityMode(isExtensionSchema ? COMPATIBILITY_OPTIONS_MODE_EXTENSION :\n               PropertyUtil.findCompatMode(project, PEGASUS_COMPATIBILITY_MODE));\n           task.setExtensionSchema(isExtensionSchema);\n           task.setHandlerJarPath(project.getConfigurations() .getByName(SCHEMA_ANNOTATION_HANDLER_CONFIGURATION));\n", "next_change": {"commit": "896c103daf96c66625eab29fa23a2d9f32d0699d", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex cb833e46e..a5028c8cd 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -1449,7 +1456,7 @@ public class PegasusPlugin implements Plugin<Project>\n           task.setPreviousSnapshotDirectory(pegasusSchemaSnapshotDir);\n           task.setCodegenClasspath(project.getConfigurations().getByName(PEGASUS_PLUGIN_CONFIGURATION)\n               .plus(project.getConfigurations().getByName(SCHEMA_ANNOTATION_HANDLER_CONFIGURATION))\n-              .plus(project.getConfigurations().getByName(JavaPlatformPlugin.RUNTIME_CONFIGURATION_NAME)));\n+              .plus(project.getConfigurations().getByName(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME)));\n           task.setCompatibilityLevel(isExtensionSchema ? COMPATIBILITY_LEVEL_BACKWARDS\n               :PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_SCHEMA_SNAPSHOT));\n           task.setCompatibilityMode(isExtensionSchema ? COMPATIBILITY_OPTIONS_MODE_EXTENSION :\n", "next_change": {"commit": "834d1e7ef0c6cda29d2aee85cbad556d9da0e446", "changed_code": [{"header": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\nindex a5028c8cd..3fd5b6e91 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java\n", "chunk": "@@ -1457,7 +1464,8 @@ public class PegasusPlugin implements Plugin<Project>\n           task.setCodegenClasspath(project.getConfigurations().getByName(PEGASUS_PLUGIN_CONFIGURATION)\n               .plus(project.getConfigurations().getByName(SCHEMA_ANNOTATION_HANDLER_CONFIGURATION))\n               .plus(project.getConfigurations().getByName(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME)));\n-          task.setCompatibilityLevel(isExtensionSchema ? COMPATIBILITY_LEVEL_BACKWARDS\n+          task.setCompatibilityLevel(isExtensionSchema ?\n+                  PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_EXTENSION_SCHEMA_SNAPSHOT)\n               :PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_SCHEMA_SNAPSHOT));\n           task.setCompatibilityMode(isExtensionSchema ? COMPATIBILITY_OPTIONS_MODE_EXTENSION :\n               PropertyUtil.findCompatMode(project, PEGASUS_COMPATIBILITY_MODE));\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "5895576ce1cdd9090d97c3016bebee6e4c514333", "committedDate": "2020-10-01 13:38:14 -0700", "message": "Fix task caching issue by using the output file to decide if models and spec are equivalent. (#431)"}, {"oid": "a1801028f8a070333a31414a7fc895369ee644c4", "committedDate": "2020-10-16 10:37:44 -0700", "message": "Clear the generated rest client java directory before generating the files. (#449)"}, {"oid": "11cb7e3d42e667aef49d5617ab02f310913e8326", "committedDate": "2020-10-19 21:37:07 -0700", "message": "Set source compatibility on data templiate compile task. (#452)"}, {"oid": "a9aaabbf10a39e7f41fb50db105c75f690f9ee3d", "committedDate": "2020-11-05 14:37:18 -0800", "message": "Check whether schemas exist or not before running pegasusSchemaSnapshotCheck task (#470)"}, {"oid": "d24b12cb08349c860fd152231941fbcea3c00bbf", "committedDate": "2020-11-06 17:55:15 -0800", "message": "Fix bug: if there is no input schema, do not run pegasusSchemaSnapshotCheck. The check statement was wrong. (#471)"}, {"oid": "231162de5d9dda9bcf8c5f4de184674ea6cf639f", "committedDate": "2020-11-09 23:37:29 -0800", "message": "Adding required record field is allowed and should be considered as backward compatible change in extension schemas (#475)"}, {"oid": "51a219f19c4c85336af825f6cc410b5fe44389a9", "committedDate": "2020-12-11 09:56:22 -0800", "message": "Setup the base infra for generating new fluent api client bindings. (#492)"}, {"oid": "91a5399587da5cb4b07cdb69c30d2232b84af667", "committedDate": "2021-01-25 13:14:42 -0800", "message": "Prevent eager resolution of UNUSED_CONFIGURATIONS values (#512)"}, {"oid": "c93e06775a2332ab397a3440e2e8434803500fb7", "committedDate": "2021-04-22 02:28:58 -0700", "message": "Add Fluent API support for FINDER and BATCH_FINDER methods. (#599)"}, {"oid": "292349f9b172183d959fabfe32be029494501317", "committedDate": "2021-04-30 22:09:48 -0700", "message": "Check Gradle version against min required/suggested versions (#614)"}, {"oid": "896c103daf96c66625eab29fa23a2d9f32d0699d", "committedDate": "2021-05-06 14:54:44 -0700", "message": "Use runtimeClasspath instead of runtime config. (#597)"}, {"oid": "87f9382e1ea0dd1e1fdbcbd7be3c18ef7c529025", "committedDate": "2021-05-24 14:24:24 -0700", "message": "Initial support for ivy-publish and feature variants (capabilities) (#568)"}, {"oid": "f2a316e971fa5b79c029bfc899088b0e786de074", "committedDate": "2021-05-27 11:01:24 -0700", "message": "Remove one more \"runtime\" configuration reference. (#631)"}, {"oid": "ec076d8ce64cca0b631eb56bbe4eb03972aa1251", "committedDate": "2021-06-22 18:18:55 -0700", "message": "More changes for Gradle 7 compatibility. (#634)"}, {"oid": "96f40573946ed9c5a27615c178e8455f508b3e9d", "committedDate": "2021-06-23 22:40:29 -0700", "message": "Do not apply Idea and Eclipse plugins. (#640)"}, {"oid": "b8fadffc4b9d7369ef0da31dd93fab4a527665db", "committedDate": "2021-06-24 15:32:28 -0700", "message": "Use the Java 7 diamond operator everywhere. (#643)"}, {"oid": "834d1e7ef0c6cda29d2aee85cbad556d9da0e446", "committedDate": "2021-07-20 16:50:15 -0700", "message": "Add compatibility level config for extension schema compatibility check (#656)"}, {"oid": "7bb4fd8d417334eb59441fcb96a8b64ae1a0bd66", "committedDate": "2021-09-13 10:49:35 -0700", "message": "Add a pegasus plugin config to use case sensitive path in datetemplate generation and rest client generation (#689)"}, {"oid": "af3a6a15d77535ec8a7289e0389a18c93486442d", "committedDate": "2021-09-14 13:05:03 -0700", "message": "Mark the 'extensions' directory as the resource root (#690)"}, {"oid": "7e57ec5cefb54c7777e9a64f5bcd7315917d9451", "committedDate": "2021-10-08 12:43:57 -0700", "message": "Make PegasusPlugin#getDataSchemaPath public. (#701)"}, {"oid": "eb9e0f48162ee2017b40cbcc5f0798dc1848df19", "committedDate": "2021-12-02 09:32:29 -0800", "message": "Add file existence check before performing compatibility report check (#736)"}, {"oid": "7a4a54775c29a2fa73276e2ccddd67b103b42fd7", "committedDate": "2022-11-16 11:15:24 -0800", "message": "Fix the deprecated configuration name used in the PegasusPlugin (#865)"}, {"oid": "5833e46592e3d00a6f3a3d3a5c11aee75b3d2ec3", "committedDate": "2022-12-12 13:54:48 -0800", "message": "Make ivy publication configuration optional (#870)"}, {"oid": "59b1c3430b0b9a6090b68112affb4258cd6c823e", "committedDate": "2022-12-20 10:32:18 -0800", "message": "Replace the API call getArchivePath() with getArchiveFile() on Gradle 7 in the Pegasus Plugin (#872)"}, {"oid": "5411abcb832c90205a44908ee857cd98fc6bf55e", "committedDate": "2023-01-03 15:00:07 -0800", "message": "add property option to force publish idl and snapshot (#878)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYzMTQwMw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496631403", "body": "lets print option value and exception trace also.\r\nSame for other places.", "bodyText": "lets print option value and exception trace also.\nSame for other places.", "bodyHTML": "<p dir=\"auto\">lets print option value and exception trace also.<br>\nSame for other places.</p>", "author": "aman1309", "createdAt": "2020-09-29T11:07:56Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.DefaultDataSchemaResolver;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static final String PDL = \".pdl\";\n+\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_report\")\n+        .withLongOpt(\"report\")\n+        .hasArg()\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length != 2)\n+    {\n+      _logger.error(\"Invalid arguments!\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String prevSnapshotDir = cliArgs[0];\n+    String currSnapshotDir = cliArgs[1];\n+\n+    List<String> prevSnapshotAndCurrSnapshotPairs = getMatchingPrevAndCurrSnapshotPairs(prevSnapshotDir, currSnapshotDir);\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");", "originalCommit": "e8cff132df27dc0936309023946b483d09cf9112", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "02a5f62be184d2095e9036247e3532f365edeb34", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 62ac2ed38..8e641866d 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -121,7 +121,7 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n       }\n       catch (IllegalArgumentException e)\n       {\n-        _logger.error(\"Invalid compatibilityLevel\");\n+        _logger.error(\"Invalid compatibilityLevel: \" + cl.getOptionValue(\"cl\") + e.getMessage());\n         help();\n         System.exit(1);\n       }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 62ac2ed38..5964f3464 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -121,7 +124,7 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n       }\n       catch (IllegalArgumentException e)\n       {\n-        _logger.error(\"Invalid compatibilityLevel\");\n+        _logger.error(\"Invalid compatibilityLevel: \" + cl.getOptionValue(\"cl\") + e.getMessage());\n         help();\n         System.exit(1);\n       }\n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}, {"oid": "d13138ec6ae83fb805cc599ff396a33fa28cb031", "committedDate": "2020-10-19 20:07:58 -0700", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check (#445)"}]}, {"oid": "02a5f62be184d2095e9036247e3532f365edeb34", "url": "https://github.com/linkedin/rest.li/commit/02a5f62be184d2095e9036247e3532f365edeb34", "message": "Add checkPegasusSchemaSnapshotTask", "committedDate": "2020-09-29T15:57:44Z", "type": "forcePushed"}, {"oid": "7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "url": "https://github.com/linkedin/rest.li/commit/7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\".", "committedDate": "2020-09-29T16:15:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNjE1Nw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496916157", "body": "the Key should include the path or atleast the package (namespace)? what if there are two schemas with the same name in a module?\r\nAlso add a unit test for this case", "bodyText": "the Key should include the path or atleast the package (namespace)? what if there are two schemas with the same name in a module?\nAlso add a unit test for this case", "bodyHTML": "<p dir=\"auto\">the Key should include the path or atleast the package (namespace)? what if there are two schemas with the same name in a module?<br>\nAlso add a unit test for this case</p>", "author": "karthikbalasub", "createdAt": "2020-09-29T17:30:19Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.DefaultDataSchemaResolver;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static final String PDL = \".pdl\";\n+\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_report\")\n+        .withLongOpt(\"report\")\n+        .hasArg()\n+        .withDescription(\"Write the compatibility report into the provided file at the end of the execution.\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length != 2)\n+    {\n+      _logger.error(\"Invalid arguments!\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String prevSnapshotDir = cliArgs[0];\n+    String currSnapshotDir = cliArgs[1];\n+\n+    List<String> prevSnapshotAndCurrSnapshotPairs = getMatchingPrevAndCurrSnapshotPairs(prevSnapshotDir, currSnapshotDir);\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel: \" + cl.getOptionValue(\"cl\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode: \" + cl.getOptionValue(\"cm\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < prevSnapshotAndCurrSnapshotPairs.size(); i += 2)\n+    {\n+      String prevSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i-1);\n+      String currentSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i);\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatMode);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      File reportFile = new File(cl.getOptionValue(\"report\"));\n+      String compatibilityReport = new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport();\n+      Files.write(reportFile.toPath(), compatibilityReport.getBytes(StandardCharsets.UTF_8));\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isModelCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityOptions.Mode compatMode)\n+  {\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      newSchemaCreated = true;\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return _infoMap;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+\n+    return _infoMap;\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    PdlSchemaParser parser = new PdlSchemaParser(new DefaultDataSchemaResolver());\n+    parser.parse(new FileInputStream(schemaFile));\n+    if (parser.hasError())\n+    {\n+      throw new RuntimeException(parser.errorMessage() + \" Error while parsing file: \" + schemaFile.toString());\n+    }\n+\n+    List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+    if (topLevelDataSchemas.size() != 1)\n+    {\n+      throw new RuntimeException(\"Could not parse schema : \" + schemaFile.getAbsolutePath() + \" The size of top level schemas is not 1.\");\n+    }\n+    DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+    if (!(topLevelDataSchema instanceof NamedDataSchema))\n+    {\n+      throw new RuntimeException(\"Invalid schema : \" + schemaFile.getAbsolutePath() + \", the schema is not a named schema.\");\n+    }\n+    return topLevelDataSchema;\n+  }\n+\n+  private static String listCompatLevelOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityLevel.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static String listCompatModeOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityOptions.Mode.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static void help()\n+  {\n+    final HelpFormatter formatter = new HelpFormatter();\n+    formatter.printHelp(120,\n+        PegasusSchemaSnapshotCompatibilityChecker.class.getSimpleName(),\n+        \"[compatibility_level], [compatibilityOption_mode], [report], [prevSnapshotDir], [currSnapshotDir]\",\n+        _options,\n+        \"\",\n+        true);\n+  }\n+\n+  /**\n+   * Generate a file pair list, the same snapshot names of prevSnapshot and currSnapshot will be grouped together.\n+   *\n+   * @param prevSnapshotDir\n+   * @param currSnapshotDir\n+   * @return filePairList List<String>\n+   */\n+  private static List<String> getMatchingPrevAndCurrSnapshotPairs(String prevSnapshotDir, String currSnapshotDir)\n+  {\n+    Map<String, String> prevFilesMap = createMapFromFiles(prevSnapshotDir);\n+    Map<String, String> currFilesMap = createMapFromFiles(currSnapshotDir);\n+    List<String> filePairs = new ArrayList<>();\n+\n+    currFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      if (currFilesMap.containsKey(filename))\n+      {\n+        filePairs.add(prevFilesMap.get(filename));\n+        filePairs.add(absolutePath);\n+        prevFilesMap.remove(filename);\n+      }\n+      else\n+      {\n+        filePairs.add(\"\");\n+        filePairs.add(absolutePath);\n+      }\n+    });\n+\n+    prevFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      filePairs.add(absolutePath);\n+      filePairs.add(\"\");\n+    });\n+\n+    return filePairs;\n+  }\n+\n+  /**\n+   * Create a map for all the files under snapshot directory.\n+   * The key is the file name, the value is the absolutePath of the file\n+   * @param snapshotFileDir\n+   * @return filesMap Map<String, String>\n+   */\n+  private static Map<String, String> createMapFromFiles(String snapshotFileDir)\n+  {\n+    try (Stream<Path> paths = Files.walk(Paths.get(snapshotFileDir)))\n+    {\n+      return paths\n+          .filter(path -> path.toString().endsWith(PDL))\n+          .map(path -> path.toFile())\n+          .collect(Collectors.toMap(File::getName, File:: getAbsolutePath, (first, second) -> first));", "originalCommit": "7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3NTA2Mg==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496975062", "bodyText": "We use FQN as pdl snapshot file name, which includes the namespace.\nI will add unit tests.", "author": "nickibi", "createdAt": "2020-09-29T19:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNjE1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "03c0e0e7db8db22d16618c58e117bafbbfa111b8", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 8e641866d..319714916 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -326,7 +326,7 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n    * @param snapshotFileDir\n    * @return filesMap Map<String, String>\n    */\n-  private static Map<String, String> createMapFromFiles(String snapshotFileDir)\n+  static Map<String, String> createMapFromFiles(String snapshotFileDir)\n   {\n     try (Stream<Path> paths = Files.walk(Paths.get(snapshotFileDir)))\n     {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 8e641866d..5964f3464 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -326,7 +329,7 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n    * @param snapshotFileDir\n    * @return filesMap Map<String, String>\n    */\n-  private static Map<String, String> createMapFromFiles(String snapshotFileDir)\n+  static Map<String, String> createMapFromFiles(String snapshotFileDir)\n   {\n     try (Stream<Path> paths = Files.walk(Paths.get(snapshotFileDir)))\n     {\n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}, {"oid": "d13138ec6ae83fb805cc599ff396a33fa28cb031", "committedDate": "2020-10-19 20:07:58 -0700", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check (#445)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNzA1Nw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496927057", "body": "should be prevFilesMap\r\nIs there a unit test to handle this case?", "bodyText": "should be prevFilesMap\nIs there a unit test to handle this case?", "bodyHTML": "<p dir=\"auto\">should be prevFilesMap<br>\nIs there a unit test to handle this case?</p>", "author": "karthikbalasub", "createdAt": "2020-09-29T17:48:09Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.DefaultDataSchemaResolver;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static final String PDL = \".pdl\";\n+\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_report\")\n+        .withLongOpt(\"report\")\n+        .hasArg()\n+        .withDescription(\"Write the compatibility report into the provided file at the end of the execution.\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length != 2)\n+    {\n+      _logger.error(\"Invalid arguments!\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String prevSnapshotDir = cliArgs[0];\n+    String currSnapshotDir = cliArgs[1];\n+\n+    List<String> prevSnapshotAndCurrSnapshotPairs = getMatchingPrevAndCurrSnapshotPairs(prevSnapshotDir, currSnapshotDir);\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel: \" + cl.getOptionValue(\"cl\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode: \" + cl.getOptionValue(\"cm\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < prevSnapshotAndCurrSnapshotPairs.size(); i += 2)\n+    {\n+      String prevSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i-1);\n+      String currentSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i);\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatMode);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      File reportFile = new File(cl.getOptionValue(\"report\"));\n+      String compatibilityReport = new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport();\n+      Files.write(reportFile.toPath(), compatibilityReport.getBytes(StandardCharsets.UTF_8));\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isModelCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityOptions.Mode compatMode)\n+  {\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      newSchemaCreated = true;\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return _infoMap;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+\n+    return _infoMap;\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    PdlSchemaParser parser = new PdlSchemaParser(new DefaultDataSchemaResolver());\n+    parser.parse(new FileInputStream(schemaFile));\n+    if (parser.hasError())\n+    {\n+      throw new RuntimeException(parser.errorMessage() + \" Error while parsing file: \" + schemaFile.toString());\n+    }\n+\n+    List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+    if (topLevelDataSchemas.size() != 1)\n+    {\n+      throw new RuntimeException(\"Could not parse schema : \" + schemaFile.getAbsolutePath() + \" The size of top level schemas is not 1.\");\n+    }\n+    DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+    if (!(topLevelDataSchema instanceof NamedDataSchema))\n+    {\n+      throw new RuntimeException(\"Invalid schema : \" + schemaFile.getAbsolutePath() + \", the schema is not a named schema.\");\n+    }\n+    return topLevelDataSchema;\n+  }\n+\n+  private static String listCompatLevelOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityLevel.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static String listCompatModeOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityOptions.Mode.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static void help()\n+  {\n+    final HelpFormatter formatter = new HelpFormatter();\n+    formatter.printHelp(120,\n+        PegasusSchemaSnapshotCompatibilityChecker.class.getSimpleName(),\n+        \"[compatibility_level], [compatibilityOption_mode], [report], [prevSnapshotDir], [currSnapshotDir]\",\n+        _options,\n+        \"\",\n+        true);\n+  }\n+\n+  /**\n+   * Generate a file pair list, the same snapshot names of prevSnapshot and currSnapshot will be grouped together.\n+   *\n+   * @param prevSnapshotDir\n+   * @param currSnapshotDir\n+   * @return filePairList List<String>\n+   */\n+  private static List<String> getMatchingPrevAndCurrSnapshotPairs(String prevSnapshotDir, String currSnapshotDir)\n+  {\n+    Map<String, String> prevFilesMap = createMapFromFiles(prevSnapshotDir);\n+    Map<String, String> currFilesMap = createMapFromFiles(currSnapshotDir);\n+    List<String> filePairs = new ArrayList<>();\n+\n+    currFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      if (currFilesMap.containsKey(filename))", "originalCommit": "7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk2NDQ5OQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496964499", "bodyText": "Oops, it should be prevFilesMap.\nI would make this method as package private for adding unit test.", "author": "nickibi", "createdAt": "2020-09-29T18:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNzA1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "03c0e0e7db8db22d16618c58e117bafbbfa111b8", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 8e641866d..319714916 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -290,7 +290,7 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n    * @param currSnapshotDir\n    * @return filePairList List<String>\n    */\n-  private static List<String> getMatchingPrevAndCurrSnapshotPairs(String prevSnapshotDir, String currSnapshotDir)\n+  static List<String> getMatchingPrevAndCurrSnapshotPairs(String prevSnapshotDir, String currSnapshotDir)\n   {\n     Map<String, String> prevFilesMap = createMapFromFiles(prevSnapshotDir);\n     Map<String, String> currFilesMap = createMapFromFiles(currSnapshotDir);\n", "next_change": null}, {"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 8e641866d..319714916 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -298,7 +298,7 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n \n     currFilesMap.forEach((filename, absolutePath) ->\n     {\n-      if (currFilesMap.containsKey(filename))\n+      if (prevFilesMap.containsKey(filename))\n       {\n         filePairs.add(prevFilesMap.get(filename));\n         filePairs.add(absolutePath);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "changed_code": [{"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 8e641866d..5964f3464 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -290,7 +293,7 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n    * @param currSnapshotDir\n    * @return filePairList List<String>\n    */\n-  private static List<String> getMatchingPrevAndCurrSnapshotPairs(String prevSnapshotDir, String currSnapshotDir)\n+  static List<String> getMatchingPrevAndCurrSnapshotPairs(String prevSnapshotDir, String currSnapshotDir)\n   {\n     Map<String, String> prevFilesMap = createMapFromFiles(prevSnapshotDir);\n     Map<String, String> currFilesMap = createMapFromFiles(currSnapshotDir);\n", "next_change": null}, {"header": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\nindex 8e641866d..5964f3464 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java\n", "chunk": "@@ -298,7 +301,7 @@ public class PegasusSchemaSnapshotCompatibilityChecker\n \n     currFilesMap.forEach((filename, absolutePath) ->\n     {\n-      if (currFilesMap.containsKey(filename))\n+      if (prevFilesMap.containsKey(filename))\n       {\n         filePairs.add(prevFilesMap.get(filename));\n         filePairs.add(absolutePath);\n", "next_change": null}]}, "commits_in_main": [{"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2", "message": "Merge commit", "committedDate": null}, {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08", "committedDate": "2020-10-12 13:29:59 -0700", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided. (#435)"}, {"oid": "d13138ec6ae83fb805cc599ff396a33fa28cb031", "committedDate": "2020-10-19 20:07:58 -0700", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check (#445)"}]}, {"oid": "03c0e0e7db8db22d16618c58e117bafbbfa111b8", "url": "https://github.com/linkedin/rest.li/commit/03c0e0e7db8db22d16618c58e117bafbbfa111b8", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\".", "committedDate": "2020-09-29T23:38:34Z", "type": "forcePushed"}, {"oid": "64e32c96a570d57853c8759bd7647904d05f8157", "url": "https://github.com/linkedin/rest.li/commit/64e32c96a570d57853c8759bd7647904d05f8157", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\".", "committedDate": "2020-09-30T00:03:18Z", "type": "forcePushed"}, {"oid": "205b990c053a124cce887f07cf7916434a805221", "url": "https://github.com/linkedin/rest.li/commit/205b990c053a124cce887f07cf7916434a805221", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\".", "committedDate": "2020-09-30T15:09:38Z", "type": "forcePushed"}, {"oid": "107af4472c44c1da1e2c6fe53f46519b7cec81f1", "url": "https://github.com/linkedin/rest.li/commit/107af4472c44c1da1e2c6fe53f46519b7cec81f1", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\".", "committedDate": "2020-09-30T15:18:15Z", "type": "forcePushed"}, {"oid": "dc6d58cf211e56744382ca4e759f7ccb65401dc1", "url": "https://github.com/linkedin/rest.li/commit/dc6d58cf211e56744382ca4e759f7ccb65401dc1", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\".", "committedDate": "2020-09-30T15:20:52Z", "type": "commit"}, {"oid": "dc6d58cf211e56744382ca4e759f7ccb65401dc1", "url": "https://github.com/linkedin/rest.li/commit/dc6d58cf211e56744382ca4e759f7ccb65401dc1", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\".", "committedDate": "2020-09-30T15:20:52Z", "type": "forcePushed"}]}